atus_t ScConvertNTSC422toCIF411_C(u_char *framein,
                         u_char *yp, u_char *up, u_char *vp,
                         int stride);
/*
** sc_convert2.s
*/
extern void ScConvert422iTo422sf_S(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V, 
                                  long width, long height);
extern int ScSepYUVto422i_S(u_char *Y, u_char *U,
                          u_char *V, u_char *ImageOut,
                          u_int width, u_int height);
extern ScStatus_t ScConvert422ToYUV_char_S(u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern void ScConvert422PlanarTo422i_S(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *ImageOut,
				     long width, long height );


/*
** sc_convert_yuv.c
*/

extern int ScInitYUVcvt();
extern int ScInitYUVtoRGB(void **pColpack,
			  BITMAPINFOHEADER *lpbiIn,
			  BITMAPINFOHEADER *lpbiOut);
extern int sc_SIFrenderYUVtoRGBnn(u_char *pY, u_char *pU, u_char *pV,
				  u_char *Oimage,
				  void *Colpack,
				  int pixels, int lines);
extern void YUV_To_RGB_422_Init(int bSign, int bBGR, _int64 * pTable);


#ifdef USE_C
#define ScConvert422ToYUV_char   ScConvert422ToYUV_char_C
#define ScConvert422PlanarTo422i ScConvert422PlanarTo422i_C
#define ScConvert411sTo422i      ScConvert411sTo422i_C
#define ScConvert411sTo422s      ScConvert411sTo422s_C
#define ScSepYUVto422i           ScSepYUVto422i_C
#define ScConvert422PlanarTo411  ScConvert422PlanarTo411_C
#define ScConvertNTSC422toCIF411 ScConvertNTSC422toCIF411_C
#define ScConvert422iTo422s      ScConvert422iTo422s_C
#define ScConvert422iTo422sf     ScConvert422iTo422sf_C
#define ScConvert1611sTo411s     ScConvert1611sTo411s_C
#define ScConvert411sTo1611s     ScConvert411sTo1611s_C
#define ScConvert1611sTo422s     ScConvert1611sTo422s_C
#define ScConvert1611sTo422i     ScConvert1611sTo422i_C
#define ScConvertRGB24sTo422i    ScConvertRGB24sTo422i_C
#define ScConvertRGB24To411s     ScConvertRGB24To411s_C
#define ScConvertRGB555To411s    ScConvertRGB555To411s_C
#define ScConvertRGB565To411s    ScConvertRGB565To411s_C
#else /* USE_C */
#define ScConvert422ToYUV_char   ScConvert422ToYUV_char_S
#define ScConvert422PlanarTo422i ScConvert422PlanarTo422i_S
#define ScConvert411sTo422i      ScConvert411sTo422i_C
#define ScConvert411sTo422s      ScConvert411sTo422s_C
#define ScSepYUVto422i           ScSepYUVto422i_S
#define ScConvert422PlanarTo411  ScConvert422PlanarTo411_C
#define ScConvertNTSC422toCIF411 ScConvertNTSC422toCIF411_C
#define ScConvert422iTo422s      ScConvert422iTo422s_C
#define ScConvert422iTo422sf     ScConvert422iTo422sf_S
#define ScConvert1611sTo411s     ScConvert1611sTo411s_C
#define ScConvert411sTo1611s     ScConvert411sTo1611s_C
#define ScConvert1611sTo422s     ScConvert1611sTo422s_C
#define ScConvert1611sTo422i     ScConvert1611sTo422i_C
#define ScConvertRGB24sTo422i    ScConvertRGB24sTo422i_C
#define ScConvertRGB24To411s     ScConvertRGB24To411s_C
#define ScConvertRGB555To411s    ScConvertRGB555To411s_C
#define ScConvertRGB565To411s    ScConvertRGB565To411s_C
#endif /* USE_C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_err.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_errors.c,v $
 * Revision 1.1.7.2  1996/12/03  00:08:25  Hans_Graves
 * 	Added SvErrorEndOfSequence error.
 * 	[1996/12/03  00:07:32  Hans_Graves]
 *
 * Revision 1.1.5.2  1996/01/02  18:30:45  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:01  Bjorn_Engberg]
 * 
 * Revision 1.1.2.6  1995/08/04  16:32:23  Karen_Dintino
 * 	Add new errors for H.261
 * 	[1995/08/04  16:25:15  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/07/26  17:48:53  Hans_Graves
 * 	Added errors: NoCompressBuffer and ClientEnd
 * 	[1995/07/26  17:46:13  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/11  22:11:26  Karen_Dintino
 * 	Add new H.261 Error Codes
 * 	[1995/07/11  21:56:35  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/07/11  14:50:37  Hans_Graves
 * 	Added ScErrorNet* errors
 * 	[1995/07/11  14:24:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:44  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:11:22  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:13:40  Hans_Graves
 * 	First time under SLIB
 * 	[1995/05/03  19:12:02  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  18:28:50  Hans_Graves
 * 	Redesigned error handling (taken from sv_printerrors.c)
 * 	     to handle multiple libraries (Sg, Su, Sv, Sa, Sr)
 * 	[1995/04/07  18:28:06  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include <stdio.h>
#include <string.h>
#include "SC.h"
#include "SC_err.h"

char _serr_msg[80];

typedef struct ErrorDesc_s {
  int   code;
  char *name;
  char *text;
} ErrorDesc_t;

/*
** ErrorDesc is a table of all errors that need to be translated into
** text messages.  Order doesn't matter, except that if there are two
** error numbers which are of the same value, the first one will be
** returned.
** Note: Any %s contained in the message text will be filled by the
**       string assigned to _serr_msg
*/
static ErrorDesc_t ErrorDesc[] =
{
  NoErrors, 		"",
			"",
/******************** Sc (Common) **************************/
  ScErrorNone, 		"",
			"",
  ScErrorForeign,	"ScErrorForeign",
			"%s",
  ScErrorMemory,	"ScErrorMemory",
			"memory request denied",
  ScErrorBadPointer,	"ScErrorBadPointer",
			"Invalid pointer passed to function",
  ScErrorNullStruct, 	"ScErrorNullStruct",
			"Parameter set structure is required",
  ScErrorFile, 		"ScErrorFile",
                        "file",
  ScErrorEOI, 		"ScErrorEOI",
			"End of Input reached",
  ScErrorBadArgument, 	"ScErrorBadArgument",
			"Invalid argument to function",
  ScErrorSmallBuffer, 	"ScErrorSmallBuffer",
			"Buffer too small",
  ScErrorUnrecognizedFormat, "ScErrorUnrecognizedFormat",
			"Unrecognized format",
  ScErrorEndBitstream,	"ScErrorEndBitstream",
			"End of data bitstream reached",
  ScErrorBadQueueEmpty,	"ScErrorBadQueueEmpty",
			"Buffer queue is empty",
  ScErrorClientEnd,     "ScErrorClientEnd",
                        "Client ended processing",
  ScErrorNetConnectIn,  "ScErrorNetConnectIn",
			"No network connection made for input.",
  ScErrorNetConnectOut, "ScErrorNetConnectOut",
			"No network connection made for output.",
  ScErrorNetProtocol,   "ScErrorNetProtocol",
			"Unsupported network protocol.",
  ScErrorNetSend,       "ScErrorNetSend",
			"Network error sending data.",
  ScErrorNetReceive,    "ScErrorNetReceive",
			"Network error receiving data.",
  ScErrorNetBadHeader,  "ScErrorNetBadHeader",
			"Bad network data header received.",
  ScErrorNetBadTrailer, "ScErrorNetBadTrailer",
			"Bad network data trailor received.",
  ScErrorNetChecksum,   "ScErrorNetChecksum",
			"Checksum error on data received over network.",
/******************** Sv (Video) ****************************/
  SvErrorForeign,	"SvErrorForeign",
			"%s",
  SvErrorMemory,	"SvErrorMemory",
			"memory request denied",
  SvErrorBadPointer,	"SvErrorBadPointer",
			"Invalid pointer passed to function",
  SvErrorFile,		"SvErrorFile",
			"Not a JPEG file",
  SvErrorEOI,		"SvErrorEOI",
			"Empty JPEG file",
  SvErrorBadArgument,	"SvErrorBadArgument",
			"Invalid argument to function",
  SvErrorSmallBuffer,	"SvErrorSmallBuffer",
			"Buffer too small",
  SvErrorEndBitstream,	"SvErrorEndBitstream",
			"End of data bitstream reached",
  SvErrorCodecType,	"SvErrorCodecType",
			"Codec type not recognized",
  SvErrorCodecHandle,	"SvErrorCodecHandle",
			"Invalid Codec handle",
  SvErrorNullCodec,	"SvErrorNullCodec",
			"Codec argument may not be NULL",
  SvErrorNullToken,	"SvErrorNullToken",
			"Registration token  may not be NULL",
  SvErrorSyncLost,	"SvErrorSyncLost",
			"Syncronization lost in data bitstream",
  SvErrorLevels,	"SvErrorLevels",
			"levels - must be between 2 and 256",
  SvErrorOrder,		"SvErrorOrder",
			"order - must be between 0 and 6",
  SvErrorLevNoneg,	"SvErrorLevNoneg",
			"%s - Must be nonnegative",
  SvErrorLev1K,		"SvErrorLev1K",	
			"%s - Must be between -1000 and 1000",
  SvErrorLevGt0,	"SvErrorLevGt0",
			"%s - Must be greater than zero",
  SvErrorYuvOnly,	"SvErrorYuvOnly",
			"operation supported for YUV images only",
  SvErrorDevOpen,	"SvErrorDevOpen",
			"unable to open device %s",
  SvErrorDevMap,	"SvErrorDevMap",
			"unable to map device registers",
  SvErrorStatQueMap,	"SvErrorStatQueMap",
			"unable to map status queue",
  SvErrorDevLock,	"SvErrorDevLock",
			"unable to Lock %s bytes of memory",
  SvErrorDevUlock,	"SvErrorDevUlock",
			"unable to unLock memory %s",
  SvErrorCache,		"SvErrorCache",	
			"could not make the pages NONCACHEABLE",
  SvErrorPageAll,	"SvErrorPageAll",
			"memory has to be page alligned, need integral # of pages",
  SvErrorTimeOut,	"SvErrorTimeOut",
			"time out on following operation(s): %s",
  SvErrorSelect,	"SvErrorSelect",
			"select failure during following operation(s): %s",
  SvErrorMapOvrfl,	"SvErrorMapOvrfl",
			"DMA scatter/gather map overflow",
  SvErrorIIC,		"SvErrorIIC",
			"IIC Bus error",
  SvErrorCompPtrs,	"SvErrorCompPtrs",
			"storage for compression flushing and/or byte count missing",
  SvErrorVideoInput,	"SvErrorVideoInput",
			"no video input",
  SvErrorPhase,		"SvErrorPhase",
			"Invalid Phase",
  SvErrorCmdQueMap,	"SvErrorCmdQueMap",
			"CmdQueue Map",
  SvErrorTmpQueMap,	"SvErrorTmpQueMap",
			"TmpQueue Map",
  SvErrorStart,		"SvErrorStart",
			"couldn't start the application",
  SvErrorStop,		"SvErrorStop",
			"couldn't stop the application",
  SvErrorWaitMix,	"SvErrorWaitMix",
			"non-blocking operations still pending",
  SvErrorClose,		"SvErrorClose",
			"Error closing device",
  SvErrorCmdQFull,	"SvErrorCmdQFull",
			"JLib internal error -- CmdQueue full",
  SvErrorPictureOp,	"SvErrorPictureOp",
			"Picture operation failed",
  SvErrorRefToken,	"SvErrorRefToken",
			"Reference token required on edit",
  SvErrorEditChange,	"SvErrorEditChange",
			"No change specified for edit",
  SvErrorCompROI,	"SvErrorCompROI",
			"SvError compression ROI",
  SvErrorBufOverlap,	"SvErrorBufOverlap",
			"Buffer overlaps previously registered buffer",
  SvErrorReqQueueFull,	"SvErrorReqQueueFull",
			"JLib internal error -- RequestQueue is full",
  SvErrorCompBufOverflow,"SvErrorCompBufOverflow",
			"Compression buffer overflow",
  SvErrorFunctionInputs,"SvErrorFunctionInputs",
			"Illegal library function inputs",
  SvErrorIICAck,	"SvErrorIICAck",
			"Missing acknowledge on video IIC bus",
  SvErrorCompressedData,"SvErrorCompressedData",
			"Cannot find end of compressed data",
  SvErrorDecompPreload,	"SvErrorDecompPreload",
			"Compressed data preload failed",
  SvErrorHuffCode,	"SvErrorHuffCode",
			"huffman code in compressed data",
  SvErrorOutOfData,	"SvErrorOutOfData",
			"Compressed data exhausted",
  SvErrorMarkerFound,	"SvErrorMarkerFound",
			"marker found in compressed data",
  SvErrorSgMapsExhausted,"SvErrorSgMapsExhausted",
			"No more DMA Map pages available",
  SvErrorSgMapInit,	"SvErrorSgMapInit",
			"Failure initializing DMA Map Pool",
  SvErrorSgMapAlreadyFree,"SvErrorSgMapAlreadyFree",
			"Freeing a DMA Map that is already free",
  SvErrorSgMapId,	"SvErrorSgMapId",
			"Invalid DMA Map Id",
  SvErrorNumBytes,	"SvErrorNumBytes",
			"Location for number of compressed bytes is required",
  SvErrorDevName,	"SvErrorDevName",
			"%s is not a valid JV2 device",
  SvErrorDevName,	"SvErrorNullStruct",
			"Parameter set structure is required",
  SvErrorAnalogPortTiming,"SvErrorAnalogPortTiming",
			"Analog port settings differ from pending settings: Use blocking call",
  SvErrorFrameMode,	"SvErrorFrameMode",
			"Frame mode not supported with PAL or SECAM video",
  SvErrorSampFactors,	"SvErrorSampFactors",
			"Invalid sampling factor",
  SvErrorNumComponents,	"SvErrorNumComponents",
			"Too many components for interleaved scan",
  SvErrorDHTTable,	"SvErrorDHTTable",
			"Invalid Huffman table",
  SvErrorQuantTable,	"SvErrorQuantTable",
			"Invalid quantization table",
  SvErrorRestartInterval,"SvErrorRestartInterval",
			"Invalid restart interval",
  SvErrorJfifRev,	"SvErrorJfifRev",
			"Unsupported JFIF version",
  SvErrorEmptyJPEG,	"SvErrorEmptyJPEG",
			"Empty JPEG image (DNL not supported)",
  SvErrorJPEGPrecision,	"SvErrorJPEGPrecision",
			"Unsupported JPEG data precision",
  SvErrorSOFLength,	"SvErrorSOFLength",
			"Invalid SOF length",
  SvErrorSOSLength,	"SvErrorSOSLength",
			"Invalid SOS length",
  SvErrorSOSCompNum,	"SvErrorSOSCompNum",
			"Invalid SOS number of components",
  SvErrorMarker,	"SvErrorMarker",
			"Unexpected Marker",
  SvErrorSOFType,	"SvErrorSOFType",
			"Unsupported SOF marker type",
  SvErrorFrameNum,	"SvErrorFrameNum",
			"frame number",
  SvErrorHuffUndefined,	"SvErrorHuffUndefined",
			"Huffman tables not initialized",
  SvErrorJPEGData,	"SvErrorJPEGData",
			"Corrupt JPEG data",
  SvErrorQMismatch,	"SvErrorQMismatch",
			"Request/status queue mismatch",
  SvErrorEmptyFlush,	"SvErrorEmptyFlush",
			"Driver's temp (flush) queue is empty",
  SvErrorDmaChan,	"SvErrorDmaChan",
			"invalid DMA channel",
  SvErrorFuture,	"SvErrorFuture",
			"future",
  SvErrorWrongev,	"SvErrorWrongev",
			"wrong ev",
  SvErrorUnknev,	"SvErrorUnknev",
			"unknown ev",
  SvErrorQueueExecuting,"SvErrorQueueExecuting",
			"JLib internal error -- Can't download with running queue",
  SvErrorReturnAddr,	"SvErrorReturnAddr",
			"JLib internal error -- Missing return address",
  SvErrorObjClass,	"SvErrorObjClass",
			"JLib internal error -- SvError object class",
  SvErrorRegAnchor,	"SvErrorRegAnchor",
			"JLib internal error -- No registration object anchor",
  SvErrorTimerRead,	"SvErrorTimerRead",
			"reading timer",
  SvErrorDriverFatal,	"SvErrorDriverFatal",
			"Fatal driver error",
  SvErrorChromaSubsample,"SvErrorChromaSubsample",
			"Chroma subsample must be Mono, 4:2:2 or 4:2:0",
  SvErrorReadBufSize,	"SvErrorReadBufSize",
			"Compressed data buffer too small",
  SvErrorQuality,	"SvErrorQuality",
			"Invalid Quality value. Range = 0 to 10,000",
  SvErrorUnrecognizedFormat,"SvErrorUnrecognizedFormat",
			"Unrecognized image format",
  SvErrorIllegalMType,    "SvErrorIllegalMType",
                        "Illegal Macroblock type",
  SvErrorBadImageSize,	"SvErrorBadImageSize",
			"Invalid image size",
  SvErrorValue,		"SvErrorValue",
			"Invalid parameter value",
  SvErrorDcmpNotStarted,"SvErrorDcmpNotStarted",
			"Codec not setup. Call SvDecompressBegin",
  SvErrorNotImplemented,"SvErrorNotImplemented",
			"Not implemented yet",
  SvErrorNoSOIMarker,	"SvErrorNoSOIMarker",
			"Invalid JPEG data",
  SvErrorProcessingAborted,"SvErrorProcessingAborted",
			"Processing Aborted by callback",
  SvErrorCompNotStarted,"SvErrorCompNotStarted",
			"Codec not setup. Call SvCompressBegin",
  SvErrorNotAligned,	"SvErrorNotAligned",
			"Memory pointer not 64-bit aligned",
  SvErrorBadQueueEmpty,	"SvErrorBadQueueEmpty",
			"Buffer queue is empty",
  SvErrorCannotDecompress,"SvErrorCannotDecompress",
			"Picture cannot be decompressed",
  SvErrorMultiBufChanged,"SvErrorMultiBufChanged",
			"Multibuffer address has changed",
  SvErrorNotDecompressable,"SvErrorNotDecompressable",
			"Picture not decompressable",
  SvErrorIndexEmpty,	"SvErrorIndexEmpty",
			"Requested frame not in index",
  SvErrorExpectedEOB,   "SvErrorExpectedEOB",
			"Expected End Of Block",
  SvErrorNoCompressBuffer, "SvErrorNoCompressBuffer",
			"No more compressed buffers available",
  SvErrorNoImageBuffer, "SvErrorNoImageBuffer",
			"No more image buffers available",
  SvErrorCBPWrite, "SvErrorCBPWrite",
			"CBP Write Error",
  SvErrorEncodingMV, "SvErrorEncodingMV",
                        "Cannot encode Motion Vectors",
  SvErrorEmptyHuff, "SvErrorEmptyHuff",
                        "Attempting to write an empty huffman code",
  SvErrorIllegalGBSC, "SvErrorIllegalGBSC",
                        "Illegal GOB Start Code",
  SvErrorEndOfSequence, "SvEndOfSequence",
                        "End Of Sequence",
/******************** Sa (Audio) ****************************/
  SaErrorNullCodec,	"SaErrorNullCodec",
			"Codec argument may not be NULL",
  SaErrorSyncLost,	"SaErrorSyncLost",
			"Syncronization lost in data bitstream",
  SaErrorMPEGLayer,     "SaErrorMPEGLayer",
			"Bad MPEG Layer %s",
  SaErrorMPEGModeExt,   "SaErrorMPEGModeExt",
			"Bad MPEG Mode Extension %s",
  SaErrorNoCompressBuffer, "SaErrorNoCompressBuffer",
			"No more compressed buffers available",
  SaErrorNoAudioBuffer, "SaErrorNoAudioBuffer",
			"No more audio buffers available",
/******************** Sr (Render) ****************************/
  SrErrorRenderType,	"SrErrorRenderType",
			"Render type not recognized",
  SrErrorRenderHandle,	"SrErrorRenderHandle",
			"Invalid Render handle",
  SrErrorRenderNotStarted,"SrErrorRenderNotStarted",
			"Renderer not setup. Call SvRenderBegin",
  SrErrorDitherNOL,	"SrErrorDitherNOL",
			"Invalid NOL value - must be between 2 & 256",
  SrErrorDitherPhase,	"SrErrorDitherPhase",
			"Invalid PhaseX/Y value - must be >= 0",
  SrErrorDefSteepness,	"SrErrorDefSteepness",
			"Invalid Default Steepness -1000.0 to +1000.0",
  SrErrorSteepness,	"SrErrorSteepness",
			"Invalid Steepness -1000.0 to +1000.0",
  SrErrorDefYoffset,	"SrErrorDefYoffset",
			"Invalid Default Yoffset -100.0 to +100.0",
  SrErrorYoffset,	"SrErrorYoffset",
			"Invalid Yoffset -100.0 to +100.0",
  SrErrorDefXoffset,	"SrErrorDefXoffset",
			"Invalid Default Xoffset -100.0 to +100.0",
  SrErrorXoffset,	"SrErrorXoffset",
			"Invalid Xoffset -100.0 to +100.0",
  SrErrorNumColors,	"SrErrorNumColors",
			"Not enough colors available for dithering",
  SrErrorBadNumColors,	"SrErrorBadNumColors",
			"Invalid Number of colors. Range = 2 to 256",
  SrErrorColorSpace,	"SrErrorColorSpace",
			"unsupported color space",
  SrErrorBadImageSize,	"SrErrorBadImageSize",
			"Invalid image size",
  SrErrorValue,		"SrErrorValue",
			"Invalid parameter value",
  0,			NULL, NULL
};


ScStatus_t ScGetErrorText (int errno, char *ReturnMsg, u_int MaxChars)
{
  int status;
  char msg[255], *pmsg;
  ErrorDesc_t *perr=ErrorDesc;

  msg[0]=0;
  pmsg=msg;
  while (perr->name!=NULL && perr->code!=errno)
    perr++;
  if (perr->name!=NULL) /* matching message found */
  {
    if (perr->name[0])
    {
      sprintf(msg,"(%s) ",perr->name);
      pmsg+=strlen(pmsg);
    }
    if (perr->text[0])
    {
      sprintf (pmsg, perr->text, _serr_msg);
      pmsg+=strlen(pmsg);
    }
    if (*msg) /* put newline if there was a message */
    {
      *pmsg++='\n';
      *pmsg=0;
    }
    status=NoErrors;
  }
  else
  {
    sprintf (msg, "No text exists for error number %d\n", errno);
    status=ScErrorForeign;
  }
  if (*msg)
  {
    if (ReturnMsg == NULL)
    {
      switch(errno&0xF000)
      {
        case ERR_SC:
	  fprintf (stderr,"SLIB Error -- %s", msg);
          break;
#ifdef ERR_SV
        case ERR_SV:
	  fprintf (stderr,"SLIB Video Error -- %s", msg);
          break;
#endif
#ifdef ERR_SA
        case ERR_SA:
	  fprintf (stderr,"SLIB Audio Error -- %s", msg);
          break;
#endif
#ifdef ERR_SR
        case ERR_SR:
	  fprintf (stderr,"SLIB Render Error -- %s", msg);
          break;
#endif
        default:
	  fprintf (stderr,"Error -- %s", msg);
      }
    }
    else
    {
      strncpy (ReturnMsg, msg, MaxChars);
      ReturnMsg[MaxChars-1] = 0; /* Make sure string is NULL terminated */
    }
  }

  return (status);
}


char *ScGetErrorStr(int errno)
{
  static char errstr[255];
  errstr[0]=0;
  ScGetErrorText(errno, errstr, sizeof(errstr)-1);
  return(errstr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_err.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC_err.h,v $
 * Revision 1.1.4.2  1996/12/03  00:08:28  Hans_Graves
 * 	Added SvErrorEndOfSequence error.
 * 	[1996/12/03  00:07:34  Hans_Graves]
 *
 * Revision 1.1.2.7  1995/08/04  16:32:25  Karen_Dintino
 * 	New error codes for H.261
 * 	[1995/08/04  16:24:25  Karen_Dintino]
 * 
 * Revision 1.1.2.6  1995/07/26  17:48:54  Hans_Graves
 * 	Added ErrorClientEnd errors.
 * 	[1995/07/26  17:44:27  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/07/11  22:11:27  Karen_Dintino
 * 	Add new H.261 Error Codes
 * 	[1995/07/11  21:52:53  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/07/11  14:50:45  Hans_Graves
 * 	Added ScErrorNet* errors
 * 	[1995/07/11  14:24:18  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/22  21:35:04  Hans_Graves
 * 	Added ScErrorDevOpen and fixed some error numbers
 * 	[1995/06/22  21:31:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:28  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:25:17  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:26:59  Hans_Graves
 * 	Included in SLIB (Oct 95)
 * 	[1995/05/03  19:23:33  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:19:26  Hans_Graves
 * 	Expanded to include new libraries: Sg,Su,Sa,Sr
 * 	[1995/04/07  19:11:07  Hans_Graves]
 * 
 * $EndLog$
 */

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*----------------------------------------------------------------------------
 * Modification History: SC_err.h (previously SV_err.h)
 *
 * 05-Nov-1991  Victor Bahl & Bob Ulichney   creation date
 * 07-Oct-1994  Paul Gauthier                SLIB v3.0 incl. MPEG Decode
 * 09-Nov-1994  Paul Gauthier                Optimizations
 *--------------------------------------------------------------------------*/

#ifndef _SC_ERR_H_
#define _SC_ERR_H_
/* 	
** List of possible errors that can be returned from routines in any 
** of SLIB libraries.
*/

/******************** Error Offsets **********************************/
#define ERR_SC   0x0000  /* Common Error */
#define ERR_SV   0x1000  /* Video Error */
#define ERR_SA   0x2000  /* Audio Error */
#define ERR_SR   0x3000  /* Render Error */

#define	NoErrors                   0

/******************** Sc (common) Errors ****************************/
#define ScErrorNone                NoErrors
#define ScErrorForeign             (ERR_SC+1)
#define ScErrorMemory              (ERR_SC+2)
#define ScErrorBadPointer          (ERR_SC+3)
#define ScErrorNullStruct          (ERR_SC+4)
#define ScErrorFile                (ERR_SC+5)
#define ScErrorEOI                 (ERR_SC+6)
#define ScErrorBadArgument         (ERR_SC+7)
#define ScErrorSmallBuffer         (ERR_SC+8)
#define ScErrorUnrecognizedFormat  (ERR_SC+9)
#define ScErrorEndBitstream        (ERR_SC+10)
#define ScErrorMapFile             (ERR_SC+11)
#define ScErrorBadQueueEmpty       (ERR_SC+12)
#define ScErrorClientEnd           (ERR_SC+13)
#define ScErrorDevOpen             (ERR_SC+14)
#define ScErrorNetConnectIn        (ERR_SC+15)
#define ScErrorNetConnectOut       (ERR_SC+16)
#define ScErrorNetProtocol         (ERR_SC+17)
#define ScErrorNetSend             (ERR_SC+18)
#define ScErrorNetReceive          (ERR_SC+19)
#define ScErrorNetBadHeader        (ERR_SC+20)
#define ScErrorNetBadTrailer       (ERR_SC+21)
#define ScErrorNetChecksum         (ERR_SC+22)

/******************** Sv (video) Errors ****************************/
#ifdef ERR_SV
#define	SvErrorNone                NoErrors
#define SvErrorMemory              ScErrorMemory
#define SvErrorBadPointer          ScErrorBadPointer
#define SvErrorNullStruct          ScErrorNullStruct
#define SvErrorBadArgument         ScErrorBadArgument
#define SvErrorSmallBuffer         ScErrorSmallBuffer
#define SvErrorEndBitstream        ScErrorEndBitstream
#define SvErrorClientEnd           ScErrorClientEnd

#define SvErrorCodecType           (ERR_SV+2)
#define SvErrorCodecHandle         (ERR_SV+3)
#define SvErrorNullCodec           (ERR_SV+4)
#define SvErrorNullToken           (ERR_SV+5)
#define SvErrorSyncLost            (ERR_SV+6)
#define	SvErrorLevels	           (ERR_SV+7)
#define	SvErrorOrder	           (ERR_SV+8)
#define SvErrorLevNoneg            (ERR_SV+9)
#define SvErrorLev1K               (ERR_SV+10)
#define SvErrorLevGt0              (ERR_SV+11)
#define SvErrorYuvOnly             (ERR_SV+13)
#define SvErrorDevOpen             (ERR_SV+14)
#define SvErrorDevMap              (ERR_SV+15)
#define SvErrorStatQueMap          (ERR_SV+16)
#define SvErrorDevLock             (ERR_SV+17)
#define SvErrorDevUlock            (ERR_SV+18)
#define SvErrorCache               (ERR_SV+19)
#define SvErrorPageAll             (ERR_SV+20)
#define SvErrorTimeOut             (ERR_SV+21)
#define SvErrorSelect              (ERR_SV+22)
#define SvErrorMapOvrfl            (ERR_SV+23)
#define SvErrorForeign             (ERR_SV+24)
#define SvErrorIIC                 (ERR_SV+25)
#define SvErrorCompPtrs            (ERR_SV+26)
#define SvErrorVideoInput          (ERR_SV+27)
#define SvErrorPhase	           (ERR_SV+28)
#define SvErrorCmdQueMap	   (ERR_SV+29)
#define SvErrorTmpQueMap	   (ERR_SV+30)
#define SvErrorStart               (ERR_SV+31)
#define SvErrorStop                (ERR_SV+32)
#define SvErrorWaitMix             (ERR_SV+33)
#define SvErrorClose               (ERR_SV+34)
#define SvErrorCmdQFull            (ERR_SV+35)
#define SvErrorPictureOp           (ERR_SV+36)
#define SvErrorRefToken            (ERR_SV+37)
#define SvErrorEditChange          (ERR_SV+38)
#define SvErrorCompROI             (ERR_SV+39)
#define SvErrorBufOverlap          (ERR_SV+40)
#define SvErrorReqQueueFull        (ERR_SV+41)
#define SvErrorCompBufOverflow     (ERR_SV+42)
#define SvErrorFunctionInputs      (ERR_SV+43)
#define SvErrorIICAck              (ERR_SV+44)
#define SvErrorCompressedData      (ERR_SV+45)
#define SvErrorDecompPreload       (ERR_SV+46)
#define SvErrorHuffCode            (ERR_SV+47)
#define SvErrorOutOfData           (ERR_SV+48)
#define SvErrorMarkerFound         (ERR_SV+49)
#define SvErrorSgMapsExhausted     (ERR_SV+50)
#define SvErrorSgMapInit           (ERR_SV+51)
#define SvErrorSgMapAlreadyFree    (ERR_SV+52)
#define SvErrorSgMapId             (ERR_SV+53)
#define SvErrorNumBytes            (ERR_SV+54)
#define SvErrorDevName             (ERR_SV+55)
#define SvErrorAnalogPortTiming    (ERR_SV+56)
#define SvErrorFrameMode           (ERR_SV+57)
#define SvErrorSampFactors         (ERR_SV+58)
#define SvErrorNumComponents       (ERR_SV+59)
#define SvErrorDHTTable            (ERR_SV+60)
#define SvErrorQuantTable          (ERR_SV+61)
#define SvErrorRestartInterval     (ERR_SV+62)
#define SvErrorJfifRev             (ERR_SV+63)
#define SvErrorEmptyJPEG           (ERR_SV+64)
#define SvErrorJPEGPrecision       (ERR_SV+65)
#define SvErrorSOFLength           (ERR_SV+66)
#define SvErrorSOSLength           (ERR_SV+67)
#define SvErrorSOSCompNum          (ERR_SV+68)
#define SvErrorMarker              (ERR_SV+69)
#define SvErrorSOFType             (ERR_SV+70)
#define SvErrorFrameNum            (ERR_SV+71)
#define SvErrorHuffUndefined       (ERR_SV+72)
#define SvErrorJPEGData            (ERR_SV+73)
#define SvErrorQMismatch           (ERR_SV+74)
#define SvErrorEmptyFlush          (ERR_SV+75)
#define SvErrorDmaChan             (ERR_SV+76)
#define SvErrorFuture              (ERR_SV+77)
#define SvErrorWrongev             (ERR_SV+78)
#define SvErrorUnknev              (ERR_SV+79)
#define SvErrorQueueExecuting      (ERR_SV+80)
#define SvErrorReturnAddr          (ERR_SV+81)
#define SvErrorObjClass            (ERR_SV+82)
#define SvErrorRegAnchor           (ERR_SV+83)
#define SvErrorTimerRead           (ERR_SV+84)
#define SvErrorDriverFatal         (ERR_SV+85)
#define SvErrorChromaSubsample     (ERR_SV+86)
#define SvErrorReadBufSize         (ERR_SV+87)
#define SvErrorQuality             (ERR_SV+88)
#define SvErrorBadImageSize        (ERR_SV+89)
#define SvErrorValue               (ERR_SV+90)
#define SvErrorDcmpNotStarted      (ERR_SV+91)
#define SvErrorNotImplemented      (ERR_SV+92)
#define SvErrorNoSOIMarker         (ERR_SV+93)
#define SvErrorProcessingAborted   (ERR_SV+94)
#define SvErrorCompNotStarted      (ERR_SV+95)
#define SvErrorNotAligned          (ERR_SV+96)
#define SvErrorBadQueueEmpty       (ERR_SV+97)
#define SvErrorCannotDecompress    (ERR_SV+98)
#define SvErrorMultiBufChanged     (ERR_SV+99)
#define SvErrorNotDecompressable   (ERR_SV+100)
#define SvErrorIndexEmpty          (ERR_SV+101)
#define SvErrorFile                (ERR_SV+102)
#define SvErrorEOI                 (ERR_SV+103)
#define SvErrorUnrecognizedFormat  (ERR_SV+104)
#define SvErrorIllegalMType	   (ERR_SV+105)
#define SvErrorExpectedEOB         (ERR_SV+106)
#define SvErrorNoCompressBuffer    (ERR_SV+107)
#define SvErrorNoImageBuffer       (ERR_SV+108)
#define SvErrorCBPWrite		   (ERR_SV+109)
#define SvErrorEncodingMV          (ERR_SV+110)
#define SvErrorEmptyHuff           (ERR_SV+111)
#define SvErrorIllegalGBSC         (ERR_SV+112)
#define SvErrorEndOfSequence       (ERR_SV+113)



#endif ERR_SV


/******************** Sa (video) Errors ****************************/
#ifdef ERR_SA
#define	SaErrorNone                NoErrors
#define SaErrorMemory              ScErrorMemory
#define SaErrorBadPointer          ScErrorBadPointer
#define SaErrorUnrecognizedFormat  ScErrorUnrecognizedFormat
#define SaErrorNullStruct          ScErrorNullStruct
#define SaErrorFile                ScErrorFile
#define SaErrorEOI                 ScErrorEOI
#define SaErrorBadArgument         ScErrorBadArgument
#define SaErrorSmallBuffer         ScErrorSmallBuffer
#define SaErrorClientEnd           ScErrorClientEnd

#define SaErrorCodecType           (ERR_SA+1)
#define SaErrorCodecHandle         (ERR_SA+2)
#define SaErrorNullCodec           (ERR_SA+3)
#define SaErrorSyncLost            (ERR_SA+4)
#define SaErrorMPEGLayer           (ERR_SA+5)
#define SaErrorMPEGModeExt         (ERR_SA+6)
#define SaErrorNoCompressBuffer    (ERR_SA+7)
#define SaErrorNoAudioBuffer       (ERR_SA+8)
#endif ERR_SA

/******************** Sr (render) Errors ****************************/
#ifdef ERR_SR
#define	SrErrorNone                NoErrors
#define SrErrorMemory              ScErrorMemory
#define SrErrorBadPointer          ScErrorBadPointer
#define SrErrorUnrecognizedFormat  ScErrorUnrecognizedFormat
#define SrErrorNullStruct          ScErrorNullStruct
#define SrErrorFile                ScErrorFile
#define SrErrorEOI                 ScErrorEOI
#define SrErrorBadArgument         ScErrorBadArgument
#define SrErrorSmallBuffer         ScErrorSmallBuffer
#define SrErrorClientEnd           ScErrorClientEnd

#define SrErrorRenderType          (ERR_SR+1)
#define SrErrorRenderHandle        (ERR_SR+2)
#define SrErrorRenderNotStarted    (ERR_SR+3)
#define SrErrorDitherNOL           (ERR_SR+4)
#define SrErrorDitherPhase         (ERR_SR+5)
#define SrErrorDefSteepness        (ERR_SR+6)
#define SrErrorSteepness           (ERR_SR+7)
#define SrErrorDefYoffset          (ERR_SR+8)
#define SrErrorYoffset             (ERR_SR+9)
#define SrErrorDefXoffset          (ERR_SR+10)
#define SrErrorXoffset             (ERR_SR+11)
#define SrErrorNumColors           (ERR_SR+12)
#define SrErrorBadNumColors        (ERR_SR+13)
#define SrErrorColorSpace          (ERR_SR+14)
#define SrErrorBadImageSize        (ERR_SR+15)
#define SrErrorValue               (ERR_SR+16)
#endif ERR_SR

#endif _S_ERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_file.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_file.c,v $
 * Revision 1.1.8.6  1996/12/12  20:54:43  Hans_Graves
 * 	Fix some NT warnings (when linking statically).
 * 	[1996/12/12  20:07:58  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/11/04  22:38:38  Hans_Graves
 * 	Fixed open/closes under NT. File closes weren't always happening.
 * 	[1996/11/04  22:29:53  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/10/28  17:32:18  Hans_Graves
 * 	Replace longs with dwords for NT portability.
 * 	[1996/10/28  16:54:46  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/09/18  23:45:38  Hans_Graves
 * 	Added ScFileClose() for portability
 * 	[1996/09/18  21:53:20  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:55:45  Hans_Graves
 * 	Fix file creation under NT.
 * 	[1996/05/07  17:11:18  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/04/01  16:23:08  Hans_Graves
 * 	Added ScFileOpen and ScFileRead/Write functions for portability
 * 	[1996/04/01  16:11:56  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/02/07  23:23:48  Hans_Graves
 * 	Added ScFileSeek().
 * 	[1996/02/07  23:21:55  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/01/02  18:30:51  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:02  Bjorn_Engberg]
 * 
 * Revision 1.1.2.5  1995/09/20  14:59:32  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:12  Bjorn_Engberg]
 * 
 * Revision 1.1.2.4  1995/07/12  19:48:22  Hans_Graves
 * 	Added H261 recognition to ScFileType().
 * 	[1995/07/12  19:33:48  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/22  21:36:00  Hans_Graves
 * 	Moved ScGetFileType() from sv_gentoc.c. Added some Audio file types.
 * 	[1995/06/22  21:33:05  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:49  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:13:00  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/07  18:55:36  Hans_Graves
 * 	Added FileExists()
 * 	[1995/04/07  18:55:13  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  18:34:21  Hans_Graves
 * 	Inclusion in SLIB's Su library
 * 	[1995/04/07  18:33:26  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include <fcntl.h>
#include <sys/types.h>
#ifndef WIN32
#include <sys/mman.h>
#endif /* WIN32 */
#include <sys/stat.h>
#include "SC.h"
#include "SC_err.h"

#ifdef WIN32
#include <string.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#endif

/*
** Name:     ScFileExists
** Purpose:  Does this file exist?
**
*/
ScBoolean_t ScFileExists(char *filename)
{
#ifdef WIN32
  struct _stat stat_buf;
  if (_stat(filename, &stat_buf))
#else
  struct stat stat_buf;
  if (stat(filename, &stat_buf))
#endif
    return(FALSE);
  else
    return(TRUE);
}

/*
** Name:    ScFileOpenForReading
** Purpose: Open a file for reading.
** Returns: Handle to file.
**          -1 if error
*/
int ScFileOpenForReading(char *filename)
{
  if (!filename)
    return(-1);
#ifdef WIN32
  return((int)_open(filename, _O_RDONLY|_O_BINARY));
#else /* OSF */
  return((int)open(filename, O_RDONLY));
#endif
}

/*
** Name:    ScFileOpenForWriting
** Purpose: Open a file for writing.  Creates it if it doesn't already exist.
** Returns: Handle to file.
**          -1 if error
*/
int ScFileOpenForWriting(char *filename, ScBoolean_t truncate)
{
  if (!filename)
    return(-1);
#ifdef WIN32
  if (truncate)
    return((int)_open(filename, _O_WRONLY|_O_CREAT|_O_TRUNC|_O_BINARY,
                                _S_IREAD|_S_IWRITE));
  else
    return((int)_open(filename, _O_WRONLY|_O_CREAT|_O_BINARY,
                                _S_IREAD|_S_IWRITE));
#else
  if (truncate)
    return((int)open(filename, O_WRONLY|O_CREAT|O_TRUNC,
                           S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH));
  else
    return((int)open(filename, O_WRONLY|O_CREAT,
                           S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH));
#endif
}

/*
** Name:    ScFileSize
** Purpose: Get the size of a file in bytes
*/
ScStatus_t ScFileSize(char *filename, unsigned qword *size)
{
#ifdef WIN32
  struct _stat stat_buf;
#else
  struct stat stat_buf;
#endif

  if (!filename || !size)
    return(ScErrorBadArgument);
#ifdef WIN32
  if (_stat(filename, &stat_buf) < 0)
#else
  if (stat(filename, &stat_buf) < 0)
#endif
  {
    *size=0;
    return(ScErrorFile);
  }
  *size=(unsigned qword)stat_buf.st_size;
  return(NoErrors);
}

/*
** Name: ScFileRead
** Purpose: Read a number of bytes from a file into a buffer
** Return:  Number of bytes read
**          -1 if EOF
*/
dword ScFileRead(int fd, void *buffer, unsigned dword bytes)
{
#ifdef __VMS
   return((long)fread(buffer, 1, bytes, fd));
#elif defined(WIN32)
   return((long)_read(fd, buffer, bytes));
#else /* UNIX */
   return((long)read(fd, buffer, bytes));
#endif
}

/*
** Name: ScFileWrite
** Purpose: Write a number of bytes from a buffer to a file
** Return:  Number of bytes written
**          0 if error
*/
dword ScFileWrite(int fd, void *buffer, unsigned dword bytes)
{
#ifdef __VMS
   return((dword)fwrite(buffer, 1, bytes, fd));
#elif defined(WIN32)
   return((dword)_write(fd, buffer, bytes));
#else /* UNIX */
   return((dword)write(fd, buffer, bytes));
#endif
}

/*
** Name: ScFileSeek
** Purpose: Seek to a specific position is a file
*/
ScStatus_t ScFileSeek(int fd, qword bytepos)
{
#ifdef __VMS
  if (fseek(fd,bytepos,SEEK_SET)<0)
#elif defined(WIN32)
  if (_lseek(fd,(long)bytepos,SEEK_SET)<0)
#else
  if (lseek(fd,(long)bytepos,SEEK_SET)<0)
#endif
    return(ScErrorFile);
  else
    return(NoErrors);
}

/*
** Name: ScFileClose
** Purpose: Close an opened file
*/
void ScFileClose(int fd)
{
  if (fd>=0)
  {
#ifdef WIN32
   _close(fd);
#else /* UNIX or VMS */
   close(fd);
#endif
  }
}

/*
** Name:    ScFileMap
** Purpose: Map an entire file to memory
**          if fd<0 then the filename is opened for reading
** Returns: buffer = memory pointer to the mapped file
**          size   = size of the buffer (file)
*/
ScStatus_t ScFileMap(char *filename, int *pfd, u_char **buffer, 
                                         unsigned qword *size)
{
#ifdef WIN32

  /*
   * Mapping of files can be supported on NT,
   * but for now return an error and implement
   * file mapping later - BE.
   */
   return(ScErrorMapFile);

#else /* !WIN32 */
  if (!pfd || !filename || !buffer || !size)
    return(ScErrorBadArgument);
  if (ScFileSize(filename, size)!=NoErrors)
    return(ScErrorFile);

  if (*pfd<0)
  {
    if ((*pfd = open (filename, O_RDONLY)) < 0)
      return(ScErrorFile);
  }

  *buffer= (unsigned char *)mmap(0, *size, PROT_READ,
                   MAP_FILE | MAP_VARIABLE | MAP_PRIVATE, *pfd, 0);
  if (*buffer==(u_char *)-1L)
  {
    *buffer=NULL;
    *size=0;
    return(ScErrorMapFile);
  }

#endif /* !WIN32 */
  return(NoErrors);
}

/*
** Name:    ScFileUnMap
** Purpose: UnMap a file mapped to memory
**          if fd>=0 then the file is closed
*/
ScStatus_t ScFileUnMap(int fd, u_char *buffer, unsigned int size)
{
  if (!buffer || !size)
    return(ScErrorBadArgument);
#ifndef WIN32
  if (munmap(buffer, size)<0)
#endif /* !WIN32 */
    return(ScErrorMapFile);
  if (fd>=0)
    ScFileClose(fd);
  return(NoErrors);
}

/*
** Name:    ScGetFileType
** Purpose: Find out the type of a multmedia file.
** Returns: UNKNOWN_FILE, AVI_FILE, JFIF_FILE, QUICKTIME_JPEG_FILE
**          MPEG_VIDEO_FILE, MPEG_AUDIO_FILE, MPEG_SYSTEM_FILE,
**          GSM_FILE
*/
int ScGetFileType(char *filename)
{
  int fd;
  u_char buf[20];
  char *fileext;

  if ((fd = ScFileOpenForReading(filename)) < 0)
    return(ScErrorDevOpen);

  ScFileRead(fd, buf, 11);

  /*
  ** MPEG video file
  */
  if ((buf[0] == 0) &&
      (buf[1] == 0) &&
      (buf[2] == 1) &&
      (buf[3] == 0xb3)) {
    ScFileClose(fd);
    return(MPEG_VIDEO_FILE);
  }
  /*
  ** MPEG system file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x00) &&
      (buf[2] == 0x01) &&
      (buf[3] == 0xba)) {
    ScFileClose(fd);
    return(MPEG_SYSTEM_FILE);
  }
  /*
  ** H261 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x01) &&
      (buf[2] == 0x00) &&
      (buf[3] == 0x88)) {
    ScFileClose(fd);
    return(H261_FILE);
  }
  /*
  ** JFIF file (ffd8 = Start-Of-Image marker)
  */
  if ((buf[0] == 0xff) &&
      (buf[1] == 0xd8)) {
    ScFileClose(fd);
    return(JFIF_FILE);
  }
  /*
  ** QUICKTIME JPEG file (4 ignored bytes, "mdat", ff, d8, ff)
  */
  if ((strncmp(&buf[4], "mdat", 4) == 0 ) &&
      (buf[8]  == 0xff) &&
      (buf[9]  == 0xd8) &&
      (buf[10] == 0xff)) {
    ScFileClose(fd);
    return(QUICKTIME_JPEG_FILE);
  }
  /******* use the file's extension to help guess the type ********/
  for (fileext=filename; *fileext; fileext++)
    if (*fileext=='.' && *(fileext+1)!='.')
    {
      fileext++;
      if (strncmp(fileext, "p64", 3)==0)
      {
        ScFileClose(fd);
        return(H261_FILE);
      }
      if (strncmp(fileext, "gsm", 3)==0)
      {
        ScFileClose(fd);
        return(GSM_FILE);
      }
      if (strncmp(fileext, "pcm", 3)==0)
      {
        ScFileClose(fd);
        return(PCM_FILE);
      }
      if (strncmp(fileext, "wav", 3)==0 && strncmp(buf, "RIFF", 4)==0)
      {
        ScFileClose(fd);
        return(WAVE_FILE);
      }
      if (strncmp(fileext, "mp", 2)==0 && buf[0]==0xFF)
      {
        ScFileClose(fd);
        return(MPEG_AUDIO_FILE);
      }
      break;
    }

  /*
  ** AVI RIFF file
  */
  if ( strncmp(buf, "RIFF", 4) == 0 ) {
    ScFileClose(fd);
    return(AVI_FILE);
  }

  ScFileClose(fd);
  return(UNKNOWN_FILE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_mem.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_mem.c,v $
 * Revision 1.1.4.2  1996/01/02  18:30:56  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:04  Bjorn_Engberg]
 *
 * Revision 1.1.2.4  1995/09/20  14:59:33  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:14  Bjorn_Engberg]
 *
 * Revision 1.1.2.3  1995/09/14  17:28:09  Bjorn_Engberg
 * 	Ported to NT
 * 	[1995/09/14  17:21:10  Bjorn_Engberg]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:53  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:15:46  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/03  19:12:55  Hans_Graves
 * 	First time under SLIB
 * 	[1995/05/03  19:12:17  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/04/17  17:46:54  Hans_Graves
 * 	Added ScAlloc2()
 * 	[1995/04/17  17:45:28  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/04/07  18:40:03  Hans_Graves
 * 	Inclusion in SLIB's Su library
 * 	[1995/04/07  18:39:43  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*-------------------------------------------------------------------------
**  Modification History: sc_mem.c
**      05-29-93  Victor Bahl  Paged aligned malloc and free
**      12-07-93  PSG          Added error reporting code
**      03-15-95  HWG          Moved to Su library, Added SuAlloc & SuFree
**      04-04-97  HWG          With WIN32 use LocalAlloc and LocalFree in
**                               place of malloc and free
**                             Added ScCalloc function.
**      04-15-97  HWG          Added memory linked list to help track leaks
**                             Fixed potential initalization bug in linked
**                               list used to track ScPaMalloc's
--------------------------------------------------------------------------*/
/*
#define _SLIBDEBUG_
*/

#include <stdio.h>  /* NULL */
#include <sys/types.h>
#ifdef WIN32
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#endif /* WIN32 */
#include "SC.h"
#include "SC_err.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   0  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */

/* keep a linked list to ttrack memory leaks */
typedef struct memblock_s {
    void *ptr;
    dword size;
    dword counter;
    char  desc[15];
    struct memblock_s *next;
} memblock_t;

static memblock_t *_blocklist=NULL;
static _blockcounter=0;
static _memused=0;

void scMemAddWatch(void *ptr, dword size, char *desc)
{
  memblock_t *pblock;
#if defined(WIN32)
  pblock = (void *)LocalAlloc(LPTR, sizeof(memblock_t));
#else
  pblock = (void *)malloc(sizeof(memblock_t));
#endif
  _memused+=size;
  if (pblock)
  {
    pblock->ptr=ptr;
    pblock->next=_blocklist;
    pblock->size=size;
    pblock->counter=_blockcounter;
    if (desc==NULL)
      pblock->desc[0]=0;
    else
    {
      int i;
      for (i=0; desc[i] && i<14; i++)
        pblock->desc[i]=desc[i];
      pblock->desc[i]=0;
    }
    _blocklist=pblock;
    _blockcounter++;
  }
}

ScBoolean_t scMemRemoveWatch(void *ptr)
{
  memblock_t *plastblock=NULL, *pblock=_blocklist;
  while (pblock)
  {
    if (pblock->ptr==ptr) /* remove from list */
    {
      if (plastblock==NULL) /* beginning of linked list */
        _blocklist=pblock->next;
      else
        plastblock->next=pblock->next;
      _memused-=pblock->size;
#ifdef WIN32
      LocalFree(pblock);
#else
      free(pblock);
#endif
      if (_blocklist==NULL) /* all memory freed, reset counter */
        _blockcounter=0;
      return(TRUE);
    }
    plastblock=pblock;
    pblock=pblock->next;
  }
  return(FALSE);
}

dword scMemDump()
{
  memblock_t *plastblock=NULL, *pblock=_blocklist;
  ScDebugPrintf(NULL, "scMemDump: memused=%ld\n", _memused);
  while (pblock)
  {
    ScDebugPrintf(NULL, " ptr=%p counter=%ld size=%ld desc=%s\n",
        pblock->ptr, pblock->counter, pblock->size, pblock->desc);
    pblock=pblock->next;
  }
  return(_memused);
}
#endif

#ifdef WIN32
int getpagesize()
{
    SYSTEM_INFO sysInfo;
    static int pagesize = 0 ;

    if( pagesize == 0 ) {
	GetSystemInfo(&sysInfo);

	pagesize = (int)sysInfo.dwPageSize;
    }

    return pagesize ;
}

#define bzero(_addr_,_len_) memset(_addr_,0,_len_)
#endif

/*------------------------------------------------------------------------
                         Simple Memory Allocation
-------------------------------------------------------------------------*/
/*
** Name:    ScAlloc
** Purpose: Allocate number of bytes of memory.
**
*/
void *ScAlloc(unsigned long bytes)
{
  void *ptr;

#ifdef  MACINTOSH
  ptr = NewPtr(bytes);
#elif MSC60
  ptr = (void FAR *) _fmalloc((unsigned int)bytes); /* far memory */
#elif defined(WIN32)
  ptr = (void *)LocalAlloc(LPTR, bytes);
#else
  ptr = (void *)malloc(bytes);
#endif
  _SlibDebug(ptr, scMemAddWatch(ptr, bytes, NULL) );
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScAlloc(%ld) returns %p\n",bytes,ptr) );
  return(ptr);
}

/*
** Name:    ScCalloc
** Purpose: Allocate number of bytes of memory and zero it out.
**
*/
void *ScCalloc(unsigned long bytes)
{
  void *ptr = ScAlloc(bytes);
  if (ptr != NULL)
  {
#ifdef  MSC60
     _fmemset(ptr, 0, (unsigned int)bytes);
#else
     memset(ptr, 0, bytes);
#endif
  }
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScCalloc(%ld) returns %p\n",bytes,ptr) );
  return(ptr);
}

/*
** Name:    ScAlloc2
** Purpose: Allocate number of bytes of memory equal to "bytes".
**          Takes an extra argument "name" which identifies the block
**          (used for debugging).
*/
void *ScAlloc2(unsigned long bytes, char *desc)
{
  void *ptr;

  ptr = ScAlloc(bytes);
#ifdef _SLIBDEBUG_
  if (_blocklist) /* copy description to leak tracking info */
  {
    int i;
    for (i=0; desc[i] && i<14; i++)
      _blocklist->desc[i]=desc[i];
    _blocklist->desc[i]=0;
  }
#endif
  _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "ScAlloc(%ld, %s) returns %p\n",bytes,desc,ptr) );
  return(ptr);
}

/*
** Name:    ScFree
** Purpose: Free memory pointed to by "*ptr_addr"
**
*/
void ScFree(void *ptr)
{
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScFree(%p)\n", ptr) );
  _SlibDebug(ptr, scMemRemoveWatch(ptr) );
  if (ptr != NULL)
  {
#ifdef MACINTOSH
    DisposPtr(ptr);
#elif defined(WIN32)
#ifdef _SLIBDEBUG_
    _SlibDebug(LocalFree(ptr)!=NULL, ScDebugPrintf(NULL, "ScFree(%p) failed\n", ptr) );
#else
    LocalFree(ptr);
#endif
#else
    free(ptr);
#endif
  }
}

/*
** Name:    ScMemCheck
** Purpose: Check block of memory all equal to a single byte,
**          else return FALSE
*/
int ScMemCheck(char *array, int test, int num)
{
  int i=0;
  /* 'test' is only tested as a char (bottom 8 bits) */
  while (array[i] == test && i<num)
    i++;
  if (i==num)
    return TRUE;
  else
    return FALSE;
}

/*------------------------------------------------------------------------
                Paged aligned malloc() and free()
-------------------------------------------------------------------------*/

/*
** This structure is used by the page align malloc/free support code.
** These "working sets" will  contain  the malloc-ed address and the
** page aligned address for the free*() call.
*/
typedef struct mpa_ws_s
{
    char *palign_addr;          /* the page aligned address that's used */
    char *malloc_addr;          /* the malloc-ed address to free */
    struct mpa_ws_s *next;      /* for the next on the list */
} mpa_ws_t;


/*
** Initialized and uninitialized data.
*/
static mpa_ws_t *mpa_qhead=NULL;      /* local Q head for the malloc stuctures */


/*
** Name:    ScPaMalloc
** Purpose: Allocate Paged Alligned Memory
**          This  routine  allocates  and returns to  the caller a system
**          page  aligned buffer. Enough  space  will  be added, one more
**          page, to allow the pointers to be  adjusted  to the next page
**          boundry. A local linked list will keep copies of the original
**          and adjusted addresses. This list will be used by sv_PaFree()
**          to free the correct buffer.
**
*/
char *ScPaMalloc(int size)
{
    mpa_ws_t *ws;                 /* pointer for the working set  */
    ULONG_PTR tptr;               /* to store pointer temp for bit masking */
    int PageSize = getpagesize(); /* system's page size           */

    /*
    ** The space for the working set structure that will go on the queue
    ** is allocated first.
    */
    if ((ws = (mpa_ws_t *)ScAlloc(sizeof(mpa_ws_t))) == (mpa_ws_t *)NULL)
        return( (char *)NULL );


    /*
    ** Using the requested size, from the argument list, and the page size
    ** from the system,  allocate enough space to page align the requested
    ** buffer.  The original request will have the space of one system page
    ** added to it.  The pointer will be adjusted.
    */
    ws->malloc_addr = (char *)ScAlloc(size + PageSize);
    if (ws->malloc_addr == (char *)NULL)
    {
      ScFree(ws);                              /* not going to be used */
      return((char *)NULL);                    /* signal the failure */
    } else
        (void) bzero (ws->malloc_addr, (size + PageSize));

    /*
    ** Now using the allocated space + 1 page, adjust the pointer to
    ** point to the next page boundry.
    */
    ws->palign_addr = ws->malloc_addr + PageSize;       /* to the next page */

    /*
    ** Using the page size and subtracting 1 to get a bit mask, mask off
    ** the low order "page offset" bits to get the aligned address.  Now the
    ** aligned pointer will contain the address of the next page with enough
    ** space to hold the users requested size.
    */
    tptr  = (ULONG_PTR)ws->palign_addr;            /* copy to local int    */
    tptr &= (ULONG_PTR)(~(PageSize - 1));          /* Mask addr bit to the */
    ws->palign_addr = (char *)tptr;             /* put back the address */
    /*
    ** Put the working set onto the linked list so that the original
    ** malloc-ed buffer can be freeed when the user program is done with it.
    */
    ws->next=mpa_qhead;
    mpa_qhead=ws;                  /* just put it at the head */

    /*
    ** Now return the aligned address to the caller.
    */
    return((char *)ws->palign_addr);
}

/*
** Name:    ScPaFree
** Purpose: This is a local free routine to return to the system a previously
**          alloc-ed buffer.  A local linked list keeps copies of the original
**          and adjusted addresses.  This list is used by this routine to free
**          the correct buffer.
*/
void ScPaFree (void *pa_addr)
{
    mpa_ws_t *p, *q;                    /* walkers for the malloc list */

    /*
    ** Walk along the malloc-ed memory linked list, watch for a match
    ** on the page aligned address.  If a match is found break out of the
    ** loop.
    */
    p = mpa_qhead;                 /* set the pointers */
    q = NULL;

    while (p != NULL)
    {
       if (p->palign_addr == pa_addr)   /* found the buffer */
          break;

       q = p;                           /* save current */
       p = p->next;                     /* get next */
    }
    _SlibDebug(_WARN_ && p==NULL,
      ScDebugPrintf(NULL, "ScPaFree(%p) Illegal pointer\n", pa_addr) );

    /*
    ** After falling out of the loop the pointers are at the place where
    ** some work has to be done, (this could also be at the beginning).
    ** If a match is found call the free() routine to return the buffer, if
    ** the loop fell off the end just return.
    */
    if (p != NULL)
    {
        /*
        ** Where on the list is it, check for making it empty.
        */
        if (q == NULL)                   /* at the front */
            mpa_qhead = p->next;   /* pop off front */
        else                            /* inside the list */
            q->next = p->next;          /* pop it */

        ScFree(p->malloc_addr);           /* free the malloc-ed addr */

        /*
        ** Now free up the working set, it is not needed any more.
        */
        ScFree(p);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sv_intrn.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_internals.h,v $
 * Revision 1.1.8.2  1996/05/07  19:56:06  Hans_Graves
 * 	Added HUFF_SUPPORT.
 * 	[1996/05/07  17:25:29  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/03/29  22:21:16  Hans_Graves
 * 	Added JPEG_SUPPORT ifdefs.  Moved JPEG specific data to JpegInfo structures
 * 	[1996/03/29  22:14:34  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:30  Hans_Graves
 * 	Added SvMpegCompressInfo_t pointer
 * 	[1995/12/07  18:27:16  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/09/22  12:58:41  Bjorn_Engberg
 * 	Added MPEG_SUPPORT, H261_SUPPORT and BITSTREAM_SUPPORT.
 * 	[1995/09/22  12:49:37  Bjorn_Engberg]
 * 
 * Revision 1.1.2.6  1995/09/11  18:49:43  Farokh_Morshed
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:49:23  Farokh_Morshed]
 * 
 * Revision 1.1.2.5  1995/07/21  17:41:06  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:28:26  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/17  16:12:14  Hans_Graves
 * 	Moved BSIn, BufQ and ImageQ to SvCodecInfo_t structure.
 * 	[1995/07/17  15:54:04  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/19  20:31:17  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:14:01  Karen_Dintino]
 * 
 * Revision 1.1.2.2  1995/05/31  18:10:06  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:43:08  Hans_Graves]
 * 
 * Revision 1.1.2.3  1994/11/18  18:48:17  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:45:08  Paul_Gauthier]
 * 
 * Revision 1.1.2.2  1994/10/07  14:54:06  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:56:29  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*      "%Z% %M% revision %I%; last modified %G%"; */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
                                                                                
/*--------------------------------------------------------------------------
 * Baseline data structure definitions.
 *
 * Modification History: sv_internals.h
 *
 *      08-Sep-94  PSG   Created
 *---------------------------------------------------------------------------*/



#ifndef _SV_INTERNALS_H_
#define _SV_INTERNALS_H_

#include "SV.h"
#ifdef JPEG_SUPPORT
#include "sv_jpeg.h"
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
#include "sv_mpeg.h"
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
#include "sv_h261.h"
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
#include "sv_h263.h"
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
#include "sv_huff.h"
#endif /* HUFF_SUPPORT */

#if defined(MPEG_SUPPORT) || defined(H261_SUPPORT) || defined(H263_SUPPORT) || defined(HUFF_SUPPORT)
#define BITSTREAM_SUPPORT
#endif /* MPEG_SUPPORT || H261_SUPPORT */

#define  TOC_ENTRIES_INCREMENT 100
#define  TEMP_BUF_SIZE        8192
#define  JBUFSIZE	     16384 
#define  BYTE_BUF_SIZE        8192

/*
** The following structure contains *all* state information pertaining 
** to each individual codec instance. Anything SLIB would ever want
** about the codec configuration is contained in this structure.
** For example:
**	- what is the codec configured for: compression or decompression
**	- source image characteristics
**	- destination image characteristics
**	- characteristics particular to JPEG compression
**	- characteristics particular to JPEG decompression
**	- component specific information
**
*/
typedef struct SvCodecInfo_s {
  /*
  ** what is the CODEC opened for:
  */ 
  SvCodecType_e	mode;		       /* code type, encode or decode */
  ScBoolean_t   started;           /* begin was called? */
  /*
  ** specific CODEC info
  */
  union {
    void *info;
#ifdef JPEG_SUPPORT
    /*
    ** JPEG information is stored here:
    **	modes = SV_JPEG_DECODE, SV_JPEG_ENCODE
    */
    SvJpegDecompressInfo_t *jdcmp;
    SvJpegCompressInfo_t *jcomp;
#endif /* !JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
    /*
    ** MPEG specific information is stored here:
    **   modes = SV_MPEG_DECODE, SV_MPEG_ENCODE, SV_MPEG_DECODE, SV_MPEG_ENCODE
    */
    SvMpegDecompressInfo_t *mdcmp;
    SvMpegCompressInfo_t   *mcomp;
#endif /* !MPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* Encoding specific information for H.261 is kept in this structure
    ** which is defined in sv_h261.h
    */
    SvH261Info_t *h261;
#endif /* !H261_SUPPORT */
#ifdef H263_SUPPORT
    /*
    ** H263 specific information is stored here:
    */
    SvH263DecompressInfo_t *h263dcmp;
    SvH263CompressInfo_t *h263comp;
#endif /* !MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    /* Encoding specific information for huffman video encoder & decoder
    */
    SvHuffInfo_t  *huff;
#endif /* !HUFF_SUPPORT */
  }; /* union */

  /*
  ** Source image characteristics:
  */
  int Width;			       /* pixels/lines     */
  int Height;			       /* number of lines  */
  unsigned int NumOperations;  /* # codec operations this session */

                                /*
  ** Microsoft specific:
  */
  BITMAPINFOHEADER   InputFormat;	
  DWORD InRedMask;      /* For BI_BITFIELDS */
  DWORD InGreenMask;    /* For BI_BITFIELDS */
  DWORD InBlueMask;     /* For BI_BITFIELDS */

  BITMAPINFOHEADER   OutputFormat;	
  DWORD OutRedMask;      /* For BI_BITFIELDS */
  DWORD OutGreenMask;    /* For BI_BITFIELDS */
  DWORD OutBlueMask;     /* For BI_BITFIELDS */

  /*
  **  Bitstream stuff - Only used by H261, H263 and MPEG
  */
  ScQueue_t      *BufQ;    /* The queue of bitstream data buffers */
  ScQueue_t      *ImageQ;  /* The queue of images (streaming mode only) */
  ScBitstream_t  *BSIn;
  ScBitstream_t  *BSOut;
  /*
  ** Callback function to abort processing & bitstream operations
  */
  int (* CallbackFunction)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *); 
} SvCodecInfo_t;


#endif _SV_INTERNALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\slib.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib.h,v $
 * Revision 1.1.6.22  1996/12/13  18:19:02  Hans_Graves
 * 	Added SlibErrorNoBeginning enum
 * 	[1996/12/13  17:42:20  Hans_Graves]
 *
 * Revision 1.1.6.21  1996/12/10  19:21:51  Hans_Graves
 * 	Added Avg/VarVideoTimeDiff and SlibFrameToTime100() macro
 * 	[1996/12/10  19:17:53  Hans_Graves]
 * 
 * Revision 1.1.6.20  1996/12/05  20:10:13  Hans_Graves
 * 	Added AvgVideoTimeDiff and AvgAudioTimeDiff to SlibInfo_t
 * 	[1996/12/05  20:07:53  Hans_Graves]
 * 
 * Revision 1.1.6.19  1996/12/03  00:08:29  Hans_Graves
 * 	Added unit SLIB_UNIT_PERCENT100 and Seek type SLIB_SEEK_RESYNC.
 * 	[1996/12/03  00:02:47  Hans_Graves]
 * 
 * Revision 1.1.6.18  1996/11/20  02:15:07  Hans_Graves
 * 	Added SEEK_AHEAD.
 * 	[1996/11/20  01:49:55  Hans_Graves]
 * 
 * Revision 1.1.6.17  1996/11/18  23:07:14  Hans_Graves
 * 	Change operations to the time-based instead of frame-based.
 * 	[1996/11/18  22:56:34  Hans_Graves]
 * 
 * Revision 1.1.6.16  1996/11/11  18:21:02  Hans_Graves
 * 	Added proto for slibRenamePin().
 * 	[1996/11/11  17:58:03  Hans_Graves]
 * 
 * Revision 1.1.6.15  1996/11/08  21:50:59  Hans_Graves
 * 	Added AC3 stuff. Better seperation of stream types.
 * 	[1996/11/08  21:18:22  Hans_Graves]
 * 
 * Revision 1.1.6.14  1996/10/31  00:08:53  Hans_Graves
 * 	Added SLIB_TIME_UNKNOWN
 * 	[1996/10/31  00:07:57  Hans_Graves]
 * 
 * Revision 1.1.6.13  1996/10/28  17:32:23  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:19:38  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/10/17  00:23:30  Hans_Graves
 * 	Added SLIB_PARAM_VIDEOFRAME and SLIB_PARAM_FRAMEDURATION.
 * 	[1996/10/17  00:17:53  Hans_Graves]
 * 
 * Revision 1.1.6.11  1996/10/12  17:18:19  Hans_Graves
 * 	Added params HALFPEL and SKIPPEL. Seperated MPEG2_SYSTEMS into TRANSPORT and PROGRAM.
 * 	[1996/10/12  16:57:14  Hans_Graves]
 * 
 * Revision 1.1.6.10  1996/10/03  19:14:19  Hans_Graves
 * 	Added PTimeCode and DTimeCode to Info struct.
 * 	[1996/10/03  19:08:35  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/09/29  22:19:35  Hans_Graves
 * 	Added stride support. Added SlibQueryData().
 * 	[1996/09/29  21:28:25  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/09/25  19:16:41  Hans_Graves
 * 	Reduce number of includes needed publicly by adding SLIB_INTERNAL ifdef.
 * 	[1996/09/25  19:02:38  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/09/23  18:04:01  Hans_Graves
 * 	Added STATS params.
 * 	[1996/09/23  18:03:23  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/09/18  23:46:20  Hans_Graves
 * 	Clean up. Added SlibAddBufferEx() and SlibReadData() protos.
 * 	[1996/09/18  21:59:36  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/08/09  20:51:19  Hans_Graves
 * 	Fix proto for SlibRegisterVideoBuffer()
 * 	[1996/08/09  20:06:26  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/07/19  02:11:05  Hans_Graves
 * 	New params. Added SlibRegisterVideoBuffer.
 * 	[1996/07/19  01:26:07  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/05/10  21:16:53  Hans_Graves
 * 	Changes for Callback support.
 * 	[1996/05/10  20:59:56  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/05/07  19:56:00  Hans_Graves
 * 	Added Callback framework.
 * 	[1996/05/07  17:23:12  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/04/24  22:33:42  Hans_Graves
 * 	Added proto for slibValidateBitrates()
 * 	[1996/04/24  22:27:46  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/04/23  21:01:41  Hans_Graves
 * 	Added SlibErrorSettingNotEqual
 * 	[1996/04/23  20:59:36  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/04/22  15:04:50  Hans_Graves
 * 	Added protos for: slibValidateVideoParams, slibValidateAudioParams, SlibValidateParams
 * 	[1996/04/22  15:03:17  Hans_Graves]
 * 
 * Revision 1.1.4.10  1996/04/19  21:52:20  Hans_Graves
 * 	Additions to SlibInfo: TotalBitRate, MuxBitRate, SystemTimeStamp, PacketCount
 * 	[1996/04/19  21:49:13  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/04/15  14:18:35  Hans_Graves
 * 	Added temp audio buffer info
 * 	[1996/04/15  14:09:23  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/04/10  21:47:36  Hans_Graves
 * 	Moved definition for EXTERN to SC.h
 * 	[1996/04/10  21:24:09  Hans_Graves]
 * 
 * 	Added QUALITY and FAST params
 * 	[1996/04/10  20:41:21  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/04/09  16:04:39  Hans_Graves
 * 	Added EXTERN define for cplusplus compatibility
 * 	[1996/04/09  14:49:16  Hans_Graves]
 * 
 * Revision 1.1.4.6  1996/04/01  19:07:50  Hans_Graves
 * 	Change slibVerifyVideoParams() proto
 * 	[1996/04/01  19:05:31  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/04/01  16:23:11  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:51  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/03/29  22:21:13  Hans_Graves
 * 	Added HeaderProcessed to SlibInfo
 * 	[1996/03/27  21:52:31  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/03/12  16:15:42  Hans_Graves
 * 	Added SLIB_PARAM_FILEBUFSIZE parameter
 * 	[1996/03/12  16:11:55  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/03/08  18:46:31  Hans_Graves
 * 	Added Imagebuf to SlibInfo_t
 * 	[1996/03/08  16:23:53  Hans_Graves]
 * 
 * Revision 1.1.2.13  1996/02/19  18:03:53  Hans_Graves
 * 	Added more SEEK types.
 * 	[1996/02/19  17:59:12  Hans_Graves]
 * 
 * Revision 1.1.2.12  1996/02/13  18:47:45  Hans_Graves
 * 	Fix some Seek related bugs
 * 	[1996/02/13  18:41:51  Hans_Graves]
 * 
 * Revision 1.1.2.11  1996/02/07  23:23:51  Hans_Graves
 * 	Added slibCountCodesOnPin() prototype
 * 	[1996/02/07  23:19:11  Hans_Graves]
 * 
 * Revision 1.1.2.10  1996/02/06  22:53:55  Hans_Graves
 * 	Prototype updates
 * 	[1996/02/06  22:44:06  Hans_Graves]
 * 
 * Revision 1.1.2.9  1996/02/02  17:36:01  Hans_Graves
 * 	Updated prototypes
 * 	[1996/02/02  17:28:41  Hans_Graves]
 * 
 * Revision 1.1.2.8  1996/01/30  22:23:06  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:22:00  Hans_Graves]
 * 
 * Revision 1.1.2.7  1996/01/15  16:26:26  Hans_Graves
 * 	Added: TYPE_WAVE, more PARAMs, SlibWriteAudio()
 * 	[1996/01/15  15:44:44  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/01/11  16:17:26  Hans_Graves
 * 	Added SlibGet/SetParam() prototypes
 * 	[1996/01/11  16:13:44  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/01/08  16:41:25  Hans_Graves
 * 	Cleaned up prototypes
 * 	[1996/01/08  15:48:38  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/12/07  19:31:27  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:28:11  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/11/09  23:14:03  Hans_Graves
 * 	Added Time structure members and prototypes
 * 	[1995/11/09  23:10:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/11/06  18:47:45  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:34:32  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SLIB_H_
#define _SLIB_H_

#ifdef WIN32
#include <windows.h>
#endif
#include "SC.h"
#ifdef SLIB_INTERNAL
#include "SV.h"
#include "SA.h"
#include "scon.h"
#endif /* SLIB_INTERNAL */

typedef void       *SlibHandle_t;
typedef ScBoolean_t SlibBoolean_t;
typedef int         SlibStream_t;
typedef qword       SlibTime_t;
typedef qword       SlibPosition_t;

#define SLIB_TIME_NONE     (SlibTime_t)(-1)
#define SLIB_TIME_UNKNOWN  (SlibTime_t)(-2)

/* units used in seeking */
typedef enum {
  SLIB_UNIT_NONE,
  SLIB_UNIT_FRAMES,     /* frames */
  SLIB_UNIT_MS,         /* milliseconds */
  SLIB_UNIT_PERCENT100, /* one hundredth of percent */
} SlibUnit_t;

#define SlibTimeIsValid(stime)  ((stime)>=0)
#define SlibTimeIsInValid(stime)  ((stime)<0)
#define SlibTimeToFrame(Sh,vs,stime) \
      ((qword)((stime)*SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS))/1000)
#define SlibFrameToTime(Sh,vs,frame) \
  ((SlibTime_t)((float)(frame*1000)/SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS)))
#define SlibFrameToTime100(Sh,vs,frame) \
 ((SlibTime_t)((float)(frame*100000)/SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS)))

typedef qword SlibListParam1_t;
typedef qword SlibListParam2_t;

typedef struct SlibList_s {
  int   Enum;   /* an enumerated value associated with the entry */
  char *Name;   /* the name of an entry in the list. NULL = last entry */
  char *Desc;   /* a lengthy description of the entry */
  SlibListParam1_t param1;
  SlibListParam2_t param2;
} SlibList_t;

typedef enum {
  SlibErrorNone = 0,
  SlibErrorInternal,
  SlibErrorMemory,
  SlibErrorBadArgument,
  SlibErrorBadHandle,
  SlibErrorBadStream,
  SlibErrorBadMode,
  SlibErrorUnsupportedFormat,
  SlibErrorReading,
  SlibErrorWriting,
  SlibErrorBufSize,
  SlibErrorEndOfStream,
  SlibErrorForwardOnly,
  SlibErrorUnsupportedParam,
  SlibErrorImageSize,        /* Invalid image height and/or width */
  SlibErrorSettingNotEqual,  /* The exact Parameter setting was not accepted */
  SlibErrorInit,             /* initialization error */
  SlibErrorFileSize,         /* file size unknown */
  SlibErrorBadPosition,      /* position argument to seek is invalid */
  SlibErrorBadUnit,          /* units are invalid */
  SlibErrorNoBeginning,      /* couldn't begin the codecs */
  SlibErrorNoData,           /* no data available */
} SlibStatus_t;

typedef enum {
  SLIB_MODE_NONE,
  SLIB_MODE_COMPRESS,
  SLIB_MODE_COMPRESS_APPEND,
  SLIB_MODE_DECOMPRESS,
} SlibMode_t;

typedef enum {
  SLIB_TYPE_UNKNOWN=0,
  /* MPEG elementary stream types */
  SLIB_TYPE_MPEG1_VIDEO=0x01,
  SLIB_TYPE_MPEG1_AUDIO=0x02,
  SLIB_TYPE_MPEG2_VIDEO=0x04,
  SLIB_TYPE_MPEG2_AUDIO=0x08,
  SLIB_TYPE_AC3_AUDIO=0x10,
  /* MPEG multiplex types */
  SLIB_TYPE_MPEG_SYSTEMS=0x100,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2=0x104, /* MPEG Systems with MPEG2 data */
  SLIB_TYPE_MPEG_TRANSPORT=0x200,
  SLIB_TYPE_MPEG_PROGRAM=0x400,
  /* H26? stream types */
  SLIB_TYPE_H261=0x800,
  SLIB_TYPE_RTP_H261=0x808,
  SLIB_TYPE_H263=0x810,
  SLIB_TYPE_RTP_H263=0x818,
  /* RIFF stream types */
  SLIB_TYPE_RIFF=0x1000,
  SLIB_TYPE_PCM_WAVE,
  SLIB_TYPE_AVI,
  SLIB_TYPE_MJPG_AVI,
  SLIB_TYPE_JPEG_AVI,
  SLIB_TYPE_YUV_AVI,
  /* Other stream types */
  SLIB_TYPE_JPEG_QUICKTIME=0x2000,
  SLIB_TYPE_JFIF,
  SLIB_TYPE_MJPG,
  SLIB_TYPE_JPEG,
  SLIB_TYPE_YUV,
  SLIB_TYPE_RGB,
  SLIB_TYPE_PCM,
  /* G72? stream types */
  SLIB_TYPE_G723=0x4000,
  /* Miscellaneous types */
  SLIB_TYPE_RASTER=0x8000,
  SLIB_TYPE_BMP,
  /* Test stream types */
  SLIB_TYPE_SLIB=0xC000,
  SLIB_TYPE_SHUFF
} SlibType_t;

#ifdef OLD_SLIB
#define SLIB_TYPE_MPEG1_SYSTEMS   SLIB_TYPE_MPEG_SYSTEMS
#define SLIB_TYPE_MPEG2_SYSTEMS   SLIB_TYPE_MPEG_TRANSPORT
#define SLIB_TYPE_MPEG2_TRANSPORT SLIB_TYPE_MPEG_TRANSPORT
#define SLIB_TYPE_MPEG2_PROGRAM   SLIB_TYPE_MPEG_PROGRAM
#endif /* OLD_SLIB */

#define SlibTypeIsMPEG(stype) (stype>=SLIB_TYPE_MPEG1_VIDEO && \
                               stype<=SLIB_TYPE_MPEG_PROGRAM)
#define SlibTypeIsMPEGVideo(stype) (stype<=SLIB_TYPE_MPEG_PROGRAM && \
                                    (stype&0x705))
#define SlibTypeIsMPEGAudio(stype) (stype<=SLIB_TYPE_MPEG_PROGRAM && \
                                    (stype&0x70A))
#define SlibTypeIsMPEGMux(stype) (stype>=SLIB_TYPE_MPEG_SYSTEMS && \
                                  stype<=SLIB_TYPE_MPEG_PROGRAM)
#define SlibTypeIsMPEG2(stype) (stype==SLIB_TYPE_MPEG2_VIDEO || \
                                stype==SLIB_TYPE_MPEG_PROGRAM || \
                                stype==SLIB_TYPE_MPEG_TRANSPORT || \
                                stype==SLIB_TYPE_MPEG2_AUDIO)
#define SlibTypeIsMPEG1(stype) (stype==SLIB_TYPE_MPEG1_VIDEO || \
                                stype==SLIB_TYPE_MPEG1_AUDIO || \
                                stype==SLIB_TYPE_MPEG_SYSTEMS)
#define SlibTypeIsH26X(stype)  ((stype&0xFF00)==0x0800)
#define SlibTypeIsAVI(stype)   (stype>=SLIB_TYPE_AVI && \
                                stype<=SLIB_TYPE_YUV_AVI)
#define SlibTypeIsAudioOnly(stype) (stype==SLIB_TYPE_MPEG1_AUDIO || \
                                    stype==SLIB_TYPE_AC3_AUDIO || \
                                    stype==SLIB_TYPE_G723 || \
                                    stype==SLIB_TYPE_PCM || \
                                    stype==SLIB_TYPE_PCM_WAVE)
#define SlibTypeIsVideoOnly(stype) (stype==SLIB_TYPE_MPEG1_VIDEO || \
                                    stype==SLIB_TYPE_MPEG2_VIDEO || \
                                    SlibTypeIsH26X(stype) || \
                                    stype==SLIB_TYPE_YUV || \
                                    stype==SLIB_TYPE_RGB || \
                                    stype==SLIB_TYPE_BMP || \
                                    stype==SLIB_TYPE_RASTER)
#define SlibTypeIsMux(stype)     (SlibTypeIsMPEGMux(stype) || \
                                  SlibTypeIsAVI(stype))
#define SlibTypeHasTimeStamps(stype) (SlibTypeIsMPEGMux(stype))

typedef enum {
  SLIB_DATA_COMPRESSED=0,
  SLIB_DATA_AUDIO,
  SLIB_DATA_VIDEO,
  SLIB_DATA_PRIVATE
} SlibDataType_t;

typedef enum {
  SLIB_MSG_CONTINUE=0,
  SLIB_MSG_OPEN=0x01,
  SLIB_MSG_ENDOFDATA=0x10,
  SLIB_MSG_ENDOFSTREAM,
  SLIB_MSG_BUFDONE,
  SLIB_MSG_REPOSITION=0x20,
  SLIB_MSG_BADPOSITION,
  SLIB_MSG_CLOSE=0x80
} SlibMessage_t;

typedef qword SlibCBParam1_t;
typedef qword SlibCBParam2_t;

typedef enum {
  SLIB_QUERY_QUERIES,
  SLIB_QUERY_TYPES,
  SLIB_QUERY_COMP_TYPES,
  SLIB_QUERY_DECOMP_TYPES,
  SLIB_QUERY_MODES,
  SLIB_QUERY_PARAMETERS,
  SLIB_QUERY_ERRORS
} SlibQueryType_t;

typedef enum {
  /* these use position */
  SLIB_SEEK_EXACT=0x00,    /* jump to the exact frame */
  SLIB_SEEK_KEY,           /* jump to the closest key (I) frame */
  SLIB_SEEK_AHEAD,         /* jump ahead by a certain amount */
  SLIB_SEEK_NEXT_NEAR=0x08, /* advance to a frame near the requested frame */
  SLIB_SEEK_NEXT_EXACT,    /* advance to the exact requested frame */
  /* these don't use position */
  SLIB_SEEK_NEXT_KEY=0x10, /* advance to the next key (I) frame */
  SLIB_SEEK_NEXT_SUBKEY,   /* advance to the next key (I) or subkey (P) frame */
  SLIB_SEEK_NEXT,          /* advance one frame */
  SLIB_SEEK_RESET=0x100,   /* reset the streams */
  SLIB_SEEK_RESYNC         /* sync up all the streams */
} SlibSeekType_t;

#define SlibSeekTypeUsesPosition(seektype) (seektype<SLIB_SEEK_NEXT_KEY)

typedef struct SlibSeekInfo_s {
  SlibTime_t        VideoTimeStamp;
  SlibTime_t        AudioTimeStamp;
  qword             FramesSkipped;
} SlibSeekInfo_t;

typedef enum {
  /* SLIB Parameters */
  SLIB_PARAM_VERSION=0x00,  /* SLIB version number */
  SLIB_PARAM_VERSION_DATE,  /* SLIB build date */
  SLIB_PARAM_NEEDACCURACY,  /* need accurate frame counts and audio lengths */
  SLIB_PARAM_DEBUG,         /* debug handle */
  SLIB_PARAM_TYPE,          /* stream type */
  SLIB_PARAM_OVERFLOWSIZE,  /* pin overflowing size */
  SLIB_PARAM_KEY,           /* SLIB security key */
  /* Video Parameters */
  SLIB_PARAM_FPS=0x100,
  SLIB_PARAM_WIDTH,
  SLIB_PARAM_HEIGHT,
  SLIB_PARAM_IMAGESIZE,
  SLIB_PARAM_VIDEOBITRATE,
  SLIB_PARAM_VIDEOFORMAT,
  SLIB_PARAM_VIDEOBITS,
  SLIB_PARAM_VIDEOSTREAMS,
  SLIB_PARAM_VIDEOLENGTH,       /* total video length in miliiseconds */
  SLIB_PARAM_VIDEOFRAMES,       /* total video frames */
  SLIB_PARAM_VIDEOQUALITY,      /* video quality */
  SLIB_PARAM_VIDEOASPECTRATIO,  /* video aspect ratio: height/width */
  SLIB_PARAM_NATIVEVIDEOFORMAT, /* native/compressed format */
  SLIB_PARAM_NATIVEWIDTH,       /* native/compressed width */
  SLIB_PARAM_NATIVEHEIGHT,      /* native/compress height */
  SLIB_PARAM_VIDEOPROGRAM,      /* Video Program ID (Transport) */
  SLIB_PARAM_STRIDE,            /* bytes between scan lines */
  SLIB_PARAM_VIDEOFRAME,        /* video frame */
  SLIB_PARAM_FRAMEDURATION,     /* video frame duration in 100-nanosec units */
  SLIB_PARAM_VIDEOMAINSTREAM,   /* Main Video Stream (Systems+Program) */
  SLIB_PARAM_FRAMETYPE,         /* frame type - I, P, B or D */
  /* Audio Parameters */
  SLIB_PARAM_AUDIOFORMAT=0x200,
  SLIB_PARAM_AUDIOBITRATE,
  SLIB_PARAM_AUDIOSTREAMS,
  SLIB_PARAM_AUDIOCHANNELS,
  SLIB_PARAM_AUDIOLENGTH,     /* milliseconds of audio */
  SLIB_PARAM_AUDIOQUALITY,    /* audio quality */
  SLIB_PARAM_SAMPLESPERSEC,
  SLIB_PARAM_BITSPERSAMPLE,
  SLIB_PARAM_NATIVESAMPLESPERSEC,
  SLIB_PARAM_NATIVEBITSPERSAMPLE,
  SLIB_PARAM_AUDIOPROGRAM,    /* Audio Program ID (Transport) */
  SLIB_PARAM_AUDIOMAINSTREAM, /* Main Audio Stream (Systems+Program) */
  /* Common Codec Parameters */
  SLIB_PARAM_FASTENCODE=0x400,/* fast encoding desired */
  SLIB_PARAM_FASTDECODE,      /* fast decoding desired */
  SLIB_PARAM_KEYSPACING,      /* I frames */
  SLIB_PARAM_SUBKEYSPACING,   /* P frames */
  SLIB_PARAM_MOTIONALG=0x420, /* Motion estimation algorithm */
  SLIB_PARAM_MOTIONSEARCH,    /* Motion search limit */
  SLIB_PARAM_MOTIONTHRESH,    /* Motion threshold */
  SLIB_PARAM_ALGFLAGS,        /* Algorithm flags */
  SLIB_PARAM_FORMATEXT,       /* Format Extensions */
  SLIB_PARAM_QUANTI=0x480,    /* Intra-frame Quantization Step */
  SLIB_PARAM_QUANTP,          /* Inter-frame Quantization Step */
  SLIB_PARAM_QUANTB,          /* Bi-directional frame Quantization Step */
  SLIB_PARAM_QUANTD,          /* D (preview) frame Quantization Step */
  /* File/Stream Parameters */
  SLIB_PARAM_BITRATE=0x800,   /* overall bitrate */
  SLIB_PARAM_TIMECODE,        /* actual timecode */
  SLIB_PARAM_CALCTIMECODE,    /* calculated timecode - 0 based */
  SLIB_PARAM_FILESIZE,
  SLIB_PARAM_FILEBUFSIZE,     /* file read/write buffer size */
  SLIB_PARAM_PTIMECODE,       /* presentation timestamp */
  SLIB_PARAM_DTIMECODE,       /* decoding timestamp */
  SLIB_PARAM_PERCENT100,      /* position in 100th of percent units */
  /* Buffering/delay Parameters */
  SLIB_PARAM_VBVBUFFERSIZE=0x1000, /* Video Buffer Verifier buf size in bytes */
  SLIB_PARAM_VBVDELAY,        /* Video Buffer Verifier delay */
  SLIB_PARAM_PACKETSIZE,      /* Packet size (RTP) */
  SLIB_PARAM_MININPUTSIZE,    /* Minimum input sample size */
  SLIB_PARAM_INPUTSIZE,       /* Suggested input sample size */
  SLIB_PARAM_COMPBUFSIZE,     /* Slib Internal compressed buffer size */
  /* Stats Parameters */
  SLIB_PARAM_STATS=0x1800,    /* Turn stats recording on/off */
  SLIB_PARAM_STATS_RESET,     /* Reset stats */
  SLIB_PARAM_STATS_TIME,      /* Ellapsed time */
  SLIB_PARAM_STATS_FRAMES,    /* Frames encoded/decoded/skipped */
  SLIB_PARAM_STATS_FRAMESPROCESSED, /* Frames encoded/decoded */
  SLIB_PARAM_STATS_FRAMESSKIPPED,   /* Frames skipped */
  SLIB_PARAM_STATS_FPS,             /* Frames per second */
  /* Miscellaneous Parameters */
  SLIB_PARAM_CB_IMAGE=0x1C00, /* Turn image callbacks on/off */
  SLIB_PARAM_CB_TIMESTAMP,    /* Turn timestamp callbacks on/off */
} SlibParameter_t;

typedef enum {
  SLIB_CODEC_STATE_NONE,   /* codec is unopened */
  SLIB_CODEC_STATE_OPEN,   /* codec is opened */
  SLIB_CODEC_STATE_INITED, /* codec is opened and inited */
  SLIB_CODEC_STATE_BEGUN,  /* codec is opened, inited and begun */
  SLIB_CODEC_STATE_REPOSITIONING,  /* codec is opened, inited and begun,
                                      but stream is being repositioned */
} SlibCodecState_t;
/*
** Stream selections
*/
#define SLIB_STREAM_ALL       -1
#define SLIB_STREAM_MAINVIDEO  0
#define SLIB_STREAM_MAINAUDIO  1

typedef struct SlibQueryInfo_s {
  SlibType_t    Type;
  dword         HeaderStart;
  dword         HeaderSize;
  dword         Bitrate; /* overall bitrate */
  /* Video info */
  int           VideoStreams;
  short         Width;
  short         Height;
  dword         VideoBitrate;
  float         FramesPerSec;
  qword         VideoLength;
  /* Audio info */
  int           AudioStreams;
  unsigned int  SamplesPerSec;
  int           BitsPerSample;
  int           Channels;
  dword         AudioBitrate;
  qword         AudioLength;
} SlibQueryInfo_t;

#ifdef SLIB_INTERNAL
typedef struct SlibBuffer_s {
  qword          offset;
  unsigned dword size;
  unsigned char *address;
  SlibTime_t     time;
  struct SlibBuffer_s *next;
} SlibBuffer_t;

typedef struct SlibPin_s {
  int           ID;
  char          name[15];
  qword         Offset;
  SlibBuffer_t *Buffers;
  SlibBuffer_t *BuffersTail;
  dword         BufferCount;
  qword         DataSize;   /* total amount of data on pin */
  struct SlibPin_s *next;
} SlibPin_t;

typedef struct SlibStats_s {
  SlibBoolean_t Record;         /* stats recording on/off */
  SlibTime_t    StartTime;
  SlibTime_t    StopTime;
  qword         FramesProcessed;
  qword         FramesSkipped;
} SlibStats_t;

typedef struct SlibInfo_s {
  SlibType_t        Type;
  SlibMode_t        Mode;
  /* Handles */
  SvHandle_t        Svh; /* video */
  SaHandle_t        Sah; /* audio */
  SconHandle_t      Sch; /* conversion */
  SlibBoolean_t     NeedAccuracy;
  dword             TotalBitRate;/* overall bitrate: video+audio+mux */
  dword             MuxBitRate;  /* bitrate required by multiplexing codes */
  SlibTime_t        SystemTimeStamp; /* timestamp for next data on pins */
  int               VideoPID;    /* MPEG II Video Program ID */
  int               VideoMainStream; /* Main Stream used for video */
  SlibType_t        VideoType;   /* Video Stream type */
  /* Audio parameters */
  int               AudioStreams;
  unsigned int      SamplesPerSec;
  int               BitsPerSample;
  int               Channels;
  dword             AudioBitRate;
  int               AudioPID;    /* MPEG II Audio Program ID */
  int               AudioMainStream; /* Main Stream used for audio */
  SlibType_t        AudioType;   /* Audio Stream type */
  /* Video parameters */
  int               VideoStreams;
  word              Width;
  word              Height;
  dword             Stride;
  dword             VideoBitRate;
  float             FramesPerSec;
  /* Data Exchange */
  SlibPin_t        *Pins;
  int               PinCount;
  dword             Offset;
  SlibBoolean_t     IOError;       /* file read/write error - EOF */
  unsigned dword    MaxBytesInput; /* used with slibSetMaxInput */
  unsigned qword    InputMarker;   /* used with slibSetMaxInput */
  /* stream dependent stuff */
  SlibTime_t        VideoLength;
  SlibBoolean_t     VideoLengthKnown;
  SlibTime_t        VideoTimeStamp;     /* current video time */
  SlibTime_t        VideoFrameDuration; /* time between frames in 100th ms */
  qword             VideoFramesProcessed;/* frames processed since key points */
  SlibTime_t        AudioLength;
  SlibBoolean_t     AudioLengthKnown;
  SlibTime_t        AudioTimeStamp;     /* current audio time */
  SlibTime_t        LastAudioTimeStamp; /* used when compressing */
  int               KeySpacing;
  int               SubKeySpacing;
  SlibTime_t        AudioPTimeBase;     /* statring presentation timecode */
  SlibTime_t        AudioPTimeCode;     /* presentation timecode */
  SlibTime_t        AudioDTimeCode;     /* decoding timecode */
  SlibTime_t        LastAudioPTimeCode; /* last encoded decoding timecode */
  SlibTime_t        VideoPTimeBase;     /* starting presentation timecode */
  SlibTime_t        VideoPTimeCode;     /* presentation timecode */
  SlibTime_t        VideoDTimeCode;     /* decoding timecode */
  SlibTime_t        LastVideoPTimeCode; /* last encoded decoding timecode */
  SlibTime_t        LastVideoDTimeCode; /* last encoded decoding timecode */
  SlibTime_t        AvgVideoTimeDiff;   /* video times differences */
  SlibTime_t        VarVideoTimeDiff;   /* video times differences variation */
  unsigned qword    BytesProcessed;     /* bytes input or output */
  /* Encoding info */
  SlibBoolean_t     HeaderProcessed;
  int               PacketCount;
  unsigned qword    BytesSincePack;
  /* Miscellaneous */
  SlibMessage_t (*SlibCB)(SlibHandle_t,   /* Callback to supply Bufs */
             SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *);
  void             *SlibCBUserData;
  int               Fd;            /* file descriptor */
  unsigned qword    FileSize;      /* total file length in bytes */
  unsigned dword    FileBufSize;   /* file read/write buffer size */
  unsigned dword    CompBufSize;   /* compressed buffer size */    
  unsigned dword    PacketSize;    /* RTP */    
  BITMAPINFOHEADER *VideoFormat;
  WAVEFORMATEX     *AudioFormat;
  BITMAPINFOHEADER *CodecVideoFormat;
  BITMAPINFOHEADER *CompVideoFormat;
  WAVEFORMATEX     *CompAudioFormat;
  SlibBoolean_t     VideoCodecState;
  SlibBoolean_t     AudioCodecState;
  unsigned char    *Multibuf;      /* multiple image buffer - MPEG, H261 */
  dword             MultibufSize;
  unsigned char    *Imagebuf;      /* temp image buffer - for conversions */
  dword             ImageSize;
  unsigned char    *CodecImagebuf; /* temp image buffer - for scaling */
  dword             CodecImageSize;
  unsigned char    *IntImagebuf;   /* intermediate image buffer - for scaling */
  dword             IntImageSize;
  unsigned char    *Audiobuf;      /* temp audio buffer - for conversions */
  unsigned dword    AudiobufSize;  /* temp audio buffer - for conversions */
  unsigned dword    AudiobufUsed;  /* byte used in audio buffer */
  unsigned dword    OverflowSize;  /* max number of bytes on a stream */
  unsigned dword    VBVbufSize;    /* video buffer verifier size */
  SlibStats_t      *stats;
  void             *dbg;           /* debug handle */
} SlibInfo_t;

#define slibTimeToFrame(Info,stime) ((qword)((stime)*Info->FramesPerSec)/1000)
#define slibFrameToTime(Info,frame) \
             ((SlibTime_t)((float)(frame*1000)/Info->FramesPerSec))
#define slibFrameToTime100(Info,frame) \
             ((SlibTime_t)((float)(frame*100000)/Info->FramesPerSec))
#define slibHasAudio(Info) (Info->AudioStreams>0 || Info->Sah)
#define slibHasVideo(Info) (Info->VideoStreams>0 || Info->Svh)
#define slibHasTimeCode(Info) (slibHasVideo(Info) && SlibTypeIsMPEG(Info->Type))
#define slibInSyncMode(Info) (Info->Fd<0 && Info->SlibCB==NULL)
#endif /* SLIB_INTERNAL */

/********************** Public Prototypes ***********************/
/*
 * slib_api.c
 */
EXTERN SlibStatus_t SlibOpen(SlibHandle_t *handle, SlibMode_t smode,
                   SlibType_t *stype, SlibMessage_t (*slibCB)(SlibHandle_t,
                   SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *),
                    void *cbuserdata);
EXTERN SlibStatus_t SlibOpenSync(SlibHandle_t *handle, SlibMode_t smode, 
                          SlibType_t *stype, void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibOpenFile(SlibHandle_t *handle, SlibMode_t smode,
                                 SlibType_t *stype, char *filename);
EXTERN SlibStatus_t SlibAddBuffer(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibAddBufferEx(SlibHandle_t handle, SlibDataType_t dtype,
                                    void *buffer, unsigned dword bufsize,
                                    void *userdata);
EXTERN SlibStatus_t SlibRegisterVideoBuffer(SlibHandle_t handle,
                                void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibReadAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword *audiobufsize);
EXTERN SlibStatus_t SlibReadVideo(SlibHandle_t handle, SlibStream_t stream,
                      void **videobuf, unsigned dword *videobufsize);
EXTERN SlibStatus_t SlibWriteVideo(SlibHandle_t handle, SlibStream_t stream,
                      void *videobuf, unsigned dword videobufsize);
EXTERN SlibStatus_t SlibWriteAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword audiobufsize);
EXTERN SlibStatus_t SlibReadData(SlibHandle_t handle, SlibStream_t stream,
                          void **databuf, unsigned dword *databufsize,
                          SlibStream_t *readstream);
EXTERN SlibStatus_t SlibQueryData(void *databuf, unsigned dword databufsize,
                                  SlibQueryInfo_t *qinfo);

EXTERN SlibStatus_t SlibSeek(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t frame);
EXTERN SlibStatus_t SlibSeekEx(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t position,
                      SlibUnit_t units, SlibSeekInfo_t *seekinfo);
EXTERN SlibBoolean_t SlibIsEnd(SlibHandle_t handle, SlibStream_t stream);

EXTERN SlibStatus_t SlibClose(SlibHandle_t handle);

EXTERN char *SlibGetErrorText(SlibStatus_t status);
EXTERN SlibList_t *SlibQueryList(SlibQueryType_t qtype);
EXTERN char *SlibQueryForDesc(SlibQueryType_t qtype, int enumval);
EXTERN int   SlibQueryForEnum(SlibQueryType_t qtype, char *name);
EXTERN SlibList_t *SlibFindEnumEntry(SlibList_t *list, int enumval);
/*
 * slib_param.c
 */
EXTERN qword SlibGetFrameNumber(SlibHandle_t handle, SlibStream_t stream);
EXTERN SlibTime_t SlibGetAudioTime(SlibHandle_t handle, SlibStream_t stream);
EXTERN SlibTime_t SlibGetVideoTime(SlibHandle_t handle, SlibStream_t stream);

EXTERN SlibBoolean_t SlibCanSetParam(SlibHandle_t handle, SlibStream_t stream,
                                     SlibParameter_t param);
EXTERN SlibBoolean_t SlibCanGetParam(SlibHandle_t handle, SlibStream_t stream,
                                     SlibParameter_t param);
EXTERN SlibStatus_t SlibSetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, long value);
EXTERN SlibStatus_t SlibSetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, qword value);
EXTERN SlibStatus_t SlibSetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, float value);
EXTERN SlibStatus_t SlibSetParamBoolean(SlibHandle_t handle, 
                                 SlibStream_t stream,
                                 SlibParameter_t param, SlibBoolean_t value);
EXTERN SlibStatus_t SlibSetParamStruct(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param,
                                 void *data, unsigned dword datasize);

EXTERN long SlibGetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN qword SlibGetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN float SlibGetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN SlibBoolean_t SlibGetParamBoolean(SlibHandle_t handle,
                                 SlibStream_t stream, SlibParameter_t param);
EXTERN char *SlibGetParamString(SlibHandle_t handle, SlibStream_t stream,
                                              SlibParameter_t param);
EXTERN SlibStatus_t SlibValidateParams(SlibHandle_t handle);

/*
 * slib_buffer.c
 */
EXTERN void *SlibAllocBuffer(unsigned int bytes);
EXTERN void *SlibAllocBufferEx(SlibHandle_t handle, unsigned int bytes);
EXTERN void *SlibAllocSharedBuffer(unsigned int bytes, int *shmid);
EXTERN dword SlibGetSharedBufferID(void *address);
EXTERN SlibStatus_t SlibAllocSubBuffer(void *address,
                                        unsigned int bytes);
EXTERN SlibStatus_t SlibFreeBuffer(void *address);
EXTERN SlibStatus_t SlibFreeBuffers(SlibHandle_t handle);
EXTERN unsigned qword SlibMemUsed();

#ifdef SLIB_INTERNAL
/********************** Private Prototypes ***********************/
/*
 * slib_api.c
 */
SlibStatus_t slibStartVideo(SlibInfo_t *Info, SlibBoolean_t fillbuf);
SlibBoolean_t slibUpdatePositions(SlibInfo_t *Info, SlibBoolean_t exactonly);
void slibAdvancePositions(SlibInfo_t *Info, qword frames);
SlibBoolean_t slibUpdateLengths(SlibInfo_t *Info);


/*
 * slib_render.c
 */
SlibStatus_t slibConvertAudio(SlibInfo_t *Info,
                              void *inbuf, unsigned dword inbufsize,
                              unsigned int insps, unsigned int inbps,
                              void **poutbuf, unsigned dword *poutbufsize,
                              unsigned int outsps, unsigned int outbps,
                              unsigned int channels);
SlibStatus_t slibRenderFrame(SlibInfo_t *Info, void *inbuf,
                               unsigned dword informat, void **outbuf);

/*
 * slib_video.c
 */
void SlibUpdateVideoInfo(SlibInfo_t *Info);
SlibStatus_t slibValidateVideoParams(SlibInfo_t *Info);
int slibCalcBits(unsigned dword fourcc, int currentbits);

/*
 * slib_audio.c
 */
void SlibUpdateAudioInfo(SlibInfo_t *Info);
SlibTime_t slibSkipAudio(SlibInfo_t *Info, SlibStream_t stream,
                                           SlibTime_t timems);
SlibStatus_t slibValidateAudioParams(SlibInfo_t *Info);

/*
 * slib_buffer.c
 */
SlibBoolean_t SlibValidBuffer(void *address);
SlibStatus_t slibManageUserBuffer(SlibInfo_t *Info, void *address,
                                   unsigned int bytes, void *userdata);
unsigned char *SlibGetBuffer(SlibInfo_t *Info, int pinid,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *SlibPeekBuffer(SlibInfo_t *Info, int pinid,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *slibSearchBuffersOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                 unsigned char *lastbuf, unsigned dword *size,
                                 unsigned int code, int codebytes,
                                 ScBoolean_t discard);
SlibTime_t slibGetNextTimeOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword maxbytes);
void slibSetMaxInput(SlibInfo_t *Info, unsigned dword maxbytes);
SlibPosition_t slibGetPinPosition(SlibInfo_t *Info, int pinid);
SlibPosition_t slibSetPinPosition(SlibInfo_t *Info, int pinid,
                                                    SlibPosition_t pos);

void slibRemovePins(SlibInfo_t *Info);
void slibEmptyPins(SlibInfo_t *Info);
SlibPin_t *slibRenamePin(SlibInfo_t *Info, int oldpinid,
                                           int newpinid, char *newname);
SlibPin_t *slibGetPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibAddPin(SlibInfo_t *Info, int pinid, char *name);
SlibStatus_t slibAddBufferToPin(SlibPin_t *pin, void *buffer,
                                unsigned dword size, SlibTime_t time);
SlibStatus_t slibInsertBufferOnPin(SlibPin_t *pin, void *buffer,
                                unsigned dword size, SlibTime_t time);

SlibStatus_t slibRemovePin(SlibInfo_t *Info, int pinid);
SlibStatus_t slibEmptyPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibLoadPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibPreLoadPin(SlibInfo_t *Info, SlibPin_t *pin);
SlibStatus_t slibPutBuffer(SlibInfo_t *Info, unsigned char *buffer,
                                             unsigned dword bufsize);
qword slibDataOnPin(SlibInfo_t *Info, int pinid);
qword slibDataOnPins(SlibInfo_t *Info);
unsigned char *slibGetBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *slibPeekBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword *size, SlibTime_t *time);
unsigned char *slibPeekNextBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                       unsigned char *lastbuffer,
                                       unsigned dword *size, SlibTime_t *time);
unsigned int slibFillBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                           unsigned char *fillbuf, unsigned dword bufsize,
                           SlibTime_t *time);
word slibGetWordFromPin(SlibInfo_t *Info, SlibPin_t *pin);
dword slibGetDWordFromPin(SlibInfo_t *Info, SlibPin_t *pin);
dword slibCountCodesOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                        unsigned int code, int codebytes,
                        unsigned dword maxlen);
SlibStatus_t slibReposition(SlibInfo_t *Info, SlibPosition_t position);
void slibPinPrepareReposition(SlibInfo_t *Info, int pinid);
void slibPinFinishReposition(SlibInfo_t *Info, int pinid);
SlibBoolean_t slibCommitBuffers(SlibInfo_t *Info, SlibBoolean_t flush);
void slibValidateBitrates(SlibInfo_t *Info);
qword slibGetSystemTime();
#endif /* SLIB_INTERNAL */

#endif /* _SLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sv_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_api.c,v $
 * Revision 1.1.8.11  1996/10/28  17:32:51  Hans_Graves
 * 	MME-01402. Changed SvGet/SetParamInt() to qwords to allow for timestamps.
 * 	[1996/10/28  17:09:33  Hans_Graves]
 *
 * Revision 1.1.8.10  1996/10/12  17:19:24  Hans_Graves
 * 	Added initialization of SV_PARAM_SKIPPEL and SV_PARAM_HALFPEL to MPEG encode.
 * 	[1996/10/12  17:16:28  Hans_Graves]
 * 
 * Revision 1.1.8.9  1996/09/29  22:19:56  Hans_Graves
 * 	Added stride to ScYuv411ToRgb() calls.
 * 	[1996/09/29  21:34:40  Hans_Graves]
 * 
 * Revision 1.1.8.8  1996/09/25  19:17:01  Hans_Graves
 * 	Fix up support for YUY2 under MPEG.
 * 	[1996/09/25  19:03:17  Hans_Graves]
 * 
 * Revision 1.1.8.7  1996/09/18  23:51:11  Hans_Graves
 * 	Added JPEG 4:1:1 to 4:2:2 conversions. Added BI_YVU9SEP and BI_RGB 24 support in MPEG decode.
 * 	[1996/09/18  22:16:08  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/07/30  20:25:50  Wei_Hsu
 * 	Add Logarithmetic search for motion estimation.
 * 	[1996/07/30  15:57:59  Wei_Hsu]
 * 
 * Revision 1.1.8.5  1996/05/24  22:22:26  Hans_Graves
 * 	Add GetImageSize MPEG support for BI_DECYUVDIB
 * 	[1996/05/24  22:14:20  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/05/08  16:24:32  Hans_Graves
 * 	Put BITSTREAM_SUPPORT around BSIn in SvDecompress
 * 	[1996/05/08  16:24:15  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/05/07  21:24:05  Hans_Graves
 * 	Add missing break in switch statement in SvRegisterCallback
 * 	[1996/05/07  21:19:50  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:56:46  Hans_Graves
 * 	Added HUFF_SUPPORT.  Remove NT warnings.
 * 	[1996/05/07  17:27:18  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/04/23  18:51:10  Karen_Dintino
 * 	Fix the memory alloc for the ref buffer for WIN32
 * 	[1996/04/23  18:49:23  Karen_Dintino]
 * 
 * Revision 1.1.6.11  1996/04/17  23:44:35  Karen_Dintino
 * 	added initializations for H.261/WIN32
 * 	[1996/04/17  23:43:20  Karen_Dintino]
 * 
 * Revision 1.1.6.10  1996/04/11  22:54:43  Karen_Dintino
 * 	added casting for in SetFrameRate
 * 	[1996/04/11  22:52:29  Karen_Dintino]
 * 
 * Revision 1.1.6.9  1996/04/11  14:14:14  Hans_Graves
 * 	Fix NT warnings
 * 	[1996/04/11  14:09:53  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/10  21:48:09  Hans_Graves
 * 	Added SvGet/SetBoolean() functions.
 * 	[1996/04/10  21:28:13  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/09  20:50:44  Karen_Dintino
 * 	Adding WIN32 support
 * 	[1996/04/09  20:47:26  Karen_Dintino]
 * 
 * Revision 1.1.6.6  1996/04/09  16:05:00  Hans_Graves
 * 	Add some abs() around height params. SvRegisterCallback() cleanup
 * 	[1996/04/09  15:39:31  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/04  23:35:27  Hans_Graves
 * 	Removed BI_YU16SEP support from MPEG decomp.
 * 	[1996/04/04  23:12:02  Hans_Graves]
 * 
 * 	Fixed up Multibuf size (MPEG) related stuff
 * 	[1996/04/04  23:08:55  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/01  15:17:47  Bjorn_Engberg
 * 	Got rid of a compiler warning.
 * 	[1996/04/01  15:02:35  Bjorn_Engberg]
 * 
 * Revision 1.1.6.3  1996/03/29  22:22:36  Hans_Graves
 * 	-Added JPEG_SUPPORT ifdefs.
 * 	-Changed JPEG related structures to fit naming conventions.
 * 	[1996/03/29  21:59:08  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/16  20:13:51  Karen_Dintino
 * 	Adding NT port changes for H.261
 * 	[1996/03/16  19:48:31  Karen_Dintino]
 * 
 * Revision 1.1.4.12  1996/02/26  18:42:32  Karen_Dintino
 * 	fix PTT 01106 server crash in ICCompress
 * 	[1996/02/26  18:41:33  Karen_Dintino]
 * 
 * Revision 1.1.4.11  1996/02/22  17:35:19  Bjorn_Engberg
 * 	Added support for JPEG Mono to BI_BITFIELDS 16 decompression on NT.
 * 	[1996/02/22  17:34:53  Bjorn_Engberg]
 * 
 * Revision 1.1.4.10  1996/02/08  13:48:44  Bjorn_Engberg
 * 	Get rid of int to float compiler warning.
 * 	[1996/02/08  13:48:20  Bjorn_Engberg]
 * 
 * Revision 1.1.4.9  1996/02/07  23:24:08  Hans_Graves
 * 	MPEG Key frame stats initialization
 * 	[1996/02/07  23:14:41  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/02/06  22:54:17  Hans_Graves
 * 	Added SvGet/SetParam functions
 * 	[1996/02/06  22:51:19  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/01/08  20:19:33  Bjorn_Engberg
 * 	Got rid of more compiler warnings.
 * 	[1996/01/08  20:19:13  Bjorn_Engberg]
 * 
 * Revision 1.1.4.6  1996/01/08  16:42:47  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:41:37  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/01/02  18:32:14  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts, Removed unused variables.
 * 	[1996/01/02  17:26:21  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1995/12/28  18:40:06  Bjorn_Engberg
 * 	IsSupported() sometimes returned garbage and thus a false match.
 * 	SvDecompressQuery() and SvCompressQuery() were using the
 * 	wrong lookup tables.
 * 	[1995/12/28  18:39:30  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1995/12/08  20:01:30  Hans_Graves
 * 	Added SvSetRate() and SvSetFrameRate() to H.261 compression open
 * 	[1995/12/08  19:58:32  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:32:17  Hans_Graves
 * 	Added MPEG I & II Encoding support
 * 	[1995/12/07  18:43:45  Hans_Graves]
 * 
 * Revision 1.1.2.46  1995/11/30  20:17:06  Hans_Graves
 * 	Added BI_DECGRAYDIB handling for JPEG decompression, used with Mono JPEG
 * 	[1995/11/30  20:12:24  Hans_Graves]
 * 
 * Revision 1.1.2.45  1995/11/29  17:53:26  Hans_Graves
 * 	Added JPEG_DIB 8-bit to BI_DECGRAYDIB as supported format
 * 	[1995/11/29  17:53:00  Hans_Graves]
 * 
 * Revision 1.1.2.44  1995/11/28  22:47:33  Hans_Graves
 * 	Added BI_BITFIELDS as supported decompression format for H261 and MPEG
 * 	[1995/11/28  22:39:25  Hans_Graves]
 * 
 * Revision 1.1.2.43  1995/11/17  21:31:28  Hans_Graves
 * 	Added checks on ImageSize in SvDecompress()
 * 	[1995/11/17  21:27:19  Hans_Graves]
 * 
 * 	Query cleanup - Added lookup tables for supportted formats
 * 	[1995/11/17  20:53:54  Hans_Graves]
 * 
 * Revision 1.1.2.42  1995/11/03  16:36:25  Paul_Gauthier
 * 	Reject requests to scale MPEG input during decompression
 * 	[1995/11/03  16:34:01  Paul_Gauthier]
 * 
 * Revision 1.1.2.41  1995/10/25  18:19:22  Bjorn_Engberg
 * 	What was allocated with ScPaMalloc() must be freed with ScPaFree().
 * 	[1995/10/25  18:02:04  Bjorn_Engberg]
 * 
 * Revision 1.1.2.40  1995/10/25  17:38:04  Hans_Graves
 * 	Removed some memory freeing calls on image memory in SvCloseCodec for H261 decoding.  The app allocates the image buffer.
 * 	[1995/10/25  17:37:35  Hans_Graves]
 * 
 * Revision 1.1.2.39  1995/10/13  16:57:19  Bjorn_Engberg
 * 	Added a cast to get rid of a compiler warning.
 * 	[1995/10/13  16:56:29  Bjorn_Engberg]
 * 
 * Revision 1.1.2.38  1995/10/06  20:51:47  Farokh_Morshed
 * 	Enhance to handle BI_BITFIELDS for input to compression
 * 	[1995/10/06  20:49:10  Farokh_Morshed]
 * 
 * Revision 1.1.2.37  1995/10/02  19:31:03  Bjorn_Engberg
 * 	Clarified what formats are supported and not.
 * 	[1995/10/02  18:51:49  Bjorn_Engberg]
 * 
 * Revision 1.1.2.36  1995/09/28  20:40:09  Farokh_Morshed
 * 	Handle negative Height
 * 	[1995/09/28  20:39:45  Farokh_Morshed]
 * 
 * Revision 1.1.2.35  1995/09/26  17:49:47  Paul_Gauthier
 * 	Fix H.261 output conversion to interleaved YUV
 * 	[1995/09/26  17:49:20  Paul_Gauthier]
 * 
 * Revision 1.1.2.34  1995/09/26  15:58:44  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:16  Paul_Gauthier]
 * 
 * Revision 1.1.2.33  1995/09/25  21:18:14  Paul_Gauthier
 * 	Added interleaved YUV output to decompression
 * 	[1995/09/25  21:17:42  Paul_Gauthier]
 * 
 * Revision 1.1.2.32  1995/09/22  12:58:50  Bjorn_Engberg
 * 	More NT porting work; Added MPEG_SUPPORT and H261_SUPPORT.
 * 	[1995/09/22  12:26:14  Bjorn_Engberg]
 * 
 * Revision 1.1.2.31  1995/09/20  19:35:02  Hans_Graves
 * 	Cleaned-up debugging statements
 * 	[1995/09/20  19:33:07  Hans_Graves]
 * 
 * Revision 1.1.2.30  1995/09/20  18:22:53  Karen_Dintino
 * 	Free temp buffer after convert
 * 	[1995/09/20  18:22:37  Karen_Dintino]
 * 
 * Revision 1.1.2.29  1995/09/20  17:39:22  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.27 **}
 * 		{** Merge revision:	1.1.2.28 **}
 * 	{** End **}
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:41  Karen_Dintino]
 * 
 * Revision 1.1.2.28  1995/09/20  15:00:03  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:43:15  Bjorn_Engberg]
 * 
 * Revision 1.1.2.27  1995/09/13  19:42:44  Paul_Gauthier
 * 	Added TGA2 support (direct 422 interleaved output from JPEG codec
 * 	[1995/09/13  19:15:47  Paul_Gauthier]
 * 
 * Revision 1.1.2.26  1995/09/11  18:53:45  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.24 **}
 * 		{** Merge revision:	1.1.2.25 **}
 * 	{** End **}
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:52:08  Farokh_Morshed]
 * 
 * Revision 1.1.2.25  1995/09/05  14:05:01  Paul_Gauthier
 * 	Add ICMODE_OLDQ flag on ICOpen for softjpeg to use old quant tables
 * 	[1995/08/31  20:58:06  Paul_Gauthier]
 * 
 * Revision 1.1.2.24  1995/08/16  19:56:46  Hans_Graves
 * 	Fixed RELEASE_BUFFER callbacks for Images
 * 	[1995/08/16  19:54:40  Hans_Graves]
 * 
 * Revision 1.1.2.23  1995/08/15  19:14:18  Karen_Dintino
 * 	pass H261 struct to inithuff & freehuff
 * 	[1995/08/15  19:10:58  Karen_Dintino]
 * 
 * Revision 1.1.2.22  1995/08/14  19:40:36  Hans_Graves
 * 	Add CB_CODEC_DONE callback. Fixed Memory allocation and freeing under H261.
 * 	[1995/08/14  18:45:22  Hans_Graves]
 * 
 * Revision 1.1.2.21  1995/08/04  17:22:49  Hans_Graves
 * 	Make END_SEQ callback happen after any H261 decompress error.
 * 	[1995/08/04  17:20:55  Hans_Graves]
 * 
 * Revision 1.1.2.20  1995/08/04  16:32:46  Karen_Dintino
 * 	Free Huffman codes on end of Encode and Decode
 * 	[1995/08/04  16:25:59  Karen_Dintino]
 * 
 * Revision 1.1.2.19  1995/07/31  21:11:14  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.17 **}
 * 		{** Merge revision:	1.1.2.18 **}
 * 	{** End **}
 * 	Add 411YUVSEP Support
 * 	[1995/07/31  20:41:28  Karen_Dintino]
 * 
 * Revision 1.1.2.18  1995/07/31  20:19:58  Hans_Graves
 * 	Set Format parameter in Frame callbacks
 * 	[1995/07/31  20:16:06  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/07/28  20:58:40  Hans_Graves
 * 	Added Queue debugging messages.
 * 	[1995/07/28  20:49:15  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/07/28  17:36:10  Hans_Graves
 * 	Fixed up H261 Compression and Decompression.
 * 	[1995/07/28  17:26:17  Hans_Graves]
 * 
 * Revision 1.1.2.15  1995/07/27  18:28:55  Hans_Graves
 * 	Fixed AddBuffer() so it works with H261.
 * 	[1995/07/27  18:24:37  Hans_Graves]
 * 
 * Revision 1.1.2.14  1995/07/26  17:49:04  Hans_Graves
 * 	Fixed SvCompressBegin() JPEG initialization.  Added ImageQ support.
 * 	[1995/07/26  17:41:24  Hans_Graves]
 * 
 * Revision 1.1.2.13  1995/07/25  22:00:33  Hans_Graves
 * 	     Fixed H261 image size logic in SvCompressQuery().
 * 	     [1995/07/25  21:59:08  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/07/21  17:41:20  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:26:11  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/18  17:26:56  Hans_Graves
 * 	Fixed QCIF width parameter checking.
 * 	[1995/07/18  17:24:55  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/07/17  22:01:45  Hans_Graves
 * 	Removed defines for CIF_WIDTH, CIF_HEIGHT, etc.
 * 	[1995/07/17  21:48:51  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/17  16:12:37  Hans_Graves
 * 	H261 Cleanup.
 * 	[1995/07/17  15:50:51  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/12  19:48:30  Hans_Graves
 * 	Fixed up some H261 Queue/Callback bugs.
 * 	[1995/07/12  19:31:51  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/11  22:12:00  Karen_Dintino
 * 	Add SvCompressQuery, SvDecompressQuery support
 * 	[1995/07/11  21:57:21  Karen_Dintino]
 * 
 * Revision 1.1.2.6  1995/07/01  18:43:49  Karen_Dintino
 * 	Add support for H.261 Decompress
 * 	[1995/07/01  18:26:18  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/06/19  20:31:51  Karen_Dintino
 * 	Adding support for H.261 Codec
 * 	[1995/06/19  19:25:27  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/06/09  18:33:34  Hans_Graves
 * 	Added SvGetInputBitstream(). Changed SvDecompressBegin() to handle NULL Image formats.
 * 	[1995/06/09  16:35:29  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/05  21:07:20  Hans_Graves
 * 	Fixed logic in SvRegisterCallback().
 * 	[1995/06/05  20:04:30  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:12:42  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  17:18:53  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/02/02  19:26:01  Paul_Gauthier
 * 	Fix to blank bottom strip & server crash for softjpeg compress
 * 	[1995/02/02  19:12:58  Paul_Gauthier]
 * 
 * Revision 1.1.2.9  1995/01/20  21:45:57  Jim_Ludwig
 * 	Add support for 16 bit YUV
 * 	[1995/01/20  21:28:49  Jim_Ludwig]
 * 
 * Revision 1.1.2.8  1994/12/12  15:38:54  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:34:21  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/11/18  18:48:36  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:44:02  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/10/28  19:56:30  Paul_Gauthier
 * 	Additional Clean Up
 * 	[1994/10/28  19:54:35  Paul_Gauthier]
 * 
 * Revision 1.1.2.5  1994/10/17  19:03:28  Paul_Gauthier
 * 	Fixed reversed Quality scale
 * 	[1994/10/17  19:02:50  Paul_Gauthier]
 * 
 * Revision 1.1.2.4  1994/10/13  20:34:27  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/13  20:23:23  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/10  21:45:50  Tom_Morris
 * 	Rename Status to not conflict with X11
 * 	[1994/10/10  21:44:16  Tom_Morris]
 * 
 * Revision 1.1.2.2  1994/10/07  14:39:25  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:53:40  Paul_Gauthier]
 * 
 * 	******************************************************************
 * 	Changes from original brance merged into this file 11/30/94 PSG
 * 	******************************************************************
 * 	Revision 1.1.2.10  1994/08/11  21:27:24  Leela_Obilichetti
 * 	Added in width and height checks into SvDecompressQuery and SvCompressQuery.
 * 	[1994/08/11  21:03:38  Leela_Obilichetti]
 * 
 * Revision 1.1.2.9  1994/08/09  18:52:40  Ken_Chiquoine
 * 	set mode type in decode as well as encode
 * 	[1994/08/09  18:52:17  Ken_Chiquoine]
 * 
 * Revision 1.1.2.8  1994/08/04  22:06:33  Leela_Obilichetti
 * 	oops, removed fprintf.
 * 	[1994/08/04  21:54:11  Leela_Obilichetti]
 * 
 * Revision 1.1.2.7  1994/08/04  21:34:04  Leela_Obilichetti
 * 	v1 drop.
 * 	[1994/08/04  21:05:01  Leela_Obilichetti]
 * 
 * Revision 1.1.2.6  1994/07/15  23:31:43  Leela_Obilichetti
 * 	added new stuff for compression - v4 of SLIB.
 * 	[1994/07/15  23:29:17  Leela_Obilichetti]
 * 
 * Revision 1.1.2.5  1994/06/08  16:44:28  Leela_Obilichetti
 * 	fixes for YUV_to_RGB for OSF/1.  Haven't tested on Microsoft.
 * 	[1994/06/08  16:42:46  Leela_Obilichetti]
 * 
 * Revision 1.1.2.4  1994/06/03  21:11:14  Leela_Obilichetti
 * 	commment out the code to let in DECYUVDIB
 * 	free memory that is allocated for YUV
 * 	add in code to convert from DECSEPYUV to DECYUV -
 * 		shouldn't get there since se don't allow YUV anymore
 * 	[1994/06/03  21:03:42  Leela_Obilichetti]
 * 
 * Revision 1.1.2.3  1994/05/11  21:02:17  Leela_Obilichetti
 * 	bug fix for NT
 * 	[1994/05/11  20:56:16  Leela_Obilichetti]
 * 
 * Revision 1.1.2.2  1994/05/09  22:06:07  Leela_Obilichetti
 * 	V3 drop
 * 	[1994/05/09  21:51:30  Leela_Obilichetti]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*-------------------------------------------------------------------------
 * Modification History: sv_api.c
 *
 *      08-Sep-94  PSG   Added MPEG decode support
 *	29-Jul-94  VB    Added restrictions for compression
 *      21-Jul-94  VB	 Rewrote/cleaned up sections of JPEG decompression
 *      13-Jul-94  PSG   Added support for encode/decode of grayscale only
 *      07-Jul-94  PSG   Converted to single Info structure (cmp/dcmp)
 *	14-Jun-94  VB	 Added JPEG compression support
 *      08-Jun-94  PSG   Added support for BI_DECXIMAGEDIB (B,G,R,0)
 *      06-Jun-94  PSG   Bring code up to SLIB v0.04 spec
 *	15-Apr-94  VB	 Added support for 24-bit,16-bit and 15-bit RGB output 
 *      24-Feb-94  PSG   Bring code up to SLIB v0.02 spec
 *      20-Jan-94  PSG   added a number of new SLIB routines
 *	12-Jan-94  VB    Created (from SLIB spec.) 
 *	
 *   Author(s):
 *	 VB - Victor Bahl
 *	PSG - Paul Gauthier
 --------------------------------------------------------------------------*/


/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "SV.h"
#include "sv_intrn.h"
#ifdef JPEG_SUPPORT
/*
 *  More JPEG code needs to be moved to sv_jpeg_init file
 */
#include "sv_jpeg_tables.h"
#endif /* JPEG_SUPPORT */
#include "sv_proto.h"
#include "SC.h"
#include "SC_conv.h"
#include "SC_err.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    0  /* warnings about strange behavior */
#endif

static void sv_copy_bmh (
    BITMAPINFOHEADER *ImgFrom, 
    BITMAPINFOHEADER *ImgTo);

typedef struct SupportList_s {
  int   InFormat;   /* Input format */
  int   InBits;     /* Input number of bits */
  int   OutFormat;  /* Output format */
  int   OutBits;    /* Output number of bits */
} SupportList_t;

/*
** Input & Output Formats supported by SLIB Compression
*/
static SupportList_t _SvCompressionSupport[] = {
  BI_DECYUVDIB,        16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_DECYUVDIB,        16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_DECYUVDIB,        16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_S422,             16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_S422,             16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_S422,             16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_BITFIELDS,        32, JPEG_DIB,             8, /* BITFIELDS */
  BI_BITFIELDS,        32, JPEG_DIB,            24, /* BITFIELDS */
  BI_BITFIELDS,        32, MJPG_DIB,            24, /* BITFIELDS */
  BI_DECSEPRGBDIB,     32, JPEG_DIB,             8, /* RGB 32 Planar */
  BI_DECSEPRGBDIB,     32, JPEG_DIB,            24, /* RGB 32 Planar */
  BI_DECSEPRGBDIB,     32, MJPG_DIB,            24, /* RGB 32 Planar */
#ifdef WIN32
  BI_RGB,              24, JPEG_DIB,             8, /* RGB 24 */
  BI_RGB,              24, JPEG_DIB,            24, /* RGB 24 */
  BI_RGB,              24, MJPG_DIB,            24, /* RGB 24 */
  BI_RGB,              32, JPEG_DIB,             8, /* RGB 32 */
  BI_RGB,              32, JPEG_DIB,            24, /* RGB 32 */
  BI_RGB,              32, MJPG_DIB,            24, /* RGB 32 */
#endif /* WIN32 */
#ifndef WIN32
  BI_DECGRAYDIB,        8, JPEG_DIB,             8, /* Gray 8 */
  BI_DECXIMAGEDIB,     24, JPEG_DIB,             8, /* XIMAGE 24 */
  BI_DECXIMAGEDIB,     24, JPEG_DIB,            24, /* XIMAGE 24 */
  BI_DECXIMAGEDIB,     24, MJPG_DIB,            24, /* XIMAGE 24 */
#endif /* !WIN32 */
#ifdef H261_SUPPORT
  BI_DECYUVDIB,        16, BI_DECH261DIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECH261DIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECH261DIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECH261DIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECH261DIB,       24, /* YUV 4:2:2 Planar */
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  BI_DECYUVDIB,        16, BI_DECH263DIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECH263DIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECH263DIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECH263DIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECH263DIB,       24, /* YUV 4:2:2 Planar */
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECYUVDIB,        16, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECMPEGDIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECMPEGDIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Planar */
  BI_YVU9SEP,          24, BI_DECMPEGDIB,       24, /* YUV 16:1:1 Planar */
  BI_RGB,              24, BI_DECMPEGDIB,       24, /* RGB 24 */
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
  BI_DECYUVDIB,        16, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECHUFFDIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECHUFFDIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Planar */
#endif /* HUFF_SUPPORT */
  0, 0, 0, 0
};

/*
** Input & Output Formats supported by SLIB Decompression
*/
static SupportList_t _SvDecompressionSupport[] = {
#ifdef JPEG_SUPPORT
  JPEG_DIB,             8, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  JPEG_DIB,            24, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  MJPG_DIB,            24, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  JPEG_DIB,             8, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  JPEG_DIB,            24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  MJPG_DIB,            24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  JPEG_DIB,             8, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  JPEG_DIB,            24, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  MJPG_DIB,            24, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  JPEG_DIB,             8, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  JPEG_DIB,            24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  MJPG_DIB,            24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  JPEG_DIB,             8, BI_BITFIELDS,        32, /* BITFIELDS */
  JPEG_DIB,            24, BI_BITFIELDS,        32, /* BITFIELDS */
  MJPG_DIB,            24, BI_BITFIELDS,        32, /* BITFIELDS */
  JPEG_DIB,             8, BI_DECGRAYDIB,        8, /* Gray 8 */
#endif /* JPEG_SUPPORT */

#ifdef WIN32
  JPEG_DIB,             8, BI_RGB,              16, /* RGB 16 */
  JPEG_DIB,            24, BI_RGB,              16, /* RGB 16 */
  MJPG_DIB,            24, BI_RGB,              16, /* RGB 16 */
  JPEG_DIB,             8, BI_RGB,              24, /* RGB 24 */
  JPEG_DIB,            24, BI_RGB,              24, /* RGB 24 */
  MJPG_DIB,            24, BI_RGB,              24, /* RGB 24 */
  JPEG_DIB,             8, BI_RGB,              32, /* RGB 32 */
  JPEG_DIB,            24, BI_RGB,              32, /* RGB 32 */
  MJPG_DIB,            24, BI_RGB,              32, /* RGB 32 */
  JPEG_DIB,             8, BI_BITFIELDS,        16, /* BITFIELDS */
#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_RGB,              16, /* RGB 16 */
  BI_DECH261DIB,       24, BI_RGB,              24, /* RGB 24 */
  BI_DECH261DIB,       24, BI_RGB,              32, /* RGB 32 */
#endif /* H261_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_RGB,              16, /* RGB 16 */
  BI_DECMPEGDIB,       24, BI_RGB,              24, /* RGB 24 */
  BI_DECMPEGDIB,       24, BI_RGB,              32, /* RGB 32 */
#endif /* MPEG_SUPPORT */
#endif /* WIN32 */

#ifndef WIN32
  JPEG_DIB,             8, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
  JPEG_DIB,            24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
  MJPG_DIB,            24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#endif /* H261_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#endif /* MPEG_SUPPORT */
#endif /* !WIN32 */

#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECH261DIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECH261DIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
  BI_DECH261DIB,       24, BI_BITFIELDS,        32, /* BITFIELDS */
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  BI_DECH263DIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECH263DIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECH263DIB,       24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  BI_DECH263DIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECMPEGDIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECMPEGDIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
  BI_DECMPEGDIB,       24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  BI_DECMPEGDIB,       24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  BI_DECMPEGDIB,       24, BI_BITFIELDS,        32, /* BITFIELDS */
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
  BI_DECHUFFDIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECHUFFDIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECHUFFDIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
#endif /* HUFF_SUPPORT */
  0, 0, 0, 0
};

/*
** Name: IsSupported
** Desc: Lookup the a given input and output format to see if it
**       exists in a SupportList.
** Note: If OutFormat==-1 and OutBits==-1 then only input format
**          is checked for support.
**       If InFormat==-1 and InBits==-1 then only output format
**          is checked for support.
** Return: NULL       Formats not supported.
**         not NULL   A pointer to the list entry.
*/
static SupportList_t *IsSupported(SupportList_t *list,
                                  int InFormat, int InBits,
                                  int OutFormat, int OutBits)
{
  if (OutFormat==-1 && OutBits==-1) /* Looking up only the Input format */
  {
    while (list->InFormat || list->InBits)
      if (list->InFormat == InFormat && list->InBits==InBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  if (InFormat==-1 && InBits==-1) /* Looking up only the Output format */
  {
    while (list->InFormat || list->InBits)
      if (list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  /* Looking up both Input and Output */
  while (list->InFormat || list->InBits)
    if (list->InFormat == InFormat && list->InBits==InBits &&
         list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
    else
      list++;
  return(NULL);
}

/*
** Name:     SvOpenCodec
** Purpose:  Open the specified codec. Return stat code.
**
** Args:     CodecType = i.e. SV_JPEG_ENCODE, SV_JPEG_DECODE, etc.
**           Svh = handle to software codec's Info structure.
*/
SvStatus_t SvOpenCodec (SvCodecType_e CodecType, SvHandle_t *Svh)
{
   SvCodecInfo_t *Info = NULL;
   _SlibDebug(_DEBUG_, printf("SvOpenCodec()\n") );

   /* check if CODEC is supported */
   switch (CodecType)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
     case SV_JPEG_ENCODE:
           break;
#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
     case SV_H261_ENCODE:
     case SV_H261_DECODE:
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
     case SV_H263_ENCODE:
     case SV_H263_DECODE:
           break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_ENCODE:
     case SV_MPEG_DECODE:
     case SV_MPEG2_ENCODE:
     case SV_MPEG2_DECODE:
           break;
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
     case SV_HUFF_ENCODE:
     case SV_HUFF_DECODE:
           break;
#endif /* HUFF_SUPPORT */
     default:
           return(SvErrorCodecType);
   }
     
   if (!Svh)
     return (SvErrorBadPointer);

   /*
   ** Allocate memory for the Codec Info structure:
   */
   if ((Info = (SvCodecInfo_t *) ScAlloc(sizeof(SvCodecInfo_t))) == NULL) 
       return (SvErrorMemory);
   memset (Info, 0, sizeof(SvCodecInfo_t));
   Info->BSIn=NULL;
   Info->BSOut=NULL;
   Info->mode = CodecType;
   Info->started = FALSE;

   /*
   ** Allocate memory for Info structure and clear it
   */
   switch (CodecType)
   {
#ifdef JPEG_SUPPORT
       case SV_JPEG_DECODE:
            if ((Info->jdcmp = (SvJpegDecompressInfo_t *) 
	        ScAlloc(sizeof(SvJpegDecompressInfo_t))) == NULL) 
              return(SvErrorMemory);
            memset (Info->jdcmp, 0, sizeof(SvJpegDecompressInfo_t));
            break;

       case SV_JPEG_ENCODE:
            if ((Info->jcomp = (SvJpegCompressInfo_t *)
	                      ScAlloc(sizeof(SvJpegCompressInfo_t))) == NULL) 
              return (SvErrorMemory);
            memset (Info->jcomp, 0, sizeof(SvJpegCompressInfo_t));
            break;
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
       case SV_MPEG_DECODE:
       case SV_MPEG2_DECODE:
            if ((Info->mdcmp = (SvMpegDecompressInfo_t *)
                ScAlloc(sizeof(SvMpegDecompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->mdcmp, 0, sizeof(SvMpegDecompressInfo_t));
            Info->mdcmp->timecode0 = 0;
            Info->mdcmp->timecode_state = MPEG_TIMECODE_START;
            Info->mdcmp->timecodefps = 0.0F;
            Info->mdcmp->fps = 0.0F;
            Info->mdcmp->twostreams = 0;
            Info->mdcmp->verbose=FALSE;
            Info->mdcmp->quiet=TRUE;
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_MPEG_ENCODE:
       case SV_MPEG2_ENCODE:
            if ((Info->mcomp = (SvMpegCompressInfo_t *)
                ScAlloc(sizeof(SvMpegCompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->mcomp, 0, sizeof(SvMpegCompressInfo_t));
            Info->mcomp->quiet=1;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            SvSetParamBoolean((SvHandle_t)Info, SV_PARAM_FASTENCODE, FALSE);
            SvSetParamBoolean((SvHandle_t)Info, SV_PARAM_FASTDECODE, FALSE);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS,
                                               PARAM_ALGFLAG_HALFPEL);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 1152000);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)25.0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_KEYSPACING, 12);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_SUBKEYSPACING, 4);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
       case SV_H261_DECODE:
            if ((Info->h261 = (SvH261Info_t *)
                  ScAlloc(sizeof(SvH261Info_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h261, 0, sizeof(SvH261Info_t));
            Info->h261->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_H261_ENCODE:
            if ((Info->h261 = (SvH261Info_t *)
                  ScAlloc(sizeof(SvH261Info_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h261, 0, sizeof(SvH261Info_t));
            Info->h261->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, ME_BRUTE);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONSEARCH, 5);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONTHRESH, 600);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 352000);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTI, 10); /* for VBR */
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTP, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_PACKETSIZE, 512);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)15.0);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
       case SV_H263_DECODE:
            if ((Info->h263dcmp = (SvH263DecompressInfo_t *)
                  ScAlloc(sizeof(SvH263DecompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h263dcmp, 0, sizeof(SvH263DecompressInfo_t));
            Info->h263dcmp->inited=FALSE;
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_H263_ENCODE:
            if ((Info->h263comp = (SvH263CompressInfo_t *)
                  ScAlloc(sizeof(SvH263CompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h263comp, 0, sizeof(SvH263CompressInfo_t));
            Info->h263comp->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 0);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)30.0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_PACKETSIZE, 512);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTI, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTP, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_KEYSPACING, 120);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
       case SV_HUFF_DECODE:
       case SV_HUFF_ENCODE:
            if ((Info->huff = (SvHuffInfo_t *)
                  ScAlloc(sizeof(SvHuffInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->huff, 0, sizeof(SvHuffInfo_t));
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* HUFF_SUPPORT */
   }
   *Svh = (SvHandle_t) Info;        /* Return handle */
   _SlibDebug(_DEBUG_, printf("SvOpenCodec() returns Svh=%p\n", *Svh) );

   return(NoErrors);
}




/*
** Name:     SvCloseCodec
** Purpose:  Closes the specified codec. Free the Info structure
**
** Args:     Svh = handle to software codec's Info structure.
**
** XXX - needs to change since now we have compression also, i.e.
**       Svh should be handle to the CodecInfo structure.  (VB)
*/
SvStatus_t SvCloseCodec (SvHandle_t Svh)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvCloseCodec()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   if (Info->BSIn)
     ScBSDestroy(Info->BSIn);
   if (Info->BSOut)
     ScBSDestroy(Info->BSOut);
   if (Info->BufQ);
     ScBufQueueDestroy(Info->BufQ);
   if (Info->ImageQ);
     ScBufQueueDestroy(Info->ImageQ);

   switch (Info->mode) /* free all associated codec memory */
   {
#ifdef JPEG_SUPPORT
      case SV_JPEG_DECODE:
           {
             int i;
             for (i = 0; i < 4; i++) {
               if (Info->jdcmp->DcHt[i])
                 ScPaFree(Info->jdcmp->DcHt[i]);
               if (Info->jdcmp->AcHt[i])
                 ScPaFree(Info->jdcmp->AcHt[i]);
             }
             if (Info->jdcmp->compinfo)
               ScFree(Info->jdcmp->compinfo);
             if (Info->jdcmp) {
               if (Info->jdcmp->TempImage)
	         ScPaFree(Info->jdcmp->TempImage);
               if (Info->jdcmp->_SvBlockPtr)
	         ScFree(Info->jdcmp->_SvBlockPtr);
               ScFree(Info->jdcmp);
             }
           }
           break;

      case SV_JPEG_ENCODE:
           {
             int i;
             for (i = 0 ; i < Info->jcomp->NumComponents ; i++) 
               if (Info->jcomp->Qt[i])
                 ScPaFree(Info->jcomp->Qt[i]);
             for (i = 0; i < 4; i++) {
               if (Info->jcomp->DcHt[i])
                 ScPaFree(Info->jcomp->DcHt[i]);
               if (Info->jcomp->AcHt[i])
                 ScPaFree(Info->jcomp->AcHt[i]);
             }
             if (Info->jcomp->compinfo)
               ScFree(Info->jcomp->compinfo);
             if (Info->jcomp) {
               if (Info->jcomp->BlkBuffer)
	         ScPaFree(Info->jcomp->BlkBuffer);
               if (Info->jcomp->BlkTable)
	         ScPaFree(Info->jcomp->BlkTable);
               ScFree(Info->jcomp);
             }
           }
           break;
#endif /* JPEG_SUPPORT */

#ifdef H261_SUPPORT
      case SV_H261_ENCODE:
           if (Info->h261)
           {
             svH261CompressFree(Info);
             ScFree(Info->h261);
           }
           break;
     case SV_H261_DECODE:
           if (Info->h261)
           {
             svH261DecompressFree(Info);
             ScFree(Info->h261);
           }
           break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
     case SV_H263_DECODE:
           if (Info->h263dcmp)
           {
             svH263FreeDecompressor(Info);
             ScFree(Info->h263dcmp);
           }
           break;
     case SV_H263_ENCODE:
           if (Info->h263comp)
           {
             svH263FreeCompressor(Info);
             ScFree(Info->h263comp);
           }
           break;
#endif /* H263_SUPPORT */

#ifdef MPEG_SUPPORT
      case SV_MPEG_DECODE:
      case SV_MPEG2_DECODE:
           if (Info->mdcmp) {
             sv_MpegFreeDecoder(Info);
             ScFree(Info->mdcmp);
           }
           break;
      case SV_MPEG_ENCODE:
      case SV_MPEG2_ENCODE:
           if (Info->mcomp) {
             ScFree(Info->mcomp);
           }
           break;
#endif /* MPEG_SUPPORT */

#ifdef HUFF_SUPPORT
      case SV_HUFF_DECODE:
      case SV_HUFF_ENCODE:
           if (Info->huff) {
             sv_HuffFreeDecoder(Info);
             ScFree(Info->huff);
           }
           break;
           break;
#endif /* HUFF_SUPPORT */
   }

   /*
   ** Free Info structure
   */
   ScFree(Info);
   
   return(NoErrors);
}




/*
** Name:     SvDecompressBegin
** Purpose:  Initialize the Decompression Codec. Call after SvOpenCodec &
**           before SvDecompress (SvDecompress will call SvDecompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = format of input (uncompressed) image
**           ImgOut = format of output (compressed) image
*/
SvStatus_t SvDecompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut)
{
   int stat;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvDecompressBegin()\n") );

   if (!Info)
     return(SvErrorCodecHandle);
   if (Info->started)
     return(SvErrorNone);
   /* if no Image header provided, use previous headers */
   if (!ImgIn)
     ImgIn = &Info->InputFormat;
   if (!ImgOut)
     ImgOut = &Info->OutputFormat;
   stat=SvDecompressQuery (Svh, ImgIn, ImgOut);
   RETURN_ON_ERROR(stat);

   /*
   ** Save input & output formats for SvDecompress
   */
   sv_copy_bmh(ImgIn, &Info->InputFormat);
   sv_copy_bmh(ImgOut, &Info->OutputFormat);

   Info->Width = Info->InputFormat.biWidth;
   Info->Height = abs(Info->InputFormat.biHeight);
      
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
       case SV_JPEG_DECODE:
            {
              SvJpegDecompressInfo_t *DInfo;
              /*
              ** Load the default Huffman tablse
              */
              stat = sv_LoadDefaultHTable (Info);
              RETURN_ON_ERROR (stat);

              stat = sv_InitJpegDecoder (Info);
              RETURN_ON_ERROR (stat);

              /*
              ** Video-specific information will be filled in during processing
              ** of first frame
              */
              DInfo = Info->jdcmp;
              DInfo->InfoFilled = 0;
              DInfo->ReInit     = 1;
              DInfo->DecompressStarted = TRUE;
              DInfo->TempImage = NULL; 
              break;
            }
#endif

#ifdef MPEG_SUPPORT
       case SV_MPEG_DECODE:
       case SV_MPEG2_DECODE:
            Info->mdcmp->DecompressStarted = TRUE;
            /* the default data source is the buffer queue */
            if (Info->BSIn)
              ScBSReset(Info->BSIn);
            else
              stat=SvSetDataSource (Svh, SV_USE_BUFFER_QUEUE, 0, NULL, 0);
            RETURN_ON_ERROR (stat);
            stat = sv_MpegInitDecoder(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
       case SV_H261_DECODE:
            stat = svH261Init(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
       case SV_H263_DECODE:
            stat = svH263InitDecompressor(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
       case SV_HUFF_DECODE:
            Info->huff->DecompressStarted = TRUE;
            /* the default data source is the buffer queue */
            if (Info->BSIn)
              ScBSReset(Info->BSIn);
            else
              stat=SvSetDataSource (Svh, SV_USE_BUFFER_QUEUE, 0, NULL, 0);
            RETURN_ON_ERROR (stat);
            stat = sv_HuffInitDecoder(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* HUFF_SUPPORT */
   }
   Info->started=TRUE;
   return (NoErrors);
}



/*
** Name:     SvGetDecompressSize
** Purpose:  Return minimum data buffer size to receive decompressed data
**           for current settings on codec
**
** Args:     Svh = handle to software codec's Info structure.
**           MinSize = Returns minimum buffer size required
*/
SvStatus_t SvGetDecompressSize (SvHandle_t Svh, int *MinSize)
{
   int pixels,lines;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   switch (Info->mode) /* check that decompressor was started */
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
           if (!Info->jdcmp->DecompressStarted) 
             return(SvErrorDcmpNotStarted);
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
           if (!Info->mdcmp->DecompressStarted) 
             return(SvErrorDcmpNotStarted);
           break;
#endif /* MPEG_SUPPORT */
     default:
           break;
   }

   if (!MinSize)
     return(SvErrorBadPointer);

   pixels = Info->OutputFormat.biWidth;
   lines  = Info->OutputFormat.biHeight;
   if (lines < 0) lines = -lines;
   _SlibDebug(_VERBOSE_, 
              printf("OutputFormat.biWidth=%d OutputFormat.biHeight=%d\n",
                      pixels, lines) );

   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
           /*
           ** On output, accept: 8, 16 or 24 bit uncompressed RGB
           ** or YUV formats, 32 bit uncompressed RGB
           */
           if (Info->OutputFormat.biBitCount == 8) 
             *MinSize = pixels * lines;
           else if (Info->OutputFormat.biBitCount == 24) {
             if (Info->OutputFormat.biCompression == BI_RGB)
	       *MinSize = 3 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_DECSEPRGBDIB) 
	       *MinSize = 3 * pixels * lines;
             else if (IsYUV422Packed(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_DECXIMAGEDIB) 
	       *MinSize = 4 * pixels * lines;
             else if (IsYUV422Sep(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (IsYUV411Sep(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else
	     return(SvErrorUnrecognizedFormat);
           }
           else if (Info->OutputFormat.biBitCount == 16) {
             if (IsYUV422Packed(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_RGB)
	       *MinSize = 2 * pixels * lines;
           }
           else if (Info->OutputFormat.biBitCount == 32) {
             if (Info->OutputFormat.biCompression == BI_RGB ||
               Info->OutputFormat.biCompression == BI_BITFIELDS)
	       *MinSize = 4 * pixels * lines;
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
           /*
           ** MPEG multibuffer size = 3 pictures*(1Y + 1/4 U + 1/4 V)*imagesize
           */
           if (IsYUV422Sep(SvGetParamInt(Svh, SV_PARAM_FINALFORMAT)) ||
               IsYUV422Packed(SvGetParamInt(Svh, SV_PARAM_FINALFORMAT)))
             *MinSize = 3 * pixels * lines * 2;  /* 4:2:2 */
           else
             *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
     case SV_H261_DECODE:
           *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
     case SV_H263_DECODE:
           *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* H263_SUPPORT */
     default:
           return(SvErrorUnrecognizedFormat);
   }
   return(NoErrors);
}



/*
** Name:     SvDecompressQuery
** Purpose:  Determine if Codec can decompress desired format
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = Pointer to BITMAPINFOHEADER structure describing format
**           ImgOut = Pointer to BITMAPINFOHEADER structure describing format
*/
SvStatus_t SvDecompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!ImgIn && !ImgOut)
    return(SvErrorBadPointer);

  if (!IsSupported(_SvDecompressionSupport,
                    ImgIn ? ImgIn->biCompression : -1, 
                    ImgIn ? ImgIn->biBitCount : -1,
                    ImgOut ? ImgOut->biCompression : -1, 
                    ImgOut ? ImgOut->biBitCount : -1))
    return(SvErrorUnrecognizedFormat);
	 
  if (ImgOut) /* Query output format */
  {
    /*
    ** XXX - check to see if the # of output lines/# of output
    **       pixels/line are a multiple of 8. If not can't decompress
    **	    Note: This is an artifical restriction since the JPEG
    **	          bitream will always be a multiple of 8x8, so we
    **		  should have no problems decoding, only on the
    **		  output will be have to add an extra copy operation
    **	    XXX - will address/remove this restriction in the 
    **		  later release  (VB)
    */ 
    if (ImgOut->biWidth  <= 0 || ImgOut->biHeight == 0)
      return(SvErrorBadImageSize);
    switch (Info->mode)
    {
#ifdef JPEG_SUPPORT
      case SV_JPEG_DECODE: /* 8x8 restriction */
            if ((ImgOut->biWidth%8) || (ImgOut->biHeight%8)) 
              return(SvErrorBadImageSize);
            break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
      case SV_MPEG_DECODE:
      case SV_MPEG2_DECODE:
            /* MPEG 16x16 - because of Software Renderer YUV limitation */
            if ((ImgOut->biWidth%16) || (ImgOut->biHeight%16)) 
              return(SvErrorBadImageSize);
            /* Reject requests to scale during decompression - renderer's job */
            if (ImgIn && ImgOut &&
                (ImgIn->biWidth  != ImgOut->biWidth) ||
                (abs(ImgIn->biHeight) != abs(ImgOut->biHeight)))
              return (SvErrorBadImageSize);
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SV_H261_DECODE:
            /* H261 16x16 - because of Software Renderer YUV limitation */
            if ((ImgOut->biWidth%16) || (ImgOut->biHeight%16))
              return(SvErrorBadImageSize);
            if ((ImgOut->biWidth!=CIF_WIDTH && ImgOut->biWidth!=QCIF_WIDTH) ||
                (abs(ImgOut->biHeight)!=CIF_HEIGHT && abs(ImgOut->biHeight)!=QCIF_HEIGHT))
              return (SvErrorBadImageSize);
            /* Reject requests to scale during decompression - renderer's job */
            if (ImgIn && ImgOut &&
                (ImgIn->biWidth  != ImgOut->biWidth) ||
                (abs(ImgIn->biHeight) != abs(ImgOut->biHeight)))
              return (SvErrorBadImageSize);
            break;
#endif /* H261_SUPPORT */
      default:
            break;
    }

    if (ImgOut->biCompression == BI_BITFIELDS && 
         ValidateBI_BITFIELDS(ImgOut) == InvalidBI_BITFIELDS)
            return (SvErrorUnrecognizedFormat);
  }

  if (ImgIn) /* Query input format also */
  {
    if (ImgIn->biWidth  <= 0 || ImgIn->biHeight == 0)
      return(SvErrorBadImageSize);
  }
  return(NoErrors);
}

/*
** Name:     SvDecompress
** Purpose:  Decompress a frame CompData -> YUV or RGB
**
** Args:     Svh          = handle to software codec's Info structure.
**           Data         = For JPEG points to compressed data (INPUT)
**                          For MPEG & H261, points to MultiBuf
**           MaxDataSize  = Length of Data buffer
**           Image        = buffer for decompressed data (OUTPUT)
**           MaxImageSize = Size of output image buffer
**
*/
SvStatus_t SvDecompress(SvHandle_t Svh, u_char *Data, int MaxDataSize,
			 u_char *Image, int MaxImageSize)
{
  int stat=NoErrors, UsedQ=FALSE, ImageSize;
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  u_char *YData=NULL, *CbData=NULL, *CrData=NULL;
  int pixels, lines;
  SvCallbackInfo_t CB;
  u_char *ReturnImage=NULL;
  _SlibDebug(_VERBOSE_, printf("SvDecompress() In\n") );

  if (!Info)
    return(SvErrorCodecHandle);
  if (!Info->started)
    return(SvErrorDcmpNotStarted);
  if (!Data && !Info->BSIn)
    return(SvErrorBadPointer);

  /*
  ** If no image buffer is supplied, see if the Image Queue
  ** has any.  If not do a callback to get a buffer.
  */
  if (Image == NULL && Info->ImageQ)
  {
    if (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &Image, &MaxImageSize);
      ScBufQueueRemove(Info->ImageQ);
      UsedQ = TRUE;
      _SlibDebug(_VERBOSE_, printf("SvDecompress() Got Image %p from Q\n",
                            Image) );
    }
    else if (Info->CallbackFunction)
    {
      CB.Message = CB_END_BUFFERS;
      CB.Data  = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      _SlibDebug(_VERBOSE_,
                 printf("SvDecompress() Calling callback for Image\n") );
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
        _SlibDebug(_DEBUG_, 
                   printf("SvDecompress() CB.Action = CB_ACTION_END\n") );
        return(SvErrorClientEnd);
      }
      else if (ScBufQueueGetNum(Info->ImageQ))
      {
        ScBufQueueGetHead(Info->ImageQ, &Image, &MaxImageSize);
        ScBufQueueRemove(Info->ImageQ);
        UsedQ = TRUE;
        _SlibDebug(_VERBOSE_,
                   printf("SvDecompress() Got Image %p from Q\n", Image) );
      }
      else
        return(SvErrorNoImageBuffer);
    }
  }

  if (!Image)
    return(SvErrorNoImageBuffer);
  ImageSize=MaxImageSize;
  pixels = Info->OutputFormat.biWidth;
  lines  = Info->OutputFormat.biHeight;
  if (lines<0) lines=-lines;

  /*
  ** Decompress an image
  */
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
        {
          SvMpegDecompressInfo_t *MDInfo;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_MPEG_DECODE\n") );

          if (!(MDInfo = Info->mdcmp))
            return(SvErrorBadPointer);

          if (!MDInfo->DecompressStarted)
            return(SvErrorDcmpNotStarted);

          if (MaxDataSize < MDInfo->finalbufsize)
            return(SvErrorSmallBuffer);

          if (!Data)
            return(SvErrorBadPointer);

          stat = sv_MpegDecompressFrame(Info, Data, &ReturnImage);
          RETURN_ON_ERROR(stat);
          /*
          ** Because the ReturnImage is a pointer into Data
          ** we need to copy it (do a format conversion if necessary).
          */
          switch (Info->OutputFormat.biCompression)
          {
            case BI_YU12SEP:
                 /* native format is 4:1:1 planar, just copy */
                 ImageSize=(3 * lines * pixels)/2;
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 memcpy(Image, ReturnImage, ImageSize);
                 break;
            case BI_DECYUVDIB:
            case BI_YUY2:
            case BI_S422: /* 4:1:1 planar -> 4:2:2 interleaved */
                 ImageSize=(3 * lines * pixels)/2;
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 ScSepYUVto422i(Image, Image+(lines*pixels), 
                                       Image+(lines*pixels*5)/4, 
	                               ReturnImage, pixels, lines);
                 break;
            default: /* 4:1:1 planar -> RGB */
                 if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                   ImageSize=lines*pixels *
                             (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                 else
                   ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 YData  = ReturnImage;
                 CbData = YData + (pixels * lines);
                 CrData = CbData + (pixels * lines)/4;
                 ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                 break;
          }
        }
        break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
    case SV_H261_DECODE:
        {
          SvH261Info_t *H261 = Info->h261;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_H261_DECODE\n") );
          if (!H261)
            return(SvErrorBadPointer);
          if (!Data)
            return(SvErrorBadPointer);
          _SlibDebug(_DEBUG_, printf("sv_DecompressH261(Data=%p)\n",Data) );
          stat=svH261Decompress(Info, Data, &ReturnImage);
          if (stat==NoErrors)
          {
            /*
            ** Because the ReturnImage is a pointer into Data
            ** we need to copy it (do a format conversion if necessary).
            */
            switch (Info->OutputFormat.biCompression)
            {
              case BI_YU12SEP:
                   /* native format is 4:1:1 planar, just copy */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   memcpy(Image, ReturnImage, ImageSize);
                   break;
              case BI_DECYUVDIB:
              case BI_YUY2:
              case BI_S422:
                   /* 4:1:1 planar -> 4:2:2 interleaved */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   ScSepYUVto422i(Image, Image+(lines*pixels), 
                                         Image+(lines*pixels*5)/4,
	                                 ReturnImage, pixels, lines);
                   break;
              default:
                   if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                     ImageSize=lines*pixels *
                               (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                   else
                     ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   YData  = ReturnImage;
                   CbData = YData  + (pixels * lines * sizeof(u_char));
                   CrData = CbData + ((pixels * lines * sizeof(u_char))/4);
                   ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                   break;
            }
          }
          else
          {
            ImageSize=0;
            if (Info->CallbackFunction)
            {
              CB.Message = CB_SEQ_END;
              CB.Data = NULL;
              CB.DataSize = 0;
              CB.DataType = CB_DATA_NONE;
              CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
              CB.Action  = CB_ACTION_CONTINUE;
              (*Info->CallbackFunction)(Svh, &CB, NULL);
              _SlibDebug(_DEBUG_, 
                   printf("H261 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                                        CB.Data, CB.Action) );
              if (CB.Action == CB_ACTION_END)
                return (ScErrorClientEnd);
            }
          }
        }
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
        {
          SvH263DecompressInfo_t *H263Info = Info->h263dcmp;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_H261_DECODE\n") );
          if (!H263Info)
            return(SvErrorBadPointer);
          _SlibDebug(_DEBUG_, printf("svH263Decompress(Data=%p)\n",Data) );
          stat=svH263Decompress(Info, &ReturnImage);
          if (stat==NoErrors)
          {
            /*
            ** Because the ReturnImage is a pointer into Data
            ** we need to copy it (do a format conversion if necessary).
            */
            switch (Info->OutputFormat.biCompression)
            {
              case BI_YU12SEP:
                   /* native format is 4:1:1 planar, just copy */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   memcpy(Image, ReturnImage, ImageSize);
                   break;
              case BI_DECYUVDIB:
              case BI_YUY2:
              case BI_S422:
                   /* 4:1:1 planar -> 4:2:2 interleaved */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   ScSepYUVto422i(Image, Image+(lines*pixels), 
                                         Image+(lines*pixels*5)/4,
	                                 ReturnImage, pixels, lines);
                   break;
              default:
                   if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                     ImageSize=lines*pixels *
                               (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                   else
                     ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   YData  = ReturnImage;
                   CbData = YData  + (pixels * lines * sizeof(u_char));
                   CrData = CbData + ((pixels * lines * sizeof(u_char))/4);
                   ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                   break;
            }
          }
          else
          {
            ImageSize=0;
            if (Info->CallbackFunction)
            {
              CB.Message = CB_SEQ_END;
              CB.Data = NULL;
              CB.DataSize = 0;
              CB.DataType = CB_DATA_NONE;
              CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
              CB.Action  = CB_ACTION_CONTINUE;
              (*Info->CallbackFunction)(Svh, &CB, NULL);
              _SlibDebug(_DEBUG_, 
                   printf("H263 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                                        CB.Data, CB.Action) );
              if (CB.Action == CB_ACTION_END)
                return (ScErrorClientEnd);
            }
          }
        }
        break;
#endif /* H263_SUPPORT */
#ifdef JPEG_SUPPORT
    case SV_JPEG_DECODE:
        {
        SvJpegDecompressInfo_t *DInfo;
        register int i;
        JPEGINFOHEADER *jpegbm;
        int maxMcu;
        EXBMINFOHEADER * exbi;
        _SlibDebug(_DEBUG_, printf("SvDecompress() SV_JPEG_DECODE\n") );

        if (!(DInfo = Info->jdcmp))
          return(SvErrorBadPointer);

        exbi = (EXBMINFOHEADER *)&Info->InputFormat;

        jpegbm = (JPEGINFOHEADER *)(
                (unsigned long)exbi + exbi->biExtDataOffset);
 	
        /*
        ** In case the application forgot to call SvDecompressBegin().
        */
        if (!DInfo->DecompressStarted)
          return(SvErrorDcmpNotStarted);
        /*
        ** If desired output is not separate YUV components, we have to 
        ** convert from Sep. YUV to desired format. Create intermediate image.
        */
        _SlibDebug(_DEBUG_, printf ("JPEGBitsPerSample %d \n",
                            jpegbm->JPEGBitsPerSample) );

        if (lines < 0) lines = -lines;
        _SlibDebug(_DEBUG_, 
           printf ("JPEG_RGB : %d - ", JPEG_RGB);
           if (jpegbm->JPEGColorSpaceID == JPEG_RGB) 
             printf ("Color Space is RGB \n");
           else
             printf ("Color Space is %d \n", jpegbm->JPEGColorSpaceID) );

        if (!IsYUV422Sep(Info->OutputFormat.biCompression) &&
            !IsYUV411Sep(Info->OutputFormat.biCompression) &&
            Info->OutputFormat.biCompression != BI_DECGRAYDIB)
        {
          /*
          ** should be done only once for each instance of the CODEC.
          **    - Note: this forces us to check the size parameters (pixels &
          **            lines)  for  each  image  to be decompressed. Should we
          **	    support sequences that do not have constant frame sizes?
          */
          if (!DInfo->TempImage) {
            DInfo->TempImage = (u_char *)ScPaMalloc (3 * pixels * lines);
	    if (DInfo->TempImage == NULL)
	      return(SvErrorMemory);
          }
          YData  = DInfo->TempImage;
          CbData = YData  + (pixels * lines * sizeof(u_char));
          CrData = CbData + (pixels * lines * sizeof(u_char));
        }
        else {
          /*
          ** For YUV Planar formats, no need to translate.
          ** Get pointers to individual components.
          */
          _SlibDebug(_DEBUG_, printf ("sv_GetYUVComponentPointers\n") );
          stat = sv_GetYUVComponentPointers(Info->OutputFormat.biCompression,
					pixels, lines, Image, MaxImageSize,
					&YData, &CbData, &CrData);
          RETURN_ON_ERROR (stat);
        }

        _SlibDebug(_DEBUG_, printf ("sv_ParseFrame\n") );
        stat = sv_ParseFrame (Data, MaxDataSize, Info);
        RETURN_ON_ERROR (stat);
      
       /*
       ** Fill Info structure with video-specific data on first frame
       */
       if (!DInfo->InfoFilled) {
         _SlibDebug(_DEBUG_, printf ("sv_InitJpegDecoder\n") );
         stat = sv_InitJpegDecoder (Info);
         RETURN_ON_ERROR (stat);
         DInfo->InfoFilled = 1;

         /*
         ** Error checking: 
         **      make the assumption that for MJPEG we need to check for 
         **      valid subsampling only once at the start of the seqence
         */
         _SlibDebug(_DEBUG_, printf ("sv_CheckChroma\n") );
         stat = sv_CheckChroma(Info);
         RETURN_ON_ERROR (stat);
       }

       /*
       ** Decompress everything into MCU's
       */
       if (!DInfo->ReInit) /* Reset the JPEG compressor */
	     sv_ReInitJpegDecoder (Info);
       maxMcu = DInfo->MCUsPerRow * DInfo->MCUrowsInScan;
       if (DInfo->ReInit) 
         DInfo->ReInit = 0; 

       DInfo->CurrBlockNumber = 0;
       /*
       ** Create the BlockPtr array for the output buffers
       */
       if ((YData  != DInfo->Old_YData)  ||
           (CbData != DInfo->Old_CbData) ||
           (CrData != DInfo->Old_CrData)) 
       {
         DInfo->Old_YData =YData;
         DInfo->Old_CbData=CbData;
         DInfo->Old_CrData=CrData;

         stat = sv_MakeDecoderBlkTable (Info);
         RETURN_ON_ERROR (stat);
       }

       CB.Message = CB_PROCESSING;
       for (i = 0; i < maxMcu; i++) {
#if 0
         if ((Info->CallbackFunction) && ((i % MCU_CALLBACK_COUNT) == 0)) {
	   (*Info->CallbackFunction)(Svh, &CB, &PictureInfo);
	   if (CB.Action == CB_ACTION_END)
	     return(SvErrorClientEnd);
         }
#endif
         _SlibDebug(_DEBUG_, printf ("sv_DecodeJpeg\n") );
         stat = sv_DecodeJpeg (Info);
         RETURN_ON_ERROR (stat);
       }
#if 0
       /*
       ** Check for multiple scans in the JPEG file
       **	  - we do not support multiple scans 
       */
       if (sv_ParseScanHeader (Info) != SvErrorEOI) 
	 _SlibDebug(_DEBUG_ || _WARN_ || _VERBOSE_, 
         printf(" *** Warning ***, Multiple Scans detected, unsupported\n") );
#endif
       if (DInfo->compinfo[0].Vsf==2) /* 4:1:1->4:2:2 */
       {
         if (IsYUV422Packed(Info->OutputFormat.biCompression))
           ScConvert411sTo422i_C(YData, CbData, CrData, Image,
                                 pixels, lines);
         else if IsYUV422Sep(Info->OutputFormat.biCompression)
           ScConvert411sTo422s_C(YData, CbData, CrData, Image,
                                 pixels, lines);
         else if IsYUV411Sep(Info->OutputFormat.biCompression)
         {
           if (YData!=Image)
             memcpy(Image, YData, pixels*lines);
           memcpy(Image+pixels*lines, CbData, (pixels*lines)/4);
           memcpy(Image+(pixels*lines*5)/4, CrData, (pixels*lines)/4);
         }
         else
         {
           ScConvert411sTo422s_C(YData, CbData, CrData, YData,
                                 pixels, lines);
           ScConvertSepYUVToOther(&Info->InputFormat, &Info->OutputFormat, 
                             Image, YData, CbData, CrData);
         }
       }
       else if (!IsYUV422Sep(Info->OutputFormat.biCompression) &&
           !IsYUV411Sep(Info->OutputFormat.biCompression) &&
            Info->OutputFormat.biCompression != BI_DECGRAYDIB)
          ScConvertSepYUVToOther(&Info->InputFormat, &Info->OutputFormat, 
                             Image, YData, CbData, CrData);
       }
       break; /* SV_JPEG_DECODE */
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_DECODE:
        {
          SvHuffInfo_t *HInfo;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_HUFF_DECODE\n") );

          if (!(HInfo = Info->huff))
            return(SvErrorBadPointer);

          if (!HInfo->DecompressStarted)
            return(SvErrorDcmpNotStarted);

          stat = sv_HuffDecodeFrame(Info, Image);
          RETURN_ON_ERROR(stat);
        }
        break;
#endif /* HUFF_SUPPORT */

    default:
       return(SvErrorCodecType);
  }

  Info->NumOperations++;
  if (Info->CallbackFunction)
  {
    if (ImageSize>0)
    {
      CB.Message = CB_FRAME_READY;
      CB.Data  = Image;
      CB.DataSize = MaxImageSize;
      CB.DataUsed = ImageSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.TimeStamp = 0;
      CB.Flags = 0;
      CB.Value = 0;
      CB.Format = (void *)&Info->OutputFormat;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_,
        printf("Decompress Callback: CB_FRAME_READY Addr=0x%x, Action=%d\n",
                CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return(SvErrorClientEnd);
    }
    /*
    ** If an Image buffer was taken from the queue, do a callback
    ** to let the client free or re-use the buffer.
    */
    if (UsedQ)
    {
      CB.Message = CB_RELEASE_BUFFER;
      CB.Data  = Image;
      CB.DataSize = MaxImageSize;
      CB.DataUsed = ImageSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_,
          printf("Decompress Callback: RELEASE_BUFFER Addr=0x%x, Action=%d\n",
                  CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return(SvErrorClientEnd);
    }
  }
  _SlibDebug(_DEBUG_, printf("SvDecompress() Out\n") );
  return(stat);
}



/*
** Name:     SvDecompressEnd
** Purpose:  Terminate the Decompression Codec. Call after all calls to
**           SvDecompress are done.
**
** Args:     Svh = handle to software codec's Info structure.
*/
SvStatus_t SvDecompressEnd (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;
  _SlibDebug(_DEBUG_, printf("SvDecompressEnd()\n") );

  if (!Info)
    return(SvErrorCodecHandle);
  if (!Info->started)
    return(SvErrorDcmpNotStarted);

  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
        Info->jdcmp->DecompressStarted = FALSE;
        break;
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
        Info->mdcmp->DecompressStarted = FALSE;
        Info->mdcmp->PicturePositioned = FALSE;
        Info->mdcmp->lastI = -1;
        Info->mdcmp->lastP = -1;
        Info->mdcmp->N = 12;
        Info->mdcmp->M = 3;
        Info->mdcmp->framenum = 0;
        break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
     case SV_H261_DECODE:
        {
        int status=svH261DecompressFree(Svh);
        RETURN_ON_ERROR(status);
        }
        break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_DECODE:
        {
        int status=svH263FreeDecompressor(Info);
        RETURN_ON_ERROR(status);
        }
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
     case SV_HUFF_DECODE:
/*
	{
        int status=sv_HuffDecompressEnd(Svh);
        RETURN_ON_ERROR(status);
        }
*/
        break;
#endif /* HUFF_SUPPORT */
  }
  /* Release any Image Buffers in the queue */
  if (Info->ImageQ)
  {
    int datasize;
    _SlibDebug(_VERBOSE_, printf("Info->ImageQ exists\n") );
    while (ScBufQueueGetNum(Info->ImageQ))
    {
      _SlibDebug(_VERBOSE_, printf("Removing from ImageQ\n") );
      ScBufQueueGetHead(Info->ImageQ, &CB.Data, &datasize);
      ScBufQueueRemove(Info->ImageQ);
      if (Info->CallbackFunction && CB.Data)
      {
        CB.Message = CB_RELEASE_BUFFER;
        CB.DataSize = datasize;
        CB.DataUsed = 0;
        CB.DataType = CB_DATA_IMAGE;
        CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
        CB.Action  = CB_ACTION_CONTINUE;
        (*(Info->CallbackFunction))(Svh, &CB, NULL);
        _SlibDebug(_DEBUG_,
           printf("SvDecompressEnd: RELEASE_BUFFER. Data = 0x%x, Action = %d\n",
                           CB.Data, CB.Action) );
      }
    }
  }
  if (Info->BSIn)
    ScBSFlush(Info->BSIn);  /* flush out any remaining compressed buffers */

  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_,
            printf("SvDecompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                    CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
  Info->started=FALSE;
  return(NoErrors);
}

/*
** Name:     SvSetDataSource 
** Purpose:  Set the data source used by the MPEG or H261 bitstream parsing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SvAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Svh    = handle to software codec's Info structure.
**           Source = SV_USE_BUFFER_QUEUE or SV_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SvStatus_t SvSetDataSource (SvHandle_t Svh, int Source, int Fd, 
			    void *Buffer_UserData, int BufSize)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int stat=NoErrors;

  if (!Info)
    return(SvErrorCodecHandle);

  if (Info->mode!=SV_MPEG_DECODE && Info->mode!=SV_MPEG2_DECODE
      && Info->mode!=SV_H261_DECODE && Info->mode!=SV_H263_DECODE
      && Info->mode!=SV_HUFF_DECODE)
    return(SvErrorCodecType);

  if (Info->BSIn)
  {
    ScBSDestroy(Info->BSIn);
    Info->BSIn=NULL;
  }

  switch (Source)
  {
     case SV_USE_BUFFER:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_BUFFER)\n") );
       stat=ScBSCreateFromBuffer(&Info->BSIn, Buffer_UserData, BufSize);
       break;

     case SV_USE_BUFFER_QUEUE:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_BUFFER_QUEUE)\n") );
       stat=ScBSCreateFromBufferQueue(&Info->BSIn, Svh, 
                                      CB_DATA_COMPRESSED,
                                      Info->BufQ,
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SV_USE_FILE:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_FILE)\n") );
       stat=ScBSCreateFromFile(&Info->BSIn, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SvErrorBadArgument;
   }
   return(stat);
}

/*
** Name:     SvSetDataDestination 
** Purpose:  Set the data destination used by the MPEG or H261 bitstream
**           writing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SvAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Svh    = handle to software codec's Info structure.
**           Source = SV_USE_BUFFER_QUEUE or SV_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SvStatus_t SvSetDataDestination(SvHandle_t Svh, int Dest, int Fd, 
			        void *Buffer_UserData, int BufSize)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int stat=NoErrors;

  if (!Info)
    return(SvErrorCodecHandle);

  if (Info->mode != SV_H261_ENCODE && Info->mode != SV_H263_ENCODE &&
      Info->mode != SV_MPEG_ENCODE &&
      Info->mode != SV_MPEG2_ENCODE && Info->mode != SV_HUFF_ENCODE)
    return(SvErrorCodecType);

  if (Info->BSOut)
  {
    ScBSDestroy(Info->BSOut);
    Info->BSOut=NULL;
  }

  switch (Dest)
  {
     case SV_USE_BUFFER:
       _SlibDebug(_DEBUG_, printf("SvSetDataDestination(SV_USE_BUFFER)\n") );
       stat=ScBSCreateFromBuffer(&Info->BSOut, Buffer_UserData, BufSize);
       break;

     case SV_USE_BUFFER_QUEUE:
       _SlibDebug(_DEBUG_, 
                  printf("SvSetDataDestination(SV_USE_BUFFER_QUEUE)\n") );
       stat=ScBSCreateFromBufferQueue(&Info->BSOut, Svh, 
                                      CB_DATA_COMPRESSED, Info->BufQ,
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SV_USE_FILE:
       _SlibDebug(_DEBUG_, printf("SvSetDataDestination(SV_USE_FILE)\n") );
       stat=ScBSCreateFromFile(&Info->BSOut, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SvErrorBadArgument;
   }
   return(stat);
}

/*
** Name: SvGetDataSource
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetDataSource (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  
  if (!Info)
    return(NULL);

  return(Info->BSIn);
}

/*
** Name: SvGetDataDestination
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetDataDestination(SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  
  if (!Info)
    return(NULL);

  return(Info->BSOut);
}

/*
** Name: SvGetInputBitstream
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetInputBitstream (SvHandle_t Svh)
{
  return(SvGetDataSource(Svh));
}

/*
** Name:    SvFlush
** Purpose: Flushes out current compressed buffers.
** Return:  status
*/
SvStatus_t SvFlush(SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  if (Info->BSIn)
    ScBSFlush(Info->BSIn);  /* flush out any remaining input compressed buffers */
  if (Info->BSOut)
    ScBSFlush(Info->BSOut); /* flush out any remaining output compressed buffers */
  return(SvErrorNone);
}

/*
** Name:     SvRegisterCallback
** Purpose:  Specify the user-function that will be called during processing
**           to determine if the codec should abort the frame.
** Args:     Svh          = handle to software codec's Info structure.
**           Callback     = callback function to register
**
*/
SvStatus_t SvRegisterCallback (SvHandle_t Svh, 
	   int (*Callback)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *),
       void *UserData)
{
  SvStatus_t stat=NoErrors;
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  _SlibDebug(_DEBUG_, printf("SvRegisterCallback()\n") );

  if (!Info)
    return(SvErrorCodecHandle);

  if (!Callback)
     return(SvErrorBadPointer);

  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT    
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT    
    case SV_H261_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->h261) /* copy callback to H261 structure */
             Info->h261->CallbackFunction=Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_H261_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->h261) /* copy callback to H261 structure */
             Info->h261->CallbackFunction=Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT    
    case SV_H263_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_H263_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT    
    case SV_HUFF_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_HUFF_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* HUFF_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(stat);
}

/*
** Name:     SvAddBuffer
** Purpose:  Add a buffer of MPEG bitstream data to the CODEC or add an image
**           buffer to be filled by the CODEC (in streaming mode)
**
** Args:     Svh = handle to software codec's Info structure.
**           BufferInfo = structure describing buffer's address, type & size
*/
SvStatus_t SvAddBuffer (SvHandle_t Svh, SvCallbackInfo_t *BufferInfo)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  ScQueue_t *Q=NULL;
  _SlibDebug(_DEBUG_, printf("SvAddBuffer() length=%d\n",BufferInfo->DataSize));

  if (!Info)
    return(SvErrorCodecHandle);

  if (BufferInfo->DataType != CB_DATA_COMPRESSED &&
      BufferInfo->DataType != CB_DATA_IMAGE)
    return(SvErrorBadArgument);

  /*
  ** Compressed data can only be added for MPEG and H261
  */
  if (BufferInfo->DataType == CB_DATA_COMPRESSED
#ifdef MPEG_SUPPORT
        && Info->mode != SV_MPEG_DECODE 
        && Info->mode != SV_MPEG2_DECODE 
        && Info->mode != SV_MPEG_ENCODE 
        && Info->mode != SV_MPEG2_ENCODE 
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
        && Info->mode != SV_H261_DECODE
        && Info->mode != SV_H261_ENCODE
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
        && Info->mode != SV_H263_DECODE
        && Info->mode != SV_H263_ENCODE
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
        && Info->mode != SV_HUFF_DECODE
        && Info->mode != SV_HUFF_ENCODE
#endif /* HUFF_SUPPORT */
     )
    return(SvErrorCodecType);

  if (!BufferInfo->Data || (BufferInfo->DataSize <= 0))
    return(SvErrorBadArgument);

  switch (BufferInfo->DataType)
  {
     case CB_DATA_COMPRESSED:
            _SlibDebug(_DEBUG_, printf("SvAddBuffer() COMPRESSED\n") );
            if (Info->BSOut && Info->BSOut->EOI)
              ScBSReset(Info->BSOut);
            if (Info->BSIn && Info->BSIn->EOI)
              ScBSReset(Info->BSIn);
            Q = Info->BufQ;
            break;
     case CB_DATA_IMAGE:
            _SlibDebug(_DEBUG_, printf("SvAddBuffer() IMAGE\n") );
            Q = Info->ImageQ;
            break;
     default:
            return(SvErrorBadArgument);
  }
  if (Q)
    ScBufQueueAdd(Q, BufferInfo->Data, BufferInfo->DataSize);
  else
    _SlibDebug(_DEBUG_, printf("ScBufQueueAdd() no Queue\n") );

  return(NoErrors);
}

/*
** Name:     SvFindNextPicture
** Purpose:  Find the start of the next picture in a bitstream.
**           Return the picture type to the caller.
**
** Args:     Svh = handle to software codec's Info structure.
**           PictureInfo = Structure used to select what type of pictures to
**                         search for and to return information about the
**                         picture that is found
*/
SvStatus_t SvFindNextPicture (SvHandle_t Svh, SvPictureInfo_t *PictureInfo)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvFindNextPicture()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   switch (Info->mode)
   {
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
            if (!Info->mdcmp)
              return(SvErrorBadPointer);
            if (!Info->mdcmp->DecompressStarted)
              return(SvErrorDcmpNotStarted);
            {
		SvStatus_t stat = sv_MpegFindNextPicture(Info, PictureInfo);
		return(stat);
	    }
#endif /* MPEG_SUPPORT */
     default:
            return(SvErrorCodecType);
   }
}

#ifdef MPEG_SUPPORT
/*
** Name:     SvDecompressMPEG
** Purpose:  Decompress the MPEG picture that starts at the current position
**           of the bitstream. If the bitstream is not properly positioned
**           then find the next picture.
**
** Args:     Svh = handle to software codec's Info structure.
**           MultiBuf = Specifies pointer to start of the Multibuffer, an area
**                      large enough to hold 3 decompressed images: the
**                      current image, the past reference image and the
**                      future reference image.
**           MaxMultiSize = Size of the Multibuffer in bytes.
**           ImagePtr = Returns a pointer to the current image. This will be
**                      somewhere within the Multibuffer.
*/
SvStatus_t SvDecompressMPEG (SvHandle_t Svh, u_char *MultiBuf, 
			     int MaxMultiSize, u_char **ImagePtr)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   SvMpegDecompressInfo_t *MDInfo;
   _SlibDebug(_DEBUG_, printf("SvDecompressMPEG()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   if (!(MDInfo = Info->mdcmp))
     return(SvErrorBadPointer);

   if (!MDInfo->DecompressStarted)
     return(SvErrorDcmpNotStarted);

   return(sv_MpegDecompressFrame(Info, MultiBuf, ImagePtr));
}
#endif /* MPEG_SUPPORT */	

#ifdef H261_SUPPORT
SvStatus_t SvDecompressH261 (SvHandle_t Svh, u_char *MultiBuf,
                             int MaxMultiSize, u_char **ImagePtr)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvH261Info_t *H261;
  ScCallbackInfo_t CB;
  SvStatus_t status;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!(H261 = Info->h261))
    return(SvErrorBadPointer);

  if (Info->BSIn->EOI)
    return(SvErrorEndBitstream);

  status = svH261Decompress(Info, MultiBuf, ImagePtr);
  if (status == SvErrorEndBitstream && Info->CallbackFunction)
  {
    CB.Message = CB_SEQ_END;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
               printf("H261 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                          CB.Data, CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
  else if (status==NoErrors)
  {
    *ImagePtr = H261->Y;
    if (Info->CallbackFunction)
    {
      CB.Message = CB_FRAME_READY;
      CB.Data = *ImagePtr;
      CB.DataSize = H261->PICSIZE+(H261->PICSIZE/2);
      CB.DataUsed = CB.DataSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.TimeStamp = 0;
      CB.Flags = 0;
      CB.Value = 0;
      CB.Format = (void *)&Info->OutputFormat;
      CB.Action  = CB_ACTION_CONTINUE;
      (*Info->CallbackFunction)(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_, 
            printf("H261 Callback: CB_FRAME_READY Data = 0x%x, Action = %d\n",
                  CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return (ScErrorClientEnd);
    }
  }
  return (status);
}
#endif /* H261_SUPPORT */

#ifdef JPEG_SUPPORT
/*---------------------------------------------------------------------
	SLIB routines to Query and return CODEC Tables to caller
 *---------------------------------------------------------------------*/

/*
** From JPEG Spec. :
**    Huffman tables are specified in terms of a 16-byte list (BITS) giving 
**    the number of codes for each code length from 1 to 16. This is 
**    followed by a list of 8-bit symbol values (HUFVAL), each of which is
**    assigned a Huffman code. The symbol values are placed in the list
**    in order of increasing code length.  Code length greater than 16-bits
**    are not allowed. 
*/


/*
** Name:     SvSetDcmpHTables
** Purpose: 
**
** Notes:    Baseline process is the only supported mode:
**		- uses 2 AC tables and 2 DC Tables
**
*/
SvStatus_t SvSetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int i,stat,count;
  SvHt_t **htblptr;
  SvHTable_t *HTab;
  register int j;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!Ht)
    return(SvErrorBadPointer);

  for (j = 0; j < 4; j++) {
    switch(j) {
    case 0: htblptr = &Info->jdcmp->DcHt[0];
      HTab = &Ht->DcY;
      break;
    case 1: htblptr = &Info->jdcmp->AcHt[0];
      HTab = &Ht->AcY;
      break;
    case 2: htblptr = &Info->jdcmp->DcHt[1];
      HTab = &Ht->DcUV;
      break;
    case 3: htblptr = &Info->jdcmp->AcHt[1];
      HTab = &Ht->AcUV;
      break;
    }
      
    if (*htblptr == NULL)
      *htblptr = (SvHt_t *) ScPaMalloc(sizeof(SvHt_t));
    
    (*htblptr)->bits[0] = 0;
    count   = 0;
    for (i = 1; i < BITS_LENGTH; i++) {
      (*htblptr)->bits[i] = (u_char)HTab->bits[i-1];
      count += (*htblptr)->bits[i];
    }
    if (count > 256) 
      return(SvErrorDHTTable);
    
    /*
    ** Load Huffman table:
    */
    for (i = 0; i < count; i++)
      (*htblptr)->value[i] = (u_char)HTab->value[i];
  }

  stat = sv_LoadDefaultHTable (Info);
  if (stat) return(stat);
  
  return(NoErrors);
}


/*
** Name:     SvGetDcmpHTables
** Purpose: 
**
*/
SvStatus_t SvGetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int i,count;
  SvHt_t **htblptr;
  SvHTable_t *HTab;
  register int j;

  if (!Info)
    return (SvErrorCodecHandle);

  if (!Ht)
    return(SvErrorBadPointer);

  for (j = 0; j < 4; j++) {
    switch(j) {
    case 0: htblptr = &Info->jdcmp->DcHt[0];
      HTab = &Ht->DcY;
      break;
    case 1: htblptr = &Info->jdcmp->AcHt[0];
      HTab = &Ht->AcY;
      break;
    case 2: htblptr = &Info->jdcmp->DcHt[1];
      HTab = &Ht->DcUV;
      break;
    case 3: htblptr = &Info->jdcmp->AcHt[1];
      HTab = &Ht->AcUV;
      break;
    }
      
    if (*htblptr == NULL)
      return(SvErrorHuffUndefined);
    
    count   = 0;
    for (i = 1; i < BITS_LENGTH; i++) {
      HTab->bits[i-1] = (int)(*htblptr)->bits[i];
      count += (*htblptr)->bits[i];
    }
    if (count > 256) 
      return(SvErrorDHTTable);
    
    /*
    ** Copy Huffman table:
    */
    for (i = 0; i < count; i++)
      HTab->value[i] = (u_int)(*htblptr)->value[i];
  }

  return(NoErrors);
}



/*
** Name:     SvSetCompHTables
** Purpose: 
**
*/
SvStatus_t SvSetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
   return(SvErrorNotImplemented);
}


/*
** Name:     SvGetCompHTables
** Purpose: 
**
*/
SvStatus_t SvGetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
   SvCodecInfo_t *Info  = (SvCodecInfo_t *)Svh;
   SvHt_t **htblptr;
   SvHTable_t *HTab;
   register int i, j, count;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Ht)
     return (SvErrorBadPointer);

   for (j = 0; j < 4; j++) {
      switch(j) {
      case 0: htblptr = &Info->jcomp->DcHt[0];
        HTab = &Ht->DcY;
        break;
      case 1: htblptr = &Info->jcomp->AcHt[0];
        HTab = &Ht->AcY;
        break;
      case 2: htblptr = &Info->jcomp->DcHt[1];
        HTab = &Ht->DcUV;
        break;
      case 3: htblptr = &Info->jcomp->AcHt[1];
        HTab = &Ht->AcUV;
        break;
      }
      
      if (*htblptr == NULL)
        return (SvErrorHuffUndefined);
    
      /*
      ** Copy the "bits" array (contains number of codes of each size)
      */
      count = 0;		
      for (i = 1; i < BITS_LENGTH; i++) {
         HTab->bits[i-1] = (int)(*htblptr)->bits[i];
         count += (*htblptr)->bits[i];
      }
      if (count > 256) 			
	 /* 
         **  total # of Huffman code words cannot exceed 256
         */
         return (SvErrorDHTTable);
    
      /*
      ** Copy the "value" array (contains values associated with above codes) 
      */
      for (i = 0; i < count; i++)
         HTab->value[i] = (u_int)(*htblptr)->value[i];
  }

  return(NoErrors);
}



/*
** Name:     SvSetDcmpQTables
** Purpose: 
**
*/
SvStatus_t SvSetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvJpegDecompressInfo_t *DInfo;

  if (!Info)
    return(SvErrorCodecHandle);

  DInfo = (SvJpegDecompressInfo_t *)Info->jdcmp;

  if (!Qt)
    return(SvErrorBadPointer);

  if (DInfo->_SviquantTblPtrs[0] == NULL) 
    if ((DInfo->_SviquantTblPtrs[0] = (int *) ScAlloc(64*sizeof(int))) ==
	(int *)NULL) return(SvErrorMemory);
  if (DInfo->_SviquantTblPtrs[1] == NULL) 
    if ((DInfo->_SviquantTblPtrs[1] = (int *) ScAlloc(64*sizeof(int))) ==
	(int *)NULL) return(SvErrorMemory);

  bcopy (Qt->c1,  DInfo->_SviquantTblPtrs[0], 64*sizeof(int));
  bcopy (Qt->c2,  DInfo->_SviquantTblPtrs[1], 64*sizeof(int));
  bcopy (Qt->c3,  DInfo->_SviquantTblPtrs[1], 64*sizeof(int));

  return(NoErrors);
}


/*
** Name:     SvGetDcmpQTables
** Purpose: 
**
*/
SvStatus_t SvGetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvJpegDecompressInfo_t *DInfo;

  if (!Info)
    return(SvErrorCodecHandle);

  DInfo = (SvJpegDecompressInfo_t *)Info->jdcmp;

  if (!Qt)
    return(SvErrorBadPointer);

  if (DInfo->_SviquantTblPtrs[0])
    bcopy (DInfo->_SviquantTblPtrs[0], Qt->c1, 64*sizeof(int));
  else
    bzero (Qt->c1, 64*sizeof(int));

  if (DInfo->_SviquantTblPtrs[1])
    bcopy(DInfo->_SviquantTblPtrs[1], Qt->c2, 64*sizeof(int));
  else
    bzero(Qt->c2, 64*sizeof(int));

  /*
  ** XXX - when the structure is changed approprately remove the
  **	   above and do the following:
  **
  **  if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3))
  **     return (SvErrorBadPointer);
  **  bcopy ((u_char *)DInfo->Qt, (u_char *)Qt, sizeof(SvQuantTables_t));
  */

  return(NoErrors);
}


/*
** Name:     SvSetCompQTables
** Purpose:  Allows user to set quantization tables directly
**
*/
SvStatus_t SvSetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Info->jcomp->CompressStarted)
     return (SvErrorCompNotStarted);

   if (!Qt)
     return (SvErrorBadPointer);

   if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3)) 
     return (SvErrorBadPointer);

   /*
   ** Convert SvQuantTables_t structure to internal SvQt_t structure.
   */
   sv_ConvertQTable(Info, Qt);

   return(NoErrors);
}
#endif /* JPEG_SUPPORT */

/*---------------------------------------------------------------------
	SLIB Compression Routines
 *---------------------------------------------------------------------*/

/*
** Name:     SvCompressBegin
** Purpose:  Initialize the Compression Codec. Call after SvOpenCodec &
**           before SvCompress (SvCompress will call SvCompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = format of input (uncompressed) image
**           ImgOut = format of output (compressed) image
*/
SvStatus_t SvCompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut)
{
   int stat;
   SvCodecInfo_t *Info  = (SvCodecInfo_t *)Svh;

   /*
   ** Sanity checks:
   */
   if (!Info)
     return (SvErrorCodecHandle);

   if (!ImgIn || !ImgOut)
     return (SvErrorBadPointer);

   stat=SvCompressQuery (Svh, ImgIn, ImgOut);
   RETURN_ON_ERROR(stat);

   /*
   ** Save input & output formats for SvDecompress
   */
   sv_copy_bmh(ImgIn, &Info->InputFormat);
   sv_copy_bmh(ImgOut, &Info->OutputFormat);

   Info->Width = Info->OutputFormat.biWidth;
   Info->Height = abs(Info->OutputFormat.biHeight);
   /*
   **  Initialize -  the encoder structure 
   **  Load       -  the default Huffman Tables
   **  Make       -  the internal Block Table
   */  
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
      case SV_JPEG_ENCODE:
            stat = sv_InitJpegEncoder (Info);
            RETURN_ON_ERROR (stat);
            /*
            ** Set up the default quantization matrices:
            */ 
            stat = SvSetQuality (Svh, DEFAULT_Q_FACTOR);
            Info->jcomp->CompressStarted = TRUE;
            Info->jcomp->Quality = DEFAULT_Q_FACTOR;
            RETURN_ON_ERROR (stat);
            break;

#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SV_H261_ENCODE:
            stat = svH261CompressInit(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
      case SV_H263_ENCODE:
            stat = svH263InitCompressor(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
      case SV_MPEG_ENCODE:
      case SV_MPEG2_ENCODE:
            stat = sv_MpegInitEncoder (Info);
            RETURN_ON_ERROR (stat);
            sv_MpegEncoderBegin(Info);
            break;
#endif /* MPEG_SUPPORT */

#ifdef HUFF_SUPPORT
      case SV_HUFF_ENCODE:
            stat = sv_HuffInitEncoder (Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* HUFF_SUPPORT */

      default:
            return(SvErrorCodecType);
   }
   return (NoErrors);
}


/*
** Name:     SvCompressEnd
** Purpose:  Terminate the Compression Codec. Call after all calls to
**           SvCompress are done.
**
** Args:     Svh = handle to software codec's Info structure.
*/
SvStatus_t SvCompressEnd (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;

  SvStatus_t status=NoErrors;
  _SlibDebug(_VERBOSE_, printf("SvCompressEnd()\n") );

  if (!Info)
    return (SvErrorCodecHandle);
  switch (Info->mode)
  {
#ifdef H261_SUPPORT
    case SV_H261_ENCODE:
          status=svH261CompressFree(Svh);
          RETURN_ON_ERROR(status)
          break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_ENCODE:
          status=svH263FreeCompressor(Svh);
          RETURN_ON_ERROR(status)
          break;
#endif /* H263_SUPPORT */

#ifdef MPEG_SUPPORT
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
          sv_MpegEncoderEnd(Info);
          sv_MpegFreeEncoder(Info);
          break;
#endif /* MPEG_SUPPORT */

#ifdef JPEG_SUPPORT
    case SV_JPEG_ENCODE:
          if (!Info->jcomp)
            return (SvErrorMemory);
          Info->jcomp->CompressStarted = FALSE;
          break;
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_ENCODE:
          sv_HuffFreeEncoder(Info);
          break;
#endif /* HUFF_SUPPORT */
    default:
          break;
  }

  /* Release any Image Buffers in the queue */
  if (Info->ImageQ)
  {
    int datasize;
    while (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &CB.Data, &datasize);
      ScBufQueueRemove(Info->ImageQ);
      if (Info->CallbackFunction && CB.Data)
      {
        CB.Message = CB_RELEASE_BUFFER;
        CB.DataSize = datasize;
        CB.DataUsed = 0;
        CB.DataType = CB_DATA_IMAGE;
        CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
        CB.Action  = CB_ACTION_CONTINUE;
        (*(Info->CallbackFunction))(Svh, &CB, NULL);
        _SlibDebug(_DEBUG_, 
            printf("SvCompressEnd: RELEASE_BUFFER. Data = 0x%X, Action = %d\n",
                           CB.Data, CB.Action) );
      }
    }
  }
  if (Info->BSOut)
    ScBSFlush(Info->BSOut);  /* flush out the last compressed data */

  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
            printf("SvCompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                  CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }

  return (status);
}


/*
** Name:     SvCompress
** Purpose: 
**
*/
SvStatus_t SvCompress(SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			 u_char *Image, int ImageSize, int *CmpBytes)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;
  int stat=NoErrors, UsedQ=FALSE;
  _SlibDebug(_DEBUG_, printf("SvCompress()\n") );

  if (!Info)
    return (SvErrorCodecHandle);
 
  /*
  ** If no image buffer is supplied, see if the Image Queue
  ** has any.  If not do a callback to get a buffer.
  */
  if (Image == NULL && Info->ImageQ)
  {
    if (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &Image, &ImageSize);
      ScBufQueueRemove(Info->ImageQ);
      UsedQ = TRUE;
    }
    else if (Info->CallbackFunction)
    {
      CB.Message = CB_END_BUFFERS;
      CB.Data  = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
        _SlibDebug(_DEBUG_, 
                   printf("SvDecompress() CB.Action = CB_ACTION_END\n") );
        return(SvErrorClientEnd);
      }
      else if (ScBufQueueGetNum(Info->ImageQ))
      {
        ScBufQueueGetHead(Info->ImageQ, &Image, &ImageSize);
        ScBufQueueRemove(Info->ImageQ);
        UsedQ = TRUE;
      }
      else
        return(SvErrorNoImageBuffer);
    }
  }

  if (Image == NULL)
    return(SvErrorNoImageBuffer);

  switch (Info->mode)
  {
#ifdef H261_SUPPORT
    case SV_H261_ENCODE:
         stat = svH261Compress(Svh, Image);
         if (CmpBytes)
           *CmpBytes = (int)(Info->h261->TotalBits/8);
         break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_ENCODE:
         stat = svH263Compress(Svh, Image);
         break;
#endif /* H261_SUPPORT */

#ifdef MPEG_SUPPORT
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
         stat = sv_MpegEncodeFrame(Svh, Image);
         break;
#endif /* MPEG_SUPPORT */

#ifdef JPEG_SUPPORT 
    case SV_JPEG_ENCODE:
         {
           SvJpegCompressInfo_t *CInfo;
           u_char *CompBuffer;
           register int i;
           int RetBytes, InLen;

           CInfo = Info->jcomp;
           /*
           ** In case the application forgot to call SvCompressBegin().
           */
           if (!CInfo->CompressStarted) 
             return (SvErrorCompNotStarted);

           if ((u_int)Image%8)
             return (SvErrorNotAligned);

           CompBuffer = CompData;
           /*
           ** Start - add header information
           **       - needed if we want to conform to the interchange format
           */
           stat = sv_AddJpegHeader (Svh, CompBuffer, MaxCompLen, &RetBytes);
           RETURN_ON_ERROR (stat);
           CompBuffer += RetBytes;

           /*
           ** Separate input image directly into 8x8 blocks.
           ** level shift to go from signed to unsigned representation
           **    - since we support baseline DCT process only (i.e 8-bit
           **      precision) subtract raw data by 128
           */
           sv_JpegExtractBlocks (Info, Image);

           for (i = 0; i < CInfo->NumComponents; i++)
             CInfo->lastDcVal[i] = 0;

           /*
           ** JPEG business loop:
           */
           {
           register int Cid, HQid, blkN, mcuN, mbn, DcVal;
           float *FQt, *FThresh, *FThreshNeg;
           float *RawData;
           SvRLE_t rle;
           const static long Mask = 0xffL;
           float DCTData[64];
           register float tmp,AcVal;

           CB.Message = CB_PROCESSING;
           /*
           ** Processing within a frame is done on a MCU by MCU basis:
           */
           for (blkN = 0, mcuN = 0 ; mcuN < (int) CInfo->NumMCU; mcuN++)
           {
             /*
             ** Callback user routine every now&then to see if we should abort
             */
             if ((Info->CallbackFunction) && ((i % MCU_CALLBACK_COUNT) == 0))
             {
               SvPictureInfo_t DummyPictInfo;
               (*Info->CallbackFunction)(Svh, &CB, &DummyPictInfo);
               if (CB.Action == CB_ACTION_END) 
                 return(SvErrorClientEnd);
             }
             /*
             ** Account for restart interval, emit restart marker if needed
             */
             if (CInfo->restartInterval)
             {
               if (CInfo->restartsToGo == 0)
                 EmitRestart (CInfo);
               CInfo->restartsToGo--;
             }
             /*
             ** Processing within an MCU is done on a block by block basis:
             */
             for (mbn = 0; mbn < (int) CInfo->BlocksInMCU; mbn++, blkN++)
             {
	       /*
	       ** Figure out the component to which the current block belongs:
	       ** -Due to the way input data is processed by "sv_extract_blocks"
	       **  and under the assumption that the input is YCrCb, 
	       **  Cid is 0,0,1,2 for each block in the MCU
	       */
               switch (mbn) {
	         case 0:
	         case 1:  Cid = 0;  HQid = 0;  break;
	         case 2:  Cid = 1;  HQid = 1;  break;
	         case 3:  Cid = 2;  HQid = 1;  break;
	       }

               RawData = CInfo->BlkTable[blkN];

#ifndef _NO_DCT_
               /*
               ** Discrete Cosine Transform:
	       ** Perform the Forward DCT, take the input data from "RawData"
	       ** and place the computed coefficients in "DCTData":
               */
               ScFDCT8x8 (RawData, DCTData);
#ifndef _NO_QUANT_
               /*
               **  Quantization:
	       **
	       ** Identify the quantization tables:
	       */
	       FQt        = (float *) (CInfo->Qt[HQid])->fval;
	       FThresh    = (float *) (CInfo->Qt[HQid])->fthresh;
	       FThreshNeg = (float *) (CInfo->Qt[HQid])->fthresh_neg;

	       /*
	       ** Quantize the DC value first:
	       */
	       tmp = DCTData[0] *FQt[0];
               if (tmp < 0)
	         DcVal = (int) (tmp - 0.5);
               else
	         DcVal = (int) (tmp + 0.5);

	       /* 
	       ** Go after (quantize) the AC coefficients now:
	       */
               for (rle.numAC = 0, i = 1; i < 64; i++)
               {
	         AcVal = DCTData[ZagIndex[i]];
 
	         if (AcVal > FThresh[i]) {
	           rle.ac[rle.numAC].index = i;
	           rle.ac[rle.numAC++].value = (int) (AcVal * FQt[i] + 0.5);
	         }
	         else if (AcVal < FThreshNeg[i]) {
	           rle.ac[rle.numAC].index = i;
	           rle.ac[rle.numAC++].value = (int) (AcVal * FQt[i] - 0.5);
	         }
               }

               /*
               ** DPCM coding:
	       **
	       ** Difference encoding of the DC value, 
	       */
	       rle.dc = DcVal - CInfo->lastDcVal[Cid];
	       CInfo->lastDcVal[Cid] = DcVal;

#ifndef _NO_HUFF_
               /*
               ** Entropy Coding:
	       **
	       ** Huffman encode the current block
	       */
  	       sv_EncodeOneBlock (&rle, CInfo->DcHt[HQid], CInfo->AcHt[HQid]); 
	       FlushBytes(&CompBuffer);
#endif /* _NO_HUFF_ */
#endif /* _NO_QUANT_ */
#endif /* _NO_DCT_ */
             }
           }
           }
           (void ) sv_HuffEncoderTerm (&CompBuffer);

           Info->OutputFormat.biSize = CompBuffer - CompData;
           InLen = MaxCompLen - Info->OutputFormat.biSize;

           /*
           ** JPEG End:
           ** - add trailer information to the compressed bitstream, 
           **   - needed if we want to conform to the interchange format
           */
           stat = sv_AddJpegTrailer (Svh, CompBuffer, InLen, &RetBytes);
           RETURN_ON_ERROR (stat);
           CompBuffer += RetBytes;
           Info->OutputFormat.biSize += RetBytes;
           if (CmpBytes)
             *CmpBytes = CompBuffer - CompData;
         }
         break;
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_ENCODE:
         stat = sv_HuffEncodeFrame(Svh, Image);
         break;
#endif /* HUFF_SUPPORT */

    default:
         return(SvErrorCodecType);
  }

  Info->NumOperations++;
  /*
  ** If an Image buffer was taken from the queue, do a callback
  ** to let the client free or re-use the buffer.
  */
  if (Info->CallbackFunction && UsedQ)
  {
    CB.Message = CB_RELEASE_BUFFER;
    CB.Data  = Image;
    CB.DataSize = ImageSize;
    CB.DataUsed = ImageSize;
    CB.DataType = CB_DATA_IMAGE;
    CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*(Info->CallbackFunction))(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
             printf("Compress Callback: RELEASE_BUFFER Addr=0x%x, Action=%d\n",
                 CB.Data, CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return(SvErrorClientEnd);
  }
  return (stat);
}

static SvStatus_t sv_ConvertRGBToSepComponent(u_char *Iimage,
BITMAPINFOHEADER * Bmh, u_char *comp1, u_char *comp2, u_char *comp3, 
int pixels, int lines)
{
  register i;
  int bpp = Bmh->biBitCount;
  u_int *Ip = (u_int *)Iimage;
  u_short *Is = (u_short *)Iimage;

  if (bpp == 24) {
    if (Bmh->biCompression == BI_RGB) {
      for (i = 0 ; i < pixels*lines ; i++) {
        comp3[i] = *Iimage++; /* Blue */
        comp2[i] = *Iimage++; /* Green */
        comp1[i] = *Iimage++; /* Red */
      }
    }
    else if (Bmh->biCompression == BI_DECXIMAGEDIB) {
                             /* RGBQUAD structures: (B,G,R,0) */
      for (i = 0 ; i < pixels*lines ; i++) {
        comp3[i] = *Iimage++; /* Blue */
        comp2[i] = *Iimage++; /* Green */
        comp1[i] = *Iimage++; /* Red */
        Iimage++;             /* Reserved */
      }
    }
  }
  else if (bpp == 32) {      /* RGBQUAD structures: (B,G,R,0) */
    for (i = 0 ; i < pixels*lines ; i++) {
      comp3[i] = (Ip[i] >> 24) & 0xFF;
      comp2[i] = (Ip[i] >> 16) & 0xFF;
      comp1[i] = (Ip[i] >> 8)  & 0xFF;
    }
  }
  else if (bpp == 16) {
    for (i = 0 ; i < pixels*lines ; i++) {
      comp1[i] = (Is[i] >> 7) & 0xf8;
      comp2[i] = (Is[i] >> 2) & 0xf8;
      comp3[i] = (Is[i] << 3) & 0xf8;
    }
  }
  return (NoErrors);
}


/*
** Name:     SvCompressQuery
** Purpose:  Determine if Codec can Compress desired format
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = Pointer to BITMAPINFOHEADER structure describing format
**           ImgOut = Pointer to BITMAPINFOHEADER structure describing format
*/
SvStatus_t SvCompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut)
{
   /*
   ** We don't *really* need the Info structures, but we check for
   ** NULL pointers to make sure the CODEC,  whoes ability is being
   ** queried, was at least opened.
   */
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   if (!ImgIn && !ImgOut)
     return(SvErrorBadPointer);

   if (!IsSupported(_SvCompressionSupport,
                    ImgIn ? ImgIn->biCompression : -1, 
                    ImgIn ? ImgIn->biBitCount : -1,
                    ImgOut ? ImgOut->biCompression : -1, 
                    ImgOut ? ImgOut->biBitCount : -1))
     return(SvErrorUnrecognizedFormat);
	 
   /*
   ** For speed we impose a restriction that the image size should be
   ** a multiple of 16x8. This insures that we would have at least one
   ** MCU for a 4:2:2 image
   **
   ** NOTE: This is an artificial restriction from JPEG's perspective.
   **       In the case when the dimesnsions are otherwise, we should
   **       pixel replicate and/or line replicate before compressing.
   */
   if (ImgIn)
   {
     if (ImgIn->biWidth  <= 0 || ImgIn->biHeight == 0)
       return(SvErrorBadImageSize);
     if ((ImgIn->biWidth%16) || (ImgIn->biHeight%8))
       return (SvErrorNotImplemented);
   }

   if (ImgOut) /* Query Output also */
   {
     if (ImgOut->biWidth <= 0 || ImgOut->biHeight == 0)
       return (SvErrorBadImageSize);
     if (ImgOut->biCompression == BI_DECH261DIB)
     {
       if ((ImgOut->biWidth != CIF_WIDTH && ImgOut->biWidth != QCIF_WIDTH) ||
	   (abs(ImgOut->biHeight) != CIF_HEIGHT && abs(ImgOut->biHeight) != QCIF_HEIGHT))
       return (SvErrorBadImageSize);
     }
   }

   return(NoErrors);
}


/*
** Name:    SvGetCompressSize
** Purpose:
**
*/
SvStatus_t SvGetCompressSize (SvHandle_t Svh, int *MaxSize)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!MaxSize)
     return (SvErrorBadPointer);

   /*
   ** We are being extra cautious here, it would reflect poorly on the JPEG 
   ** commitee is the compressed bitstream was so big
   */
   *MaxSize = 2 * Info->InputFormat.biWidth * abs(Info->InputFormat.biHeight);

   return(NoErrors);
}



#ifdef JPEG_SUPPORT
/*
** Name:     SvGetQuality
** Purpose:
**
*/
SvStatus_t SvGetQuality (SvHandle_t Svh, int *Quality)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Quality)
     return (SvErrorBadPointer);

   *Quality = Info->jcomp->Quality;

   return (NoErrors);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:    SvSetQuality
** Purpose: 
**
*/
SvStatus_t SvSetQuality (SvHandle_t Svh, int Quality)
{
   int stat,ConvertedQuality;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if ((Quality < 0) || (Quality > 10000))
     return (SvErrorValue);

   Info->jcomp->Quality = Quality;
   ConvertedQuality = 10000 - Quality;
   if (ConvertedQuality < MIN_QUAL)
     ConvertedQuality = MIN_QUAL;
   stat = sv_MakeQTables (ConvertedQuality, Info);
   return (stat);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:     SvGetCompQTables
** Purpose: 
**
*/
SvStatus_t SvGetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
   register int i;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Info->jcomp->CompressStarted)
     return (SvErrorCompNotStarted);

   if (!Qt)
     return (SvErrorBadPointer);

   if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3)) 
     return (SvErrorBadPointer);

   for (i = 0 ; i < 64 ; i++) {
     register int zz = ZigZag[i];
     Qt->c1[i] = (Info->jcomp->Qt[0])->ival[zz];
     Qt->c2[i] = (Info->jcomp->Qt[1])->ival[zz];
     Qt->c3[i] = (Info->jcomp->Qt[1])->ival[zz];
   }

   return(NoErrors);
}
#endif /* JPEG_SUPPORT */

/*
** Name:     SvGetCodecInfo
** Purpose:  Get info about the codec & the data
**
** Args:     Svh = handle to software codec's Info structure.
**
** XXX - does not work for compression, this has to wait for the
**       decompressor to use SvCodecInfo_t struct for this to work
*/
SvStatus_t SvGetInfo (SvHandle_t Svh, SV_INFO_t *lpinfo, BITMAPINFOHEADER *Bmh)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   lpinfo->Version 	     = SLIB_VERSION;
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_ENCODE:
           lpinfo->CodecStarted = Info->jcomp->CompressStarted;
           break;
     case SV_JPEG_DECODE:
           lpinfo->CodecStarted = Info->jdcmp->DecompressStarted;
           break;
#endif /* JPEG_SUPPORT */
     default:
           lpinfo->CodecStarted = 0;
           break;
   }
   lpinfo->NumOperations     = Info->NumOperations;

   *Bmh = Info->InputFormat;
   return(NoErrors);
}



/*
** Name:     sv_GetComponentPointers
** Purpose:  Given a pointer to an image and its size,
**           return pointers to the individual image components
**
** Args:     pixels   = number of pixels in a line.
**           lines    = number of lines in image.
**           Image    = Pointer to start of combined image data
**           MaxLen   = Size of image data in bytes
**           comp1/2/3= pointers to pointers to individual components
*/
static SvStatus_t sv_GetYUVComponentPointers(int biCompression, 
		    int pixels, int lines, u_char *Image, 
		    int MaxLen, u_char **comp1, u_char **comp2, u_char **comp3)
{
  u_int sz1,sz2,sz3,maxlen;

  sz1 = pixels * lines; 
  sz2 = sz3 = (IsYUV411Sep(biCompression)) ? (sz1 / 4) : 
              ((IsYUV1611Sep(biCompression)) ? (pixels * lines / 16) 
                                             : (sz1 / 2));
  maxlen = (MaxLen > 0) ? (u_int) MaxLen : 0 ;
  if (biCompression == BI_DECGRAYDIB) {
    if (sz1 > maxlen)
      return(SvErrorBadImageSize);
    *comp1 = Image;
    *comp2 = NULL;
    *comp3 = NULL;
  }
  else {
    if ((sz1+sz2+sz3) > maxlen)
      return(SvErrorBadImageSize);
    *comp1 = Image;
    *comp2 = Image + sz1;
    *comp3 = Image + sz1 + sz2;
  }
  return(SvErrorNone);
}



#ifdef JPEG_SUPPORT
/*
** Name:     sv_JpegExtractBlocks 
** Purpose:  
**
** Note:    If we did our job right, memory for all global structures should 
**	    have been allocated by the upper layers, we do not waste time 
**	    checking for NULL pointers at this point
**
*/
static SvStatus_t sv_JpegExtractBlocks (SvCodecInfo_t *Info, u_char *RawImage)
{
  SvJpegCompressInfo_t *CInfo = (SvJpegCompressInfo_t *)Info->jcomp;
  int size = Info->Width * Info->Height;
  u_char *TempImage;
  SvStatus_t stat;

  if (IsYUV422Packed(Info->InputFormat.biCompression))
    /*
    ** This will extract chunks of 64 bytes (8x8 blocks) from the uncompressed
    ** 4:2:2 interleaved input video frame and place them in three separate 
    ** linear arrays for later processing.
    **	XXX - should also do level shifting in this routine
    ** 
    */
    ScConvert422iTo422sf_C(RawImage, 16, 
			     (float *)(CInfo->BlkBuffer),
			     (float *)(CInfo->BlkBuffer + size),
			     (float *)(CInfo->BlkBuffer + size + size/2),
			     Info->Width, 
			     Info->Height);

  else if (IsYUV422Sep(Info->InputFormat.biCompression))
    /*
    ** Same but RawImage is not interleaved. Three components are sequential.
    */
    ScConvertSep422ToBlockYUV (RawImage, 16, 
				(float *)(CInfo->BlkBuffer),
				(float *)(CInfo->BlkBuffer + size),
				(float *)(CInfo->BlkBuffer + size + size/2),
				Info->Width, 
				Info->Height);

  else if (Info->InputFormat.biCompression == BI_DECGRAYDIB)
    /*
    ** Grayscale: one component
    */
    ScConvertGrayToBlock (RawImage, 
                          8, 
			  (float *)(CInfo->BlkBuffer),
			  Info->Width, 
			  Info->Height);

  if ((Info->InputFormat.biCompression == BI_RGB) ||
      (Info->InputFormat.biCompression == BI_DECXIMAGEDIB) ||
      (ValidateBI_BITFIELDS(&Info->InputFormat) != InvalidBI_BITFIELDS))
  {
      TempImage = (u_char *)ScPaMalloc (3 * Info->Width * Info->Height);

      if (TempImage == NULL)
	 return(ScErrorMemory);

      stat = ScRgbInterlToYuvInterl(
		 &Info->InputFormat,
		 (int)Info->Width, 
		 (int)Info->Height,
		 RawImage, 
		 (u_short *) TempImage);
      RETURN_ON_ERROR (stat);

      ScConvert422iTo422sf_C(
          TempImage, 
          16,
	  (float *)(CInfo->BlkBuffer),
	  (float *)(CInfo->BlkBuffer + size),
	  (float *)(CInfo->BlkBuffer + size + size/2),
	  Info->Width,
	  Info->Height);

     ScPaFree(TempImage);
  }

  return (NoErrors);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:    SvSetQuantMode
** Purpose: Used only in the "Q Conversion" program "jpegconvert" to
**          set a flag in the comp & decomp info structures that causes
**          the quantization algorithm to use the new or old versions
**          of JPEG quantization.
**
*/
SvStatus_t SvSetQuantMode (SvHandle_t Svh, int QuantMode)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if ((QuantMode != SV_JPEG_QUANT_OLD) && (QuantMode != SV_JPEG_QUANT_NEW))
     return (SvErrorValue);

   if (Info->jdcmp)
     Info->jdcmp->QuantMode = QuantMode;
   if (Info->jcomp)
     Info->jcomp->QuantMode = QuantMode;

   return (NoErrors);
}
#endif /* JPEG_SUPPORT */

/*
** Name: SvSetParamBoolean()
** Desc: Generic call used to set specific BOOLEAN (TRUE or FALSE) parameters
**       of the CODEC.
*/
SvStatus_t SvSetParamBoolean(SvHandle_t Svh, SvParameter_t param, 
                                             ScBoolean_t value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamBoolean()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamBoolean(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamBoolean(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamBoolean(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvSetParamInt()
** Desc: Generic call used to set specific INTEGER (qword) parameters
**       of the CODEC.
*/
SvStatus_t SvSetParamInt(SvHandle_t Svh, SvParameter_t param, qword value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamInt()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamInt(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamInt(Svh, param, value);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamInt(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvSetParamFloat()
** Desc: Generic call used to set specific FLOAT parameters of the CODEC.
*/
SvStatus_t SvSetParamFloat(SvHandle_t Svh, SvParameter_t param, float value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamFloat()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamFloat(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamFloat(Svh, param, value);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamFloat(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvGetParamBoolean()
** Desc: Generic call used to get the setting of specific BOOLEAN (TRUE or FALSE)
**       parameters of the CODEC.
*/
ScBoolean_t SvGetParamBoolean(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(FALSE);
  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
    /* this code should be moved into JPEG codec: svJPEGGetParamBoolean()  */
    case SV_JPEG_DECODE:
    case SV_JPEG_ENCODE:
           switch (param)
           {
              case SV_PARAM_BITSTREAMING:
                    return(FALSE);  /* this is a frame-based codecs */
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamBoolean(Svh, param));
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* this code should be moved into H261 codec: svH261GetParamBoolean()  */
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamBoolean(Svh, param));
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamBoolean(Svh, param));
           break;
#endif /* H263_SUPPORT */
  }
  return(FALSE);
}

/*
** Name: SvGetParamInt()
** Desc: Generic call used to get the setting of specific INTEGER (qword)
**       parameters of the CODEC.
*/
qword SvGetParamInt(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(0);
  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
    /* this code should be moved into JPEG codec: svJPEGGetParamInt() */
    case SV_JPEG_DECODE:
    case SV_JPEG_ENCODE:
           switch (param)
           {
              case SV_PARAM_NATIVEFORMAT:
                    return(BI_YU16SEP);
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* this code should be moved into H261 codec: svH261GetParamInt()  */
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamInt(Svh, param));
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamInt(Svh, param));
           break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamInt(Svh, param));
#endif /* MPEG_SUPPORT */
  }
  switch (param)
  {
     case SV_PARAM_FINALFORMAT:
           return(Info->OutputFormat.biCompression);
  }
  return(0);
}

/*
** Name: SvGetParamBoolean()
** Desc: Generic call used to get the setting of specific FLOAT
**       parameters of the CODEC.
*/
float SvGetParamFloat(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(0.0f);
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamFloat(Svh, param));
#endif
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamFloat(Svh, param));
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamFloat(Svh, param));
#endif /* H263_SUPPORT */
  }
  return(0.0f);
}

/*
** Name:     sv_copy_bmh
** Purpose:  Copy a BITMAPINFOHEADER struct.  For now, it only knows about the 
**           extra DWORD masks at the end of BI_BITFIELDS bitmapinfoheaders.
**           Otherwise, it treats others (such as 8 bit rgb, or jpeg) the
**           same as a vanilla bitmapinfoheader.
*/
static void sv_copy_bmh (
    BITMAPINFOHEADER *ImgFrom, 
    BITMAPINFOHEADER *ImgTo)
{
    *ImgTo = *ImgFrom;

    if (ImgFrom->biCompression == BI_BITFIELDS)
        bcopy(ImgFrom + 1, ImgTo + 1, 3*sizeof(DWORD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sv.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SV.h,v $
 * Revision 1.1.10.6  1996/10/28  17:32:21  Hans_Graves
 * 	MME-01402. Added TimeStamp support to Callbacks.
 * 	[1996/10/28  17:05:52  Hans_Graves]
 *
 * Revision 1.1.10.5  1996/10/12  17:18:18  Hans_Graves
 * 	Rearranged PARAMs. Added SV_PARAM_HALFPEL and SV_PARAM_SKIPPEL.
 * 	[1996/10/12  16:55:44  Hans_Graves]
 * 
 * Revision 1.1.10.4  1996/09/18  23:45:53  Hans_Graves
 * 	More PARAMs
 * 	[1996/09/18  21:56:45  Hans_Graves]
 * 
 * Revision 1.1.10.3  1996/07/19  02:11:02  Hans_Graves
 * 	Added SV_PARAM_DEBUG
 * 	[1996/07/19  01:23:39  Hans_Graves]
 * 
 * Revision 1.1.10.2  1996/05/07  19:55:54  Hans_Graves
 * 	Added SV_HUFF_DECODE and SV_HUFF_ENCODE
 * 	[1996/05/07  17:23:47  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/04/10  21:47:20  Hans_Graves
 * 	Added PARAMs. Replaced externs with EXTERN.
 * 	[1996/04/10  21:22:51  Hans_Graves]
 * 
 * Revision 1.1.8.5  1996/04/04  23:35:03  Hans_Graves
 * 	Added SV_PARAM_FINALFORMAT enum
 * 	[1996/04/04  23:02:48  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/04/01  15:17:45  Bjorn_Engberg
 * 	Replace include mmsystem.h with windows.h and mmreg.h for NT.
 * 	[1996/04/01  14:58:57  Bjorn_Engberg]
 * 
 * Revision 1.1.8.3  1996/03/29  22:21:06  Hans_Graves
 * 	Include <mmsystem.h> here only
 * 	[1996/03/29  21:48:59  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/03/16  19:22:55  Karen_Dintino
 * 	added H261 NT includes
 * 	[1996/03/16  18:39:31  Karen_Dintino]
 * 
 * Revision 1.1.6.4  1996/02/06  22:53:54  Hans_Graves
 * 	Added PARAM enums
 * 	[1996/02/06  22:18:07  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/01/02  18:31:16  Bjorn_Engberg
 * 	Added and improved function prototypes.
 * 	[1996/01/02  15:03:05  Bjorn_Engberg]
 * 
 * Revision 1.1.6.2  1995/12/07  19:31:23  Hans_Graves
 * 	Added defs for SV_MPEG_ENCODE,SV_MPEG2_DECODE,SV_MPEG2_ENCODE,IT_FULL,FULL_WIDTH,FULL_HEIGHT
 * 	[1995/12/07  17:59:38  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/09/22  18:17:02  Hans_Graves
 * 	Remove MPEG_SUPPORT, H261_SUPPORT, and JPEG_SUPPORT
 * 	[1995/09/22  18:14:14  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/09/22  15:04:40  Hans_Graves
 * 	Added definitions for MPEG_SUPPORT, H261_SUPPORT, and JPEG_SUPPORT
 * 	[1995/09/22  15:04:22  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/09/20  14:59:39  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:40:10  Bjorn_Engberg]
 * 
 * 	Add ICMODE_OLDQ flag on ICOpen for softjpeg to use old quant tables
 * 	[1995/08/31  20:57:52  Paul_Gauthier]
 * 
 * Revision 1.1.2.15  1995/09/05  14:52:39  Hans_Graves
 * 	Removed BI_* definitions - moved to SC.h
 * 	[1995/09/05  14:50:45  Hans_Graves]
 * 
 * Revision 1.1.2.14  1995/08/31  21:13:27  Paul_Gauthier
 * 	Add SV_JPEG_QUANT_NEW/OLD definitions
 * 	[1995/08/31  21:13:04  Paul_Gauthier]
 * 
 * Revision 1.1.2.12  1995/08/08  13:21:17  Hans_Graves
 * 	Added Motion Estimation types
 * 	[1995/08/07  22:03:30  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/31  21:11:02  Karen_Dintino
 * 	Add yuv12 definition
 * 	[1995/07/31  19:27:58  Karen_Dintino]
 * 
 * Revision 1.1.2.10  1995/07/26  17:48:56  Hans_Graves
 * 	Added prototypes for sv_GetMpegImageInfo() and sv_GetH261ImageInfo().
 * 	[1995/07/26  17:45:14  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/21  17:41:03  Hans_Graves
 * 	Moved Callback related stuff to SC.h
 * 	[1995/07/21  17:27:31  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/17  22:01:33  Hans_Graves
 * 	Defined SvBufferInfo_t as ScBufferInfo_t.
 * 	[1995/07/17  21:45:06  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/17  16:12:05  Hans_Graves
 * 	Added extern's to prototypes.
 * 	[1995/07/17  15:56:16  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/01  18:43:17  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.4 **}
 * 		{** Merge revision:	1.1.2.5 **}
 * 	{** End **}
 * 	Add H.261 Decompress support
 * 	[1995/07/01  18:27:43  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/06/22  21:35:06  Hans_Graves
 * 	Moved filetypes to SC.h
 * 	[1995/06/22  21:29:42  Hans_Graves]
 * 
 * 	Added TimeCode parameter to SvPictureInfo struct
 * 	[1995/04/26  19:23:55  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/19  20:30:48  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:13:47  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/06/09  18:33:31  Hans_Graves
 * 	Added SvGetInputBitstream() prototype.
 * 	[1995/06/09  16:36:52  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:38  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:28:39  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/01/17  16:40:30  Paul_Gauthier
 * 	Use Modified Adjust LUTs for Indeo video
 * 	[1995/01/17  16:38:31  Paul_Gauthier]
 * 
 * Revision 1.1.2.8  1994/12/12  15:39:28  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:34:59  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/11/18  18:48:26  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:45:02  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/11/08  21:58:59  Paul_Gauthier
 * 	Changed <mmsystem.h> to <mme/mmsystem.h>
 * 	[1994/11/08  21:47:58  Paul_Gauthier]
 * 
 * Revision 1.1.2.5  1994/10/25  19:17:47  Paul_Gauthier
 * 	Changes for random access
 * 	[1994/10/25  19:09:07  Paul_Gauthier]
 * 
 * Revision 1.1.2.4  1994/10/13  20:34:55  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/12  21:08:45  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/10  21:45:43  Tom_Morris
 * 	Rename Status to not conflict with X11
 * 	[1994/10/10  21:44:59  Tom_Morris]
 * 
 * Revision 1.1.2.2  1994/10/07  14:51:19  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:56:05  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*	"%Z% %M% revision %I%; last modified %G%"; */
/*
**                              SV.h 
**
**    User required data structures for Software Video Codec
**
*/

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*---------------------------------------------------------------------------
 * Modification History: SV.h 
 *
 *   08-Sep-1994  PSG   Modified to include MPEG decoder
 *   10-Jan-1994  VB	Created for SLIB 
 *--------------------------------------------------------------------------*/

#ifndef _SV_H_
#define _SV_H_

#ifndef _SV_COMMON_
#define _SV_COMMON_

#include <sys/types.h>
#include "SC.h"

#define SV_CONTINUE 0
#define SV_ABORT    1

typedef void      *SvHandle_t;       /* Identifies a codec or renderer */
typedef ScStatus_t SvStatus_t;       /* Return status code */

#ifdef WIN32
#include <windows.h>
#include <mmreg.h>
#else /* !WIN32 */
#include <mmsystem.h> 
#endif /* !WIN32 */

#endif /* _SV_COMMON_ */

#define SV_USE_BUFFER       STREAM_USE_BUFFER
#define SV_USE_BUFFER_QUEUE STREAM_USE_QUEUE
#define SV_USE_FILE         STREAM_USE_FILE

typedef enum {
   SV_JPEG_DECODE = 100,
   SV_JPEG_ENCODE = 101,
   SV_MPEG_DECODE = 102,
   SV_MPEG_ENCODE = 103,
   SV_MPEG2_DECODE = 104,
   SV_MPEG2_ENCODE = 105,
   SV_H261_DECODE = 106,
   SV_H261_ENCODE = 107,
   SV_H263_DECODE = 108,
   SV_H263_ENCODE = 109,
   SV_HUFF_DECODE = 110,
   SV_HUFF_ENCODE = 111
} SvCodecType_e;

/*
** Parameters
*/
typedef enum {
  /* General params */
  SV_PARAM_WIDTH = 0x10,    /* image width */
  SV_PARAM_HEIGHT,          /* image height */
  SV_PARAM_BITRATE,         /* bit rate (bits per second) */
  SV_PARAM_NATIVEFORMAT,    /* native decompressed format (FOURCC) */
  SV_PARAM_FINALFORMAT,     /* Final format (format returned by codec) */
  SV_PARAM_BITSPERPIXEL,    /* Average bits per pixel */
  SV_PARAM_FPS,             /* frames per second */
  SV_PARAM_ASPECTRATIO,     /* Aspect ratio: height/width */
  SV_PARAM_BITSTREAMING,    /* is this a bitstreaming CODEC */
  /* Frame params */
  SV_PARAM_FRAME = 0x30,    /* current frame number */
  SV_PARAM_KEYSPACING,      /* I frames */
  SV_PARAM_SUBKEYSPACING,   /* P frames */
  /* Timecode/length */
  SV_PARAM_TIMECODE = 0x50, /* Actual frame timecode */
  SV_PARAM_CALCTIMECODE,    /* Calculated frame timecode for start of seq */
  SV_PARAM_LENGTH,          /* total video length in miliiseconds */
  SV_PARAM_FRAMES,          /* total video frames */
  /* Decode params */
  SV_PARAM_FRAMETYPE = 0x70, /* I, P, B or D frame */
  /* Encode params */
  SV_PARAM_ALGFLAGS,        /* Algorithm flags */
  SV_PARAM_MOTIONALG,       /* Motion estimation algorithm */
  SV_PARAM_MOTIONSEARCH,    /* Motion search limit */
  SV_PARAM_MOTIONTHRESH,    /* Motion threshold */
  SV_PARAM_QUANTI,          /* Intra-frame Quantization Step */
  SV_PARAM_QUANTP,          /* Inter-frame Quantization Step */
  SV_PARAM_QUANTB,          /* Bi-drectional frame Quantization Step */
  SV_PARAM_QUANTD,          /* D (preview) frame Quantization Step */
  /* Encode/Decode params */
  SV_PARAM_QUALITY=0x90,    /* Quality: 0=worst 99>=best */
  SV_PARAM_FASTDECODE,      /* Fast decode desired */
  SV_PARAM_FASTENCODE,      /* Fast decode desired */
  SV_PARAM_VBVBUFFERSIZE,   /* Video Buffer Verifier buffer size in bytes */
  SV_PARAM_VBVDELAY,        /* Video Buffer Verifier delay */
  SV_PARAM_FORMATEXT,       /* format extensions (i.e. rtp) */
  SV_PARAM_PACKETSIZE,      /* packet size in bytes (rtp) */
  SV_PARAM_DEBUG,           /* Setup debug info */
} SvParameter_t;

/*
** Old & new quantization modes for use by the "convertjpeg" program
** that converts JPEG clips using old quantiztion algorithm to new algorithm
*/
typedef enum {
   SV_JPEG_QUANT_NEW = 0,
   SV_JPEG_QUANT_OLD = 1
} SvQuantMode_e;

/*
** Store basic info for user about the codec
*/
typedef struct SV_INFO_s {
    u_int Version;              /* Codec version number  */
    int   CodecStarted;         /* SvDecompressBegin/End */
    u_int NumOperations;        /* Current # of decompresses */
} SV_INFO_t;

/*
** Image types
*/
#define IT_NTSC 0
#define IT_CIF  1
#define IT_QCIF 2
#define IT_FULL 3

/*
** Algorithms (Motion Estimation)
*/
#define ME_CRAWL        1
#define ME_BRUTE        2
#define ME_TEST1        3
#define ME_TEST2        4
#define ME_FASTEST      ME_CRAWL

/*
** Standard Image sizes
*/
#define FULL_WIDTH      640
#define FULL_HEIGHT     480
#define NTSC_WIDTH      320
#define NTSC_HEIGHT     240
#define SIF_WIDTH       352
#define SIF_HEIGHT      240
#define CIF_WIDTH       352
#define CIF_HEIGHT      288
#define SQCIF_WIDTH     128
#define SQCIF_HEIGHT    96
#define QCIF_WIDTH      176
#define QCIF_HEIGHT     144
#define CIF4_WIDTH      (CIF_WIDTH*2)
#define CIF4_HEIGHT     (CIF_HEIGHT*2)
#define CIF16_WIDTH     (CIF_WIDTH*4)
#define CIF16_HEIGHT    (CIF_HEIGHT*4)

/******************** MPEG structures & constants ***************************/

/*
** Picture types
*/
#define SV_I_PICTURE 1
#define SV_P_PICTURE 2
#define SV_B_PICTURE 4
#define SV_D_PICTURE 8
#define SV_ANY_PICTURE  SV_I_PICTURE | SV_P_PICTURE | SV_B_PICTURE
#define SV_ALL_PICTURES SV_ANY_PICTURE | SV_D_PICTURE

/*
** Status values returned by SvFindNextPicture
*/
#define SV_CAN_DECOMPRESS    1
#define SV_CANNOT_DECOMPRESS 2

/*
** SvPictureInfo_t describes picture found by CODEC
*/
typedef struct SvPictureInfo_s {
  int Type;                     /* SV_I_PICTURE | SV_P_PICTURE |             */
                                /* SV_B_PICTURE | SV_D_PICTURE               */
  int myStatus;                   /* CAN_DECOMPRESS or CANNOT_DECOMPRESS     */
  int TemporalRef;              /* Temporal reference # from picture header  */
  int PicNumber;                /* Cummulative picture num from stream start */
  qword ByteOffset;             /* Cummulative byte offset from stream start */
  qword TimeCode;               /* TimeCode: hours (5 bits), min (6 bits),   */
                                /*           sec (6 bits), frame (6 bits)    */
} SvPictureInfo_t;

/*
** SvCallbackInfo_t passes info back & forth during callback
*/
typedef ScCallbackInfo_t SvCallbackInfo_t;

/*
** Structure used in sv_GetMpegImageInfo call
*/
typedef struct SvImageInfo_s {
  int len;                      /* Meaning depends on file format */
  int precision;                /* Bits per pixel */
  int height;                   /* Height of images in pixels */
  int width;                    /* Width  of images in pixels */
  int numcomps;                 /* Number of color components present */
  float picture_rate;           /* Picture rate decoded from seq header */
} SvImageInfo_t;

/******************** End of MPEG structures & constants *********************/


/******************** JPEG structures & constants ****************************/

/*
** Huffman Tables (JPEG)
*/
typedef struct SvHTable_s {
    u_int bits[16];
    u_int value[256];
} SvHTable_t;


typedef struct SvHuffmanTables_s {
    SvHTable_t DcY;
    SvHTable_t DcUV;
    SvHTable_t AcY;
    SvHTable_t AcUV;
} SvHuffmanTables_t;


/*
** Quantization Tables (JPEG)
*/
typedef u_int SvQTable_t;
typedef struct SvQuantTables_s {
    SvQTable_t c1[64];
    SvQTable_t c2[64];
    SvQTable_t c3[64];
} SvQuantTables_t;

/******************** End of JPEG structures & constants *********************/

/*
** Table of contents structure
*/
typedef struct SvToc_s {
    u_int offset;                 /* Byte offset of start of video frame */
    u_int size;                   /* Size in bytes of frame */
    u_int type;                   /* Type of frame (SV_I_PICTURE, ...) */
} SvToc_t;

typedef struct IndexStr {         /* AVI-format table of contents entry */
  size_t        size;
  unsigned long offset;
} IndexStr, indexStr;

#define SvSetRate(Svh, Rate) SvSetParamInt(Svh, SV_PARAM_BITRATE, Rate)
#define SvSetFrameRate(Svh, FrameRate) SvSetParamFloat(Svh, SV_PARAM_FPS, FrameRate)

EXTERN SvStatus_t SvOpenCodec (SvCodecType_e CodecType, SvHandle_t *Svh);
EXTERN SvStatus_t SvCloseCodec (SvHandle_t Svh);
EXTERN SvStatus_t SvDecompressQuery(SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                                    BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvDecompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvGetDecompressSize (SvHandle_t Svh, int *MinSize);
EXTERN SvStatus_t SvDecompress (SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			        u_char *DcmpImage, int MaxOutLen);
EXTERN SvStatus_t SvDecompressEnd (SvHandle_t Svh);
EXTERN SvStatus_t SvSetDataSource (SvHandle_t Svh, int Source, int Fd, 
    			           void *Buffer_UserData, int BufSize);
EXTERN SvStatus_t SvSetDataDestination (SvHandle_t Svh, int Source, int Fd, 
			                void *Buffer_UserData, int BufSize);
EXTERN ScBitstream_t *SvGetDataSource (SvHandle_t Svh);
EXTERN ScBitstream_t *SvGetDataDestination (SvHandle_t Svh);
EXTERN ScBitstream_t *SvGetInputBitstream (SvHandle_t Svh);
EXTERN SvStatus_t SvFlush(SvHandle_t Svh);
EXTERN SvStatus_t SvAddBuffer (SvHandle_t Svh, SvCallbackInfo_t *BufferInfo);
EXTERN SvStatus_t SvFindNextPicture (SvHandle_t Svh, 
                                     SvPictureInfo_t *PictureInfo);
#ifdef JPEG_SUPPORT
EXTERN SvStatus_t SvSetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvGetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvSetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvGetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvSetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvGetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvSetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvGetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvSetQuantMode (SvHandle_t Svh, int QuantMode);
EXTERN SvStatus_t SvGetQuality (SvHandle_t Svh, int *Quality);
EXTERN SvStatus_t SvSetQuality (SvHandle_t Svh, int Quality);
#endif /* JPEG_SUPPORT */

EXTERN SvStatus_t SvSetParamBoolean(SvHandle_t Svh, SvParameter_t param,
                                  ScBoolean_t value);
EXTERN SvStatus_t SvSetParamInt(SvHandle_t Svh, SvParameter_t param,
                                  qword value);
EXTERN SvStatus_t SvSetParamFloat(SvHandle_t Svh, SvParameter_t param,
                                  float value);
EXTERN ScBoolean_t SvGetParamBoolean(SvHandle_t Svh, SvParameter_t param);
EXTERN qword SvGetParamInt(SvHandle_t Svh, SvParameter_t param);
EXTERN float SvGetParamFloat(SvHandle_t Svh, SvParameter_t param);

EXTERN SvStatus_t SvCompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvCompressEnd (SvHandle_t Svh);
EXTERN SvStatus_t SvCompress (SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			 u_char *InputImage, int InLen, int *CmpBytes);
EXTERN SvStatus_t SvCompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvGetCompressSize (SvHandle_t Svh, int *MaxSize);
EXTERN SvStatus_t SvGetInfo (SvHandle_t Svh, SV_INFO_t *lpinfo, 
                                             BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvRegisterCallback (SvHandle_t, 
          int (*Callback)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *),
          void *UserData);
#ifdef MPEG_SUPPORT
EXTERN SvStatus_t SvDecompressMPEG (SvHandle_t Svh, u_char *MultiBuf, 
			     int MaxMultiSize, u_char **ImagePtr);
EXTERN SvStatus_t sv_GetMpegImageInfo(int fd, SvImageInfo_t *iminfo);
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
EXTERN SvStatus_t SvDecompressH261 (SvHandle_t Svh, u_char *MultiBuf,
                             int MaxMultiSize, u_char **ImagePtr);
EXTERN SvStatus_t sv_GetH261ImageInfo(int fd, SvImageInfo_t *iminfo);
#endif /* H261_SUPPORT */

#endif /* _SV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\video.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_video.c,v $
 * Revision 1.1.6.13  1996/12/13  18:19:11  Hans_Graves
 * 	Added initialization of VideoPTimeBase.
 * 	[1996/12/13  18:07:51  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/12/10  19:22:01  Hans_Graves
 * 	Made calculate video positions more accurate using slibFrameToTime100().
 * 	[1996/12/10  19:16:24  Hans_Graves]
 *
 * Revision 1.1.6.11  1996/11/18  23:07:40  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:48:05  Hans_Graves]
 *
 * Revision 1.1.6.10  1996/11/11  18:21:11  Hans_Graves
 * 	Moved setting of VideoMainStream to slib_api.c
 * 	[1996/11/11  18:02:11  Hans_Graves]
 *
 * Revision 1.1.6.9  1996/11/08  21:51:09  Hans_Graves
 * 	Added AC3 support. Better seperation of stream types.
 * 	[1996/11/08  21:28:03  Hans_Graves]
 *
 * Revision 1.1.6.8  1996/10/28  17:32:36  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:11  Hans_Graves]
 *
 * Revision 1.1.6.7  1996/10/12  17:18:59  Hans_Graves
 * 	Seperated TYPE_MPEG2_SYSTEMS into TRANSPORT and PROGRAM.
 * 	[1996/10/12  17:03:19  Hans_Graves]
 *
 * Revision 1.1.6.6  1996/09/29  22:19:45  Hans_Graves
 * 	Added Stride support. YUY2 fixups.
 * 	[1996/09/29  21:32:24  Hans_Graves]
 *
 * Revision 1.1.6.5  1996/09/25  19:16:51  Hans_Graves
 * 	Fix up support for YUY2. Add SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:18  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/09/23  18:04:06  Hans_Graves
 * 	Add reallocation of ScaleBuf if width/height changes.
 * 	[1996/09/23  17:58:27  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/09/18  23:47:25  Hans_Graves
 * 	Added MPEG2 YUV 4:2:2 handling
 * 	[1996/09/18  22:04:18  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/05/07  19:56:25  Hans_Graves
 * 	Added HUFF_SUPPORT.
 * 	[1996/05/07  17:21:23  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/05/02  17:10:37  Hans_Graves
 * 	Reject a data type when header info is not found. Fixes MME-01234
 * 	[1996/05/02  17:09:53  Hans_Graves]
 *
 * Revision 1.1.4.6  1996/04/22  15:04:56  Hans_Graves
 * 	Renamed slibVerifyVideoParams() to slibValidateVideoParams()
 * 	[1996/04/22  14:44:29  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/04/19  21:52:28  Hans_Graves
 * 	Fix Height and Width checking for H261
 * 	[1996/04/19  21:46:27  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/04/01  19:07:58  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:42  Hans_Graves]
 *
 * Revision 1.1.4.3  1996/03/29  22:21:37  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:57:04  Hans_Graves]
 *
 * 	Added MPEG-I Systems encoding support
 * 	[1996/03/27  21:56:00  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/08  18:46:51  Hans_Graves
 * 	Added slibVerifyVideoParams()
 * 	[1996/03/08  18:36:51  Hans_Graves]
 *
 * Revision 1.1.2.12  1996/02/19  18:04:00  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:50  Hans_Graves]
 *
 * Revision 1.1.2.11  1996/02/07  23:24:01  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:39  Hans_Graves]
 *
 * Revision 1.1.2.10  1996/02/02  17:36:06  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:51  Hans_Graves]
 *
 * Revision 1.1.2.9  1996/01/30  22:23:10  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:21:45  Hans_Graves]
 *
 * Revision 1.1.2.8  1996/01/15  16:26:33  Hans_Graves
 * 	No video if SLIB_TYPE_MPEG1_AUDIO or SLIB_TYPE_WAVE
 * 	[1996/01/15  15:47:40  Hans_Graves]
 *
 * Revision 1.1.2.7  1996/01/11  16:17:36  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:41  Hans_Graves]
 *
 * Revision 1.1.2.6  1996/01/08  16:41:35  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:10  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/12/08  20:01:24  Hans_Graves
 * 	Added H.261 compression support.
 * 	[1995/12/08  20:00:52  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/12/07  19:31:37  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:30:12  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/11/09  23:14:08  Hans_Graves
 * 	Added GetVideoTime()
 * 	[1995/11/09  23:09:19  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/11/06  18:47:57  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:36:05  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#define SLIB_INTERNAL
#include "slib.h"
#include "mpeg.h"
#include "h261.h"
#include "h263.h"
#include "jpeg.h"
#include "avi.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

int slibCalcBits(unsigned dword fourcc, int currentbits)
{
  switch (fourcc)
  {
      case BI_DECMPEGDIB:
      case BI_DECH261DIB:
      case BI_MSH261DIB:
      case BI_DECH263DIB:
      case BI_MSH263DIB:
      case JPEG_DIB:
          return(24);
      case MJPG_DIB:
      case BI_YU12SEP:         /* YUV 4:1:1 Planar */
          return(24);
      case BI_DECYUVDIB:       /* YUV 4:2:2 Packed */
      case BI_YUY2:            /* YUV 4:2:2 Packed */
          return(16);
      case BI_YU16SEP:         /* YUV 4:2:2 Planar */
          return(24);
      case BI_YVU9SEP:         /* YUV 16:1:1 Planar */
          return(24);
  }
  return(currentbits);
}

static unsigned dword slibCalcImageSize(unsigned dword fourcc, int bits,
                              int width, int height)
{
  unsigned dword imagesize=0;
  if (width<0) width=-width;
  if (height<0) height=-height;
  switch (fourcc)
  {
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
          imagesize = (width*height*5)/4;
          break;
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
          imagesize = (width*height*3)/2;
          break;
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
          imagesize = width*height*2;
          break;
#ifndef WIN32
      case BI_DECXIMAGEDIB:
          imagesize = width*height*(bits==24 ? 4 : 1);
          break;
#endif /* !WIN32 */
      case BI_RGB:
      case BI_BITFIELDS:
          imagesize = width*height*(bits/8);
          break;
      default:
          imagesize = width*height;
  }
  return(imagesize);
}

static dword slibFOURCCtoVideoType(dword *fourcc)
{
  switch (*fourcc)
  {
    case BI_DECH261DIB:
    case BI_MSH261DIB:
       *fourcc=BI_DECH261DIB;
       return(SLIB_TYPE_H261);
    case BI_DECH263DIB:
    case BI_MSH263DIB:
       *fourcc=BI_DECH263DIB;
       return(SLIB_TYPE_H263);
    case JPEG_DIB:
       return(SLIB_TYPE_JPEG);
    case MJPG_DIB:
       return(SLIB_TYPE_MJPG);
    case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
    case BI_YUY2:      /* YUV 4:2:2 Packed */
    case BI_YU16SEP:   /* YUV 4:2:2 Planar */
    case BI_YU12SEP:   /* YUV 4:1:1 Planar */
    case BI_YVU9SEP:   /* YUV 16:1:1 Planar */
       return(SLIB_TYPE_YUV);
    default:
       _SlibDebug(_WARN_, printf("Unsupported AVI format\n") );
  }
  return(0);
}

static void slibUpdateVideoFrames(SlibInfo_t *Info)
{
#ifdef MPEG_SUPPORT
  if (Info->VideoLengthKnown==FALSE && slibDataOnPin(Info, SLIB_DATA_VIDEO) &&
           Info->FileSize>0 && Info->FileSize<Info->OverflowSize)
  {
    if (SlibTypeIsMPEGVideo(Info->Type))
    {
      dword frames = slibCountCodesOnPin(Info,
                                    slibGetPin(Info, SLIB_DATA_VIDEO),
                                    MPEG_PICTURE_START, 4, 0);
      if (Info->FramesPerSec)
        Info->VideoLength=slibFrameToTime(Info, frames);
      Info->VideoLengthKnown=TRUE;
    }
  }
#endif /* MPEG_SUPPORT */
}

void SlibUpdateVideoInfo(SlibInfo_t *Info)
{
  int inbpp=24, outbpp=24, compformat=0, dcmpformat=0;
  SlibTime_t ptime;
  _SlibDebug(_DEBUG_, printf("SlibUpdateVideoInfo()\n") );

  if (SlibTypeIsAudioOnly(Info->Type)) /* no video? */
    return;
  if (Info->Mode == SLIB_MODE_COMPRESS)
  {
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
      case SLIB_TYPE_MPEG2_VIDEO:
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
            compformat=BI_DECMPEGDIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = SIF_WIDTH;
            Info->Height = SIF_HEIGHT;
            Info->FramesPerSec = 25.0F;
            Info->VideoBitRate = 1152000;
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
      case SLIB_TYPE_RTP_H261:
            compformat=BI_DECH261DIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = CIF_WIDTH;
            Info->Height = CIF_HEIGHT;
            Info->FramesPerSec = 15.0F;
            Info->VideoBitRate = 352000;
            break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
      case SLIB_TYPE_RTP_H263:
            compformat=BI_DECH263DIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = CIF_WIDTH;
            Info->Height = CIF_HEIGHT;
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
            compformat=BI_DECHUFFDIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = 320;
            Info->Height = 240;
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            break;
#endif /* HUFF_SUPPORT */
      default:
            break;
    }
  }
  else if (Info->Mode == SLIB_MODE_DECOMPRESS)
  {
    unsigned char *buf;
    unsigned dword size;
    Info->VideoStreams=1;
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
      case SLIB_TYPE_MPEG2_VIDEO:
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
      case SLIB_TYPE_MPEG_TRANSPORT:
      case SLIB_TYPE_MPEG_PROGRAM:
            _SlibDebug(_DEBUG_,
                 printf("SlibUpdateVideoInfo() MPEG1 or MPEG2\n") );
            if (!slibLoadPin(Info, SLIB_DATA_VIDEO))
            {
              _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() No VIDEO data\n") );
              Info->Type=SLIB_TYPE_UNKNOWN;
              Info->VideoStreams=0;
              return;
            }
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, MPEG_SEQ_HEAD,
                                         MPEG_SEQ_HEAD_LEN/8, FALSE);
            if (buf)
            {
              const float fps[16] = {
               30.0F, 23.976F, 24.0F, 25.0F, 29.97F, 30.0F, 50.0F, 59.94F,
               60.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F
              };
             /*  ScDumpChar(buf, size, 0); */
              Info->Width = ((int)buf[0])*16+(int)(buf[1]>>4);
              Info->Height = ((int)buf[1]&0x0F)*256+(int)buf[2];
              /* must be 16x16 because of Render limitations, round up */
              Info->Width += (Info->Width%16) ? 16-(Info->Width%16) : 0;
              Info->Height += (Info->Height%16) ? 16-(Info->Height%16) : 0;
              Info->FramesPerSec = fps[buf[3]&0x0F];
              Info->VideoBitRate = (((dword)buf[4]&0xFF)<<10) +
                                   (((dword)buf[5])<<2) +
                                    (dword)(buf[6]>>6);
              Info->VideoBitRate *= 400;
              Info->VBVbufSize = ((int)buf[6]&0x1F)<<5 | (int)(buf[7]>>3);
              Info->VBVbufSize *= 2*1024;
              _SlibDebug(_DEBUG_, printf("VBVbufSize=%d\n", Info->VBVbufSize) );
              if (Info->VideoBitRate)
              {
                qword secs=(qword)(((qword)Info->FileSize*80L)
                                                       /Info->VideoBitRate);
                Info->VideoLength = secs*100;
                _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() VideoLength = %ld  Bitrate=%ld\n",
                                Info->VideoLength, Info->VideoBitRate) );
              }
            }
            else /* invalid format */
            {
              _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() Didn't find MPEG sequence header\n") );
              Info->Type=SLIB_TYPE_UNKNOWN;
              Info->VideoStreams=0;
              return;
            }
            compformat=BI_DECMPEGDIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_MPEG1_VIDEO;
            /* check to see if this is MPEG 2 */
            _SlibDebug(_DEBUG_,
              printf("Searching for MPEG 2 extensions...\n") );
            do {
              buf = slibSearchBuffersOnPin(Info,
                                           slibGetPin(Info, SLIB_DATA_VIDEO),
                                           buf, &size, MPEG_START_CODE,
                                           MPEG_START_CODE_LEN/8, FALSE);
              if (buf && buf[0]==MPEG_EXT_START_BASE)
              {
                _SlibDebug(_DEBUG_,
                  printf("Found START CODE %X, ID=%d\n", buf[0], buf[1]>>4) );
                if ((buf[1]>>4)==MPEG_SEQ_ID) /* has to be MPEG 2 */
                {
                  if (Info->Type==SLIB_TYPE_MPEG1_VIDEO)
                    Info->Type=SLIB_TYPE_MPEG2_VIDEO;
                  else if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS)
                    Info->Type=SLIB_TYPE_MPEG_SYSTEMS_MPEG2;
                  Info->VideoType=SLIB_TYPE_MPEG2_VIDEO;
                  switch ((buf[2]>>1)&0x03)
                  {
                    default:
                    case 1: /* 4:1:1 */ dcmpformat=BI_YU12SEP;
                            _SlibDebug(_DEBUG_, printf("4:1:1\n") );
                            break;
                    case 2: /* 4:2:2 */ dcmpformat=BI_YU16SEP;
                            _SlibDebug(_DEBUG_, printf("4:2:2\n") );
                            break;
                    case 3: /* 4:4:4 */ dcmpformat=BI_YU16SEP;
                            _SlibDebug(_DEBUG_, printf("4:4:4\n") );
                            break;
                  }
                  break;
                }
              }
              else
                break;
            } while (1);
            _SlibDebug(_DEBUG_,
              printf("Done searching for MPEG 2 extensions.\n") );
            Info->KeySpacing=12;
            Info->SubKeySpacing=3;
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
      case SLIB_TYPE_RTP_H261:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, H261_START_CODE,
                                         H261_START_CODE_LEN/8, FALSE);
            if (buf)
            {
              if ((buf[0]&0xF0)==0) /* picture start code */
              {
                if (buf[1]&0x08)
                {
                  Info->Width = 352;
                  Info->Height = 288;
                }
                else
                {
                  Info->Width = 176;
                  Info->Height = 144;
                }
              }
              Info->FramesPerSec = 15.0F;
            }
            compformat=BI_DECH261DIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_H261;
            break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
      case SLIB_TYPE_RTP_H263:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, 0x000080,
                                         3, FALSE);
            if (buf)
            {
              switch ((buf[1]>>2)&0x07)
              {
                case H263_SF_SQCIF:
                  Info->Width = SQCIF_WIDTH;
                  Info->Height = SQCIF_HEIGHT;
                  break;
                case H263_SF_QCIF:
                  Info->Width = QCIF_WIDTH;
                  Info->Height = QCIF_HEIGHT;
                  break;
                case H263_SF_4CIF:
                  Info->Width = CIF4_WIDTH;
                  Info->Height = CIF4_HEIGHT;
                  break;
                case H263_SF_16CIF:
                  Info->Width = CIF16_WIDTH;
                  Info->Height = CIF16_HEIGHT;
                  break;
                case H263_SF_CIF:
                default:
                  Info->Width = CIF_WIDTH;
                  Info->Height = CIF_HEIGHT;
              }
              Info->FramesPerSec = 30.0F;
            }
            compformat=BI_DECH263DIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_H263;
            break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf=slibPeekBufferOnPin(Info,
                    slibGetPin(Info,SLIB_DATA_VIDEO), &size, NULL);
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1],
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((int)buf[3]*256)+(int)buf[4];
              Info->Height = ((int)buf[5]*256)+(int)buf[6];
            }
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            compformat=BI_DECHUFFDIB;
            dcmpformat=BI_YU12SEP;
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            Info->VideoType=SLIB_TYPE_SHUFF;
            break;
#endif /* HUFF_SUPPORT */
      case SLIB_TYPE_RASTER:
            buf=slibPeekBufferOnPin(Info, 
                    slibGetPin(Info,SLIB_DATA_COMPRESSED), &size, NULL);
            Info->FramesPerSec = 30.0F;
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1], 
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((int)buf[4]<<24)+((int)buf[5]<<16)+((int)buf[6]<<8)+(int)buf[7];
              Info->Height = ((int)buf[8]<<24)+((int)buf[9]<<16)+((int)buf[10]<<8)+(int)buf[11];

              Info->VideoLength = slibFrameToTime(Info,
                                 (signed qword)Info->FileSize/(Info->Width*Info->Height*3));
            }
            else
              Info->VideoLength = slibFrameToTime(Info, 1);
            Info->VideoBitRate = 0;
            compformat=BI_RGB;
            dcmpformat=BI_YU12SEP;
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            Info->VideoType=SLIB_TYPE_RASTER;
            break;
      case SLIB_TYPE_BMP:
            buf=slibPeekBufferOnPin(Info, 
                    slibGetPin(Info,SLIB_DATA_COMPRESSED), &size, NULL);
            Info->FramesPerSec = 30.0F;
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1], 
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((dword)buf[15]<<24)+((dword)buf[16]<<16)+((dword)buf[17]<<8)+(dword)buf[18];
              Info->Height = ((dword)buf[19]<<24)+((dword)buf[20]<<16)+((dword)buf[21]<<8)+(dword)buf[22];
              compformat=((dword)buf[30]<<24)+((dword)buf[25]<<16)+((dword)buf[26]<<8)+(dword)buf[27];
              inbpp=(dword)buf[28];
              Info->VideoLength = slibFrameToTime(Info,
                                 (signed qword)Info->FileSize/(Info->Width*Info->Height*3));
            }
            else
              Info->VideoLength = slibFrameToTime(Info, 1);
            Info->VideoBitRate = 0;
            Info->VideoType = slibFOURCCtoVideoType(&compformat);
            dcmpformat=BI_YU16SEP;
            outbpp=slibCalcBits(dcmpformat, outbpp);
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            break;

      case SLIB_TYPE_RIFF:
      case SLIB_TYPE_AVI:
            slibLoadPin(Info, SLIB_DATA_COMPRESSED);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info,SLIB_DATA_COMPRESSED),
                                         NULL, &size, AVI_MAINHDR, 4, FALSE);
            if (buf)
            {
              AVI_MainHeader hdr;
              /* printf("%d %d %d %d\n", buf[4], buf[5], buf[6], buf[7]); */
              memcpy(&hdr, buf+4, sizeof(AVI_MainHeader));
              Info->Width  = (short)hdr.dwWidth;
              Info->Height = (short)hdr.dwHeight;
              Info->FramesPerSec = 1000000.0F/hdr.dwMicroSecPerFrame;
              if (Info->FramesPerSec==0.0F)
                Info->FramesPerSec = 30.0F;
              Info->VideoLength = slibFrameToTime(Info, hdr.dwTotalFrames);
              Info->VideoLengthKnown = TRUE;
            }
            buf = slibSearchBuffersOnPin(Info,
                                     slibGetPin(Info,SLIB_DATA_COMPRESSED),
                                     NULL, &size, AVI_STREAMFORMAT, 4, FALSE);
            if (buf)
            {
              AVI_StreamHeader hdr;
              /* printf("%c %c %c %c\n", buf[4], buf[5], buf[6], buf[7]); */
              memcpy(&hdr, buf+20, sizeof(AVI_StreamHeader));
              compformat=hdr.fccType;
              Info->VideoType = slibFOURCCtoVideoType(&compformat);
              switch (Info->VideoType)
              {
                case SLIB_TYPE_JPEG:
                  Info->Type = SLIB_TYPE_JPEG_AVI;
                  dcmpformat=BI_YU16SEP;
                  break;
                case SLIB_TYPE_MJPG:
                  Info->Type = SLIB_TYPE_MJPG_AVI;
                  dcmpformat=BI_YU16SEP;
                  break;
                case SLIB_TYPE_YUV:
                  Info->Type = SLIB_TYPE_YUV_AVI;
                  dcmpformat=compformat;
                  if (IsYUV422Packed(dcmpformat) || IsYUV422Sep(dcmpformat))
                    dcmpformat=BI_YU16SEP;
                  break;
                default:
                  _SlibDebug(_WARN_, printf("Unsupported AVI format\n") );
                  return;
              }
              inbpp=slibCalcBits(compformat, inbpp);
              outbpp=slibCalcBits(dcmpformat, outbpp);
              Info->KeySpacing=1;
              Info->SubKeySpacing=1;
            }
            break;
#ifdef JPEG_SUPPORT
      case SLIB_TYPE_JPEG_QUICKTIME:
      case SLIB_TYPE_JFIF:
            /* not supported - need to know how to parse */
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                    slibGetPin(Info, SLIB_DATA_VIDEO),
                                    NULL, &size, (JPEG_MARKER<<8)|JPEG_SOF0,
                                    2, FALSE);
            if (buf)
            {
              Info->Width  = ((int)buf[5]<<8) + (int)buf[6];
              Info->Height = ((int)buf[3]<<8) + (int)buf[4];
              Info->FramesPerSec = 30.0F;
            }
            compformat=MJPG_DIB;
            dcmpformat=BI_YU16SEP;
            Info->VideoType = SLIB_TYPE_JPEG;
            break;
#endif /* JPEG_SUPPORT */
    }
    slibUpdateVideoFrames(Info);
  }
  if (SlibTypeHasTimeStamps(Info->Type))
  {
    ptime=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_VIDEO), 100*1024);
    if (SlibTimeIsValid(ptime))
      Info->VideoPTimeBase=ptime;
  }
  if (Info->CompVideoFormat==NULL)
    Info->CompVideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
  _SlibDebug(_VERBOSE_,
         printf("Width=%d Height=%d Stride=%d\n",
              Info->Width, Info->Height, Info->Stride) );
  if (Info->CompVideoFormat!=NULL)
  {
    Info->CompVideoFormat->biSize          = sizeof(BITMAPINFOHEADER);
    Info->CompVideoFormat->biWidth         = Info->Width;
    Info->CompVideoFormat->biHeight        = Info->Height;
    Info->CompVideoFormat->biPlanes        = 1;
    Info->CompVideoFormat->biBitCount      = (WORD)inbpp;
    Info->CompVideoFormat->biCompression   = compformat;
    Info->CompVideoFormat->biSizeImage     = 0;
    Info->CompVideoFormat->biXPelsPerMeter = 0;
    Info->CompVideoFormat->biYPelsPerMeter = 0;
    Info->CompVideoFormat->biClrUsed       = 0;
    Info->CompVideoFormat->biClrImportant  = 0;
  }
  if (Info->VideoFormat==NULL)
    Info->VideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
  if (Info->VideoFormat!=NULL)
  {
    Info->VideoFormat->biSize          = sizeof(BITMAPINFOHEADER);
    Info->VideoFormat->biWidth         = Info->Width;
    Info->VideoFormat->biHeight        = Info->Height;
    Info->VideoFormat->biPlanes        = 1;
    Info->VideoFormat->biBitCount      = (WORD)outbpp;
    Info->VideoFormat->biCompression   = dcmpformat;
    Info->VideoFormat->biSizeImage     = 0;
    Info->VideoFormat->biXPelsPerMeter = 0;
    Info->VideoFormat->biYPelsPerMeter = 0;
    Info->VideoFormat->biClrUsed       = 0;
    Info->VideoFormat->biClrImportant  = 0;
  }
  if (Info->CodecVideoFormat==NULL)
  {
    Info->CodecVideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
    if (Info->CodecVideoFormat!=NULL)
      memcpy(Info->CodecVideoFormat, Info->VideoFormat,
                                     sizeof(BITMAPINFOHEADER));
  }
  slibValidateVideoParams(Info);
}

SlibStatus_t slibValidateVideoParams(SlibInfo_t *Info)
{
  dword oldimagesize, codecwidth, codecheight;
  SlibStatus_t status=SlibErrorNone;
  if (Info->CodecVideoFormat)
  {
    codecwidth=Info->CodecVideoFormat->biWidth;
    codecheight=Info->CodecVideoFormat->biHeight;
  }
  else
  {
    codecwidth=Info->Width;
    codecheight=Info->Height;
  }
  if (Info->Mode==SLIB_MODE_COMPRESS)
  {
    switch (Info->Type)
    {
      case SLIB_TYPE_H261:
            if (Info->Width!=CIF_WIDTH && Info->Width!=QCIF_WIDTH)
              status=SlibErrorImageSize;
            if (Info->Height!=CIF_HEIGHT && Info->Height!=QCIF_HEIGHT)
              status=SlibErrorImageSize;
            if (status!=SlibErrorNone) /* set to closest size */
            {
              if (Info->Width<=300)
              {
                codecwidth=QCIF_WIDTH;
                codecheight=QCIF_HEIGHT;
              }
              else
              {
                codecwidth=CIF_WIDTH;
                codecheight=CIF_HEIGHT;
              }
            }
            break;
      case SLIB_TYPE_H263:
            if (Info->Width!=CIF_WIDTH && Info->Width!=SQCIF_WIDTH && Info->Width!=QCIF_WIDTH &&
                Info->Width!=CIF4_WIDTH && Info->Width!=CIF16_WIDTH)
              status=SlibErrorImageSize;
            if (Info->Height!=CIF_HEIGHT && Info->Height!=SQCIF_HEIGHT && Info->Height!=QCIF_HEIGHT &&
                Info->Height!=CIF4_HEIGHT && Info->Height!=CIF16_HEIGHT)
              status=SlibErrorImageSize;
            if (status!=SlibErrorNone) /* set to closest size */
            {
              if (Info->Width<=168)
              {
                codecwidth=SQCIF_WIDTH;
                codecheight=SQCIF_HEIGHT;
              }
              else if (Info->Width<=300)
              {
                codecwidth=QCIF_WIDTH;
                codecheight=QCIF_HEIGHT;
              }
              else if (Info->Width<=(CIF4_WIDTH+CIF_WIDTH)/2)
              {
                codecwidth=CIF_WIDTH;
                codecheight=CIF_HEIGHT;
              }
              else if (Info->Width<=(CIF16_WIDTH+CIF4_WIDTH)/2)
              {
                codecwidth=CIF4_WIDTH;
                codecheight=CIF4_HEIGHT;
              }
              else
              {
                codecwidth=CIF16_WIDTH;
                codecheight=CIF16_HEIGHT;
              }
            }
            break;
    }
    /* height and width must be mults of 8 */
    if (codecwidth%8 || codecheight%8)
      return(SlibErrorImageSize);
    if (status==SlibErrorImageSize)
    {
      if (Info->CodecVideoFormat)
      {
        Info->CodecVideoFormat->biWidth=codecwidth;
        Info->CodecVideoFormat->biHeight=codecheight;
      }
      if (Info->CompVideoFormat)
      {
        Info->CompVideoFormat->biWidth=codecwidth;
        Info->CompVideoFormat->biHeight=codecheight;
      }
    }
  }
  if (Info->VideoFormat)
  {
    oldimagesize=Info->ImageSize;
    Info->ImageSize=slibCalcImageSize(Info->VideoFormat->biCompression,
                                      Info->VideoFormat->biBitCount,
                                      Info->VideoFormat->biWidth,
                                      Info->VideoFormat->biHeight);
    if (Info->ImageSize!=oldimagesize && Info->Imagebuf)
    {
      SlibFreeBuffer(Info->Imagebuf);
      Info->Imagebuf=NULL;
    }
    Info->VideoFormat->biBitCount=(WORD)slibCalcBits(
                                      Info->VideoFormat->biCompression,
                                      Info->VideoFormat->biBitCount);
    Info->VideoFormat->biSizeImage=Info->ImageSize;
  }
  if (Info->CodecVideoFormat)
  {
    oldimagesize=Info->CodecImageSize;
    Info->CodecImageSize=slibCalcImageSize(
                                      Info->CodecVideoFormat->biCompression,
                                      Info->CodecVideoFormat->biBitCount,
                                      Info->CodecVideoFormat->biWidth,
                                      Info->CodecVideoFormat->biHeight);
    if (Info->CodecImageSize!=oldimagesize && Info->CodecImagebuf)
    {
      SlibFreeBuffer(Info->CodecImagebuf);
      Info->CodecImagebuf=NULL;
    }
    Info->CodecVideoFormat->biBitCount=(WORD)slibCalcBits(
                                      Info->CodecVideoFormat->biCompression,
                                      Info->CodecVideoFormat->biBitCount);
    Info->CodecVideoFormat->biSizeImage=Info->CodecImageSize;
  }
  if (Info->VideoFormat && Info->CodecVideoFormat)
  {
    oldimagesize=Info->IntImageSize;
    Info->IntImageSize=slibCalcImageSize(Info->VideoFormat->biCompression,
                                         Info->VideoFormat->biBitCount,
                                         Info->CodecVideoFormat->biWidth,
                                         Info->CodecVideoFormat->biHeight);
    if (Info->IntImageSize!=oldimagesize && Info->IntImagebuf)
    {
      SlibFreeBuffer(Info->IntImagebuf);
      Info->IntImagebuf=NULL;
    }
  }
  /* close format converter since formats may have changed */
  if (Info->Sch)
  {
    SconClose(Info->Sch);
    Info->Sch=NULL;
  }
  if (Info->FramesPerSec)
    Info->VideoFrameDuration=slibFrameToTime100(Info, 1);
  return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\yuv2rgb.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_yuv_to_rgb.c,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: YUV_To_RGB_422_Init                                     */
/*  Author:   Bill Hallahan                                           */
/*  Date:     July 29, 1994                                           */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function produces a table that is used by the         */
/*    yuv_to_rgb_422 conversion routines. This table is required      */
/*    by the following routines.                                      */
/*                                                                    */
/*        YUV_To_RGB_422_24_Bit                                       */
/*        YUV_To_RGB_422_555                                          */
/*                                                                    */
/*                                                                    */
/*         YUV to RGB conversion can be described by a 3x3 matrix     */
/*    multiplication:                                                 */
/*                                                                    */
/*         R     | 1   0  VR |  Y                                     */
/*         G  =  | 1  UG  VG |  U                                     */
/*         B     | 1  UB   0 |  V                                     */
/*                                                                    */
/*         where:                                                     */
/*                                                                    */
/*            0 <= Y <= 255                                           */
/*         -128 <= U <= 127    UG = -0.3455    UB =  1.7790           */
/*         -128 <= V <= 127    VR =  1.4075    VG = -0.7169           */
/*                                                                    */
/*         The Red, Green, and Blue output values are obtained in     */
/*    parallel by summing three 64 bit words as shown. Each of the    */
/*    quadwords is obtained from either the Y_Table, the U_Table,     */
/*    or the V_table using the corresponding 8 bit Y, U, or V value   */
/*    as an index. Thus all multiplications are performed by table    */
/*    lookup. Note that the matrix output is ordered as B, R, G	      */
/*    and then B again (starting at the LSB).			      */
/*    This is to allow an efficient conversion to the output format.  */
/*								      */
/*    For 32-bit RGB, the Red and Blue bits are already in the	      */
/*    correct position, the conversion routine only has to shift      */
/*    the Green bits. For General BI-BITFIELDS however, the Red,      */
/*    Green and Blue bits could be anywhere in a 16-bit or 32-bit     */
/*    word (we only support 16-bit for now). To avoid a costly	      */
/*    decicion in the inner loop whether to shift the Blue bits left  */
/*    or right, we maintain a copy of the Blue bits in position 48    */
/*    so a right shift will always work. Each conversion routine can  */
/*    choose whichever set of Blue bits that are fastest to use,      */
/*    they are identical.					      */
/*								      */
/*                                                                    */
/*           MSW                                         LSW          */
/*                                                                    */
/*           63       48 47       32 31       16 15        0    Index */
/*           -----------------------------------------------          */
/*          |          Y|          Y|          Y|          Y|     Y   */
/*           -----------------------------------------------          */
/*                                                                    */
/*           -----------------------------------------------          */
/*          |         ub|         ug|          0|         ub|     U   */
/*           -----------------------------------------------          */
/*                                                                    */
/*           -----------------------------------------------          */
/*       +  |          0|         vg|         vr|          0|     V   */
/*           -----------------------------------------------          */
/*    __________________________________________________________      */
/*                                                                    */
/*           -----------------------------------------------          */
/*    Total |    0|    0|    x|    G|    x|    R|    x|    B|         */
/*           -----------------------------------------------          */
/*                                                                    */
/*                                                                    */
/*      where:                                                        */
/*                                                                    */
/*          ub = UB * U                                               */
/*          ug = UG * U                                               */
/*          vg = VG * V                                               */
/*          vr = VR * V                                               */
/*                                                                    */
/*                                                                    */
/*         The maximum absolute value for Y is 255 and the maximum    */
/*    for U or V is 128, so 9 bits is the minimum size to represent   */
/*    them together as two's complement values. The maximum           */
/*    chrominance (U or V) magnitude is 128. This is 0.5 as a Q9      */
/*    two's complement fraction. 255 is 1 - 2^-8 in Q9 fraction form. */
/*                                                                    */
/*    The maximum possible bit growth is determined as follows.       */
/*                                                                    */
/*      R_Max = 1 - 2^-8 +                  0.5 * fabs(VR) = 1.6998   */
/*      G_Max = 1 - 2^-8 + 0.5 * fabs(UG) + 0.5 * fabs(VG) = 1.5273   */
/*      B_Max = 1 - 2^-8 + 0.5 * fabs(UB)                  = 1.8856   */
/*                                                                    */
/*                                                                    */
/*         Since B_Max = 1.8856 then the next highest integer         */
/*    greater than or equal to log base 2 of 1.8856 is 1. So 1 bit    */
/*    is required for bit growth. The minimum accumulator size        */
/*    required is 9 + 1 = 10 bits. This code uses 12 bit accumulators */
/*    since there are bits to spare.                                  */
/*                                                                    */
/*         The 11'th bit (starting at bit 0) of each accumulator      */
/*    is the sign bit. This may be tested to determine if there is    */
/*    a negative result. Accumulator overflows are discarded as is    */
/*    normal for two's complement arithmetic. Each R, G, or B result  */
/*    that is over 255 is set to 255. Each R, G, or B result that is  */
/*    less than zero is set to zero.                                  */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*                                                                    */
/*    bSign     Contains a 32 bit boolean that if non-zero, changes   */
/*              the interpretation of the chrominance (U and V) data  */
/*              from an offset binary format, where the values range  */
/*              from 0 to 255 with 128 representing 0 chrominance,    */
/*              to a signed two's complement format, where the values */
/*              range from -128 to 127.                               */
/*                                                                    */
/*                                                                    */
/*    bBGR      Contains a 32 bit boolean that if non-zero, changes   */
/*              the order of the conversion from RGB to BGR.          */
/*                                                                    */
/*                                                                    */
/*    pTable    The address of the RGB (or BGR) conversion table      */
/*              that is filled in by this function. The table         */
/*              address must be quadword aligned. The table size      */
/*              is 6244 bytes 3 * 256 quadwords.                      */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function has no return value.                              */
/*                                                                    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

/*
 * Define NEW_YCBCR to use new YCbCr conversion values.
 */
#define NEW_YCBCR

#define GetRGB555(in16, r, g, b) b = (in16>>7)&0xF8; \
                                 g = (in16>>2)&0xF8; \
                                 r = (in16<<3)&0xF8

#define AddRGB555(in16, r, g, b) b += (in16>>7)&0xF8; \
                                 g += (in16>>2)&0xF8; \
                                 r += (in16<<3)&0xF8

#define PutRGB565(r, g, b, out16) out16 = ((r&0xf8)<<8)|((g&0xfC)<<3)|((b&0xf8)>>3)

#define PutRGB555(r, g, b, out16) out16 = ((r&0xf8)<<7)|((g&0xf8)<<2)|((b&0xf8)>>3)

#ifdef NEW_YCBCR
/*
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
*/
#define YC 16.000
#define UC 16.055
#define VC 16.055
#define YR  0.257
#define UR  0.148
#define VR  0.439
#define YG  0.504
#define UG  0.291
#define VG  0.368
#define YB  0.098
#define UB  0.439
#define VB  0.071

#else /* !NEW_YCBCR */
/*
**    ( y =  0.0      0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
*/
#define YC 0.0
#define UC 0.245
#define VC 0.4235
#define YR 0.299
#define UR 0.169
#define VR 0.500
#define YG 0.587
#define UG 0.332
#define VG 0.419
#define YB 0.1140
#define UB 0.5000
#define VB 0.0813

#endif /* !NEW_YCBCR */

/********************************** YUV to RGB ***********************************/
/*
 * The YUV to RGB conversion routines
 * generates RGB values in a 64-bit
 * word thus:
 *
 *	63   56	55   48	47   40 39   32	31   24	23   16	15    8	7     0
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |     0 |  Blue |     0 | Green |     0 |   Red |     0 |  Blue |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * Figure out how many steps to the right are needed to
 * shift the red, green and blue into the correct position.
 */
#define ArrangRGB565(inrgb, outrgb) \
	  outrgb=((inrgb>>8)&0xf800)|((inrgb>>29)&0x07e0)|((inrgb>>51)&0x001f)
#define ArrangRGB888(inrgb, outrgb) \
	  outrgb=(inrgb&0xFF0000)|((inrgb>>24)&0x00FF00)|(inrgb&0x0000FF)


SconStatus_t sconInitYUVtoRGB(SconInfo_t *Info)
{
  qword i, qY, qUV, qSigned;
  SconBoolean_t bBGR=Info->Output.vinfo.Rmask&1; /* BGR vs RGB ordering */
  SconBoolean_t bSign=FALSE; /* U and V are signed values */
  unsigned qword qRed;
  unsigned qword qGreen;
  unsigned qword qBlue;
  unsigned qword qTemp;
  unsigned qword qAccMask = 0xFFF;
  unsigned qword *pTable, *pU_Table, *pV_Table;
  double Chrominance;
#ifdef NEW_YCBCR
  double CF_UB = 2.018;
  double CF_UG = -0.391;
  double CF_VG = -0.813;
  double CF_VR = 1.596;
#else /* !NEW_YCBCR */
  double CF_UB = 1.7790;
  double CF_UG = -0.3455;
  double CF_VG = -0.7169;
  double CF_VR = 1.4075;
#endif /* !NEW_YCBCR */

  /* allocate memory to hold the lookup table */
  if (Info->Table && Info->TableSize<256*3*8)
  {
    ScPaFree(Info->Table);
    Info->Table=NULL;
  }
  if (Info->Table==NULL)
  {
    if ((Info->Table = ScPaMalloc(256*3*8)) == NULL)
      return(SconErrorMemory);
    Info->TableSize=256*3*8;
  }
  /*
   *  Set constant that determines if the U and V chrominance values
   *  are interpreted as signed or unsigned values.
   */
  if ( !bSign )
    qSigned = 0;
  else
    qSigned = 0xFFFFFFFFFFFFFF80;

  /* Get the U, and V table pointers. */
  pTable = (unsigned qword *)Info->Table;
  pU_Table = pTable + 256;
  pV_Table = pU_Table + 256;

  /* Initialize the Y_Table, the U_Table, and the V_Table. */
  for ( i = 0; i < 256; i++ )
  {
    /******************************************************************/
    /*  Construct the Y array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |          Y|          Y|          Y|          Y|     Y = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/

#ifdef NEW_YCBCR
    qY = (qword) ((i-16)*1.164) ;
    qY = (qY < 0) ? 0 : (qY > 255) ? 255 : qY ;
#else /* !NEW_YCBCR */
    qY = i ;
#endif /* !NEW_YCBCR */
    qY |= qY << 16 ;
    *pTable++ = qY | ( qY << 32 ) ;
    /******************************************************************/
    /*  Construct the U array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |         ub|         ug|          0|         ub|     U = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/

#ifdef NEW_YCBCR
    qUV = (i< 16) ? 16
        : (i<240) ?  i
        : 240 ;
#else /* !NEW_YCBCR */
    qUV = i ;
#endif /* !NEW_YCBCR */
         
    Chrominance = (double) (( qUV - 128 ) ^ qSigned );

    qBlue = ((qword)( CF_UB * Chrominance )) & qAccMask;
    qGreen = ((qword)( CF_UG * Chrominance )) & qAccMask;
    qRed = 0;
    if ( bBGR )
    {
      qTemp = qBlue;
      qBlue = qRed;
      qRed = qTemp;
    }
    *pU_Table++ = qBlue | ( qRed << 16 ) | ( qGreen << 32 ) | ( qBlue << 48 );
    /******************************************************************/
    /*  Construct the V array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |          0|         vg|         vr|          0|     V = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/
    qBlue = 0;
    qGreen = ((qword)( CF_VG * Chrominance )) & qAccMask;
    qRed = ((qword)( CF_VR * Chrominance )) & qAccMask;
    if ( bBGR )
    {
      qTemp = qBlue;
      qBlue = qRed;
      qRed = qTemp;
    }
    *pV_Table++ = qBlue | ( qRed << 16 ) | ( qGreen << 32 );
  }
  return(SconErrorNone);
}

SconStatus_t scon422ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword y4, y5, y6, y7 ;
  unsigned qword u01, v01, u23, v23 ;
  unsigned qword  *yData=(unsigned qword *)inimage;
  unsigned int *uData=(unsigned int *)(inimage+width*height);
  unsigned int *vData=(unsigned int *)(inimage+(width*height*3)/2);
  unsigned qword *rgbData=(unsigned qword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  for (line=height; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned qword *)outimage;
    for (x=width>>3; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;	y >>= 8 ;
      y4  = y & 255 ;	y >>= 8 ;
      y5  = y & 255 ;	y >>= 8 ;
      y6  = y & 255 ;	y >>= 8 ;
      y7  = y & 255 ;	y >>= 8 ;

      u   = *uData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ; u >>= 8 ;

      v   = *vData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ; v >>= 8 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;
      y4  = pTable[y4] ;
      y5  = pTable[y5] ;
      y6  = pTable[y6] ;
      y7  = pTable[y7] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /*
       * Same thing for more pixels.
       * Use u01 for u45 and u23 for u67
       */
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Convert to RGB. */
      y4 += u01 + v01 ;
      y5 += u01 + v01 ;
      y6 += u23 + v23 ;
      y7 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3 | y4 | y5 | y6 | y7) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        y = y4 & mask ; y4 &= ~(y - (y>>11)) ;
        y = y5 & mask ; y5 &= ~(y - (y>>11)) ;
        y = y6 & mask ; y6 &= ~(y - (y>>11)) ;
        y = y7 & mask ; y7 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        y = y4 & mask ; y4 |= (y - (y >> 8)) ;
        y = y5 & mask ; y5 |= (y - (y >> 8)) ;
        y = y6 & mask ; y6 |= (y - (y >> 8)) ;
        y = y7 & mask ; y7 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB565(y0, y0);
      ArrangRGB565(y1, y1);
      ArrangRGB565(y2, y2);
      ArrangRGB565(y3, y3);
      ArrangRGB565(y4, y4);
      ArrangRGB565(y5, y5);
      ArrangRGB565(y6, y6);
      ArrangRGB565(y7, y7);
      *rgbData++ = y0 | (y1 << 16) | (y2 << 32) | (y3 << 48) ;
      *rgbData++ = y4 | (y5 << 16) | (y6 << 32) | (y7 << 48) ;
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon422ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword u01, v01, u23, v23 ;
  unsigned dword *yData=(unsigned dword *)inimage;
  unsigned word *uData=(unsigned word *)(inimage+width*height);
  unsigned word *vData=(unsigned word *)(inimage+(width*height*3)/2);
  unsigned dword *rgbData=(unsigned dword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  for (line=height; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned dword *)outimage;
    for (x=width>>2; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;

      u   = *uData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v   = *vData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB888(y0, y0);
      ArrangRGB888(y1, y1);
      ArrangRGB888(y2, y2);
      ArrangRGB888(y3, y3);
      *rgbData++ = (unsigned dword)(y0 | (y1 << 24));
      *rgbData++ = (unsigned dword)((y1 & 0xFFFF) | (y2 << 16));
      *rgbData++ = (unsigned dword)((y2 & 0xFF) | (y3 << 8));
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon420ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword y4, y5, y6, y7 ;
  unsigned qword u01, v01, u23, v23;
  unsigned qword  *yData=(unsigned qword *)inimage;
  unsigned int *uData=(unsigned int *)(inimage+width*height);
  unsigned int *vData=(unsigned int *)(inimage+(width*height*5)/4);
  unsigned int *puData, *pvData;
  unsigned qword *rgbData=(unsigned qword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  puData=uData;
  pvData=vData;
  for (line=(height>>1)<<1; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned qword *)outimage;
    if (line&1) /* odd line, reuse U and V */
    {
      puData=uData;
      pvData=vData;
    }
    else
    {
      uData=puData;
      vData=pvData;
    }
    for (x=width>>3; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;	y >>= 8 ;
      y4  = y & 255 ;	y >>= 8 ;
      y5  = y & 255 ;	y >>= 8 ;
      y6  = y & 255 ;	y >>= 8 ;
      y7  = y & 255 ;	y >>= 8 ;

      u   = *puData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ; u >>= 8 ;

      v   = *pvData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ; v >>= 8 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;
      y4  = pTable[y4] ;
      y5  = pTable[y5] ;
      y6  = pTable[y6] ;
      y7  = pTable[y7] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;

      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /*
       * Same thing for more pixels.
       * Use u01 for u45 and u23 for u67
       */
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Convert to RGB. */
      y4 += u01 + v01 ;
      y5 += u01 + v01 ;
      y6 += u23 + v23 ;
      y7 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3 | y4 | y5 | y6 | y7) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        y = y4 & mask ; y4 &= ~(y - (y>>11)) ;
        y = y5 & mask ; y5 &= ~(y - (y>>11)) ;
        y = y6 & mask ; y6 &= ~(y - (y>>11)) ;
        y = y7 & mask ; y7 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        y = y4 & mask ; y4 |= (y - (y >> 8)) ;
        y = y5 & mask ; y5 |= (y - (y >> 8)) ;
        y = y6 & mask ; y6 |= (y - (y >> 8)) ;
        y = y7 & mask ; y7 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB565(y0, y0);
      ArrangRGB565(y1, y1);
      ArrangRGB565(y2, y2);
      ArrangRGB565(y3, y3);
      ArrangRGB565(y4, y4);
      ArrangRGB565(y5, y5);
      ArrangRGB565(y6, y6);
      ArrangRGB565(y7, y7);
      *rgbData++ = y0 | (y1 << 16) | (y2 << 32) | (y3 << 48) ;
      *rgbData++ = y4 | (y5 << 16) | (y6 << 32) | (y7 << 48) ;
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon420ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword u01, v01, u23, v23;
  unsigned dword *yData=(unsigned dword *)inimage;
  unsigned word *uData=(unsigned word *)(inimage+width*height);
  unsigned word *vData=(unsigned word *)(inimage+(width*height*5)/4);
  unsigned word *puData, *pvData;
  unsigned dword *rgbData=(unsigned dword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  puData=uData;
  pvData=vData;
  for (line=(height>>1)<<1; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned dword *)outimage;
    if (line&1) /* odd line, reuse U and V */
    {
      puData=uData;
      pvData=vData;
    }
    else
    {
      uData=puData;
      vData=pvData;
    }
    for (x=width>>2; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;

      u   = *puData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v   = *pvData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;

      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB888(y0, y0);
      ArrangRGB888(y1, y1);
      ArrangRGB888(y2, y2);
      ArrangRGB888(y3, y3);
      *rgbData++ = (unsigned dword)(y0 | (y1 << 24));
      *rgbData++ = (unsigned dword)((y1 >> 8) | (y2 << 16));
      *rgbData++ = (unsigned dword)((y2 >> 16) | (y3 << 8));
    }
  }
  return(SconErrorNone);
}

/********************************** YUV to RGB ***********************************/
SconStatus_t sconInitRGBtoYUV(SconInfo_t *Info)
{
  unsigned dword i, y, u, v ;
  qword *RedToYuyv, *GreenToYuyv, *BlueToYuyv;

  /* allocate memory to hold the lookup table */
  if (Info->Table && Info->TableSize<256*3*8)
  {
    ScPaFree(Info->Table);
    Info->Table=NULL;
  }
  if (Info->Table==NULL)
  {
    if ((Info->Table = ScPaMalloc(256*3*8)) == NULL)
      return(SconErrorMemory);
    Info->TableSize=256*3*8;
  }
  RedToYuyv=(unsigned qword *)Info->Table;
  GreenToYuyv=RedToYuyv+256;
  BlueToYuyv=RedToYuyv+512;

  for( i=0 ; i<256 ; i++ )
  {
    /*
     * Calculate contribution from red.
     * We will also add in the constant here.
     * Pack it into the tables thus: lsb->YUYV<-msb
     */
    y = (unsigned dword) ((float)YC + (float)YR * (float)i) ;
    u = (unsigned dword) ((float)UC + (float)UR * (float)(255-i)) ;
    v = (unsigned dword) ((float)VC + (float)VR * (float)i) ;
    RedToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
    /*
     * Calculate contribution from green.
     */
    y = (unsigned dword) ((float)YG * (float)i) ;
    u = (unsigned dword) ((float)UG * (float)(255-i)) ;
    v = (unsigned dword) ((float)VG * (float)(255-i)) ;
    GreenToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
    /*
     * Calculate contribution from blue.
     */
    y = (unsigned dword) ((float)YB * (float)i) ;
    u = (unsigned dword) ((float)UB * (float)i) ;
    v = (unsigned dword) ((float)VB * (float)(255-i)) ;
    BlueToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
  }
  return(SconErrorNone);
}

/*
** Name:    sconRGB888To420
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:1:1 format)
*/
SconStatus_t sconRGB888To420(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned char *yData=(unsigned char *)outimage;
  unsigned char *uData=(unsigned char *)(outimage+width*height);
  unsigned char *vData=(unsigned char *)(outimage+(width*height*5)/4);
  register unsigned dword row, col;
  unsigned dword yuyv, r, g, b;
  unsigned char *tmp, *evl, *odl;
  if (stride<0)
    inimage=inimage+(-stride*(height-1));
  for (row=height; row>0; row--)
  {
    if (row&1)
    {
      tmp=inimage;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
        *yData++ = (yuyv&0xff);
      }
      inimage+=stride;
    }
    else
    {
      tmp = evl = inimage;
      inimage+=stride;
      odl = inimage;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
        *yData++ = (yuyv&0xff);
        /* We only store every fourth value of u and v components */
        if (col & 1)
        {
          /* Compute average r, g and b values */
          r = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          g = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          b = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          r += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          g += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          b += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;
          yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
          *uData++ = (yuyv>>24)& 0xff;       // V
          *vData++ = (yuyv>>8) & 0xff;       // U
        }
      }
    }
  }
  return(SconErrorNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sv_h263.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1996                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/****************************************************************************
 *
 *  sv_h263.h
 *  Wei-Lien Hsu
 *  Date: December 11, 1996
 *
 ****************************************************************************/


#ifndef _SV_H263_
#define _SV_H263_

#include "SC.h"
#include "h263.h"

/* Scaled IDCT precision */
#define H263_SCALED_IDCT_BITS   20
#define H263_SCALED_IDCT_MULT   (1<<H263_SCALED_IDCT_BITS)

/* Some macros */
#define sign(a)  	((a) < 0 ? -1 : 1)
#define mnint(a)	((a) < 0 ? (int)(a - 0.5) : (int)(a + 0.5))
#define mshort(a)	((a) < 0.0 ? (short)(a - 0.5) : (short)(a + 0.5))  
#define mmax(a, b)  	((a) > (b) ? (a) : (b))
#define mmin(a, b)  	((a) < (b) ? (a) : (b))

#ifndef INT_MAX
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#endif

#ifdef WIN32
#ifndef floorf
#define floorf floor
#endif
#endif

#define H263_mfloor(a)      ((a) < 0 ? (int)(a - 0.5) : (int)(a))
#define H263_limit(x) \
{ \
    if (x > 255) x = 255; \
    if (x <   0)   x = 0; \
}

#define H263_S_CODE

#define H263_NO_VEC                          999

#define H263_DEF_OUTPUTNAME  "DECOUT"

#define H263_T_YUV      0
#define H263_T_SIF      1
#define H263_T_TGA      2
#define H263_T_PPM      3
#define H263_T_X11      4
#define H263_T_YUV_CONC 5
#define H263_T_WIN      6

/* MBC = DEF_PELS/MB_SIZE, MBR = DEF_LINES/MB_SIZE$*/
/* this is necessary for the max resolution 16CIF */
#define H263_MBC                             88
#define H263_MBR                             72

#define H263_YES       1
#define H263_NO        0
#define H263_ON        1
#define H263_OFF       0


/************************** H263 Decoder ********************************/

/*
** Structures used to pass around the H263 decompression information.
** Part of SvCodecInfo_t structure.
*/
typedef struct SvH263DecompressInfo_s {
  ScBoolean_t inited;  /* was this info initialized yet */
  int quality;
  /* output */
  char *outputname;
  int outtype;
  /* printf's */
  int quiet;
  int trace;
  char errortext[256];
  unsigned int frame_rate;
  unsigned int bit_rate; /* encode bitrate */
  unsigned char *refframe[3], *oldrefframe[3];
  unsigned char *bframe[3], *newframe[3];
  unsigned char *edgeframe[3], *edgeframeorig[3]; 
  unsigned char *exnewframe[3];
  int MV[2][5][H263_MBR+1][H263_MBC+2];
  int modemap[H263_MBR+1][H263_MBC+2];
  unsigned char *clp;
  int horizontal_size, vertical_size;
  int mb_width, mb_height;
  int coded_picture_width, coded_picture_height;
  int chrom_width, chrom_height, blk_cnt;
  int pict_type, newgob;
  int mv_outside_frame, syntax_arith_coding;
  int adv_pred_mode, pb_frame;
  int long_vectors;
  int fault, expand;
  int verbose;
  int refidct;
  int matrix_coefficients;
  int temp_ref, quant, source_format;
  int framenum;

  int trd, trb, bscan, bquant;
#if 0
  /* bit input */
  int infile;
  unsigned char rdbfr[2051];
  unsigned char *rdptr;
  unsigned qword inbfr;
  unsigned qword position;
  int incnt;
  int bitcnt;
#endif
  /* block data [12] */
  int (*block)[66];
  void *dbg;  /* debug handle */
} SvH263DecompressInfo_t;


/************************************* H263 Encoder *************************************/

/* If you are not using the included Makefile, or want to override
   the Makefile, you can uncomment one or more of the defines 
   below instead */
/* #define PRINTMV */
/* to print MVs to stdout while coding. */
/* #define PRINTQ */
/* to print the quantizer used during coding */
/* #define FASTIDCT */
/* for a fast single precision IDCT. */
/* #define OFFLINE_RATE_CONTROL */
/* for the rate control optimized for offline encoding. */
/* #define QCIF */
/* to change the coding format uncommment the above line and change to
   SQCIF, QCIF, CIF, CIF4, or CIF16 */

/* From config.h */

/* for FAST search */
#define H263_SRCH_RANGE 24

/*************************************************************************/

/* Default modes */
/* see http://www.nta.no/brukere/DVC/h263_options.html */

/* Added by Nuno on 06/27/96 to support prefiltering */
/* use prefiltering as default */
#define H263_DEF_PREFILT_MODE H263_NO
/*************************************************************************/

/* Search windows */

/* default integer pel search seek distance ( also option "-s <n> " ) */
#define H263_DEF_SEEK_DIST        15   

/* default integer search window for 8x8 search centered 
   around 16x16 vector. When it is zero only half pel estimation
   around the integer 16x16 vector will be performed */
/* for best performance, keep this small, preferably zero,
   but do your own simulations if you want to try something else */
#define H263_DEF_8X8_WIN          0

/* default search window for PB delta vectors */
/* keep this small also */
#define H263_DEF_PBDELTA_WIN      2

/*************************************************************************/

/* Miscellaneous */

/* write repeated reconstructed frames to disk (useful for variable
 * framerate, since sequence will be saved at 25 Hz) 
 * Can be changed at run-time with option "-m" */
#define H263_DEF_WRITE_REPEATED   H263_NO

/* write bitstream trace to files trace.intra / trace 
 * (also option "-t") */
#define H263_DEF_WRITE_TRACE      H263_NO

/* start rate control after DEF_START_RATE_CONTROL % of sequence
 * has been encoded. Can be changed at run-time with option "-R <n>" */
#define H263_DEF_START_RATE_CONTROL   0

/* headerlength on concatenated 4:1:1 YUV input file 
 * Can be changed at run-time with option -e <headerlength> */
#define H263_DEF_HEADERLENGTH     0

/* insert sync after each DEF_INSERT_SYNC for increased error robustness
 * 0 means do not insert extra syncs */
#define H263_DEF_INSERT_SYNC      0

/*************************************************************************/

/* ME methods */
#define H263_FULL_SEARCH         0
#define H263_TWO_LEVELS_7_1      1
#define H263_TWO_LEVELS_421_1    2
#define H263_TWO_LEVELS_7_polint 3
#define H263_TWO_LEVELS_7_pihp   4

#define H263_FINDHALFPEL         0
#define H263_POLINT              1
#define H263_IDLE                2

#define H263_DCT8BY8             0
#define H263_DCT16COEFF          1
#define H263_DCT4BY4             2

/* prefiltering */
#define H263_GAUSS 1
#define H263_MORPH 2

/* morph.c */

#define H263_DEF_HPME_METHOD  H263_FINDHALFPEL
#define H263_DEF_DCT_METHOD   H263_DCT8BY8
#define H263_DEF_VSNR         0  /* FALSE */

#define H263_DEF_SOURCE_FORMAT   H263_SF_QCIF

/* Added by Nuno to support prefiltering */
#define H263_DEF_PYR_DEPTH 3
#define H263_DEF_PREF_PYR_TYPE H263_GAUSS
#define H263_MAX_PYR_DEPTH 5
#define H263_DEF_STAT_PREF_STATE H263_NO

/* This should not be changed */
#define H263_MB_SIZE              16

/* Parameters from TMN */
#define H263_PREF_NULL_VEC        100
#define H263_PREF_16_VEC          200
#define H263_PREF_PBDELTA_NULL_VEC 50


#define H263_MAX_CALC_QUALITY     0xFFFFFFFF
#define H263_MIN_CALC_QUALITY     0x00000000

/****************************/

/* Motionvector structure */

typedef struct H263_motionvector {
  short x;        /* Horizontal comp. of mv         */
  short y;        /* Vertical comp. of mv         */
  short x_half;        /* Horizontal half-pel acc.	 */
  short y_half;        /* Vertical half-pel acc.	 */
  short min_error;        /* Min error for this vector	 */
  short Mode;                     /* Necessary for adv. pred. mode */
} H263_MotionVector;

/* Point structure */

typedef struct H263_point {
  short x;
  short y;
} H263_Point;

/* Structure with image data */

typedef struct H263_pict_image {
  unsigned char *lum;        /* Luminance plane        */
  unsigned char *Cr;        /* Cr plane        */
  unsigned char *Cb;        /* Cb plane        */
} H263_PictImage;

/* Added by Nuno on 06/24/96 to support filtering of the prediction error */
typedef struct pred_image {
  short *lum;		/* Luminance plane		*/
  short *Cr;		/* Cr plane			*/
  short *Cb;		/* Cb plane			*/
} PredImage;

/* Group of pictures structure. */

/* Picture structure */
typedef struct H263_pict {
  int prev; 
  int curr;
  int TR;             /* Time reference */
  int bit_rate;
  int src_frame_rate;
  float target_frame_rate;
  int source_format;
  int picture_coding_type;
  int spare;
  int unrestricted_mv_mode;
  int PB;
  int QUANT;
  int DQUANT;
  int MB;
  int seek_dist;        /* Motion vector search window */
  int use_gobsync;      /* flag for gob_sync */
  int MODB;             /* B-frame mode */
  int BQUANT;           /* which quantizer to use for B-MBs in PB-frame */
  int TRB;              /* Time reference for B-picture */
  float QP_mean;        /* mean quantizer */
} H263_Pict;

/* Slice structure */
/*
typedef struct H263_slice {
  unsigned int vert_pos;	
  unsigned int quant_scale;	
} H263_Slice;
*/
/* Macroblock structure */
/*
typedef struct H263_macroblock {
  int mb_address;        
  int macroblock_type;       
  int skipped;        
  H263_MotionVector motion;	       
} H263_Macroblock;
*/

/* Structure for macroblock data */
typedef struct mb_structure {
  short lum[16][16];
  short Cr[8][8];
  short Cb[8][8];
} H263_MB_Structure;

/* Added by Nuno on 06/24/96 to support filtering of the prediction error */
typedef struct working_buffer {
  short         *qcoeff_P;              /* P frame coefficient */   
  unsigned char *ipol_image;            /* interpolated image */ 
} H263_WORKING_BUFFER;

/* Structure for counted bits */

typedef struct H263_bits_counted {
  int Y;
  int C;
  int vec;
  int CBPY;
  int CBPCM;
  int MODB;
  int CBPB;
  int COD;
  int header;
  int DQUANT;
  int total;
  int no_inter;
  int no_inter4v;
  int no_intra;
/* NB: Remember to change AddBits(), ZeroBits() and AddBitsPicture() 
   when entries are added here */
} H263_Bits;

/* Structure for data for data from previous macroblock */

/* Structure for average results and virtal buffer data */

typedef struct H263_results {
  float SNR_l;        /* SNR for luminance */
  float SNR_Cr;        /* SNR for chrominance */
  float SNR_Cb;
  float QP_mean;                /* Mean quantizer */
} H263_Results;

/**************** RTP *****************/
#define RTP_H263_INTRA_CODED 0x00000001
#define RTP_H263_PB_FRAME    0x00000002
#define RTP_H263_AP          0x00000004
#define RTP_H263_SAC         0x00000008

#define H263_RTP_MODE_A      PARAM_FORMATEXT_RTPA
#define H263_RTP_MODE_B      PARAM_FORMATEXT_RTPB
#define H263_RTP_MODE_C      PARAM_FORMATEXT_RTPC

#define H263_RTP_DEFAULT_MODE  RTP_H263_MODE_A 
#define H263_RTP_MAX_PACKETS   64*2

typedef struct SvH263BSInfo_s {
	unsigned dword	dwFlag;
	unsigned dword	dwBitOffset;
	unsigned char	Mode;
	unsigned char	MBA;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV1;
	char			VMV1;
	char			HMV2;
	char			VMV2;
} SvH263BSInfo_t;

typedef struct SvH263BSTrailer_s {
	unsigned dword	dwVersion;
	unsigned dword	dwFlags;
	unsigned dword	dwUniqueCode;
	unsigned dword  dwCompressedSize;
	unsigned dword  dwNumberOfPackets;
	unsigned char	SourceFormat;
	unsigned char	TR;
	unsigned char   TRB;
	unsigned char   DBQ;
} SvH263BSTrailer_t;

typedef struct SvH263RTPInfo_s {
    SvH263BSTrailer_t trailer;
    SvH263BSInfo_t    bsinfo[H263_RTP_MAX_PACKETS];
    dword             packet_id;
    ScBSPosition_t    pic_start_position, packet_start_position;
	ScBSPosition_t    pre_GOB_position, pre_MB_position;
} SvH263RTPInfo_t;

/*
** Structures used to pass around the H263 compression information.
** Part of SvCodecInfo_t structure.
*/
typedef struct SvH263CompressInfo_s {
  ScBoolean_t inited;  /* was this info initialized yet */
  /* options */
  int quality;
  unsigned dword calc_quality;  /* calculated quality */
  int advanced;
  int syntax_arith_coding;
  int pb_frames;
  int unrestricted;
  int extbitstream;  /* extended bitstream (rtp) */
  int packetsize;    /* packet size (rtp) */
  /* for FAST search */
  unsigned char *block_subs2, *srch_area_subs2;
  /* Global variables */ 
  int headerlength;
  int source_format;
  int mb_width;
  int mb_height;
  int pels;
  int cpels;
  int lines;
  int trace;
  int mv_outside_frame;
  int long_vectors;
  float target_framerate;
  int prefilter; /* Added by Nuno on 06/24/96 to support prefiltering */

  H263_PictImage *prev_image;
  H263_PictImage *curr_image;
  H263_PictImage *curr_recon;
  H263_PictImage *prev_recon;

  /* To support filtering of the prediction error */
  H263_PictImage **curr_filtd;
  H263_PictImage *curr_clean;
  H263_PictImage *curr_selects;
  H263_PictImage *B_selects;

  /* PB-frame specific */
  H263_PictImage *B_recon;
  H263_PictImage *B_image;
  H263_PictImage **B_filtd;
  H263_PictImage *B_clean;

  H263_Pict *pic;
  H263_WORKING_BUFFER *wk_buffers;
  /* for Motion Estimation */
  H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2];
  unsigned char PREF_LEVEL[4][3], MOTresh[4];
  int PYR_DEPTH, PrefPyrType, H263_StaticPref, PETresh[3];

  H263_Bits *bits ;
  H263_Bits *total_bits;
  H263_Bits *intra_bits ;
  H263_Results *res; 
  H263_Results *total_res; 
  H263_Results *b_res ;
  /* bitrate control */
  int buffer_fullness;
  int buffer_frames_stored;
  int first_loop_finished, start_rate_control;
  unsigned char **PreFilterLevel;
  int bit_rate;
  int total_frames_passed, PPFlag;
  int first_frameskip, next_frameskip, chosen_frameskip;
  float orig_frameskip;
  int frames,bframes,pframes,pdist,bdist;
  int distance_to_next_frame;
  int QP, QP_init, QPI;
  float ref_frame_rate, orig_frame_rate;
  float frame_rate, seconds;
  int ME_method;
  int HPME_method;
  int refidct;
  int DCT_method;
  int vsnr;
  int start, end;
  int frame_no;

  SvH263RTPInfo_t *RTPInfo;
  int VARgob[16];

  char *seqfilename; 
  char *streamname; 
  void *dbg;  /* debug handle */
} SvH263CompressInfo_t;


#endif _SV_H263_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sv_proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_prototypes.h,v $
 * Revision 1.1.9.6  1996/10/28  17:32:26  Hans_Graves
 * 	Changed sv_MpegGet/SetParamInt() to use qwords.
 * 	[1996/10/28  17:07:11  Hans_Graves]
 *
 * Revision 1.1.9.5  1996/10/02  18:42:52  Hans_Graves
 * 	Added InputFourCC to sv_MpegEncodeFrameInOrder().
 * 	[1996/10/02  18:34:36  Hans_Graves]
 * 
 * Revision 1.1.9.4  1996/07/19  02:11:09  Hans_Graves
 * 	Change 422i motion recon function protos.
 * 	[1996/07/19  01:27:59  Hans_Graves]
 * 
 * Revision 1.1.9.3  1996/05/24  22:21:42  Hans_Graves
 * 	Added MPEG 422i protos
 * 	[1996/05/24  21:55:51  Hans_Graves]
 * 
 * Revision 1.1.9.2  1996/05/07  19:56:10  Hans_Graves
 * 	Added HUFF_SUPPORT
 * 	[1996/05/07  17:24:56  Hans_Graves]
 * 
 * Revision 1.1.7.7  1996/04/10  21:47:39  Hans_Graves
 * 	Added Set/GetParamBoolean()
 * 	[1996/04/10  20:39:51  Hans_Graves]
 * 
 * Revision 1.1.7.6  1996/04/09  20:50:35  Karen_Dintino
 * 	Adding WIN32 support
 * 	[1996/04/09  20:47:45  Karen_Dintino]
 * 
 * Revision 1.1.7.5  1996/04/09  16:04:40  Hans_Graves
 * 	Fix protos for sv_MpegIDCTToFrame/AddToFrame()
 * 	[1996/04/09  16:03:24  Hans_Graves]
 * 
 * Revision 1.1.7.4  1996/04/04  23:35:05  Hans_Graves
 * 	Added protos for sv_MpegReconFieldBlock() and sv_MpegReconFrameBlock()
 * 	[1996/04/04  22:59:42  Hans_Graves]
 * 
 * Revision 1.1.7.3  1996/03/29  22:21:21  Hans_Graves
 * 	Added JPEG_SUPPORT ifdefs.
 * 	[1996/03/29  22:14:58  Hans_Graves]
 * 
 * 	Added protos for SvMpegIDCTToFrameP_S() and SvMpegIDCTAddToFrameP_S()
 * 	[1996/03/27  21:54:00  Hans_Graves]
 * 
 * Revision 1.1.7.2  1996/03/08  18:46:37  Hans_Graves
 * 	Added protos for new MPEG assembly
 * 	[1996/03/08  16:25:05  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/02/06  22:54:03  Hans_Graves
 * 	Added MpegGet/SetParam() prototypes
 * 	[1996/02/06  22:50:20  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/01/24  19:33:21  Hans_Graves
 * 	Changed DCT block for shorts to ints
 * 	[1996/01/24  18:13:05  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/08  16:41:29  Hans_Graves
 * 	Updated MPEG I and II prototypes for new decoder
 * 	[1996/01/08  15:47:45  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:35  Hans_Graves
 * 	Removed prototype for error()
 * 	[1995/12/07  19:20:55  Hans_Graves]
 * 
 * 	Added MPEG encoder prototypes
 * 	[1995/12/07  18:00:18  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/09/22  12:58:43  Bjorn_Engberg
 * 	Use MPEG_SUPPORT and H261_SUPPORT.
 * 	[1995/09/22  12:50:18  Bjorn_Engberg]
 * 
 * Revision 1.1.2.15  1995/09/11  20:36:34  Paul_Gauthier
 * 	Add version string to JPEG header as APP1 segment
 * 	[1995/09/11  20:35:13  Paul_Gauthier]
 * 
 * Revision 1.1.2.14  1995/08/15  19:13:57  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.12 **}
 * 		{** Merge revision:	1.1.2.13 **}
 * 	{** End **}
 * 	fix reentrant problem
 * 	[1995/08/15  18:31:06  Karen_Dintino]
 * 
 * Revision 1.1.2.13  1995/08/14  19:40:28  Hans_Graves
 * 	Fixed H261 Init prototypes.
 * 	[1995/08/14  18:43:51  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/08/07  22:09:52  Hans_Graves
 * 	Added prototype for CrawlMotionEstimation()
 * 	[1995/08/07  22:09:31  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/08/04  16:32:28  Karen_Dintino
 * 	Change to SvStatus_t for some low level rtns
 * 	[1995/08/04  16:22:50  Karen_Dintino]
 * 
 * Revision 1.1.2.10  1995/08/03  18:02:07  Karen_Dintino
 * 	Encode/Decode routines need to return SvStatus_t
 * 	[1995/08/03  18:00:02  Karen_Dintino]
 * 
 * Revision 1.1.2.9  1995/08/02  15:27:00  Hans_Graves
 * 	Changed prototype for blockdiff16_C()
 * 	[1995/08/02  15:25:00  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/28  17:36:05  Hans_Graves
 * 	Added prototype for sv_CompressH261()
 * 	[1995/07/28  17:29:00  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/26  17:48:57  Hans_Graves
 * 	Added prototype for sv_DecompressH261()
 * 	[1995/07/26  17:47:19  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/17  16:12:17  Hans_Graves
 * 	Added H261 prototypes.
 * 	[1995/07/17  15:54:27  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  13:54:27  Hans_Graves
 * 	Removed prototype for sv_RdRunLevel().
 * 	[1995/06/27  13:52:12  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/20  14:13:39  Karen_Dintino
 * 	Separate H.261 prototypes
 * 	[1995/06/20  13:29:25  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/06/19  20:31:18  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:14:23  Karen_Dintino]
 * 
 * Revision 1.1.2.2  1995/05/31  18:10:24  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:51:00  Hans_Graves]
 * 
 * Revision 1.1.2.8  1994/12/14  19:09:54  Paul_Gauthier
 * 	Removed sv_gentoc.c from SLIB
 * 	[1994/12/14  19:07:29  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/12/12  15:39:31  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:35:04  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/11/09  21:33:12  Paul_Gauthier
 * 	Optimizations
 * 	[1994/11/09  15:31:22  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/13  20:34:53  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/12  21:08:55  Paul_Gauthier]
 * 
 * Revision 1.1.2.2  1994/10/07  14:58:16  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:57:07  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*--------------------------------------------------------------------------
 * SLIB Internals Prototype file (externals are in SV.h)
 *
 * Modification History: sv_prototypes.h
 *
 *      29-Jul-94  PSG  Created
 *---------------------------------------------------------------------------*/

#ifndef _SV_PROTOTYPES_H
#define _SV_PROTOTYPES_H

extern void DumpBlock(char *title, short *blk);

/*---------------------------------------------------------------------------*/
/*                     Compress/Decompress Codec Prototypes                  */
/*---------------------------------------------------------------------------*/

/*
** sv_codec_api.c
*/
static SvStatus_t sv_GetYUVComponentPointers(int, int, int, u_char *, int,
					     u_char **, u_char **, u_char **);
static SvStatus_t sv_JpegExtractBlocks (SvCodecInfo_t *, u_char *);

#ifdef JPEG_SUPPORT
/*
** sv_jpeg_decode.c
*/
static void sv_FillBitBuffer (int);
static SvStatus_t sv_ProcessRestart (SvCodecInfo_t *);
extern SvStatus_t sv_DecodeJpeg (SvCodecInfo_t *);
extern void sv_ReInitJpegDecoder (SvCodecInfo_t *);

/*
** sv_jpeg_encode.c
*/
extern void WriteJpegData(char *, int, u_char **);
extern void FlushBytes (u_char **);
static void EmitBits(u_short, int);
static void FlushBits (void);
extern void sv_EncodeOneBlock (SvRLE_t *, SvHt_t *, SvHt_t *);
extern void sv_HuffEncoderInit (SvCodecInfo_t *);
extern void EmitRestart (SvJpegCompressInfo_t *);
extern void sv_HuffEncoderTerm (u_char **);


/*
** sv_jpeg_format.c
*/
extern SvStatus_t sv_AddJpegHeader (SvHandle_t, u_char *, int, int *);
extern SvStatus_t sv_AddJpegTrailer (SvHandle_t, u_char *, int, int *);
extern SvStatus_t sv_FormatJpegData (SvHandle_t, char *, char *, int, int *);
static SvStatus_t sv_AddCompSpecs (int, int, int, int, char **, char *); 
static SvStatus_t sv_AddEntropyData (SvCodecInfo_t *, char *, char **, char *);
static SvStatus_t sv_AddFrame (SvCodecInfo_t *, char *, char **, char *);
static SvStatus_t sv_AddFrameHeader (SvCodecInfo_t *, char **, char *);
static SvStatus_t sv_AddMarker ();
static SvStatus_t sv_AddScanHeader (SvCodecInfo_t *, char **, char *);
static SvStatus_t sv_AddSLIBHeader (char **, char *);
static SvStatus_t sv_Write16bits (short, char **, char *);
static SvStatus_t sv_Write8bits (int, char **, char *);
static SvStatus_t sv_AddMMSVer (char **, char *);

/*
** sv_jpeg_init.c
*/
static SvStatus_t sv_InitEncoderStruct (SvCodecInfo_t *);
static SvStatus_t sv_InitDecoderStruct (SvCodecInfo_t *);
static SvStatus_t sv_InitHDecoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitJpegEncoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitJpegDecoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitInfo (SvCodecInfo_t *);
extern void sv_copyHTable (SvHt_t *, SvHt_t *);
extern SvStatus_t sv_CheckChroma (SvCodecInfo_t *);
static int JroundUp (int, int);
/*
** sv_jpeg_tables.c
*/
extern SvStatus_t sv_MakeQTables (int, SvCodecInfo_t *);
extern SvStatus_t sv_MakeHEncodingTables (SvCodecInfo_t *);
extern SvStatus_t sv_MakeHDecodingTables (SvCodecInfo_t *);
extern SvStatus_t sv_MakeEncoderBlkTable (SvCodecInfo_t *);
extern SvStatus_t sv_MakeDecoderBlkTable (SvCodecInfo_t *);
static void sv_MakeHCodeTables (SvHt_t *, char *, u_short *, u_int *);
extern SvStatus_t sv_ConvertQTable (SvCodecInfo_t *, SvQuantTables_t *);
extern SvStatus_t sv_LoadDefaultHTable (SvCodecInfo_t *);

/*
** sv_jpeg_parse.c
*/
static u_int sv_GetShort (SvCodecInfo_t *);
static int sv_GetNextMarker (void);
static void sv_ProcessBogusMarker (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDHT (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDQT (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDRI (SvCodecInfo_t *);
static SvStatus_t sv_ProcessAPP0 (SvCodecInfo_t *);
static SvStatus_t sv_ProcessSOF (SvCodecInfo_t *, int);
static SvStatus_t sv_ProcessSOS (SvCodecInfo_t *);
static SvStatus_t sv_ProcessSOI (SvCodecInfo_t *);
/*static int sv_ProcessTables (SvCodecInfo_t *);*/
static SvStatus_t sv_ParseFileHeader (SvCodecInfo_t *);
extern SvStatus_t sv_ParseScanHeader (SvCodecInfo_t *);
extern SvStatus_t sv_ParseFrame (u_char *, int, SvCodecInfo_t *);
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*---------------------------------------------------------------------------*/
/*                              MPEG Prototypes                              */
/*---------------------------------------------------------------------------*/
/*
** sv_mpeg_common.c
*/
extern SvStatus_t sv_MpegSetParamBoolean(SvHandle_t Svh, SvParameter_t param,
                                                  ScBoolean_t value);
extern SvStatus_t sv_MpegSetParamInt(SvHandle_t Svh, SvParameter_t param,
                                qword value);
extern SvStatus_t sv_MpegSetParamFloat(SvHandle_t Svh, SvParameter_t param,
                                float value);
extern ScBoolean_t sv_MpegGetParamBoolean(SvHandle_t Svh, SvParameter_t param);
extern qword sv_MpegGetParamInt(SvHandle_t Svh, SvParameter_t param);
extern float sv_MpegGetParamFloat(SvHandle_t Svh, SvParameter_t param);

/*
** sv_mpeg_parse.c
*/
extern SvStatus_t sv_MpegGetHeader(SvMpegDecompressInfo_t *MpegInfo,
                                   ScBitstream_t *bs);
extern int sv_MpegGetSliceHdr(SvMpegDecompressInfo_t *MpegInfo,
                              ScBitstream_t *bs,
                              SvMpegLayer_t *layer);
extern SvStatus_t sv_MpegGetImageInfo(int fd, SvImageInfo_t *iminfo);
extern SvStatus_t sv_MpegFindNextPicture(SvCodecInfo_t *Info,
                                         SvPictureInfo_t *PictureInfo);

/*
** sv_mpeg_decode.c
*/
extern SvStatus_t sv_MpegInitDecoder (SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegFreeDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegDecompressFrame(SvCodecInfo_t *, u_char *, u_char **);

/*
** sv_mpeg_block.c
*/
extern ScBoolean_t sv_MpegGetIntraBlock(
                          ScBitstream_t *bs, SvMpegLayer_t *layer, int comp,
                          int *dc_dct_pred);
extern ScBoolean_t sv_MpegGetInterBlock(SvMpegDecompressInfo_t *MpegInfo,
                          ScBitstream_t *bs, SvMpegLayer_t *layer, int comp);
extern ScBoolean_t sv_Mpeg2GetIntraBlock(SvMpegDecompressInfo_t *MpegInfo,
                           ScBitstream_t *bs, SvMpegLayer_t *layer, int comp,
                           int *dc_dct_pred);
extern ScBoolean_t sv_Mpeg2GetInterBlock(SvMpegDecompressInfo_t *MpegInfo,
                           ScBitstream_t *bs, SvMpegLayer_t *layer, int comp);

extern ScBoolean_t sv_MpegMotionVectors(ScBitstream_t *bs,
                            int PMV[2][2][2],
                            int dmvector[2], int mv_field_sel[2][2],
                            int s, int mv_count, int mv_format,
                            int h_r_size, int v_r_size, int dmv, int mvscale);
extern ScBoolean_t sv_MpegMotionVector(ScBitstream_t *bs,
                                int *PMV, int *dmvector,
                                int h_r_size, int v_r_size, 
                                int dmv, int mvscale, int full_pel_vector);
extern void sv_MpegCalcDMV(SvMpegDecompressInfo_t *MpegInfo,
                           int DMV[][2], int *dmvector, int mvx, int mvy);
extern int sv_MpegGetDClum_C(ScBitString_t bits, unsigned int *bitsleft);
extern int sv_MpegGetDCchrom_C(ScBitString_t bits, unsigned int *bitsleft);

/*
** sv_mpeg_block2.s
*/
extern void sv_MpegClearBlock_S(int *block);
extern int sv_MpegInterHuffToDCT_S(int *dctblk, unsigned int zzpos, 
                        ScBitString_t bits, unsigned int *pbitsleft,
                        int quant_scale, int *quant_matrix);
extern int sv_MpegIntraHuffToDCT_S(int *dctblk, unsigned int comp, 
                        ScBitString_t bits, unsigned int *pbitsleft,
                        int quant_scale, int *quant_matrix,
                        int *dc_dct_pred);
extern int sv_MpegGetDClum_S(ScBitString_t  bits, unsigned int  *bitsleft);
extern int sv_MpegGetDCchrom_S(ScBitString_t bits, unsigned int *bitsleft);


/*
** sv_mpeg_recon.c
*/
extern void sv_MpegReconstruct(SvMpegDecompressInfo_t *MpegInfo,
                       unsigned char **newframe, int bx, int by,
                       int mb_type, int motion_type, int PMV[2][2][2],
                       int mv_field_sel[2][2], int dmvector[2], int stwtype);
extern void sv_MpegReconFieldBlock(int chroma,
                  unsigned char *src[], int sfield,
                  unsigned char *dst[], int dfield, int lx, int lx2,
                  int w, int h, int x, int y, int dx, int dy, int addflag);
extern void sv_MpegReconFrameBlock(int chroma,
                  unsigned char *src[], unsigned char *dst[], int lx, int lx2,
                  int w, int h, int x, int y, int dx, int dy, int addflag);


/*
** sv_mpeg_getmb.c
*/
extern int sv_MpegGetMBtype(SvMpegDecompressInfo_t *MpegInfo,
                            ScBitstream_t *bs, SvMpegLayer_t *layer);
extern int sv_MpegGetIMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetPMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetBMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetDMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetSpIMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetSpPMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);
extern int sv_MpegGetSpBMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);
extern int sv_MpegGetSNRMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);

extern int sv_MpegGetCBP(ScBitstream_t *bs);

/*
** sv_mpeg_422recon.c
*/
void sv_CopyCBP_C(int *cpbdata, unsigned char *np, unsigned int w);
void sv_CopyCBPf_C(int *cpbdata, unsigned char *np, unsigned int w);
void sv_MpegFrameCopy411to422i(unsigned char *refframe,
                              unsigned char *newframe,
                              int x, int y, unsigned int w,
                              int dx, int dy, unsigned char *tmpbuf);
void sv_MpegFrameMC411to422i(int *block, unsigned int cbp,
                    unsigned char *refframe, unsigned char *newframe,
                    int x, int y, unsigned int w, int dx, int dy,
                    ScBoolean_t fdct, unsigned char *tmpbuf);
void sv_MpegDFrameMC411to422i(int *block, unsigned int cbp,
                    unsigned char *brefframe, unsigned char *frefframe,
                    unsigned char *newframe,
                    int x, int y, unsigned int w,
                    int bdx, int bdy, int fdx, int fdy, ScBoolean_t fdct,
                    unsigned char *tmpbuf);
void sv_MpegDFieldMC411to422i(int *block, unsigned int cbp,
                    unsigned char *refframe, int rfield0, int rfield1,
                    unsigned char *newframe, int x, int y, unsigned int w,
                    int dx0, int dy0, int dx1, int dy1, ScBoolean_t fdct,
                    unsigned char *tmpbuf);
void sv_MpegQFieldMC411to422i(int *blocks, unsigned int cbp,
                unsigned char *bframe, int bfield0, int bfield1,
                unsigned char *fframe, int ffield0, int ffield1,
                unsigned char *newframe, int x, int y, unsigned int w,
                int bdx0, int bdy0, int bdx1, int bdy1,
                int fdx0, int fdy0, int fdx1, int fdy1,
                ScBoolean_t fdct, unsigned char *tmpbuf);

/*
** sv_mpeg_422reconcbp.s
*/
void sv_CopyCBP_S(int *cpbdata, unsigned char *np, unsigned int w);
void sv_CopyCBPf_S(int *cpbdata, unsigned char *np, unsigned int w);

/*
** sv_mpeg_idct.c
*/
void sv_MpegIDCTToFrame_C(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrame_C(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTToFrame2_C(int *inbuf, unsigned char *rfp, int rinc,
                                       unsigned char *ffp, int finc, int comp);
void sv_MpegIDCTAddToFrame2_C(int *inbuf, unsigned char *rfp, int rinc,
                                       unsigned char *ffp, int finc, int comp);

/*
** sv_mpeg_idct2.s
*/
void sv_MpegIDCTToFrame_S(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrame_S(int *inbuf, unsigned char *rfp, int incr);

/*
** sv_mpeg_idct3.s
*/
void sv_MpegIDCTToFrameP_S(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrameP_S(int *inbuf, unsigned char *rfp, int incr);

/*
** sv_mpeg_init.c
*/
extern SvStatus_t sv_MpegInitEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegFreeEncoder(SvCodecInfo_t *Info);

/*
** sv_mpeg_encode.c
*/
extern SvStatus_t sv_MpegEncoderBegin(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegEncodeFrame(SvCodecInfo_t *Info, 
                                     unsigned char *InputImage);
extern SvStatus_t sv_MpegEncodeFrameInOrder(SvCodecInfo_t *Info,
                                     unsigned char *InputImage,
                                     unsigned int InputFourCC);
extern SvStatus_t sv_MpegEncoderEnd(SvCodecInfo_t *Info);

/*
** sv_mpeg_putpic.c
*/
extern void sv_MpegPutPict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *BS,
                           unsigned char *frame);

/*
** sv_mpeg_puthdr.c
*/
extern void sv_MpegPutSeqHdr(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern void sv_MpegPutSeqExt(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern void sv_MpegPutSeqDispExt(SvMpegCompressInfo_t *MpegInfo,
                                           ScBitstream_t *bs);
extern void sv_MpegPutUserData(ScBitstream_t *bs, char *userdata);
extern void sv_MpegPutGOPHdr(ScBitstream_t *bs, float frame_rate, int tco,
                       int frame, int closed_gop);
extern void sv_MpegPutSeqEnd(ScBitstream_t *bs);

/*
** sv_mpeg_motion.c
*/
extern void sv_MpegMotionEstimation(SvMpegCompressInfo_t *MpegInfo, 
                       unsigned char *oldorg, unsigned char *neworg,
                       unsigned char *oldref, unsigned char *newref,
                       unsigned char *cur, unsigned char *curref,
                       int sxf, int syf, int sxb, int syb,
                       struct mbinfo *mbi, int secondfield, int ipflag);

/*
** sv_mpeg_quantize.c
*/
int sv_MpegIntraQuant(short *src, short *dst, int dc_prec,
                unsigned char *quant_mat, int mquant, int mpeg1);
int sv_MpegNonIntraQuant(short *src, short *dst,
                    unsigned char *quant_mat, int mquant, int mpeg1);
void sv_MpegIntraInvQuant(short *src, short *dst, int dc_prec,
                  unsigned char *quant_mat, int mquant, int mpeg1);
void sv_MpegNonIntraInvQuant(short *src, short *dst,
                      unsigned char *quant_mat, int mquant, int mpeg1);

/*
** sv_mpeg_transfrm.c
*/
void sv_MpegTransform(SvMpegCompressInfo_t *MpegInfo,
               unsigned char *pred[], unsigned char *cur[],
               struct mbinfo *mbi, short blocks[][64]);
void sv_MpegInvTransform(SvMpegCompressInfo_t *MpegInfo,
                unsigned char *pred[], unsigned char *cur[],
                struct mbinfo *mbi,short blocks[][64]);
void sv_MpegDCTtypeEstimation(SvMpegCompressInfo_t *MpegInfo,
                         unsigned char *pred, unsigned char *cur,
                         struct mbinfo *mbi);

/*
** sv_mpeg_predict.c
*/
extern void sv_MpegPredict(SvMpegCompressInfo_t *MpegInfo,
             unsigned char *reff[], unsigned char *refb[],
             unsigned char *cur[3], int secondfield, struct mbinfo *mbi);

/*
** sv_mpeg_ratectl.c
*/
extern void rc_init_seq(SvMpegCompressInfo_t *MpegInfo);
extern void rc_init_GOP(SvMpegCompressInfo_t *MpegInfo, int np, int nb);
extern void rc_init_pict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs,
                         unsigned char *frame);
extern void rc_update_pict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern int rc_start_mb(SvMpegCompressInfo_t *MpegInfo);
extern int rc_calc_mquant(SvMpegCompressInfo_t *MpegInfo,  ScBitstream_t *bs,
                         int j);
void sv_MpegVBVendofpic(ScBitstream_t *bs);
void sv_MpegVBVcalcdelay(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);

#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
/*---------------------------------------------------------------------------*/
/*                             H.261 Prototypes                              */
/*---------------------------------------------------------------------------*/

/*
** sv_h261_init.c
*/
extern SvStatus_t svH261Init(SvCodecInfo_t *Info);
extern SvStatus_t svH261CompressInit(SvCodecInfo_t *Info);

extern SvStatus_t svH261SetParamInt(SvHandle_t Svh, SvParameter_t param, qword value);
extern qword      svH261GetParamInt(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH261SetParamFloat(SvHandle_t Svh, SvParameter_t param, float value);
extern float      svH261GetParamFloat(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH261SetParamBoolean(SvHandle_t Svh, SvParameter_t param, ScBoolean_t value);
extern ScBoolean_t svH261GetParamBoolean(SvHandle_t Svh, SvParameter_t param);

/*
** sv_h261_decompress.c
*/
extern SvStatus_t svH261Decompress(SvCodecInfo_t *Info,
                             u_char *MultiBuf, u_char **ImagePtr);
extern SvStatus_t svH261DecompressFree(SvHandle_t Svh);

/*
** sv_h261_compress.c
*/
extern SvStatus_t svH261Compress(SvCodecInfo_t *Info, u_char *InputImage);
extern SvStatus_t svH261CompressFree(SvHandle_t Svh);
extern SvStatus_t SvSetFrameSkip (SvHandle_t Svh, int FrameSkip);
extern SvStatus_t SvSetFrameCount (SvHandle_t Svh, int FrameCount);
extern SvStatus_t SvSetSearchLimit (SvHandle_t Svh, int SearchLimit);

extern SvStatus_t SvSetImageType (SvHandle_t Svh, int ImageType);
extern SvStatus_t SvGetFrameNumber (SvHandle_t Svh, u_int *FrameNumber);


#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
/*---------------------------------------------------------------------------*/
/*                              H263 Prototypes                              */
/*---------------------------------------------------------------------------*/
/*
** sv_h263_common.c
*/
extern SvStatus_t svH263SetParamInt(SvHandle_t Svh, SvParameter_t param, qword value);
extern qword      svH263GetParamInt(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH263SetParamFloat(SvHandle_t Svh, SvParameter_t param, float value);
extern float      svH263GetParamFloat(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH263SetParamBoolean(SvHandle_t Svh, SvParameter_t param, ScBoolean_t value);
extern ScBoolean_t svH263GetParamBoolean(SvHandle_t Svh, SvParameter_t param);

/*
** sv_h263_decode.c
*/
extern SvStatus_t svH263InitDecompressor(SvCodecInfo_t *Info);
extern SvStatus_t svH263Decompress(SvCodecInfo_t *Info, u_char **ImagePtr);
extern SvStatus_t svH263FreeDecompressor(SvCodecInfo_t *Info);
/*
** sv_h263_encode.c
*/
extern SvStatus_t svH263InitCompressor(SvCodecInfo_t *Info);
extern SvStatus_t svH263Compress(SvCodecInfo_t *Info, u_char *ImagePtr);
extern SvStatus_t svH263FreeCompressor(SvCodecInfo_t *Info);

#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
/*---------------------------------------------------------------------------*/
/*                             Huff Prototypes                               */
/*---------------------------------------------------------------------------*/

/*
** sv_huff_encode.c
*/
extern SvStatus_t sv_HuffInitEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffFreeEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffEncodeFrame(SvCodecInfo_t *Info,
                                      unsigned char *InputImage);
extern SvStatus_t sv_HuffPutHeader(SvHuffInfo_t *HInfo, ScBitstream_t *bs);


/*
** sv_huff_decode.c
*/
extern SvStatus_t sv_HuffInitDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffFreeDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffDecodeFrame(SvCodecInfo_t *Info,
                                     unsigned char *OutputImage);
extern SvStatus_t sv_HuffGetHeader(SvHuffInfo_t *HInfo, ScBitstream_t *bs);

/*
** sv_huff_encode.c
*/

#endif /* HUFF_SUPPORT */

#endif /* _SV_PROTOTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\cb53mmx.c ===
// cb53mmx.c

#include "cst_lbc.h"
#include "mmxutil.h"
#include "opt.h"
#include "exc_lbc.h"
#include "timer.h"
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "util_lbc.h"

#define ASM_CORHPL 1
#define ASM_CORHDL 1
#define TESTME 0
#define CHTEST 0

#if COMPILE_MMX
void CorrelateIntTri(short *taps, short *array, int *corr, int ncor);
void CorrelateInt22(short *taps, short *array, int *corr, int ncor);
void Cor_h_Xint(short h[],short X[],int D[]);
void Cor_hint0(short *H, int *rr);
void Cor_hint1(short *H, int *rr);
void cor_h_prodloop(int n, int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0);
void cor_h_diag(int n, int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0);

//------------------------------------------------------------
int ACELP_LBC_code_int(float X[], float h[], int T0, float code[],
		int *ind_gain, int *shift, int *sign, float gain_T0, int flags)
{
  int i, index;
  float gain_q;
  float Dn[SubFrLen2], tmp_code[SubFrLen2];
  float rr[DIM_RR];
  DECLARE_INT(rrint, DIM_RR);
  DECLARE_SHORT(hint, SubFrLen2);
  DECLARE_INT(Dnint, SubFrLen2);
  DECLARE_SHORT(Xint, SubFrLen2);
  int XScale;
  float hScale;
  int m;
#if 0//TESTME
   float htest[SubFrLen], Xtest[SubFrLen];

   for (i = 0; i<SubFrLen; i++)
   {
	 htest[i] = i; //(float)(i<30?i:60-i);
	 Xtest[i] = (float)(i<30?i:60-i);
   }
   h = htest;
   X = Xtest;
#endif //TESTME

// Include fixed-gain pitch contribution into impulse resp. h[]

  if (T0 < SubFrLen-2)
    for (i = T0; i < SubFrLen; i++)
      h[i] += gain_T0*h[i-T0];

  ALIGN_ARRAY(rrint);
  ALIGN_ARRAY(hint);
  ALIGN_ARRAY(Dnint);
  ALIGN_ARRAY(Xint);

  //hScale = FloatToShortScaled(h, hint, SubFrLen, 3);
  hScale = (float)sqrt(DotProd(h,h,SubFrLen)/(double)SubFrLen);
  m = (asint(hScale) & 0x7f800000) >> 23;
  ScaleFloatToShort(h, hint, SubFrLen, m+3);

  XScale = FloatToShortScaled(X, Xint, SubFrLen, 3);  //would be better to normalize based on engery, not max
#if 0
   for (i = 0; i<SubFrLen; i++)
   {
	 hint[i] = i;
   }
#endif

  // Compute correlations of h[] needed for the codebook search
//TIMER_STAMP(a);
  Cor_hint1(hint, rrint);
   IntToFloat(rrint, DIM_RR, rr);
//TIMER_STAMP(b);
//  Cor_h(h, rr);
////TIMER_STAMP(c);
#if CHTEST
{
  DECLARE_INT(rrint2, DIM_RR);

  ALIGN_ARRAY(rrint2);//debug
  Cor_hint0(hint, rrint2);
  for(i = 0; i<DIM_RR; i++)	 //debug
	  if(rrint[i] != rrint2[i])
	    printf("%3d: %8d %8d  %8d\n",i, rrint[i], rrint2[i], rrint[i] - rrint2[i]);
}
#endif //CHTEST

// Compute correlation of target vector with impulse response.

//TIMER_STAMP(c);
   Cor_h_Xint(hint, Xint, Dnint);
//TIMER_STAMP(d);
   IntToFloat(Dnint, SubFrLen, Dn);

   //TIMER_STAMP(a);

#if TESTME //test
  {
    int fpDnint[SubFrLen2];
//	float scale;

//	scale  =
    Cor_h_X(h,X,Dn);
    FloatToIntScaled(Dn, fpDnint, SubFrLen, 7);
    for (i = 0; i<SubFrLen; i++)
      if(fpDnint[i] != Dnint[i])
        printf("%3d: %8x %8x %8x\n", i, Dnint[i] - fpDnint[i],Dnint[i], fpDnint[i]);
  }
#endif //test


// Find codebook index

//TIMER_STAMP(c);
  index = D4i64_LBC(Dn, rr, h, tmp_code, rr, shift, sign, flags);
//TIMER_STAMP(f);

// Compute innovation vector gain.
// Include fixed-gain pitch contribution into code[].

  *ind_gain = G_code(X, rr, &gain_q);

  for (i=0; i < SubFrLen; i++)
    code[i] = tmp_code[i]*gain_q;

  if(T0 < SubFrLen-2)
    for (i=T0; i < SubFrLen; i++)
      code[i] += code[i-T0]*gain_T0;

  return index;
}


//---------------------------------------------------------------
//---------------------------------------------------------------
void Cor_hint0(short *H, int *rr)
{

//  Compute  correlations of h[]  needed for the codebook search.
//    h[]              :Impulse response.
//    rr[]             :Correlations.

  int *rri0i0, *rri1i1, *rri2i2, *rri3i3;
  int *rri0i1, *rri0i2, *rri0i3;
  int *rri1i2, *rri1i3, *rri2i3;

  int *p0, *p1, *p2, *p3;
  int cor;

  int i, k, m, t;
  DECLARE_SHORT(h,SubFrLen2);
  DECLARE_SHORT(h2,SubFrLen2);

  ALIGN_ARRAY(h);
  ALIGN_ARRAY(h2);

  for(i=0; i<4; i++)
    h[i] = (short)0;

  for(i=0; i<SubFrLen; i++)
    h2[i+2] = h[i+4] = H[i];


// Init pointers

  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;

// Compute rri0i0[], rri1i1[], rri2i2[] and rri3i3[]

  cor = 0;
  m = 0;
  for(i=NB_POS-1; i>=0; i--)
  {
    cor += h[m+0]*h[m+0] + h[m+1]*h[m+1];   rri3i3[i] = cor;
    cor += h[m+2]*h[m+2] + h[m+3]*h[m+3];   rri2i2[i] = cor;
    cor += h[m+4]*h[m+4] + h[m+5]*h[m+5];   rri1i1[i] = cor;
    cor += h[m+6]*h[m+6] + h[m+7]*h[m+7];   rri0i0[i] = cor;

    m += 8;
  }

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = h+2;
  p3 = rri2i3 + MSIZE-1;
  p2 = rri1i2 + MSIZE-1;
  p1 = rri0i1 + MSIZE-1;
  p0 = rri0i3 + MSIZE-2;

  for (k=0; k<NB_POS; k++)
  {
    cor = 0;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
    cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= NB_POS;
    p1 -= NB_POS;
    p0 -= 1;
  }


// Compute elements of: rri0i2[], rri1i3[]

  h2 = h+4;
  p3 = rri1i3 + MSIZE-1;
  p2 = rri0i2 + MSIZE-1;
  p1 = rri1i3 + MSIZE-2;
  p0 = rri0i2 + MSIZE-2;

  for (k=0; k<NB_POS; k++)
  {
    cor = 0;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= NB_POS;
    p1 -= 1;
    p0 -= 1;
  }

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = h+6;
  p3 = rri0i3 + MSIZE-1;
  p2 = rri2i3 + MSIZE-2;
  p1 = rri1i2 + MSIZE-2;
  p0 = rri0i1 + MSIZE-2;

  for (k=0; k<NB_POS; k++)
  {
    cor = 0;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= 1;
    p1 -= 1;
    p0 -= 1;
  }

  return;
}

//---------------------------------------------------------------
void cor_h_prods(int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0,int dp3,int dp2,int dp1,int dp0){
  int k;

  for (k=0; k<NB_POS; k++)
  {
    cor_h_prodloop(NB_POS-(k+1),oddn,h,h2,p3,p2,p1,p0);
    h2 += STEP;
    p3 -= dp3;
    p2 -= dp2;
    p1 -= dp1;
    p0 -= dp0;
  }
  return;
}

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

void cor_h_prodloop(int n, int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0)
{
#if ASM_CORHPL
	

	n = n * 4 + oddn;

#define in edi
#define inoff edx
#define out esi
#define out3 out+eax
#define out2 out+ebx
#define out1 out+ebp
#define out0 out

#define L(m,n)  ASM movq mm##m, QP[in+8*n]
#define M(m,n)  ASM pmaddwd mm##m, QP[in+inoff+8*n]
#define S(m)    ASM psrlq mm##m, 32
#define AH(m,n)   ASM paddd mm##m, mm##n
#define WH(m,o) ASM movd DP[out##o], mm##m
#define AL(m,n)   ASM paddd mm##m, mm##n
#define WL(m,o) ASM movd DP[out##o], mm##m


ASM {
   push ebp;
   mov ecx, n;
   mov in, h;
   mov inoff, h2;
   sub inoff, in;
   mov out, p0;
   mov eax, p3;
   mov ebx, p2;
   mov ebp, p1;
   sub eax, out;
   sub ebx, out;
   sub ebp, out;
}
L(0,0);
ASM pxor mm3,mm3;
M(0,0);
		L(1,1);
						AL(3,0); //really a copy
		M(1,1);
S(0);
ASM sub ecx,8;
ASM  jl oddends;

inner:
				L(2,2);
AH(0,3);
						WL(3,3);
WH(0,2);
AL(0,1);
				M(2,2);
		S(1);

						L(3,3);
		AH(1,0);
WL(0,1);
		WH(1,0);
		AL(1,2);
						M(3,3);
				S(2);
ASM sub out, 4*(NB_POS+1);

L(0,4);
				AH(2,1);
		WL(1,3);
				WH(2,2);
				AL(2,3);
M(0,4);
						S(3);

		L(1,5);
						AH(3,2);
				WL(2,1);
						WH(3,0);
						AL(3,0);
		M(1,5);
S(0);
ASM sub out, 4*(NB_POS+1);
ASM  add in, 16*2;
ASM sub ecx, 8;
ASM  jge inner;

oddends:
ASM add ecx, 4;
ASM  jl cleanup;

//four more
				L(2,2);
AH(0,3);
						WL(3,3);
WH(0,2);
AL(0,1);
				M(2,2);
		S(1);

						L(3,3);
		AH(1,0);
WL(0,1);
		WH(1,0);
		AL(1,2);
						M(3,3);
				S(2);
ASM sub out, 4*(NB_POS+1);

				AH(2,1);
ASM dec ecx;
ASM jl innerdone;
		WL(1,3);
ASM dec ecx;
ASM jl innerdone;
				WH(2,2);
				AL(2,3);
ASM dec ecx;
ASM jl innerdone;
				WL(2,1);
ASM jmp innerdone;

cleanup:
ASM add ecx, 4;
ASM dec ecx;
ASM jl innerdone;
AH(0,3);
						WL(3,3);
ASM dec ecx;
ASM jl innerdone;
WH(0,2);
AL(0,1);
ASM dec ecx;
ASM jl innerdone;
WL(0,1);

innerdone:
ASM emms;		
ASM pop ebp;
#undef in
#undef inoff
#undef out
#undef out3
#undef out2
#undef out1
#undef out0

#undef L
#undef M
#undef S
#undef AH
#undef WH
#undef AL
#undef WL
#else //ASM_CORHPL
  int cor;
  int i,m,t;

  cor = 0;
  m = 0;
  t = 0;

  for(i=n; i; i--)
  {
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
    cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
    cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

    t -= (NB_POS+1);
    m += 8;
  }
  if(oddn >= 1) {
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    if(oddn >= 2) {
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      if(oddn >= 3) {
        cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      }
    }
  }
#endif //ASM_CORHPL

  return;
}

void cor_h_diag(int n, int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0)
{
#if ASM_CORHDL
	

	n = n * 4 + oddn;

#define in edi
#define inoff edx
#define out esi
#define out3 out+eax
#define out2 out+ebx
#define out1 out+ebp
#define out0 out

#define L(m,n)  ASM movq mm##m, QP[in+8*n]
#define M(m,n)  ASM pmaddwd mm##m, QP[in+inoff+8*n]
#define R(m)    ASM psrad mm##m, 1
#define S(m)    ASM psrlq mm##m, 32
#define AH(m,n) ASM paddd mm##m, mm##n
#define WH(m,o) ASM movd DP[out##o], mm##m
#define AL(m,n) ASM paddd mm##m, mm##n
#define WL(m,o) ASM movd DP[out##o], mm##m


ASM {
   push ebp;
   mov ecx, n;
   mov in, h;
   mov inoff, h2;
   sub inoff, in;
   mov out, p0;
   mov eax, p3;
   mov ebx, p2;
   mov ebp, p1;
   sub eax, out;
   sub ebx, out;
   sub ebp, out;
}
L(0,0);
ASM pxor mm3,mm3;
M(0,0);
		L(1,1);
						AL(3,0); //really a copy
		M(1,1);
R(0);
S(0);
ASM sub ecx,8;
ASM  jl oddends;

inner:
				L(2,2);
AH(0,3);
						WL(3,3);
		R(1);
WH(0,2);
AL(0,1);
				M(2,2);
		S(1);

						L(3,3);
		AH(1,0);
WL(0,1);
				R(2);
		WH(1,0);
		AL(1,2);
						M(3,3);
				S(2);
ASM sub out, 4*1;

L(0,4);
				AH(2,1);
		WL(1,3);
						R(3);
				WH(2,2);
				AL(2,3);
M(0,4);
						S(3);

		L(1,5);
						AH(3,2);
				WL(2,1);
R(0);
						WH(3,0);
						AL(3,0);
		M(1,5);
S(0);
ASM sub out, 4*1;
ASM  add in, 16*2;
ASM sub ecx, 8;
ASM  jge inner;

oddends:
ASM add ecx, 4;
ASM  jl cleanup;

//four more
				L(2,2);
AH(0,3);
						WL(3,3);
		R(1);
WH(0,2);
AL(0,1);
				M(2,2);
		S(1);

						L(3,3);
		AH(1,0);
WL(0,1);
				R(2);
		WH(1,0);
		AL(1,2);
						M(3,3);
				S(2);
ASM sub out, 4*1;

				AH(2,1);
ASM dec ecx;
ASM jl innerdone;
		WL(1,3);
ASM dec ecx;
ASM jl innerdone;
				WH(2,2);
				AL(2,3);
ASM dec ecx;
ASM jl innerdone;
				WL(2,1);
ASM jmp innerdone;

cleanup:
ASM add ecx, 4;
ASM dec ecx;
ASM jl innerdone;
AH(0,3);
						WL(3,3);
ASM dec ecx;
ASM jl innerdone;
WH(0,2);
AL(0,1);
ASM dec ecx;
ASM jl innerdone;
WL(0,1);

innerdone:
ASM emms;		
ASM pop ebp;
#undef in
#undef inoff
#undef out
#undef out3
#undef out2
#undef out1
#undef out0

#undef L
#undef M
#undef R
#undef S
#undef AH
#undef WH
#undef AL
#undef WL
#else //ASM_CORHDL
  int cor;
  int i,m,t;

  cor = 0;
  m = 0;
  t = 0;

  for(i=n; i; i--)
  {
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor>>1;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor>>1;
    cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor>>1;
    cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor>>1;

    t -= 1;
    m += 8;
  }
  if(oddn >= 1) {
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    if(oddn >= 2) {
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      if(oddn >= 3) {
        cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      }
    }
  }
#endif //ASM_CORHDL

  return;
}

void Cor_hint1(short *H, int *rr)
{

//  Compute  correlations of h[]  needed for the codebook search.
//    h[]              :Impulse response.
//    rr[]             :Correlations.

  int *rri0i0, *rri1i1, *rri2i2, *rri3i3;
  int *rri0i1, *rri0i2, *rri0i3;
  int *rri1i2, *rri1i3, *rri2i3;

  int *p0, *p1, *p2, *p3;
  short *h2;

  int i;
  DECLARE_SHORT(h,SubFrLen2);
  DECLARE_SHORT(hp2,SubFrLen2);

  ALIGN_ARRAY(h);
  ALIGN_ARRAY(hp2);

  for(i=0; i<4; i++)
    h[i] = (short)0;

  for(i=0; i<SubFrLen; i++)
    hp2[i+2] = h[i+4] = H[i];


// Init pointers

  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;
//TIMER_STAMP(a);
// Compute rri0i0[], rri1i1[], rri2i2[] and rri3i3[]

  cor_h_diag(NB_POS,0,h,h,&rri3i3[NB_POS-1],&rri2i2[NB_POS-1],&rri1i1[NB_POS-1],&rri0i0[NB_POS-1]);
//TIMER_STAMP(b);

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = hp2;
  p3 = rri2i3 + MSIZE-1;
  p2 = rri1i2 + MSIZE-1;
  p1 = rri0i1 + MSIZE-1;
  p0 = rri0i3 + MSIZE-2;

  cor_h_prods(4-1,h,h2,p3,p2,p1,p0,NB_POS,NB_POS,NB_POS,1);

// Compute elements of: rri0i2[], rri1i3[]

  h2 = h+4;
  p3 = rri1i3 + MSIZE-1;
  p2 = rri0i2 + MSIZE-1;
  p1 = rri1i3 + MSIZE-2;
  p0 = rri0i2 + MSIZE-2;

  cor_h_prods(4-2,h,h2,p3,p2,p1,p0,NB_POS,NB_POS,1,1);

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = hp2+4;
  p3 = rri0i3 + MSIZE-1;
  p2 = rri2i3 + MSIZE-2;
  p1 = rri1i2 + MSIZE-2;
  p0 = rri0i1 + MSIZE-2;

  cor_h_prods(4-3,h,h2,p3,p2,p1,p0,NB_POS,1,1,1);
//TIMER_STAMP(c);

  return;
}

//---------------------------------------------------------------------------
void Cor_h_Xint(short h[],short X[],int D[])
{
   int i;
   DECLARE_SHORT(hh, 2*SubFrLen+16); //h[-1,0,0,1,1,2,2,3,3,4,4,5,...57,58,58,59]
   DECLARE_SHORT(XX, 2*SubFrLen+16); //X[ 0,1,0,1,2,3,2,3,4,5,4,5,...58,59,58,59]
#if TESTME
   short htest[SubFrLen], Xtest[SubFrLen];

   for (i = 0; i<SubFrLen; i++)
   {
	 htest[i] = 1;//(short)(i<30?i:60-i);
	 Xtest[i] = 1;//(short)(i<30?i:60-i);
   }
   h = htest;
   X = Xtest;
#endif //TESTME

   ALIGN_ARRAY(hh);
   ALIGN_ARRAY(XX);
   for (i=2*SubFrLen; i < 2*SubFrLen+16; i++) {
	 XX[i] = hh[i] = (short)0;
   }
//   hh += 8; XX += 8;

#define ASM_Cor_h_Xint 1
#if ASM_Cor_h_Xint
   ab2ababw(X, XX, SubFrLen);
   ab2abzaw(h, hh, SubFrLen);
   //TIMER_STAMP(e);
   CorrelateIntTri (hh, XX, D, SubFrLen);
#if TESTME
   {
	   int D2[SubFrLen];
       CorrelateInt22 (hh, XX, D2, SubFrLen);
	   for (i = 0; i<SubFrLen; i++)	{
		//  if(D[i] != D2[i])
			printf("%3d: %6d %6d %6d   ", i,D[i], D2[i], D[i] - D2[i]);
			if(i&1) printf("\n");
	   }
   }
#endif TESTME	

#else //ASM_Cor_h_Xint
   for (i=0; i < SubFrLen; i+=2)	 {
	 hh[2*i] = (i-1 >= 0) ? h[i-1] : (short)0;
     hh[2*i+1] = h[i];
     hh[2*i+2] = h[i];
     hh[2*i+3] = h[i+1];
	 XX[2*i] = X[i];
	 XX[2*i+1] = X[i+1];
	 XX[2*i+2] = X[i];
	 XX[2*i+3] = X[i+1];
}

   for (i=0; i < 2*SubFrLen; i+=4)	 {
	 int acc0 = 0, acc1 = 0;
	 for (j=0; j < 2*SubFrLen - i; j+=4) {
       acc0 += (int)hh[j]*XX[i+j] + (int)hh[j+1]*XX[i+j+1];
       acc1 += (int)hh[j+2]*XX[i+j+2] + (int)hh[j+3]*XX[i+j+3];
	 }
	 D[i/2] = acc0 >> 16;
	 D[i/2+1] = acc1 >> 16;
   }
#endif //ASM_Cor_h_Xint
	
   return;
}
//---------------------------------------------------------------------------
#define ASM_CORR_TRI 1
//#if ASM_CORR_TRI
//------------------------------------------------------
// triangular correlations
// ASSUMES that array has 8 zero values beyond the end
//   and can be read 8 more beyond that (without page fault etc)
// data format is
//   taps: 0 t0 t0 t1  t1 t2 t2 t3  t3 t4 t4 t5 ... t57 t58 t58 t59
//	 arr: a0 a1 a0 a1  a2 a3 a2 a3  a4 a5 a4 a5 ... a58 a59 a58 a59
//
void CorrelateIntTri(short *taps, short *array, int *corr, int ncor)
{
#define rega0  mm0
#define regb0  mm1
#define rega1  mm2
#define regb1  mm3
#define rega2  mm4
#define regb2  mm5
#define acc0   mm6
#define acc1   mm7

#define arr    esi
#define tap    edi
#define cor    eax
#define icnt   ecx

// In the following macros, 'n' is the column number and 'i' is the
// iteration number.

// we use "the convolution trick" or using la twice so that one
// of the pmadd's is reg,reg and thus can be in the V-slot.

// NOTE: we have read ahead up to 2 quadwords
//   so we need QP[taps+8*ncor] = QP[taps+8*ncor+8] = [0 0 0 0]
//   and reading QP[array+8*ncor] or QP[array+8*ncor+8] must be legal

#define la(n,i)  ASM movq  rega##n,QP[arr+8*i]
#define lb(n,i)  ASM movq  regb##n,QP[tap+8*i-8]
#define m0(n,i)  ASM pmaddwd regb##n,rega##n
#define m1(n,i)  ASM pmaddwd rega##n,QP[tap+8*i]
#define a0(n,i)  ASM paddd acc0,regb##n
#define a1(n,i)  ASM paddd acc1,rega##n

  ASM
  {
    shr ncor,1;
    mov cor,corr;
    mov tap,taps;
    mov arr,array;
    mov icnt,ncor;
  }

ForEachCorrPair:

// prime the pump

  la(0,0);
  ASM pxor regb0,regb0;   // to  avoid lb(0,0) reading taps[-1]
          la(1,1);
  ASM pxor acc0,acc0;	  // clear accumulator
  m1(0,0);
  ASM pxor acc1,acc1;	  // clear accumulator
          lb(1,1);
  ASM sub icnt, 1;        // account for pump priming
  ASM jle cleanup;        // bypass if only one to do

inner:
                  la(2,2);
          m0(1,1);
          m1(1,1);
  a0(0,0);
                  lb(2,2);
  a1(0,0);
  la(0,3);
                  m0(2,2);
                  m1(2,2);
          a0(1,1);
  lb(0,3);
          a1(1,1);
          la(1,4);
  m0(0,3);
  m1(0,3);
                  a0(2,2);
          lb(1,4);
                  a1(2,2);

  ASM add arr,24;
  ASM add tap,24;

  ASM sub icnt,3;
  ASM jg inner;

cleanup:  //  last two adds
  a0(0,0);
  a1(0,0);

// Done with one correlation pair.  Pack and store 2 results in corr array

  ASM
  {
    add cor,16;
     mov arr, array
    mov tap,taps;
	 add arr,16;
    mov icnt, ncor;
	
	mov array, arr;
	 sub icnt,2;	  //set flags for jump

	movq  QP[cor-16],acc1;
	movq  QP[cor-8],acc0;

	mov ncor, icnt;
    jg ForEachCorrPair;

    emms;
  }

}
#undef rega0
#undef regb0
#undef rega1
#undef regb1
#undef rega2
#undef regb2
#undef acc0
#undef acc1

#undef arr
#undef tap
#undef cor
#undef icnt
#undef la
#undef lb
#undef m0
#undef m1
#undef a0
#undef a1
// 16 bit output
//	 psrad acc0,16;//this could be less in some cases
//	 psrad acc1,16;
//	 packssdw acc1,acc0;
//   movq  QP[cor-8],acc0;

//#else
//------------------------------------------------------
void CorrelateInt22(short *taps, short *array, int *corr, int ncor)
{
  int i,j;

  for (i=0; i < 2*ncor; i+=4)	 {
    int acc0 = 0, acc1 = 0;
    for (j=0; j < 2*ncor - i; j+=4) {
      acc0 += (int)taps[j]*array[i+j] + (int)taps[j+1]*array[i+j+1];
      acc1 += (int)taps[j+2]*array[i+j+2] + (int)taps[j+3]*array[i+j+3];
    }
    corr[i/2] = acc0 ;
    corr[i/2+1] = acc1 ;
  }

  return;
}
//#endif

#endif //COMPILE_MMX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\cb53.c ===
//cb53.c - 5.3 rate codebook code

#include "opt.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "util_lbc.h"
#include "exc_lbc.h"
#include "timer.h"
#include "mmxutil.h"

void fourPulseFlt (float *rr, float *Dn, float thres, int ip[], int *shiftPtr);

//--------------------------------------------------------
int extra;
void reset_max_time(void)
{
  extra = 120;
}


//------------------------------------------------------------
int ACELP_LBC_code(float X[], float h[], int T0, float code[],
		int *ind_gain, int *shift, int *sign, float gain_T0, int flags)
{
  int i, index;
  float gain_q;
  float Dn[SubFrLen2], tmp_code[SubFrLen2];
  float rr[DIM_RR];

// Include fixed-gain pitch contribution into impulse resp. h[]

  if (T0 < SubFrLen-2)
    for (i = T0; i < SubFrLen; i++)
      h[i] += gain_T0*h[i-T0];

// Compute correlations of h[] needed for the codebook search

  Cor_h(h, rr);
 
// Compute correlation of target vector with impulse response.

  Cor_h_X(h, X, Dn);
  
// Find codebook index

  index = D4i64_LBC(Dn, rr, h, tmp_code, rr, shift, sign, flags);

// Compute innovation vector gain.
// Include fixed-gain pitch contribution into code[].

  *ind_gain = G_code(X, rr, &gain_q);

  for (i=0; i < SubFrLen; i++)
    code[i] = tmp_code[i]*gain_q;

  if(T0 < SubFrLen-2)
    for (i=T0; i < SubFrLen; i++)
      code[i] += code[i-T0]*gain_T0;

  return index;
}


//---------------------------------------------------------------
void Cor_h(float *H, float *rr)
{

//  Compute  correlations of h[]  needed for the codebook search.
//    h[]              :Impulse response.
//    rr[]             :Correlations.

  float *rri0i0, *rri1i1, *rri2i2, *rri3i3;
  float *rri0i1, *rri0i2, *rri0i3;
  float *rri1i2, *rri1i3, *rri2i3;

  float *p0, *p1, *p2, *p3;
  float cor, *h2;
  int i, k, m, t;
  float h[SubFrLen2];

  for(i=0; i<SubFrLen; i++)
    h[i+4] = H[i];

  for(i=0; i<4; i++)
    h[i] = 0.0f;

// Init pointers

  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;

// Compute rri0i0[], rri1i1[], rri2i2[] and rri3i3[]

  cor = 0.0f;
  m = 0;
  for(i=NB_POS-1; i>=0; i--)
  {
    cor += h[m+0]*h[m+0] + h[m+1]*h[m+1];   rri3i3[i] = cor*0.5f;
    cor += h[m+2]*h[m+2] + h[m+3]*h[m+3];   rri2i2[i] = cor*0.5f;
    cor += h[m+4]*h[m+4] + h[m+5]*h[m+5];   rri1i1[i] = cor*0.5f;
    cor += h[m+6]*h[m+6] + h[m+7]*h[m+7];   rri0i0[i] = cor*0.5f;

    m += 8;
  }

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = h+2;
  p3 = rri2i3 + MSIZE-1;
  p2 = rri1i2 + MSIZE-1;
  p1 = rri0i1 + MSIZE-1;
  p0 = rri0i3 + MSIZE-2;
    
  for (k=0; k<NB_POS; k++)
  {
    cor = 0.0f;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
    cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= NB_POS;
    p1 -= NB_POS;
    p0 -= 1;
  }


// Compute elements of: rri0i2[], rri1i3[] 

  h2 = h+4;
  p3 = rri1i3 + MSIZE-1;
  p2 = rri0i2 + MSIZE-1;
  p1 = rri1i3 + MSIZE-2;
  p0 = rri0i2 + MSIZE-2;
    
  for (k=0; k<NB_POS; k++)
  {
    cor = 0.0f;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
    
    h2 += STEP;
    p3 -= NB_POS;
    p2 -= NB_POS;
    p1 -= 1;
    p0 -= 1;
  }
  
// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = h+6;
  p3 = rri0i3 + MSIZE-1;
  p2 = rri2i3 + MSIZE-2;
  p1 = rri1i2 + MSIZE-2;
  p0 = rri0i1 + MSIZE-2;
    
  for (k=0; k<NB_POS; k++)
  {
    cor = 0.0f;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= 1;
    p1 -= 1;
    p0 -= 1;
  }
  
  return;
}

//---------------------------------------------------------------------------
void Cor_h_X(float h[],float X[],float D[])
{
   int i;
  
   for (i=0; i < SubFrLen; i++)	 
     D[i] = DotProd(&X[i],h,(SubFrLen-i));
	
   return;
}

//-------------------------------------------------------------------------
Find_Pulse4(float *Dn,float *rri3i3,float *ptr_ri0i3,float *ptr_ri1i3,
  float *ptr_ri2i3,float *ptr, float ps2,float alp2,float *psbest,float *abest)
{
  int k,bestk;
  float ps3;
  float a[16];

  for (k=0; k<8; k++)
  {
    ps3 = ps2 + *ptr;
    a[k] = alp2 + rri3i3[k] + ptr_ri0i3[k] + ptr_ri1i3[k] + ptr_ri2i3[k];
    a[k+8] = ps3 * ps3;
    
    ptr += STEP;
  }

  bestk = -1;
  for (k=0; k<8; k++)
  {
    if((a[k+8] * (*abest)) > ((*psbest) * a[k]))
    {
      *psbest = a[k+8];
      *abest = a[k];
      bestk = k;
    }
  }
  return(bestk);
}

//-------------------------------------------------------------------------
//   routine   D4i64_LBC                                                  
//           ~~~~~~~~~                                                   
// Algebraic codebook for LBC.                                           
//  -> 17 bits; 4 pulses in a frame of 60 samples                        
//                                                                       
// The code length is 60, containing 4 nonzero pulses i0, i1, i2, i3.    
// Each pulses can have 8 possible positions (positive or negative):     
//                                                                       
// i0 (+-1) : 0, 8,  16, 24, 32, 40, 48, 56                              
// i1 (+-1) : 2, 10, 18, 26, 34, 42, 50, 58                              
// i2 (+-1) : 4, 12, 20, 28, 36, 44, 52, (60)                            
// i3 (+-1) : 6, 14, 22, 30, 38, 46, 54, (62)                            
//                                                                       
// All the pulse can be shift by one.                                    
// The last position of the last 2 pulse falls outside the               
// frame and signifies that the pulse is not present.                    
//
//  Input arguments:                                                     
//                                                                       
//   Dn[]       Correlation between target vector and impulse response h[]
//   rr[]       Correlations of impulse response h[]                     
//   h[]        Impulse response of filters                              
//                                                                       
//  Output arguments:                                                   
//                                                                       
//   cod[]      Selected algebraic codeword                              
//   y[]        Filtered codeword                                        
//   code_shift Shift of the codeword                                    
//   sign       Signs of the 4 pulses.                                   
//                                                                       
//   return:    Index of selected codevector                             
//
// The threshold control if a section of the innovative              
// codebook should be searched or not.                               
//                                                                   
//--------------------------------------------------------------------

int D4i64_LBC(float Dn[], float rr[], float h[], float cod[],
			  float y[], int *code_shift, int *sign, int flags)
{
   int  ip[4];
   int  i0, i1, i2, i3, ip0, ip1, ip2, ip3;
   int  i, j;
   int  shif;
   float   means, max0, max1, max2, thres;

   float *rri0i0,*rri1i1,*rri2i2,*rri3i3;
   float *rri0i1,*rri0i2,*rri0i3;
   float *rri1i2,*rri1i3,*rri2i3;

  // float *ptr_ri0i0,*ptr_ri1i1,*ptr_ri2i2;
   float *ptr_ri0i1,*ptr_ri0i2,*ptr_ri0i3;
   float *ptr_ri1i2,*ptr_ri1i3,*ptr_ri2i3;

   int  p_sign[SubFrLen2/2];
//   float  p_sign[SubFrLen2/2],p_sign2[SubFrLen2/2];

// Init pointers 

  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;

 // Extend the backward filtered target vector by zeros                

   for (i=SubFrLen; i < SubFrLen2; i++) 
     Dn[i] = 0.0f;

// Chose the sign of the impulse.                                        

   for (i=0; i<SubFrLen; i+=2)
   {
     if((Dn[i] + Dn[i+1]) >= 0.0f)
     {
		 p_sign[i/2] = 0x00000000;
//       p_sign[i/2] = 1.0f;
//       p_sign2[i/2] = 2.0f;
     }
     else
     {
		 p_sign[i/2] = 0x80000000;
//       p_sign[i/2] = -1.0f;
//       p_sign2[i/2] = -2.0f;
       Dn[i] = -Dn[i];
       Dn[i+1] = -Dn[i+1];
     }
   }
   p_sign[30] = p_sign[31] = 0x00000000;
//   p_sign[30] = p_sign[31] = 1.0f;
//   p_sign2[30] = p_sign2[31] = 2.0f;

// - Compute the search threshold after three pulses                 
// odd positions 
// Find maximum of Dn[i0]+Dn[i1]+Dn[i2]

   max0 = Dn[0];
   max1 = Dn[2];
   max2 = Dn[4];
   for (i=8; i < SubFrLen; i+=STEP)
   {
     if (Dn[i] > max0)   max0 = Dn[i];
     if (Dn[i+2] > max1) max1 = Dn[i+2];
     if (Dn[i+4] > max2) max2 = Dn[i+4];
   }
   max0 = max0 + max1 + max2;

// Find means of Dn[i0]+Dn[i1]+Dn[i]

   means = 0.0f;
   for (i=0; i < SubFrLen; i+=STEP)
     means += Dn[i+4] + Dn[i+2] + Dn[i];

   means *= 0.125f;  
   if (flags & SC_THRES)
     thres = means*0.25f + max0*0.75f;
   else
     thres = means + (max0-means)*0.5f;
 
 // even positions 
 // Find maximum of Dn[i0]+Dn[i1]+Dn[i2]

   max0 = Dn[1];
   max1 = Dn[3];
   max2 = Dn[5];
   for (i=9; i < SubFrLen; i+=STEP)
   {
     if (Dn[i] > max0)   max0 = Dn[i];
     if (Dn[i+2] > max1) max1 = Dn[i+2];
     if (Dn[i+4] > max2) max2 = Dn[i+4];
   }
   max0 = max0 + max1 + max2;

// Find means of Dn[i0]+Dn[i1]+Dn[i2] 

   means = 0.0f;
   for (i=1; i < SubFrLen; i+=STEP)
     means += Dn[i+4] + Dn[i+2] + Dn[i];
  
   means *= 0.125f;
   if (flags & SC_THRES)
     max1 = means*0.25f + max0*0.75f;
   else
     max1 = means + (max0-means)*0.5f; 

// Keep maximum threshold between odd and even position 

   if(max1 > thres) thres = max1;

// Modification of rrixiy[] to take signs into account.
//TIMER_STAMP(a);            
  ptr_ri0i1 = rri0i1;
  ptr_ri0i2 = rri0i2;
  ptr_ri0i3 = rri0i3;

  for(i0=0; i0<SubFrLen/2; i0+=STEP/2)
  {
	 for(i1=2/2; i1<SubFrLen/2; i1+=STEP/2)
     {
	   (int)*ptr_ri0i1++ = (asint(*ptr_ri0i1) ^ p_sign[i0] ^ p_sign[i1]);
	   (int)*ptr_ri0i2++ = (asint(*ptr_ri0i2) ^ p_sign[i0] ^ p_sign[i1+1]);
	   (int)*ptr_ri0i3++ = (asint(*ptr_ri0i3) ^ p_sign[i0] ^ p_sign[i1+2]);
     }
  }

  ptr_ri1i2 = rri1i2;
  ptr_ri1i3 = rri1i3;
  for(i1=2/2; i1<SubFrLen/2; i1+=STEP/2)
  {
	 for(i2=4/2; i2<SubFrLen2/2; i2+=STEP/2)
     {
	   (int)*ptr_ri1i2++ = (asint(*ptr_ri1i2) ^ p_sign[i1] ^ p_sign[i2]);
	   (int)*ptr_ri1i3++ = (asint(*ptr_ri1i3) ^ p_sign[i1] ^ p_sign[i2+1]);
     }
  }

  ptr_ri2i3 = rri2i3;
  for(i2=4/2; i2<SubFrLen2/2; i2+=STEP/2)
  {
	 for(i3=6/2; i3<SubFrLen2/2; i3+=STEP/2)
	   (int)*ptr_ri2i3++ = (asint(*ptr_ri2i3) ^ p_sign[i2] ^ p_sign[i3]);
  }

//TIMER_STAMP(b);            
fourPulseFlt(rr, Dn, thres, ip, code_shift);
//TIMER_STAMP(c);            

ip0 = ip[0];
ip1 = ip[1];
ip2 = ip[2];
ip3 = ip[3];
shif = *code_shift;

// Set the sign of impulses 

 i0 = (p_sign[(ip0 >> 1)]>=0?1:-1);
 i1 = (p_sign[(ip1 >> 1)]>=0?1:-1);
 i2 = (p_sign[(ip2 >> 1)]>=0?1:-1);
 i3 = (p_sign[(ip3 >> 1)]>=0?1:-1);

// Find the codeword corresponding to the selected positions 

 for(i=0; i<SubFrLen; i++) 
   cod[i] = 0.0f;

 if(shif > 0)
 {
   ip0++;
   ip1++;
   ip2++;
   ip3++;
 }
 
//printf("%3d %3d %3d %3d\n",ip0*i0,ip1*i1,ip2*i2,ip3*i3);
 cod[ip0] =  (float)i0;
 cod[ip1] =  (float)i1;
 if(ip2<SubFrLen)
   cod[ip2] = (float)i2;
 if(ip3<SubFrLen)
   cod[ip3] = (float)i3;

// find the filtered codeword 

 for (i=0; i < SubFrLen; i++) 
   y[i] = 0.0f;

 if(i0 > 0)
   for(i=ip0, j=0; i<SubFrLen; i++, j++)
	   y[i] = y[i] + h[j];
 else
   for(i=ip0, j=0; i<SubFrLen; i++, j++)
       y[i] = y[i] - h[j];

 if(i1 > 0)
   for(i=ip1, j=0; i<SubFrLen; i++, j++)
	   y[i] = y[i] + h[j];
 else
   for(i=ip1, j=0; i<SubFrLen; i++, j++)
       y[i] = y[i] - h[j];

 if(ip2<SubFrLen)
 {
   if(i2 > 0)
	 for(i=ip2, j=0; i<SubFrLen; i++, j++)
         y[i] = y[i] + h[j];
   else
	 for(i=ip2, j=0; i<SubFrLen; i++, j++)
         y[i] = y[i] - h[j];
 }

 if(ip3<SubFrLen)
 {
   if(i3 > 0)
	 for(i=ip3, j=0; i<SubFrLen; i++, j++)
       y[i] = y[i] + h[j];
   else
	 for(i=ip3, j=0; i<SubFrLen; i++, j++)
       y[i] = y[i] - h[j];
 }

// find codebook index;  17-bit address 

 *code_shift = shif;

 *sign = 0;
 if(i0 > 0) *sign += 1;
 if(i1 > 0) *sign += 2;
 if(i2 > 0) *sign += 4;
 if(i3 > 0) *sign += 8;

 i = ((ip3 >> 3) << 9) + ((ip2 >> 3) << 6) + ((ip1 >> 3) << 3) + (ip0 >> 3);
//TIMER_STAMP(d);

 return i;
}

//--------------------------------------------------------------------
int G_code(float X[], float Y[], float *gain_q)
{
   int i;
   float xy, yy, gain_nq; 
   int gain;
   float dist, dist_min;

// Compute scalar product <X[],Y[]>
   
	xy = DotProd(X,Y,SubFrLen);

// Be sure xy < yy 

   if(xy <= 0) 
   {
	 gain = 0;
	 *gain_q =FcbkGainTable[gain];
	 return(gain);
   }

// Compute scalar product <Y[],Y[]> 
  
   yy = DotProd(Y,Y,SubFrLen);

   if (yy != 0.0f)
     gain_nq = xy/yy * 0.5f;
   else
     gain_nq = 0.0f;

   gain = 0;
   dist_min = (float)fabs(gain_nq - FcbkGainTable[0]);
 
   for (i=1; i <NumOfGainLev; i++) 
   {
	 dist = (float)fabs(gain_nq - FcbkGainTable[i]);
	 if (dist < dist_min) 
	 {
		dist_min = dist;
		gain = i;
	 }
   }
   *gain_q = FcbkGainTable[gain];
   return(gain);
}



 //-------------------------------------------------------------------
 // Search the optimum positions of the four  pulses which maximize   
 //     square(correlation) / energy                                  
 // The search is performed in four  nested loops. At each loop, one  
 // pulse contribution is added to the correlation and energy.        
 //                                                                   
 // The fourth loop is entered only if the correlation due to the     
 //  contribution of the first three pulses exceeds the preset        
 //  threshold.                                                       
 //-------------------------------------------------------------------
void fourPulseFlt (float *rr, float *Dn, float thres, int ip[], int *shifPtr){

 // Default values 

   int ip0    = 0;
   int ip1    = 2;
   int ip2    = 4;
   int ip3    = 6;
   int shif   = 0;
   int  i0, i1, i2;
   int  k, time;
   int  shift, bestk, lasti2, inc;
   float psc    = 0.0f;
   float alpha  = 1.0f;
   float  ps0, ps1, ps2, alp0;
   float  alp1, alp2;
   float  ps0a, ps1a, ps2a;
   float *ptr_ri0i0,*ptr_ri1i1,*ptr_ri2i2;
   float *ptr_ri0i1,*ptr_ri0i2,*ptr_ri0i3;
   float *ptr_ri1i2,*ptr_ri1i3,*ptr_ri2i3;

   float *rri0i0,*rri1i1,*rri2i2,*rri3i3;
   float *rri0i1,*rri0i2,*rri0i3;
   float *rri1i2,*rri1i3,*rri2i3;
   
   float a[16];
   float t1,t2,*pntr;
   float dmax4, dmax5, dmax2, dmax3; //used for bypass
#if !OPT_PULSE4
   int i3;
   float ps3;
#endif

 time   = max_time + extra;

 // Four loops to search innovation code.
 // Init. pointers that depend on first loop
  
  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;

 ptr_ri0i0 = rri0i0;    
 ptr_ri0i1 = rri0i1;
 ptr_ri0i2 = rri0i2;
 ptr_ri0i3 = rri0i3;

 // Compute the Dn max's

 dmax2 = dmax3 = dmax4 = dmax5 = -1000000.0f; //i.e., large negative number
 for (k = 2; k<SubFrLen2; k+=STEP)
 {
   if (Dn[k] > dmax2) dmax2 = Dn[k];
   if (Dn[k+1] > dmax3) dmax3 = Dn[k+1];
   if (Dn[k+2] > dmax4) dmax4 = Dn[k+2];
   if (Dn[k+3] > dmax5) dmax5 = Dn[k+3];
 }

// first pulse loop  
 for (i0=0; i0 < SubFrLen; i0 +=STEP)        
 {
   ps0  = Dn[i0];
   ps0a = Dn[i0+1];
   alp0 = *ptr_ri0i0++;

// Init. pointers that depand on second loop
 
   ptr_ri1i1 = rri1i1;    
   ptr_ri1i2 = rri1i2;
   ptr_ri1i3 = rri1i3;

   ps1 = ps0 + dmax2 + dmax4;
   ps1a = ps0a + dmax3 + dmax5;
   if (asint(ps1) < asint(thres) && asint(ps1a) < asint(thres))
   {
	 ptr_ri0i1 += NB_POS;
	 goto skipsecond;
   }

 // second pulse loop

   for (i1=2; i1 < SubFrLen; i1 +=STEP)     
   {
	 ps1  = ps0 + Dn[i1];
	 ps1a = ps0a + Dn[i1+1];

	 alp1 = alp0 + *ptr_ri1i1++ + *ptr_ri0i1++; 

// Init. pointers that depend on third loop
 
     ptr_ri2i2 = rri2i2;     
     ptr_ri2i3 = rri2i3;
     lasti2 = 4;
 
     ps2 = ps1 + dmax4;
     ps2a = ps1a + dmax5;
     if (asint(ps2) < asint(thres) && asint(ps2a) < asint(thres))
     {
	   i2 = 68;
	   goto skipthird;
     }

// third pulse loop

	 for (i2 = 4; i2 < SubFrLen2; i2 +=STEP)    
   {
	   ps2  = ps1 + Dn[i2];
	   ps2a = ps1a + Dn[i2+1];

// Threshold test and 4th pulse loop.  Since the probability of
// entering this is low, we cram as much of the 3rd-pulse-loop
// logic inside the threshold test.  So the computation of shift,
// the choice of ps2 vs ps2a, the computation of alp2, and the
// incrementing of the 02,12,22 pointers are all done there.
     
     if (asint(ps2) > asint(thres) || asint(ps2a) > asint(thres))
	   {
       shift = 0;
       if(asint(ps2a) > asint(ps2))
       {
         shift = 1;
         ps2   = ps2a;
       }

       inc = (i2 - lasti2) >> 3;
       lasti2 = i2;
       ptr_ri0i2 += inc;
       ptr_ri1i2 += inc;
       ptr_ri2i2 += inc;

       alp2 = alp1 + *ptr_ri2i2 + *ptr_ri0i2 + *ptr_ri1i2; 
       pntr = &Dn[6+shift];

#if OPT_PULSE4

  ASM
  {
    push esi;
    push ebx;

    mov esi,pntr;

;// First half of first loop

    fld DP [esi+4*8*0];
    fld DP [esi+4*8*1];
    fld DP [esi+4*8*2];
    fld DP [esi+4*8*3];

    fxch ST(3);
    fadd ps2;
    fxch ST(2);
    fadd ps2;
    fxch ST(1);
    fadd ps2;
    fxch ST(3);
    fadd ps2;

    fxch ST(2);
    fmul ST,ST(0);
    fxch ST(1);
    fmul ST,ST(0);
    fxch ST(3);
    fmul ST,ST(0);
    fxch ST(2);
    fmul ST,ST(0);

    fxch ST(1);
    fstp a[4*8];
    fxch ST(2);
    fstp a[4*9];
    fstp a[4*10];
    fstp a[4*11];

;// Second half of first loop

    fld DP [esi+4*8*4];
    fld DP [esi+4*8*5];
    fld DP [esi+4*8*6];
    fld DP [esi+4*8*7];

    fxch ST(3);
    fadd ps2;
    fxch ST(2);
    fadd ps2;
    fxch ST(1);
    fadd ps2;
    fxch ST(3);
    fadd ps2;

    fxch ST(2);
    fmul ST,ST(0);
    fxch ST(1);
    fmul ST,ST(0);
    fxch ST(3);
    fmul ST,ST(0);
    fxch ST(2);
    fmul ST,ST(0);

    fxch ST(1);
    fstp a[4*12];
    fxch ST(2);
    fstp a[4*13];
    fstp a[4*14];
    fstp a[4*15];

;// First half of second loop

    mov eax,rri3i3;
    mov ebx,ptr_ri0i3;
    mov ecx,ptr_ri1i3;
    mov edx,ptr_ri2i3;

    fld alp2;
    fld alp2;
    fld alp2;
    fld alp2;

    fxch ST(3);
    fadd DP [eax+4*0];
    fxch ST(2);
    fadd DP [eax+4*1];
    fxch ST(1);
    fadd DP [eax+4*2];
    fxch ST(3);
    fadd DP [eax+4*3];

    fxch ST(2);
    fadd DP [ebx+4*0];
    fxch ST(1);
    fadd DP [ebx+4*1];
    fxch ST(3);
    fadd DP [ebx+4*2];
    fxch ST(2);
    fadd DP [ebx+4*3];

    fxch ST(1);
    fadd DP [ecx+4*0];
    fxch ST(3);
    fadd DP [ecx+4*1];
    fxch ST(2);
    fadd DP [ecx+4*2];
    fxch ST(1);
    fadd DP [ecx+4*3];

    fxch ST(3);
    fadd DP [edx+4*0];
    fxch ST(2);
    fadd DP [edx+4*1];
    fxch ST(1);
    fadd DP [edx+4*2];
    fxch ST(3);
    fadd DP [edx+4*3];

    fxch ST(2);
    fstp a[4*0];
    fstp a[4*1];
    fxch ST(1);
    fstp a[4*2];
    fstp a[4*3];

;// Second half of second loop

    fld alp2;
    fld alp2;
    fld alp2;
    fld alp2;

    fxch ST(3);
    fadd DP [eax+4*4];
    fxch ST(2);
    fadd DP [eax+4*5];
    fxch ST(1);
    fadd DP [eax+4*6];
    fxch ST(3);
    fadd DP [eax+4*7];

    fxch ST(2);
    fadd DP [ebx+4*4];
    fxch ST(1);
    fadd DP [ebx+4*5];
    fxch ST(3);
    fadd DP [ebx+4*6];
    fxch ST(2);
    fadd DP [ebx+4*7];

    fxch ST(1);
    fadd DP [ecx+4*4];
    fxch ST(3);
    fadd DP [ecx+4*5];
    fxch ST(2);
    fadd DP [ecx+4*6];
    fxch ST(1);
    fadd DP [ecx+4*7];

    fxch ST(3);
    fadd DP [edx+4*4];
    fxch ST(2);
    fadd DP [edx+4*5];
    fxch ST(1);
    fadd DP [edx+4*6];
    fxch ST(3);
    fadd DP [edx+4*7];

    fxch ST(2);
    fstp a[4*4];
    fstp a[4*5];
    fxch ST(1);
    fstp a[4*6];
    fstp a[4*7];
    
    pop ebx;
    pop esi;
  }

#else

       for (k=0; k<8; k++)
       {
         ps3 = ps2 + *pntr;
         pntr += STEP;
         a[k+8] = ps3 * ps3;
       }

       for (k=0; k<8; k++)
         a[k] = alp2 + rri3i3[k] + ptr_ri0i3[k] + ptr_ri1i3[k] + ptr_ri2i3[k];

#endif

       bestk = -1;
       for (k=0; k<8; k++)
       {
         t1 = a[k+8] * alpha;
         t2 = psc * a[k];
         if (asint(t1) > asint(t2))
         {
           psc = a[k+8];
           alpha = a[k];
           bestk = k;
         }
       }
          
       if (bestk >= 0)
       {
         ip0 = i0;
         ip1 = i1;
         ip2 = i2;
         ip3 = 6 + (bestk << 3);
         shif = shift;
//#define t32 4294967296.0f
//		 printf("  %3d %3d %3d %3d %d %f %f %f\n",ip0,ip1,ip2,ip3,shift,psc/thres/thres,alpha/thres,(float)psc/(float)alpha/thres);
       }
       
       time--;
       if(time <= 0) 
         goto end_search;     
     }
     ptr_ri2i3 += NB_POS;
	 }
skipthird:
   inc = (i2 - lasti2) >> 3;
   ptr_ri0i2 += inc;
   ptr_ri1i2 += inc;
   ptr_ri2i2 += inc;
	 
 // end of for i2 = 

     ptr_ri0i2 -= NB_POS;
     ptr_ri1i3 += NB_POS;
   } 
skipsecond:

 // end of for i1 =

   ptr_ri0i2 += NB_POS;
   ptr_ri0i3 += NB_POS;
 }
 // end of for i0 = 

end_search:

extra = time;
 
 ip[0] = ip0;
 ip[1] = ip1;
 ip[2] = ip2;
 ip[3] = ip3;
 *shifPtr = shif;

 return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\11to8.c ===
#include <stdio.h>
#include <memory.h>

#define BUF  220  // input buffer size for test main

#define OUT2(o,i,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13) \
  t = ( (int)in[i]*t0 + (int)in[i+1]*t1 + \
    (int)in[i+2]*t2 + (int)in[i+3]*t3 + \
    (int)in[i+4]*t4 + (int)in[i+5]*t5 + \
    (int)in[i+6]*t6 + (int)in[i+7]*t7 + \
    (int)in[i+8]*t8 + (int)in[i+9]*t9 + \
    (int)in[i+8]*t10 + (int)in[i+9]*t11 + \
    (int)in[i+8]*t12 + (int)in[i+9]*t13 ) >> 10; \
  if (t < -32768) out[o] = -32768; else if (t > 32767) out[o]=32767; else out[o] = t;

//--------------------------------------------------------
void segment11to8(short *in, short *out)
{
  int t;
  
  OUT2(   0,   0,     7, -20,  12,  42,-140, 238,
    745, 238,-140,  42,  12, -20,   7,   0);
  OUT2(   1,   1,     4,  -4, -18,  62, -85,   0,
    654, 510, -99, -27,  49, -26,   3,   1);
  OUT2(   2,   2,     0,   6, -26,  38,   0,-126,
    422, 704,  70,-110,  61, -10,  -9,   5);
  OUT2(   3,   4,     6, -15,   0,  55,-129, 150,
    734, 330,-140,  24,  25, -24,   7,   0);
  OUT2(   4,   5,     2,   0, -24,  58, -56, -57,
    589, 589, -57, -56,  58, -24,   0,   2);
  OUT2(   5,   7,     7, -24,  25,  24,-140, 330,
    734, 150,-129,  55,   0, -15,   6,   0);
  OUT2(   6,   8,     5,  -9, -10,  61,-110,  70,
    704, 422,-126,   0,  38, -26,   6,   0);
  OUT2(   7,   9,     1,   3, -26,  49, -27, -99,
    510, 654,   0, -85,  62, -18,  -4,   4);
}
//--------------------------------------------------------
void convert11to8(short *in, short *out, short *prev, int len)
{
/*
  Convert a buffer from 11KHz to 8KHz.

  Note: len is number of shorts in input buffer, which MUST
  be a multiple of 11 and at least 44.

  How the overhang works:  The filter kernel for 1 section of
  11 input samples requires KERNEL (=25) samples of the input.  So we use 14
  samples of overhang from the previous frame, which means the
  beginning of this frame looks like:

    ppppppppppp ppp01234567 89abcdefghi 19.... 30.... / 41 42 43
    X           X           x           x

  So we first have to do two special segments (the ones starting
  at X) then we do the rest (the x's) in a loop.  For the example
  length=44 shown above, we'll do up & including 44-25=19, stopping on the
  last x shown.  Then we save 30-43 in the overhang buffer so that
  30 is the first group done on the next frame.
*/

#define OVERHANG2 14
#define KERNEL2   25

  int i,k;
  short tmp[KERNEL2+11];
  
// Convert the first two segments, where segment= 11 samples of input

  memcpy(tmp,prev,sizeof(short)*OVERHANG2);
  memcpy(tmp+OVERHANG2,in,sizeof(short)*(KERNEL2+11-OVERHANG2));

  segment11to8(tmp,out);
  segment11to8(tmp+11,out+8);

// Loop through the remaining segments

  k = 16;
  for (i=22-OVERHANG2; i<=len-KERNEL2; i+=11)
  {
    segment11to8(in+i,out+k);
    k += 8;
  }

// Save OVERHANG2 samples for next time

  memcpy(prev,in+len-OVERHANG2,sizeof(short)*OVERHANG2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\8to11.c ===
#include <stdio.h>
#include <memory.h>

#define BUF  240  // input buffer size for test main

#define OUTPUT(o,i,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16) \
  t = ( (int)in[i]*t0 + (int)in[i+1]*t1 + \
    (int)in[i+2]*t2 + (int)in[i+3]*t3 + \
    (int)in[i+4]*t4 + (int)in[i+5]*t5 + \
    (int)in[i+6]*t6 + (int)in[i+7]*t7 + \
    (int)in[i+8]*t8 + (int)in[i+9]*t9 + \
    (int)in[i+10]*t10 + (int)in[i+11]*t11 + \
    (int)in[i+12]*t12 + (int)in[i+13]*t13 + \
    (int)in[i+14]*t14 + (int)in[i+15]*t15 + \
    (int)in[i+16]*t16 ) >> 10; \
  if (t < -32768) out[o] = -32768; else if (t > 32767) out[o]=32767; else out[o] = t;

//--------------------------------------------------------
void segment8to11(short *in, short *out)
{
  int t;
  
  OUTPUT(  0,  0,     0,   0,   0,   0,   0,   0,   0,   0,1024,   0,   0,   0,   0,   0,   0,   0,   0);
  OUTPUT(  1,  1,    -5,  11, -20,  32, -49,  77,-134, 335, 903,-187,  97, -60,  39, -24,  15,  -8,   3);
  OUTPUT(  2,  1,     2,  -9,  17, -29,  47, -73, 116,-213, 708, 589,-199, 111, -70,  45, -28,  16,  -8);
  OUTPUT(  3,  2,     2,  -6,  11, -18,  29, -45,  73,-145, 969, 213, -91,  53, -34,  22, -13,   7,  -3);
  OUTPUT(  4,  3,    -2,   4,  -7,  11, -17,  26, -45,  99,1010, -82,  40, -24,  16, -10,   6,  -3,   1);
  OUTPUT(  5,  4,    -7,  14, -25,  40, -61,  97,-172, 463, 814,-210, 112, -69,  45, -28,  17,  -8,   3);
  OUTPUT(  6,  4,     3,  -8,  17, -28,  45, -69, 112,-210, 814, 463,-172,  97, -61,  40, -25,  14,  -7);
  OUTPUT(  7,  5,     1,  -3,   6, -10,  16, -24,  40, -82,1010,  99, -45,  26, -17,  11,  -7,   4,  -2);
  OUTPUT(  8,  6,    -3,   7, -13,  22, -34,  53, -91, 213, 969,-145,  73, -45,  29, -18,  11,  -6,   2);
  OUTPUT(  9,  7,    -8,  16, -28,  45, -70, 111,-199, 589, 708,-213, 116, -73,  47, -29,  17,  -9,   2);
  OUTPUT( 10,  7,     3,  -8,  15, -24,  39, -60,  97,-187, 903, 335,-134,  77, -49,  32, -20,  11,  -5);

/* original
  out[0] = in[4];
  OUTPUT(1,  0,  3, -20,  52,-116, 327, 899,-174,  75, -32,   9);
  OUTPUT(2,  1,  9, -36,  85,-192, 701, 581,-178,  79, -32,   7);
  OUTPUT(3,  2,  8, -25,  58,-136, 968, 206, -77,  35, -13,   1);
  OUTPUT(4,  2,  0,  -6,  17, -37,  96,1010, -78,  32, -14,   5);
  OUTPUT(5,  3,  5, -27,  68,-151, 454, 809,-192,  84, -36,  10);
  OUTPUT(6,  4, 10, -36,  84,-192, 809, 454,-151,  68, -27,   5);
  OUTPUT(7,  5,  5, -14,  32, -78,1010,  96, -37,  17,  -6,   0);
  OUTPUT(8,  5,  1, -13,  35, -77, 206, 968,-136,  58, -25,   8);
  OUTPUT(9,  6,  7, -32,  79,-178, 581, 701,-192,  85, -36,   9);
  OUTPUT(10, 7,  9, -32,  75,-174, 899, 327,-116,  52, -20,   3);
*/
/*  From MD
  OUTPUT( 1, 0, 10, -16,  26, -44,  98,1000, -81,  39, -24,  15,);
  OUTPUT( 2, 0, 21, -32,  51, -88, 208, 951,-142,  71, -43,  28,);
  OUTPUT( 3, 0, 30, -47,  74,-130, 326, 879,-182,  94, -57,  37,);
  OUTPUT( 4, 0, 37, -58,  93,-165, 448, 788,-202, 107, -66,  42,);
  OUTPUT( 5, 0, 42, -66, 106,-191, 568, 683,-205, 111, -69,  44,);
  OUTPUT( 6, 0, 44, -69, 111,-205, 683, 568,-191, 106, -66,  42,);
  OUTPUT( 7, 0, 42, -66, 107,-202, 788, 448,-165,  93, -58,  37,);
  OUTPUT( 8, 0, 37, -57,  94,-182, 879, 326,-130,  74, -47,  30,);
  OUTPUT( 9, 0, 28, -43,  71,-142, 951, 208, -88,  51, -32,  21,);
  OUTPUT(10, 0, 15, -24,  39, -81,1000,  98, -44,  26, -16,  10,);
*/
}
//--------------------------------------------------------
void convert8to11(short *in, short *out, short *prev, int len)
{
/*
  Convert a buffer from 8KHz to 11KHz.

  Note: len is number of shorts in input buffer, which MUST
  be a multiple of 8 and at least 32.

  How the overhang works:  The filter kernel for 1 section of
  8 samples requires KERNEL (=17) samples of the input.  So we use 16
  samples of overhang from the previous frame, which means the
  beginning of this frame looks like:

    pppppppp pppppppp 01234567 89abcdef 16...... 24......
    X        X        x        x

  So we first have to do two special segments (the ones starting
  at X) then we do the rest (the x's) in a loop.  For the example
  length=32 shown above, we'll do up to 32-24=8, stopping on the
  last x shown.  Then we save 16-31 in the overhang buffer so that
  16 is the first group done on the next frame.
*/

#define OVERHANG 16
#define KERNEL   24

  int i,k;
  short tmp[KERNEL+8];
  
// Convert the first two segments, where segment= 8 samples of input

  memcpy(tmp,prev,sizeof(short)*OVERHANG);
  memcpy(tmp+OVERHANG,in,sizeof(short)*(KERNEL+8-OVERHANG));

  segment8to11(tmp,out);
  segment8to11(tmp+8,out+11);

// Loop through the remaining segments

  k = 22;
  for (i=16-OVERHANG; i<=len-KERNEL; i+=8)
  {
    segment8to11(in+i,out+k);
    k += 11;
  }

// Save overhang samples for next time

  memcpy(prev,in+len-OVERHANG,sizeof(short)*OVERHANG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\cb63.c ===
//cb63.c - 6.3 rate codebook code
#include "opt.h"

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "util_lbc.h"
#include "exc_lbc.h"
#include "timer.h"
#include "mmxutil.h"

//-------------------------------------------------------
void  Gen_Trn(float *Dst, float *Src, int Olp)
{
  int  i;

  int Tmp0;
  float  Tmp[SubFrLen];

  Tmp0 = Olp;

  for (i=0; i < SubFrLen; i++)
  {
    Tmp[i] = Src[i];
    Dst[i] = Src[i];
  }

  while (Tmp0 < SubFrLen)
  {
    for (i=Tmp0; i < SubFrLen; i++)
      Dst[i] += Tmp[i-Tmp0];

    Tmp0 += Olp;
  }
}

//------------------------------------------------------------------------
int Find_L(float *OccPos, float *ImrCorr, float *WrkBlk, float Pamp, int k)
{
#if FT_FINDL

//====== New version using FT trick that removes OccPos test ======

#if FIND_L_OPT

  int best;
  float max = -32768.0f;
  float tmp0,tmp1,tmp2,tmp3,tmp4;

// Simply interleave 5 copies of the inner loop.  Since we step
// by 2, this means we do the 60 samples in chunks of 10.

ASM
{
  mov edi,WrkBlk;
  mov edx,ImrCorr;
  mov ecx,k;

loop1:
  fld  DP[edx+4*ecx+4*0];
  fmul Pamp;
  fld  DP[edx+4*ecx+4*2];
  fmul Pamp;
  fld  DP[edx+4*ecx+4*4];
  fmul Pamp;
  fld  DP[edx+4*ecx+4*6];
  fmul Pamp;
  fld  DP[edx+4*ecx+4*8];// 4 3 2 1 0
  fmul Pamp;

  fxch ST(4);            // 0 3 2 1 4
  fsubr DP[edi+4*ecx+4*0];
  fxch ST(3);            // 1 3 2 0 4
  fsubr DP[edi+4*ecx+4*2];
  fxch ST(2);            // 2 3 1 0 4
  fsubr DP[edi+4*ecx+4*4];
  fxch ST(1);            // 3 2 1 0 4
  fsubr DP[edi+4*ecx+4*6];
  fxch ST(4);            // 4 2 1 0 3
  fsubr DP[edi+4*ecx+4*8];

  fxch ST(3);            // 0 2 1 4 3
  fst DP[edi+4*ecx+4*0];
  fxch ST(2);            // 1 2 0 4 3
  fst DP[edi+4*ecx+4*2];
  fxch ST(1);            // 2 1 0 4 3
  fst DP[edi+4*ecx+4*4];
  fxch ST(4);            // 3 1 0 4 2
  fst DP[edi+4*ecx+4*6];
  fxch ST(3);            // 4 1 0 3 2
  fst DP[edi+4*ecx+4*8];

  fxch ST(2);            // 0 1 4 3 2
  fabs;
  fxch ST(1);            // 1 0 4 3 2
  fabs;
  fxch ST(4);            // 2 0 4 3 1
  fabs;
  fxch ST(3);            // 3 0 4 2 1
  fabs;
  fxch ST(2);            // 4 0 3 2 1
  fabs;

  fxch ST(1);            // 0 4 3 2 1
  fstp tmp0;             // 4 3 2 1
  fxch ST(3);            // 1 3 2 4
  fstp tmp1;             // 3 2 4
  fxch ST(1);            // 2 3 4
  fstp tmp2;
  fstp tmp3;
  fstp tmp4;

  mov eax,tmp0;
   mov ebx,max;
  cmp eax,ebx;
   jle skip0;
  mov max,eax;
   mov best,ecx;
skip0:

  mov eax,tmp1;
   mov ebx,max;
  cmp eax,ebx;
   jle skip1;
  lea esi,[ecx+2];
  mov max,eax;
   mov best,esi;
skip1:

  mov eax,tmp2;
   mov ebx,max;
  cmp eax,ebx;
   jle skip2;
  lea esi,[ecx+4];
  mov max,eax;
   mov best,esi;
skip2:

  mov eax,tmp3;
   mov ebx,max;
  cmp eax,ebx;
   jle skip3;
  lea esi,[ecx+6];
  mov max,eax;
   mov best,esi;
skip3:

  mov eax,tmp4;
   mov ebx,max;
  cmp eax,ebx;
   jle skip4;
  lea esi,[ecx+8];
  mov max,eax;
   mov best,esi;
skip4:

  add ecx,10;
  cmp ecx,SubFrLen;
   jl loop1;
}
#else

  int best;
  float max = -32768.0f,tmp;
  
  while (k < SubFrLen)
  {
    WrkBlk[k] = WrkBlk[k] - Pamp*ImrCorr[k];

    tmp = (float) fabs(WrkBlk[k]);

//    printf("k %2d  tmp %10.2f  max %10.2f\n",k,tmp,max);
    if (asint(tmp) > asint(max))
    {
      max = tmp;
      best = k;
    }
    k += Sgrid;
  }
#endif

#else
//==================================================================
// Old version of Find_L

  int best;
  float max = -32768.0f,tmp;
  
#if FIND_L_OPT

// Because of the (if OccPos[k]) clause, this code is difficult
// to pipeline.  We could do a complicated pipeline job, but that
// would require computing most of WrkBlk[k] = WrkBlk[k] - Pamp*ImrCorr[k]
// whether or not OccPos[k] was 0.  Alternatively, we can just do
// one iteration at a time, in which case we can avoid more of that computation
// when OccPos[k] is not 0, but we pay a penalty in that computing it once
// is slower due to stalls.  Since there isn't much difference between these
// two approaches, we choose the second one since the code is so much
// simpler.  Loop control is only 2 clocks, so we don't even bother to unroll.

ASM
{
  mov esi,OccPos;
  mov edi,WrkBlk;
  mov edx,ImrCorr;
  mov ecx,k;

loop1:
  fld  DP[edx+4*ecx];    // start this here so fsubr below doesn't stall
  fmul Pamp;

  mov eax,DP[esi+4*ecx];
  test eax,07fffffffh;
  jne next1;             // but if this is taken we have to pop FP stack once

  fsubr DP[edi+4*ecx];
  fld ST(0);
  fabs;
  fstp tmp;              // save store of non-absolute-value for later

  mov eax,tmp;
   mov ebx,max;
  cmp eax,ebx;
   jle skip1;

  mov max,eax;
   mov best,ecx;

skip1:
  fstp DP[edi+4*ecx];    // store new WrkBlk value

  add ecx,2;
  cmp ecx,SubFrLen;
  jl loop1;
  jmp endit;

next1:
  faddp ST(0),ST;       // get rid of value on top of stack
  add ecx,2;
  cmp ecx,SubFrLen;
  jl loop1;

endit:
}

#else
  
  while (k < SubFrLen)
  {
    if (OccPos[k] == 0.0f)
    {
      WrkBlk[k] = WrkBlk[k] - Pamp*ImrCorr[k];

      tmp = (float) fabs(WrkBlk[k]);
      if (asint(tmp) > asint(max))
      {
        max = tmp;
        best = k;
      }
    }
    k += Sgrid;
  }

#endif
  
#endif

//  printf("best = %d\n",best);
//  printaff("WrkBlk",WrkBlk,60);

  return(best);
}
//------------------------------------------------------------------------
void  Find_Best(BESTDEF *Best, float *Tv, float *ImpResp,int Np,int Olp)
{


  int  i,j,k,l,n,ip;
  BESTDEF  Temp;
 
  int     MaxAmpId,flag=0;
  float   MaxAmp;
  float   Acc0,Acc1,Acc2,amp;

  float   Imr[SubFrLen];
  float   OccPos[SubFrLen];
  float   ImrCorr[2*SubFrLen];  // see comment below
  float   ErrBlk[SubFrLen];
  float   WrkBlk[SubFrLen];

// A trick is used here to simplify Find_L.  The original Find_L
// accessed ImrCorr[abs(k)].  In order to simplify this to ImrCorr[k],
// we double the size of the ImrCorr array, offset the elements with
// non-negative indices by SubFrLen, and then duplicate them in
// reverse order in the first half of the array.  This affects the
// way ImrCorr is addressed in this routine also.

//Update Impulse responce
   
  if (Olp < (SubFrLen-2)) 
  {
    Temp.UseTrn = 1;
    Gen_Trn(Imr, ImpResp, Olp);
  }
  else 
  {
    Temp.UseTrn = 0;
    for (i = 0; i < SubFrLen; i++)
      Imr[i] = ImpResp[i];
  }

//Search for the best sequence
 
  for (k=0; k < Sgrid; k++)
  {
    Temp.GridId = k;

//Find maximum amplitude
 
    Acc1 = 0.0f;
    for (i=k; i < SubFrLen; i +=Sgrid)
    { 
       OccPos[i] = Imr[i];	
       ImrCorr[SubFrLen+i] = DotProd(&Imr[i],Imr,SubFrLen-i) * 2.0f;
       Acc0 = (float) fabs(ErrBlk[i]=DotProd(&Tv[i],Imr,SubFrLen-i));
     
      if (Acc0 >= Acc1)
      {
        Acc1 = Acc0;
        Temp.Ploc[0] = i;
      }
    }
    for (i=1; i<SubFrLen; i++)
      ImrCorr[i] = ImrCorr[2*SubFrLen-i];
    
 //Quantize the maximum amplitude
  
    Acc2 = Acc1;
    Acc1 = 32767.0f;
    MaxAmpId = (NumOfGainLev - MlqSteps);

    for (i=MaxAmpId; i >= MlqSteps; i--)
    {
      Acc0 = (float) fabs(FcbkGainTable[i]*ImrCorr[SubFrLen] - Acc2);
      if (Acc0 < Acc1)
      {
        Acc1 = Acc0;
        MaxAmpId = i;
      }
    }
    MaxAmpId --;

    for (i=1; i <=2*MlqSteps; i++)
    {
      for (j=k; j < SubFrLen; j +=Sgrid)
      {
        WrkBlk[j] = ErrBlk[j];
        OccPos[j] = 0.0f;
      }
      Temp.MampId = MaxAmpId - MlqSteps + i;

      MaxAmp = FcbkGainTable[Temp.MampId];

      if (WrkBlk[Temp.Ploc[0]] >= 0.0f)
        Temp.Pamp[0] = MaxAmp;
      else
        Temp.Pamp[0] = -MaxAmp;

      OccPos[Temp.Ploc[0]] = 1.0f;

      for (j=1; j < Np; j++)
      {

#if FT_FINDL
        for (ip=0; ip<j; ip++)
          WrkBlk[Temp.Ploc[ip]] = Temp.Pamp[j-1]*
            ImrCorr[SubFrLen + Temp.Ploc[ip] - Temp.Ploc[j-1]];
#endif

        Temp.Ploc[j] = Find_L(OccPos,&ImrCorr[SubFrLen-Temp.Ploc[j-1]],WrkBlk,
          Temp.Pamp[j-1],k);
    
        if (WrkBlk[Temp.Ploc[j]] >= 0.0f)
          Temp.Pamp[j] = MaxAmp;
        else
          Temp.Pamp[j] = -MaxAmp;

        OccPos[Temp.Ploc[j]] = 1.0f;
      }

//Compute error vector
 
#if FT_FBFILT
// FT/CNET's trick #6, for reducing computation of filtered codeword
      
      for (j=0; j < SubFrLen; j++)
        OccPos[j] = 0.0f;

      for (j=0; j<Np; j++)
      {
// Extra sub-trick we added: since pulse positions are either all
// even or all odd, there's a natural two-ness in the inner loop,
// so we unroll two times.

        amp = Temp.Pamp[j];
        l = 0;
        for (n=Temp.Ploc[j]; n<SubFrLen-k; n+=2)
        {
          OccPos[n] += amp*Imr[l];
          OccPos[n+1] += amp*Imr[l+1];
          l += 2;
        }
        if (k)
          OccPos[n] += amp*Imr[l];
      }

#else
      for (j=0; j < SubFrLen; j++)
        OccPos[j] = 0.0f;

      for (j=0; j < Np; j++)
        OccPos[Temp.Ploc[j]] = Temp.Pamp[j];

      for (l=SubFrLen-1; l >= 0; l--)
        OccPos[l] = DotRev(OccPos,Imr,l+1); 
#endif
       
       
//Evaluate error
 
      Acc2 = DotProd(Tv,OccPos,SubFrLen) - DotProd(OccPos,OccPos,SubFrLen);

      if (Acc2 > (*Best).MaxErr)
      {
        flag = 1;
        (*Best).MaxErr = Acc2;
        (*Best).GridId = Temp.GridId;
        (*Best).MampId = Temp.MampId;
        (*Best).UseTrn = Temp.UseTrn;
        for (j = 0; j < Np; j++)
        {
          (*Best).Pamp[j] = Temp.Pamp[j];
          (*Best).Ploc[j] = Temp.Ploc[j];
        }
      }
    }
  }

#ifdef DEBUG
	if (flag == 0)
	{
		// this code is for tracking a rare condition in which
		// the above loop never get executed (Best is left uninitialized)
		DebugBreak();
	}

#endif


 return;
}

void  Fcbk_Pack(float *Dpnt, SFSDEF *Sfs, BESTDEF *Best, int Np)
{
  int  i,j;

//Code the amplitudes and positions
 
  j = MaxPulseNum - Np;

  (*Sfs).Pamp = 0;
  (*Sfs).Ppos = 0;

  for (i=0; i < SubFrLen/Sgrid; i++) 
  {

    if (Dpnt[(*Best).GridId + Sgrid*i] == 0)
      (*Sfs).Ppos = (*Sfs).Ppos + CombinatorialTable[j][i];
    else {
      (*Sfs).Pamp = (*Sfs).Pamp << 1;
      if (Dpnt[(*Best).GridId + Sgrid*i] < 0)
        (*Sfs).Pamp++;

      j++;

//Check for end 

      if (j == MaxPulseNum)
        break;
      }
    }

  (*Sfs).Mamp = (*Best).MampId;
  (*Sfs).Grid = (*Best).GridId;
  (*Sfs).Tran = (*Best).UseTrn;

  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\coder.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

extern void  Init_Coder(CODDEF *CodStat);
extern Flag  Coder(float *DataBuff, Word32 *Vout,CODDEF  *CodStat,
  int quality, int UseCpuId, int UseMMX);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\coder.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//
#include "timer.h"
#include "ctiming.h"
#include "opt.h"
#include <stdlib.h>
#include <stdio.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "coder.h"
#include "lpc.h"
#include "lsp.h"
#include "exc_lbc.h"
#include "util_lbc.h"
#include "memory.h"
#include "mmxutil.h"

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
#pragma message ("Current log encode timing computations handle 2057 frames max")
void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo, unsigned long dwFrameCount);
void OutputEncTimingDetail(FILE * pFile, ENC_TIMING_INFO * pEncTimingInfo);
#endif // } LOG_ENCODE_TIMINGS_ON

//
//   This file includes the coder main functions
//



//--------------------------------------------------
void  Init_Coder(CODDEF  *CodStat)
{
   int   i;

// Init prev Lsp to Dc  
   for (i=0; i < LpcOrder; i++)
      CodStat->PrevLsp[i] = LspDcTable[i];
	CodStat->p = 9;
	CodStat->q = 9;
	CodStat->VadAct = 1;

/* Initialize the taming procedure */
   for(i=0; i<SizErr; i++) CodStat->Err[i] = Err0;

}

//---------------------------------------------------
Flag  Coder(float *DataBuff, Word32 *Vout, CODDEF *CodStat,
 int quality, int UseCpuId, int UseMMX)
{
   int   i,j,flags  ;

   static int qual2flags[16] =
   {SC_DEF,SC_DEF,SC_DEF,SC_DEF,SC_DEF,SC_DEF,SC_DEF,SC_DEF,
    SC_DEF,SC_DEF,SC_DEF,SC_DEF,
    SC_LAG1 | SC_GAIN | SC_FINDB,
    SC_GAIN | SC_FINDB,
    SC_FINDB,
    0};

//   Local variables
    
   float   UnqLpc[SubFrames*LpcOrder];
   float   QntLpc[SubFrames*LpcOrder];
   float   PerLpc[2*SubFrames*LpcOrder];

   float   LspVect[LpcOrder];
   LINEDEF Line;
   PWDEF   Pw[SubFrames];

   float   ImpResp[SubFrLen];
   float   Dpnt[PitchMax+Frame];
   float   *dptr;
 
#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	unsigned long dwStartLow;
	unsigned long dwStartHigh;
	unsigned long dwElapsed;
	unsigned long dwBefore;
	unsigned long dwEncode = 0;
	int bTimingThisFrame = 0;
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	unsigned long dwRem_Dc = 0;
	unsigned long dwComp_Lpc = 0;
	unsigned long dwAtoLsp = 0;
	unsigned long dwLsp_Qnt = 0;
	unsigned long dwLsp_Inq = 0;
	unsigned long dwLsp_Int = 0;
	unsigned long dwMem_Shift = 0;
	unsigned long dwWght_Lpc = 0;
	unsigned long dwError_Wght = 0;
	unsigned long dwFew_Lps_In_Coder = 0;
	unsigned long dwFilt_Pw = 0;
	unsigned long dwComp_Ir = 0;
	unsigned long dwSub_Ring = 0;
	unsigned long dwFind_Acbk = 0;
	unsigned long dwFind_Fcbk = 0;
	unsigned long dwDecode_Acbk = 0;
	unsigned long dwReconstr_Excit = 0;
	unsigned long dwUpd_Ring = 0;
	unsigned long dwLine_Pack = 0;
	unsigned long dwComp_IrTemp = 0;
	unsigned long dwSub_RingTemp = 0;
	unsigned long dwFind_AcbkTemp = 0;
	unsigned long dwFind_FcbkTemp = 0;
	unsigned long dwDecode_AcbkTemp = 0;
	unsigned long dwReconstr_ExcitTemp = 0;
	unsigned long dwUpd_RingTemp = 0;
#endif // } DETAILED_ENCODE_TIMINGS_ON
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO * pEncTimingInfo = NULL;
#endif // } LOG_ENCODE_TIMINGS_ON

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	TIMER_START(bTimingThisFrame,dwStartLow,dwStartHigh);
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (CodStat->dwStatFrameCount < ENC_TIMING_INFO_FRAME_COUNT)
	{
		CodStat->dwStartLow = dwStartLow;
		CodStat->dwStartHigh = dwStartHigh;
	}
	CodStat->bTimingThisFrame = bTimingThisFrame;
#endif // } LOG_ENCODE_TIMINGS_ON

	if (quality < 0 || quality > 15) quality = 0;
		flags = qual2flags[quality];

	// If UseCpuId is set, determine whether to use MMX based on the
	// actual hardware CPUID.  Otherwise, just use the passed-in parameter.
#if COMPILE_MMX
	if (UseCpuId)
		UseMMX = IsMMX();
#else
	UseMMX = UseCpuId = FALSE;
#endif //COMPILE_MMX


	//Coder Start
	Line.Crc = 0;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Rem_Dc(DataBuff, CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwRem_Dc);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Compute the Unquantized Lpc set for whole frame
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if COMPILE_MMX
	if (UseMMX)
		Comp_LpcInt(UnqLpc, CodStat->PrevDat, DataBuff, CodStat);
	else
#endif
	Comp_Lpc(UnqLpc, CodStat->PrevDat, DataBuff, CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwComp_Lpc);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Convert to Lsp
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	AtoLsp(LspVect, &UnqLpc[LpcOrder*(SubFrames-1)], CodStat->PrevLsp);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwAtoLsp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// VQ Lsp vector
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Line.LspId = Lsp_Qnt(LspVect, CodStat->PrevLsp, UseMMX);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Qnt);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Inverse quantization of the LSP 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Lsp_Inq(LspVect, CodStat->PrevLsp, Line.LspId, Line.Crc);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Inq);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Interpolate the Lsp vectors
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Lsp_Int(QntLpc, LspVect, CodStat->PrevLsp);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Int);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Mem_Shift(CodStat->PrevDat, DataBuff);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwMem_Shift);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Compute Percetual filter Lpc coefficeints 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Wght_Lpc(PerLpc, UnqLpc);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwWght_Lpc);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Apply the perceptual weighting filter 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Error_Wght(DataBuff, PerLpc,CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwError_Wght);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Compute Open loop pitch estimates
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Construct the buffer

	memcpy(Dpnt,CodStat->PrevWgt,4*PitchMax);
	memcpy(&Dpnt[PitchMax],DataBuff,4*Frame);
	/*
	for (i=0; i < PitchMax;i++)
		Dpnt[i] = CodStat->PrevWgt[i];
	for (i=0;i < Frame;i++)
		Dpnt[PitchMax+i] = DataBuff[i];
	*/

	j = PitchMax;
	for (i=0; i < SubFrames/2; i++) 
	{
#if COMPILE_MMX
		if (UseMMX)
			Line.Olp[i] = Estim_Int(Dpnt, j);
		else
#endif
			Line.Olp[i] = Estim_Pitch(Dpnt, j);
		j += 2*SubFrLen;
	}

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFew_Lps_In_Coder);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Compute the Hmw 
	j = PitchMax;
	for (i=0; i < SubFrames; i++) 
	{
		Pw[i] = Comp_Pw(Dpnt, j, Line.Olp[i>>1]);
		j += SubFrLen;
	}

	// Reload the buffer 
	for (i=0; i < PitchMax; i++)
		Dpnt[i] = CodStat->PrevWgt[i];
	for (i=0; i < Frame; i++)
		Dpnt[PitchMax+i] = DataBuff[i];

	// Save PrevWgt
	for (i=0; i < PitchMax; i++)
		CodStat->PrevWgt[i] = Dpnt[Frame+i];

	// Apply the Harmonic filter
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON
	j = 0;
	for (i=0; i < SubFrames; i++) 
	{
		Filt_Pw(DataBuff, Dpnt, j , Pw[i]);
		j += SubFrLen;
	}
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFilt_Pw);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Start the sub frame processing loop
	dptr = DataBuff;

	for (i=0; i < SubFrames; i++) 
	{
		// Compute full impulse responce
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Comp_Ir(ImpResp, &QntLpc[i*LpcOrder], &PerLpc[i*2*LpcOrder], Pw[i]);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwComp_IrTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Subtruct the ringing of previos sub-frame
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Sub_Ring(dptr, &QntLpc[i*LpcOrder], &PerLpc[i*2*LpcOrder],
				CodStat->PrevErr, Pw[i], CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwSub_RingTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Compute adaptive code book contribution
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if COMPILE_MMX
		if(UseMMX)
			Find_AcbkInt(dptr, ImpResp, CodStat->PrevExc, &Line,i, CodStat->WrkRate, flags, CodStat);
		else
#endif
			Find_Acbk(dptr, ImpResp, CodStat->PrevExc, &Line,i, CodStat->WrkRate, flags, CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFind_AcbkTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Compute fixed code book contribution
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Find_Fcbk(dptr, ImpResp, &Line, i, CodStat->WrkRate, flags, UseMMX);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFind_FcbkTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Reconstruct the excitation
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Decod_Acbk(ImpResp, CodStat->PrevExc, Line.Olp[i>>1],
					Line.Sfs[i].AcLg, Line.Sfs[i].AcGn, CodStat->WrkRate);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwDecode_AcbkTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		for (j=SubFrLen; j < PitchMax; j++)
			CodStat->PrevExc[j-SubFrLen] = CodStat->PrevExc[j];

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		for (j=0; j < SubFrLen; j++) 
		{
			dptr[j] = dptr[j]*2.0f+ImpResp[j];
			CodStat->PrevExc[PitchMax-SubFrLen+j] = dptr[j];
			/* Clip the new samples */
#if 1 //do clipping
			//clip to +/- 32767.0 doing abs & compare with integer unit
			//if clipping is needed shift sign bit to use as lookup table index
#define FLTCLIP(x) \
			{\
				const float T[2] = {32767.0f, -32767.0f};\
				if ((asint(x) & 0x7fffffff) > asint(T[0]))\
				x = T[((unsigned)asint(x)) >> 31];\
			}

			FLTCLIP(CodStat->PrevExc[PitchMax-SubFrLen+j]);
#endif //optclip
		}

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwReconstr_ExcitTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		/* Update exc_err */
		Update_Err(Line.Olp[i>>1], Line.Sfs[i].AcLg, Line.Sfs[i].AcGn, CodStat);

		// Update the ringing delays 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Upd_Ring(dptr, &QntLpc[i*LpcOrder], &PerLpc[i*2*LpcOrder],
					CodStat->PrevErr, CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwUpd_RingTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		dptr += SubFrLen;

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		// Sum stats
		dwComp_Ir += dwComp_IrTemp; dwComp_IrTemp = 0;
		dwSub_Ring += dwSub_RingTemp; dwSub_RingTemp = 0;
		dwFind_Acbk += dwFind_AcbkTemp; dwFind_AcbkTemp = 0;
		dwFind_Fcbk += dwFind_FcbkTemp; dwFind_FcbkTemp = 0;
		dwDecode_Acbk += dwDecode_AcbkTemp; dwDecode_AcbkTemp = 0;
		dwReconstr_Excit += dwReconstr_ExcitTemp; dwReconstr_ExcitTemp = 0;
		dwUpd_Ring += dwUpd_RingTemp; dwUpd_RingTemp = 0;
#endif // } DETAILED_ENCODE_TIMINGS_ON
	}

	// Pack the Line structure
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Line_Pack(&Line, Vout,&(CodStat->VadAct),CodStat->WrkRate);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLine_Pack);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	TIMER_STOP(bTimingThisFrame,dwStartLow,dwStartHigh,dwEncode);
#endif // } ENCODE_TIMINGS_ON

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (bTimingThisFrame && (CodStat->dwStatFrameCount < ENC_TIMING_INFO_FRAME_COUNT))
	{
		pEncTimingInfo = &CodStat->EncTimingInfo[CodStat->dwStatFrameCount];
		pEncTimingInfo->dwEncode			= dwEncode;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		pEncTimingInfo->dwRem_Dc			= dwRem_Dc;
		pEncTimingInfo->dwComp_Lpc			= dwComp_Lpc;
		pEncTimingInfo->dwAtoLsp			= dwAtoLsp;
		pEncTimingInfo->dwLsp_Qnt			= dwLsp_Qnt;
		pEncTimingInfo->dwLsp_Inq			= dwLsp_Inq;
		pEncTimingInfo->dwLsp_Int			= dwLsp_Int;
		pEncTimingInfo->dwMem_Shift			= dwMem_Shift;
		pEncTimingInfo->dwWght_Lpc			= dwWght_Lpc;
		pEncTimingInfo->dwError_Wght		= dwError_Wght;
		pEncTimingInfo->dwFew_Lps_In_Coder	= dwFew_Lps_In_Coder;
		pEncTimingInfo->dwFilt_Pw			= dwFilt_Pw;
		pEncTimingInfo->dwComp_Ir			= dwComp_Ir;
		pEncTimingInfo->dwSub_Ring			= dwSub_Ring;
		pEncTimingInfo->dwFind_Acbk			= dwFind_Acbk;
		pEncTimingInfo->dwFind_Fcbk			= dwFind_Fcbk;
		pEncTimingInfo->dwDecode_Acbk		= dwDecode_Acbk;
		pEncTimingInfo->dwReconstr_Excit	= dwReconstr_Excit;
		pEncTimingInfo->dwUpd_Ring			= dwUpd_Ring;
		pEncTimingInfo->dwLine_Pack			= dwLine_Pack;
#endif // } DETAILED_ENCODE_TIMINGS_ON
		CodStat->dwStatFrameCount++;
	}
	else
	{
		_asm int 3;
	}
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

	return (Flag) True;
}


#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo, unsigned long dwFrameCount)
{
    FILE * pFile;
	ENC_TIMING_INFO * pTempEncTimingInfo;
	ENC_TIMING_INFO etiTemp;
	int i;
	int iCount;

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	    goto done;

#if 0
	// Too verbose !!!
	/* Output the detail information
	*/
	fprintf(pFile,"\nDetail Timing Information\n");
	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; i < dwFrameCount ; i++, pTempEncTimingInfo++ )
	{
		fprintf(pFile, "Frame %d Detail Timing Information\n", i);
		OutputEncTimingDetail(pFile, pTempEncTimingInfo);
	}
#endif

	/* Compute the total information
	*/
	memset(&etiTemp, 0, sizeof(ENC_TIMING_INFO));
	iCount = 0;

	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; i < dwFrameCount ; i++, pTempEncTimingInfo++ )
	{
		iCount++;
		etiTemp.dwEncode			+= pTempEncTimingInfo->dwEncode;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		etiTemp.dwRem_Dc			+= pTempEncTimingInfo->dwRem_Dc;
		etiTemp.dwComp_Lpc			+= pTempEncTimingInfo->dwComp_Lpc;
		etiTemp.dwAtoLsp			+= pTempEncTimingInfo->dwAtoLsp;
		etiTemp.dwLsp_Qnt			+= pTempEncTimingInfo->dwLsp_Qnt;
		etiTemp.dwLsp_Inq			+= pTempEncTimingInfo->dwLsp_Inq;
		etiTemp.dwLsp_Int			+= pTempEncTimingInfo->dwLsp_Int;
		etiTemp.dwMem_Shift			+= pTempEncTimingInfo->dwMem_Shift;
		etiTemp.dwWght_Lpc			+= pTempEncTimingInfo->dwWght_Lpc;
		etiTemp.dwError_Wght		+= pTempEncTimingInfo->dwError_Wght;
		etiTemp.dwFew_Lps_In_Coder	+= pTempEncTimingInfo->dwFew_Lps_In_Coder;
		etiTemp.dwFilt_Pw			+= pTempEncTimingInfo->dwFilt_Pw;
		etiTemp.dwComp_Ir			+= pTempEncTimingInfo->dwComp_Ir;
		etiTemp.dwSub_Ring			+= pTempEncTimingInfo->dwSub_Ring;
		etiTemp.dwFind_Acbk			+= pTempEncTimingInfo->dwFind_Acbk;
		etiTemp.dwFind_Fcbk			+= pTempEncTimingInfo->dwFind_Fcbk;
		etiTemp.dwDecode_Acbk		+= pTempEncTimingInfo->dwDecode_Acbk;
		etiTemp.dwReconstr_Excit	+= pTempEncTimingInfo->dwReconstr_Excit;
		etiTemp.dwUpd_Ring			+= pTempEncTimingInfo->dwUpd_Ring;
		etiTemp.dwLine_Pack			+= pTempEncTimingInfo->dwLine_Pack;
#endif // } DETAILED_ENCODE_TIMINGS_ON
	}

	if (iCount > 0) 
	{
		/* Output the total information
		*/
		fprintf(pFile,"Total for %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);

		/* Compute the average
		*/
		etiTemp.dwEncode			= (etiTemp.dwEncode + (iCount / 2)) / iCount;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		etiTemp.dwRem_Dc			= (etiTemp.dwRem_Dc + (iCount / 2)) / iCount;
		etiTemp.dwComp_Lpc			= (etiTemp.dwComp_Lpc + (iCount / 2)) / iCount;
		etiTemp.dwAtoLsp			= (etiTemp.dwAtoLsp + (iCount / 2)) / iCount;
		etiTemp.dwLsp_Qnt			= (etiTemp.dwLsp_Qnt + (iCount / 2)) / iCount;
		etiTemp.dwLsp_Inq			= (etiTemp.dwLsp_Inq + (iCount / 2)) / iCount;
		etiTemp.dwLsp_Int			= (etiTemp.dwLsp_Int + (iCount / 2)) / iCount;
		etiTemp.dwMem_Shift			= (etiTemp.dwMem_Shift + (iCount / 2)) / iCount;
		etiTemp.dwWght_Lpc			= (etiTemp.dwWght_Lpc + (iCount / 2)) / iCount;
		etiTemp.dwError_Wght		= (etiTemp.dwError_Wght + (iCount / 2)) / iCount;
		etiTemp.dwFew_Lps_In_Coder	= (etiTemp.dwFew_Lps_In_Coder + (iCount / 2)) / iCount;
		etiTemp.dwFilt_Pw			= (etiTemp.dwFilt_Pw + (iCount / 2)) / iCount;
		etiTemp.dwComp_Ir			= (etiTemp.dwComp_Ir + (iCount / 2)) / iCount;
		etiTemp.dwSub_Ring			= (etiTemp.dwSub_Ring + (iCount / 2)) / iCount;
		etiTemp.dwFind_Acbk			= (etiTemp.dwFind_Acbk + (iCount / 2)) / iCount;
		etiTemp.dwFind_Fcbk			= (etiTemp.dwFind_Fcbk + (iCount / 2)) / iCount;
		etiTemp.dwDecode_Acbk		= (etiTemp.dwDecode_Acbk + (iCount / 2)) / iCount;
		etiTemp.dwReconstr_Excit	= (etiTemp.dwReconstr_Excit + (iCount / 2)) / iCount;
		etiTemp.dwUpd_Ring			= (etiTemp.dwUpd_Ring + (iCount / 2)) / iCount;
		etiTemp.dwLine_Pack			= (etiTemp.dwLine_Pack + (iCount / 2)) / iCount;
#endif // } DETAILED_ENCODE_TIMINGS_ON

		/* Output the average information
		*/
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);
	}

	fclose(pFile);
done:

    return;
}

void OutputEncTimingDetail(FILE * pFile, ENC_TIMING_INFO * pEncTimingInfo)
{
	unsigned long dwOther;
	unsigned long dwRoundUp;
	unsigned long dwDivisor;

	fprintf(pFile, "\tEncode =     %10u (%d milliseconds at 166Mhz)\n", pEncTimingInfo->dwEncode,
			(pEncTimingInfo->dwEncode + 83000) / 166000);
	dwOther = pEncTimingInfo->dwEncode;
	
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	/* This is needed because of the integer truncation.
	 */
	dwDivisor = pEncTimingInfo->dwEncode / 100; // to yield a percent
	dwRoundUp = dwDivisor / 2;
	
	if (dwDivisor)
	{
		fprintf(pFile, "\tRem_Dc =           %10u (%2d%%)\n", pEncTimingInfo->dwRem_Dc, 
				(pEncTimingInfo->dwRem_Dc + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwRem_Dc;
									   
		fprintf(pFile, "\tComp_Lpc =         %10u (%2d%%)\n", pEncTimingInfo->dwComp_Lpc, 
				(pEncTimingInfo->dwComp_Lpc + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwComp_Lpc;
									   
		fprintf(pFile, "\tAtoLsp =           %10u (%2d%%)\n", pEncTimingInfo->dwAtoLsp, 
				(pEncTimingInfo->dwAtoLsp + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwAtoLsp;

		fprintf(pFile, "\tLsp_Qnt =          %10u (%2d%%)\n", pEncTimingInfo->dwLsp_Qnt, 
				(pEncTimingInfo->dwLsp_Qnt + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwLsp_Qnt;
									   
		fprintf(pFile, "\tLsp_Inq =          %10u (%2d%%)\n", pEncTimingInfo->dwLsp_Inq, 
				(pEncTimingInfo->dwLsp_Inq + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwLsp_Inq;
									   
		fprintf(pFile, "\tLsp_Int =          %10u (%2d%%)\n", pEncTimingInfo->dwLsp_Int, 
				(pEncTimingInfo->dwLsp_Int + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwLsp_Int;
									   
		fprintf(pFile, "\tMem_Shift =        %10u (%2d%%)\n", pEncTimingInfo->dwMem_Shift, 
				(pEncTimingInfo->dwMem_Shift + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwMem_Shift;
									   
		fprintf(pFile, "\tWght_Lpc =         %10u (%2d%%)\n", pEncTimingInfo->dwWght_Lpc, 
				(pEncTimingInfo->dwWght_Lpc + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwWght_Lpc;
									   
		fprintf(pFile, "\tError_Wght =       %10u (%2d%%)\n", pEncTimingInfo->dwError_Wght, 
				(pEncTimingInfo->dwError_Wght + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwError_Wght;
									   
		fprintf(pFile, "\tFew_Lps_In_Coder = %10u (%2d%%)\n", pEncTimingInfo->dwFew_Lps_In_Coder, 
				(pEncTimingInfo->dwFew_Lps_In_Coder + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwFew_Lps_In_Coder;
									   
		fprintf(pFile, "\tFilt_Pw =          %10u (%2d%%)\n", pEncTimingInfo->dwFilt_Pw, 
				(pEncTimingInfo->dwFilt_Pw + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwFilt_Pw;
									   
		fprintf(pFile, "\tComp_Ir =          %10u (%2d%%)\n", pEncTimingInfo->dwComp_Ir, 
				(pEncTimingInfo->dwComp_Ir + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwComp_Ir;
									   
		fprintf(pFile, "\tSub_Ring =         %10u (%2d%%)\n", pEncTimingInfo->dwSub_Ring, 
				(pEncTimingInfo->dwSub_Ring + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwSub_Ring;
									   
		fprintf(pFile, "\tFind_Acbk =        %10u (%2d%%)\n", pEncTimingInfo->dwFind_Acbk, 
				(pEncTimingInfo->dwFind_Acbk + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwFind_Acbk;
									   
		fprintf(pFile, "\tFind_Fcbk =        %10u (%2d%%)\n", pEncTimingInfo->dwFind_Fcbk, 
				(pEncTimingInfo->dwFind_Fcbk + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwFind_Fcbk;
									   
		fprintf(pFile, "\tDecode_Acbk =      %10u (%2d%%)\n", pEncTimingInfo->dwDecode_Acbk, 
				(pEncTimingInfo->dwDecode_Acbk + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwDecode_Acbk;
									   
		fprintf(pFile, "\tReconstr_Excit =   %10u (%2d%%)\n", pEncTimingInfo->dwReconstr_Excit, 
				(pEncTimingInfo->dwReconstr_Excit + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwReconstr_Excit;
									   
		fprintf(pFile, "\tUpd_Ring =         %10u (%2d%%)\n", pEncTimingInfo->dwUpd_Ring, 
				(pEncTimingInfo->dwUpd_Ring + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwUpd_Ring;
									   
		fprintf(pFile, "\tLine_Pack =        %10u (%2d%%)\n", pEncTimingInfo->dwLine_Pack, 
				(pEncTimingInfo->dwLine_Pack + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwLine_Pack;
									   
		fprintf(pFile, "\tOther =            %10u (%2d%%)\n", dwOther, 
				(dwOther + dwRoundUp) / dwDivisor);
	}
#endif // } DETAILED_ENCODE_TIMINGS_ON

}
#endif // { LOG_ENCODE_TIMINGS_ON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\cst_lbc.h ===
/*
**
** File:        "cst_lbc.h"
**
** Description:  This file contains global definition of the SG15
**    LBC Coder for 6.3/5.3 kbps.
**
*/

/*
  	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 3.01

    Original fixed-point code copyright (c) 1995,
    AudioCodes, DSP Group, France Telecom, Universite de Sherbrooke.
    All rights reserved.

    Floating-point code copyright (c) 1995,
    Intel Corporation and France Telecom (CNET).
    All rights reserved.
*/

/*
   This file contains global definition of the SG15
      LBR Coder for 6.4/5.3 kbps.
*/
#include "typedef.h"
#define  False 0
#define  True  1
//#if NOTMINI
#define  FALSE 0
#define  TRUE  1
//#endif

/* Definition of the working mode */
enum  Wmode { Both, Cod, Dec } ;

/* Coder rate */
//enum  Crate    { Silent, Rate53, Rate63, Lost } ;
/* Changed in V4.1 */
enum  Crate    { Rate63, Rate53, Silent, Lost } ;


/* Coder global constants */
#define  Frame       240
#define  LpcFrame    180
#define  SubFrames   4
#define  SubFrLen    (Frame/SubFrames)

#define  LpcOrder          10
#define  RidgeFact         10
#define  CosineTableSize   512
#define  PreCoef           -0.25f

#define  LspPrd0           12288
#define  LspPrd1           23552

#define  LspPred0          (12.0f/32.0f)
#define  LspPred1          (23.0f/32.0f)

#define  LspQntBands       3
#define  LspCbSize         256
#define  LspCbBits         8

#define  PitchMin          18
#define  PitchMax          (PitchMin+127) 
#define PwRange            3
#define  ClPitchOrd        5
#define  Pstep             1

#define NbFilt085           85
#define NbFilt170           170

#define  Sgrid             2
#define  MaxPulseNum       6
#define  MlqSteps     	   2
/* acelp constants */
#define SubFrLen2    (SubFrLen +4)
#define DIM_RR   416
#define NB_POS   8
#define STEP     8
#define MSIZE    64
#define threshold  0.5f
#define max_time   120

#define  NumOfGainLev      24

#define  ErrMaxNum         3

/* Taming constants */
#define NbFilt085_min       51
#define NbFilt170_min       93
#define SizErr              5
#define Err0                0.00000381464f
#define ThreshErr           128.0f

#define SRCSTATELEN         16   // sample rate conversion state length

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
/* Encoder Timing Data - per frame
*/
typedef struct {
	unsigned long dwEncode;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	unsigned long dwRem_Dc;
	unsigned long dwComp_Lpc;
	unsigned long dwAtoLsp;
	unsigned long dwLsp_Qnt;
	unsigned long dwLsp_Inq;
	unsigned long dwLsp_Int;
	unsigned long dwMem_Shift;
	unsigned long dwWght_Lpc;
	unsigned long dwError_Wght;
	unsigned long dwFew_Lps_In_Coder;
	unsigned long dwFilt_Pw;
	unsigned long dwComp_Ir;
	unsigned long dwSub_Ring;
	unsigned long dwFind_Acbk;
	unsigned long dwFind_Fcbk;
	unsigned long dwDecode_Acbk;
	unsigned long dwReconstr_Excit;
	unsigned long dwUpd_Ring;
	unsigned long dwLine_Pack;
#endif // } DETAILED_ENCODE_TIMINGS_ON
} ENC_TIMING_INFO;
// 2057 frames will allow us to store stats
// for all of our Geo08kHz16BitMonoPCM.wav
// test file...
#define ENC_TIMING_INFO_FRAME_COUNT 2057
#endif // } LOG_ENCODE_TIMINGS_ON

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
/* Encoder Timing Data - per frame
*/
typedef struct {
	unsigned long dwDecode;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	unsigned long dwLine_Unpk;
	unsigned long dwLsp_Inq;
	unsigned long dwLsp_Int;
	unsigned long dwVariousD;
	unsigned long dwFcbk_UnpkD;
	unsigned long dwDecod_AcbkD;
	unsigned long dwComp_Info;
	unsigned long dwRegen;
	unsigned long dwSynt;
#endif // } DETAILED_DECODE_TIMINGS_ON
} DEC_TIMING_INFO;
// 2057 frames will allow us to store stats
// for all of our Geo08kHz16BitMonoPCM.wav
// test file...
#define DEC_TIMING_INFO_FRAME_COUNT 2057
#endif // } LOG_DECODE_TIMINGS_ON

/*
   Used structures
*/
typedef  struct   {

  float   HpfZdl;
  float   HpfPdl;
   /* Lsp previous vector */
   float   PrevLsp[LpcOrder] ;

   /* All pitch operation buffers */
   float    PrevWgt[PitchMax] ;
   float    PrevErr[PitchMax] ;
   float    PrevExc[PitchMax] ;

   /* Requered memory for the delay */
   float   PrevDat[LpcFrame-SubFrLen] ;

   /* Used delay lines */
   float    WghtFirDl[2*LpcOrder];
   float    WghtIirDl[2*LpcOrder];
   float    RingFirDl[2*LpcOrder];
   float    RingIirDl[2*LpcOrder];

   /* For taming procedure */

   int  	SinDet;
   float    Err[SizErr];

   //These entries are not part of the ITU 723 std.
   int      p;
   int      q;

   int      srccount;              // sampling rate conversion count
   short    srcstate[SRCSTATELEN]; // sampling rate conversion state
  
   // Lsp previous vector 

   /* All pitch operation buffers */
   int VadAct;
   Flag UseHp;
   enum Crate WrkRate;
   int quality;

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO	EncTimingInfo[ENC_TIMING_INFO_FRAME_COUNT];
	unsigned long   dwStatFrameCount;
	int             bTimingThisFrame;
	unsigned long   dwStartLow;
	unsigned long   dwStartHigh;
#endif // } LOG_ENCODE_TIMINGS_ON

   } CODDEF  ;

 typedef  struct   {
   int     Ecount;
   float   InterGain;
   int     InterIndx;
   int     Rseed;
   
   // Lsp previous vector
   // Name changed to avoid confusion with encoder 
   //	previous LSPs 
   //float PrevLSP[LpcOrder];
   float   dPrevLsp[LpcOrder];

   /* All pitch operation buffers */
   // Name changed to avoid confusion with encoder 
   //	previous excitation
   //float PrevExc[PitchMax]; 
   float   dPrevExc[PitchMax] ;

   /* Used delay lines */
   float   SyntIirDl[2*LpcOrder] ;

   //These entries are not part of the ITU 723 std.
   int     dp;
   int     dq;

   int     srccount;              // sampling rate conversion count
   short   srcstate[SRCSTATELEN]; // sampling rate conversion state
   short   srcbuff[480];          // sampling rate conversion buffer
   int     i;

   int VadAct;
   Flag UsePf;
   enum Crate WrkRate;

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	DEC_TIMING_INFO	DecTimingInfo[DEC_TIMING_INFO_FRAME_COUNT];
	unsigned long   dwStatFrameCount;
	int             bTimingThisFrame;
	unsigned long   dwStartLow;
	unsigned long   dwStartHigh;
#endif // } LOG_DECODE_TIMINGS_ON

   } DECDEF  ;

typedef  struct   {
   int   AcLg;
   int   AcGn;
   int   Mamp;
   int   Grid;
   int   Tran;
   int   Pamp;
   Word32   Ppos;
   } SFSDEF;

typedef  struct   {
   int     Crc   ;
   Word32  LspId ;
   int     Olp[SubFrames/2] ;
   SFSDEF  Sfs[SubFrames] ;
   } LINEDEF ;

typedef  struct   {
   int   Indx;
   float Gain;
   } PWDEF;

typedef  struct {
   float    MaxErr   ;
   int      GridId   ;
   int      MampId   ;
   int      UseTrn   ;
   int      Ploc[MaxPulseNum] ;
   float    Pamp[MaxPulseNum] ;
   } BESTDEF ;





/* Prototype used for the ACELP codebook */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\ctiming.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*
 * ctiming.h
 *
 * DESCRIPTION:
 *		Common timing functions.  
 *
 *		I extracted this code from meantime.h in HQV's decode directory.
 */

// $Header:   S:\h26x\src\common\ctiming.h_v   1.2   26 Dec 1995 17:43:06   DBRUCKS  $
// $Log:   S:\h26x\src\common\ctiming.h_v  $
;// 
;//    Rev 1.2   26 Dec 1995 17:43:06   DBRUCKS
;// changed bTimerIsOn to bTimerIsActive
;// 
;//    Rev 1.1   26 Dec 1995 12:40:54   DBRUCKS
;// added higher level macros to simplify use
;// 
;//    Rev 1.0   20 Dec 1995 15:06:14   DBRUCKS
;// Initial revision.

#ifndef __CTIMING_H__
#define __CTIMING_H__

/* The following timing overhead numbers were generated by Tom Walsh
 * based on static variables for startlow, starthigh, and elapsed.
 * 
 * When timing sections of code with low clock numbers be careful to
 * minimize the timing overhead.  Store the sub totals to a stack variable
 * instead of to the instance via a pointer indirection and offset.
 */
#define P5TIMING_OVERHEAD 13
#define P6TIMING_OVERHEAD 33

/* Low Level Macros
 */
#define __RDTSC__ __asm { __asm __emit 0Fh __asm __emit 31h }

#define STARTCLOCK(startlow,starthigh) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm mov	startlow,	eax	\
		__asm mov	starthigh,	edx	\
	} \
}

#define STOPCLOCKP5(startlow,starthigh,elapsed) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm sub	eax,	startlow	\
		__asm sbb	edx,	starthigh	\
		__asm sub	eax,	P5TIMING_OVERHEAD		\
		__asm sbb	edx,	0		\
		__asm mov	elapsed,eax		\
	} \
}

#define STOPCLOCKP6(startlow,starthigh,elapsed) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm sub	eax,	startlow	\
		__asm sbb	edx,	starthigh	\
		__asm sub	eax,	P6TIMING_OVERHEAD		\
		__asm sbb	edx,	0		\
		__asm mov	elapsed,eax		\
	} \
}

/* High Level Macros
 *
 * Call TIMER_START and TIMER_STOP in the main function that you wish to time.
 * TIMER_BEFORE and TIMER_AFTER should be used inside of that main function.
 * Fo example:
 *
 *		TIMER_START
 *			TIMER_BEFORE
 *			TIMER_AFTER_P5
 *			TIMER_BEFORE
 *			TIMER_AFTER_P5
 *		TIMER_STOP
 * 
 * Variable Definitions
 *		DWORD dwStartLow;		 // temporary set in TIMER_START 
 *		DWORD dwStartHigh;		 // temporary set in TIMER_START
 *		DWORD dwElapsed;		 // temporary used in TIMER_AFTER_*
 *		DWORD dwBefore;			 // temporary used in TIMER_BEFORE and TIMER_AFTER_*
 *		DWORD dwResult;			 // result variable
 *		int   bTimerIsActive	 // boolean - true if timing this frame
 *
 * WARNING: TIMER_AFTER_P5 and TIMER_AFTER_P6 add to the result variable.
 */
#define	TIMER_START(bTimerIsActive,dwStartLow,dwStartHigh) \
{ \
	bTimerIsActive = 1; \
	STARTCLOCK(dwStartLow,dwStartHigh); \
}

#define TIMER_BEFORE(bTimerIsActive,dwStartLow,dwStartHigh,dwBefore) \
{ \
	if (bTimerIsActive)	\
	{	\
		STOPCLOCKP5(dwStartLow,dwStartHigh,dwBefore); \
	} \
}

#define TIMER_AFTER_P5(bTimerIsActive,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwResult) \
{ \
	if (bTimerIsActive)	\
	{ \
		STOPCLOCKP5(dwStartLow,dwStartHigh,dwElapsed); \
		dwResult += dwElapsed - dwBefore;	    \
	} \
}

#define TIMER_STOP(bTimerIsActive,dwStartLow,dwStartHigh,dwResult) \
{ \
	if (bTimerIsActive)	\
	{ \
		STOPCLOCKP5(dwStartLow,dwStartHigh,dwResult);	\
	} \
}

#endif /* __CTIMING_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "MSG7231"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef _WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support.
//      All code compiles to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef _WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef _WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
        DebugBreak();
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static CHAR     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
		DebugBreak();
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\decod.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//


extern void  Init_Decod(DECDEF *DecStat);

//Changed in v4.0f
extern Flag  Decod( float *DataBuff, Word32 *Vinp , Word16 Crc, DECDEF *DecStat);
//extern Flag  Decod( float *DataBuff, char *Vinp , Word16 Crc, DECDEF *DecStat);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\exc_lbc.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//


#include "opt.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "util_lbc.h"
#include "exc_lbc.h"
#include "timer.h"
#include "mmxutil.h"

// This file contains pitch and excitation related functions.
//------------------------------------------------------
#if COMPILE_MMX

int Estim_Int(float *Dpnt, int Start)
{
  int  i,k;

#define NCOR (PitchMax+1-PitchMin)   // = 128 (rounded up to mult of 4)
#define NTAPS (2*SubFrLen+12)        // = 132

  int Pr,Indx = PitchMin;
  float MaxE = 1.0f;
  float MaxC = 0.0f;
  float E,C2,E2,Diff;
  int corr[NCOR];

  typedef struct
  {
    short taps[4][NTAPS];                  //**  These two arrays need
    short temp[PitchMax-3+2*SubFrLen];     //**  to be 8-byte aligned
    double foo;
  } EstimStruct;

  EstimStruct est,*e;
  e = &est;

  ASM
  {
    mov eax,e;
    add e,7;
    and e,0fffffff8h;
    mov e,eax;
  }

// Convert just the necessary portion of Dpnt to 16-bit integers,
// store the result in 'temp'.  4 guard bits are needed since the
// correlations are length 120, which means 7 guard bits are needed.
// So we use 4 so that 4+4=8 guard bits are present in the product.

  FloatToShortScaled(&Dpnt[Start-PitchMax+3],e->temp,PitchMax-3+2*SubFrLen,4);

  MakeAligned4(&e->temp[PitchMax-3],e->taps[0],2*NTAPS);
  MakeAligned2(&e->temp[PitchMax-4],e->taps[1],2*NTAPS);
  MakeAligned0(&e->temp[PitchMax-5],e->taps[2],2*NTAPS);
  MakeAligned6(&e->temp[PitchMax-6],e->taps[3],2*NTAPS);

  for (i=0; i<4; i++)
  {
    for (k=0; k<i; k++)
      e->taps[i][k] = 0;
    for (k=NTAPS-12+i; k<NTAPS; k++)
      e->taps[i][k] = 0;
  }

// Compute cross-correlations, store in corr[] array

  CorrelateInt4(e->taps[0],e->temp,corr,NTAPS-12,NCOR>>2);
  for (i=1; i<4; i++)
    CorrelateInt4(e->taps[i],e->temp,&corr[i],NTAPS,NCOR>>2);


// Now do the actual pitch search.
  
  Pr = Start - PitchMin;
  k = PitchMax-PitchMin-3;
  E = DotProd(&Dpnt[Pr],&Dpnt[Pr],2*SubFrLen);  // first energy value

  for (i=0; i < (PitchMax-2-PitchMin); i++)
  {
// Update energy

    E = E - Dpnt[Pr+2*SubFrLen]*Dpnt[Pr+2*SubFrLen] + Dpnt[Pr]*Dpnt[Pr];

// Check for new maximum

    if (corr[k] > 0)
    {
      C2 = ((float)corr[k]) * ((float)corr[k]);
      E2 = C2*MaxE;
      Diff = (E2 - E*MaxC)*4.0f;
      if (asint(Diff) > asint(E2) || (Diff > 0.0f && ((i - Indx) < PitchMin)))
      {
        Indx = i;
        MaxE = E;
        MaxC = C2;
      }
    }
    Pr--;
    k--;
  }
  return(Indx+PitchMin);
}

#endif



//------------------------------------------------------
int Estim_Pitch(float *Dpnt, int Start)
{
  int  i;

  int Pr,Indx = PitchMin;
  float MaxE = 1.0f;
  float MaxC = 0.0f;
  float E,C,C2,E2,Diff;
  int *dptr,*eptr;

  dptr = (int *)&Diff;
  eptr = (int *)&E2;
  Pr = Start - PitchMin + 1;

// Init the energy estimate
  
  E = DotProd(&Dpnt[Pr],&Dpnt[Pr],2*SubFrLen);

// Main Open loop pitch search loop
  
  for (i=PitchMin; i <= PitchMax-3; i++)
  {
    Pr--;


// Update energy, compute cross

    C = DotProd(&Dpnt[Start],&Dpnt[Pr],2*SubFrLen);
    E = E - Dpnt[Pr+2*SubFrLen]*Dpnt[Pr+2*SubFrLen] + Dpnt[Pr]*Dpnt[Pr];
    C2 = C*C;

// Check for new maximum

    E2 = C2*MaxE;
    Diff = (E2 - E*MaxC)*4.0f;
    if (C > 0.0f && E > 0.0f &&
      (*dptr > *eptr || (Diff > 0.0f && ((i - Indx) < PitchMin))))
    {
      Indx = i;
      MaxE = E;
      MaxC = C2;
    }
  }
  return Indx;
}



//------------------------------------------------------
PWDEF Comp_Pw(float *Dpnt, int Start, int Olp)
{

  int  i,k;
  float Energy,C,E,C2,MaxE,MaxC2,MaxC,Gopt;
  PWDEF Pw;

// Compute target energy

  Energy = DotProd(&Dpnt[Start],&Dpnt[Start],SubFrLen);

// Find position with maximum C2/E value

  MaxE = 1.0f;
  MaxC = 0.0f;
  MaxC2 = 0.0f;
  Pw.Indx = -1;
  Pw.Gain = 0.0f;
  k = Start - (Olp-PwRange);
  E = DotProd(&Dpnt[k],&Dpnt[k],SubFrLen);
  
  for (i=0; i <= 2*PwRange; i++)
  {
    C = DotProd(&Dpnt[Start],&Dpnt[k],SubFrLen);

    if (E > 0.0f && C > 0.0f)
    {
      C2 = C*C;
      if (C2*MaxE > E*MaxC2)
      {
        Pw.Indx = i;
        MaxE = E;
        MaxC = C;
        MaxC2 = C2;
      }
    }
    k--;

    if (k < 0)
    {
      break;
    }

    E = E - Dpnt[k+SubFrLen]*Dpnt[k+SubFrLen] + Dpnt[k]*Dpnt[k];

  }

  if (Pw.Indx == -1)
  {
    Pw.Indx = Olp;
	return Pw;
  }

  Pw.Gain = 0.0f;
  if (MaxC2 > MaxE*Energy*0.375f)
  {
    if (MaxC > MaxE || MaxE == 0.0f)
      Gopt = 1.0f;
    else
      Gopt = (float) fabs(MaxC)/MaxE;

    Pw.Gain = 0.3125f*Gopt;
  }
  Pw.Indx = Olp - PwRange + Pw.Indx;
  return Pw;


}



//--------------------------------------------------------------
void  Filt_Pw(float *DataBuff, float *Dpnt, int Start, PWDEF Pw)
{
  int  i;

// Perform the harmonic weighting
  
  for (i=0; i < SubFrLen; i++)
    DataBuff[Start+i] = Dpnt[PitchMax+Start+i] -
                        Pw.Gain*Dpnt[PitchMax+Start-Pw.Indx+i];
}


//-----------------------------------------------------------------
void  Find_Fcbk(float *Dpnt, float *ImpResp, LINEDEF *Line, int Sfc, enum Crate WrkRate, int flags, int UseMMX)
{
  int  i;
  int  Srate,T0_acelp;
  float gain_T0;

  BESTDEF  Best = {0};

  switch(WrkRate)
  {
    case Rate63:
      Srate = Nb_puls[Sfc];
      Best.MaxErr = -99999999.9f;

      if (flags & SC_FINDB)
      {
        if ((*Line).Olp[Sfc>>1] < SubFrLen-2)
          Find_Best(&Best, Dpnt, ImpResp, Srate, (*Line).Olp[Sfc>>1]);
        else
          Find_Best(&Best, Dpnt, ImpResp, Srate, SubFrLen);
      }
      else
      {
        Find_Best(&Best, Dpnt, ImpResp, Srate, SubFrLen);
        if ((*Line).Olp[Sfc>>1] < SubFrLen-2)
          Find_Best(&Best, Dpnt, ImpResp, Srate, (*Line).Olp[Sfc>>1]);
      }

// Reconstruct the excitation
    
      for (i=0; i <  SubFrLen; i++)
        Dpnt[i] = 0.0f;

      for (i=0; i < Srate; i++)
        Dpnt[Best.Ploc[i]] = Best.Pamp[i];

// Code the excitation
    
      Fcbk_Pack(Dpnt, &((*Line).Sfs[Sfc]), &Best, Srate);

      if (Best.UseTrn == 1)
        Gen_Trn(Dpnt, Dpnt, (*Line).Olp[Sfc>>1]);
      break;
	 
    case Rate53:

      T0_acelp = search_T0 ((*Line).Olp[Sfc>>1]-1+(*Line).Sfs[Sfc].AcLg,
        (*Line).Sfs[Sfc].AcGn, &gain_T0);

      
#if COMPILE_MMX
      if (UseMMX)
	  {
		  (*Line).Sfs[Sfc].Ppos = ACELP_LBC_code_int(Dpnt, ImpResp, T0_acelp, Dpnt,
					&(*Line).Sfs[Sfc].Mamp,  &(*Line).Sfs[Sfc].Grid,
					&(*Line).Sfs[Sfc].Pamp, gain_T0, flags);
	  }
      else
#endif //COMPILE_MMX
	  {
		  (*Line).Sfs[Sfc].Ppos = ACELP_LBC_code(Dpnt, ImpResp, T0_acelp, Dpnt,
					&(*Line).Sfs[Sfc].Mamp,  &(*Line).Sfs[Sfc].Grid,
					&(*Line).Sfs[Sfc].Pamp, gain_T0, flags);

	  }
      (*Line).Sfs[Sfc].Tran = 0;
      break;
  }

  return;
}


//---------------------------------------------------------
void  Fcbk_Unpk(float *Tv, SFSDEF Sfs, int Olp, int Sfc, enum Crate WrkRate)
{
  int  i,j,Np;
  float  Tv_tmp[SubFrLen+4];
  float  acelp_gain,gain_T0;
  int acelp_sign, acelp_shift, acelp_pos;
  int offset, ipos, T0_acelp;
  Word32 Acc0;

	switch(WrkRate)
    {
		case Rate63:
        {
          Np = Nb_puls[Sfc];

          for (i=0; i < SubFrLen; i++)
            Tv[i] = 0.0f;

          if (Sfs.Ppos >= MaxPosTable[Sfc])
           return;

// Decode the amplitudes and positions
      
          j = MaxPulseNum - Np;
          Acc0 = Sfs.Ppos;

          for (i = 0; i < SubFrLen/Sgrid; i++)
          {
            Acc0 -= CombinatorialTable[j][i];

            if (Acc0 < (Word32) 0)
            {
              Acc0 += CombinatorialTable[j][i];
              j++;

            if ((Sfs.Pamp & (1 << (MaxPulseNum-j))) != 0)
              Tv[Sfs.Grid + Sgrid*i] = -FcbkGainTable[Sfs.Mamp];
            else
              Tv[Sfs.Grid + Sgrid*i] =  FcbkGainTable[Sfs.Mamp];

            if (j == MaxPulseNum)
              break;
           }
         }

         if (Sfs.Tran == 1)
           Gen_Trn(Tv, Tv, Olp);
         break;
    }

    case Rate53:
    {

      for (i = 0; i < SubFrLen+4; i++)
        Tv_tmp[i] = 0.0f;

      acelp_gain = FcbkGainTable[Sfs.Mamp];
      acelp_shift = Sfs.Grid;
      acelp_sign = Sfs.Pamp;
      acelp_pos = Sfs.Ppos;
      
      offset  = 0;
      for(i=0; i<4; i++)
      {
        ipos = (acelp_pos & 7);
        ipos = (ipos << 3) + acelp_shift + offset;
        
        if((acelp_sign & 1)== 1)
          Tv_tmp[ipos] = acelp_gain;
        else
          Tv_tmp[ipos] = -acelp_gain;
        
        offset += 2;
        acelp_pos = acelp_pos >> 3;
        acelp_sign = acelp_sign >> 1;
      }
      for (i = 0; i < SubFrLen; i++)
        Tv[i] = Tv_tmp[i];
      
      T0_acelp = search_T0(Olp-1+Sfs.AcLg, Sfs.AcGn, &gain_T0);
      if (T0_acelp < SubFrLen-2)
      {
        for (i = T0_acelp; i < SubFrLen; i++)
          Tv[i] += Tv[i-T0_acelp]*gain_T0;
      }
   break;
    }
  }
  return;
}


//---------------------------------------------------------------------
void Acbk_Filt(float *output,float *input,float fac,float *impresp)
{
#if OPT_ACBKF

  ASM
  {
    push esi;
    push edi;
    push ebx;

    mov eax,58;
    mov esi,input;
    mov edi,output;
    mov ebx,impresp;

loop1:
    fld  DP[ebx+4*eax];
    fmul fac;
    fld  DP[ebx+4*eax-4];
    fmul fac;
    fld  DP[ebx+4*eax-8];
    fmul fac;
    fld  DP[ebx+4*eax-12];
    fmul fac;                // a3 a2 a1 a0

    fxch ST(3);
    fadd DP[esi+4*eax];      // b0 a2 a1 a3
    fxch ST(2);
    fadd DP[esi+4*eax-4];    // b1 a2 b0 a3
    fxch ST(1);
    fadd DP[esi+4*eax-8];    // b2 b1 b0 a3
    fxch ST(3);
    fadd DP[esi+4*eax-12];   // b3 b1 b0 b2

    fxch ST(2);
    fstp DP[edi+4*eax];      // b1 b3 b2
    fstp DP[edi+4*eax-4];    // b3 b2
    fxch ST(1);
    fstp DP[edi+4*eax-8];
    fstp DP[edi+4*eax-12];

    sub eax,4;
    cmp eax,2;
    jg  loop1;

    pop ebx;
    pop edi;
    pop esi;
  }

#else

  int i;

  for (i=58; i>2; i-=4)
  {
    output[i-0] = fac*impresp[i-0] + input[i-0];
    output[i-1] = fac*impresp[i-1] + input[i-1];
    output[i-2] = fac*impresp[i-2] + input[i-2];
    output[i-3] = fac*impresp[i-3] + input[i-3];
  }
#endif
  
  output[2] = fac*impresp[2] + input[2];
  output[1] = fac*impresp[1] + input[1];
  output[0] = fac*impresp[0] + input[0];
}
//---------------------------------------------------------------------
#if COMPILE_MMX
void  Find_AcbkInt(float *Tv, float *ImpResp, float *PrevExc, LINEDEF
*Line, int Sfc, enum Crate WrkRate, int flags, CODDEF *CodStat)
{
  int  i,j,k;

  float RezBuf[SubFrLen+ClPitchOrd-1];

  short TvInt[SubFrLen];
  int   Tvxi[SubFrLen];

  short *lPntInt,*sPntInt,*PtrInt;

  int	CorBufInt[4*(2*ClPitchOrd + ClPitchOrd*(ClPitchOrd-1)/2)];
  int  *lPntd;

  long	Acc0l, Acc1l;
 
  int   Olp,Lid,Gid,Hb,t,k1,k2;
  int	Bound[3];
  int	Lag1, Lag2;
  int	MaxInt,off_filt;

  int shift,Tshift,mx;

  DECLARE_SHORT(FltBuf0Int,63);
  DECLARE_SHORT(FltBuf1Int,63);
  DECLARE_SHORT(FltBuf2Int,63);
  DECLARE_SHORT(FltBuf3Int,63);
  DECLARE_SHORT(FltBuf4Int,63) ;
  DECLARE_SHORT(CorVctInt,4*(2*ClPitchOrd + ClPitchOrd*(ClPitchOrd-1)/2)) ;
  DECLARE_SHORT(RezTmpInt,16) ;
  DECLARE_SHORT(RezBufInt,SubFrLen+ClPitchOrd-1) ;
  DECLARE_SHORT(ImpRespInt,63);

  DECLARE_SHORT(Ix,2*SubFrLen+16) ;
  DECLARE_SHORT(Rx,2*SubFrLen+16);
  DECLARE_INT(Temp,64);

  ALIGN_ARRAY(FltBuf0Int);
  ALIGN_ARRAY(FltBuf1Int);
  ALIGN_ARRAY(FltBuf2Int);
  ALIGN_ARRAY(FltBuf3Int);
  ALIGN_ARRAY(FltBuf4Int);
  ALIGN_ARRAY(RezBufInt);
  ALIGN_ARRAY(RezTmpInt);
  ALIGN_ARRAY(ImpRespInt);
  ALIGN_ARRAY(CorVctInt);

  ALIGN_ARRAY(Ix);
  ALIGN_ARRAY(Rx);
  ALIGN_ARRAY(Temp);


  Olp = (*Line).Olp[Sfc>>1];
  Lid = Pstep;
  Gid = 0;
  Hb  = 3 + (Sfc & 1);

// For even frames only
  
  if ((Sfc & 1) == 0)
  {
    if (Olp == PitchMin)
      Olp++;
    if (Olp > (PitchMax-5))
      Olp = PitchMax-5;
  }

  if (flags & SC_LAG1)
  {
   lPntInt = &CorVctInt[20];
    k1 = 1;
    k2 = 2;
  }
  else
  {
   lPntInt = CorVctInt;
    k1 = 0;
    k2 = Hb;
  }

//TIMER_SPOT_ON(Conversion);
  //Convert Tv to 16-bit
  ConstFloatToInt(Tv, Tvxi, SubFrLen, 32768.0f);
  for(i=0; i<SubFrLen; i++) TvInt[i] = (short)(((Tvxi[i]<<1)+0x00008000)>>16);

  //Convert ImpResp to 16-bit
  //Scale by 2^14 & truncate bits right of decimal
  ConstFloatToShort(ImpResp,ImpRespInt,SubFrLen,16384.0f);

  for (k=k1; k<k2; k++)
  {
   lPntd = &CorBufInt[k*20];

// Get residual from the excitation buffer
    
  	Get_Rez(RezBuf, PrevExc, Olp-Pstep+k);

	//Convert RezBuf to 16-bit
	ConstFloatToShort(RezBuf,RezBufInt,SubFrLen+ClPitchOrd-1,1.0f);

	// Filter the last one (ClPitchOrd-1) using the impulse responce
//TIMER_SPOT_OFF(Conversion);
//TIMER_SPOT_ON(Convolution);  
 
	ab2abbcw(&RezBufInt[ClPitchOrd-1], Rx, SubFrLen);

	j=0;
	for(i=0; i<SubFrLen;    i+=2){
		Ix[j]  =Ix[j+2]=ImpRespInt[SubFrLen-1-i];
		Ix[j+1]=Ix[j+3]=ImpRespInt[SubFrLen-2-i];
		j+=4;
	}
	for(i=0; i<16; i++)
		Ix[j+i]=0;
	
	ConvMMX(Rx, Ix, Temp, 60);
	for(i=0; i<SubFrLen; i++) FltBuf4Int[i] = (short)(((Temp[i]<<1)+0x00008000)>>16);

//TIMER_SPOT_OFF(Convolution);
//TIMER_SPOT_ON(FbufCalc);
    
	// Update the others (ClPitchOrd-2 down to 0)
	Acc0l = ((RezBufInt[3]<<13)+0x00004000)>>15;
	FltBuf3Int[0] = (short)Acc0l;

	Acc0l = ((RezBufInt[2]<<13)+0x00004000)>>15;
	FltBuf2Int[0] = (short)Acc0l;

	Acc0l = ((RezBufInt[1]<<13)+0x00004000)>>15;
	FltBuf1Int[0] = (short)Acc0l;

	Acc0l = ((RezBufInt[0]<<13)+0x00004000)>>15;
	FltBuf0Int[0] = (short)Acc0l;

	DupRezBuf(RezBufInt,RezTmpInt);

	FBufCalcInt(FltBuf4Int,FltBuf3Int,ImpRespInt,RezTmpInt,0);
	FBufCalcInt(FltBuf3Int,FltBuf2Int,ImpRespInt,RezTmpInt,1);
	FBufCalcInt(FltBuf2Int,FltBuf1Int,ImpRespInt,RezTmpInt,2);
	FBufCalcInt(FltBuf1Int,FltBuf0Int,ImpRespInt,RezTmpInt,3);

//TIMER_SPOT_OFF(FbufCalc);
//TIMER_SPOT_ON(Dots);
	// Compute the cross products with the signal

	*lPntd++ = DotMMX60(TvInt,FltBuf0Int)<<1;
	*lPntd++ = DotMMX60(TvInt,FltBuf1Int)<<1;
	*lPntd++ = DotMMX60(TvInt,FltBuf2Int)<<1;
	*lPntd++ = DotMMX60(TvInt,FltBuf3Int)<<1;
	*lPntd++ = DotMMX60(TvInt,FltBuf4Int)<<1;

// Compute the energies
   	 
	*lPntd++ = DotMMX60(FltBuf0Int,FltBuf0Int)<<1;
	*lPntd++ = DotMMX60(FltBuf1Int,FltBuf1Int)<<1;
	*lPntd++ = DotMMX60(FltBuf2Int,FltBuf2Int)<<1;
	*lPntd++ = DotMMX60(FltBuf3Int,FltBuf3Int)<<1;
	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf4Int)<<1;

// Compute the between crosses

	*lPntd++ = DotMMX60(FltBuf1Int,FltBuf0Int)<<2;

	*lPntd++ = DotMMX60(FltBuf2Int,FltBuf0Int)<<2;
	*lPntd++ = DotMMX60(FltBuf2Int,FltBuf1Int)<<2;

	*lPntd++ = DotMMX60(FltBuf3Int,FltBuf0Int)<<2;
	*lPntd++ = DotMMX60(FltBuf3Int,FltBuf1Int)<<2;
	*lPntd++ = DotMMX60(FltBuf3Int,FltBuf2Int)<<2;

	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf0Int)<<2;
	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf1Int)<<2;
	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf2Int)<<2;
	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf3Int)<<2;

//TIMER_SPOT_OFF(Dots);

  }

  //Convert k1 through k2 indices of CorBufInt to 16-bit
  //	values
  Acc1l = 0L;
  for(j=k1; j<k2; j++)
  {
  	 for(i=0; i<20; i++)
	 {
  	 	Acc0l = abs(CorBufInt[j*20 + i]);
	 	if( Acc0l > Acc1l) Acc1l = Acc0l;
	 }
  }

  //Need a convert_long_to_short routine
  shift = norm(Acc1l);
  for(j=k1; j<k2; j++)
  {
	 for(i=0; i<20; i++)
	 {
  	  	CorBufInt[j*20 + i]=CorBufInt[j*20 + i]<<shift;
	  	CorBufInt[j*20 + i] += 0x00008000L; //round up to 16 MSBs
	  	*lPntInt++=(short)(CorBufInt[j*20 + i]>>16);
	  }
  }

  /* Test potential error */
  Lag1 = Olp - Pstep;
  Lag2 = Olp - Pstep + Hb - 1;

  off_filt = Test_Err(Lag1, Lag2, CodStat);

  Bound[0] =  NbFilt085_min + (off_filt << 2);
  if(Bound[0] > NbFilt085) Bound[0] = NbFilt085;
  Bound[1] =  NbFilt170_min + (off_filt << 3);
  if(Bound[1] > NbFilt170) Bound[1] = NbFilt170;

  Bound[2] = 85; //Use subset table in the case t=2

  MaxInt = 0;

  for (k=k1; k<k2; k++)
  {

// Select Quantization table
    
    t = 0;
    if (WrkRate == Rate63)
    {
      if ((Sfc & 1) == 0)
      {
        if (Olp-Pstep+k >= SubFrLen-2)
          t = 1;
      }
      else
      {
        if (Olp >= SubFrLen-2)
          t = 1;
      }
    }
    else
      t = 1;

	/* If Bound=170 and SC_GAIN=TRUE, use 170subset table.
	   Else, use full table with limited Bound.*/ 
    //if (t==1 && (flags & SC_GAIN) && Bound[t]==NbFilt170)
	if ((WrkRate == Rate53) && (flags & SC_GAIN) && (Bound[t]==NbFilt170))
      t = 2;
    
// Search for maximum
//t=1;

	sPntInt = AcbkGainTablePtrInt[t];
	PtrInt = &CorVctInt[k*20];

//TIMER_SPOT_ON(CodeBook);
   
	CodeBkSrch(PtrInt, sPntInt, Bound[t], &Gid, &MaxInt);

//TIMER_SPOT_OFF(CodeBook);
	  
    if (t==2)
	 Gid = GainScramble[Gid];
    //else
        //Gid = Gid;

	Lid = k;
  }

// Modify Olp for even sub frames
  
  if ((Sfc & 1) == 0)
  {
    Olp = Olp - Pstep + Lid;
    Lid = Pstep;
  }

// Save Lag, Gain and Olp
  
  (*Line).Sfs[Sfc].AcLg = Lid;
  (*Line).Sfs[Sfc].AcGn = Gid;
  (*Line).Olp[Sfc>>1] = Olp;

//ASM emms;

/* ------------------------------ FLOAT -----------------------*/


// Decode the Acbk contribution and subtract it
  
  Decod_Acbk(RezBuf, PrevExc, Olp, Lid, Gid, WrkRate);

//TIMER_SPOT_ON(LastConvolv);

  mx = FloatToShortScaled(RezBuf, RezBufInt, SubFrLen+ClPitchOrd-1, 3);
  Tshift = 11 - (mx-126);
  if(mx==0) Tshift = 0;

  ab2abbcw(RezBufInt, Rx, 60);
  ConvMMX(Rx, Ix, Temp, SubFrLen);

  //ASM emms;

  if (Tshift >=0) {
	for(j=0; j<SubFrLen; j++){
		Temp[j] = Temp[j]>>Tshift;
		Tv[j]=((float)(Tvxi[j] - Temp[j]))*0.00003052f;
	}
  }
  else
  {
    for(j=0; j<SubFrLen; j++){
		Temp[j] = Temp[j]<<(-Tshift);
		Tv[j]=((float)(Tvxi[j] - Temp[j]))*0.00003052f;
	}
  }

//TIMER_SPOT_OFF(LastConvolv);

}
#endif //COMPILE_MMX

short norm(long L_var1)
{
    short var_out;

    if (L_var1 == 0L) {
        var_out = (short)0;
    }
    else {
        if (L_var1 == (long)0xffffffffL) {
            var_out = (short)31;
        }
        else {
            if (L_var1 < 0L) {
                L_var1 = ~L_var1;
            }

            for(var_out = (short)0;L_var1 < 0x40000000L;var_out++) 
            {
                L_var1 <<= 1L;
            }
        }
    }

    return(var_out);
}
/*---------------------------------------------------------------------*/
void  Find_Acbk(float *Tv, float *ImpResp, float *PrevExc, LINEDEF
*Line, int Sfc, enum Crate WrkRate, int flags, CODDEF *CodStat)
{
  int  i,j,k;

  float Acc0,Max;

  float RezBuf[SubFrLen+ClPitchOrd-1];
  float FltBuf[ClPitchOrd][SubFrLen];
  float CorVct[4*(2*ClPitchOrd + ClPitchOrd*(ClPitchOrd-1)/2)];
  float *lPnt;
  float *sPnt,*Ptr;
  int   Olp,Lid,Gid,Hb,t,k1,k2;
  int	Bound[3];
  int	Lag1, Lag2;
  int	off_filt;

  Olp = (*Line).Olp[Sfc>>1];
  Lid = Pstep;
  Gid = 0;
  Hb  = 3 + (Sfc & 1);

// For even frames only
  
  if ((Sfc & 1) == 0)
  {
    if (Olp == PitchMin)
      Olp++;
    if (Olp > (PitchMax-5))
      Olp = PitchMax-5;
  }

  if (flags & SC_LAG1)
  {
    lPnt = &CorVct[20];
    k1 = 1;
    k2 = 2;
  }
  else
  {
    lPnt = CorVct;
    k1 = 0;
    k2 = Hb;
  }

  for (k=k1; k<k2; k++)
  {

// Get residual from the exitation buffer
    
    Get_Rez(RezBuf, PrevExc, Olp-Pstep+k);

// Filter the last one (ClPitchOrd-1) using the impulse responce
    
    for (i=0; i < SubFrLen; i++)
      FltBuf[ClPitchOrd-1][i] = DotRev(&RezBuf[ClPitchOrd-1],ImpResp,i+1);
    
// Update the others (ClPitchOrd-2 down to 0)
    
    for (i=ClPitchOrd-2; i >= 0; i --)
    {
      FltBuf[i][0] = RezBuf[i]*0.5f;
      Acbk_Filt(&FltBuf[i][1],&FltBuf[i+1][0],RezBuf[i],&ImpResp[1]);
//      for (j = 1; j < SubFrLen; j++)
//        FltBuf[i][j] = RezBuf[i]*ImpResp[j] + FltBuf[i+1][j-1];
    }

// Compute the cross products with the signal
    
    for (i=0; i < ClPitchOrd; i++)
      *lPnt++ = DotProd(Tv, FltBuf[i], SubFrLen);

// Compute the energies
    
    for (i=0; i < ClPitchOrd; i++)
      *lPnt++ = 0.5f*DotProd(FltBuf[i], FltBuf[i], SubFrLen);

// Compute the between crosses
    
    for (i=1; i < ClPitchOrd; i++)
      for (j = 0; j < i; j++)
        *lPnt++ = DotProd(FltBuf[i], FltBuf[j], SubFrLen);

  }

  /* Test potential error */
  Lag1 = Olp - Pstep;
  Lag2 = Olp - Pstep + Hb - 1;

  off_filt = Test_Err(Lag1, Lag2, CodStat);

  Bound[0] =  NbFilt085_min + (off_filt << 2);
  if(Bound[0] > NbFilt085) Bound[0] = NbFilt085;
  Bound[1] =  NbFilt170_min + (off_filt << 3);
  if(Bound[1] > NbFilt170) Bound[1] = NbFilt170;

  Bound[2] = 85; //Use subset table in the case t=2

  Max = 0.0f;

  for (k=k1; k<k2; k++)
  {

// Select Quantization table
    
    t = 0;
    if (WrkRate == Rate63)
    {
      if ((Sfc & 1) == 0)
      {
        if (Olp-Pstep+k >= SubFrLen-2)
          t = 1;
      }
      else
      {
        if (Olp >= SubFrLen-2)
          t = 1;
      }
    }
    else
      t = 1;

	/* If Bound=170 and SC_GAIN=TRUE, use 170subset table.
	   Else, use full table with limited Bound.*/ 
    if (t==1 && (flags & SC_GAIN) && Bound[t]==NbFilt170)
      t = 2;
    
// Search for maximum

	sPnt = AcbkGainTablePtr[t];
  	Ptr  = &CorVct[k*20];

    for (i=0; i < Bound[t]; i++)
    {
      Acc0 = Ptr[0]*sPnt[0] + Ptr[1]*sPnt[1] +
        Ptr[2]*sPnt[2] + Ptr[3]*sPnt[3] +
        Ptr[4]*sPnt[4] + Ptr[5]*sPnt[5] +
        Ptr[6]*sPnt[6] + Ptr[7]*sPnt[7] +
        Ptr[8]*sPnt[8] + Ptr[9]*sPnt[9] +
        Ptr[10]*sPnt[10] + Ptr[11]*sPnt[11] +
        Ptr[12]*sPnt[12] + Ptr[13]*sPnt[13] +
        Ptr[14]*sPnt[14] + Ptr[15]*sPnt[15] +
        Ptr[16]*sPnt[16] + Ptr[17]*sPnt[17] +
        Ptr[18]*sPnt[18] + Ptr[19]*sPnt[19];

      sPnt += 20;

      if (asint(Acc0) > asint(Max))  // integer cmp, since Max is not negative.
      {
        Max = Acc0;

        if (t==2)
          Gid = GainScramble[i];
        else
          Gid = i;

        Lid = k;
      }
    }
  }

// Modify Olp for even sub frames
  
  if ((Sfc & 1) == 0)
  {
    Olp = Olp - Pstep + Lid;
    Lid = Pstep;
  }

// Save Lag, Gain and Olp
  
  (*Line).Sfs[Sfc].AcLg = Lid;
  (*Line).Sfs[Sfc].AcGn = Gid;
  (*Line).Olp[Sfc>>1] = Olp;

// Decode the Acbk contribution and subtract it
  
  Decod_Acbk(RezBuf, PrevExc, Olp, Lid, Gid, WrkRate);

  for (i=0; i < SubFrLen; i++)
    Tv[i] -= DotRev(RezBuf,ImpResp,i+1);

}

//-----------------------------------------------------------------
void  Get_Rez(float *Tv, float *PrevExc, int Lag)
{
  int  i,n,div,mod;
  float *src,*dst;

  for (i=0; i < ClPitchOrd/2; i++)
    Tv[i] = PrevExc[PitchMax - Lag - ClPitchOrd/2 + i];

  n = SubFrLen+ClPitchOrd/2;
  div = n/Lag;
  mod = n%Lag;

  dst = &Tv[ClPitchOrd/2];
  src = &PrevExc[PitchMax-Lag];
  for (i=0; i<div; i++)
  {
    memcpy(dst,src,4*Lag);
    dst += Lag;
  }
  memcpy(dst,src,4*mod);
}


//-----------------------------------------------------------------
void  Decod_Acbk(float *Tv, float *PrevExc, int Olp, int Lid, int Gid, enum Crate WrkRate)
{
  int  i;

  float  RezBuf[SubFrLen+ClPitchOrd-1];
  float *sPnt;

  Get_Rez(RezBuf, PrevExc, (Olp + Lid) - Pstep);

// Select Quantization tables
  
  i = 0;
  if (WrkRate == Rate63)
  {
	if (Olp >= (SubFrLen-2))
      i++;
  }
  else
    i=1;

  sPnt = AcbkGainTablePtr[i] + Gid*20;

// Compute output vector

  for (i=0; i < SubFrLen; i++)
    Tv[i] = RezBuf[i]*sPnt[0] + RezBuf[i+1]*sPnt[1] + RezBuf[i+2]*sPnt[2] +
      RezBuf[i+3]*sPnt[3] + RezBuf[i+4]*sPnt[4];
}


//-----------------------------------------------
int  Comp_Info(float Buff[60], int Olp)
{
  int  i;

  float  Acc0;

  float  Tenr;
  float  Ccr,Enr;
  int  Indx;

  if (Olp > (PitchMax-3))
    Olp = (PitchMax-3);

  Indx = Olp;
  Ccr =  0.0f;

  for (i=Olp-3; i <= Olp+3; i++)
  {
    Acc0 = DotProd(&Buff[PitchMax+Frame-2*SubFrLen],
      &Buff[PitchMax+Frame-2*SubFrLen-i],2*SubFrLen);
    
    if (Acc0 > Ccr)
    {
      Ccr = Acc0;
      Indx = i;
    }
  }

// Compute target energy 
 
    Tenr = DotProd(&Buff[PitchMax+Frame-2*SubFrLen],
      &Buff[PitchMax+Frame-2*SubFrLen],2*SubFrLen);

// Compute best energy
    
    Enr = DotProd(&Buff[PitchMax+Frame-2*SubFrLen-Indx],
      &Buff[PitchMax+Frame-2*SubFrLen-Indx],2*SubFrLen);

  if (Ccr <= 0.0f)
    return 0;
	
  if (((0.125f*Enr*Tenr) - (Ccr*Ccr)) < 0.0f)
    return Indx;
  else
    return 0;
}


//------------------------------------------------------------------
void    Regen(float *DataBuff, float *Buff, int Lag, float Gain,
              int Ecount, int *Sd)
{
  int  i;

// Test for clearing

  if (Ecount >= ErrMaxNum)
  {
    for (i = 0; i < Frame; i++)
	  DataBuff[i] = 0.0f;
	for (i = 0; i < Frame+PitchMax; i++)
	  Buff[i] = 0.0f;
  }
  else
  {
    
// Interpolate accordingly to the voicing estimation

    if (Lag != 0)
    {
      // Voiced case
      for (i = 0; i < Frame; i++)
        Buff[PitchMax+i] = Buff[PitchMax-Lag+i];
      for (i = 0; i < Frame; i++)
        DataBuff[i] = Buff[PitchMax+i] = Buff[PitchMax+i] *  0.75f;
    }
    else
    {

//Unvoiced case

      for (i = 0; i < Frame; i++)
        DataBuff[i] = Gain*(float)Rand_lbc(Sd)*(1.0f/16384.0f);

//Clear buffer to reset memory
 
      for (i = 0; i < Frame+PitchMax; i++)
        Buff[i] = 0.0f;
     }
  }
}


//------------------------------------------------------
//Comp_Lpf

//------------------------------------------------------
//Find_B

//------------------------------------------------------
//Find_F

//------------------------------------------------------
//Get_Ind

//------------------------------------------------------
//Filt_Lpf

//---------------------------------------------------------------
int search_T0 (int T0, int Gid, float *gain_T0)
{

	int T0_mod;

	T0_mod = T0+epsi170[Gid];
    *gain_T0 = gain170[Gid];

	return(T0_mod);
}


/*
**
** Function:    Update_Err()
**
** Description:   Estimation of the excitation error associated
**          to the excitation signal when it is disturbed at
**          the decoder, the disturbing signal being filtered
**          by the long term synthesis filters
**          one value for (SubFrLen/2) samples
**          Updates the table CodStat.Err
**
** Links to text:   Section
**
** Arguments:
**
**  int Olp    Center value for pitch delay
**  int AcLg   Offset value for pitch delay
**  int AcGn   Index of Gain LT filter
**
** Outputs: None
**
** Return value:  None
**
*/

#define MAX 256.0f

void Update_Err(int Olp, int AcLg, int AcGn, CODDEF *CodStat)
{
  int i, iz, temp2;
  int Lag;
  float Worst1, Worst0, wtemp;
  float beta,*ptr_tab;

  Lag = Olp - Pstep + AcLg;

  /* Select Quantization tables */
  i = 0 ;
  ptr_tab = tabgain85;
  if ( CodStat->WrkRate == Rate63 ) {
    if ( Olp >= (SubFrLen-2) ) ptr_tab = tabgain170;
  }
  else {
    ptr_tab = tabgain170;
  }
  beta = ptr_tab[(int)AcGn];


  if(Lag <= (SubFrLen/2))
  {
    Worst0 = CodStat->Err[0]*beta + Err0;
    Worst1 = Worst0;
  }
  else
  {
    iz = (Lag*1092) >> 15;
    temp2 = 30*(iz+1);

    if (temp2 != Lag)
    {
      if(iz == 1)
      {
        Worst0 = CodStat->Err[0]*beta + Err0;
        Worst1 = CodStat->Err[1]*beta + Err0;

        if (Worst0 > Worst1)
          Worst1 = Worst0;
        else
          Worst0 = Worst1;
      }
      else
      {
        wtemp = CodStat->Err[iz-1]*beta + Err0;
        Worst0 = CodStat->Err[iz-2]*beta + Err0;
        if (wtemp > Worst0) Worst0 = wtemp;
        Worst1 = CodStat->Err[iz]*beta + Err0;
        if (wtemp > Worst1) Worst1 = wtemp;
      }
    }
    else
    {  
      Worst0 = CodStat->Err[iz-1]*beta + Err0;
      Worst1 = CodStat->Err[iz]*beta + Err0;
    }
  }

  if (Worst0 > MAX) Worst0 = MAX;
  if (Worst1 > MAX) Worst1 = MAX;

  for(i=4; i>=2; i--)
    CodStat->Err[i] = CodStat->Err[i-2];

  CodStat->Err[0] = Worst0;
  CodStat->Err[1] = Worst1;

  return;
}

/*
**
** Function:    Test_Err()
**
** Description:   Check the error excitation maximum for
**          the subframe and computes an index iTest used to
**          calculate the maximum nb of filters (in Find_Acbk) :
**          Bound = Min(Nmin + iTest x pas, Nmax) , with
**          AcbkGainTable085 : pas = 2, Nmin = 51, Nmax = 85
**          AcbkGainTable170 : pas = 4, Nmin = 93, Nmax = 170
**          iTest depends on the relative difference between
**          errmax and a fixed threshold
**
** Links to text:   Section
**
** Arguments:
**
**  Word16 Lag1    1st long term Lag of the tested zone
**  Word16 Lag2    2nd long term Lag of the tested zone
**
** Outputs: None
**
** Return value:
**  Word16      index iTest used to compute Acbk number of filters
*/

int Test_Err(int Lag1, int Lag2, CODDEF *CodStat)
{
  int i, i1, i2;
  int zone1, zone2, iTest;
  float Err_max;

  i2 = Lag2 + ClPitchOrd/2;
  zone2 = i2/30;

  i1 = - SubFrLen + 1 + Lag1 - ClPitchOrd/2;
  if (i1 <= 0) i1 = 1;
  zone1 = i1/30;

  Err_max = -1.0f;
  for(i=zone2; i>=zone1; i--)
  {
    if (CodStat->Err[i] > Err_max)
      Err_max = CodStat->Err[i];
  }
  if((Err_max > ThreshErr) || (CodStat->SinDet < 0 ) )
  {
    iTest = 0;
    //ount_clip++;
  }
  else
  {
    iTest = (int)(ThreshErr - Err_max);
  }

  return(iTest);
}


#if COMPILE_MMX

#if ASM_FACBK

int DotMMX60(short *ind, short *oud)
{
int dotprod;

#define reg0  mm0
#define reg1  mm1
#define reg2  mm2
#define acc0  mm6

#define inx	  esi
#define oux	  edi
#define dot   eax
#define jcnt  ebx

#define l(n)  ASM movq    reg##n,QP[inx+8*n]
#define m(n)  ASM pmaddwd reg##n,QP[oux+8*n]
#define a(n)  ASM paddd   acc0,reg##n

  ASM
  {
    mov		inx,ind;
    mov		oux,oud;
	mov		jcnt,5;
  }
  

//Begin loop

 ASM pxor	acc0,acc0;	
 ASM pxor	reg1,reg1;   //make first a(1) a nop
 ASM pxor	reg2,reg2;   //make first a(2) a nop

inner:				
//------------------
l(0);
		a(1);
m(0);
		l(1);
				a(2);
		m(1);
				l(2);
a(0);
				m(2);
//-------------------

			
ASM add inx,24;
ASM add oux,24;

ASM sub jcnt,1;
ASM jg inner;

a(1);
a(2);

ASM
{
	//Add the two halves of acc0
    movq  reg0,acc0;
    psrlq acc0,32;
    paddd acc0,reg0;
	movd  dot,acc0; //store
	mov   dotprod,dot
}

ASM emms;

 return(dotprod);
#undef reg0
#undef reg1
#undef reg2
#undef acc0

#undef inx
#undef oux
#undef dot
#undef jcnt

#undef l
#undef m
#undef a
  
}

#else

int DotMMX60(short *in, short *out)
{
int dotprod;
int j;

dotprod=0;
for(i=0; i < 60; i++)
{
	
  dotprod += in[j]*out[j];

}

return(dotprod);
}

#endif

#if ASM_FACBK

void DupRezBuf(short *rezbuf, short *reztemp)
{
  #define reg0	mm0
  #define reg1	mm1
  #define reg2	mm2
  #define reg3	mm3

  #define rbuf	edi
  #define rztmp esi

	//rezbuf duplication operations
  #define cr(r0,r1) ASM movq reg##r0,reg##r1
  #define uph(r0)   ASM punpckhwd reg##r0,reg##r0 
  #define upl(r0)   ASM punpcklwd reg##r0,reg##r0 
  #define sto(r0,i) ASM movq QP[rztmp+8*i],reg##r0
  #define sl(r0)	ASM psllw reg##r0,1
  #define l(r0)		ASM movq reg##r0,QP[rbuf]

  //Duplicate first 4 rezbuf values 4 times each
  //	and store into 4 QWORDS in reztemp
  //Multiply by two while we're at it
  ASM mov rbuf,rezbuf;
  ASM mov rztmp,reztemp;

	l(0);
	sl(0);
	cr(2,0);
	 uph(0);
	upl(2);
	 cr(1,0);
	cr(3,2);
	 uph(0);
	sto(0,0);
	 upl(1);
	sto(1,1);
	 uph(2);
	sto(2,2);
	 upl(3);
	sto(3,3);

ASM emms;

}
  #undef reg0
  #undef reg1
  #undef reg2
  #undef reg3

  #undef rbuf
  #undef rztmp

  #undef cr
  #undef uph
  #undef upl
  #undef sto
  #undef sl
  #undef l

#endif

#if ASM_FACBK

void FBufCalcInt(short *fi, short *fo, short *impresp, short *reztemp, int n)
{
  #define reg0	mm0
  #define reg1	mm1
  #define reg2	mm2
  #define reg3	mm3
  #define reg4	mm4
  #define reg5	mm5
  #define reg6	mm6
  #define reg7	mm1
  #define reg8	mm7

  #define fbufi	esi
  #define rbuf	edi
  #define imp	edx
  #define fbufo	ebx
  #define jcnt	ecx
  #define rzv   eax

  //Diagonal array operations
  #define l1(r0,j)  ASM movq reg##r0,QP[fbufi+8*j]
  #define l2(r0,j)  ASM movq reg##r0,QP[fbufi+8+8*j]
  #define c3(r0)    ASM movq reg##r0,QP[rbuf+8*rzv]
  #define m1(r0,j)  ASM pmulhw reg##r0,QP[imp+8+8*j]
  #define a1(r0,r1) ASM paddsw reg##r0,reg##r1
  #define sto(r0,j) ASM movq QP[fbufo+8+8*j], reg##r0
  #define s1(r0)    ASM psrlq reg##r0,48
  #define s2(r0)    ASM psllq reg##r0,16
  #define or(r0,r1) ASM por reg##r0,reg##r1


//Loop setup
ASM 
{
	mov rbuf,reztemp
	mov jcnt,5;
	mov fbufi,fi;
	mov fbufo,fo;
	mov imp,impresp;
	mov rzv,n
}
//Compute initial values
//Zero-th QWORD is different

ASM 
{
	movq	reg0,QP[fbufo];
	psllq	reg0,48;
	psrlq	reg0,48;

//zero-th part of fbufo now in reg0
	movq    reg2,QP[rbuf+8*rzv];
	pmulhw	reg2,QP[imp+2];
	paddsw	reg2,QP[fbufi];
	psllq	reg2,16;
	por		reg0,reg2;

	movq	QP[fbufo],reg0;
}
//begin loop 
	l2(0,0);		
	l1(1,0);
	s2(0);
	s1(1);
	c3(2);
	m1(2,0);
			l2(3,1);
			l1(4,1);
			s2(3);
			s1(4);
	or(0,1);
	
inner: 
 //-------------------------
					l2(6,2);
	a1(0,2);
			c3(5);
			m1(5,1);
			or(3,4);
					l1(7,2);
					s2(6);
	sto(0,0);
					s1(7);
	l2(0,3);
			a1(3,5);
					c3(8);
					m1(8,2);
					or(6,7);
	l1(1,3);
	s2(0);
			sto(3,1);
	s1(1);
			l2(3,4);
					a1(6,8);
	c3(2);
	m1(2,3);
	or(0,1);
			l1(4,4);
			s2(3);
					sto(6,2);
			s1(4);
 //-------------------------

 ASM add fbufo,24;
 ASM add fbufi,24;
 ASM add imp,24;

 ASM sub jcnt,1;
 ASM jg inner;

 ASM emms;
}
  #undef reg0
  #undef reg1
  #undef reg2
  #undef reg3
  #undef reg4
  #undef reg5
  #undef reg6
  #undef reg7
  #undef reg8

  #undef fbufi
  #undef rbuf
  #undef imp
  #undef fbufo
  #undef jcnt
  #undef rzv

  #undef l1
  #undef l2
  #undef c3
  #undef m1
  #undef a1
  #undef sto
  #undef s1
  #undef s2
  #undef or

#else

void FBufCalcInt(short *fi, short *fo, short *impresp, short *rezbuf, short *reztemp, int n)
{
  long Acc0l;
  int j;

  #define MAX16  32767
  #define MIN16 -32768

	for(j=1; j<SubFrLen; j++)
	{	
		Acc0l = fi[j-1];
		Acc0l += (((rezbuf[4-n]<<1)*impresp[j]))>>16;
		if	   (Acc0l > MAX16) Acc0l = MAX16;
	    else if(Acc0l < MIN16) Acc0l = MIN16;
		fo[j] = (short)(Acc0l);
	}	
}
#endif


#if ASM_FACBK
//#if 0

void CodeBkSrch(short *lpint, short *spint, int numvecs, int *gid, int *max)
{

#define reg0  mm0
#define reg1  mm1
#define reg2  mm2
#define reg3  mm3
#define reg4  mm4
#define acc1  mm5
#define acc0  mm6
#define gdx	  mm3
#define gd	  mm7
#define icx	  mm2

#define lp	  esi
#define sp	  edi
#define maxx  eax
#define gidx  edx
#define icnt  ebx

// In the following macros, 'n' is the column number.
#define l(n)  ASM movq    reg##n,QP[lp+8*n]
#define m(n)  ASM pmaddwd reg##n,QP[sp+8*n]
#define a(n)  ASM paddd   acc0,reg##n

  ASM
  {
    mov		sp,spint;
    mov		lp,lpint;
	mov		icnt,numvecs;
	mov		gidx,gid;
	mov	    maxx,max;
  }
  
  ASM movd	gd,numvecs;//load gd with top codebook index
  ASM movd  acc1,DP[maxx];//load acc1 with previous max

//Begin loop

outer:
//inner:
  ASM pxor  acc0,acc0;	
  ASM pxor	reg1,reg1;   //make first a(1) a nop
  ASM pxor	reg2,reg2;   //make first a(2) a nop
//--------------------------
l(0);
				a(1);
m(0);
		l(1);
						a(2);
		m(1);
				l(2);
a(0);
				m(2);
						l(3);
		a(1);
						m(3);
l(4);
				a(2);
m(4);

ASM add	 sp,40;
						a(3);
ASM movq  gdx,gd;
ASM movd  icx,icnt;

a(4);

  ASM
  {
    movq  reg0,acc0;
    psrlq acc0,32;

	pxor  gd,icx;//gd=MASK 
    paddd acc0,reg0;
	
	movq    reg0,acc0; //copy acc0
	movq    reg1,acc1; //copy old max
	
	pxor    reg1,acc0
	pcmpgtd reg0,acc1; //reg0=0xFF or 0x00
	pand    reg1,reg0; //reg1=MASK or 0x00
	pxor    acc1,reg1; //acc1=acc0 or acc1
	
	pand	gd,reg0; //gd=MASK or 0x00
	pxor	gd,gdx;  //gd=icnt or previous value	
 
    sub icnt,1;
    jg  outer;
  }

  ASM movd  reg0,numvecs;
  ASM psubd reg0,gd;
  ASM movd  DP[gidx],reg0;//return gid 
  ASM movd  DP[maxx],acc1;//return max
  ASM emms;
  
}
#undef reg0
#undef reg1
#undef reg2
#undef reg3
#undef reg4
#undef acc1
#undef acc0
#undef gdx
#undef gd
#undef icx

#undef lp
#undef sp
#undef maxx
#undef gidx
#undef icnt

#undef l
#undef m
#undef a

#else

void CodeBkSrch(short *lpint, short *spint, int numvecs, int *gid, int *max)
{
int acc0;
int i,j;


for(i=0; i < numvecs; i++)
{
	acc0 = 0;

	for(j=0; j<20; j++)
		acc0 += lpint[j]*spint[j];

	if (acc0 > *max)
	{
		*max = acc0;
		*gid = i;
	}

	spint += 20;
}


}

#endif

#endif //COMPILE_MMX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\exc_lbc.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//


int Estim_Pitch( float *Dpnt, int Start );
int Estim_Int( float *Dpnt, int Start );
PWDEF Comp_Pw( float *Dpnt, int Start, int Olp );
void  Filt_Pw( float *DataBuff, float *Dpnt, int Start, PWDEF Pw );
void  Find_Fcbk( float *Dpnt, float *ImpResp, LINEDEF *Line, int Sfc, enum Crate WrkRate, int flags, int UseMMX );
int ACELP_LBC_code(float *X, float *h, int T0, float *code,
  int *ind_gain, int *shift, int *sign, float gain_T0, int flags);
int ACELP_LBC_code_int(float *X, float *h, int T0, float *code,
  int *ind_gain, int *shift, int *sign, float gain_T0, int flags);
void Cor_h(float *H, float *rr);
void Cor_h_X(float h[],float X[],float D[]);
int D4i64_LBC(float Dn[], float rr[], float h[], float cod[],
				 float y[], int *code_shift, int *sign, int flags);
int G_code(float X[], float Y[], float *gain_q);
void  Gen_Trn( float *Dst, float *Src, int Olp );
void  Find_Best( BESTDEF *Best, float *Tv, float *ImpResp, int Np,
int Olp );
void  Fcbk_Pack( float *Dpnt, SFSDEF *Sfs, BESTDEF *Best, int Np );
void  Fcbk_Unpk( float *Tv, SFSDEF Sfs, int Olp, int Sfc, enum Crate WrkRate );
void  Find_Acbk( float *Tv, float *ImpResp, float *PrevExc, LINEDEF
*Line, int Sfc, enum Crate WrkRate, int flags, CODDEF *CodStat);
void  Get_Rez( float *Tv, float *PrevExc, int Lag );
void  Decod_Acbk( float *Tv, float *PrevExc, int Olp, int Lid,
int Gid, enum Crate WrkRate );
int   Comp_Info( float *Buff, int Olp );
void     Regen( float *DataBuff, float *Buff, int Lag, float Gain,
int Ecount, int *Sd );
//Comp_Lpf
//Find_B
//Find_F
//Get_Ind
//Filt_Lpf
int  search_T0 ( int T0, int Gid, float *gain_T0);
void reset_max_time(void);

//This routine is not part of the ITU 723 standard

 int Find_L(float *OccPos, float *ImrCorr, float *WrkBlk, float Pamp, int k);

int Test_Err(int Lag1, int Lag2, CODDEF *CodStat);
void Update_Err(int Olp, int AcLg, int AcGn, CODDEF *CodStat);


void  Find_AcbkInt( float *Tv, float *ImpResp, float *PrevExc, LINEDEF
*Line, int Sfc, enum Crate WrkRate, int flags, CODDEF *CodStat);

short norm(long L_var1);
void FBufCalcInt(short *fi, short *fo, short *impresp, short *reztemp, int n);
void CodeBkSrch(short *lpint, short *spint, int numloops, int *gid, int *max);
void FloatToShort(float *fbuf, short *sbuf, int count);
int DotMMX60(short *ind, short *oud);
void DupRezBuf(short *rezbuf, short *reztemp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\decod.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//
#include "timer.h"
#include "ctiming.h"
#include "opt.h"
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "decod.h"
#include "util_lbc.h"
#include "lpc.h"
#include "lsp.h"
#include "exc_lbc.h"

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
#pragma message ("Current log decode timing computations handle 2057 frames max")
void OutputDecodeTimingStatistics(char * szFileName, DEC_TIMING_INFO * pDecTimingInfo, unsigned long dwFrameCount);
void OutputDecTimingDetail(FILE * pFile, DEC_TIMING_INFO * pDecTimingInfo);
#endif // } LOG_DECODE_TIMINGS_ON

//  This file includes the decoder main functions


//--------------------------------------------------
void  Init_Decod(DECDEF *DecStat)
{
  int  i;

// Init prev Lsp to Dc
  for (i = 0; i < LpcOrder; i++)
    DecStat->dPrevLsp[i] = LspDcTable[i];

  DecStat->dp = 9;
  DecStat->dq = 9;	
 
}

//--------------------------------------------------
Flag  Decod(float *DataBuff, Word32 *Vinp, Word16 Crc, DECDEF *DecStat)
{
	int		i,j,g;

	float	QntLpc[SubFrames*LpcOrder];
	float	AcbkCont[SubFrLen];

	float	LspVect[LpcOrder];
	float	Temp[PitchMax+Frame];
	float	*Dpnt;

	LINEDEF	Line;

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	unsigned long dwStartLow;
	unsigned long dwStartHigh;
	unsigned long dwElapsed;
	unsigned long dwBefore;
	unsigned long dwDecode = 0;
	int bTimingThisFrame = 0;
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	unsigned long dwLine_Unpk = 0;
	unsigned long dwLsp_Inq = 0;
	unsigned long dwLsp_Int = 0;
	unsigned long dwVariousD = 0;
	unsigned long dwFcbk_UnpkD = 0;
	unsigned long dwDecod_AcbkD = 0;
	unsigned long dwComp_Info = 0;
	unsigned long dwRegen = 0;
	unsigned long dwSynt = 0;
	unsigned long dwFcbk_UnpkDTemp = 0;
	unsigned long dwDecod_AcbkDTemp = 0;
	unsigned long dwSyntTemp = 0;
#endif // } DETAILED_DECODE_TIMINGS_ON
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	DEC_TIMING_INFO * pDecTimingInfo = NULL;
#endif // } LOG_DECODE_TIMINGS_ON

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	TIMER_START(bTimingThisFrame,dwStartLow,dwStartHigh);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	if (DecStat->dwStatFrameCount < DEC_TIMING_INFO_FRAME_COUNT)
	{
		DecStat->dwStartLow = dwStartLow;
		DecStat->dwStartHigh = dwStartHigh;
	}
	DecStat->bTimingThisFrame = bTimingThisFrame;
#endif // } LOG_DECODE_TIMINGS_ON

	// Unpack the Line info
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

	Line_Unpk(&Line, Vinp, &DecStat->WrkRate, Crc);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLine_Unpk);
#endif // } DETAILED_DECODE_TIMINGS_ON

	if(DecStat->WrkRate == Silent) {
		//HACK: For handling SID frames.
		//Until comfort noise generator is in place, we play
		//	out random noise frames.
		//In Line_unpck, reset WrkRate to original setting
		//	and decode.  We therefore should never reach this point.
		memset(DataBuff, 0, sizeof(float) * Frame);
		//exit having filled frame with zeros leave state alone
		//this will be fixed up in a later ITU release
		return (Flag) False; 
	}
	else if(DecStat->WrkRate == Lost) {
		Line.Crc = !0;
	}
/*
  Line.Crc equals one means that the line was corrupted. It shouldn't
  be reassigned. Otherwise, member of Line will be used uninitialized.
  Comment out the following two lines.                muhan, 5/26/98

  else {
    Line.Crc = Crc;
  }
*/
	if (Line.Crc != 0)
		DecStat->Ecount++;
	else
		DecStat->Ecount = 0;

	if (DecStat->Ecount >  ErrMaxNum)
		DecStat->Ecount = ErrMaxNum;

	// Inverse quantization of the LSP
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

	Lsp_Inq(LspVect, DecStat->dPrevLsp, Line.LspId, Line.Crc);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Inq);
#endif // } DETAILED_DECODE_TIMINGS_ON

	// Interpolate the Lsp vectors
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

	Lsp_Int(QntLpc, LspVect, DecStat->dPrevLsp);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Int);
#endif // } DETAILED_DECODE_TIMINGS_ON

	/* Copy the LSP vector for the next frame */
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

	for ( i = 0 ; i < LpcOrder ; i ++ )
		DecStat->dPrevLsp[i] = LspVect[i] ;

	/* 
	 * In case of no erasure, update the interpolation gain memory.
	 * Otherwise compute the interpolation gain (Text: Section 3.10)
	 */

	if (DecStat->Ecount == 0)
	{
		g = (Line.Sfs[SubFrames-2].Mamp + Line.Sfs[SubFrames-1].Mamp) >> 1;
		DecStat->InterGain = FcbkGainTable[g];
	}
	else
		DecStat->InterGain = DecStat->InterGain*0.75f;

	// Regenerate the excitation
	for (i = 0; i < PitchMax; i++)
		Temp[i] = DecStat->dPrevExc[i];

	Dpnt = &Temp[PitchMax];

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwVariousD);
#endif // } DETAILED_DECODE_TIMINGS_ON

	if (DecStat->Ecount == 0)
	{
		for (i = 0; i < SubFrames; i++)
		{
			// Unpack fixed code book
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

			Fcbk_Unpk(Dpnt, Line.Sfs[i], Line.Olp[i>>1], i, DecStat->WrkRate);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFcbk_UnpkDTemp);
#endif // } DETAILED_DECODE_TIMINGS_ON

			// Reconstruct the excitation
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

			Decod_Acbk(AcbkCont, &Temp[SubFrLen*i], Line.Olp[i>>1],
			Line.Sfs[i].AcLg, Line.Sfs[i].AcGn, DecStat->WrkRate);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwDecod_AcbkDTemp);
#endif // } DETAILED_DECODE_TIMINGS_ON

			for (j = 0; j < SubFrLen; j++)
				Dpnt[j] = Dpnt[j]*2.0f + AcbkCont[j];

			Dpnt += SubFrLen;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			// Cumulate stats
			dwFcbk_UnpkD += dwFcbk_UnpkDTemp; dwFcbk_UnpkDTemp = 0;
			dwDecod_AcbkD+= dwDecod_AcbkDTemp; dwDecod_AcbkDTemp = 0;
#endif // } DETAILED_DECODE_TIMINGS_ON
		}

		// Save the Excitation
		for (j = 0; j < Frame; j++)
			DataBuff[j] = Temp[PitchMax+j];

		// Compute interpolation index, for future use in frame erasures
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

		DecStat->InterIndx = Comp_Info(Temp, Line.Olp[SubFrames/2-1]);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwComp_Info);
#endif // } DETAILED_DECODE_TIMINGS_ON

		// Reload back
		for (j = 0; j < PitchMax; j++)
			Temp[j] = DecStat->dPrevExc[j];
		for (j = 0; j < Frame; j++)
			Temp[PitchMax+j] = DataBuff[j];

#if 1 //do clipping
		/* Clip newly generated samples in Temp array */
		for(j = 0; j < Frame; j++)
		{
			//clip to +/- 32767.0 doing abs & compare with integer unit
			//if clipping is needed shift sign bit to use as lookup table index
#define FLTCLIP(x) \
			{\
			const float T[2] = {32767.0f, -32767.0f};\
			if ((asint(x) & 0x7fffffff) > asint(T[0]))\
			x = T[((unsigned)asint(x)) >> 31];\
			}

			FLTCLIP(Temp[PitchMax+j]);
		}
#endif //optclip
	}
	else
	{
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

		Regen(DataBuff, Temp, DecStat->InterIndx, DecStat->InterGain,
				DecStat->Ecount, &DecStat->Rseed);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwRegen);
#endif // } DETAILED_DECODE_TIMINGS_ON
	}

	// Update PrevExc for next frame
	for (j = 0; j < PitchMax; j++)
		DecStat->dPrevExc[j] = Temp[Frame+j];

	// Synthesis
	Dpnt = DataBuff;
	for (i = 0; i < SubFrames; i++)
	{
		// Synthesize output speech
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

		Synt(Dpnt, &QntLpc[i*LpcOrder], DecStat);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwSyntTemp);
#endif // } DETAILED_DECODE_TIMINGS_ON

		Dpnt += SubFrLen;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		// Cumulate stats
		dwSynt += dwSyntTemp; dwSyntTemp = 0;
#endif // } DETAILED_DECODE_TIMINGS_ON
	}

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	TIMER_STOP(bTimingThisFrame,dwStartLow,dwStartHigh,dwDecode);
#endif // } DECODE_TIMINGS_ON

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	if (bTimingThisFrame && (DecStat->dwStatFrameCount < DEC_TIMING_INFO_FRAME_COUNT))
	{
		pDecTimingInfo = &DecStat->DecTimingInfo[DecStat->dwStatFrameCount];
		pDecTimingInfo->dwDecode		= dwDecode;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		pDecTimingInfo->dwLine_Unpk		= dwLine_Unpk;
		pDecTimingInfo->dwLsp_Inq		= dwLsp_Inq;
		pDecTimingInfo->dwLsp_Int		= dwLsp_Int;
		pDecTimingInfo->dwVariousD		= dwVariousD;
		pDecTimingInfo->dwFcbk_UnpkD	= dwFcbk_UnpkD;
		pDecTimingInfo->dwDecod_AcbkD	= dwDecod_AcbkD;
		pDecTimingInfo->dwComp_Info		= dwComp_Info;
		pDecTimingInfo->dwRegen			= dwRegen;
		pDecTimingInfo->dwSynt			= dwSynt;
#endif // } DETAILED_DECODE_TIMINGS_ON
		DecStat->dwStatFrameCount++;
	}
	else
	{
		_asm int 3;
	}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

	return (Flag) True;
}

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
void OutputDecodeTimingStatistics(char * szFileName, DEC_TIMING_INFO * pDecTimingInfo, unsigned long dwFrameCount)
{
    FILE * pFile;
	DEC_TIMING_INFO * pTempDecTimingInfo;
	DEC_TIMING_INFO dtiTemp;
	int i;
	int iCount;

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	    goto done;

#if 0
	// Too verbose !!!
	/* Output the detail information
	*/
	fprintf(pFile,"\nDetail Timing Information\n");
	for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < dwFrameCount ; i++, pTempDecTimingInfo++ )
	{
		fprintf(pFile, "Frame %d Detail Timing Information\n", i);
		OutputDecTimingDetail(pFile, pTempDecTimingInfo);
	}
#endif

	/* Compute the total information
	*/
	memset(&dtiTemp, 0, sizeof(DEC_TIMING_INFO));
	iCount = 0;

	for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < dwFrameCount ; i++, pTempDecTimingInfo++ )
	{
		iCount++;
		dtiTemp.dwDecode		+= pTempDecTimingInfo->dwDecode;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		dtiTemp.dwLine_Unpk		+= pTempDecTimingInfo->dwLine_Unpk;
		dtiTemp.dwLsp_Inq		+= pTempDecTimingInfo->dwLsp_Inq;
		dtiTemp.dwLsp_Int		+= pTempDecTimingInfo->dwLsp_Int;
		dtiTemp.dwVariousD		+= pTempDecTimingInfo->dwVariousD;
		dtiTemp.dwFcbk_UnpkD	+= pTempDecTimingInfo->dwFcbk_UnpkD;
		dtiTemp.dwDecod_AcbkD	+= pTempDecTimingInfo->dwDecod_AcbkD;
		dtiTemp.dwComp_Info		+= pTempDecTimingInfo->dwComp_Info;
		dtiTemp.dwRegen			+= pTempDecTimingInfo->dwRegen;
		dtiTemp.dwSynt			+= pTempDecTimingInfo->dwSynt;
#endif // } DETAILED_DECODE_TIMINGS_ON
	}

	if (iCount > 0) 
	{
		/* Output the total information
		*/
		fprintf(pFile,"Total for %d frames\n", iCount);
		OutputDecTimingDetail(pFile, &dtiTemp);

		/* Compute the average
		*/
		dtiTemp.dwDecode		= (dtiTemp.dwDecode + (iCount / 2)) / iCount;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		dtiTemp.dwLine_Unpk		= (dtiTemp.dwLine_Unpk + (iCount / 2)) / iCount;
		dtiTemp.dwLsp_Inq		= (dtiTemp.dwLsp_Inq + (iCount / 2)) / iCount;
		dtiTemp.dwLsp_Int		= (dtiTemp.dwLsp_Int + (iCount / 2)) / iCount;
		dtiTemp.dwVariousD		= (dtiTemp.dwVariousD + (iCount / 2)) / iCount;
		dtiTemp.dwFcbk_UnpkD	= (dtiTemp.dwFcbk_UnpkD + (iCount / 2)) / iCount;
		dtiTemp.dwDecod_AcbkD	= (dtiTemp.dwDecod_AcbkD + (iCount / 2)) / iCount;
		dtiTemp.dwComp_Info		= (dtiTemp.dwComp_Info + (iCount / 2)) / iCount;
		dtiTemp.dwRegen			= (dtiTemp.dwRegen + (iCount / 2)) / iCount;
		dtiTemp.dwSynt			= (dtiTemp.dwSynt + (iCount / 2)) / iCount;
#endif // } DETAILED_DECODE_TIMINGS_ON

		/* Output the average information
		*/
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputDecTimingDetail(pFile, &dtiTemp);
	}

	fclose(pFile);
done:

    return;
}

void OutputDecTimingDetail(FILE * pFile, DEC_TIMING_INFO * pDecTimingInfo)
{
	unsigned long dwOther;
	unsigned long dwRoundUp;
	unsigned long dwDivisor;

	fprintf(pFile, "\tDecode =      %10u (%d milliseconds at 166Mhz)\n", pDecTimingInfo->dwDecode,
			(pDecTimingInfo->dwDecode + 83000) / 166000);
	dwOther = pDecTimingInfo->dwDecode;
	
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	/* This is needed because of the integer truncation.
	 */
	dwDivisor = pDecTimingInfo->dwDecode / 100; // to yield a percent
	dwRoundUp = dwDivisor / 2;
	
	if (dwDivisor)
	{
		fprintf(pFile, "\tLine_Unpk =   %10u (%2d%%)\n", pDecTimingInfo->dwLine_Unpk, 
				(pDecTimingInfo->dwLine_Unpk + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwLine_Unpk;
									   
		fprintf(pFile, "\tLsp_Inq =     %10u (%2d%%)\n", pDecTimingInfo->dwLsp_Inq, 
				(pDecTimingInfo->dwLsp_Inq + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwLsp_Inq;
									   
		fprintf(pFile, "\tLsp_Int =     %10u (%2d%%)\n", pDecTimingInfo->dwLsp_Int, 
				(pDecTimingInfo->dwLsp_Int + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwLsp_Int;
									   
		fprintf(pFile, "\tVariousD =    %10u (%2d%%)\n", pDecTimingInfo->dwVariousD, 
				(pDecTimingInfo->dwVariousD + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwVariousD;
									   
		fprintf(pFile, "\tFcbk_UnpkD =  %10u (%2d%%)\n", pDecTimingInfo->dwFcbk_UnpkD, 
				(pDecTimingInfo->dwFcbk_UnpkD + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwFcbk_UnpkD;
									   
		fprintf(pFile, "\tDecod_AcbkD = %10u (%2d%%)\n", pDecTimingInfo->dwDecod_AcbkD, 
				(pDecTimingInfo->dwDecod_AcbkD + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwDecod_AcbkD;
									   
		fprintf(pFile, "\tComp_Info =   %10u (%2d%%)\n", pDecTimingInfo->dwComp_Info, 
				(pDecTimingInfo->dwComp_Info + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwComp_Info;
									   
		fprintf(pFile, "\tRegen =       %10u (%2d%%)\n", pDecTimingInfo->dwRegen, 
				(pDecTimingInfo->dwRegen + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwRegen;
									   
		fprintf(pFile, "\tSynt =        %10u (%2d%%)\n", pDecTimingInfo->dwSynt, 
				(pDecTimingInfo->dwSynt + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwSynt;
									   
		fprintf(pFile, "\tOther =       %10u (%2d%%)\n", dwOther, 
				(dwOther + dwRoundUp) / dwDivisor);
	}
#endif // } DETAILED_DECODE_TIMINGS_ON

}
#endif // { LOG_DECODE_TIMINGS_ON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\isrg.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision:   1.0  $
      $Date:   11 Jun 1996 11:05:20  $
    $Author:   KMILLS  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

//
//	directions
//		Pick a number (mod 100) and create a base for the next 
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD	Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (32*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (60*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------
#define DBG 				0
#define ERR 				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the 
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
DllExport void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
TTDbgMsg 
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
DllExport void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

DllExport void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

DllExport void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

DllExport void WINAPI DLL_EXPORT
ISR_ClearItems (void);

DllExport UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

DllExport UINT WINAPI DLL_EXPORT
ISR_GetNumModules (void);

DllExport ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

DllExport ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

DllExport int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if (DEBUG >= 1) || (_DEBUG >= 1)
#define ISRDEBUGINFO	1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions
static void
InitModules (void);

static UINT
ValidCaptureMsg (WORD hISRInst, BYTE DbgLevel);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)

                                                      
//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26) 
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\g723.h ===
//==========================================================================;
//
//    INTEL Corporation Proprietary Information
//
//    This listing is supplied under the terms of a license
//    agreement with INTEL Corporation and may not be copied
//    nor disclosed except in accordance with the terms of
//    that agreement.
//
//    Copyright (c) 1996 Intel Corporation.
//    All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  g723.h
//
//  Description:
//      This file contains prototypes for the filtering routines.
//
//
//==========================================================================;
#include "cst_lbc.h"
#include "sdstruct.h"

#ifndef _G723_H_
#define _G723_H_

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#define  NETMEETING_MSG723_ACM_ID		82
#define  WAVE_FORMAT_MSG723				0x0042     /*  Microsoft Corporation  */
#define  G723MAGICWORD1					0xf7329ace
#define  G723MAGICWORD2					0xacdeaea2

typedef struct msg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} MSG723WAVEFORMAT;
typedef MSG723WAVEFORMAT       *PMSG723WAVEFORMAT;
typedef MSG723WAVEFORMAT NEAR  *NPMSG723WAVEFORMAT;
typedef MSG723WAVEFORMAT FAR   *LPMSG723WAVEFORMAT;

typedef struct {
    CODDEF  CodStat;
    INSTNCE SD_Instance;
} G723CODDEF;

#define RATE 0x1
#define POST_FILTER 0x2
#define SILENCE_ENABLE 0x4

//
//  array of sample rates supported
//
//
const UINT G723_SAMPLING_RATE[] =
{
    8000,
    8000,
    8000,
    8000
};
const UINT PCM_SAMPLING_RATE[] =
{
    11025,
    8000
};
const UINT G723_SAMPLES_PER_BLOCK_PCM[] =
{
    330,
    240
};

//
//
//
//
#define G723_MAX_CHANNELS       1
#define G723_BITS_PER_SAMPLE    0
#define G723_WFX_EXTRA_BYTES    (sizeof(MSG723WAVEFORMAT) - sizeof(WAVEFORMATEX))
#define G723_HEADER_LENGTH      0    // In bytes, per channel.

#ifdef G723_USECONFIG
#define G723_CONFIGTESTTIME     4   // seconds of PCM data for test.
#define G723_CONFIG_DEFAULT                             0x0000
#define G723_CONFIG_DEFAULT_MAXRTENCODESETTING          5
#define G723_CONFIG_DEFAULT_MAXRTDECODESETTING          6
#define G723_CONFIG_UNCONFIGURED                        0x0999
#define G723_CONFIG_TEXTLEN                             80
#define G723_CONFIG_DEFAULTKEY                          HKEY_CURRENT_USER
#define G723_CONFIG_MIN_ENCODE                          4
#define G723_CONFIG_MIN_DECODE                          5
#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures
#define	IDS_FORMAT_DETAILS_MONO_8KHZ_5333BIT_S (6)
#define	IDS_FORMAT_DETAILS_MONO_8KHZ_5333BIT_SID (7)
#define	IDS_FORMAT_DETAILS_MONO_8KHZ_6400BIT_S (8)
#define	IDS_FORMAT_DETAILS_MONO_8KHZ_6400BIT_SID (9)

#define IDS_ACM_DRIVER_TAG_NAME     (20)    // ACMFORMATTAGDETAILS.szFormatTag

#ifdef G723_USECONFIG
//
//  resource id's for the configuration dialog box
//

#define IDS_CONFIG_NORATES          (30)
#define IDS_CONFIG_ALLRATES         (31)
#define IDS_CONFIG_MONOONLY         (32)
#define IDS_CONFIG_STEREOONLY       (33)
#define IDS_CONFIG_MONOSTEREO       (34)
#define IDS_ERROR                   (35)
#define IDS_ERROR_NOMEM             (36)

#define IDD_CONFIG                      RCID(100)
#define IDC_BTN_AUTOCONFIG              1001
#define IDC_BTN_HELP                    1002
#define IDC_COMBO_MAXRTENCODE           1003
#define IDC_COMBO_MAXRTDECODE           1004
#define IDC_STATIC1                     1005
#define IDC_STATIC2                     1006
#define IDC_STATIC3                     1007

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _G723_H_


#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as 
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) & 
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
    
#ifdef _WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(1,  2, 1)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 50, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(2, 3, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
// 
//  Win 16/32 portability stuff...
// 
// 
// 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef _WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL __loadds
        #define FNEXPORT    FAR PASCAL __export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL __export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef _CRTAPI1
    #define _CRTAPI1    __cdecl
    #endif
    #ifndef _CRTAPI2
    #define _CRTAPI2    __cdecl
    #endif
    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)
    typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  Compilation options:
//
//      If G723_USECONFIG is defined, then the codec will be compiled
//      with a configuration dialog.  If not, then the codec will not be
//      configurable.  It is expected that the configuration is only
//      necessary for certain platforms...
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

//#define G723_USECONFIG


#ifdef G723_USECONFIG

//
//  See codec.c for a description of this structure and its use.
//
typedef struct tRATELISTFORMAT
{
    UINT        uFormatType;
    UINT        idsFormat;
    DWORD       dwMonoRate;
} RATELISTFORMAT;
typedef RATELISTFORMAT *PRATELISTFORMAT;

#define CONFIG_RLF_NONUMBER     1
#define CONFIG_RLF_MONOONLY     2
#define CONFIG_RLF_STEREOONLY   3
#define CONFIG_RLF_MONOSTEREO   4

#endif // G723_USECONFIG



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))

//
//
//
typedef BOOL FAR*   LPBOOL;


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwfx argument is a pointer to a WAVEFORMATEX structure.
//
#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))


#define FLOATTOSHORT(b) ((b < -32768.) ? (short)(-32768) : \
                        ((b >  32767.) ? (short)(32767)  : \
			((b <      0.) ? (short)(b-0.5)  : \
			                 (short)(b+0.5))))


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    DWORD           fdwConfig;      // stream instance configuration flags

    BOOL            enabled;        // driver enabled flag

#ifdef G723_USECONFIG    
    LPDRVCONFIGINFO pdci;
    HKEY            hkey;
    UINT            nConfigMaxRTEncodeSetting;
    UINT            nConfigMaxRTDecodeSetting;
    UINT    	    nConfigPercentCPU;
    BOOL            fHelpRunning;           // Used by config DlgProc only.
#ifdef WIN4
    HBRUSH          hbrDialog;              // Used by config DlgProc only.
#endif
#endif

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 


//
//  This define deals with unaligned data for Win32, and huge data for Win16.
//  Basically, any time you cast an HPBYTE to a non-byte variable (ie long or
//  short), you should cast it to ( {short,long} HUGE_T *).  This will cast
//  it to _huge for Win16, and make sure that there are no alignment problems
//  for Win32 on MIPS and Alpha machines.
//

typedef BYTE HUGE *HPBYTE;

#ifdef _WIN32
    #define HUGE_T  UNALIGNED
#else
    #define HUGE_T  _huge
#endif


//
//
//
//
typedef DWORD (FNGLOBAL *STREAMCONVERTPROC)
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst
//    UINT                    nBlockAlignment,
//    UINT                    cSamplesPerBlock,
//    int                 *   pnStepIndexL,
//    int                 *   pnStepIndexR
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags


} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;




//
//  global variables, etc...
//
#ifdef G723_USECONFIG

extern const UINT   gauFormatIndexToSampleRate[];
extern const UINT   ACM_DRIVER_MAX_SAMPLE_RATES;
extern const UINT   ACM_DRIVER_MAX_CHANNELS;
extern const RATELISTFORMAT gaRateListFormat[];
extern const UINT   G723_CONFIG_NUMSETTINGS;

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  function prototypes
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

void convert11to8(short *in, short *out, short *prev, int len);
void convert8to11(short *in, short *out, short *prev, int len);

#ifdef G723_USECONFIG

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE	    pdi,
    LPCTSTR		    pszAliasName
);

BOOL FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
);

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
);

LRESULT FNLOCAL acmdStreamConvert
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\lpc.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//
#include <stdio.h>
#include <math.h>
#include "opt.h"
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "coder.h"
#include "decod.h"
#include "util_lbc.h"
#include "lpc.h"

#include "mmxutil.h"


#define Dot10m(x,y) \
  ( (*x)*(*y) + (*((x)+1))*(*((y)+1)) + (*((x)+2))*(*((y)+2)) + \
   (*((x)+3))*(*((y)+3)) + (*((x)+4))*(*((y)+4)) + (*((x)+5))*(*((y)+5)) + \
   (*((x)+6))*(*((y)+6)) + (*((x)+7))*(*((y)+7)) + (*((x)+8))*(*((y)+8)) + \
   (*((x)+9))*(*((y)+9)) )

//-----------------------------------------------------------------
void  Comp_Lpc(float *UnqLpc, float *PrevDat, float *DataBuff, CODDEF *CodStat)
{
  int   i,j,k;

  float  Dpnt[Frame+LpcFrame-SubFrLen];
  float  Vect[LpcFrame];
  float  Corr[LpcOrder+1];

// Form Buffer

  for (i=0; i < LpcFrame-SubFrLen; i++)
    Dpnt[i] = PrevDat[i];
  for (i=0; i < Frame; i++)
    Dpnt[i+LpcFrame-SubFrLen] = DataBuff[i];

// Do for all the sub frames
  
  for (k=0; k < SubFrames; k++)
  {
// Copy the current window, multiply by Hamming window
    
    for (i = 0; i < LpcFrame; i++)
      Vect[i] = Dpnt[k*SubFrLen+i]*HammingWindowTable[i];

// Compute correlation coefficients

    for (i=0; i<=LpcOrder; i++)
      Corr[i] = DotProd(Vect, &Vect[i], LpcFrame-i)/(LpcFrame*LpcFrame) *
        BinomialWindowTable[i];

// Do Ridge regression

    Corr[0] *= (1025.0f/1024.0f);

    Durbin(&UnqLpc[k*LpcOrder], &Corr[1], Corr[0], CodStat);
  }
  /* Update sine detector */
    CodStat->SinDet &= 0x7fff ;

    j = CodStat->SinDet ;
    k = 0 ;
    for ( i = 0 ; i < 15 ; i ++ ) {
        k += j & 1 ;
        j >>= 1 ;
    }
    if ( k >= 14 )
        CodStat->SinDet |= 0x8000 ;

}

#if COMPILE_MMX

void  Comp_LpcInt(float *UnqLpc, float *PrevDat, float *DataBuff, CODDEF *CodStat)
{
  int   i,j,k;

  float  Dpnt[Frame+LpcFrame-SubFrLen];
  float  Vect[LpcFrame];
  float  Corr[LpcOrder+1];
  float  Fshift;

  int	mx, Tshift;

  DECLARE_SHORT(VectShrt,LpcFrame+32);
  DECLARE_INT(Temp,12);

  ALIGN_ARRAY(VectShrt);
  ALIGN_ARRAY(Temp);

// Form Buffer

  for (i=0; i < LpcFrame-SubFrLen; i++)
    Dpnt[i] = PrevDat[i];
  for (i=0; i < Frame; i++)
    Dpnt[i+LpcFrame-SubFrLen] = DataBuff[i];

// Do for all the sub frames
  
  for (k=0; k < SubFrames; k++)
  {
// Copy the current window, multiply by Hamming window
    
    for (i = 0; i < LpcFrame; i++)
      Vect[i] = Dpnt[k*SubFrLen+i]*HammingWindowTable[i];

// Compute correlation coefficients

    mx = FloatToShortScaled(Vect,VectShrt,LpcFrame,3);
	for(j=0; j<31; j++) VectShrt[LpcFrame+j]=0;
	Tshift = 30 - (6+2*(mx-126));
    if(mx==0) Tshift = 0;

	CorrCoeff01(VectShrt, &VectShrt[0], Temp, LpcFrame);
	CorrCoeff23(VectShrt, &VectShrt[0], &Temp[2], LpcFrame);
	CorrCoeff01(VectShrt, &VectShrt[4], &Temp[4], LpcFrame);
	CorrCoeff23(VectShrt, &VectShrt[4], &Temp[6], LpcFrame);
	CorrCoeff01(VectShrt, &VectShrt[8], &Temp[8], LpcFrame);
	CorrCoeff23(VectShrt, &VectShrt[8], &Temp[10],LpcFrame);
	
	Fshift = 2.0f;

	if(Tshift>=0){
		for(j=1; j<Tshift; j++) Fshift *= 2.0f;
		Fshift = 1.0f/Fshift;
	}
	else
	{
		Tshift=-Tshift;
		for(j=1; j<Tshift; j++) Fshift *= 2.0f;
	}

	
	for (i=0; i<LpcOrder; i+=2){
		Corr[i]  =((float)Temp[i])*Fshift*BinomialWindowTable[i]  /(LpcFrame*LpcFrame);
		Corr[i+1]=((float)Temp[i+1])*Fshift*BinomialWindowTable[i+1]/(LpcFrame*LpcFrame);
	}
	Corr[10]  =((float)Temp[10])*Fshift*BinomialWindowTable[10]  /(LpcFrame*LpcFrame);
	

// Do Ridge regression

    Corr[0] *= (1025.0f/1024.0f);

    Durbin(&UnqLpc[k*LpcOrder], &Corr[1], Corr[0], CodStat);
  }
  /* Update sine detector */
    CodStat->SinDet &= 0x7fff ;

    j = CodStat->SinDet ;
    k = 0 ;
    for ( i = 0 ; i < 15 ; i ++ ) {
        k += j & 1 ;
        j >>= 1 ;
    }
    if ( k >= 14 )
        CodStat->SinDet |= 0x8000 ;

}

#endif

//----------------------------------------------------
float Durbin(float *Lpc, float *Corr, float Err, CODDEF *CodStat)
{
  int  i,j;
  float  Temp[LpcOrder];
  float  Pk,Tmp0;

// Clear the result lpc vector

  for (i=0; i < LpcOrder; i++)
    Lpc[i] = 0.0f;

  for (i=0; i < LpcOrder; i++)
  {
    Tmp0 = Corr[i];
    for (j=0; j<i; j++)
      Tmp0 -= Lpc[j]*Corr[i-j-1];
    
    if (fabs(Tmp0) >= Err)
      break;
    
    Lpc[i] = Pk = Tmp0/Err;
    Err -= Tmp0*Pk;
    
    for (j=0; j < i; j++)
      Temp[j] = Lpc[j];

    for (j=0; j < i; j++)
      Lpc[j] = Lpc[j] - Pk*Temp[i-j-1];

	/*
     * Sine detector
     */
     if ( i == 1 ) 
     {
       CodStat->SinDet <<= 1 ;
	   if ( Pk > 0.95f)
           CodStat->SinDet ++ ;
     }

  }

// Lpc[] values * 2^13 corresponds to fixed-point values
  return Err;

}


//---------------------------------------------------------
void  Wght_Lpc(float *PerLpc, float *UnqLpc)
{
  int  i,j;

  for (i=0; i < SubFrames; i++)
  {
    for (j=0; j < LpcOrder; j++)
    {
      PerLpc[j]          = UnqLpc[j]*PerFiltZeroTable[j];
      PerLpc[j+LpcOrder] = UnqLpc[j]*PerFiltPoleTable[j];
    }
    PerLpc += 2*LpcOrder;
    UnqLpc += LpcOrder;
  }
}


//----------------------------------------------------------
void  Error_Wght(float *Dpnt, float *PerLpc,CODDEF *CodStat)
{
  int  i,k;

  float Acc0;


  for (k=0; k < SubFrames; k++)
  {
    for (i=0; i < SubFrLen; i++)
    {
// FIR part

      Acc0 = *Dpnt - Dot10m(PerLpc,&CodStat->WghtFirDl[CodStat->p]);

// IIR part
      
      Acc0 += Dot10m(&PerLpc[LpcOrder],&CodStat->WghtIirDl[CodStat->p]);

      CodStat->p = minus1mod10[CodStat->p];       
      CodStat->WghtFirDl[CodStat->p] =
        CodStat->WghtFirDl[CodStat->p + LpcOrder] = *Dpnt;

      *Dpnt++ = CodStat->WghtIirDl[CodStat->p] =
        CodStat->WghtIirDl[CodStat->p + LpcOrder] = Acc0;
    }
    PerLpc += 2*LpcOrder;
  }
}



//-----------------------------------------------------------------------
void  Comp_Ir(float *ImpResp, float *QntLpc, float *PerLpc, PWDEF Pw)
{
  int  i;

  float  FirDl[2*LpcOrder];
  float  IirDl[2*LpcOrder];
  float  Temp[PitchMax+SubFrLen];
  float  Acc0,Acc1;
  int    p = 9;

// Clear all
  
  for (i=0; i < 2*LpcOrder; i++)
    FirDl[i] = IirDl[i] = 0.0f;

  for (i=0; i < PitchMax+SubFrLen; i++)
    Temp[i] = 0.0f;

// Compute impulse response
  
  Acc0 = 0.5f;

  for (i=0; i < SubFrLen; i++)
  {
// Synthesis filter
    
    Acc1 = Acc0 + Dot10m(QntLpc,&FirDl[p]);

// FIR, IIR part

    Acc0 = Acc1 - Dot10m(PerLpc,&FirDl[p])
      + Dot10m(&PerLpc[LpcOrder],&IirDl[p]);

    p = minus1mod10[p];
    FirDl[p] = FirDl[p  + LpcOrder] = Acc1;
    Temp[PitchMax+i] = IirDl[p] = IirDl[p + LpcOrder] = Acc0;

// Harmonic part

    ImpResp[i] = Acc0 - Pw.Gain*Temp[PitchMax-Pw.Indx+i];
    
    Acc0 = 0.0f;
  }
}


//------------------------------------------------------------------
void  Sub_Ring(float *Dpnt, float *QntLpc, float *PerLpc, float
               *PrevErr, PWDEF Pw,CODDEF *CodStat)
{
  int  i;
  float Acc0,Acc1;

  float  FirDl[2*LpcOrder];
  float  IirDl[2*LpcOrder];
  float  Temp[PitchMax+SubFrLen];
  int    p = 9;


// Initialize the delay lines
  
  for (i=0; i < PitchMax; i++)
    Temp[i] = PrevErr[i];

  for (i=0; i < 2*LpcOrder; i++)
  {
    FirDl[i] = CodStat->RingFirDl[i];
    IirDl[i] = CodStat->RingIirDl[i];
  }

// Main loop
  
  for (i=0; i < SubFrLen; i++)
  {
// Synthesis filter
    
    Acc1 = Acc0 = Dot10m(QntLpc,&FirDl[p]);

// FIR, IIR part
    
    Acc0 -= Dot10m(PerLpc,&FirDl[p]);
    Acc0 += Dot10m(&PerLpc[LpcOrder],&IirDl[p]);

    p = minus1mod10[p];
    FirDl[p] = FirDl[p + LpcOrder] = Acc1;
    Temp[PitchMax+i] = IirDl[p] = IirDl[p + LpcOrder] =  Acc0;

// Harmonic Part
    
    Dpnt[i] -= Acc0 - Pw.Gain*Temp[PitchMax-Pw.Indx+i];
  }
}


//-----------------------------------------------------------------
void  Upd_Ring(float *Dpnt, float *QntLpc, float *PerLpc, float
               *PrevErr, CODDEF *CodStat)
{
  int  i;

  float  Acc0,Acc1;

// Shift the PrevErr buffer
 
  for (i=SubFrLen; i < PitchMax; i++)
    PrevErr[i-SubFrLen] = PrevErr[i];

// Update the ring delay and PrevErr buffer 

  for (i=0; i < SubFrLen; i++) 
  {
// Synt filter 

    Acc1 = Acc0 = Dpnt[i] += Dot10m(QntLpc,&CodStat->RingFirDl[CodStat->q])*2.0f;

// Fir,Iir filter
 
    Acc0 -= Dot10m(PerLpc,&CodStat->RingFirDl[CodStat->q])*2.0f;
    Acc0 += Dot10m(&PerLpc[LpcOrder],&CodStat->RingIirDl[CodStat->q])*2.0f;

    CodStat->q = minus1mod10[CodStat->q];
    CodStat->RingFirDl[CodStat->q] =
      CodStat->RingFirDl[CodStat->q + LpcOrder] =  Acc1*0.5f;
    PrevErr[PitchMax-SubFrLen+i] = CodStat->RingIirDl[CodStat->q] =
      CodStat->RingIirDl[CodStat->q + LpcOrder] = Acc0*0.5f;
  }
}


//----------------------------------------------------
void Synt(float *Dpnt, float *Lpc, DECDEF *DecStat)
{
   int   i;

   float   Acc0  ;

   for (i=0 ; i < SubFrLen ; i++)
   {
     Acc0 = Dpnt[i] + Dot10m(Lpc,&DecStat->SyntIirDl[DecStat->dq]);

     DecStat->dq = minus1mod10[DecStat->dq];
     Dpnt[i] = DecStat->SyntIirDl[DecStat->dq] =
       DecStat->SyntIirDl[DecStat->dq + LpcOrder] = Acc0;
   }
}


//----------------------------------------------------
//Spf

#if COMPILE_MMX

void CorrCoeff01(short *samples, short *samples_offst, int *coeff, int buffsz)
{

#define reg0  mm0
#define reg1  mm1
#define reg2  mm2

#define reg3  mm3
#define reg4  mm4
#define reg5  mm5

#define acc0  mm6
#define acc1  mm7

#define s    esi
#define t    edi
#define cnt	 ecx
#define c0	 eax

#define  L1(i,r0)	ASM movq  reg##r0,QP[t+8*cnt+8*i]
#define  L2(i,r0)	ASM movq  reg##r0,QP[t+8*cnt+8+8*i]
#define  C1(r0,r1)  ASM movq  reg##r0,reg##r1
#define  M1(i,r0)	ASM pmaddwd reg##r0,QP[s+8*cnt+8*i]
#define  M2(i,r0)	ASM pmaddwd reg##r0,QP[s+8*cnt+8*i]
#define  O1(r0,r1)	ASM por reg##r0,reg##r1
#define  A1(r0)		ASM paddd acc0,reg##r0
#define  A2(r0)		ASM paddd acc1,reg##r0
#define  S1(r0)    ASM psrlq reg##r0,16
#define  S2(r0)    ASM psllq reg##r0,48

  ASM
  {
	mov c0, coeff;

	mov s,samples;
	mov t,samples_offst;

	mov cnt,buffsz;
	//assume that mod(buffsz,4)=0
	//this is very dangerous!!
	shr cnt,2;
	sub cnt,1;

	pxor acc0,acc0;
	pxor acc1,acc1;
	pxor reg2,reg2;
	pxor reg0,reg0;
	pxor reg3,reg3;
	pxor reg4,reg4;
	pxor reg5,reg5;
  }
			
looptop:
//----------------------------------
				 L2(1,5)
				 S1(4)
				 M1(1,3)
				 S2(5)
	   L1(0,0)
				 O1(5,4)
				 M2(1,5)
	   A2(2)
	   L2(0,2)
	   C1(1,0)
	   M1(0,0)
	   S1(1)
	   S2(2)
ASM						 sub cnt,2;
	   O1(2,1)
				 A1(3)
				 L1(1,3)
				 A2(5)
	   M2(2,2)
				 C1(4,3)
	   A1(0)
ASM						 jge looptop;
//----------------------------------
			
  ASM
  {
	movq  reg0,acc0;
    psrlq acc0,32;
    paddd acc0,reg0;
	movd  DP[c0],acc0;

	movq  reg1,acc1;
    psrlq acc1,32;
    paddd acc1,reg1;
	movd  DP[c0+4],acc1;

    emms;
  }  

}
#undef reg0
#undef reg1
#undef reg2
#undef acc0
#undef acc1
#undef cnt
#undef tmp

#undef L1
#undef L2
#undef C1
#undef M1
#undef M2
#undef A1
#undef A2
#undef S1
#undef S2
#undef O1


#else

void CorrCoeff01(short *samples, short *samples_offst, int *coeff, int buffsz)
{
 int i,j;
 int Acc0;

 for(i=0; i<=1; i++){
	Acc0=0;
	for(j=0; j<LpcFrame; j++)
		Acc0 += samples[j]*samples_offst[j+i];

	*coeff++ = Acc0;
 }
 
 
}
#endif 


#if COMPILE_MMX

void CorrCoeff23(short *samples, short *samples_offst, int *coeff, int buffsz)
{

#define reg0  mm0
#define reg1  mm1
#define reg2  mm2

#define reg3  mm3
#define reg4  mm4
#define reg5  mm5

#define acc0  mm6
#define acc1  mm7

#define s    esi
#define t    edi
#define cnt	 ecx
#define c0	 eax

#define  L1(i,r0)	ASM movq  reg##r0,QP[t+8*cnt+8*i]
#define  L2(i,r0)	ASM movq  reg##r0,QP[t+8*cnt+8+8*i]
#define  C1(r0,r1)  ASM movq  reg##r0,reg##r1
#define  M1(i,r0)	ASM pmaddwd reg##r0,QP[s+8*cnt+8*i]
#define  M2(i,r0)	ASM pmaddwd reg##r0,QP[s+8*cnt+8*i]
#define  O1(r0,r1)	ASM por reg##r0,reg##r1
#define  O2(r0,r1)	ASM por reg##r0,reg##r1
#define  A1(r0)		ASM paddd acc0,reg##r0
#define  A2(r0)		ASM paddd acc1,reg##r0
#define  S1(r0)     ASM psrlq reg##r0,48
#define  S2(r0)     ASM psllq reg##r0,16
#define  S3(r0)     ASM psrlq reg##r0,32
#define  S4(r0)     ASM psllq reg##r0,16

  ASM
  {
	mov c0, coeff;

	mov s,samples;
	mov t,samples_offst;

	mov cnt,buffsz;
	//assume that mod(buffsz,4)=0
	//this is very dangerous!!
	shr cnt,2;
	sub cnt,1;

	pxor acc0,acc0;
	pxor acc1,acc1;
	pxor reg2,reg2;
	pxor reg1,reg1;
	pxor reg0,reg0;
	pxor reg3,reg3;
	pxor reg4,reg4;
	pxor reg5,reg5;
  }
			
looptop:
//----------------------------------
	  O1(0,2)
	  S3(1)
	  M1(1,0)
				 A2(5)
				 L1(0,3)
	  S4(2)
				 L2(0,5)
	  O2(2,1)
	  M2(1,2)
				 C1(4,3)
				 S1(3)
	  A1(0)
				 S2(5)
ASM						  sub cnt,2;				 
				 
				 O1(3,5)
				 S3(4)
				 M1(2,3)
	  A2(2)
	  L1(1,0)
				 S4(5)
	  L2(1,2)
				 O2(5,4)
				 M2(2,5)
	  C1(1,0)
	  S1(0)
				 A1(3)
	  S2(2)
ASM						  jge looptop;
//------------------------------------
			
  ASM
  {
	movq  reg0,acc1;
    psrlq acc1,32;
    paddd acc1,reg0;
	movd  DP[c0],acc1;

	movq  reg1,acc0;
    psrlq acc0,32;
    paddd acc0,reg1;
	movd  DP[c0+4],acc0;

    emms;
  }  

}
#undef reg0
#undef reg1
#undef reg2
#undef acc0
#undef acc1
#undef cnt
#undef tmp

#undef L1
#undef L2
#undef C1
#undef M1
#undef M2
#undef A1
#undef A2
#undef S1
#undef S2
#undef S3
#undef S4
#undef O1
#undef O2


#else

void CorrCoeff23(short *samples, short *samples_offst, int *coeff, int buffsz)
{
 int i,j;
 int Acc0;

 for(i=2; i<=3; i++){
	Acc0=0;
	for(j=0; j<LpcFrame; j++)
		Acc0 += samples[j]*samples_offst[j+i];

    *coeff++ = Acc0;
 }	
	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\g723.c ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
**  codec.c
**
**  Description:
**      This file contains the ACM wrapper code for the G.723.1 compressor.
**
**
****************************************************************************
*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
//#include <mmddk.h>
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "g723.h"
#include "debug.h"
//#include "cst_lbc.h"
#include "coder.h"
#include "decod.h"
#include "sdstuff.h"
#include "float.h"
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
#include "isrg.h"
#endif // } NO_DEBUGGING_OUTPUT
#endif

const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_MSG723
};

#define ACM_DRIVER_MAX_FORMAT_TAGS      SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS      0


//
//  Required by config.c as well as codec.c.
//

#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM  1
#define ACM_DRIVER_MAX_BITSPERSAMPLE_G723 0

//extern void 	glblSDinitialize(CODDEF *CodStat);
//extern void 	prefilter(CODDEF *CodStat,int bufsize);
//extern void 	getParams(CODDEF *CodStat,int buffersize);
//extern int  	initializeSD(CODDEF *CodStat);
//extern int 		silenceDetect(CODDEF *CodStat);
//extern void		execSDloop(CODDEF *CodStat, int *isFrameSilent);
//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_FORMATS_PCM     2

#define ACM_DRIVER_MAX_FORMATS_G723    2


//==========================================================================;
//
//
//
//
//==========================================================================;
static float SDThreashold = 5.0f;		// silence converter threashold.
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
static WORD ghISRInst = 0;
#endif // } NO_DEBUGGING_OUTPUT
#endif
//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//                                        
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef _WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // _WIN32


//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that we can deal with.  Right now we are limited to an 8k
//      sampling rate.  That should go to 8 and 11 shortly.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
  int i;

    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm wave format tag:  %d",
	      pwfx->wFormatTag);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }

//
//  verify nChannels member is within the allowed range
//
    if ((pwfx->nChannels != G723_MAX_CHANNELS) )
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm channels:  %d",pwfx->nChannels);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  only allow the bits per sample that we can encode and decode with
//
    if (16 != pwfx->wBitsPerSample )
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm bits per sample:  %d",
	      pwfx->wBitsPerSample);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  only allow supported sampling rates
//
    for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
      if (pwfx->nSamplesPerSec == PCM_SAMPLING_RATE[i])
	break;

    if (i == ACM_DRIVER_MAX_FORMATS_PCM)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm sampling rate:  %d",
	      pwfx->nSamplesPerSec);
#endif // } NO_DEBUGGING_OUTPUT
#endif
      return(FALSE);
    }
//
//  now verify that the block alignment is correct..
//
    if (PCM_BLOCKALIGNMENT(pwfx) != pwfx->nBlockAlign)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm block alignment:  %d",
	      pwfx->nBlockAlign);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  finally, verify that avg bytes per second is correct
//
    if (PCM_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm avg bytes per sec:  %d",
	      pwfx->nAvgBytesPerSec);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
    return (TRUE);
}


//--------------------------------------------------------------------------;
//
//  BOOL G723IsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid 
//      G.723.1 header that this ACM driver can deal with.
//  
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL g723IsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
//	LPMSG723WAVEFORMAT		pwfg723;

    if (NULL == pwfx)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 format structure pointer");
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
    if (WAVE_FORMAT_MSG723 != pwfx->wFormatTag)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 format tag:  %d",
	      pwfx->wFormatTag);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  check wBitsPerSample
//
    if (G723_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 bits per sample:  %d",
	      pwfx->wBitsPerSample);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  check channels
//
    if (pwfx->nChannels != G723_MAX_CHANNELS)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 channels:  %d",
	      pwfx->nChannels);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  Check block alignment - must be an integral number of DWORDs for
//  mono, or an even number of DWORDs for stereo.
//
    if( 0 != pwfx->nBlockAlign % (sizeof(DWORD)) )
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 block alignment:  %d",
	      pwfx->nBlockAlign);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return FALSE;
    }
    if (G723_WFX_EXTRA_BYTES != pwfx->cbSize)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 extra bytes:  %d",
	      pwfx->cbSize);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//	pwfg723 = (LPMSG723WAVEFORMAT)pwfx;

    return (TRUE);
}


//--------------------------------------------------------------------------;
//  
//  UINT g723BlockAlign
//  
//  Description:
//      This function computes the standard block alignment that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid G723 format
//      and that the following fields in the format structure are valid:
//
//          nChannels
//          nSamplesPerSec
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//  
//  Return (UINT):
//      The return value is the block alignment that should be placed in
//      the pwfx->nBlockAlign field.
//
//--------------------------------------------------------------------------;

UINT FNLOCAL g723BlockAlign
(
    LPMSG723WAVEFORMAT         pwfg723
)
{
    UINT                uBlockAlign;

	if((pwfg723->wConfigWord&RATE) == Rate63)
    	uBlockAlign  = 24;
	else uBlockAlign = 20;

    return (uBlockAlign);

}



//--------------------------------------------------------------------------;
//  
//  UINT g723AvgBytesPerSec
//  
//  Description:
//      This function computes the Average Bytes Per Second (decoded!)
//      that should be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid g723 format
//      and that the following fields in the format structure are valid:
//
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//  
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL g723AvgBytesPerSec
(
    LPWAVEFORMATEX          pwfx
)
{
  int i;
  DWORD               dwAvgBytesPerSec;


//
//  compute bytes per second including header bytes
//
    dwAvgBytesPerSec = (pwfx->nSamplesPerSec * pwfx->nBlockAlign)
                       / G723_SAMPLES_PER_BLOCK_PCM[0];

    for(i=1;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
      if (pwfx->nSamplesPerSec == PCM_SAMPLING_RATE[i])
	dwAvgBytesPerSec = (pwfx->nSamplesPerSec * pwfx->nBlockAlign)
                           /  G723_SAMPLES_PER_BLOCK_PCM[i];

    return (dwAvgBytesPerSec);
}


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

//
//  the [optional] open description that is passed to this driver can
//  be from multiple 'managers.' for example, AVI looks for installable
//  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
//  that we are being opened as an Audio Compression Manager driver.
//
//  if paod is NULL, then the driver is being opened for some purpose
//  other than converting (that is, there will be no stream open
//  requests for this instance of being opened). the most common case
//  of this is the Control Panel's Drivers option checking for config
//  support (DRV_[QUERY]CONFIGURE).
//
//  we want to succeed this open, but be able to know that this
//  open instance is bogus for creating streams. for this purpose we
//  leave most of the members of our instance structure that we 
//  allocate below as zero...
//

  // for some reason, floating point exceptions will crash Win9x
  // machines.  They should be getting ignored.  The only work-around
  // is to call _fpreset to force the floating point control word to
  // be reinitialized
    _fpreset();

    if (NULL != paod)
    {
//
//  refuse to open if we are not being opened as an ACM driver.
//  note that we do NOT modify the value of paod->dwError in this
//  case.
//
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
            return (0L);
    }


//
//  we are being opened as an installable driver--we can allocate some
//  instance data to be returned in dwId argument of the DriverProc;
//  or simply return non-zero to succeed the open.
//
//  this driver allocates a small instance structure. note that we
//  rely on allocating the memory as zero-initialized!
//
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
//
//  if this open attempt was as an ACM driver, then return the
//  reason we are failing in the open description structure..
//
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        return (0L);
    }

#ifdef NOTPRODUCT
    pdi->enabled        = TRUE;
#else
    pdi->enabled        = FALSE;
#endif

    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;

        paod->dwError     = MMSYSERR_NOERROR;
    }


#ifdef G723_USECONFIG
//
// Get config info for this driver.  If we're not passed an
// ACMDRVOPENDESC structure then we'll assume we are being
// opened for configuration and will put off getting the config
// info until we receive the DRV_CONFIGURE message.  Otherwise we
// get the config info now using the alias passed through the
// ACMDRVOPENDESC structure.
//
    pdi->hkey = NULL;           // This is important!

    if (NULL != paod)
    {
#if defined(_WIN32) && !defined(UNICODE)
//
//  We must translate the UNICODE alias name to an ANSI version
//  that we can use.
//
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, paod->pszAliasName,-1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAllocPtr( GPTR, iLen );
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, paod->pszAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFreePtr( lpstr );
	    }
#else
    	acmdDriverConfigInit(pdi, paod->pszAliasName);
#endif // _WIN32 && !UNICODE
    }
#else
//
//  Actually, fdwConfig is not used - there is no configuration data.
//
	pdi->fdwConfig    = 0L;
#endif // G723_USECONFIG

//
//  non-zero return is success for DRV_OPEN
//
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
    ISRREGISTERMODULE(&ghISRInst,"G723ACM","G.723.1 ACM Driver");
    TTDBG(ghISRInst,TT_TRACE,"Driver Opened");
#endif // } NO_DEBUGGING_OUTPUT
#endif

    return ((LRESULT)(UINT)pdi);
}


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
#ifdef G723_USECONFIG
//
//  Release the registry key, if we allocated one.
//
    if( NULL != pdi->hkey )
    {
        (void)RegCloseKey( pdi->hkey );
    }
#endif

//
//  check to see if we allocated instance data. if we did not, then
//  immediately succeed.
//
    if (NULL != pdi)
    {
//
//  close down the driver instance. this driver simply needs
//  to free the instance data structure... note that if this 
//  'free' fails, then this ACM driver probably trashed its
//  heap; assume we didn't do that.
//
        LocalFree((HLOCAL)pdi);
    }

    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.  
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires 
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
//    int         n;

    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
#ifdef G723_USECONFIG
        //
        //  this ACM driver supports a configuration dialog box, so
        //  return non-zero...
        //
        return (1L);

#else
    return(0L);
#endif
    }

//
//  we are being asked to bring up our configuration dialog. if this
//  driver supports a configuration dialog box, then after the dialog
//  is dismissed we must return one of the following values:
//
//  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//  and canceled by the user. this value should also be returned if
//  no configuration information was modified.
//
//  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//  the user pressed OK.  This value should be returned even if the
//  user didn't change anything - otherwise, the driver may not
//  install properly.  
//
//  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//  and some configuration information was changed that requires 
//  Windows to be restarted before the changes take affect. the driver
//  should remain configured with current values until the driver
//  has been 'rebooted'.
//
#ifdef G723_USECONFIG
    if (NULL == pdci)
    {
        //
        //  !!!
        //
        DPF(2,"acmdDriverConfigure returning CANCEL due to NULL==pdci.");
        return (DRVCNF_CANCEL);
    }

    pdi->pdci = pdci;

//
// We may not have our config info yet if the driver has only been
// opened specifically for configuration.  So, read our configuration
// using the alias passed in the DRVCONFIGINFO structure passed
// through the DRV_CONFIGURE message
//
#if (defined(_WIN32) && !defined(UNICODE))
    {
    //
    //  We must translate the UNICODE alias name to an ANSI version
    //  that we can use.
    //
    	LPSTR	lpstr;
        int     iLen;

//
//  Calculate required length without calling UNICODE APIs or CRT.
//
        iLen  = WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, -1,
                NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAllocPtr( GPTR, iLen );
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFreePtr( lpstr );
	    }
    }
#else
    acmdDriverConfigInit(pdi, pdci->lpszDCIAliasName);
#endif // _WIN32 && !UNICODE

    n = DialogBoxParam(pdi->hinst,
                       IDD_CONFIG,
                       hwnd,
                       acmdDlgProcConfigure,
                       (LPARAM)(UINT)pdi);

    pdi->pdci = NULL;

    return ((LRESULT)n);
#else
    return(DRVCNF_CANCEL);
#endif // G723_USECONFIG

}


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to 
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

//
//  it is easiest to fill in a temporary structure with valid info
//  and then copy the requested number of bytes to the destination
//  buffer.
//
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


//
//  for the current implementation of an ACM driver, the fccType and
//  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
//  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
//
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


//
//  the manufacturer id (wMid) and product id (wPid) must be filled
//  in with your company's _registered_ identifier's. for more
//  information on these identifier's and how to get them registered
//  contact Microsoft and get the Multimedia Developer Registration Kit:
//
//      Microsoft Corporation
//      Multimedia Technology Group
//      One Microsoft Way
//      Redmond, WA 98052-6399
//
//      Developer Services Phone: (800) 227-4679 x11771
//
//  note that during the development phase or your ACM driver, you may
//  use the reserved value of '0' for both wMid and wPid. however it
//  is not acceptable to ship a driver with these values.
//
    add.wMid            = MM_MICROSOFT;
    add.wPid            = NETMEETING_MSG723_ACM_ID;


//
//  the vdwACM and vdwDriver members contain version information for
//  the driver.
//
//  vdwACM: must contain the version of the *ACM* that the driver was
//  _designed_ for. this is the _minimum_ version number of the ACM
//  that the driver will work with. this value must be >= V2.00.000.
//
//  vdwDriver: the version of this ACM driver.
//
//  ACM driver versions are 32 bit numbers broken into three parts as
//  follows (note these parts are displayed as decimal values):
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


//
//  the following flags are used to specify the type of conversion(s)
//  that the ACM driver supports. note that a driver may support one or
//  more of these flags in any combination.
//
//  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver 
//  supports conversions from one format tag to another format tag. for
//  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
//  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
//  true even if the data is not actually changed in size--for example
//  a conversion from u-Law to A-Law will still set this bit because
//  the format tags differ.
//
//  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
//  driver supports conversions on the same format tag. as an example,
//  the PCM converter that is built into the ACM sets this bit (and only
//  this bit) because it converts only between PCM formats (bits, sample
//  rate).
//
//  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver 
//  supports transformations on a single format tag but does change
//  the base characteristics of the format (bit depth, sample rate, etc
//  will remain the same). for example, a driver that changed the
//  'volume' of PCM data or applied a low pass filter would set this bit.
//
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;

//
//  the number of individual format tags this ACM driver supports. for
//  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
//  WAVE_FORMAT_PCM format tags, then this value would be two. if the
//  driver only supports filtering on WAVE_FORMAT_PCM, then this value
//  would be one. if this driver supported WAVE_FORMAT_ALAW,
//  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
//  three. etc, etc.
//
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

//
//  the number of individual filter tags this ACM driver supports. if
//  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
//  NOT set in the fdwSupport member), then this value must be zero.
//
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


//
//  the remaining members in the ACMDRIVERDETAILS structure are sometimes
//  not needed. because of this we make a quick check to see if we
//  should go through the effort of filling in these members.
//
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
//
//  fill in the hicon member will a handle to a custom icon for
//  the ACM driver. this allows the driver to be represented by
//  an application graphically (usually this will be a company
//  logo or something). if a driver does not wish to have a custom
//  icon displayed, then simply set this member to NULL and a
//  generic icon will be displayed instead.
//
//  See the MSFILTER sample for a codec which contains a custom icon.
//
        add.hicon = NULL;

//
//  the short name and long name are used to represent the driver
//  in a unique description. the short name is intended for small
//  display areas (for example, in a menu or combo box). the long
//  name is intended for more descriptive displays (for example,
//  in an 'about box').
//
//  NOTE! an ACM driver should never place formatting characters
//  of any sort in these strings (for example CR/LF's, etc). it
//  is up to the application to format the text.
//
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

//
//  the last three members are intended for 'about box' information.
//  these members are optional and may be zero length strings if
//  the driver wishes.
//
//  NOTE! an ACM driver should never place formatting characters
//  of any sort in these strings (for example CR/LF's, etc). it
//  is up to the application to format the text.
//
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


//
//  now copy the correct number of bytes to the caller's buffer
//
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


//
//  success!
//
    return (MMSYSERR_NOERROR);
}


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or  
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
//
//  first check to see if we are only being queried for custom about
//  box support. if hwnd == (HWND)-1 then we are being queried and
//  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
//  MMSYSERR_NOERROR for 'supported'.
//
    if ((HWND)-1 == hwnd)
    {
//
//  this ACM driver does NOT support a custom about box, so
//  return MMSYSERR_NOTSUPPORTED...
//
        return (MMSYSERR_NOTSUPPORTED);
    }


//
//  this driver does not support a custom dialog, so tell the ACM or
//  calling application to display one for us. note that this is the
//  _recommended_ method for consistency and simplicity of ACM drivers.
//  why write code when you don't have to?
//
    return (MMSYSERR_NOTSUPPORTED);
} 


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
	LPMSG723WAVEFORMAT		pwfg723;
    DWORD                   fdwSuggest;
    int i;

//
//  grab the suggestion restriction bits and verify that we support
//  the ones that are specified... an ACM driver must return the
//  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
//  are not supported.
//
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


//
//  get the source and destination formats in more convenient variables
//
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;
    

//
//
//
//
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
//
//  strictly verify that the source format is acceptable for
//  this driver
//
            if (!pcmIsValidFormat(pwfxSrc))
                break;

//
//  if the destination format tag is restricted, verify that
//  it is within our capabilities...
//
//  this driver is only able to encode to G.723.1
//
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_MSG723 != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_MSG723;
            }

//
//  if the destination channel count is restricted, verify that
//  it is within our capabilities...
//
//  this driver is not able to handle more than 1 channel
//
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != G723_MAX_CHANNELS)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = G723_MAX_CHANNELS;
            }

//
//  if the destination samples per second is restricted, verify
//  that it is within our capabilities...
//
//  G.723.1 is designed for 8000 Hz sampling rate
//
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxDst->nSamplesPerSec != 8000)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = 8000;
            }

//
//  if the destination bits per sample is restricted, verify
//  that it is within our capabilities...
//
		    if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (G723_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = G723_BITS_PER_SAMPLE;
            }


//
//  at this point, we have filled in all fields except the
//  following for our 'suggested' destination format:
//
//      nAvgBytesPerSec
//      nBlockAlign
//      cbSize
//
//      wSamplesPerBlock    ->  G723 extended information
//
			pwfg723 = (LPMSG723WAVEFORMAT)pwfxDst;
			pwfg723->wConfigWord        = Rate63;

            pwfxDst->nBlockAlign     = g723BlockAlign(pwfg723);
            pwfxDst->nAvgBytesPerSec = g723AvgBytesPerSec(pwfxDst);
            pwfxDst->cbSize          = G723_WFX_EXTRA_BYTES;


            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_MSG723:
//
//  strictly verify that the source format is acceptable for
//  this driver
//
            if (!g723IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);
      

//
//  if the destination format tag is restricted, verify that
//  it is within our capabilities...
//
//  this driver is only able to decode to PCM
//
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_PCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
            }


//
//  if the destination channel count is restricted, verify that
//  it is within our capabilities...
//
//  this driver is not able to change the number of channels
//
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != G723_MAX_CHANNELS)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = G723_MAX_CHANNELS;
            }

//
//  if the destination samples per second is restricted, verify
//  that it is within our capabilities...
//
//  G.723.1 produces PCM at 8000 Hz sampling rate
//
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
	      for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		if (pwfxDst->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  break;

	      if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		return (ACMERR_NOTPOSSIBLE);

	      pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }
            else
            {
	      //
	      // 11025 is the default since it is more common
	      // in the PC world than 8000.  Moreover, this
	      // prevents applications like MS Sound Recorder
	      // from using a low quality SRC in certain cases.
	      //
	      pwfxDst->nSamplesPerSec = 11025;
            }

//
//  if the destination bits per sample is restricted, verify
//  that it is within our capabilities...
//
//  this driver is only able to decode to 16 bit
//
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (16 != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = 16;
            }


//
//  at this point, we have filled in all fields except the
//  following for our 'suggested' destination format:
//
//      nAvgBytesPerSec
//      nBlockAlign
//      cbSize              !!! not used for PCM !!!
//
            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                       pwfxDst->nBlockAlign;

        // pwfxDst->cbSize       = not used;
	
            return (MMSYSERR_NOERROR);
    }


//
//  can't suggest anything because either the source format is foreign
//  or the destination format has restrictions that this ACM driver
//  cannot deal with.
//
    return (ACMERR_NOTPOSSIBLE);
}


//--------------------------------------------------------------------------;
//  
//  LRESULT acmdFormatTagDetails
//  
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//  
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a 
            //  non-existant format.  return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_MSG723:
                    uFormatTag = WAVE_FORMAT_MSG723;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_MSG723:
                    uFormatTag = WAVE_FORMAT_MSG723;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0]   =  '\0';
            break;

        case WAVE_FORMAT_MSG723:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_MSG723;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      G723_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_G723;

            LoadStringCodec(pdi->hinst,
			 IDS_ACM_DRIVER_TAG_NAME,
			 padft->szFormatTag,
			 SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));

    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//  
//  LRESULT acmdFormatDetails
//  
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//  
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member 
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//  
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX          pwfx;
    LPMSG723WAVEFORMAT		pwfg723;

    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            pwfx = padf->pwfx;

            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (padf->dwFormatIndex >= ACM_DRIVER_MAX_FORMATS_PCM)
		      return (ACMERR_NOTPOSSIBLE);

                    pwfx->nSamplesPerSec
		      = PCM_SAMPLING_RATE[padf->dwFormatIndex]; 

                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

                    pwfx->nChannels       = 1;
                    pwfx->wBitsPerSample  = 16; 

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;
                    break;

        
                case WAVE_FORMAT_MSG723:
                    if (padf->dwFormatIndex >= ACM_DRIVER_MAX_FORMATS_G723)
		      return (ACMERR_NOTPOSSIBLE);

                    pwfx->wFormatTag      = WAVE_FORMAT_MSG723;

                    pwfx->nSamplesPerSec
		      = G723_SAMPLING_RATE[padf->dwFormatIndex]; 

                    pwfx->nChannels       = G723_MAX_CHANNELS;
                    pwfx->wBitsPerSample  = G723_BITS_PER_SAMPLE;
                    pwfg723				  = (LPMSG723WAVEFORMAT)pwfx;

		    if(padf->dwFormatIndex == 0)
		    {
		      pwfx->nBlockAlign     = 24;
		      pwfx->nAvgBytesPerSec = 800;
		      pwfg723->wConfigWord  = Rate63+POST_FILTER;
		    }
		    if(padf->dwFormatIndex == 1)
		    {
		      pwfx->nBlockAlign     = 20;
		      pwfx->nAvgBytesPerSec = 666;
		      pwfg723->wConfigWord  = Rate53+POST_FILTER;
		    }
		    if(padf->dwFormatIndex == 2)
		    {
		      pwfx->nBlockAlign     = 24;
		      pwfx->nAvgBytesPerSec = 800;
		      pwfg723->wConfigWord=Rate63+POST_FILTER+SILENCE_ENABLE;
		    }
		    if(padf->dwFormatIndex == 3)
		    {
		      pwfx->nBlockAlign     = 20;
		      pwfx->nAvgBytesPerSec = 666;
		      pwfg723->wConfigWord=Rate53+POST_FILTER+SILENCE_ENABLE;
		    }
                    pwfx->cbSize          = G723_WFX_EXTRA_BYTES;

                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            pwfx = padf->pwfx;

            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                case WAVE_FORMAT_MSG723:
                    if (!g723IsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            return (MMSYSERR_NOTSUPPORTED);
    }


    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    pwfg723	          = (LPMSG723WAVEFORMAT)pwfx;

	if(padf->dwFormatTag == WAVE_FORMAT_MSG723)
	{
		if((pwfg723->wConfigWord&5) == 0)
			LoadStringCodec(pdi->hinst, IDS_FORMAT_DETAILS_MONO_8KHZ_6400BIT_S,
			padf->szFormat,SIZEOFACMSTR(padf->szFormat));
		if((pwfg723->wConfigWord&5) == 4)
			LoadStringCodec(pdi->hinst, IDS_FORMAT_DETAILS_MONO_8KHZ_6400BIT_SID,
			padf->szFormat,SIZEOFACMSTR(padf->szFormat));
		if((pwfg723->wConfigWord&5) == 1)
			LoadStringCodec(pdi->hinst, IDS_FORMAT_DETAILS_MONO_8KHZ_5333BIT_S,
			padf->szFormat,SIZEOFACMSTR(padf->szFormat));
		if((pwfg723->wConfigWord&5) == 5)
			LoadStringCodec(pdi->hinst, IDS_FORMAT_DETAILS_MONO_8KHZ_5333BIT_SID,
			padf->szFormat,SIZEOFACMSTR(padf->szFormat));
	}
    else
	    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the 
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPMSG723WAVEFORMAT	pwfg723;
	CODDEF *CodStat;
	DECDEF *DecStat;
    G723CODDEF *g723Inst;
    INSTNCE *SD_Inst;

    UINT   psi;
	int i;

#ifdef G723_USECONFIG
    DWORD               nConfigMaxRTEncodeSamplesPerSec;
    DWORD               nConfigMaxRTDecodeSamplesPerSec;
    DWORD               dw;
#endif


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

//    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));

    
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            if (!pcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!g723IsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            break;

        case WAVE_FORMAT_MSG723:
            if (!g723IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!pcmIsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }

    //
    //  for this driver, we must also verify that the nChannels
    //  member is the same between the source and destination
    //  formats.
    //
    if (pwfxSrc->nChannels != pwfxDst->nChannels)
        return (MMSYSERR_NOTSUPPORTED);

    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
		TTDBG(ghISRInst,TT_TRACE,"Stream open query");
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:

          g723Inst = LocalAlloc(LPTR,sizeof(G723CODDEF));
          if (NULL == g723Inst)
            return (MMSYSERR_NOMEM);

          CodStat = &g723Inst->CodStat;
          Init_Coder(CodStat);
          CodStat->UseHp = True;

          pwfg723 = (LPMSG723WAVEFORMAT)pwfxDst;

          CodStat->WrkRate = pwfg723->wConfigWord&RATE;

          CodStat->srccount = (int)0;
          for(i=0;i<SRCSTATELEN;i++)
            CodStat->srcstate[i] = (short)0;

/*****************************************************************
   Silence detector Init
*****************************************************************/

/* This value enables silence detection, early exit, and the default
** squelch value.
*/
			SD_Inst = &g723Inst->SD_Instance;
			SD_Inst->SDFlags = 0x00000005;
//			isFrameSilent = 0;		// initialize to "not silent"
/*
** Inintialize first OFFSET samples of storebuff
*/
			for(i=0;i<OFFSET;i++)SD_Inst->SDstate.Filt.storebuff[i] = 0.0f;
			glblSDinitialize(SD_Inst);

			psi = (DWORD)(UINT)g723Inst;

#ifndef NOTPRODUCT
            if ((pwfg723->dwCodeword1 == G723MAGICWORD1)
                && (pwfg723->dwCodeword2 == G723MAGICWORD2))
            {
              pdi->enabled = TRUE;
            }
#endif // NOTPRODUCT

			break;

        case WAVE_FORMAT_MSG723:

			DecStat = LocalAlloc(LPTR,sizeof(DECDEF));
		    if (NULL == DecStat)
        		return (MMSYSERR_NOMEM);

			Init_Decod(DecStat);				//low rate high pass and post filters enabled
            pwfg723 = (LPMSG723WAVEFORMAT)pwfxSrc;
			DecStat->UsePf = pwfg723->wConfigWord & POST_FILTER;

#ifndef NOTPRODUCT
          if ((pwfg723->dwCodeword1 == G723MAGICWORD1)
              && (pwfg723->dwCodeword2 == G723MAGICWORD2))
          {
            pdi->enabled = TRUE;
          }
#endif // NOTPRODUCT

//			DecStat->FrameSize = 20;
//			if((pwfg723->wConfigWord & RATE) == 0)
//				DecStat->FrameSize = 24;

			DecStat->srccount = (int)0;
			for(i=0;i<SRCSTATELEN;i++)
			  DecStat->srcstate[i] = (short)0;
			  DecStat->i = 0;
//			  DecStat->srcbuffend = DecStat->srcbuff;

			psi = (DWORD)(UINT)DecStat;
			break;
	}



    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a 
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //

//    psi->fnConvert      = fnConvert;
//   psi->fdwConfig      = pdi->fdwConfig;


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = psi;
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Stream Open padsi=%lx  psi=%lx",padsi,psi);
#endif // } NO_DEBUGGING_OUTPUT
#endif

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
	UINT		psi;
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	CODDEF		*CodStat;
	G723CODDEF	*g723Inst;
#endif // } LOG_ENCODE_TIMINGS_ON
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	DECDEF		*DecStat;
#endif // } LOG_ENCODE_TIMINGS_ON

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (UINT)padsi->dwDriver;

#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Stream Close padsi=%lx  psi=%lx",padsi,psi);
#endif // } NO_DEBUGGING_OUTPUT
#endif
    if (0 != psi)
   {
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
		g723Inst = (G723CODDEF *)psi;
		CodStat = &g723Inst->CodStat;
		OutputEncodeTimingStatistics("c:\\encode.txt", CodStat->EncTimingInfo, CodStat->dwStatFrameCount);
#endif // } LOG_ENCODE_TIMINGS_ON
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
		DecStat = (DECDEF *)psi;
		OutputDecodeTimingStatistics("c:\\decode.txt", DecStat->DecTimingInfo, DecStat->dwStatFrameCount);
#endif // } LOG_DECODE_TIMINGS_ON

        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }
    
    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//  
//  LRESULT acmdStreamSize
//  
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//  
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//  
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    PSTREAMINSTANCE         psi;
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    LPMSG723WAVEFORMAT		pwfg723;
    DWORD                   cb;
    DWORD                   cBlocks;
    DWORD                   cbBytesPerBlock;
    int i;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    psi = (PSTREAMINSTANCE)(UINT)padsi->dwDriver;

    //
    //
    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            cb = padss->cbSrcLength;

            if (WAVE_FORMAT_MSG723 == pwfxSrc->wFormatTag)
            {
                //
                //  how many destination PCM bytes are needed to hold
                //  the decoded g723 data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                cBlocks = cb / pwfxSrc->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfg723 = (LPMSG723WAVEFORMAT)pwfxSrc;

		for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		  if (pwfxDst->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  {
		    cbBytesPerBlock = G723_SAMPLES_PER_BLOCK_PCM[i]
		                      * pwfxDst->nBlockAlign;
		    break;
		  }

                if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		  return (ACMERR_NOTPOSSIBLE);

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
                if (0 == (cb % pwfxSrc->nBlockAlign))
                {
                    cb = cBlocks * cbBytesPerBlock;
                }
                else
                {
                    cb = (cBlocks + 1) * cbBytesPerBlock;
                }
		//
		// This ensures that there is enough room to adjust
		// from 11000 to 11025 Hz sampling rate when necessary
		//
		if (G723_SAMPLES_PER_BLOCK_PCM[i] == 330)
		  cb += (int)(1.0 + cBlocks / 440.0) * cbBytesPerBlock;
            }
            else
            {
                //
                //  how many destination g723 bytes are needed to hold
                //  the encoded PCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                pwfg723 = (LPMSG723WAVEFORMAT)pwfxDst;

		for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		  if (pwfxSrc->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  {
		    cbBytesPerBlock = G723_SAMPLES_PER_BLOCK_PCM[i]
		                      * pwfxSrc->nBlockAlign;
		    break;
		  }

                if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		  return (ACMERR_NOTPOSSIBLE);

                cBlocks = cb / cbBytesPerBlock;

                if (0 == (cb % cbBytesPerBlock))
                {
                    cb = cBlocks * pwfxDst->nBlockAlign;
                }
                else
                {
                    cb = (cBlocks + 1) * pwfxDst->nBlockAlign;
                }

                if (0L == cb)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }
            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            cb = padss->cbDstLength;


            if (WAVE_FORMAT_MSG723 == pwfxDst->wFormatTag)
            {
                //
                //  how many source PCM bytes can be encoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                cBlocks = cb / pwfxDst->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfg723 = (LPMSG723WAVEFORMAT)pwfxDst;

		for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		  if (pwfxSrc->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  {
		    cbBytesPerBlock = G723_SAMPLES_PER_BLOCK_PCM[i]
		                      * pwfxSrc->nBlockAlign;
		    break;
		  }

                if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		  return (ACMERR_NOTPOSSIBLE);

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * cbBytesPerBlock;
            }
            else
            {
                //
                //  how many source g723 bytes can be decoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                pwfg723 = (LPMSG723WAVEFORMAT)pwfxSrc;

		for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		  if (pwfxDst->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  {
		    cbBytesPerBlock = G723_SAMPLES_PER_BLOCK_PCM[i]
		                      * pwfxDst->nBlockAlign;
		    break;
		  }

                if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		  return (ACMERR_NOTPOSSIBLE);

                cBlocks = cb / cbBytesPerBlock;

		//
		// This ensures that there is enough room to adjust
		// from 11000 to 11025 Hz sampling rate when necessary
		//
		if (G723_SAMPLES_PER_BLOCK_PCM[i] == 330)
		  cBlocks -= (int)(1.0 + cBlocks / 440.0);

                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * pwfxSrc->nBlockAlign;
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()



//--------------------------------------------------------------------------;
//  
//  LRESULT acmdStreamConvert
//  
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//  
//--------------------------------------------------------------------------;
LRESULT FNLOCAL acmdStreamConvert
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
	LPMSG723WAVEFORMAT		pwfg723;

	UINT	psi;
	CODDEF *CodStat;
	DECDEF *DecStat;
    G723CODDEF *g723Inst;
    INSTNCE *SD_Inst;
	char	*Dst,*Src;
	short	*wDst;
	short	*wSrc;

	float Dbuf[240];
	short Ebuf[330];
	short Sbuf[240];
	int   i,k,m,cBlocks,temp,src_length,frame_size;
	int   Dst_length,isFrameSilent,silence,tmpbuf[24];
	int   pcm_format;

//__asm int 3
	psi = padsi->dwDriver;
   	pwfxSrc = padsi->pwfxSrc;
   	pwfxDst = padsi->pwfxDst;

    if (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag) {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
		TTDBG(ghISRInst,TT_TRACE,"Stream Encode padsi=%lx  psi=%lx",padsi,psi);
#endif // } NO_DEBUGGING_OUTPUT
#endif

        //
        //  Encode.
        //
	g723Inst = (G723CODDEF *)psi;
	CodStat = &g723Inst->CodStat;
	SD_Inst = &g723Inst->SD_Instance;

	pwfg723 = (LPMSG723WAVEFORMAT)padsi->pwfxDst;
	
	if(padsh->cbSrcLength == 0)
	  return (MMSYSERR_NOERROR);

      // *** compute # of frames that we can encode.***

      for(pcm_format=0;pcm_format<ACM_DRIVER_MAX_FORMATS_PCM;pcm_format++)
	if (pwfxSrc->nSamplesPerSec == PCM_SAMPLING_RATE[pcm_format])
	  break;
      if (pcm_format == ACM_DRIVER_MAX_FORMATS_PCM)
	return(MMSYSERR_INVALPARAM);

      cBlocks = padsh->cbSrcLength
	        / (pwfxSrc->nBlockAlign
		   * G723_SAMPLES_PER_BLOCK_PCM[pcm_format]);

      // check to see if there are enough extra samples to remove 
      // every 441st sample (to go from 11025 to 11000 Hz)

      if (G723_SAMPLES_PER_BLOCK_PCM[pcm_format] == 330)
      {
	i = padsh->cbSrcLength / pwfxSrc->nBlockAlign; // input samples
	k = cBlocks
	    * G723_SAMPLES_PER_BLOCK_PCM[pcm_format];  // used samples

	if (i - k < k / 441)          // if there aren't enough extra samples
	  cBlocks -= (1+k/(441*330)); // then decrement the number of blocks
      }

      if(cBlocks == 0)
      {
	padsh->cbDstLengthUsed = 0;
	padsh->cbSrcLengthUsed = 0;
	return (MMSYSERR_NOERROR);
      }

      wSrc = (short *)padsh->pbSrc;
      Dst = (char *)padsh->pbDst;
      frame_size = (CodStat->WrkRate == Rate63) ? 24 : 20;
      silence = 0;

      for(i=0;i<cBlocks;i++)
      {
	if (G723_SAMPLES_PER_BLOCK_PCM[pcm_format] == 330)
	{
	  for (k=0; k<330; k++)
	  {
	    Ebuf[k] = *wSrc++;

	    // *** code to adjust from 11025 Hz to 11000 Hz ***

	    if (++ CodStat->srccount == 441)
	    {
	      Ebuf[k] = *wSrc++;       // skip a sample
	      CodStat->srccount = 0;
	    }
	  }

	  convert11to8(Ebuf,Sbuf,CodStat->srcstate,330);

	  for (k=0; k<240; k++)
	    SD_Inst->SDstate.Filt.sbuff[k] = (float) Sbuf[k];
	}
	else
	  for (k=0; k<240; k++)
	    SD_Inst->SDstate.Filt.sbuff[k] = (float) *wSrc++;

        if(pwfg723->wConfigWord & SILENCE_ENABLE)
	{
	  prefilter(SD_Inst,SD_Inst->SDstate.Filt.sbuff,
		    SD_Inst->SDstate.Filt.storebuff,240);

	  getParams(SD_Inst, SD_Inst->SDstate.Filt.storebuff,240);

	  execSDloop(SD_Inst,&isFrameSilent,SDThreashold);
	}
	else isFrameSilent = 0;

	if(isFrameSilent)
	{
	  *Dst++ = 0x02;
	  *Dst++ = 0;
	  *Dst++ = 0;
	  *Dst++ = 0;

	  padsh->cbDstLengthUsed += 4;

	  silence++;
	}
	else
	{
	  Coder(SD_Inst->SDstate.Filt.sbuff,(Word32*)(long HUGE_T*)Dst,CodStat,0,1,0);

	  Dst += frame_size;

	  padsh->cbDstLengthUsed += frame_size;
	}
      }

      padsh->cbSrcLengthUsed = pwfxSrc->nBlockAlign
	                       * (wSrc - (short *)padsh->pbSrc);

      return (MMSYSERR_NOERROR);
    }
    else
    {

// Decode ---------------------------------------------

#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
      TTDBG(ghISRInst,TT_TRACE,"Stream Decode padsi=%lx  psi=%lx",padsi,psi);
#endif // } NO_DEBUGGING_OUTPUT
#endif

      for(pcm_format=0;pcm_format<ACM_DRIVER_MAX_FORMATS_PCM;pcm_format++)
	if (pwfxDst->nSamplesPerSec == PCM_SAMPLING_RATE[pcm_format])
	  break;
      if (pcm_format == ACM_DRIVER_MAX_FORMATS_PCM)
	return(MMSYSERR_INVALPARAM);

      DecStat = (DECDEF *)psi;

      cBlocks = 0;
      wDst = (short *)padsh->pbDst;
      Dst_length = padsh->cbDstLength;
      Src = (char *)padsh->pbSrc;
      src_length = padsh->cbSrcLength;
      padsh->cbSrcLengthUsed = 0;

      while(src_length > 0)
      {
	switch(*Src&3)
	{
          case 0 :
	    DecStat->WrkRate = Rate63;
	    frame_size = 24;
	    break;

	  case 1 :
	    DecStat->WrkRate = Rate53;
	    frame_size = 20;
	    break;

          case 2 :
//	    DecStat->WrkRate = Silent;  // Uncomment for V5.0 of G.723.1
	    frame_size = 4;		// this is an SID frame
            break;

         case 3 :
	   DecStat->WrkRate = Lost;
	   frame_size = 4;
	   break;
	}

	src_length-=frame_size;
	if(src_length < 0) break; // just in case we are given a partial frame

	memcpy(tmpbuf,(long HUGE_T *)Src,frame_size);
	Decod(Dbuf,(Word32*)(long HUGE_T*)tmpbuf,0,DecStat);
	Src += frame_size;
	padsh->cbSrcLengthUsed += frame_size;
	cBlocks++;
	
	if (G723_SAMPLES_PER_BLOCK_PCM[pcm_format] == 330)
	{
	  //
	  // Ouput Sampling rate is 11025 Hz
	  //
	  if (440 - DecStat->srccount <= 240)   // need to insert a sample?
	  {
	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(Dbuf[0]);
	    if (++ DecStat->srccount == 440) DecStat->srccount = 0;

	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(0.25 * Dbuf[0]
						    + 0.75 * Dbuf[1]);
	    if (++ DecStat->srccount == 440) DecStat->srccount = 0;

	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(0.50 * Dbuf[1]
						    + 0.50 * Dbuf[2]);
	    if (++ DecStat->srccount == 440) DecStat->srccount = 0;

	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(0.75 * Dbuf[2]
						    + 0.25 * Dbuf[3]);
	    if (++ DecStat->srccount == 440) DecStat->srccount = 0;

	    m = 3;
	  }
	  else m = 0;

	  for (k=m; k<240; k++)
	  {
	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(Dbuf[k]);
	    
	    if (++ DecStat->srccount == 440)
	      DecStat->srccount = 0;
	  }

	  if (DecStat->i == 480)
	  {
	    //
	    // *** 240 extra samples have accumulated ***
	    //
	    convert8to11(DecStat->srcbuff,wDst,DecStat->srcstate,480);
	    Dst_length -= 1320;   // two output frames (1320 bytes)
	    wDst += 660;

	    DecStat->i = 0;

	    if(Dst_length < 1320) break; // no more space in output buffer
	  }
	  else
	  {
	    //
	    // *** less than 240 extra samples have accumulated ***
	    //
	    convert8to11(DecStat->srcbuff,wDst,DecStat->srcstate,240);
	    Dst_length -= 660; 	       // one output frame (660 bytes)
	    wDst += 330;

	    //
	    // move partial frame to the front of the SRC buffer
	    //
            for(i=0;i<DecStat->i-240;i++)
	      DecStat->srcbuff[i] = DecStat->srcbuff[i+240];
	    DecStat->i -=240;

	    if(Dst_length < 1320) break; // no more space in output buffer
	  }
	}
	else
	{
	  //
	  // Ouput Sampling rate is 8000 Hz
	  //
	  for (k=0; k<240; k++)
	  {
	    temp = FLOATTOSHORT(Dbuf[k]);
	    *wDst++ = temp;
	  }

	  Dst_length -= 480;           // we just chewed up 480 bytes;
	  if(Dst_length < 480) break;  // we can't do any more!
	}
      }
      padsh->cbDstLengthUsed = pwfxDst->nBlockAlign * cBlocks
	                       * G723_SAMPLES_PER_BLOCK_PCM[pcm_format];
    }
	
    return (MMSYSERR_NOERROR);
} // acmdStreamConvert()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//      
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application 
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message. 
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD                   dwId, 
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;
    int	                k;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"DriverProc uMsg=%x lParam1=%lx lParam2=%lx",uMsg,lParam1,lParam2);
#endif // } NO_DEBUGGING_OUTPUT
#endif

    pdi = (PDRIVERINSTANCE)(UINT)dwId;
    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef _WIN32
            DbgInitialize(TRUE);
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            return (1L);
        
        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
		    TTDBG(ghISRInst,TT_TRACE,"Driver Closed");
#endif // } NO_DEBUGGING_OUTPUT
#endif
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);

            

        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
            lr = acmdFormatSuggest(pdi, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, lParam2);
            return (lr);

            
        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	  TTDBG(ghISRInst,TT_TRACE,"Stream open result:  %d",lr);
#endif // } NO_DEBUGGING_OUTPUT
#endif
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	  TTDBG(ghISRInst,TT_TRACE,"Stream close result:  %d",lr);
#endif // } NO_DEBUGGING_OUTPUT
#endif
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
          lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1,
                              (LPACMDRVSTREAMSIZE)lParam2);
          return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
          if (pdi->enabled)
          {
            lr = acmdStreamConvert(pdi, (LPACMDRVSTREAMINSTANCE)lParam1,
                                   (LPACMDRVSTREAMHEADER)lParam2);
            return (lr);
          }
          else return(MMSYSERR_NOTSUPPORTED);


        //
        //  lParam1: Setting for Silence detector threashold.
        //
        //  lParam2: Not used. Ignore this argument.
	//
        case DRV_USER:
	  k = (int)SDThreashold;
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	  TTDBG(ghISRInst,TT_TRACE,"Old Threashold = %d",k);
#endif // } NO_DEBUGGING_OUTPUT
#endif
	  SDThreashold = (float)lParam1;
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	  TTDBG(ghISRInst,TT_TRACE,"Setting Threashold to %ld",lParam1);
#endif // } NO_DEBUGGING_OUTPUT
#endif
	  return (lParam1);
        
#ifndef NOTPRODUCT
        //
        //  DRV_USER+1
        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: 0 = PCM stream, 1 = G.723.1 stream
        //
        case DRV_USER+1:
          if (lParam1 == G723MAGICWORD1 && lParam2 == G723MAGICWORD2)
            pdi->enabled = TRUE;
          else
            pdi->enabled = FALSE;

	  return (MMSYSERR_NOERROR);
#endif // NOTPRODUCT

    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Unknown command %d / %d",uMsg,DRV_USER);
#endif // } NO_DEBUGGING_OUTPUT
#endif
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\slib_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_api.c,v $
 * Revision 1.1.6.35  1996/12/13  18:19:04  Hans_Graves
 * 	Update Audio and Video timestamp correctly.
 * 	[1996/12/13  18:09:02  Hans_Graves]
 *
 * Revision 1.1.6.34  1996/12/12  20:54:44  Hans_Graves
 * 	Timestamp fixes after seek to Key frames.
 * 	[1996/12/12  20:52:06  Hans_Graves]
 *
 * Revision 1.1.6.33  1996/12/10  19:46:02  Hans_Graves
 * 	Fix floating division error when audio only.
 * 	[1996/12/10  19:45:03  Hans_Graves]
 *
 * Revision 1.1.6.32  1996/12/10  19:21:55  Hans_Graves
 * 	Made calculate video positions more accurate using slibFrameToTime100().
 * 	[1996/12/10  19:16:20  Hans_Graves]
 *
 * Revision 1.1.6.31  1996/12/05  20:10:15  Hans_Graves
 * 	Add gradual increase or decrease of framerates according to timestamps.
 * 	[1996/12/05  20:06:57  Hans_Graves]
 *
 * Revision 1.1.6.30  1996/12/04  22:34:28  Hans_Graves
 * 	Put limit on data used by Sv/SaDecompressBegin().
 * 	[1996/12/04  22:14:33  Hans_Graves]
 *
 * Revision 1.1.6.29  1996/12/03  23:15:13  Hans_Graves
 * 	MME-1498: Made seeks with PERCENT100 more accurate
 * 	[1996/12/03  23:10:43  Hans_Graves]
 *
 * Revision 1.1.6.28  1996/12/03  00:08:31  Hans_Graves
 * 	Handling of End Of Sequence points. Added PERCENT100 support.
 * 	[1996/12/03  00:05:59  Hans_Graves]
 *
 * Revision 1.1.6.27  1996/11/21  23:34:21  Hans_Graves
 * 	Handle MPEG B frames better when seeking.
 * 	[1996/11/21  23:28:18  Hans_Graves]
 *
 * Revision 1.1.6.26  1996/11/20  02:15:09  Hans_Graves
 * 	Added SEEK_AHEAD.  Removed old code.
 * 	[1996/11/20  02:10:43  Hans_Graves]
 *
 * Revision 1.1.6.25  1996/11/18  23:07:21  Hans_Graves
 * 	Remove MaxVideoLength usage.
 * 	[1996/11/18  22:55:56  Hans_Graves]
 *
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:47:30  Hans_Graves]
 *
 * Revision 1.1.6.24  1996/11/14  21:49:26  Hans_Graves
 * 	AC3 buffering fixes.
 * 	[1996/11/14  21:43:20  Hans_Graves]
 *
 * Revision 1.1.6.23  1996/11/13  16:10:54  Hans_Graves
 * 	AC3 recognition of byte reversed streams in slibGetDataFormat().
 * 	[1996/11/13  16:03:14  Hans_Graves]
 *
 * Revision 1.1.6.22  1996/11/11  18:21:03  Hans_Graves
 * 	More AC3 support changes.
 * 	[1996/11/11  17:59:01  Hans_Graves]
 *
 * Revision 1.1.6.21  1996/11/08  21:51:02  Hans_Graves
 * 	Added AC3 support. Better seperation of stream types.
 * 	[1996/11/08  21:27:57  Hans_Graves]
 *
 * Revision 1.1.6.20  1996/10/31  00:08:51  Hans_Graves
 * 	Fix skipping data after RESET with MPEG video only streams.
 * 	[1996/10/31  00:07:08  Hans_Graves]
 *
 * Revision 1.1.6.19  1996/10/28  23:16:42  Hans_Graves
 * 	MME-0145?, Fix artifacts when using SlibReadData() at a new position. Jump to first GOP.
 * 	[1996/10/28  23:13:01  Hans_Graves]
 *
 * Revision 1.1.6.18  1996/10/28  17:32:28  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:22:58  Hans_Graves]
 *
 * Revision 1.1.6.17  1996/10/17  00:23:32  Hans_Graves
 * 	Fix buffer problems after SlibQueryData() calls.
 * 	[1996/10/17  00:19:05  Hans_Graves]
 *
 * Revision 1.1.6.16  1996/10/15  17:34:09  Hans_Graves
 * 	Added MPEG-2 Program Stream support.
 * 	[1996/10/15  17:30:26  Hans_Graves]
 *
 * Revision 1.1.6.15  1996/10/12  17:18:51  Hans_Graves
 * 	Fixed some seeking problems. Moved render code to slib_render.c
 * 	[1996/10/12  17:00:49  Hans_Graves]
 *
 * Revision 1.1.6.14  1996/10/03  19:14:21  Hans_Graves
 * 	Added Presentation and Decoding timestamp support.
 * 	[1996/10/03  19:10:35  Hans_Graves]
 *
 * Revision 1.1.6.13  1996/09/29  22:19:37  Hans_Graves
 * 	Added stride support. Added SlibQueryData().
 * 	[1996/09/29  21:29:44  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/09/25  19:16:44  Hans_Graves
 * 	Added DECOMPRESS_QUERY. Fix up support for YUY2.
 * 	[1996/09/25  19:00:45  Hans_Graves]
 *
 * Revision 1.1.6.11  1996/09/23  18:04:03  Hans_Graves
 * 	Added stats support. Scaleing and negative height fixes.
 * 	[1996/09/23  17:59:31  Hans_Graves]
 *
 * Revision 1.1.6.10  1996/09/18  23:46:32  Hans_Graves
 * 	Seek fixes. Added SlibReadData() and SlibAddBufferEx().
 * 	[1996/09/18  22:04:57  Hans_Graves]
 *
 * Revision 1.1.6.9  1996/08/09  20:51:42  Hans_Graves
 * 	Fix handle arg for SlibRegisterVideoBuffer()
 * 	[1996/08/09  20:10:11  Hans_Graves]
 *
 * Revision 1.1.6.8  1996/07/19  02:11:11  Hans_Graves
 * 	Added SlibRegisterVideoBuffer. Added YUV422i to RGB 16 rendering.
 * 	[1996/07/19  02:01:11  Hans_Graves]
 *
 * Revision 1.1.6.7  1996/06/03  21:41:12  Hans_Graves
 * 	Fix file seeking.  Always seeked to position 0.
 * 	[1996/06/03  21:40:44  Hans_Graves]
 *
 * Revision 1.1.6.6  1996/05/24  22:21:44  Hans_Graves
 * 	Merge MME-1221. Last SlibReadAudio() returned EndOfStream even if data read.
 * 	[1996/05/24  20:58:42  Hans_Graves]
 *
 * Revision 1.1.6.5  1996/05/23  18:46:35  Hans_Graves
 * 	Seperate global audio and video SInfo variables, to help multi-threaded apps
 * 	[1996/05/23  18:35:14  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/05/23  18:16:31  Hans_Graves
 * 	Added more YUV Conversions. MPEG audio buffering fix.
 * 	[1996/05/23  18:16:11  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/05/10  21:17:00  Hans_Graves
 * 	Added callback support. Also fill entire buffers when calling SlibReadAudio()
 * 	[1996/05/10  20:26:08  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/05/07  19:56:16  Hans_Graves
 * 	Added SlibOpen() and SlibAddBuffer() framework. Added HUFF_SUPPORT.
 * 	[1996/05/07  17:20:12  Hans_Graves]
 *
 * Revision 1.1.4.16  1996/05/02  17:10:33  Hans_Graves
 * 	Be more specific about checking for MPEG-2 Systems file type. Fixes MME-01234
 * 	[1996/05/02  17:04:44  Hans_Graves]
 *
 * Revision 1.1.4.15  1996/04/24  22:33:44  Hans_Graves
 * 	MPEG encoding bitrate fixups.
 * 	[1996/04/24  22:27:09  Hans_Graves]
 *
 * Revision 1.1.4.14  1996/04/23  21:22:31  Hans_Graves
 * 	Added description for SlibErrorSettingNotEqual
 * 	[1996/04/23  21:16:09  Hans_Graves]
 *
 * Revision 1.1.4.13  1996/04/22  15:04:51  Hans_Graves
 * 	Fix bad frame counts and seeking under NT caused by int overflows
 * 	[1996/04/22  15:02:26  Hans_Graves]
 *
 * Revision 1.1.4.12  1996/04/19  21:52:22  Hans_Graves
 * 	MPEG 1 Systems writing enhancements
 * 	[1996/04/19  21:47:48  Hans_Graves]
 *
 * Revision 1.1.4.11  1996/04/15  14:18:37  Hans_Graves
 * 	Handle any audio buffer size during encoding.
 * 	[1996/04/15  14:16:11  Hans_Graves]
 *
 * Revision 1.1.4.10  1996/04/12  19:25:20  Hans_Graves
 * 	Add MPEG2_VIDEO type to Commit
 * 	[1996/04/12  19:24:19  Hans_Graves]
 *
 * Revision 1.1.4.9  1996/04/10  21:47:41  Hans_Graves
 * 	Fix in SlibIsEnd().
 * 	[1996/04/10  21:39:37  Hans_Graves]
 *
 * Revision 1.1.4.8  1996/04/09  16:04:42  Hans_Graves
 * 	Remove NT warnings
 * 	[1996/04/09  14:42:48  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/04/04  23:35:07  Hans_Graves
 * 	Format conversion cleanup
 * 	[1996/04/04  23:16:20  Hans_Graves]
 *
 * Revision 1.1.4.6  1996/04/01  19:07:52  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:33  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/04/01  16:23:12  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:54  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/03/29  22:21:30  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:56:55  Hans_Graves]
 *
 * 	Added MPEG-I Systems encoding support
 * 	[1996/03/27  21:55:54  Hans_Graves]
 *
 * Revision 1.1.4.3  1996/03/12  16:15:45  Hans_Graves
 * 	Added seperate streams to SlibIsEnd()
 * 	[1996/03/12  15:56:28  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/08  18:46:42  Hans_Graves
 * 	YUV conversions moved to slibRenderFrame()
 * 	[1996/03/08  18:14:47  Hans_Graves]
 *
 * Revision 1.1.2.18  1996/02/22  23:30:24  Hans_Graves
 * 	Update FPS on seeks
 * 	[1996/02/22  23:29:27  Hans_Graves]
 *
 * Revision 1.1.2.17  1996/02/22  22:23:56  Hans_Graves
 * 	Update frame numbers with timecode more often
 * 	[1996/02/22  22:23:07  Hans_Graves]
 *
 * Revision 1.1.2.16  1996/02/21  22:52:43  Hans_Graves
 * 	Fixed MPEG 2 systems stuff
 * 	[1996/02/21  22:50:55  Hans_Graves]
 *
 * Revision 1.1.2.15  1996/02/19  20:09:28  Hans_Graves
 * 	Debugging message clean-up
 * 	[1996/02/19  20:08:31  Hans_Graves]
 *
 * Revision 1.1.2.14  1996/02/19  18:03:54  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:36  Hans_Graves]
 *
 * Revision 1.1.2.13  1996/02/13  18:47:46  Hans_Graves
 * 	Fix some Seek related bugs
 * 	[1996/02/13  18:40:36  Hans_Graves]
 *
 * Revision 1.1.2.12  1996/02/07  23:23:54  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:29  Hans_Graves]
 *
 * Revision 1.1.2.11  1996/02/06  22:54:05  Hans_Graves
 * 	Seek fix-ups. More accurate MPEG frame counts.
 * 	[1996/02/06  22:44:56  Hans_Graves]
 *
 * Revision 1.1.2.10  1996/02/02  17:36:02  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:44  Hans_Graves]
 *
 * Revision 1.1.2.9  1996/01/30  22:23:08  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:21:38  Hans_Graves]
 *
 * Revision 1.1.2.8  1996/01/15  16:26:27  Hans_Graves
 * 	Removed debuging message
 * 	[1996/01/15  16:02:47  Hans_Graves]
 *
 * 	Added MPEG 1 Audio compression and SlibWriteAudio()
 * 	[1996/01/15  15:45:46  Hans_Graves]
 *
 * Revision 1.1.2.7  1996/01/11  16:17:29  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:33  Hans_Graves]
 *
 * Revision 1.1.2.6  1996/01/08  16:41:31  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:02  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/12/08  20:01:20  Hans_Graves
 * 	Fixed SlibSetParam(). Added H.261 compression support.
 * 	[1995/12/08  19:53:52  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/12/07  19:31:36  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:30:10  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/11/09  23:14:05  Hans_Graves
 * 	Added MPEG audio decompression
 * 	[1995/11/09  23:08:33  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/11/06  18:47:52  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:36:01  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/


#include <fcntl.h>
#include <sys/stat.h>
#ifdef WIN32
#include <io.h>
#endif
#ifdef _SHM_
#include  <sys/ipc.h>  /* shared memory */
#endif
#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"
/* #include "SC_convert.h" */
#include "mpeg.h"
#include "ac3.h"
#include "avi.h"

#ifdef _SLIBDEBUG_
#include <stdio.h>
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#define _SEEK_      1  /* seek, frame counts/timecode info: 2=more detail */
#define _CALLBACK_  0  /* callback debugging */
#define _DUMP_      0  /* dump data in hex format */
#define _TIMECODE_  1  /* debug timecodes */
#endif

static SlibStatus_t slibOpen(SlibHandle_t *handle, SlibMode_t smode,
                             SlibType_t *stype);

/*
** Lists
*/
static SlibList_t _listTypes [] = {
  SLIB_TYPE_MPEG1_VIDEO,   "MPEG1_VIDEO", "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,   "MPEG1_AUDIO", "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,   "MPEG2_VIDEO", "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG2_AUDIO,   "MPEG2_AUDIO", "MPEG-2 Audio Stream",0,0,
  SLIB_TYPE_AC3_AUDIO,     "AC3", "Dolby Digital(AC-3) Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,  "MPEG_SYSTEMS", "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG_SYSTEMS_MPEG2", "MPEG Systems (MPEG-2)",0,0,
  SLIB_TYPE_MPEG_TRANSPORT,"MPEG_TRANSPORT", "MPEG Transport Stream",0,0,
  SLIB_TYPE_MPEG_PROGRAM,  "MPEG_PROGRAM", "MPEG Program Stream",0,0,
  SLIB_TYPE_H261,          "H261", "H.261 Video Stream",0,0,
  SLIB_TYPE_RTP_H261,      "RTP_H261", "RTP (H.261) Stream",0,0,
  SLIB_TYPE_H263,          "H263", "H.263 Video Stream",0,0,
  SLIB_TYPE_RTP_H263,      "RTP_H263", "RTP (H.263) Stream",0,0,
  SLIB_TYPE_RIFF,          "RIFF", "RIFF File Format",0,0,
  SLIB_TYPE_AVI,           "AVI", "AVI File Format",0,0,
  SLIB_TYPE_PCM_WAVE,      "PCM_WAVE", "WAVE (PCM) File Format",0,0,
  SLIB_TYPE_JPEG_AVI,      "JPEG_AVI", "AVI (JPEG) Stream",0,0,
  SLIB_TYPE_MJPG_AVI,      "MJPG_AVI", "AVI (MJPG) Stream",0,0,
  SLIB_TYPE_YUV_AVI,       "YUV_AVI", "AVI (YUV) File Format",0,0,
  SLIB_TYPE_JFIF,          "JFIF",  "JPEG (JFIF) Stream",0,0,
  SLIB_TYPE_JPEG_QUICKTIME,"JPEG_QUICKTIME","JPEG (Quicktime) Stream",0,0,
  SLIB_TYPE_JPEG,          "JPEG",  "JPEG Stream",0,0,
  SLIB_TYPE_MJPG,          "MJPG",  "MJPG Stream",0,0,
  SLIB_TYPE_YUV,           "YUV",   "YUV Data",0,0,
  SLIB_TYPE_RGB,           "RGB",   "RGB Data",0,0,
  SLIB_TYPE_PCM,           "PCM",   "PCM Audio",0,0,
  SLIB_TYPE_SLIB,          "SLIB",  "SLIB Stream",0,0,
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
  SLIB_TYPE_RASTER,        "RASTER","Sun Raster",0,0,
  SLIB_TYPE_BMP,           "BMP",   "Windows Bitmap",0,0,
  0, NULL, "End of List",0,0
};

static SlibList_t _listCompressTypes [] = {
#ifdef MPEG_SUPPORT
  SLIB_TYPE_MPEG1_VIDEO,        "MPEG1_VIDEO",   "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,        "MPEG1_AUDIO",   "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,        "MPEG2_VIDEO",   "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,       "MPEG_SYSTEMS",  "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG2_SYSTEMS", "MPEG Systems (MPEG-2)",0,0,
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
  SLIB_TYPE_H261,          "H261",  "H.261 Video Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  SLIB_TYPE_H263,          "H263",  "H.263 Video Stream",0,0,
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
#endif /* G723_SUPPORT */
  0, NULL, "End of List",0,0
};

static SlibList_t _listDecompressTypes [] = {
#ifdef MPEG_SUPPORT
  SLIB_TYPE_MPEG1_VIDEO,   "MPEG1_VIDEO", "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,   "MPEG1_AUDIO", "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,   "MPEG2_VIDEO", "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,       "MPEG_SYSTEMS",   "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG2_SYSTEMS",  "MPEG Systems (MPEG-2)",0,0,
  SLIB_TYPE_MPEG_TRANSPORT,     "MPEG_TRANSPORT", "MPEG Transport Stream",0,0,
  SLIB_TYPE_MPEG_PROGRAM,       "MPEG_PROGRAM",   "MPEG Program Stream",0,0,
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
  SLIB_TYPE_AC3_AUDIO,     "AC3",         "Dolby Digital(AC-3) Stream",0,0,
#endif /* AC3_SUPPORT */
#ifdef H261_SUPPORT
  SLIB_TYPE_H261,          "H261",  "H.261 Video Stream",0,0,
  SLIB_TYPE_RTP_H261,      "RTP_H261", "RTP (H.261) Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  SLIB_TYPE_H263,          "H263",     "H.263 Video Stream",0,0,
  SLIB_TYPE_RTP_H263,      "RTP_H263", "RTP (H.263) Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef JPEG_SUPPORT
  SLIB_TYPE_JPEG_AVI,      "JPEG_AVI", "AVI (JPEG) Stream",0,0,
  SLIB_TYPE_MJPG_AVI,      "MJPG_AVI", "AVI (MJPG) Stream",0,0,
#endif /* JPEG_SUPPORT */
  SLIB_TYPE_RIFF,          "RIFF", "RIFF File Format",0,0,
  SLIB_TYPE_AVI,           "AVI", "AVI File Format",0,0,
  SLIB_TYPE_PCM_WAVE,      "PCM_WAVE", "WAVE (PCM) File Format",0,0,
  SLIB_TYPE_YUV_AVI,       "YUV_AVI", "AVI (YUV) File Format",0,0,
  SLIB_TYPE_RASTER,        "RASTER","Sun Raster",0,0,
  SLIB_TYPE_BMP,           "BMP",   "Windows Bitmap",0,0,
#ifdef HUFF_SUPPORT
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
#endif /* G723_SUPPORT */
  0, NULL, "End of List",0,0
};

static SlibList_t _listErrors[] = {
  SlibErrorNone,        "SlibErrorNone",
                        "No Error",0,0,
  SlibErrorInternal,    "SlibErrorInternal",
                        "Internal SLIB error",0,0,
  SlibErrorMemory,      "SlibErrorMemory",
                        "Unable to allocated memory",0,0,
  SlibErrorBadArgument, "SlibErrorBadArgument",
                        "Invalid argument to function",0,0,
  SlibErrorBadHandle,   "SlibErrorBadHandle",
                        "Invalid SLIB handle",0,0,
  SlibErrorBadMode,     "SlibErrorBadMode",
                        "Invalid SLIB mode",0,0,
  SlibErrorUnsupportedFormat, "SlibErrorUnsupportedFormat",
                        "Unsupported format",0,0,
  SlibErrorReading,     "SlibErrorReading",
                        "Error reading from file",0,0,
  SlibErrorWriting,     "SlibErrorWriting",
                        "Error writing to file",0,0,
  SlibErrorBufSize,     "SlibErrorBufSize",
                        "Buffer size is too small",0,0,
  SlibErrorEndOfStream, "SlibErrorEndOfStream",
                        "End of data stream",0,0,
  SlibErrorForwardOnly, "SlibErrorForwardOnly",
                        "The decompressor can work only forward",0,0,
  SlibErrorUnsupportedParam, "SlibErrorUnsupportedParam",
                        "The parameter is invalid or unsupported",0,0,
  SlibErrorImageSize,   "SlibErrorImageSize",
                        "Invalid image height and/or width size",0,0,
  SlibErrorSettingNotEqual, "SlibErrorSettingNotEqual",
                        "The exact parameter setting was not used",0,0,
  SlibErrorInit,        "SlibErrorInit",
                        "Initializing CODEC failed",0,0,
  SlibErrorFileSize,    "SlibErrorFileSize",
                        "Error in file size",0,0,
  SlibErrorBadPosition, "SlibErrorBadPosition",
                        "Error in seek position",0,0,
  SlibErrorBadUnit,     "SlibErrorBadUnit",
                        "Error in seek units",0,0,
  SlibErrorNoData,      "SlibErrorNoData",
                        "No data available",0,0,
  0, NULL, "End of List",0,0
};

SlibList_t *SlibFindEnumEntry(SlibList_t *list, int enumval)
{
  if (!list)
    return(NULL);
  while (list->Name)
  {
    if (list->Enum==enumval)
      return(list);
    list++;
  }
  return(NULL);
}

char *SlibGetErrorText(SlibStatus_t status)
{
  SlibList_t *entry=SlibFindEnumEntry(_listErrors, status);
  if (entry)
    return(entry->Desc);
  else
    return(NULL);
}

int VCompressCallback(SvHandle_t Svh, SvCallbackInfo_t *CB,
                                      SvPictureInfo_t *pinfo)
{
  int status;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("VCompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("VCompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              CB->DataSize=Info->CompBufSize;
              CB->Data=SlibAllocBuffer(CB->DataSize);
              status=SvAddBuffer(Svh, CB);
              _SlibDebug(_WARN_ && status!=NoErrors,
                        printf("SvAddBuffer() %s\n", ScGetErrorStr(status)) );
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("VCompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data && CB->DataUsed)
            {
              SlibPin_t *dstpin=slibGetPin(Info, SLIB_DATA_VIDEO);
              if (dstpin)
              {
                slibAddBufferToPin(dstpin, CB->Data, CB->DataUsed,
                                           Info->VideoPTimeCode);
                Info->VideoPTimeCode=SLIB_TIME_NONE;
                if (!slibCommitBuffers(Info, FALSE))
                  CB->Action = CB_ACTION_END;
                break;
              }
            }
            if (CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_FRAME_START:
            _SlibDebug(_CALLBACK_||_TIMECODE_,
               printf("VCompress CB_FRAME_START: TimeCode=%ld TemporalRef=%d\n",
                        pinfo->TimeCode, pinfo->TemporalRef) );
            Info->VideoPTimeCode=pinfo->TimeCode;
#if 0
            if (pinfo->Type==SV_I_PICTURE || pinfo->Type==SV_P_PICTURE)
            {
              if (!SlibTimeIsValid(Info->LastVideoDTimeCode))
                Info->VideoDTimeCode=-1000/(long)Info->FramesPerSec;
              else
                Info->VideoDTimeCode=Info->LastVideoDTimeCode;
              Info->LastVideoDTimeCode=pinfo->TimeCode;
              _SlibDebug(_CALLBACK_||_TIMECODE_,
                printf("CB_FRAME_START: LastVideoDTimeCode=%ld VideoDTimeCode=%ld\n",
                           Info->LastVideoDTimeCode, Info->VideoDTimeCode));
            }
            else
              Info->VideoDTimeCode=-1;
#endif
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

int VDecompressCallback(SvHandle_t Svh, SvCallbackInfo_t *CB,
                                       SvPictureInfo_t *PictInfo)
{
  int status;
  unsigned dword size;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("VDecompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_SEQ_END: /* reset presentation timestamps at end-of-sequence */
            _SlibDebug(_CALLBACK_ || _TIMECODE_,
              printf("VDecompressCallback received CB_SEQ_END message\n") );
            Info->VideoPTimeCode=SLIB_TIME_NONE;
            Info->AudioPTimeCode=SLIB_TIME_NONE;
            Info->VideoTimeStamp=SLIB_TIME_NONE;
            Info->AudioTimeStamp=SLIB_TIME_NONE;
            break;
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              SlibTime_t ptimestamp, timediff;
              slibSetMaxInput(Info, 1500*1024); /* set limit for input data */
              CB->Data = SlibGetBuffer(Info, SLIB_DATA_VIDEO, &size,
                                        &ptimestamp);
              slibSetMaxInput(Info, 0); /* clear limit */
              CB->DataSize = size;
              if (SlibTimeIsValid(Info->AudioPTimeCode))
              {
                timediff=ptimestamp-Info->AudioPTimeCode;
                if (timediff>6000)
                {
                  /* Make sure a NEW audio time is not way out of
                   * sync with video time.
                   * This can happen after an End of Sequence.
                   */
                  /* assign audio time to video time */
                  Info->VideoPTimeCode=SLIB_TIME_NONE;
                  Info->VideoPTimeBase=Info->AudioPTimeBase;
                  ptimestamp=Info->AudioPTimeCode;
                }
              }
              if (SlibTimeIsValid(ptimestamp) &&
                  ptimestamp>Info->VideoPTimeCode)
              {
                SlibTime_t lasttime=Info->VideoPTimeCode;
                Info->VideoPTimeCode=ptimestamp;
                _SlibDebug(_CALLBACK_||_TIMECODE_,
                  printf("VideoPTimeCode=%ld\n", Info->VideoPTimeCode) );
                ptimestamp-=Info->VideoPTimeBase;
                timediff=ptimestamp-Info->VideoTimeStamp;
                if (SlibTimeIsInValid(lasttime) ||
                    SlibTimeIsInValid(Info->VideoTimeStamp))
                {
                  _SlibDebug(_TIMECODE_,
                     printf("Updating VideoTimeStamp none->%ld\n",
                           ptimestamp) );
                  Info->VideoTimeStamp=ptimestamp;
                  Info->AvgVideoTimeDiff=0;
                  Info->VarVideoTimeDiff=0;
                }
                else /* see if times are far off */
                {
                  SlibTime_t lastavg=Info->AvgVideoTimeDiff;
                  Info->AvgVideoTimeDiff=(lastavg*14+timediff)/15;
                  Info->VarVideoTimeDiff=(Info->VarVideoTimeDiff*3+
                        lastavg-Info->AvgVideoTimeDiff)/4;
                  _SlibDebug(_CALLBACK_||_TIMECODE_,
                    printf("Video timediff: Cur=%ld Avg=%ld Var=%ld\n",
                              timediff, Info->AvgVideoTimeDiff,
                                        Info->VarVideoTimeDiff));
                  if (Info->VarVideoTimeDiff==0)
                  {
                    _SlibDebug(_TIMECODE_,
                      printf("Updating VideoTimeStamp %ld->%ld (diff=%ld)\n",
                           Info->VideoTimeStamp, ptimestamp,
                           ptimestamp-Info->VideoTimeStamp) );
                    Info->VideoTimeStamp=ptimestamp;
                    Info->AvgVideoTimeDiff=0;
                  }
                  else if (Info->AvgVideoTimeDiff>=100
                           || Info->AvgVideoTimeDiff<=-100)
                  {
                    /* calculated time and timestamps are too far off */
                    float fps=Info->FramesPerSec;
                    if (Info->VarVideoTimeDiff>1 && fps>=15.5F)
                      fps-=0.25F;  /* playing too fast, slow frame rate */
                    else if (Info->VarVideoTimeDiff<-1 && fps<=59.0F)
                      fps+=0.25F;  /* playing too slow, speed up frame rate */
                    _SlibDebug(_WARN_ || _CALLBACK_||_TIMECODE_,
                        printf("Updating fps from %.4f -> %.4f\n",
                                 Info->FramesPerSec, fps) );
                    Info->FramesPerSec=fps;
                    Info->VideoFrameDuration=slibFrameToTime100(Info, 1);
                    Info->VideoTimeStamp=ptimestamp;
                    Info->AvgVideoTimeDiff=0;
                  }
                }
                Info->VideoFramesProcessed=0; /* reset frames processed */
              }
              if (CB->DataSize>0)
              {
                _SlibDebug(_DUMP_,
                  SlibPin_t *pin=slibGetPin(Info, SLIB_DATA_VIDEO);
                    printf("VDecompressCallback() Adding buffer of length %d\n",
                             CB->DataSize);
                  ScDumpChar(CB->Data, (int)CB->DataSize, (int)pin->Offset-CB->DataSize));
                CB->DataType = CB_DATA_COMPRESSED;
                _SlibDebug(_CALLBACK_,
                  printf("VDecompressCallback() Adding buffer of length %d\n",
                               CB->DataSize) );
                status = SvAddBuffer(Svh, CB);
              }
              else
              {
                _SlibDebug(_WARN_ || _CALLBACK_,
                   printf("VDecompressCallback() got no data\n") );
                CB->Action = CB_ACTION_END;
                return(NoErrors);
              }
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("VDecompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_PROCESSING:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_PROCESSING message\n") );
            break;
     case CB_CODEC_DONE:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_CODEC_DONE message\n") );
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

int ACompressCallback(SaHandle_t Sah, SaCallbackInfo_t *CB, SaInfo_t *SaInfo)
{
  int status;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("ACompressCallback()\n") );

  CB->Action = CB_ACTION_CONTINUE;
  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("ACompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              CB->DataSize=Info->CompBufSize;
              CB->Data=SlibAllocBuffer(CB->DataSize);
              _SlibDebug(_CALLBACK_,
                printf("ACompressCallback() Adding buffer of length %d\n",
                             CB->DataSize) );
              status=SaAddBuffer(Sah, CB);
              _SlibDebug(_WARN_ && status!=NoErrors,
                        printf("SaAddBuffer() %s\n", ScGetErrorStr(status)) );
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("ACompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data && CB->DataUsed)
            {
              SlibPin_t *dstpin=slibGetPin(Info, SLIB_DATA_AUDIO);
              if (dstpin)
              {
                slibAddBufferToPin(dstpin, CB->Data, CB->DataUsed,
                                           Info->AudioPTimeCode);
                Info->AudioPTimeCode=SLIB_TIME_NONE;
                if (!slibCommitBuffers(Info, FALSE))
                  CB->Action = CB_ACTION_END;
              }
            }
            else if (CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_FRAME_START:
            _SlibDebug(_CALLBACK_||_TIMECODE_,
                 printf("ACompress CB_FRAME_START: TimeStamp=%ld Frame=%d\n",
                                   CB->TimeStamp, Info->VideoFramesProcessed
                                     ) );
            if (SlibTimeIsInValid(Info->AudioPTimeCode))
            {
              Info->AudioPTimeCode=CB->TimeStamp;
              _SlibDebug(_TIMECODE_,
                 printf("AudioPTimeCode=%ld\n", Info->AudioPTimeCode) );
              _SlibDebug(_WARN_ && (Info->AudioTimeStamp-CB->TimeStamp>400 ||
                                    CB->TimeStamp-Info->AudioTimeStamp>400),
               printf("Bad Audio Time: AudioPTimeCode=%ld AudioTimestamp=%ld\n",
                     Info->AudioPTimeCode, Info->AudioTimeStamp) );
            }
            break;
  }
  return(NoErrors);
}

int ADecompressCallback(SvHandle_t Sah, SaCallbackInfo_t *CB, SaInfo_t *SaInfo)
{
  int status;
  unsigned dword size;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_DEBUG_, printf("ADecompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_END_BUFFER\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              SlibTime_t ptimestamp, timediff;
              slibSetMaxInput(Info, 2000*1024); /* set limit for input data */
              CB->Data = SlibGetBuffer(Info, SLIB_DATA_AUDIO, &size,
                                                                &ptimestamp);
              slibSetMaxInput(Info, 0); /* clear limit */
              CB->DataSize = size;
              if (SlibTimeIsValid(ptimestamp))
              {
                Info->AudioPTimeCode=ptimestamp;
                _SlibDebug(_CALLBACK_||_TIMECODE_,
                  printf("AudioPTimeCode=%ld\n", Info->AudioPTimeCode) );
                ptimestamp-=Info->AudioPTimeBase;
                timediff=ptimestamp-Info->AudioTimeStamp;
                if (SlibTimeIsInValid(Info->AudioTimeStamp))
                  Info->AudioTimeStamp=ptimestamp;
                else if (timediff<-300 || timediff>300) /* time is far off */
                {
                  _SlibDebug(_WARN_||_TIMECODE_,
                    printf("Updating AudioTimeStamp %ld->%ld (diff=%ld)\n",
                         Info->AudioTimeStamp, ptimestamp,timediff) );
                  Info->AudioTimeStamp=ptimestamp;
                  if (SlibTimeIsValid(Info->VideoTimeStamp))
                  {
                    /* Make sure a NEW audio time is not way out of
                     * sync with video time.
                     * This can happen after an End of Sequence.
                     */
                    timediff=ptimestamp-Info->VideoTimeStamp;
                    if (timediff<-6000)
                    {
                      /* assign audio time to video time */
                      Info->VideoPTimeCode=SLIB_TIME_NONE;
                      Info->VideoPTimeBase=Info->AudioPTimeBase;
                      Info->VideoTimeStamp=ptimestamp;
                    }
                  }
                }
              }
              if (CB->Data)
              {
                if (CB->DataSize>0)
                {
                  CB->DataType = CB_DATA_COMPRESSED;
                  _SlibDebug(_CALLBACK_,
                    printf("ADecompressCallback() Adding buffer of length %d\n",
                               CB->DataSize) );
                  status = SaAddBuffer(Sah, CB);
                }
                else
                  SlibFreeBuffer(CB->Data);
              }
              else
              {
                _SlibDebug(_WARN_ || _CALLBACK_,
                   printf("ADecompressCallback() got no data\n") );
                CB->Action = CB_ACTION_END;
                return(NoErrors);
              }
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("ADecompressCallback() CB_RELEASE_BUFFER\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_PROCESSING:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_PROCESSING\n") );
            break;
     case CB_CODEC_DONE:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_CODEC_DONE\n") );
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

static void slibInitInfo(SlibInfo_t *Info)
{
  _SlibDebug(_DEBUG_, printf("slibInitInfo()\n") );
  Info->Type = SLIB_TYPE_UNKNOWN;
  Info->Mode = SLIB_MODE_NONE;
  Info->Svh = NULL;
  Info->Sah = NULL;
  Info->Sch = NULL;
  Info->NeedAccuracy = FALSE;
  Info->TotalBitRate = 0;
  Info->MuxBitRate = 0;
  Info->SystemTimeStamp = 0;
  /* Audio parameters */
  Info->AudioStreams = 0;
  Info->SamplesPerSec = 0;
  Info->BitsPerSample = 0;
  Info->Channels = 0;
  Info->AudioBitRate = 0;
  Info->AudioMainStream = 0;
  Info->AudioType = SLIB_TYPE_UNKNOWN;
  /* Video parameters */
  Info->VideoStreams = 0;
  Info->Width = 0;
  Info->Height = 0;
  Info->Stride = 0;
  Info->VideoBitRate = 0;
  Info->FramesPerSec = 0.0F;
  Info->ImageSize = 0;
  Info->AudioPID = -1;
  Info->VideoPID = -1;
  Info->VideoMainStream = 0;
  Info->VideoType = SLIB_TYPE_UNKNOWN;
  /* Data Exchange */
  Info->Offset = 0;
  Info->Pins = NULL;
  Info->PinCount = 0;
  Info->IOError = FALSE;
  Info->MaxBytesInput = 0;
  Info->BytesProcessed = 0;
  /* stream dependent stuff */
  Info->VideoLength = 0;
  Info->VideoLengthKnown = FALSE;
  Info->VideoTimeStamp = SLIB_TIME_NONE;
  Info->VideoFrameDuration = 0;
  Info->AudioLength = 0;
  Info->AudioLengthKnown = FALSE;
  Info->AudioTimeStamp = SLIB_TIME_NONE;
  Info->LastAudioTimeStamp = SLIB_TIME_NONE;
  Info->KeySpacing = 0;
  Info->SubKeySpacing = 0;
  Info->VideoPTimeBase = SLIB_TIME_NONE;
  Info->VideoPTimeCode = SLIB_TIME_NONE;
  Info->VideoDTimeCode = SLIB_TIME_NONE;
  Info->LastAudioPTimeCode = SLIB_TIME_NONE;
  Info->LastVideoPTimeCode = SLIB_TIME_NONE;
  Info->LastVideoDTimeCode = SLIB_TIME_NONE;
  Info->AvgVideoTimeDiff = 0;
  Info->VarVideoTimeDiff = 0;
  Info->AudioPTimeBase = SLIB_TIME_NONE;
  Info->AudioPTimeCode = SLIB_TIME_NONE;
  Info->AudioDTimeCode = SLIB_TIME_NONE;
  Info->VideoFramesProcessed=0;
  /* Encoding info */
  Info->HeaderProcessed = FALSE;
  Info->PacketCount = 0;
  Info->BytesSincePack = 0;
  /* Miscellaneous */
  Info->SlibCB = NULL;
  Info->SlibCBUserData = NULL;
  Info->Fd = -1;
  Info->FileSize = 0;
  Info->FileBufSize = 50*1024;
  Info->CompBufSize = 2*1024;
  Info->PacketSize = 512;
  Info->AudioFormat = NULL;
  Info->VideoFormat = NULL;
  Info->CompAudioFormat = NULL;
  Info->CompVideoFormat = NULL;
  Info->CodecVideoFormat = NULL;
  Info->VideoCodecState = SLIB_CODEC_STATE_NONE;
  Info->AudioCodecState = SLIB_CODEC_STATE_NONE;
  Info->Imagebuf = NULL;
  Info->IntImagebuf = NULL;
  Info->IntImageSize = 0;
  Info->CodecImagebuf = NULL;
  Info->CodecImageSize = 0;
  Info->Multibuf = NULL;
  Info->MultibufSize = 0;
  Info->Audiobuf = NULL;
  Info->AudiobufSize = 0;
  Info->AudiobufUsed = 0;
  Info->OverflowSize = 1500*1024;
  Info->VBVbufSize = 0;
  Info->stats = NULL;
  Info->dbg = NULL;
}

/*
** Name:    slibGetDataFormat
** Purpose: Find out the type of some multmedia data.
*/
static SlibType_t slibGetDataFormat(unsigned char *buf, int size,
                                             dword *headerstart,
                                             dword *headersize)
{
  dword i, count;
  unsigned char *bufptr;
  if (headersize)
    *headersize=0;
  if (size<4 || !buf)
    return(SLIB_TYPE_UNKNOWN);
  /*
  ** H261 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x01) &&
      (buf[2] & 0xF0)==0x00)
    return(SLIB_TYPE_H261);
  /*
  ** H263 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x00) &&
      (buf[2] == 0x80) &&
      (buf[3] & 0xF8)==0x00)
    return(SLIB_TYPE_H263);
  /*
  ** JFIF file (ffd8 = Start-Of-Image marker)
  */
  if (buf[0] == 0xff && buf[1] == 0xd8)
    return(SLIB_TYPE_JFIF);
  /*
  ** QUICKTIME JPEG file (4 ignored bytes, "mdat", ff, d8, ff)
  */
  if ((strncmp(&buf[4], "mdat", 4) == 0 ) &&
      (buf[8]  == 0xff) &&
      (buf[9]  == 0xd8) &&
      (buf[10] == 0xff))
    return(SLIB_TYPE_JPEG_QUICKTIME);
  /*
  ** AVI RIFF file
  */
  if ( strncmp(buf, "RIFF", 4) == 0 )
  {
    if (strncmp(&buf[8], "WAVE",4) == 0)
      return(SLIB_TYPE_PCM_WAVE);
    else if (strncmp(&buf[8], "AVI ",4) == 0)
      return(SLIB_TYPE_AVI);
    else
      return(SLIB_TYPE_RIFF);
  }
  /*
  ** BMP file
  */
  if (buf[0] == 'B' && buf[1]=='M')
    return(SLIB_TYPE_BMP);
  /*
  ** Dolby AC-3 stream
  */
  if ((buf[0]==0x77 && buf[1] == 0x0B) ||  /* may be byte reversed */
      (buf[0]==0x0B && buf[1] == 0x77))
    return(SLIB_TYPE_AC3_AUDIO);

  /*
  ** Sun Raster file
  */
  if ((buf[0]==0x59 && buf[1] == 0xA6) ||  /* may be byte reversed */
      (buf[0]==0x6A && buf[1] == 0x95))
    return(SLIB_TYPE_RASTER);

  /*
  ** SLIB file
  */
  if ((buf[0] == 'S') && (buf[1] == 'L') &&
      (buf[2] == 'I') && (buf[3] == 'B'))
  {
    if ((buf[4] == 'H') && (buf[5] == 'U') &&  /* SLIB Huffman Stream */
        (buf[6] == 'F') && (buf[7] == 'F'))
      return(SLIB_TYPE_SHUFF);
    else
      return(SLIB_TYPE_SLIB);
  }
  /*
  ** MPEG II Transport Stream
  */
  if (buf[0] == MPEG_TSYNC_CODE &&
        (buf[3]&0x30)!=0) /* adaptation field value is not reserved */
    return(SLIB_TYPE_MPEG_TRANSPORT);
  if (buf[0] == MPEG_TSYNC_CODE && buf[1] == 0x1F &&
        buf[2]==0xFF) /* NULL PID */
    return(SLIB_TYPE_MPEG_TRANSPORT);

  /* search for mpeg startcode 000001 */
  bufptr=buf;
  for (i=4, count=size;
          i<count && (bufptr[0]!=0x00 || bufptr[1]!=0x00 || bufptr[2]!=0x01); i++)
    bufptr++;
  count-=i-4;
  if (headerstart)
    *headerstart=i-4;
  /*
  ** MPEG video file
  */
  if (bufptr[0] == 0x00 && bufptr[1] == 0x00 &&
      bufptr[2] == 0x01 && bufptr[3] == 0xB3)
  {
    if (headersize) /* calculate the header size */
    {
      *headersize=12;  /* minimum size is twelve bytes */
      if (count>11 && (bufptr[11]&0x02)) /* load_intra_quantizer_matrixe */
      {
        *headersize+=64;
        if (count>75 && bufptr[64+11]&0x01) /* load_non_intra_quantizer_matrix */
          *headersize+=64;
      }
      else if (count>11 && (bufptr[11]&0x01)) /* load_non_intra_quant_matrix */
        *headersize+=64;
    }
    return(SLIB_TYPE_MPEG1_VIDEO);
  }
  /*
  ** MPEG I Systems file
  */
  if ((bufptr[0] == 0x00) && (bufptr[1] == 0x00) &&
      (bufptr[2] == 0x01) && (bufptr[3] == 0xba) &&
      ((bufptr[4]&0xF0) == 0x20))
    return(SLIB_TYPE_MPEG_SYSTEMS);
  /*
  ** MPEG II Program Stream
  */
  if ((bufptr[0] == 0x00) && (bufptr[1] == 0x00) &&
      (bufptr[2] == 0x01) && (bufptr[3] == 0xba) &&
      ((bufptr[4]&0xC0) == 0x40))
    return(SLIB_TYPE_MPEG_PROGRAM);
  /*
  ** H263 video stream file
  */
  /* search for H.263 picture startcode 000000000000000100000 */
  for (bufptr=buf, i=0, count=size-4; i<count; i++, bufptr++)
  {
    if ((bufptr[0] == 0x00) &&
        (bufptr[1] == 0x00) &&
        (bufptr[2] == 0x80) &&
        (bufptr[3] & 0xF8)==0x00)
      return(i>=12 ? SLIB_TYPE_RTP_H263 : SLIB_TYPE_H263);
  }
  /*
  ** H261 video stream file
  */
  /* search for H.261 picture startcode 00000000000000010000 */
  for (bufptr=buf, i=0, count=size-3; i<count; i++, bufptr++)
  {
    if ((bufptr[0] == 0x00) &&
        (bufptr[1] == 0x01) &&
        (bufptr[2] & 0xF0)==0x00)
      return(i>=12 ? SLIB_TYPE_RTP_H261 : SLIB_TYPE_H261);
  }
  /*
  ** MPEG audio stream file
  */
  if (buf[0]==0xFF && (buf[1] & 0xF0)==0xF0)
    return(SLIB_TYPE_MPEG1_AUDIO);

#ifdef G723_SUPPORT
  //Detect the RATEFLAG and VADFLAG in each frame in this
  //buffer.
  {
     int i,iFrameSize,iNoOfFrames;
     BOOL bRateFlag; //0 for High rate(6.3K 24bit), 1 for low rate(5.3K,20bit)
     BOOL bVADflag;  // 0 for Active speech  1 for Non-speech
     BOOL bTypeG723 = TRUE; //Initialized to say that it's a g723 media stream

     if(buf[0] & 0x1)
     {
        bRateFlag = TRUE; //Low rate 5.3K
        iFrameSize = 20;
     }
     else
     {
        bRateFlag = FALSE; //High Rate 6.3K
        iFrameSize = 24;
     }
     if(buf[0] & 0x2)
        bVADflag =TRUE;    //Non-Speech
     else
        bVADflag = FALSE;  //Active-Speech

     iNoOfFrames = size/iFrameSize;
     if (iNoOfFrames>15) iNoOfFrames=15; /* just check first 15 frames */
     //Leave the first frame.The first frame is used to extract
     // the above information.Check for this info in the remaining
     // frames.If it exists in all frames,the audio is G723 ,otherwise
     // audio type is Unknown.
     for(i =1; i < iNoOfFrames;i++)
     {
       //Search for RateFlag and bVADflag for each frame
       if(((buf[i*iFrameSize] & 0x1) == bRateFlag) &&
          ((buf[i*iFrameSize] & 0x2) == bVADflag))
         continue;
       //type is Unknown ,Set the flag to false and
       //break from the for loop
       bTypeG723 = FALSE;
       break;
     }
     if(bTypeG723)
       return(SLIB_TYPE_G723);
  }
#endif /* G723_SUPPORT */
  _SlibDebug(_WARN_, printf("slibGetDataFormat() Unknown file format\n") );
  return(SLIB_TYPE_UNKNOWN);
}

SlibStatus_t SlibQueryData(void *databuf, unsigned dword databufsize,
                              SlibQueryInfo_t *qinfo)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  if (!databuf)
    return(SlibErrorBadArgument);
  if (databufsize==0)
    return(SlibErrorBufSize);
  qinfo->Bitrate=0;
  qinfo->VideoStreams=0;
  qinfo->Width=0;
  qinfo->Height=0;
  qinfo->VideoBitrate=0;
  qinfo->FramesPerSec=0.0F;
  qinfo->VideoLength=0;
  qinfo->AudioStreams=0;
  qinfo->SamplesPerSec=0;
  qinfo->BitsPerSample=0;
  qinfo->Channels=0;
  qinfo->AudioBitrate=0;
  qinfo->AudioLength=0;
  qinfo->Type = slibGetDataFormat(databuf, databufsize,
                                  &qinfo->HeaderStart, &qinfo->HeaderSize);
  if (qinfo->Type!=SLIB_TYPE_UNKNOWN)
  {
    if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
      return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Mode = SLIB_MODE_DECOMPRESS;
    Info->Type = qinfo->Type;
    slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
    status=slibManageUserBuffer(NULL, databuf, databufsize, NULL);
    if (status==SlibErrorNone)
      status=slibAddBufferToPin(slibGetPin(Info, SLIB_DATA_COMPRESSED),
                                       databuf, databufsize, SLIB_TIME_NONE);
    if (status!=SlibErrorNone)
    {
      SlibClose((SlibHandle_t)Info);
      return(status);
    }
    slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
    slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    if (Info->TotalBitRate==0)
      qinfo->Bitrate=Info->AudioBitRate+
                     ((Info->VideoBitRate>100000000)?0:Info->VideoBitRate);
    else
      qinfo->Bitrate=Info->TotalBitRate;
    qinfo->VideoStreams=Info->VideoStreams;
    qinfo->Width=Info->Width;
    qinfo->Height=Info->Height;
    qinfo->VideoBitrate=Info->VideoBitRate;
    qinfo->FramesPerSec=Info->FramesPerSec;
    qinfo->VideoLength=Info->VideoLength;
    qinfo->AudioStreams=Info->AudioStreams;
    qinfo->SamplesPerSec=Info->SamplesPerSec;
    qinfo->BitsPerSample=Info->BitsPerSample;
    qinfo->Channels=Info->Channels;
    qinfo->AudioBitrate=Info->AudioBitRate;
    qinfo->AudioLength=Info->AudioLength;
    SlibClose((SlibHandle_t)Info);
    return(SlibErrorNone);
  }
  return(SlibErrorUnsupportedFormat);
}
/************************** The Main Slib API ***********************/

SlibStatus_t SlibOpen(SlibHandle_t *handle, SlibMode_t smode,
                   SlibType_t *stype, SlibMessage_t (*slibCB)(SlibHandle_t,
                         SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *),
                         void *cbuserdata)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpen()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (!slibCB)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
  }
  if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
     return(SlibErrorMemory);
  slibInitInfo(Info);
  slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  Info->SlibCB = slibCB;
  Info->SlibCBUserData = cbuserdata;
  *handle=(SlibHandle_t)Info;
  if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
    *handle = NULL;
  return(status);
}

SlibStatus_t SlibOpenSync(SlibHandle_t *handle, SlibMode_t smode,
                          SlibType_t *stype, void *buffer, unsigned dword bufsize)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpenSync()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    /* for decompression we need the first buffer to open the codecs */
    if (!buffer || bufsize==0)
      return(SlibErrorBadArgument);
  }
  if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
     return(SlibErrorMemory);
  slibInitInfo(Info);
  Info->Mode=smode;
  slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  if (smode == SLIB_MODE_DECOMPRESS)
  {
    status=SlibAddBuffer((SlibHandle_t *)Info, SLIB_DATA_COMPRESSED, buffer, bufsize);
    if (status!=SlibErrorNone)
      return(status);
  }
  *handle=(SlibHandle_t)Info;
  if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
    *handle = NULL;
  return(status);
}

SlibStatus_t SlibOpenFile(SlibHandle_t *handle, SlibMode_t smode,
                          SlibType_t *stype, char *filename)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpenFile()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (!filename)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
    if ((Info = (SlibInfo_t *) ScAlloc(sizeof(SlibInfo_t))) == NULL)
       return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Fd = ScFileOpenForWriting(filename, TRUE);
    if (Info->Fd<0)
    {
      ScFree(Info);
      return(SlibErrorWriting);
    }
    *handle=(SlibHandle_t)Info;
    if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
      *handle = NULL;
    return(status);
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
       return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Fd = ScFileOpenForReading(filename);
    if (Info->Fd<0)
    {
      ScFree(Info);
      return(SlibErrorReading);
    }
    ScFileSize(filename, &Info->FileSize);
    *handle=(SlibHandle_t)Info;
    if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
      *handle = NULL;
    return(status);
  }
  else
    return(SlibErrorBadMode);
}

static SlibStatus_t slibOpen(SlibHandle_t *handle, SlibMode_t smode,
                             SlibType_t *stype)
{
  SlibInfo_t *Info=(SlibInfo_t *)*handle;
  unsigned char *buf;
  unsigned dword size;
  _SlibDebug(_VERBOSE_,printf("SlibOpenFile()\n") );
  if (!Info)
    return(SlibErrorMemory);
  if (!stype)
    return(SlibErrorBadArgument);
  if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
      printf("slibOpen() SlibCB(SLIB_MSG_OPEN)\n") );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                      SLIB_MSG_OPEN, (SlibCBParam1_t)0,
                    (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
  }
  if (smode == SLIB_MODE_COMPRESS)
  {
    Info->Mode = smode;
    Info->Type = *stype;
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
      case SLIB_TYPE_MPEG1_VIDEO:
             Info->VideoStreams = 1;
             if (SvOpenCodec (Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2 ?
                               SV_MPEG2_ENCODE : SV_MPEG_ENCODE,
                               &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             if (Info->Type==SLIB_TYPE_MPEG1_VIDEO)
               break;
      case SLIB_TYPE_MPEG1_AUDIO:
             Info->AudioStreams = 1;
             if (SaOpenCodec (SA_MPEG_ENCODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
             break;
      case SLIB_TYPE_MPEG2_VIDEO:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_MPEG2_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_H261_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_H263_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_HUFF_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
      case SLIB_TYPE_G723:
             Info->AudioStreams = 1;
             if (SaOpenCodec (SA_G723_ENCODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
             break;

#endif /*G723_SUPPORT*/
      default:
             return(SlibErrorUnsupportedFormat);
    }
    slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    Info->Mode = smode;
    /*
    ** Determine the input data type
    */
    if (slibLoadPin(Info, SLIB_DATA_COMPRESSED)==NULL)
      return(SlibErrorReading);
    if ((buf=SlibPeekBuffer(Info, SLIB_DATA_COMPRESSED, &size, NULL))==NULL
             || size<=0)
    {
      /* couldn't get any compressed data */
      SlibClose((SlibHandle_t)Info);
      return(SlibErrorReading);
    }
    Info->Type = slibGetDataFormat(buf, size, NULL, NULL);
    /* if we can't determine the type, use stype as the type */
    if (Info->Type==SLIB_TYPE_UNKNOWN && stype)
      Info->Type=*stype;
    if (SlibFindEnumEntry(_listDecompressTypes, Info->Type)==NULL)
    {
      SlibClose((SlibHandle_t)Info);
      return(SlibErrorUnsupportedFormat);
    }

    slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
    slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
    if (SlibTypeIsMPEGMux(Info->Type))
    {
      /* need to select main streams for multiplexed streams */
      Info->AudioMainStream=MPEG_AUDIO_STREAM_START;
      Info->VideoMainStream=MPEG_VIDEO_STREAM_START;
      /* private data may be needed - i.e. AC3 */
      slibAddPin(Info, SLIB_DATA_PRIVATE, "Private");
    }
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    if (Info->AudioStreams<=0)
      slibRemovePin(Info, SLIB_DATA_AUDIO);
    if (Info->VideoStreams<=0)
      slibRemovePin(Info, SLIB_DATA_VIDEO);

    slibRemovePin(Info, SLIB_DATA_PRIVATE); /* only used in init */
    if (Info->AudioBitRate && Info->VideoBitRate)
    {
      if (!Info->VideoLengthKnown)
      {
        qword ms=((qword)Info->FileSize*80L)/
                   (Info->AudioBitRate+Info->VideoBitRate);
        ms = (ms*75)/80; /* adjust for systems data */
        Info->AudioLength = Info->VideoLength = (SlibTime_t)ms*100;
        _SlibDebug(_SEEK_||_VERBOSE_,
            ScDebugPrintf(Info->dbg,"slibOpen() FileSize=%ld VideoLength=%ld\n",
                    Info->FileSize, Info->VideoLength) );
      }
      else if (Info->VideoLengthKnown && Info->FramesPerSec)
        Info->AudioLength = Info->VideoLength;
    }
    if (Info->TotalBitRate==0)
      Info->TotalBitRate=Info->AudioBitRate +
                     ((Info->VideoBitRate>100000000)?0:Info->VideoBitRate);
    _SlibDebug(_SEEK_||_VERBOSE_,
               ScDebugPrintf(Info->dbg,"AudioLength=%ld VideoLength=%ld %s\n",
                   Info->AudioLength, Info->VideoLength,
                   Info->VideoLengthKnown?"(known)":"") );

    if (Info->AudioType==SLIB_TYPE_UNKNOWN &&
        Info->VideoType==SLIB_TYPE_UNKNOWN)
      return(SlibErrorUnsupportedFormat);
    switch (Info->AudioType)
    {
      case SLIB_TYPE_UNKNOWN:
             break;
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_AUDIO:
             if (SaOpenCodec (SA_MPEG_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
             if (SaOpenCodec (SA_GSM_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
	  case SLIB_TYPE_AC3_AUDIO:
             if (SaOpenCodec (SA_AC3_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
      case SLIB_TYPE_G723:
             if (SaOpenCodec (SA_G723_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* G723_SUPPORT */
    } /* AudioType */
    switch (Info->VideoType)
    {
      case SLIB_TYPE_UNKNOWN:
             break;
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
             if (SvOpenCodec (SV_MPEG_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
      case SLIB_TYPE_MPEG2_VIDEO:
             if (SvOpenCodec (SV_MPEG2_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
             if (SvOpenCodec (SV_H261_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
             if (SvOpenCodec (SV_H263_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
             if (SvOpenCodec (SV_HUFF_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* HUFF_SUPPORT */
#ifdef JPEG_SUPPORT
      case SLIB_TYPE_JPEG:
      case SLIB_TYPE_MJPG:
             if (SvOpenCodec (SV_JPEG_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* JPEG_SUPPORT */
    } /* VideoType */
  }
  else
    return(SlibErrorBadMode);
  *stype = Info->Type;
  return(SlibErrorNone);
}

SlibStatus_t SlibAddBuffer(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibPin_t *dstpin;
  if (!handle)
    return(SlibErrorBadHandle);
  dstpin = slibGetPin(Info, dtype);
  if (dstpin==NULL || buffer==NULL)
    return(SlibErrorBadArgument);
  if (Info->SlibCB)
  {
    status=slibManageUserBuffer(Info, buffer, bufsize, NULL);
    if (status!=SlibErrorNone)
      return(status);
    status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  }
  else if (!SlibValidBuffer(buffer))
  {
    /* we need to create a SLIB allocated buffer to copy the
     * output to and then add to the compressed data pin
     */
    unsigned char *bufptr=SlibAllocBuffer(bufsize);
    if (!bufptr)
      return(SlibErrorMemory);
    memcpy(bufptr, buffer, bufsize);
    status=slibAddBufferToPin(dstpin, bufptr, bufsize, SLIB_TIME_NONE);
  }
  else
    status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  if (Info->Mode==SLIB_MODE_DECOMPRESS)
  {
    ScBitstream_t *BS;
    Info->IOError=FALSE;
    /* reset end-of-input flags in bitstream objects */
    if (Info->Svh)
    {
      BS=SvGetDataSource(Info->Svh);
      if (BS && BS->EOI) ScBSReset(BS);
    }
    if (Info->Sah)
    {
      BS=SaGetDataSource(Info->Sah);
      if (BS && BS->EOI) ScBSReset(BS);
    }
  }
  return(status);
}

SlibStatus_t SlibAddBufferEx(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize,
                                void *userdata)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibPin_t *dstpin;
  if (!handle)
    return(SlibErrorBadHandle);
  dstpin = slibGetPin(Info, dtype);
  if (dstpin==NULL || buffer==NULL)
    return(SlibErrorBadArgument);
  status=slibManageUserBuffer(Info, buffer, bufsize, userdata);
  if (status!=SlibErrorNone)
    return(status);
  status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  return(status);
}

SlibStatus_t slibStartVideo(SlibInfo_t *Info, SlibBoolean_t fillbuf)
{
  SvStatus_t status=SvErrorNone;
  _SlibDebug(_VERBOSE_,printf("slibStartVideo()\n") );
  if (Info->VideoCodecState==SLIB_CODEC_STATE_NONE ||
      Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"slibStartVideo(filebuf=%d) %s\n",
      fillbuf,Info->VideoCodecState==SLIB_CODEC_STATE_NONE ? "NONE" : "BEGUN") );
    return(SlibErrorNone);
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_OPEN)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"slibStartVideo(filebuf=%d) OPEN\n",
                                                      fillbuf));
    if (Info->Mode==SLIB_MODE_DECOMPRESS)
    {
      if (Info->Type==SLIB_TYPE_YUV_AVI)
      {
        Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
      else if (Info->Svh)
      {
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"SvRegisterCallback()\n") );
        status = SvRegisterCallback(Info->Svh, VDecompressCallback, (void *)Info);
        /* if codec is not bitstreaming, don't use callbacks */
        if (status==SlibErrorNone && SvGetDataSource(Info->Svh)==NULL)
        {
          _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"SvRegisterCallback(NULL)\n") );
          status = SvRegisterCallback(Info->Svh, NULL, NULL);
        }
        _SlibDebug(_WARN_ && status!=SvErrorNone,
                           ScDebugPrintf(Info->dbg,"SvRegisterCallback() %s\n",
                             ScGetErrorStr(status)) );
        Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("VideoCodecState=INITED\n"));
      }
    }
    else if (Info->Mode==SLIB_MODE_COMPRESS)
    {
      if (Info->TotalBitRate==0)
      {
#ifdef MPEG_SUPPORT
        if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS || /* default to 1XCDROM rate */
            Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2)
          SlibSetParamInt((SlibHandle_t)Info, SLIB_STREAM_ALL,
                          SLIB_PARAM_BITRATE, 44100*16*2);
#endif
        slibValidateBitrates(Info);  /* update bitrates */
      }
      if (Info->Svh)
      {
        status = SvRegisterCallback(Info->Svh, VCompressCallback, (void *)Info);
        _SlibDebug(_WARN_ && status!=SvErrorNone,
                      ScDebugPrintf(Info->dbg,"SvRegisterCallback() %s\n",
                           ScGetErrorStr(status)) );
        /* if codec is not bitstreaming, don't use callbacks */
        if (status==SlibErrorNone && SvGetDataDestination(Info->Svh)==NULL)
          status = SvRegisterCallback(Info->Svh, NULL, NULL);
        Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
    }
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_INITED ||
      Info->VideoCodecState==SLIB_CODEC_STATE_REPOSITIONING)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,
           "slibStartVideo(fillbuf=%d) INITED || REPOSITIONING\n",fillbuf));
    if (Info->Mode==SLIB_MODE_DECOMPRESS)
    {
      if (Info->Type==SLIB_TYPE_YUV_AVI)
      {
        if (Info->CompVideoFormat->biCompression !=
             Info->VideoFormat->biCompression &&
             Info->Multibuf==NULL)
        {
          Info->MultibufSize=Info->ImageSize;
          Info->Multibuf = SlibAllocSharedBuffer(Info->MultibufSize, NULL);
        }
      }
      else if (Info->Svh)
      {
        int mbufsize;
        if (1) /* fillbuf && Info->CodecVideoFormat) */
        {
          Info->CodecVideoFormat->biCompression=
            SlibGetParamInt((SlibHandle_t)Info, SLIB_STREAM_MAINVIDEO,
                                       SLIB_PARAM_NATIVEVIDEOFORMAT);
          if (Info->CodecVideoFormat->biCompression==0)
            Info->CodecVideoFormat->biCompression=
                       Info->VideoFormat->biCompression;
        }
        else
        {
          Info->CodecVideoFormat->biCompression=
                       Info->VideoFormat->biCompression;
          Info->CodecVideoFormat->biBitCount=
                       Info->VideoFormat->biBitCount;
        }
        slibValidateVideoParams(Info);
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,
                    "SvDecompressBegin(%c%c%c%c/%d bits,%c%c%c%c/%d bits)\n",
                     (Info->CompVideoFormat->biCompression)&0xFF,
                     (Info->CompVideoFormat->biCompression>>8)&0xFF,
                     (Info->CompVideoFormat->biCompression>>16)&0xFF,
                     (Info->CompVideoFormat->biCompression>>24)&0xFF,
                      Info->CompVideoFormat->biBitCount,
                     (Info->CodecVideoFormat->biCompression)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>8)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>16)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>24)&0xFF,
                      Info->CodecVideoFormat->biBitCount) );
        status=SvDecompressBegin(Info->Svh, Info->CompVideoFormat,
                          Info->CodecVideoFormat);
        if (status==SvErrorNone)
        {
          Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
          Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
          Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
          Info->HeaderProcessed=TRUE; /* we must have processed header info */
          _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
        }
        else if (status==SvErrorEndBitstream)
          return(SlibErrorNoBeginning);
        else
        {
          _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SvDecompressBegin() %s\n",
                                ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvGetDecompressSize\n") );
        SvGetDecompressSize(Info->Svh, &mbufsize);
        if (Info->Multibuf==NULL || Info->MultibufSize<mbufsize)
        {
          if (Info->Multibuf) SlibFreeBuffer(Info->Multibuf);
          Info->MultibufSize=mbufsize;
          Info->Multibuf = SlibAllocSharedBuffer(Info->MultibufSize, NULL);
        }
      }
    }
    else if (Info->Mode==SLIB_MODE_COMPRESS && Info->Svh)
    {
      status=SvCompressBegin(Info->Svh, Info->CodecVideoFormat,
                             Info->CompVideoFormat);
      if (status==SvErrorNone)
      {
        Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
        Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
        Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
      else
      {
        _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SvCompressBegin() %s\n",
                                 ScGetErrorStr(status)) );
        return(SlibErrorUnsupportedFormat);
      }
    }
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
    return(SlibErrorNone);
  else
    return(SlibErrorInit);
}

static SlibStatus_t slibStartAudio(SlibInfo_t *Info)
{
  SvStatus_t status=SvErrorNone;
  _SlibDebug(_VERBOSE_,printf("slibStartAudio()\n") );
  if (Info->AudioCodecState==SLIB_CODEC_STATE_NONE ||
      Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() %s\n",
      Info->AudioCodecState==SLIB_CODEC_STATE_NONE ? "NONE" : "BEGUN") );
    return(SlibErrorNone);
  }
  if (Info->AudioCodecState==SLIB_CODEC_STATE_OPEN)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() OPEN\n"));
    if (Info->Sah)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
      {
        status = SaRegisterCallback(Info->Sah, ADecompressCallback, (void *)Info);
        if (status!=SaErrorNone)
        {
          _SlibDebug(_WARN_, printf("SaRegisterCallback() ",
                         ScGetErrorStr(status)) );
          return(SlibErrorInternal);
        }
        status = SaSetDataSource(Info->Sah, SA_USE_BUFFER_QUEUE, 0, (void *)Info, 0);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                       printf("SaSetDataSource() ", ScGetErrorStr(status)) );
        Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("AudioCodecState=INITED\n"));
      }
      else if (Info->Mode==SLIB_MODE_COMPRESS)
      {
        if (Info->TotalBitRate==0)
        {
#ifdef MPEG_SUPPORT
          /* default to 1X CDROM rate */
          if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS ||
              Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2)
            SlibSetParamInt((SlibHandle_t)Info, SLIB_STREAM_ALL,
                          SLIB_PARAM_BITRATE, 44100*16*2);
#endif
          slibValidateBitrates(Info);  /* update bitrates */
        }
        status = SaRegisterCallback(Info->Sah, ACompressCallback, (void *)Info);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                  printf("SaRegisterCallback() %s\n", ScGetErrorStr(status)) );
        status = SaSetDataDestination(Info->Sah, SA_USE_BUFFER_QUEUE, 0,
                                      (void *)Info, 0);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                        printf("SaSetDataDestination() %s\n",
                           ScGetErrorStr(status)) );
        Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("AudioCodecState=INITED\n"));
      }
    }
  }
  if (Info->AudioCodecState==SLIB_CODEC_STATE_INITED ||
      Info->AudioCodecState==SLIB_CODEC_STATE_REPOSITIONING)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() INITED || REPOSITIONING\n"));
    if (Info->Sah)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
      {
        Info->AudiobufUsed=0;
        /* don't want codec to search through to much data for start */
        status=SaDecompressBegin(Info->Sah, Info->CompAudioFormat,
                                 Info->AudioFormat);
        if (status==SaErrorNone)
        {
          Info->AudioCodecState=SLIB_CODEC_STATE_BEGUN;
          _SlibDebug(_DEBUG_,printf("AudioCodecState=BEGUN\n"));
        }
        else if (status==SlibErrorNoBeginning)
          return(SlibErrorEndOfStream);
        else
        {
          _SlibDebug(_WARN_, printf("SaDecompressBegin() %s\n",
                               ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
      }
      else if (Info->Mode==SLIB_MODE_COMPRESS)
      {
        status=SaCompressBegin(Info->Sah, Info->AudioFormat,
                          Info->CompAudioFormat);
        if (status==SvErrorNone)
        {
          Info->AudioCodecState=SLIB_CODEC_STATE_BEGUN;
          _SlibDebug(_DEBUG_,printf("AudioCodecState=BEGUN\n"));
        }
        else
        {
          _SlibDebug(_WARN_, printf("SaCompressBegin() %s\n",
                               ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
      }
    }
  }
  return(SlibErrorNone);
}


SlibStatus_t SlibRegisterVideoBuffer(SlibHandle_t handle,
                                void *buffer, unsigned dword bufsize)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  dword mbufsize;
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Multibuf) SlibFreeBuffer(Info->Multibuf);
  Info->MultibufSize=bufsize;
  Info->Multibuf = buffer;
  status=slibManageUserBuffer(Info, buffer, bufsize, NULL);
  if (Info->Svh)
  {
    SvGetDecompressSize(Info->Svh, &mbufsize);
    if (bufsize<(unsigned dword)mbufsize)
      return(SlibErrorBufSize);
  }
  return(status);
}

SlibStatus_t SlibReadData(SlibHandle_t handle, SlibStream_t stream,
                          void **databuf, unsigned dword *databufsize,
                          SlibStream_t *readstream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  int pinid;
  SlibPin_t *pin;
  SlibTime_t ptimestamp;
  _SlibDebug(_VERBOSE_, printf("SlibReadDATA()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!databuf) /* we're querying to find out how much data is queued */
  {
    if (!databufsize)
      return(SlibErrorBadArgument);
    if (Info->Mode==SLIB_MODE_COMPRESS)
      pinid=SLIB_DATA_COMPRESSED;
    else if (stream==SLIB_STREAM_MAINVIDEO)
      pinid=SLIB_DATA_VIDEO;
    else if (stream==SLIB_STREAM_MAINAUDIO)
      pinid=SLIB_DATA_AUDIO;
    else
    {
      *databufsize=(unsigned dword)slibDataOnPins(Info); /* get amount of data on all pins */
      return(SlibErrorNone);
    }
    *databufsize=(unsigned dword)slibDataOnPin(Info, SLIB_DATA_COMPRESSED);
    return(SlibErrorNone);
  }
  if (Info->Mode==SLIB_MODE_COMPRESS)
  {
    pinid=SLIB_DATA_COMPRESSED;
    stream=SLIB_STREAM_ALL;
    /* flush out all compressed data */
    if (Info->Sah)
      ScBSFlush(SaGetDataDestination(Info->Sah));
    if (Info->Svh)
      ScBSFlush(SvGetDataDestination(Info->Svh));
  }
  else /* SLIB_MODE_DECOMPRESS */
  {
    if (stream==SLIB_STREAM_ALL && (Info->AudioStreams || Info->VideoStreams))
    {
      if (Info->AudioStreams==0) /* there's only video */
        stream=SLIB_STREAM_MAINVIDEO;
      else if (Info->VideoStreams==0) /* there's only audio */
        stream=SLIB_STREAM_MAINAUDIO;
      else if (slibDataOnPin(Info, SLIB_DATA_AUDIO)>
               slibDataOnPin(Info, SLIB_DATA_VIDEO)) /* more audio than video */
        stream=SLIB_STREAM_MAINAUDIO;
      else
        stream=SLIB_STREAM_MAINVIDEO;
    }
    switch (stream) /* translate stream to pin */
    {
      case SLIB_STREAM_MAINVIDEO:
          pinid=SLIB_DATA_VIDEO;
          break;
      case SLIB_STREAM_MAINAUDIO:
          pinid=SLIB_DATA_AUDIO;
          break;
      default:
          return(SlibErrorBadStream);
    }
  }
  if (readstream)
    *readstream=stream;
  pin=slibLoadPin(Info,  pinid);
  if (pin==NULL)
    return(Info->Mode==SLIB_MODE_COMPRESS?SlibErrorNoData:SlibErrorBadStream);
  if (stream==SLIB_STREAM_MAINVIDEO && Info->Mode==SLIB_MODE_DECOMPRESS &&
      Info->VideoPTimeCode==SLIB_TIME_NONE &&
      SlibTypeIsMPEG(Info->Type))
  {
    /* search from GOP start */
    dword i, iend;
    SlibTime_t nexttime;
    unsigned char *tmpbuf, *prevbuf=NULL;
    unsigned dword tmpsize, bytessearched=0;
    tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &ptimestamp);
    if (tmpbuf==NULL)
      return(SlibErrorEndOfStream);
    do {
      for (i=0, iend=tmpsize-3; i<iend; i++)
        if (tmpbuf[i]==0&&tmpbuf[i+1]==0&&tmpbuf[i+2]==1&&
                      (tmpbuf[i+3]==0xB8||tmpbuf[i+3]==0xB3))
          break;
      if (i<iend)
      {
        slibInsertBufferOnPin(pin, tmpbuf+i, tmpsize-i, ptimestamp);
        tmpbuf=NULL;
        break;
      }
      else if (tmpbuf[i]==0 && tmpbuf[i+1]==0 && tmpbuf[i+2]==1)
      {
        prevbuf=tmpbuf+tmpsize-3;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==0xB8||tmpbuf[0]==0xB3)
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 3, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else if (tmpbuf[i+1]==0 && tmpbuf[i+2]==0)
      {
        prevbuf=tmpbuf+tmpsize-2;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==1 && (tmpbuf[1]==0xB8||tmpbuf[0]==0xB3))
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 2, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else if (tmpbuf[i+2]==0)
      {
        prevbuf=tmpbuf+tmpsize-1;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==0 && tmpbuf[1]==1 && (tmpbuf[2]==0xB8||tmpbuf[0]==0xB3))
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 1, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else
      {
        SlibFreeBuffer(tmpbuf);
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
      }
      bytessearched+=tmpsize;
    } while (tmpbuf && bytessearched<512*1024);
  }
  if (*databuf==NULL)
    *databuf=SlibGetBuffer(Info, pinid, databufsize, &ptimestamp);
  else
    *databufsize=slibFillBufferFromPin(Info, pin, *databuf, *databufsize,
                          &ptimestamp);
  if (Info->Mode==SLIB_MODE_DECOMPRESS)
  {
    if (ptimestamp!=SLIB_TIME_NONE)
      switch (stream) /* set presentation timecodes */
      {
        case SLIB_STREAM_MAINVIDEO:
            Info->VideoPTimeCode=ptimestamp;
            _SlibDebug(_TIMECODE_ || _VERBOSE_,
               printf("SlibReadData() VideoPTimeCode=%ld\n", ptimestamp) );
            break;
        case SLIB_STREAM_MAINAUDIO:
            Info->AudioPTimeCode=ptimestamp;
            _SlibDebug(_TIMECODE_ || _VERBOSE_,
               printf("SlibReadData() AudioPTimeCode=%ld\n", ptimestamp) );
            break;
      }
    else if (stream==SLIB_STREAM_MAINVIDEO &&
             Info->VideoPTimeCode==SLIB_TIME_NONE)
      Info->VideoPTimeCode=SLIB_TIME_UNKNOWN;
  }
  if (*databuf==NULL || *databufsize==0)
  {
    if (!slibDataOnPin(Info, pinid))
      return(SlibErrorEndOfStream);
    else
      return(SlibErrorReading);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibReadVideo(SlibHandle_t handle, SlibStream_t stream,
                      void **videobuf, unsigned dword *videobufsize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SvErrorNone;
  unsigned char *imagebuf=NULL;
  SlibTime_t startvideotime;
  _SlibDebug(_VERBOSE_, printf("SlibReadVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!videobuf)
    return(SlibErrorBadArgument);
/*
  imagesize=(Info->Width*Info->Height*3)/2;
  if (videobufsize<imagesize)
    return(SlibErrorBufSize);
*/
  if (Info->Mode!=SLIB_MODE_DECOMPRESS)
    return(SlibErrorBadMode);
  if (Info->VideoFormat==NULL || Info->CodecVideoFormat==NULL ||
               Info->CompVideoFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if ((status=slibStartVideo(Info, (SlibBoolean_t)((*videobuf==NULL)?FALSE:TRUE)))
                  !=SlibErrorNone)
    return(status);
  startvideotime=Info->VideoTimeStamp;
  switch(Info->VideoType)
  {
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_VIDEO:
    case SLIB_TYPE_MPEG2_VIDEO:
        do {
          _SlibDebug(_DEBUG_, printf("SvDecompressMPEG()\n") );
          status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                             Info->MultibufSize, &imagebuf);
          _SlibDebug(_WARN_ && status!=SvErrorNone,
                             printf("SvDecompressMPEG() %s\n",
                               ScGetErrorStr(status)) );
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        _SlibDebug(_SEEK_>1, printf("timecode=%d ms  framenum=%d\n",
                SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE),
                SvGetParamInt(Info->Svh, SV_PARAM_FRAME) ) );
        break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SLIB_TYPE_H261:
        do {
          _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompressH261()\n") );
          status = SvDecompressH261(Info->Svh, Info->Multibuf,
                                    Info->MultibufSize,
                                    &imagebuf);
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SLIB_TYPE_H263:
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress(%d bytes)\n", Info->MultibufSize) );
        status=SvDecompress(Info->Svh, NULL, 0,
                                 Info->Multibuf, Info->MultibufSize);
        imagebuf=Info->Multibuf;
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* H263_SUPPORT */
#ifdef JPEG_SUPPORT
    case SLIB_TYPE_JPEG:
    case SLIB_TYPE_MJPG:
        {
          unsigned dword bufsize;
          unsigned char *buf;
          buf=SlibGetBuffer(Info, SLIB_DATA_VIDEO, &bufsize, NULL);
          if (buf)
          {
            /* ScDumpChar(buf, 10000, 0); */
            _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress(%d bytes)\n", bufsize) );
            status=SvDecompress(Info->Svh, buf, bufsize,
                                 Info->Multibuf, Info->MultibufSize);
            imagebuf=Info->Multibuf;
            SlibFreeBuffer(buf);
          }
          else
            status=SvErrorForeign;
          if (status==SvErrorNone)
            SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        }
        break;
#endif /* JPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    case SLIB_TYPE_SHUFF:
        if (*videobuf==NULL)
        {
          if (Info->Imagebuf==NULL &&
              (Info->Imagebuf=SlibAllocBuffer(Info->ImageSize))==NULL)
            return(SlibErrorMemory);
          imagebuf=Info->Imagebuf;
        }
        else
          imagebuf=*videobuf;
        do {
          _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress()\n") );
          status=SvDecompress(Info->Svh, NULL, 0,
                               imagebuf,  Info->CodecVideoFormat->biSizeImage);
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* HUFF_SUPPORT */
    case SLIB_TYPE_RASTER:
    case SLIB_TYPE_YUV:
        if (*videobuf && videobufsize && *videobufsize==0)
          return(SlibErrorBadArgument);
        imagebuf=SlibGetBuffer(Info, SLIB_DATA_VIDEO, videobufsize, NULL);

        if (*videobufsize==0)
          status=SvErrorEndBitstream;
        _SlibDebug(_DEBUG_,
               ScDebugPrintf(Info->dbg,"Video frame size = %d ImageSize=%d\n",
                     *videobufsize, Info->ImageSize) );
        break;
    default:
        return(SlibErrorUnsupportedFormat);
  }

  if (status==SvErrorNone)
  {
    /* format conversion */
    if (Info->Sch==NULL) /* start the format converter */
    {
      if (Info->Svh) /* compressed video format */
      {
        unsigned dword fourcc=(unsigned dword)SvGetParamInt(Info->Svh, SV_PARAM_FINALFORMAT);
        if (fourcc)
        {
          Info->CodecVideoFormat->biCompression=fourcc;
          Info->CodecVideoFormat->biBitCount=
                (WORD)slibCalcBits(fourcc, Info->CodecVideoFormat->biBitCount);
        }
      }
      else /* uncompressed video format */
        memcpy(Info->CodecVideoFormat, Info->CompVideoFormat, sizeof(BITMAPINFOHEADER));
      if (SconOpen(&Info->Sch, SCON_MODE_VIDEO, (void *)Info->CodecVideoFormat, (void *)Info->VideoFormat)
           !=SconErrorNone)
        return(SlibErrorUnsupportedFormat);
      if (Info->Stride)
        SconSetParamInt(Info->Sch, SCON_OUTPUT, SCON_PARAM_STRIDE, Info->Stride);

    }
    if (SconIsSame(Info->Sch) && *videobuf == NULL) /* no conversion */
      *videobuf=imagebuf;
    else
    {
      if (*videobuf == NULL && (*videobuf=SlibAllocBuffer(Info->ImageSize))==NULL)
        return(SlibErrorMemory);
      if (SconConvert(Info->Sch, imagebuf, Info->CodecVideoFormat->biSizeImage,
                      *videobuf, Info->ImageSize) != SconErrorNone)
      {
        SlibFreeBuffer(imagebuf); /* free decompressed image */
        return(SlibErrorUnsupportedFormat);
      }
      SlibFreeBuffer(imagebuf); /* free decompressed image */
    }
    *videobufsize = Info->ImageSize;
    /* update stats */
    if (Info->stats && Info->stats->Record)
      Info->stats->FramesProcessed++;
    if (startvideotime==Info->VideoTimeStamp) /* video time hasn't changed */
      slibAdvancePositions(Info, 1);
  }
  else
  {
    if (status==ScErrorEndBitstream ||
        !slibDataOnPin(Info, SLIB_DATA_VIDEO))
    {
      if (Info->FileSize>0 && !Info->VideoLengthKnown)
        slibUpdateLengths(Info);
      _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SlibReadVideo() %s\n",
                           ScGetErrorStr(status)) );
      return(SlibErrorEndOfStream);
    }
    _SlibDebug(_WARN_, printf("SlibReadVideo() %s\n",
                           ScGetErrorStr(status)) );
    return(SlibErrorReading);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibReadAudio(SlibHandle_t handle, SlibStream_t stream,
                     void *audiobuf, unsigned dword *audiobufsize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SaErrorNone;
  unsigned dword totalbytes=0, bytes_since_timeupdate=0;
  SlibTime_t startaudiotime;
#ifdef _SLIBDEBUG_
  SlibTime_t calcaudiotime;
#endif

  _SlibDebug(_VERBOSE_, printf("SlibReadAudio(audiobufsize=%d, time=%d)\n",
                                  *audiobufsize, Info->AudioTimeStamp) );
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Mode!=SLIB_MODE_DECOMPRESS)
    return(SlibErrorBadMode);
  if (Info->AudioFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if ((status=slibStartAudio(Info))!=SlibErrorNone)
    return(status);
#ifdef _SLIBDEBUG_
  calcaudiotime=Info->AudioTimeStamp;
#endif
  startaudiotime=Info->AudioTimeStamp;
  switch(Info->AudioType)
  {
    case SLIB_TYPE_PCM:
        totalbytes=slibFillBufferFromPin(Info,
                                   slibGetPin(Info, SLIB_DATA_AUDIO),
                                   (unsigned char *)audiobuf, *audiobufsize,
                                   NULL);
        if (totalbytes==0)
          status=ScErrorEndBitstream;
        *audiobufsize = totalbytes;
        bytes_since_timeupdate = totalbytes;
        break;
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_AUDIO:
	{
	  unsigned dword bytes;
          /* see if some bytes of audio are left in the temp audio buffer */
          if (Info->Audiobuf && Info->AudiobufUsed>0)
          {
            _SlibDebug(_DEBUG_,
                 printf("SlibReadAudio() Audiobuf contains %d bytes\n",
                      Info->AudiobufUsed) );
            if (*audiobufsize>=Info->AudiobufUsed)
            {
              memcpy(audiobuf, Info->Audiobuf, Info->AudiobufUsed);
              totalbytes=Info->AudiobufUsed;
              Info->AudiobufUsed=0;
            }
            else
            {
              memcpy(audiobuf, Info->Audiobuf, *audiobufsize);
              totalbytes=*audiobufsize;
              Info->AudiobufUsed-=*audiobufsize;
              memcpy(Info->Audiobuf, Info->Audiobuf+*audiobufsize,
                                 Info->AudiobufUsed);
            }
          }
          /* need to alloc a temp audio buffer? */
          if (!Info->Audiobuf || Info->AudiobufSize<
                     *audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4)
          {
            unsigned char *newbuf;
            /* enlarge Audiobuf or alloc it for the first time */
            _SlibDebug(_DEBUG_,
                printf("SlibReadAudio() enlarging Audiobuf: %d->%d bytes\n",
                 Info->AudiobufSize,*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4) );
            newbuf=SlibAllocBuffer(*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4);
            if (!newbuf)
              return(SlibErrorMemory);
            Info->AudiobufSize=*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4;
            if (Info->Audiobuf)
              SlibFreeBuffer(Info->Audiobuf);
            Info->Audiobuf=newbuf;
            Info->AudiobufUsed=0;
          }
          if (*audiobufsize>=MPEG1_AUDIO_FRAME_SIZE*4)
          {
            unsigned dword stopbytes=*audiobufsize-(MPEG1_AUDIO_FRAME_SIZE*4)+1;
            while (status==SaErrorNone && totalbytes<stopbytes)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_,
                  printf("SaDecompress(bytes=%d) in totalbytes=%d\n",
                                        bytes, totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                           (unsigned char *)audiobuf+totalbytes, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out: bytes=%d\n",
                                            bytes) );
              totalbytes += bytes;
              if (Info->AudioTimeStamp!=startaudiotime)
              {
                startaudiotime=Info->AudioTimeStamp;
                bytes_since_timeupdate=bytes;
              }
              else
                bytes_since_timeupdate+=bytes;
            }
          }
          if (totalbytes<*audiobufsize && status==SaErrorNone)
          {
            unsigned dword neededbytes=*audiobufsize-totalbytes;
            while (status==SaErrorNone && Info->AudiobufUsed<neededbytes)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                          totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                  (unsigned char *)Info->Audiobuf+Info->AudiobufUsed, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                            bytes) );
              Info->AudiobufUsed += bytes;
            }
            if (Info->AudiobufUsed>0)
            {
              if (Info->AudiobufUsed>neededbytes) /* complete buffer returned */
              {
                memcpy((unsigned char*)audiobuf+totalbytes,
                        Info->Audiobuf, neededbytes);
                Info->AudiobufUsed-=neededbytes;
                memcpy(Info->Audiobuf, Info->Audiobuf+neededbytes,
                                   Info->AudiobufUsed);
                totalbytes+=neededbytes;
                bytes_since_timeupdate+=neededbytes;
              }
              else  /* partially filled buffer */
              {
                memcpy((unsigned char*)audiobuf+totalbytes, Info->Audiobuf,
                       Info->AudiobufUsed);
                totalbytes+=Info->AudiobufUsed;
                Info->AudiobufUsed=0;
              }
            }
          }
          *audiobufsize = totalbytes;
          _SlibDebug(_WARN_>1 && totalbytes>0 &&
                       totalbytes!=*audiobufsize,
             printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
	}
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
    case SLIB_TYPE_AC3_AUDIO:
	{
	  unsigned dword bytes;
	  unsigned int framesize;
	  unsigned int buffersize;
	  int samplesize;
	  int buffers;
	  unsigned char *pointers[3];
	  int i;

	  if (Info->Channels>2)
	  {
            framesize = AC3_FRAME_SIZE*((Info->BitsPerSample+7)/8)
                                      *Info->Channels;
            samplesize=Info->Channels*((Info->BitsPerSample+7)/8);
            buffers = (Info->Channels+1)/2;
            buffersize = (*audiobufsize/samplesize/buffers)*samplesize;

            for(i=0; i<buffers; i++)
              pointers[i]=(unsigned char *)audiobuf+buffersize*i;

            if (*audiobufsize>=framesize)
            {
              while (status==SaErrorNone && totalbytes<buffersize)
              {
                bytes = buffersize - totalbytes;
                _SlibDebug(_DEBUG_,printf("SaDecompressEx() in totalbytes=%d\n",
                                   totalbytes) );
                status = SaDecompressEx(Info->Sah, NULL, 0, pointers, &bytes);
                _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                            bytes) );
                for(i=0;i<buffers;i++)
                  pointers[i]+=bytes;
                totalbytes += bytes;
                if (Info->AudioTimeStamp!=startaudiotime)
                {
                  startaudiotime=Info->AudioTimeStamp;
                  bytes_since_timeupdate=bytes;
                }
                else
                  bytes_since_timeupdate+=bytes;
              }
            }
	  }
	  else
	  {
            while (status==SaErrorNone && totalbytes<*audiobufsize)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                   totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                             (unsigned char *)audiobuf+totalbytes, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                    bytes) );
              totalbytes += bytes;
              if (Info->AudioTimeStamp!=startaudiotime)
              {
                startaudiotime=Info->AudioTimeStamp;
                bytes_since_timeupdate=bytes;
              }
              else
                bytes_since_timeupdate+=bytes;
            }
	  }
          /*
          ** NOTE: The semantics are different here
          **       we return the size of just one stereo pair's buffer
          */
          *audiobufsize = totalbytes;
          _SlibDebug(_WARN_>1 && totalbytes>0 &&
                       totalbytes!=*audiobufsize,
             printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
	}
        break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
    case SLIB_TYPE_G723:
    //G723 decompresses in multiples of 480 samples.
    //To eliminate cumbersome buffer calculations,
    // Always fill the output buffer up to multiples
    // of 480 samples.To do this we iterate basically
    // the below "while" loop "audiobufsize/480 times.
    {
      int iTimes = (int)*audiobufsize/480;
      int iLoop =0;
	  unsigned dword bytes;
      if (slibInSyncMode(Info))
      {
        /* in synchronous mode we can't decompress past last frame
         * otherwise we may lose a frame
         */
        int iMaxTimes=(int)(slibDataOnPin(Info, SLIB_DATA_COMPRESSED)+
                           slibDataOnPin(Info, SLIB_DATA_AUDIO))/
                       SlibGetParamInt(handle, stream, SLIB_PARAM_MININPUTSIZE);
        if (iTimes>iMaxTimes)
          iTimes=iMaxTimes;
      }
      while (status==SaErrorNone && iLoop<iTimes)
      {
         bytes = *audiobufsize - totalbytes;
         _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                totalbytes) );
         status = SaDecompress(Info->Sah, NULL, 0,
            (unsigned char *)audiobuf+totalbytes, &bytes);
         _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                    bytes) );
         totalbytes += bytes;
         iLoop++;
         if (Info->AudioTimeStamp!=startaudiotime)
         {
            startaudiotime=Info->AudioTimeStamp;
            bytes_since_timeupdate=bytes;
         }
         else
            bytes_since_timeupdate+=bytes;
      }
      *audiobufsize = totalbytes;

      _SlibDebug(_WARN_>1 && totalbytes>0 &&
                  totalbytes!=*audiobufsize,
       printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
    }
    break;
#endif /* G723_SUPPORT */
    default:
        *audiobufsize = 0;
        return(SlibErrorUnsupportedFormat);
  }
  /* as we're decompressing audiotime may be updated with timecodes */
  if (Info->AudioTimeStamp==startaudiotime)
    Info->AudioTimeStamp = startaudiotime + (bytes_since_timeupdate*8000)/
           (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
  _SlibDebug(_TIMECODE_||_VERBOSE_,
              calcaudiotime += (*audiobufsize*8000)/
                 (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
              printf("AudioTimeStamp=%ld calcaudiotime=%ld (diff=%ld)\n",
                               Info->AudioTimeStamp, calcaudiotime,
                               calcaudiotime-Info->AudioTimeStamp);
              Info->AudioTimeStamp = calcaudiotime );

  _SlibDebug(_VERBOSE_||_TIMECODE_,
   printf("ReadAudio(%d) Time=%ld SamplesPerSec=%d BitsPerSample=%d Channels=%d\n",
         totalbytes,
         Info->AudioTimeStamp, Info->SamplesPerSec, Info->BitsPerSample,
         Info->Channels) );
  /* Info->SystemTimeStamp=Info->AudioTimeStamp; */
  if (status==SaErrorNone)
    return(SlibErrorNone);
  else if (status==ScErrorEndBitstream || status==ScErrorEOI)
  {
    if (*audiobufsize!=0)
      return(SlibErrorNone);
    else
      return(SlibErrorEndOfStream);
  }
  else
  {
    _SlibDebug(_WARN_ && status!=ScErrorEndBitstream
                      && status!=ScErrorEOI,
              printf("SlibReadAudio() %s\n", ScGetErrorStr(status)) );
    if (SlibIsEnd(handle, stream))
      return(SlibErrorEndOfStream);
    return(SlibErrorReading);
  }
}


SlibStatus_t SlibWriteVideo(SlibHandle_t handle, SlibStream_t stream,
                            void *videobuf, unsigned dword videobufsize)
{
  int compsize=0;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status;
  _SlibDebug(_DEBUG_, printf("SlibWriteVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!videobuf)
    return(SlibErrorBadArgument);
  if (videobufsize<(unsigned dword)Info->ImageSize)
    return(SlibErrorBufSize);
  if (Info->Mode!=SLIB_MODE_COMPRESS)
    return(SlibErrorBadMode);
  if (Info->VideoFormat==NULL || Info->CompVideoFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if (Info->IOError)
    return(SlibErrorWriting);
  if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
    return(status);
  if (Info->Sch==NULL) /* start the format converter */
  {
    if (SconOpen(&Info->Sch, SCON_MODE_VIDEO, (void *)Info->VideoFormat, (void *)Info->CodecVideoFormat)
         !=SconErrorNone)
      return(SlibErrorUnsupportedFormat);
  }
  if (!SconIsSame(Info->Sch)) /* need a conversion */
  {
    unsigned char *tmpbuf=NULL;
    if (Info->CodecImagebuf==NULL &&
        (Info->CodecImagebuf=SlibAllocBuffer(Info->CodecImageSize))==NULL)
      return(SlibErrorMemory);
    if (SconConvert(Info->Sch, videobuf, Info->ImageSize,
                      Info->CodecImagebuf, Info->CodecImageSize) != SconErrorNone)
      return(SlibErrorUnsupportedFormat);
    videobuf=Info->CodecImagebuf;
    videobufsize=Info->CodecImageSize;
  }
  switch(Info->Type)
  {
#ifdef H261_SUPPORT
    case SLIB_TYPE_H261:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SLIB_TYPE_H263:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_VIDEO:
    case SLIB_TYPE_MPEG2_VIDEO:
    case SLIB_TYPE_MPEG_SYSTEMS:
    case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    case SLIB_TYPE_SHUFF:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* HUFF_SUPPORT */
    default:
        return(SlibErrorUnsupportedFormat);
  }


  if (status==SvErrorNone && !Info->IOError)
  {
    if (Info->stats && Info->stats->Record)
      Info->stats->FramesProcessed++;
    slibAdvancePositions(Info, 1);
  }
  else
  {
    _SlibDebug(_WARN_, printf("SlibWriteVideo() %s\n",
                         ScGetErrorStr(status)) );
    if (status==ScErrorEndBitstream || Info->IOError)
      return(SlibErrorEndOfStream);
    return(SlibErrorWriting);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibWriteAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword audiobufsize)
{
  unsigned dword compsize=0;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status;
  _SlibDebug(_DEBUG_, printf("SlibAudioVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!audiobuf)
    return(SlibErrorBadArgument);
  if (Info->Mode!=SLIB_MODE_COMPRESS)
    return(SlibErrorBadMode);
  if (Info->AudioFormat==NULL || Info->CompAudioFormat==NULL)
  {
    _SlibDebug(_VERBOSE_ || _WARN_,
          printf("SlibWriteAudio() Audio Formats not setup\n") );
    return(SlibErrorUnsupportedFormat);
  }
  if (Info->IOError)
    return(SlibErrorWriting);
  if ((status=slibStartAudio(Info))!=SlibErrorNone)
    return(status);
  switch(Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_AUDIO:
    case SLIB_TYPE_MPEG_SYSTEMS:
    case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
        {
          unsigned dword audiobytes;
          void *audiooutbuf=NULL;
          status=slibConvertAudio(Info, audiobuf, audiobufsize,
                              Info->SamplesPerSec, Info->BitsPerSample,
                              &audiooutbuf, &audiobytes,
                              Info->AudioFormat->nSamplesPerSec,
                              Info->AudioFormat->wBitsPerSample,
                              Info->Channels);
          if (status!=SlibErrorNone)
              return(status);
          audiobuf=audiooutbuf;
          audiobufsize=audiobytes;
          if (Info->AudiobufUsed && Info->Audiobuf) /* left over audio data */
          {
            if (Info->AudiobufSize<Info->AudiobufUsed+audiobufsize)
            {
              unsigned char *newbuf;
              /* enlarge Audiobuf */
              _SlibDebug(_DEBUG_, printf("enlarging Audiobuf: %d->%d bytes\n",
                        Info->AudiobufSize,audiobufsize+4608) );
              newbuf=SlibAllocBuffer(audiobufsize+4608);
              if (!newbuf)
                return(SlibErrorMemory);
              memcpy(newbuf, Info->Audiobuf, Info->AudiobufUsed);
              SlibFreeBuffer(Info->Audiobuf);
              Info->AudiobufSize+=audiobufsize;
              Info->Audiobuf=newbuf;
            }
            _SlibDebug(_DEBUG_,
               printf("Appending audio data: Info->AudiobufUsed=%d\n",
                                                 Info->AudiobufUsed) );
            memcpy(Info->Audiobuf+Info->AudiobufUsed, audiobuf, audiobufsize);
            audiobuf=Info->Audiobuf;
            audiobufsize+=Info->AudiobufUsed;
            audiobytes=audiobufsize;
            Info->AudiobufUsed=0;
          }
          status = SaCompress(Info->Sah, (unsigned char *)audiobuf,
                                        &audiobytes, NULL, &compsize);
          if (audiobytes<audiobufsize) /* save audio data not compressed */
          {
            _SlibDebug(_DEBUG_,
              printf("audiobytes(%d)<audiobufsize(%d)\n",
                                  audiobytes,audiobufsize) );
            if (!Info->Audiobuf)
            {
              Info->AudiobufSize=audiobufsize+(audiobufsize-audiobytes);
              Info->Audiobuf=SlibAllocBuffer(Info->AudiobufSize);
              if (!Info->Audiobuf)
              {
                Info->AudiobufSize=0;
                return(SlibErrorMemory);
              }
            }
            memcpy(Info->Audiobuf, (unsigned char *)audiobuf+audiobytes,
                                   audiobufsize-audiobytes);
            Info->AudiobufUsed=audiobufsize-audiobytes;
          }
          audiobufsize=audiobytes; /* actual amount written */
          if (audiooutbuf)
            SlibFreeBuffer(audiooutbuf);
        }
        break;
#endif /* MPEG_SUPPORT */
#ifdef G723_SUPPORT
    case SLIB_TYPE_G723:
    {
      unsigned int iNumBytesUnProcessed =0;
      unsigned int iNumBytesCompressed = 0;
      //You always compress in terms of frames (Frame is 480 bytes)
      //So,the files with sizes which are not exactly divisible by
      // 480 always leave some bytes at the end Unprocessed,Which is O.K

      //Check for any Unprocessed Audio stored in Temp buff
      //from the previous call to SlibWriteAudio.
      if (Info->AudiobufUsed && Info->Audiobuf) /* left over audio data */
      {
         if (Info->AudiobufSize < Info->AudiobufUsed+audiobufsize)
         {
            unsigned char *newbuf;
            /* enlarge Audiobuf to new Size (Current size + left over audio)*/
            _SlibDebug(_DEBUG_, printf("enlarging Audiobuf: %d->%d bytes\n",
                      Info->AudiobufSize,audiobufsize+Info->AudiobufUsed) );
            newbuf=SlibAllocBuffer(Info->AudiobufUsed+audiobufsize);
            if (!newbuf)
               return(SlibErrorMemory);
            memcpy(newbuf, Info->Audiobuf, Info->AudiobufUsed);
            SlibFreeBuffer(Info->Audiobuf);
            //Info->AudiobufSize+=audiobufsize;
            Info->Audiobuf=newbuf;
         }
         _SlibDebug(_DEBUG_,
           printf("Appending audio data: Info->AudiobufUsed=%d\n",
                                            Info->AudiobufUsed) );
         memcpy(Info->Audiobuf+Info->AudiobufUsed, audiobuf, audiobufsize);
         audiobuf=Info->Audiobuf;
         audiobufsize+=Info->AudiobufUsed;
         Info->AudiobufUsed=0;
      }

      iNumBytesCompressed = audiobufsize;
      status = SaCompress(Info->Sah,(unsigned char *)audiobuf,
                           &iNumBytesCompressed, NULL,&compsize);
      iNumBytesUnProcessed = audiobufsize - iNumBytesCompressed;
      //Store the Unprocessed Bytes into temp buffer
      if(iNumBytesUnProcessed)
      {
         //Allocate temp buff and store this audio.
         if (!Info->Audiobuf)
         {
            //MVP:To reduce ReAllocations and copying of memory
            //while checking for Unprocessed data (above),Allocate
            // now (normal audio buff size + Unprocessed bytes) more
            // memory upfront.
            Info->AudiobufSize=audiobufsize + iNumBytesUnProcessed;
            Info->Audiobuf=SlibAllocBuffer(Info->AudiobufSize);
            if (!Info->Audiobuf)
            {
               Info->AudiobufSize=0;
               return(SlibErrorMemory);
            }
         }
         memcpy(Info->Audiobuf, (unsigned char *)audiobuf+iNumBytesCompressed,
                                   iNumBytesUnProcessed);
         Info->AudiobufUsed=iNumBytesUnProcessed;
      }
      audiobufsize=iNumBytesCompressed; /* actual amount written */
    }
       break;
#endif /* G723_SUPPORT */
    default:
        _SlibDebug(_VERBOSE_ || _WARN_,
           printf("SlibWriteAudio() Unsupported Format\n") );
        return(SlibErrorUnsupportedFormat);
  }

  if (status==SaErrorNone && !Info->IOError)
  {
    if (Info->AudioFormat)
      Info->AudioTimeStamp += (audiobufsize*8000)/
        (Info->AudioFormat->nSamplesPerSec*Info->AudioFormat->wBitsPerSample*
             Info->Channels);
    else
      Info->AudioTimeStamp += (audiobufsize*8000)/
           (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
    _SlibDebug(_VERBOSE_||_TIMECODE_,
    printf("WriteAudio(%d) Time=%ld SamplesPerSec=%d BitsPerSample=%d Channels=%d\n",
         audiobufsize,
         Info->AudioTimeStamp, Info->SamplesPerSec, Info->BitsPerSample,
         Info->Channels) );
  }
  else
  {
    _SlibDebug(_WARN_, printf("SlibWriteAudio() %s\n", ScGetErrorStr(status)) );
    if (status==ScErrorEndBitstream || Info->IOError)
      return(SlibErrorEndOfStream);
    return(SlibErrorWriting);
  }
  return(SlibErrorNone);
}

/*
** Name: slibPinReposition
** Purpose: Called when input data stream is to be repositioned.
*/
SlibStatus_t slibReposition(SlibInfo_t *Info, SlibPosition_t position)
{
  SlibPin_t *pin=slibGetPin(Info, SLIB_DATA_COMPRESSED);
  _SlibDebug(_DEBUG_, printf("slibReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  if (pin) pin->Offset=position;
  Info->VideoPTimeCode = SLIB_TIME_NONE;
  Info->VideoDTimeCode = SLIB_TIME_NONE;
  Info->AudioPTimeCode = SLIB_TIME_NONE;
  Info->AudioDTimeCode = SLIB_TIME_NONE;
  if (Info->Fd >= 0)
  {
    _SlibDebug(_SEEK_, printf("ScFileSeek(%d, %d)\n", Info->Fd, position) );
    if (ScFileSeek(Info->Fd, position)!=NoErrors)
      return(SlibErrorEndOfStream);
    return(SlibErrorNone);
  }
  else if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
        printf("slibReposition() SlibCB(SLIB_MSG_REPOSITION, %d)\n",
                                   position) );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                        SLIB_MSG_REPOSITION, (SlibCBParam1_t)position,
                        (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
    if (result!=SLIB_MSG_CONTINUE)
      return(SlibErrorEndOfStream);
    return(SlibErrorNone);
  }
  return(SlibErrorForwardOnly);
}

/*
** Name: slibPinPrepareReposition
** Purpose: Should be called when a stream is about to be repositioned (a seek).
**          This will empty any remaining buffers being used by the
**          CODECs and restart them.
*/
void slibPinPrepareReposition(SlibInfo_t *Info, int pinid)
{
  _SlibDebug(_DEBUG_, printf("slibPinPrepareReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  switch(pinid)
  {
     case SLIB_DATA_VIDEO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(Video) in\n") );
             if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN && Info->Svh &&
#ifdef JPEG_SUPPORT
                 Info->Type != SLIB_TYPE_JPEG_AVI &&
                 Info->Type != SLIB_TYPE_MJPG_AVI &&
#endif /* JPEG_SUPPORT */
                 Info->Type != SLIB_TYPE_YUV_AVI)
             {
               SvDecompressEnd(Info->Svh); /* this will reset the bitstream */
               Info->VideoCodecState=SLIB_CODEC_STATE_REPOSITIONING;
               _SlibDebug(_DEBUG_, printf("VideoCodecState=REPOSITIONING\n"));
               Info->IOError=FALSE;
             }
             Info->VideoPTimeCode = SLIB_TIME_NONE;
             Info->VideoDTimeCode = SLIB_TIME_NONE;
             Info->VideoTimeStamp = SLIB_TIME_NONE;
             Info->AvgVideoTimeDiff = 0;
             Info->VarVideoTimeDiff = 0;
             Info->VideoFramesProcessed=0; /* reset frames processed */
             break;
     case SLIB_DATA_AUDIO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(Audio) in\n") );
             if (Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN && Info->Sah)
             {
               SaDecompressEnd(Info->Sah); /* this will reset the bitstream */
               Info->AudioCodecState=SLIB_CODEC_STATE_REPOSITIONING;
               _SlibDebug(_DEBUG_, printf("AudioCodecState=REPOSITIONING\n"));
               Info->IOError=FALSE;
             }
             Info->AudioPTimeCode = SLIB_TIME_NONE;
             Info->AudioDTimeCode = SLIB_TIME_NONE;
             Info->AudioTimeStamp = SLIB_TIME_NONE;
             break;
     default:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(%d) in\n", pinid) );
  }
  _SlibDebug(_VERBOSE_||_SEEK_>1, printf("slibPinPrepareReposition(%d) out\n",
                                         pinid) );
}

void slibPinFinishReposition(SlibInfo_t *Info, int pinid)
{
  _SlibDebug(_DEBUG_, printf("slibPinFinishReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  switch(pinid)
  {
     case SLIB_DATA_VIDEO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(Video) in\n") );
             if (Info->VideoCodecState==SLIB_CODEC_STATE_REPOSITIONING &&
                   Info->Svh && slibGetPin(Info, SLIB_DATA_VIDEO) &&
#ifdef JPEG_SUPPORT
                 Info->Type != SLIB_TYPE_JPEG_AVI &&
                 Info->Type != SLIB_TYPE_MJPG_AVI &&
#endif /* JPEG_SUPPORT */
                 Info->Type != SLIB_TYPE_YUV_AVI)
               slibStartVideo(Info, FALSE);
             break;
     case SLIB_DATA_AUDIO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(Audio) in\n") );
             if (Info->AudioCodecState==SLIB_CODEC_STATE_REPOSITIONING &&
                  Info->Sah && slibGetPin(Info, SLIB_DATA_AUDIO))
               slibStartAudio(Info);
             break;
     default:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(%d) in\n", pinid) );
  }
  _SlibDebug(_VERBOSE_||_SEEK_>1, printf("slibPinFinishReposition(%d) out\n",
                                         pinid) );
}

SlibBoolean_t slibUpdateLengths(SlibInfo_t *Info)
{
  if (Info->FileSize>0 && !Info->VideoLengthKnown &&
       (SlibTimeIsValid(Info->VideoPTimeCode) ||
        SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE)>=1000)
     )
  {
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    Info->VideoLengthKnown=TRUE;
    _SlibDebug(_SEEK_ || _TIMECODE_,
    printf("slibUpdateLengths() AudioLength=%ld VideoLength=%ld\n",
                  Info->AudioLength, Info->VideoLength) );
    return(TRUE);
  }
  return(FALSE);
}

SlibBoolean_t slibUpdatePositions(SlibInfo_t *Info, SlibBoolean_t exactonly)
{
  SlibBoolean_t updated=FALSE;

  if (!exactonly)
  {
    if (SlibTimeIsValid(Info->VideoTimeStamp))
      updated=TRUE;
    else if (SlibTimeIsValid(Info->AudioTimeStamp))
    {
      if (slibHasVideo(Info))
        Info->VideoTimeStamp=Info->AudioTimeStamp;
      updated=TRUE;
    }
    else if (slibHasVideo(Info))
    {
      Info->VideoTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_VIDEO), 500*1024);
      if (SlibTimeIsValid(Info->VideoTimeStamp))
      {
        Info->VideoTimeStamp-=Info->VideoPTimeBase;
        updated=TRUE;
      }
    }
  }
  if (!updated && (!exactonly || SlibTimeIsInValid(Info->VideoPTimeBase)) &&
           SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE)>=1500 &&
            SvGetParamInt(Info->Svh, SV_PARAM_FRAME)>24)
  {
    _SlibDebug(_TIMECODE_, printf("slibUpdatePositions() using video time\n") );
    Info->VideoTimeStamp=SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE);
    updated=TRUE;
  }
  if (updated)
  {
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    if (SlibTimeIsInValid(Info->AudioTimeStamp) && slibHasAudio(Info))
    {
      /* need to update audio time */
      Info->AudioTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_AUDIO), 100*1024);
      if (SlibTimeIsInValid(Info->AudioTimeStamp))
        Info->AudioTimeStamp=Info->VideoTimeStamp;
      else
        Info->AudioTimeStamp-=Info->AudioPTimeBase;
    }
    if (SlibTimeIsInValid(Info->VideoPTimeCode))
      Info->VideoFramesProcessed=slibTimeToFrame(Info, Info->VideoTimeStamp);
  }
  _SlibDebug(_SEEK_ || _TIMECODE_,
     printf("slibUpdatePositions() AudioTimeStamp=%ld VideoTimeStamp=%ld %s\n",
         Info->AudioTimeStamp, Info->VideoTimeStamp, updated?"updated":"") );
  return(updated);
}

void slibAdvancePositions(SlibInfo_t *Info, qword frames)
{
  Info->VideoFramesProcessed+=frames;
  if (Info->FramesPerSec)
  {
    if (Info->Mode==SLIB_MODE_COMPRESS ||
        SlibTimeIsInValid(Info->VideoPTimeCode))
      Info->VideoTimeStamp=slibFrameToTime(Info, Info->VideoFramesProcessed);
    else
      Info->VideoTimeStamp=Info->VideoPTimeCode - Info->VideoPTimeBase +
                           slibFrameToTime(Info, Info->VideoFramesProcessed);
    /* Info->VideoTimeStamp+=slibFrameToTime(Info, frames); */
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    _SlibDebug(_TIMECODE_,
          printf("slibAdvancePositions(frames=%d) VideoTimeStamp=%ld\n",
             frames, Info->VideoTimeStamp) );
  }
}

SlibStatus_t SlibSeek(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t frame)
{
  return(SlibSeekEx(handle, stream, seektype, frame, SLIB_UNIT_FRAMES, NULL));
}

SlibStatus_t SlibSeekEx(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t seekpos,
                      SlibUnit_t seekunits, SlibSeekInfo_t *seekinfo)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SlibErrorNone;
  SlibTime_t seektime, timediff;
  unsigned int tries=0;
  _SlibDebug(_SEEK_,
      printf("SlibSeekEx(stream=%d,seektype=%d,pos=%ld,units=%d)\n",
                     stream,seektype,seekpos,seekunits) );
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Mode!=SLIB_MODE_DECOMPRESS && seektype!=SLIB_SEEK_RESET)
    return(SlibErrorBadMode);
  if (SlibSeekTypeUsesPosition(seektype))
  {
    switch (seekunits)
    {
      case SLIB_UNIT_FRAMES: /* frames */
            /* we need to convert the frame to the time */
            if (Info->FramesPerSec)
              seektime=slibFrameToTime(Info, seekpos);
            else
              seektime=SLIB_TIME_NONE;
            break;
      case SLIB_UNIT_MS:  /* milliseconds */
            seektime=(seekpos<0) ? 0 : seekpos;
            break;
      case SLIB_UNIT_PERCENT100:  /* 100th of a percent */
            if (seekpos<0 || seekpos>10000)
              return(SlibErrorBadPosition);
            if (Info->VideoStreams==0 || stream==SLIB_STREAM_MAINAUDIO)
              seektime=(seekpos * Info->AudioLength)/(SlibPosition_t)10000;
            else
              seektime=(seekpos * Info->VideoLength)/(SlibPosition_t)10000;
            break;
      default:
            return(SlibErrorBadUnit);
    }
    /* see if the new position is past the end of the file */
    if (Info->VideoLengthKnown && seektime>Info->VideoLength)
      return(SlibErrorBadPosition);
  }
  else
    seektime=(seekpos<0) ? 0 : seekpos;
  if (seekinfo)
    seekinfo->FramesSkipped=0;
  switch(seektype)
  {
    case SLIB_SEEK_AHEAD:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,AHEAD,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (seektime<=0)
            return(SlibErrorNone);
          if (stream==SLIB_STREAM_MAINAUDIO || Info->VideoStreams<=0)
            seektime+=Info->AudioTimeStamp;
          else
            seektime+=Info->VideoTimeStamp;
          return(SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_NEAR, seektime,
                       SLIB_UNIT_MS, seekinfo));
    case SLIB_SEEK_NEXT_NEAR:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_NEAR,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          status=slibStartVideo(Info, FALSE);
          if (status==SlibErrorNone)
          {
            qword framesskipped=0;
            SlibBoolean_t atkey=FALSE; /* key's must be decoded */
            if (Info->Svh) /* update key spacing */
            {
              Info->KeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_KEYSPACING);
              Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
            }
            timediff=seektime-Info->VideoTimeStamp;
            while (status==SlibErrorNone &&
               (timediff>500 ||
                timediff>(Info->VideoFrameDuration*Info->KeySpacing*6)/1000))
            {
              status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_KEY, 0,
                                SLIB_UNIT_NONE, seekinfo);
              if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
              timediff=seektime-Info->VideoTimeStamp;
              atkey=TRUE;
            }
            if (!atkey && status==SlibErrorNone &&
               (timediff>150 ||
                timediff>(Info->VideoFrameDuration*Info->SubKeySpacing*6)/1000))
            {
              if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)!=FRAME_TYPE_I &&
                  SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)!=FRAME_TYPE_P)
              {
                /* we're seeking past more than one frame */
                status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_SUBKEY, 0,
                                SLIB_UNIT_NONE, seekinfo);
                if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
                timediff=seektime-Info->VideoTimeStamp;
              }
              atkey=TRUE;
            }
            while (!atkey && status==SlibErrorNone &&
                   timediff>Info->VideoFrameDuration/100)
            {
              if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_B ||
                  SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_NONE)
              {
                /* we can skip B frames without decompressing them */
                status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT, 0,
                                SLIB_UNIT_NONE, seekinfo);
                if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
                timediff=seektime-Info->VideoTimeStamp;
              }
              else
                atkey=TRUE;
            }
            if (seekinfo) seekinfo->FramesSkipped=framesskipped;
          }
          return(status);
    case SLIB_SEEK_NEXT:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN
              && Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            unsigned char *videobuf;
            /* cannot skip I or B frames without decompressing them */
            if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_I ||
                SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_P)
            {
              _SlibDebug(_DEBUG_||_SEEK_, printf("SvDecompressMPEG()\n") );
              status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                                        Info->MultibufSize, &videobuf);
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                   printf("SvDecompressMPEG() %s\n", ScGetErrorStr(status)) );
            }
            else
            {
              mpegPictureInfo.Type = SV_I_PICTURE|SV_P_PICTURE|SV_B_PICTURE;
              _SlibDebug(_VERBOSE_||_SEEK_>1,
                        printf("SvFindNextPicture(I|P|B)\n") );
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                   printf("SvFindNextPicture() %s\n", ScGetErrorStr(status)) );
            }
            if (status==NoErrors)
            {
              slibAdvancePositions(Info, 1);
              if (Info->stats && Info->stats->Record)
                Info->stats->FramesSkipped++;
              if (seekinfo) seekinfo->FramesSkipped++;
            }
            else if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
            return(SlibErrorNone);
          }
#endif /* MPEG_SUPPORT */
          return(SlibErrorReading);
    case SLIB_SEEK_EXACT:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,EXACT,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (Info->FileSize<=0)
            return(SlibErrorFileSize);
          if (seektime==0 || Info->VideoStreams<=0)
            return(SlibSeekEx(handle, stream, SLIB_SEEK_KEY, 0, SLIB_UNIT_MS,
                                                                seekinfo));
          timediff=seektime-Info->VideoTimeStamp;
          if ((stream==SLIB_STREAM_MAINVIDEO || Info->AudioStreams==0) &&
             (timediff>=-20 && timediff<=20)) /* we're already near the frame */
            return(SlibErrorNone);
          if (Info->Svh) /* update key spacing */
            Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
          if (timediff>(Info->KeySpacing*Info->VideoFrameDuration)/100 ||
                  timediff<0 ||
             (stream!=SLIB_STREAM_MAINVIDEO && Info->AudioStreams>0))
          {
            if (Info->KeySpacing>1)
            {
              const SlibTime_t keytime=
                   (Info->VideoFrameDuration*Info->KeySpacing)/100;
              if (seektime>=0 && seektime<keytime)
                status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY, 0,
                                                SLIB_UNIT_MS, seekinfo);
              else
                status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
                                  seektime-(keytime*2), SLIB_UNIT_MS, seekinfo);
            }
            else
              status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
                                seektime-1000, SLIB_UNIT_MS, seekinfo);
            if (status!=NoErrors) return(status);
            timediff=seektime-Info->VideoTimeStamp;
          }
#if 0
          if (SvGetParamFloat(Info->Svh, SV_PARAM_FPS)>0)
            Info->FramesPerSec=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
#endif
          if (status==SlibErrorNone && timediff>=Info->VideoFrameDuration/100)
          {
            dword framesskipped=0;
            do {
              status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT, 0,
                                                SLIB_UNIT_NONE, seekinfo);
              framesskipped++;
              timediff=seektime-Info->VideoTimeStamp;
            } while (timediff>0 && status==SlibErrorNone);
            if (seekinfo) seekinfo->FramesSkipped+=framesskipped;
            /* if we skipped some frames, skip some audio too */
            if (framesskipped>5 && stream==SLIB_STREAM_ALL &&
                        Info->AudioStreams>0)
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibSkipAudio(Info, stream, (Info->VideoFrameDuration*
                                          framesskipped)/100);
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
            }
          }
          return(status);
    case SLIB_SEEK_NEXT_KEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_KEY,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            SlibTime_t vtime=Info->VideoTimeStamp;
            do {
              mpegPictureInfo.Type = SV_I_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              if (status==NoErrors && mpegPictureInfo.Type==SV_I_PICTURE)
              {
                if (Info->stats && Info->stats->Record)
                  Info->stats->FramesSkipped+=mpegPictureInfo.TemporalRef;
                if (vtime==Info->VideoTimeStamp)
                  /* timecode didn't update time */
                  slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
                vtime=Info->VideoTimeStamp;
                if (seekinfo)
                {
                  seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
                  seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                  seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
                }
                return(SlibErrorNone);
              }
            } while (status==NoErrors);
            if (seekinfo)
            {
              seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
              seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
            }
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
          }
          _SlibDebug(_WARN_, printf("SvFindNextPicture() %s\n",
                               ScGetErrorStr(status)) );
#endif /* MPEG_SUPPORT */
          /* do an absolute seek */
          status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
              (Info->VideoStreams<=0?Info->AudioTimeStamp
                                    :Info->VideoTimeStamp)+1000,
              SLIB_UNIT_MS, seekinfo);
          return(status);
    case SLIB_SEEK_NEXT_SUBKEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_SUBKEY,time=%d) VideoTime=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            unsigned char *videobuf;
            SlibTime_t vtime=Info->VideoTimeStamp;
            /* cannot skip I or B frames without decompressing them */
            if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_I ||
                SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_P)
            {
              _SlibDebug(_DEBUG_||_SEEK_, printf("SvDecompressMPEG()\n") );
              status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                                        Info->MultibufSize, &videobuf);
              if (vtime==Info->VideoTimeStamp  /* timecode didn't update time */
                  && status==SvErrorNone)
                slibAdvancePositions(Info, 1);
              vtime=Info->VideoTimeStamp;
              if (seekinfo)
                seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                    printf("SvDecompressMPEG() %s\n", ScGetErrorStr(status)) );
            }
            do {
              mpegPictureInfo.Type = SV_I_PICTURE|SV_P_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              if (Info->stats && Info->stats->Record)
                Info->stats->FramesSkipped+=mpegPictureInfo.TemporalRef;
              if (vtime==Info->VideoTimeStamp) /* timecode didn't update time */
                slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
              vtime=Info->VideoTimeStamp;
              if (seekinfo)
                seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
              if (mpegPictureInfo.Type == SV_I_PICTURE ||
                  mpegPictureInfo.Type == SV_P_PICTURE)
              {
                /* found a subkey frame */
                if (seekinfo)
                {
                  seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                  seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
                }
                return(SlibErrorNone);
              }
            } while(status==NoErrors);
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              if (seekinfo)
              {
                seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
              }
              return(SlibErrorEndOfStream);
            }
          }
          _SlibDebug(_WARN_, printf("SvFindNextPicture() %s\n",
                             ScGetErrorStr(status)) );
#endif /* MPEG_SUPPORT */
          /* do an absolute seek */
          status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
              (Info->VideoStreams<=0?Info->AudioTimeStamp
                                    :Info->VideoTimeStamp)+500,
              SLIB_UNIT_MS, seekinfo);
          return(status);
    case SLIB_SEEK_KEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
            printf("SlibSeekEx(stream=%d,KEY,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (!Info->HeaderProcessed)
          {
            /* At very start of file we must Start the codecs since they
             * may need crucial header info
             */
            status=slibStartVideo(Info, FALSE);
            if (status!=SlibErrorNone) return(status);
          }
          if (Info->FileSize<=0)
            return(SlibErrorFileSize);
          if (seekpos!=0 && seekunits!=SLIB_UNIT_PERCENT100 &&
              (stream==SLIB_STREAM_MAINVIDEO || Info->AudioStreams==0) &&
               SlibTimeIsValid(Info->VideoTimeStamp))
          {
            /* see if we're already near the frame */
            timediff=seektime-Info->VideoTimeStamp;
            if (timediff>=-33 && timediff<=33)
              return(SlibErrorNone);
          }
          if ((seekunits==SLIB_UNIT_PERCENT100 && seekpos<=50)
                || seektime<=slibTimeToFrame(Info, 6))
          {
            /* close to beginning */
            if (seektime<=(Info->VideoFrameDuration*2)/100 &&
                  stream==SLIB_STREAM_MAINVIDEO) /* already close enough */
              return(SlibErrorNone);
seek_to_beginning:
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibEmptyPin(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibEmptyPin(Info, SLIB_DATA_AUDIO);
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            if ((status=slibReposition(Info, 0))!=SlibErrorNone)
              return(status);
            Info->IOError=FALSE;
            Info->VideoTimeStamp = slibHasVideo(Info) ? 0 : SLIB_TIME_NONE;
            Info->AudioTimeStamp = slibHasAudio(Info) ? 0 : SLIB_TIME_NONE;
            return(SlibErrorNone);
          }
          else
          {
	    qword skippedframes=0;
            unsigned qword filepos;
            SlibTime_t vtime;
            const qword length=(Info->VideoStreams<=0) ? Info->AudioLength
                                                       : Info->VideoLength;
            if (seekunits==SLIB_UNIT_PERCENT100)
            {
              unsigned qword bytes_between_keys=Info->TotalBitRate/(8*2);
              filepos = (seekpos*Info->FileSize)/10000;
              /* seek a little before the desired point */
              if (bytes_between_keys>filepos)
                goto seek_to_beginning;
              else
                filepos-=bytes_between_keys;
            }
            else if (length==0)
              goto seek_to_beginning;
            else if (Info->FileSize<0x100000000)/* be careful of mul overflow */
              filepos = (seektime*Info->FileSize)/length;
            else
              filepos = ((seektime/100)*Info->FileSize)/(length/100);
seek_to_key:
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibEmptyPin(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibEmptyPin(Info, SLIB_DATA_AUDIO);
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            if ((status=slibReposition(Info, filepos))!=SlibErrorNone)
              return(status);
            Info->IOError=FALSE;
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinFinishReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
            vtime=Info->VideoTimeStamp;
#ifdef MPEG_SUPPORT
            if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
            {
              SvPictureInfo_t mpegPictureInfo;
              if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
                return(status);
              mpegPictureInfo.Type = SV_I_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              _SlibDebug(_WARN_ && status!=NoErrors,
                            printf("SvFindNextPicture() %s\n",
                              ScGetErrorStr(status)) );
              if (status!=NoErrors)
                return(SlibErrorEndOfStream);
              skippedframes=mpegPictureInfo.TemporalRef;
            }
#endif /* MPEG_SUPPORT */
            if (seekunits==SLIB_UNIT_PERCENT100)
            {
              /* See if we seeked to far ahead */
              SlibPosition_t posdiff=
                SlibGetParamInt(Info, SLIB_STREAM_ALL, SLIB_PARAM_PERCENT100)
                  -seekpos;
              if (filepos>0 && posdiff>0 && tries<2)
              {
                tries++;
                /* we're ahead by one percent or more */
                /* move filepos back in the proportion that we're off by */
                filepos-=(posdiff*Info->FileSize)/8000;
                if (filepos<0)
                  goto seek_to_beginning;
                goto seek_to_key;
              }
            }
            if (slibUpdatePositions(Info, FALSE)) /* timecoded */
            {
              /* timecoded */
              /*
               * See if we seeked to far ahead
               * Note: if times are way off then we should ignore them.
               */
              if (seekunits==SLIB_UNIT_PERCENT100) /* ignore times */
                timediff=0;
              else
              {
                timediff=seektime-Info->VideoTimeStamp;
                if (timediff>-5000 && timediff<-100 && tries<3)
                {
                  /* move filepos back in the proportion that we're off by */
                  filepos=(filepos*seektime)/Info->VideoTimeStamp;
                  if (filepos<0)
                    filepos=0;
                  tries++;
                  goto seek_to_key;
                }
              }
#ifdef MPEG_SUPPORT
              if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
              {
                SvPictureInfo_t mpegPictureInfo;
                mpegPictureInfo.Type = SV_I_PICTURE;
                while (timediff>Info->VideoFrameDuration/100 &&status==NoErrors)
                {
                  _SlibDebug(_SEEK_>1,
                     printf("SlibSeekEx(KEY, %d) Find next I frame (%d/%d)\n",
                      seektime, SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE),
                      Info->VideoTimeStamp) );
                  status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
                  _SlibDebug(_WARN_ && status!=NoErrors,
                    printf("SvFindNextPicture() %s\n", ScGetErrorStr(status)) );
                  skippedframes+=mpegPictureInfo.TemporalRef;
                  if (vtime==Info->VideoTimeStamp)
                    /* timecode didn't update time */
                    slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
                  vtime=Info->VideoTimeStamp;
                  timediff=seektime-Info->VideoTimeStamp;
                }
              }
#endif /* MPEG_SUPPORT */
            }
            else
            {
              _SlibDebug(_SEEK_, printf("SlibSeekEx(KEY, %d) no timecode\n",
                                       seektime) );
              if (slibHasVideo(Info))
              {
                Info->VideoTimeStamp=seektime;
                Info->VideoFramesProcessed=slibTimeToFrame(Info, seektime);
              }
              if (slibHasAudio(Info))
                Info->AudioTimeStamp=seektime;
              slibAdvancePositions(Info, skippedframes);
              timediff=seektime-Info->VideoTimeStamp;
            }
            if (Info->stats && Info->stats->Record)
              Info->stats->FramesSkipped+=skippedframes;
            if (seekinfo) seekinfo->FramesSkipped=skippedframes;
#if 0
            if (Info->Svh)
              Info->FramesPerSec=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
#endif
            /* if we skipped some frames, skip some audio too */
            if (skippedframes>5 && stream==SLIB_STREAM_ALL && slibHasAudio(Info))
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibSkipAudio(Info, stream, (Info->VideoFrameDuration*
                                          skippedframes)/100);
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
              if (SlibTimeIsInValid(Info->AudioTimeStamp))
              {
                Info->AudioTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_AUDIO), 100*1024);
                if (SlibTimeIsInValid(Info->AudioTimeStamp))
                  Info->AudioTimeStamp=Info->VideoTimeStamp;
                else
                  Info->AudioTimeStamp-=Info->AudioPTimeBase;
              }
            }
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
            else if (status!=NoErrors)
              return(SlibErrorReading);
            return(SlibErrorNone);
          }
          break;
    case SLIB_SEEK_RESET:
          _SlibDebug(_VERBOSE_||_SEEK_,
            printf("SlibSeekEx(stream=%d,RESET,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
            slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
            slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
            slibEmptyPin(Info, SLIB_DATA_VIDEO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
            slibEmptyPin(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_MAINAUDIO)
            slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_ALL)
          {
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            Info->BytesProcessed = 0;
          }
          Info->HeaderProcessed = FALSE;
          return(SlibErrorNone);
      case SLIB_SEEK_RESYNC:
          seekpos=SlibGetParamInt(Info, SLIB_STREAM_ALL, SLIB_PARAM_PERCENT100);
          if (seekpos<0 ||
              (SlibTimeIsValid(Info->VideoTimeStamp) &&
               Info->VideoTimeStamp<slibFrameToTime(Info, 6)))
            seekpos=0;
          _SlibDebug(_VERBOSE_||_SEEK_,
             printf("SlibSeekEx(stream=%d,RESYNC) seekpos=%ld\n",
                        stream, seekpos) );
          return(SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, seekpos,
                             SLIB_UNIT_PERCENT100, seekinfo));
      default:
          _SlibDebug(_VERBOSE_||_SEEK_||_WARN_,
             printf("SlibSeekEx(stream=%d,seektype=%d,time=%d) VideoTimeStamp=%ld Bad seek type\n",
                        stream,seektype,seektime,Info->VideoTimeStamp) );
  }
  return(SlibErrorForwardOnly);
}


SlibList_t *SlibQueryList(SlibQueryType_t qtype)
{
  switch(qtype)
  {
    case SLIB_QUERY_TYPES:        return(_listTypes);
    case SLIB_QUERY_COMP_TYPES:   return(_listCompressTypes);
    case SLIB_QUERY_DECOMP_TYPES: return(_listDecompressTypes);
    case SLIB_QUERY_ERRORS:       return(_listErrors);
    default:                      return(NULL);
  }
}

char *SlibQueryForDesc(SlibQueryType_t qtype, int enumval)
{
  SlibList_t *entry=SlibQueryList(qtype);
  if (entry)
    entry=SlibFindEnumEntry(entry, enumval);
  if (entry)
    return(entry->Desc);
  else
    return(NULL);
}

int SlibQueryForEnum(SlibQueryType_t qtype, char *name)
{
  SlibList_t *list=SlibQueryList(qtype);
  if (!list)
    return(-1);
  while (list->Name)
  {
    if (strcmp(list->Name, name)==0)
      return(list->Enum);
    list++;
  }
  return(-1);
}

SlibBoolean_t SlibIsEnd(SlibHandle_t handle, SlibStream_t stream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibBoolean_t isend=FALSE;
  if (!handle)
    isend=TRUE;
  else if (stream==SLIB_STREAM_MAINAUDIO)
  {
    isend=SlibPeekBuffer(Info, SLIB_DATA_AUDIO, NULL, NULL)==NULL?TRUE:FALSE;
    if (isend && Info->Sah) /* see if the audio codec still has data */
    {
      ScBitstream_t *bs=SaGetDataSource(Info->Sah);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  else if (stream==SLIB_STREAM_MAINVIDEO)
  {
    isend=SlibPeekBuffer(Info, SLIB_DATA_VIDEO, NULL, NULL)==NULL?TRUE:FALSE;
    if (isend && Info->Svh) /* see if the video codec still has data */
    {
      ScBitstream_t *bs=SvGetDataSource(Info->Svh);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  else if (SlibPeekBuffer(Info, SLIB_DATA_AUDIO, NULL, NULL)==NULL &&
           SlibPeekBuffer(Info, SLIB_DATA_VIDEO, NULL, NULL)==NULL &&
           SlibPeekBuffer(Info, SLIB_DATA_COMPRESSED, NULL, NULL)==NULL)
  {
    ScBitstream_t *bs;
    isend=TRUE;
    if (Info->Svh) /* see if the video codec still has data */
    {
      bs=SvGetDataSource(Info->Svh);
      if (bs && !bs->EOI) isend=FALSE;
    }
    if (isend && Info->Sah) /* see if the audio codec still has data */
    {
      bs=SaGetDataSource(Info->Sah);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  _SlibDebug(_VERBOSE_,
      printf("SlibIsEnd() %s\n",isend?"TRUE":"FALSE"));
  return(isend);
}

SlibStatus_t SlibClose(SlibHandle_t handle)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  _SlibDebug(_DEBUG_, printf("SlibClose\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  /* close video codec */
  if (Info->Svh)
  {
    if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
    {
      _SlibDebug(_DEBUG_, printf("SvDecompress/CompressEnd()\n") );
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
        SvDecompressEnd(Info->Svh);
      else if (Info->Mode==SLIB_MODE_COMPRESS)
        SvCompressEnd(Info->Svh);
      Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
    }
    _SlibDebug(_DEBUG_, printf("SvCloseCodec()\n") );
    SvCloseCodec(Info->Svh);
  }
  Info->VideoCodecState=SLIB_CODEC_STATE_NONE;
  /* close audio codec */
  if (Info->Sah)
  {
    if (Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
        SaDecompressEnd(Info->Sah);
      else if (Info->Mode==SLIB_MODE_COMPRESS)
        SaCompressEnd(Info->Sah);
      Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
    }
    _SlibDebug(_DEBUG_, printf("SaCloseCodec()\n") );
    SaCloseCodec(Info->Sah);
  }
  Info->AudioCodecState=SLIB_CODEC_STATE_NONE;
  if (Info->Mode==SLIB_MODE_COMPRESS && Info->HeaderProcessed)
    slibCommitBuffers(Info, TRUE);
  /* close format converter */
  if (Info->Sch)
  {
    SconClose(Info->Sch);
    Info->Sch=NULL;
  }
  /* close data sources */
  if (Info->Fd>=0)
  {
    _SlibDebug(_DEBUG_, printf("ScFileClose(%d)\n",Info->Fd) );
    ScFileClose(Info->Fd);
    Info->Fd=-1;
  }
  slibRemovePins(Info);
  /* slibDumpMemory(); */
  if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
      printf("SlibClose() SlibCB(SLIB_MSG_CLOSE)\n") );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                        SLIB_MSG_CLOSE, (SlibCBParam1_t)0,
                      (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
    Info->SlibCB=NULL;
  }
  /* free memory */
  if (Info->stats)  ScFree(Info->stats);
  if (Info->CompVideoFormat) ScFree(Info->CompVideoFormat);
  if (Info->CodecVideoFormat) ScFree(Info->CodecVideoFormat);
  if (Info->VideoFormat)  ScFree(Info->VideoFormat);
  if (Info->AudioFormat) ScFree(Info->AudioFormat);
  if (Info->CompAudioFormat) ScFree(Info->CompAudioFormat);
  if (Info->Imagebuf) SlibFreeBuffer(Info->Imagebuf);
  if (Info->CodecImagebuf) SlibFreeBuffer(Info->CodecImagebuf);
  if (Info->IntImagebuf) SlibFreeBuffer(Info->IntImagebuf);
  if (Info->Audiobuf) SlibFreeBuffer(Info->Audiobuf);
  if (Info->Multibuf) /* free all outstanding allocations on Multibuf */
    while (SlibFreeBuffer(Info->Multibuf)==SlibErrorNone);
  ScFree(Info);
  _SlibDebug(_WARN_ && SlibMemUsed()>0, printf("SlibClose() mem used=%d\n",
                     SlibMemUsed()) );
  return(SlibErrorNone);
}

/*
SlibStatus_t SlibGetInfo(SlibHandle_t handle, SlibInfo_t *info)
{
  if (!handle)
    return(SlibErrorBadHandle);
  if (!info)
    return(SlibErrorBadArgument);
  memcpy(info, handle, sizeof(SlibInfo_t));
  return(SlibErrorNone);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\lsp.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

void  AtoLsp( float *LspVect, float *Lpc, float *PrevLsp );
Word32 Lsp_Qnt( float *CurrLsp, float *PrevLsp, int UseMMX );
Word32 Lsp_Svq( float *Lsp, float *Wvect );
Word32 Svq_Int( float *Lsp, float *Wvect );
Flag  Lsp_Inq( float *Lsp, float *PrevLsp, Word32 LspId, int Crc );
void  Lsp_Int( float *QntLpc, float *CurrLsp, float *PrevLsp );
void  LsptoA( float *Lsp );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\mmxutil.c ===
//  SAC MMx utilities
#include <memory.h>

#include "mmxutil.h"
#include "opt.h"
#define I2FTEST 0
#if I2FTEST
#include "stdio.h"
#endif

//------------------------------------------------------
int IsMMX()     // does the processor I'm running have MMX(tm) technology?
{
  int retu;

#ifdef _ALPHA_
    return 0;
#endif

#ifdef _X86_
  __asm
  {
	push ebx
    pushfd
    pop edx
    mov eax,edx
    xor edx,200000h
    push edx
    popfd
    pushfd
    pop edx
//
//  DON'T do this. This clears EAX, but the code is relying
//  on edx being 0 in the bail out case!!!
//
//  -mikeg
//
//    xor       eax,edx
//
//
    xor edx,eax     //This is the right way
    je  no_cpuid

    mov eax,1
    _emit 0x0f     //CPUID magic incantation
    _emit 0xa2
    and  edx,000800000h
    shr  edx,23
no_cpuid:
    mov  retu,edx
	pop ebx
  }
  return(retu);
#endif
}
//------------------------------------------------------
/* The following 4 routines make an 8-byte-aligned 'output' array
   from an 'input' array with various alignments.  MakeAlignedN assumes
   that 'input' starts on an address equal to N mod 8.  For now we
   only handle even N.
*/

//------------------------------------------------------
void MakeAligned0(void *input, void *output, int numbytes)
{
  memcpy(output,input,numbytes);
}
//------------------------------------------------------
void MakeAligned2(void *input, void *output, int numbytes)
{
  memcpy(output,input,numbytes);
}
//------------------------------------------------------
void MakeAligned4(void *input, void *output, int numbytes)
{
  memcpy(output,input,numbytes);
}
//------------------------------------------------------
void MakeAligned6(void *input, void *output, int numbytes)
{
  memcpy(output,input,numbytes);
}

//------------------------------------------------------
int FloatToShortScaled(float *input, short *output, int len, int guard)
{
  int max;

/* Convert an array of floats to an array of shorts with dynamic scaling.
   If guard=0 the array is scaled so that the largest power of 2 contained
   in the input comes out as 16384, which means all values fit in 16 bits
   without overflow.  If guard>0 the outputs are shifted an extra 'guard'
   bits to the right.
*/

  max = FloatMaxExp(input, len);
  ScaleFloatToShort(input, output, len, max + guard);

  return max;
}

int FloatToIntScaled(float *input, int *output, int len, int guard)
{
  int max;

/* Convert an array of floats to an array of shorts with dynamic scaling.
   If guard=0 the array is scaled so that the largest power of 2 contained
   in the input comes out as 2^30, which means all values fit in 32 bits
   without overflow.  If guard>0 the outputs are shifted an extra 'guard'
   bits to the right.
*/

  max = FloatMaxExp(input, len);
  ScaleFloatToInt(input, output, len, max + guard);

  return max;
}

int FloatMaxExp(float *input, int len)
{
  int max;

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    xor eax,eax;
    mov ebx,len;
    xor edi,edi;   // max

loop2:
    mov ecx,DP[esi+4*eax];
     mov edx,DP[esi+4*eax+4];

    and ecx,07f800000h;
     and edx,07f800000h;

    cmp edi,ecx;
     jge skip1;
    mov edi,ecx;
skip1:

    cmp edi,edx;
     jge skip2;
    mov edi,edx;
skip2:

    add eax,2;
    cmp eax,ebx;
    jl loop2;

    mov max,edi;
  }

#else

  int exp,i;

  max = 0;
  for (i=0; i<len; i++)
  {
    exp = (*((int *)(input + i))) & 0x7f800000;
    if (exp > max)
      max = exp;
  }
#endif

  return max >> 23;
}


void ScaleFloatToShort(float *input, short *output, int len, int newmax)
{
  int i;
  float scale;
/*
  If max exponent is 14, we want a scale factor of 1, since
  then values will be at most +/- 32727.  So scale factor multiplier
  should be 2^(14 - max - guard).  But 'max' has the exponent bias
  built in, so we must add BIAS once to the exponent to get a "real"
  exponent.  But then we want a FP exponent that has bias, so we
  need to add BIAS again!  So we get 2^(2*BIAS+14 - max - guard).
  2*BIAS+14 is 254 + 14 = 252+12, so it's 0x86000000 (first 9 bits 1 0000 1100)
*/

  i = 0x86000000 - (newmax << 23);
  scale = (*(float *)&i);

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    mov edi,output;
    xor eax,eax;
    mov ebx,len;

loop1:
    fld DP[esi+4*eax];
    fmul scale;
    fld DP[esi+4*eax+4];
    fmul scale;
    fxch(1);
    fistp WP[edi+2*eax];
    fistp WP[edi+2*eax+2];

    add eax,2;
    cmp eax,ebx;
    jl loop1;
  }

#else

  for (i=0; i<len; i++)
    output[i] = (short)(input[i]*scale);

#endif
  return;
}

void ConstFloatToShort(float *input, short *output, int len, float scale)
{

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    mov edi,output;
    xor eax,eax;
    mov ebx,len;

loop1:
    fld DP[esi+4*eax];
    fmul scale;
    fld DP[esi+4*eax+4];
    fmul scale;
    fxch(1);
    fistp WP[edi+2*eax];
    fistp WP[edi+2*eax+2];

    add eax,2;
    cmp eax,ebx;
    jl loop1;
  }

#else
  int i;

  for (i=0; i<len; i++)
    output[i] = (short)(input[i]*scale);

#endif
  return;
}


//------------------------------------------------------
void ScaleFloatToInt(float *input, int *output, int len, int newmax)
{
  int i;
  float scale;

  i = 0x8E000000 - (newmax << 23);
  scale = (*(float *)&i);

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    mov edi,output;
    xor eax,eax;
    mov ebx,len;

loop1:
    fld DP[esi+4*eax];
    fmul scale;
    fld DP[esi+4*eax+4];
    fmul scale;
    fxch(1);
    fistp DP[edi+4*eax];
    fistp DP[edi+4*eax+4];

    add eax,2;
    cmp eax,ebx;
    jl loop1;
  }

#else

  for (i=0; i<len; i++)
    output[i] = (int)(input[i]*scale);

#endif
  return;
}

void ConstFloatToInt(float *input, int *output, int len, float scale)
{

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    mov edi,output;
    xor eax,eax;
    mov ebx,len;

loop1:
    fld DP[esi+4*eax];
    fmul scale;
    fld DP[esi+4*eax+4];
    fmul scale;
    fxch(1);
    fistp DP[edi+4*eax];
    fistp DP[edi+4*eax+4];

    add eax,2;
    cmp eax,ebx;
    jl loop1;
  }

#else
  int i;

  for (i=0; i<len; i++)
    output[i] = (int)(input[i]*scale);

#endif
  return;
}


//------------------------------------------------------
void CorrelateInt(short *taps, short *array, int *corr, int len, int num)
{
  int i,j;

  for (i=0; i<num; i++)  // for each correlation
  {
    corr[i] = 0;
    for (j=0; j<len; j++)
      corr[i] += (int)taps[j] * (int)array[i+j];
  }
}

#if ASM_CORR
//------------------------------------------------------
void CorrelateInt4(short *taps, short *array, int *corr, int ntaps, int ncor)
{

#define rega0  mm0
#define regb0  mm1
#define rega1  mm2
#define regb1  mm3
#define rega2  mm4
#define regb2  mm5
#define acc0   mm6
#define acc1   mm7

#define arr    esi
#define tap    edi
#define cor    eax
#define icnt   ebx

// In the following macros, 'n' is the column number and 'i' is the
// iteration number.

#define la(n,i)  ASM movq  rega##n,QP[arr+8*i]
#define lb(n,i)  ASM movq  regb##n,QP[tap+8*i+8]
#define m0(n,i)  ASM pmaddwd regb##n,rega##n
#define m1(n,i)  ASM pmaddwd rega##n,QP[tap+8*i]
#define a0(n,i)  ASM paddd acc0,regb##n
#define a1(n,i)  ASM paddd acc1,rega##n

  ASM
  {
    shr ntaps,2;
    sub taps,8;  // point to 1 before start of taps array
    mov cor,corr;

ForEachCorrPair:

    mov icnt,ntaps;
    pxor acc0,acc0;
    pxor acc1,acc1;
    mov tap,taps;
    mov arr,array;
  }

// prime the pump

  la(0,0);
  lb(0,0);
  m0(0,0);
  ASM pxor rega0,rega0;   // to make first a1(0,0) a nop
	  la(1,1);
	  lb(1,1);

inner:
		  la(2,2);
	  m0(1,1);
	  m1(1,1);
  a0(0,0);
		  lb(2,2);
  a1(0,0);
  la(0,3);
		  m0(2,2);
		  m1(2,2);
	  a0(1,1);
  lb(0,3);
	  a1(1,1);
	  la(1,4);
  m0(0,3);
  m1(0,3);
		  a0(2,2);
	  lb(1,4);
		  a1(2,2);

  ASM add arr,24;
  ASM add tap,24;

  ASM sub icnt,3;
  ASM jg inner;

  a1(0,0);

// Done with one correlation pair.  First need to add halves of
// acc0 and acc1 together and then store 2 results in corr array

  ASM
  {
    movq  mm0,acc0;
    psrlq acc0,32;
    paddd acc0,mm0;
    movq  mm1,acc1;
    psrlq acc1,32;
    movd  DP[cor],acc0;
    paddd acc1,mm1;
    movd  DP[cor+16],acc1;

    add cor,32;
    add array,16;
    sub ncor,2;
    jg ForEachCorrPair;

    emms;
  }

}
#undef rega0
#undef regb0
#undef rega1
#undef regb1
#undef rega2
#undef regb2
#undef acc0
#undef acc1

#undef arr
#undef tap
#undef cor
#undef icnt
#undef la
#undef lb
#undef m0
#undef m1
#undef a0
#undef a1

#else
//------------------------------------------------------
void CorrelateInt4(short *taps, short *array, int *corr, int ntaps, int ncor)
{
  int i,j,k;

  k = 0;
  for (i=0; i<ncor; i++)  // for each correlation
  {
    corr[k] = 0;
    for (j=0; j<ntaps; j++)
      corr[k] += (int)taps[j] * (int)array[k+j];
    k += 4;
  }
}
#endif
#if COMPILE_MMX
#undef icnt
void ab2abbcw(const short *input, short *output, int n)
{

#define in edi
#define out esi
#define icnt ecx

#define L(m,i)  ASM movq mm##m,QP[in+8*(i/2)]
#define PL(m)   ASM punpcklwd mm##m,mm##m
#define PH(m)   ASM punpckhwd mm##m,mm##m
#define SL(m) ASM psllq mm##m,16
#define SR(m) ASM psrlq mm##m,48
#define O(m,n)  ASM por mm##m,mm##n
#define S(m,i)  ASM movq QP[out+8*i],mm##m
	ASM {
	mov in, input;
	mov out, output;
	mov icnt, n;
	ASM     pxor mm3,mm3;
	sub icnt, 8;
	jl odd_ends;
	}

	//prime pump
	L(0,0);
	PL(0);
			L(1,1);
	SL(0);
			PH(1);
			SL(1);
							O(3,0);
					L(2,2);
	SR(0);
							S(3,0);
					PL(2);

	ASM sub icnt, 8;
	ASM jl cleanup;
inner:
					SL(2);
	O(0,1);
							L(3,3)
			SR(1);
	S(0,1);
							PH(3);
							SL(3);
			O(1,2);
	L(0,4);
					SR(2);
			S(1,2);
	PL(0);
	SL(0);          
					O(2,3);
			L(1,5);
							SR(3);
					S(2,3);
			PH(1);
			SL(1);
							O(3,0);
					L(2,6);
	SR(0);
							S(3,4);
					PL(2);

	ASM add in, 16;
	ASM  add out, 32;
	ASM sub icnt, 8;
	ASM  jg inner;

cleanup:
					SL(2);
	O(0,1);
							L(3,2);
			SR(1);
	S(0,1);
							PH(3);
							SL(3);
			O(1,2);
					SR(2);
			S(1,2);
					O(2,3);
					S(2,3);

odd_ends:
	ASM add icnt, 8-4;
	ASM  jl end;     // jump if no sign change

	L(0,4);
							SR(3);
	PL(0);
			L(1,5);
	SL(0);          
			PH(1);
							O(3,0);
			SL(1);
	SR(0);
							S(3,4);
	O(0,1);
	S(0,5);

end:
	ASM emms;
#undef in
#undef out
#undef icnt

#undef L
#undef PL
#undef PH
#undef SL
#undef SR
#undef O
#undef S

	return;
}
void ab2ababw(const short *input, short *output, int n)
{

#define in edi
#define out esi
#define icnt ecx

#define L(m,i) ASM movq mm##m,QP[in+4*i]
#define C(m,n) ASM movq mm##m,mm##n
#define PL(m)  ASM punpckldq mm##m,mm##m
#define PH(m)  ASM punpckhdq mm##m,mm##m
#define S(m,i) ASM movq [out+8*i],mm##m

	ASM {
	mov in, input;
	mov out, output;
	mov icnt, n;
	sub icnt, 8;
	jl odd_ends;
	}
	//prime pump
	L(0,0);
			C(1,0);
	PL(0);
					L(2,2);
			PH(1);
	S(0,0);
							C(3,2);
			S(1,1);
					PL(2);
	ASM add in, 16;
	ASM  add out, 32;
	ASM sub icnt, 8;
	ASM  jl cleanup;

inner:
	L(0,0);
							PH(3);
					S(2,-2);
			C(1,0);
							S(3,-1);
	PL(0);
					L(2,2);
			PH(1);
	S(0,0);
					C(3,2);
			S(1,1);
					PL(2);
	ASM add in, 16;
	ASM  add out, 32;
	ASM sub icnt, 8;
	ASM  jg inner;

cleanup:
							PH(3);
					S(2,-2);
							S(3,-1);
odd_ends:
	ASM add icnt, 8-2;
	ASM  jl end;     // jump if no sign change

inner_by2:
	ASM movd mm0, DP[in];
	PL(0);
	S(0,0);
	ASM add in, 4;
	ASM  add out, 8;
	ASM sub icnt, 2;
	ASM  jge inner_by2;

end:
	ASM emms;

	return;
}
#undef in
#undef out
#undef icnt

#undef L
#undef C
#undef PL
#undef PH
#undef S

void ConvMMX(short *input1, short *input2, int *output, int ncor)
{
#define rega0  mm0
#define regb0  mm1
#define rega1  mm2
#define regb1  mm3
#define rega2  mm4
#define regb2  mm5
#define acc0   mm6
#define acc1   mm7

#define in2    esi
#define in1    edi
#define out    eax
#define icnt   ecx
#define tmp        ebx

// In the following macros, 'n' is the column number and 'i' is the
// iteration number.

// we use "the convolution trick" or using la twice so that one
// of the pmadd's is reg,reg and thus can be in the V-slot.

// NOTE: we have read ahead up to 2 quadwords
//   so we need QP[taps+8*ncor] = QP[taps+8*ncor+8] = [0 0 0 0]
//   and reading QP[array+8*ncor] or QP[array+8*ncor+8] must be legal

#define la(n,i)  ASM movq  rega##n,QP[in2+8*i]
#define lb(n,i)  ASM movq  regb##n,QP[in1+8*i-8]
#define m0(n,i)  ASM pmaddwd regb##n,rega##n
#define m1(n,i)  ASM pmaddwd rega##n,QP[in1+8*i]
#define a0(n,i)  ASM paddd acc0,regb##n
#define a1(n,i)  ASM paddd acc1,rega##n

  ASM
  {
	mov tmp,ncor;
	shl tmp,2;
    shr ncor,1;
    mov out,output;
	add out,tmp;
	add out,16;
    mov in1,input1;
    mov in2,input2;
    mov icnt,ncor;
  }

ForEachCorrPair:

// prime the pump

  la(0,0);
  ASM pxor regb0,regb0;   // to  avoid lb(0,0) reading taps[-1]
	  la(1,1);
  ASM pxor acc0,acc0;     // clear accumulator
  m1(0,0);
  ASM pxor acc1,acc1;     // clear accumulator
	  lb(1,1);
  ASM sub icnt, 1;        // account for pump priming
  ASM jle cleanup;        // bypass if only one to do

inner:
		  la(2,2);
	  m0(1,1);
	  m1(1,1);
  a0(0,0);
		  lb(2,2);
  a1(0,0);
  la(0,3);
		  m0(2,2);
		  m1(2,2);
	  a0(1,1);
  lb(0,3);
	  a1(1,1);
	  la(1,4);
  m0(0,3);
  m1(0,3);
		  a0(2,2);
	  lb(1,4);
		  a1(2,2);

  ASM add in2,24;
  ASM add in1,24;

  ASM sub icnt,3;
  ASM jg inner;

cleanup:  //  last two adds
  a0(0,0);
  a1(0,0);

// Done with one correlation pair.  Pack and store 2 results in corr array

  ASM
  {
    sub out,16;
	
     mov in2, input2;
    mov in1,input1;
	 add in2,16;
    mov icnt, ncor;
	
	mov input2, in2;
	 sub icnt,2;      //set flags for jump

	movq  QP[out-16],acc0;
	movq  QP[out-8],acc1;

	mov ncor, icnt;
    jg ForEachCorrPair;

    emms;
  }

}
#undef rega0
#undef regb0
#undef rega1
#undef regb1
#undef rega2
#undef regb2
#undef acc0
#undef acc1

#undef in2
#undef in1
#undef out
#undef icnt
#undef tmp

#undef la
#undef lb
#undef m0
#undef m1
#undef a0
#undef a1
// 16 bit output
//       psrad acc0,16;//this could be less in some cases
//       psrad acc1,16;
//       packssdw acc1,acc0;
//   movq  QP[cor-8],acc0;

//#else
//------------------------------------------------------
/*
void ConvMMX(short *in1, short *in2, int *out, int ncor)
{
  int i,j;

  for (i=0; i < 2*ncor; i+=4)    {
    int acc0 = 0, acc1 = 0;
    for (j=0; j < 2*ncor - i; j+=4) {
      acc0 += (int)taps[j]*array[i+j] + (int)taps[j+1]*array[i+j+1];
      acc1 += (int)taps[j+2]*array[i+j+2] + (int)taps[j+3]*array[i+j+3];
    }
    corr[i/2] = acc0 ;
    corr[i/2+1] = acc1 ;
  }

  return;
}*/

void ab2abzaw(const short *input, short *output, int n)
{
	register int i;
	register unsigned *in, *out;
	register unsigned x, y; //tread two words at a time as raw bits

	in = (unsigned *)input;
	out = (unsigned *)output;
	//unroll by two
	for (i = n/2 - 2; i>0; i-=2) {
		x = in[i];
		y = in[i+1];
		out[2*(i+1)] = y;
		out[2*(i+1)+1] = (y<<16 | x>>16);
		
		x = in[i-1];
		y = in[i];
		out[2*i] = y;
		out[2*i+1] = (y<<16 | x>>16);
	}
	//odd ends
	for (i++; i>=0; i--) {
		x = (i>0)?in[i-1]:0;
		y = in[i];
		out[2*i] = y;
		out[2*i+1] = (y<<16 | x>>16);
	}
	return;
}

void ShortToFloatScale(short *x, float scale, int N, float *y)
{

/*
	short i;
	float yy[100];
	for (i=0; i<N; i++)
	{ yy[i]=x[i]*scale; }


  ASM
	{       
    mov esi,x;
    mov edi,y;
	lea ecx,scale;
	mov     eax, N
	sub     eax, 2
loop1:
	fild    WORD PTR [esi+eax*2]
	fmul    DWORD PTR [ecx]
	fstp    DWORD PTR [edi+eax*4]

	fild    WORD PTR [esi+eax*2+2]
	fmul    DWORD PTR [ecx]
	fstp    DWORD PTR [edi+eax*4+4]

	sub     eax, 2
	jge loop1;
	}

*/

  ASM
	{
	mov esi,x;
	mov edi,y;
	lea ecx,scale;
	mov     eax, N
	sub     eax, 6
	fld     DP [ecx]        ;                     c

	fild    WORD PTR [esi+eax*2+8] ;          L0  c

	fild    WORD PTR [esi+eax*2+10] ;      L1 L0  c
	 fxch   ST(1) ;                        L0 L1  c
	fmul    ST(0), ST(2) ;                        M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmul   ST(0),ST(2) ;                         M1 M0  c

	fild    WORD PTR [esi+eax*2+4] ;    L0 M1 M0  c

	fild    WORD PTR [esi+eax*2+6];  L1 L0 M1 M0  c
	 fxch    ST(3) ;                 M0 L0 M1 L1  c
	fstp    DWORD PTR [edi+eax*4+16];   L0 M1 L1  c
loop1:  ;                                   L0 M1 L1  c

	fmul    ST(0),ST(3) ;                     M0 M1 L1  c
	 fxch    ST(1) ;                    M1 M0 L1  c
	fstp    DWORD PTR [edi+eax*4+20];      M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmul   ST(0),ST(2) ;                         M1 M0  c
	fild    WORD PTR [esi+eax*2] ;      L0 M1 M0  c

	fild    WORD PTR [esi+eax*2+2] ; L1 L0 M1 M0  c
	 fxch    ST(3) ;                 M0 L0 M1 L1  c
	fstp    DWORD PTR [edi+eax*4+8];    L0 M1 L1  c

	sub     eax, 2
	 jge loop1;
	fmul    ST(0),ST(3) ;eax==-2              M0 M1 L1  c
	 fxch    ST(1) ;                    M1 M0 L1  c
	fstp    DWORD PTR [edi+eax*4+20] ;     M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmulp   ST(2), st(0) ;                           M0 M1

	fstp    DWORD PTR [edi+eax*4+8] ;            M1

	fstp    DWORD PTR [edi+eax*4+12] ;
	}
/*


for (i=0; i<N; i++)
{
if (y[i]!=yy[i])
{
fprintf(stdout,"\nfloat problem\n");
break;
}
}

*/


}

//assumes N is even
void IntToFloatScale(int *x, float scale, int N, float *y)
{
#if I2FTEST //test code
	int i;
	float yy[1000];
	for (i=0; i<N; i++)
	{ yy[i]=(float)x[i]*scale; }
#endif //test code

#if 0 //simple code
//simple assembly version       
	ASM
	{       
    mov esi,x;
    mov edi,y;
	lea ecx,scale;
	mov     eax, N
	sub     eax, 2
loop1:
	fild    DWORD PTR [esi+eax*4]
	fmul    DWORD PTR [ecx]
	fstp    DWORD PTR [edi+eax*4]

	fild    DWORD PTR [esi+eax*4+4]
	fmul    DWORD PTR [ecx]
	fstp    DWORD PTR [edi+eax*4+4]

	sub     eax, 2
	jge loop1;
	}
#endif //test code


  ASM
	{
	mov esi,x;
	mov edi,y;
	lea ecx,scale;
	mov     eax, N
	sub     eax, 6
	fld     DP [ecx]        ;                     c

	fild    DWORD PTR [esi+eax*4+16] ;        L0  c

	fild    DWORD PTR [esi+eax*4+20] ;     L1 L0  c
	 fxch   ST(1) ;                        L0 L1  c
	fmul    ST(0), ST(2) ;                 M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmul   ST(0),ST(2) ;                   M1 M0  c

	fild    DWORD PTR [esi+eax*4+8] ;   L0 M1 M0  c

	fild    DWORD PTR [esi+eax*4+12];L1 L0 M1 M0  c
	 fxch    ST(3) ;                 M0 L0 M1 L1  c
	fstp    DWORD PTR [edi+eax*4+16];   L0 M1 L1  c
loop1:  ;                                   L0 M1 L1  c

	fmul    ST(0),ST(3) ;               M0 M1 L1  c
	 fxch    ST(1) ;                    M1 M0 L1  c
	fstp    DWORD PTR [edi+eax*4+20];      M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmul   ST(0),ST(2) ;                   M1 M0  c
	fild    DWORD PTR [esi+eax*4] ;     L0 M1 M0  c

	fild    DWORD PTR [esi+eax*4+4] ;L1 L0 M1 M0  c
	 fxch    ST(3) ;                 M0 L0 M1 L1  c
	fstp    DWORD PTR [edi+eax*4+8];    L0 M1 L1  c

	sub     eax, 2
	 jge loop1;
	fmul    ST(0),ST(3) ;eax==-2        M0 M1 L1  c
	 fxch    ST(1) ;                    M1 M0 L1  c
	fstp    DWORD PTR [edi+eax*4+20] ;     M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmulp   ST(2), st(0) ;                    M0 M1

	fstp    DWORD PTR [edi+eax*4+8] ;            M1

	fstp    DWORD PTR [edi+eax*4+12] ;
	}


#if I2FTEST
  for (i=0; i<N; i++)
  {
    if (y[i]!=yy[i])
    {
      printf("F2I %3d %8f %8f\n", i, y[i], yy[i]);
    }
  }
#endif //test code


}

//assumes N is even
void IntToFloat(int *x, int N, float *y)
{
#if I2FTEST //test code
	int i;
	float yy[1000];
	for (i=0; i<N; i++)
	{ yy[i]=(float)x[i]; }
#endif //test code

//simple assembly version       
	ASM
	{       
    mov esi,x;
    mov edi,y;
	mov     eax, N
	sub     eax, 2
loop1:
	fild    DWORD PTR [esi+eax*4]
	fild    DWORD PTR [esi+eax*4+4]
	 fxch    ST(1) ;
	fstp    DWORD PTR [edi+eax*4]
	fstp    DWORD PTR [edi+eax*4+4]

	sub     eax, 2
	jge loop1;
	}


#if I2FTEST
  for (i=0; i<N; i++)
  {
    if (y[i]!=yy[i])
    {
      printf("F2I %3d %8f %8f\n", i, y[i], yy[i]);
    }
  }
#endif //test code


}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\lpc.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

// prototypes for lpc 

float Durbin(float *Lpc, float *Corr, float Err, CODDEF *CodStat);
void  Wght_Lpc(float *PerLpc, float *UnqLpc );
void  Error_Wght(float *Dpnt, float *PerLpc, CODDEF *CodStat );
void  Comp_Ir(float *ImpResp, float *QntLpc, float *PerLpc, PWDEF Pw );
void  Sub_Ring(float *Dpnt, float *QntLpc, float *PerLpc, float
*PrevErr, PWDEF Pw, CODDEF *CodStat );
void  Upd_Ring( float *Dpnt, float *QntLpc, float *PerLpc, float
*PrevErr, CODDEF *CodStat );
void  Synt(float *Dpnt, float *Lpc, DECDEF *DecStat);
//Spf

void CorrCoeff01(short *samples, short *samples_offst, int *coeff, int buffsz);
void CorrCoeff23(short *samples, short *samples_offst, int *coeff, int buffsz);

void Comp_LpcInt( float *UnqLpc, float *PrevDat, float *DataBuff, CODDEF *CodStat );
void Comp_Lpc( float *UnqLpc, float *PrevDat, float *DataBuff, CODDEF *CodStat );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\lsp.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//


#include <stdio.h>
#include <math.h>
#include "opt.h"
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "util_lbc.h"
#include "lsp.h"
#include "timer.h"
#include "mmxutil.h"

#if COMPILE_MMX
//  This file includes all the Lsp related functions

//--------------------------------------------------------------
int mult(short x, short y)
{
  return ( ((int)x)*((int)y) >> 16 );
}
//--------------------------------------------------------------
int LspSearchInt(short *Lspw, short *LspTab)
{

#if ASM_SVQ

  int mem8000[2] = {0x80008000,0x80008000}, zero[2] = {0,0};
  short maxes[4],mx;
  int retu;
  int *ptr,tmp,t,i,k;

#define lsp esi
#define tab edi
#define idx edx
#define pidx eax  // packed index: n+3 n+2 n+1 n
#define maxi ecx

#define r0   mm0
#define r1   mm1
#define r2   mm2
#define r3   mm3
#define r4   mm4
#define max  mm5


// Expand Lspw table so it's 0000 1111 2222 3333 4444 5555 6666 7777

  ptr = (int *)Lspw;
  k = 14;
  for (i=7; i>=0; i--)
  {
    t = Lspw[i]; t = t & 0xffff;
    tmp = t;
    tmp = (tmp << 16) | t;
    ptr[k] = ptr[k+1] = tmp;
    k -= 2;
  }

// Need LspTab to be ordered 0 4 8 12  1 5 9 13  etc.
// so that lo word of each qword sees 0123, next sees 4567, etc.
//
// 'idx' counts iterations, so it goes 0 to 256 in steps of 4.
// The 4 LspTab sets at any given time are 8*idx, 8*idx+8, +16, +24
// Lspw[n] is lsp+8*n, as defined below

#define a(n)  [tab+8*idx+8*n]
#define b(n)  [lsp+8*n]

  ASM
  {
    push lsp;
    push tab;
    push idx;
    push pidx;
    push maxi;

    mov lsp,Lspw;
    mov tab,LspTab;
    xor idx,idx;
    xor maxi,maxi;
    mov pidx,003020100h;
    movq max,mem8000;

/*
  The code below is interleaved with k=1.
  The structure is: four levels of indentation, one for each of the
  4 terms of the sum.  The instructions completely left-justified
  are the part of the loop that's wrapped around on itself.
  Note that the code reads 8 bytes past the end of the LspTab that's
  passed to it.  This is made o.k. by making the table that's passed
  to it have 8 dummy bytes at the end.
*/

// Start up the pipeline

    movq r0,a(0);
    movq r1,r0;
    pmulhw r0,b(4);
    psubsw r1,b(0);
      movq r2,a(1);
      movq r3,r2;
    psllw r0,2;
    pmulhw r0,r1;
      pmulhw r2,b(5);
      psubsw r3,b(1);
        movq r1,a(2);
      psllw r2,2;
      pmulhw r2,r3;  
        movq r3,r1;  
        pmulhw r1,b(6);
        psubsw r3,b(2);
      paddw r0,r2;   
          movq r2,a(3);
        psllw r1,2;
        pmulhw r1,r3;
          movq r3,r2;
          pmulhw r2,b(7);
          psubsw r3,b(3);
        paddw r1,r0;

loop1:
    movq r0,a(4);
          movq r4,r1;   // save accum so not wiped out by first half of loop

          psllw r2,2;
          
    movq r1,r0;
          pmulhw r2,r3;
    
    pmulhw r0,b(4);

    psubsw r1,b(0);
          paddw r4,r2;      // now final answer is in r4

      movq r2,a(5);

paddw r4,mem8000  // make final sum unsigned
      movq r3,r2;      // 0123

    psllw r0,2;
    
psubusw max,r4    // start to compute max
    pmulhw r0,r1;      // 0.23

      pmulhw r2,b(5);
paddw max,r4      // max now done

      psubsw r3,b(1);
pcmpeqw r4,max    // now 1111's means a new max was found

        movq r1,a(6);  // 0123
packsswb r4,r4;    // put all fields in low 32 bits

      psllw r2,2;
      
movd ebx,r4;
      pmulhw r2,r3;    // 012.

xor ebx,0ffffffffh;   // invert mask

and maxi,ebx;       // get old index to keep
        movq r3,r1;    // 0123

        pmulhw r1,b(6);

        psubsw r3,b(2);

xor ebx,0ffffffffh;   // invert mask

      paddw r0,r2;     // 01.3
and ebx,pidx;       // get new index

        psllw r1,2;
        
          movq r2,a(7);// 0123
        pmulhw r1,r3;  // 012.

          movq r3,r2;  // 0123
or maxi,ebx;       // now maxi is done

          pmulhw r2,b(7);

          psubsw r3,b(3);

        paddw r1,r0;   // .123
add idx,4;

add pidx,004040404h;

cmp idx,256;
jl loop1;

psubw max,mem8000;
mov retu,maxi;
movq maxes,max;

    pop maxi;
    pop pidx;
    pop idx;
    pop tab;
    pop lsp;
  }

// find which of the 4 maxes is the max, and return the appropriate
// one of the 4 maxindices.

  mx = maxes[0]; t = 0;
  if (maxes[1] >= mx) { mx = maxes[1]; t = 8; }
  if (maxes[2] >= mx) { mx = maxes[2]; t = 16; }
  if (maxes[3] >= mx) { mx = maxes[3]; t = 24; }

  ASM emms;
  retu = (retu >> t) & 0xff;

  return(retu);

#undef a
#undef b
#undef idx
#undef lsp
#undef tab
#undef max
#undef maxi

#else   // if assembly code not selected, use C code

  int Indx[4],i,s,ret;
  short Max[4],Err,mx;
  short m0,m1,m2,m3,m4,m5,m6,m7,t;

  for (i=0; i<4; i++)
  {
    Max[i] = Indx[i] = 0;
  }
    
  for (i=0; i < LspCbSize; i++)
  {
    s = (i&3);

    m0 = mult(Lspw[4],LspTab[s+0]);
    t = LspTab[s+0]-Lspw[0];  m1 = mult(t,m0<<2);
    m2 = mult(Lspw[5],LspTab[s+4]);
    t = LspTab[s+4]-Lspw[1];  m3 = mult(t,m2<<2);
    m4 = mult(Lspw[6],LspTab[s+8]);
    t = LspTab[s+8]-Lspw[2];  m5 = mult(t,m4<<2);
    m6 = mult(Lspw[7],LspTab[s+12]);
    t = LspTab[s+12]-Lspw[3];  m7 = mult(t,m6<<2);

    Err = m1+m3+m5+m7;

    if (Err >= Max[s])
    {
      Max[s] = Err;
      Indx[s] = i;
    }

    if (s==3)
      LspTab += 16;
  }
  mx = Max[0]; ret = Indx[0];
  if (Max[1] >= mx) { mx = Max[1]; ret = Indx[1]; }
  if (Max[2] >= mx) { mx = Max[2]; ret = Indx[2]; }
  if (Max[3] >= mx) { mx = Max[3]; ret = Indx[3]; }

  return(ret);

#endif
}
//--------------------------------------------------------------

Word32  Svq_Int(float *Lsp, float *Wvect)
{
#define LSP_SCALE 256

  int  i;

  Word32 Rez;
  int    z;
  short Wint[LpcOrder],LspTemp[LpcOrder];
  DECLARE_SHORT(Lspw,32);

  ALIGN_ARRAY(Lspw);

  for (i=0; i<LpcOrder; i++)
  {
    z = (int)(LSP_SCALE*2*Lsp[i]);
    if (z > 32767) LspTemp[i] = 32767;
    else if (z < -32768) LspTemp[i] = -32768;
    else LspTemp[i] = z;
  }
  FloatToShortScaled(Wvect,Wint,10,0);
  Rez = (Word32) 0;

// For each of the 3 bands
  
  Lspw[0] = LspTemp[0]; Lspw[1] = LspTemp[1]; Lspw[2] = LspTemp[2];
  Lspw[3] = 0;
  Lspw[4] = -Wint[0]; Lspw[5] = -Wint[1]; Lspw[6] = -Wint[2];
  Lspw[7] = 0;
  Rez = LspSearchInt(Lspw,LspTableInt);

  Lspw[0] = LspTemp[3]; Lspw[1] = LspTemp[4]; Lspw[2] = LspTemp[5];
  Lspw[3] = 0;
  Lspw[4] = -Wint[3]; Lspw[5] = -Wint[4]; Lspw[6] = -Wint[5];
  Lspw[7] = 0;
  Rez = (Rez<<8) + LspSearchInt(Lspw,&LspTableInt[1024]);

  Lspw[0] = LspTemp[6]; Lspw[1] = LspTemp[7]; Lspw[2] = LspTemp[8];
  Lspw[3] = LspTemp[9];
  Lspw[4] = -Wint[6]; Lspw[5] = -Wint[7]; Lspw[6] = -Wint[8];
  Lspw[7] = -Wint[9];
  Rez = (Rez<<8) + LspSearchInt(Lspw,&LspTableInt[2048]);

  return Rez;

}
#endif
//---------------------------------------------------------------
float Polynomial(float *Lpq, int CosPtr)
{
  return(Lpq[LpcOrder]*CosineTable[0] +
    Lpq[LpcOrder-2]*CosineTable[CosPtr] +
    Lpq[LpcOrder-4]*CosineTable[(CosPtr*2)&(CosineTableSize-1)] +
    Lpq[LpcOrder-6]*CosineTable[(CosPtr*3)&(CosineTableSize-1)] +
    Lpq[LpcOrder-8]*CosineTable[(CosPtr*4)&(CosineTableSize-1)] +
    Lpq[LpcOrder-10]*CosineTable[(CosPtr*5)&(CosineTableSize-1)]);
}


//--------------------------------------------------------------
void  AtoLsp(float *LspVect, float *Lpc, float *PrevLsp)
{
  int  i,j,k;
  int  LspCnt;
  float  Lpq[LpcOrder+2];
  float  PrevVal,CurrVal,AbsPrev,AbsCurr;

// Small additional bandwidth expansion
  
  for (i=0; i < LpcOrder; i++)
    LspVect[i] = Lpc[i]*BandExpTable[i];

// Compute Lp and Lq
 
  Lpq[0] = Lpq[1] = 1.0f;

  for (i=0; i < LpcOrder/2; i++)
  {
    Lpq[2*i+2] = -Lpq[2*i+0] - LspVect[i] - LspVect[LpcOrder-1-i];
    Lpq[2*i+3] =  Lpq[2*i+1] - LspVect[i] + LspVect[LpcOrder-1-i];
  }
  Lpq[LpcOrder+0] *= 0.5f;
  Lpq[LpcOrder+1] *= 0.5f;

// Do first evaluation
  
  k = 0;
  LspCnt = 0;
  PrevVal = Polynomial(Lpq,0);

  for (i=1; i < CosineTableSize/2; i++)
  {
// Evaluate the polynomial
    
    CurrVal = Polynomial(&Lpq[k],i);

// Test for sign change
    
    if ((asint(CurrVal) ^ asint(PrevVal)) < 0)
    {
      AbsPrev = (float)fabs(PrevVal);
      AbsCurr = (float)fabs(CurrVal);

      LspVect[LspCnt++] = (i-1 + AbsPrev/(AbsPrev+AbsCurr));

// Check if all found 

      if (LspCnt == LpcOrder)
        break;

// Switch the pointer, evaluate again
 
      k ^= 1;
      CurrVal = Polynomial(&Lpq[k],i);
    }
    PrevVal = CurrVal;
  }

// Check if all Lsp found

  if (LspCnt != LpcOrder)
  {
    for (j=0; j < LpcOrder; j++)
      LspVect[j] = PrevLsp[j];
    
  }
    return;
}
//--------------------------------------------------------------
Word32 Lsp_Qnt(float *CurrLsp, float *PrevLsp, int UseMMX)
{
  int  i;

  float Wvect[LpcOrder];
  float Min,Tmp;

// Compute the weighting vector
  
  Wvect[0] = 1.0f/(CurrLsp[1] - CurrLsp[0]);
  Wvect[LpcOrder-1] = 1.0f/(CurrLsp[LpcOrder-1] - CurrLsp[LpcOrder-2]);

  for (i=1; i < LpcOrder-1; i++)
  {
    Min = CurrLsp[i+1] - CurrLsp[i];
    Tmp = CurrLsp[i] - CurrLsp[i-1];
    
    if (Tmp < Min)
      Min = Tmp;

    if (Min > 0.0f)
      Wvect[i] = 1.0f/Min;
    else
      Wvect[i] = 1.0f;
  }

// Generate predicted vector as (DC-removed-Curr) - b*(DC-removed-Prev)

    CurrLsp[0] = (CurrLsp[0] - LspDcTable[0]) -
      LspPred0*(PrevLsp[0] - LspDcTable[0]);
	   CurrLsp[1] = (CurrLsp[1] - LspDcTable[1]) -
      LspPred0*(PrevLsp[1] - LspDcTable[1]);
	   CurrLsp[2] = (CurrLsp[2] - LspDcTable[2]) -
      LspPred0*(PrevLsp[2] - LspDcTable[2]);
	   CurrLsp[3] = (CurrLsp[3] - LspDcTable[3]) -
      LspPred0*(PrevLsp[3] - LspDcTable[3]);
	   CurrLsp[4] = (CurrLsp[4] - LspDcTable[4]) -
      LspPred0*(PrevLsp[4] - LspDcTable[4]);
	   CurrLsp[5] = (CurrLsp[5] - LspDcTable[5]) -
      LspPred0*(PrevLsp[5] - LspDcTable[5]);
	   CurrLsp[6] = (CurrLsp[6] - LspDcTable[6]) -
      LspPred0*(PrevLsp[6] - LspDcTable[6]);
	   CurrLsp[7] = (CurrLsp[7] - LspDcTable[7]) -
      LspPred0*(PrevLsp[7] - LspDcTable[7]);
	   CurrLsp[8] = (CurrLsp[8] - LspDcTable[8]) -
      LspPred0*(PrevLsp[8] - LspDcTable[8]);
	   CurrLsp[9] = (CurrLsp[9] - LspDcTable[9]) -
      LspPred0*(PrevLsp[9] - LspDcTable[9]);

// Do the SVQ
#if COMPILE_MMX
  	if (UseMMX)
    	return Svq_Int(CurrLsp, Wvect);
  	else
#endif
    	return Lsp_Svq(CurrLsp, Wvect);
}


//--------------------------------------------------------------
Word32  Lsp_Svq(float *Lsp, float *Wvect)
{
  int  i,k;

  Word32 Rez;
  int    Indx,Start,Dim;
  float *LspQntPnt;
  float  Max,Err,lsp0,lsp1,lsp2,lsp3,w0,w1,w2,w3;
  float LspTemp[LpcOrder];

  for (i=0; i<LpcOrder; i++)
    LspTemp[i] = 2.0f*Lsp[i];
  Rez = (Word32) 0;

// For each of the 3 bands
  
  for (k=0; k < LspQntBands; k++)
  {

// Initialize the search
    
    Max = 0.0f;  //-1.0f;
    Indx = 0;
    LspQntPnt = BandQntTable[k];
    Start = BandInfoTable[k][0];
    Dim = BandInfoTable[k][1];

    lsp0 = LspTemp[Start+0];
    lsp1 = LspTemp[Start+1];
    lsp2 = LspTemp[Start+2];
    w0 = Wvect[Start+0];
    w1 = Wvect[Start+1];
    w2 = Wvect[Start+2];
    
    if (k < 2)
    {
      for (i=0; i < LspCbSize; i++)
      {
        Err = (lsp0 - LspQntPnt[0])*w0*LspQntPnt[0] +
          (lsp1 - LspQntPnt[1])*w1*LspQntPnt[1] +
          (lsp2 - LspQntPnt[2])*w2*LspQntPnt[2];

        LspQntPnt += 3;

        if (asint(Err) > asint(Max))
        {
          Max = Err;
          Indx = i;
        }
      }
    }
    else
    {
      lsp3 = LspTemp[Start+3];
      w3 = Wvect[Start+3];
      for (i=0; i < LspCbSize; i++)
      {
        Err = (lsp0 - LspQntPnt[0])*w0*LspQntPnt[0] +
          (lsp1 - LspQntPnt[1])*w1*LspQntPnt[1] +
          (lsp2 - LspQntPnt[2])*w2*LspQntPnt[2] +
          (lsp3 - LspQntPnt[3])*w3*LspQntPnt[3];

        LspQntPnt += 4;

        if (asint(Err) > asint(Max))
        {
          Max = Err;
          Indx = i;
        }
      }
    }
    Rez = (Rez << 8) | Indx;
  }

  return Rez;
}


//--------------------------------------------------------------
Flag  Lsp_Inq(float *Lsp, float *PrevLsp, Word32 LspId, int Crc)
{
  int  i,j;

  float *LspQntPnt;
  float  Lprd,Scon,Tmpf,Scon2;
  int    Tmp;
  Flag   Test;

  if (Crc == 0)
  {
    Scon = 2.0f;
    Lprd = LspPred0;
  }
  else
  {
    LspId = (Word32) 0;
    Scon = 4.0f;
    Lprd = LspPred1;
  }
  Scon2 = Scon - 0.03125f;

// Reconstruct the LSP vector
  
  for (i=LspQntBands-1; i >= 0; i--)
  {
    Tmp = LspId & (Word32) 0x000000ff;
    LspId >>= 8;

    LspQntPnt = BandQntTable[i];

    for (j=0; j < BandInfoTable[i][1]; j++)
      Lsp[BandInfoTable[i][0] + j] = LspQntPnt[Tmp*BandInfoTable[i][1] + j];
  }

// Add predicted vector and DC to decoded vector
  
  for (j=0; j < LpcOrder; j++)
    Lsp[j] = Lsp[j] + (PrevLsp[j] - LspDcTable[j])*Lprd + LspDcTable[j];

// Perform the stability check
  
  for (i=0; i < LpcOrder; i++)
  {

// Test the first and last one

    if (Lsp[0] < 3.0) 
      Lsp[0] = 3.0f;

    if (Lsp[LpcOrder-1] > 252.0f)
      Lsp[LpcOrder-1] = 252.0f;

// Test the others
    
    for (j=1; j < LpcOrder; j++)
    {
      Tmpf = Scon + Lsp[j-1] - Lsp[j];
      if (Tmpf > 0)
      {
        Tmpf *= 0.5f;
        Lsp[j-1] -= Tmpf;
        Lsp[j] += Tmpf;
      }
    }
    
// Test if stable
    
    Test = False;
    for (j=1; j < LpcOrder; j++)
      if ((Lsp[j] - Lsp[j-1]) < Scon2)
        Test = True;

    if (Test == False)
      break;
  }
  if (Test == True)
  	for (j=0; j < LpcOrder; j++)
	  Lsp[j] = PrevLsp[j];
  return Test;
}


//--------------------------------------------------------------
void  Lsp_Int(float *QntLpc, float *CurrLsp, float *PrevLsp)
{
  int  i,j;

  float  *Dpnt;
  float  Fac[4] = {0.25f, 0.5f, 0.75f, 1.0f};

  Dpnt = QntLpc;
  for (i=0; i < SubFrames; i++)
  {
// Interpolate

    for (j=0; j < LpcOrder; j++)
      Dpnt[j] = (1.0f - Fac[i])*PrevLsp[j] + Fac[i]*CurrLsp[j];

// Convert to Lpc
    
	  LsptoA(Dpnt);
    Dpnt += LpcOrder;
  }

// Copy the Lsp vector
  
  for (i=0; i < LpcOrder; i++)
    PrevLsp[i] = CurrLsp[i];
}


//--------------------------------------------------------------
void  LsptoA(float *Lsp)
{
  int i,j;

  float P[LpcOrder/2+1];
  float Q[LpcOrder/2+1];
  float Fac[(LpcOrder/2)-2] = {1.0f,0.5f,0.25f};

// Convert Lsp's to cosines
  
  for (i=0; i < LpcOrder; i++)
  {
    j = MyFloor(Lsp[i]);
    Lsp[i] = -(CosineTable[j] +
      (CosineTable[j+1]-CosineTable[j])*(Lsp[i]-j));
  }

// Init P and Q.  Note that P,Q * 2^26 correspond to fixed-point code

  P[0] = 0.5f;
  P[1] = Lsp[0] + Lsp[2];
  P[2] = 1.0f + 2.0f*Lsp[0]*Lsp[2];

  Q[0] = 0.5f;
  Q[1] = Lsp[1] + Lsp[3];
  Q[2] = 1.0f + 2.0f*Lsp[1]*Lsp[3];

// Compute all the others
  
  for (i=2; i < LpcOrder/2; i++)
  {
    P[i+1] = P[i-1] + P[i]*Lsp[2*i+0];
    Q[i+1] = Q[i-1] + Q[i]*Lsp[2*i+1];

// All update
    
    for (j=i; j >= 2; j--)
    {
      P[j] = P[j-1]*Lsp[2*i+0] + 0.5f*(P[j]+P[j-2]);
      Q[j] = Q[j-1]*Lsp[2*i+1] + 0.5f*(Q[j]+Q[j-2]);
    }

// Update PQ[01]

    P[0] = P[0]*0.5f;
    Q[0] = Q[0]*0.5f;

    P[1] = (P[1] + Lsp[2*i+0]*Fac[i-2])*0.5f;
    Q[1] = (Q[1] + Lsp[2*i+1]*Fac[i-2])*0.5f;
  }

// Convert to Lpc
  
  for (i=0; i < LpcOrder/2; i++)
  {
    Lsp[i] =            (-P[i] - P[i+1] + Q[i] - Q[i+1])*8.0f;
    Lsp[LpcOrder-1-i] = (-P[i] - P[i+1] - Q[i] + Q[i+1])*8.0f;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\mmxutil.h ===
int  IsMMX();
void MakeAligned0(void *input, void *output, int numbytes);
void MakeAligned2(void *input, void *output, int numbytes);
void MakeAligned4(void *input, void *output, int numbytes);
void MakeAligned6(void *input, void *output, int numbytes);
void ShortToFloatScale(short *x, float scale, int N, float *y);
void IntToFloatScale(int *x, float scale, int N, float *y);
void IntToFloat(int *x, int N, float *y);
int FloatToShortScaled(float *in, short *out, int len, int guard);
int FloatToIntScaled(float *in, int *out, int len, int guard);
int FloatMaxExp(float *in, int len);
void ScaleFloatToShort(float *in, short *out, int len, int newmax);
void ScaleFloatToInt(float *in, int *out, int len, int newmax);
void CorrelateInt(short *taps, short *array, int *corr, int len, int num);
void CorrelateInt4(short *taps, short *array, int *corr, int len, int num);
void ab2abbcw(const short *input, short *output, int n);
void ab2ababw(const short *input, short *output, int n);
void ab2abzaw(const short *input, short *output, int n);
void ConvMMX(short *in1, short *in2, int *out, int ncor);
void ConstFloatToShort(float *input, short *output, int len, float scale) ;
void ConstFloatToInt(float *input, int *output, int len, float scale) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\sdstruct.h ===
/**********************************************************************/
/**********************************************************************/
/*********       Global constants used by silence detector      *******/
/**********************************************************************/
/**********************************************************************/

//BUFERSIZE is the size, in samples, of the speech encoder input buffer.
//This should be set to the same value as MYCODEC_BUFFER_SAMPS in mycodec.h 

#define BUFFERSIZE 	240

//HIST_TIME is the time period, in seconds, represented by the number of past values of SD
//	parameters kept in memory.  HIST_SIZE is the size of the history arrys and is set so 
//	that the size of the history arrays correspond to HIST_TIME seconds of stored SD parameters. 

#define HIST_TIME 	1.0
#define HIST_SIZE 	(int)(HIST_TIME*8000/BUFFERSIZE)

//ENERGY_TAU_HIST_TIME is the time period, in seconds, represented by the number of past 
// values of energy tau kept in memory.  Energy tau is used only by the SD initializer.

#define ENERGY_TAU_HIST_TIME  1.5
#define	ENERGY_TAU_HIST_SIZE  (int)(ENERGY_TAU_HIST_TIME*8000/BUFFERSIZE)

#define OFFSET					10
#define MAX_SAMPLE				32768.0

#define MASK_SILENCE_MARKED		0x01
#define MASK_EARLY_EXIT			0x02
#define MASK_SILENCE_CODED		0x04

#define MASK_SQUELCH			0xF00

//The following times (in seconds) are used by initializeSD to 
//	decide when to stop initializing.
//Initialization is not allowed to complete before the end of
//  MIN_STARTUP_TIME, in seconds.
//If initialization fails before the end of MAX_STARTUP_TIME,
//  silence detection is disabled
#define MIN_STARTUP_TIME		2
#define MAX_STARTUP_TIME		20

#define STOPPING_STDEV			3.0
#define INITL_STOPPING_STDEV	10.0
#define INITL_MIN_TAU			20.0

#define INITL_STDEV				2.0

//MAX_SPEECH_TIME time is the amount of time in seconds that the silence "off"
//  mode (no silent frames detected) is allowed to continue before
//  reinitialization is automatically invoked.
#define MAX_SPEECH_TIME			4.0

//SD_MIN_BUFFERSIZE is the smallest possible input buffersize
//	in bytes for silence detection (20 samples)  
#define SD_MIN_BUFFERSIZE		40

//Initial threshold settings
#define SLIDER_MAX				100.0f
#define SLIDER_MIN				0.0f

#define INITL_HANGTIME			0
#define MIN_SPEECH_INTERVAL		6
#define HANG_SLOPE				6.0f/14.0f

#define INITL_ENERGY_ON			3.8f
#define INITL_ENERGY_TX			INITL_ENERGY_ON

#define INITL_ZC_ON				2.0f
#define INITL_ZC_TX				INITL_ZC_ON
#define ZC_SLOPE				0.045f

#define INITL_ALPHA_ON			2.0f

#define INITL_ENERGY_OFF		2.8f

#define INITL_ZC_OFF			INITL_ZC_ON

#define INITL_ALPHA_OFF			INITL_ALPHA_ON
 
#define FALSE		0
#define TRUE		1

#define SPEECH		0
#define SILENCE		1
#define NONADAPT	3

/**********************************************************************/
/**********************************************************************/
/*********   Data structure for silence detector and prefilters *******/
/**********************************************************************/
/**********************************************************************/

typedef struct {

	float Mean;
	float Stdev;
	float History[HIST_SIZE];

} STATS;

typedef struct {

	STATS Energy;
	STATS Alpha1;
	STATS ZC;
	int   FrameCount;
	
} MODE0;

typedef struct {

	STATS Energy;
	int   FrameCount;
	
} MODE1;

typedef struct {

	float TauMean;
	float TauStdev;
	float TauHistory[ENERGY_TAU_HIST_SIZE];

} TAU_STATS;

typedef struct {

	TAU_STATS TauEnergy;
	TAU_STATS TauAlpha1;
	TAU_STATS TauZC;
	
} TAU_MODE;

typedef struct {

/*The following parameters are used to set thresholds for
 *	changing from silence to speechmode designation in Silence_Detect.  
 *	These are factors which are used to multiply the standard deviation of
 *	the energy, alpha1, & zero crossing, respectively.
 */
	float Energy_on;
	float ZC_on;
	float Alpha1_on;

	float Energy_tx;
	float ZC_tx;

/*The following parameters are used to set thresholds for
 *	changing from speech to silent mode designation in Silence_Detect.  
 *These are factors which are used to multiply the standard deviation of
 *	the energy & zero crossing, respectively.
 */
	float Energy_off;
	float ZC_off;
	float Alpha1_off;

/* Tau is the distance between the Mode0 (silence) and the Mode1 (speech) energy means.
	If the distance between mode 0 and mode 1 energy means is less than MIN_TAU, 
 	silence detection is impossible.  
 */
	float Energy_MinTau;

/* Energy squelch level */
	
	float Squelch_set;

	int   BufferSize;
	int   HistSize;
	int   TauHistSize;

	int	  MinStartupCount;
	int   MaxStartupCount;

	int	  MaxSpeechFrameCount;

} SETTINGS;

typedef struct {

	float nBuffer[4];
	float dBuffer[3];
	float denom[6];
	float num[6];
	float sbuff[BUFFERSIZE];
	float storebuff[BUFFERSIZE];

} FILTERS;

typedef struct {

  MODE0 Mode0;
  MODE1 Mode1;

  MODE0 *Mode0Ptr;
  MODE1 *Mode1Ptr;

  TAU_MODE TauMode; 
  
  int  	initFrameCount;
  int	Class;
  int	SD_enable;

  float	FrameEnergy;
  float	FrameLinPred;
  float	FrameZCs;

  SETTINGS SDsettings;

  FILTERS Filt;

  int	HangCntr;

} SD_STATE_VALS;

typedef struct {
  
  long SDFlags;

  //COMFORT_PARMS ComfortParms;

  SD_STATE_VALS SDstate;

} INSTNCE, *SD_INST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\sdstuff.c ===
#include <stdio.h>
#include <stdlib.h>
#include "sdstruct.h"
#include "sdstuff.h"
#include "tabl_ns.h"
#include <math.h>

/**************************************************************
***************************************************************
***************************************************************
***************************************************************
Silence Detection subroutines 
Mark R. Walker, 5/95
Copyright Intel Inc., 1995
***************************************************************
***************************************************************
***************************************************************/


/************************************************************************************************/
/************************************************************************************************/
/*******                                  get_params                             ************/
/************************************************************************************************/
/************************************************************************************************/
/* This subroutine computes the parameters used by the classifier to determine 
whether the current frame is silent*/
#if PLOTFILE	
	void getParams(INSTNCE *SD_inst, float *inbuff, int buffersize, float *p1, float *p2, float *p3)
#else
	void getParams(INSTNCE *SD_inst, float *inbuff, int buffersize)
#endif
{
	int		M, p, i, q, offset, index;
	float	*buffptr,R[12];
	float	gamma, delta, L[50], E[12];
	float 	alpha0;
	float	Energy;
	float	epsilon = 0.00001f;

		
	M = 6;

	buffptr = inbuff;
	offset = M;

	for(i=0; i<(M-1)*(M-1); i++) L[i] = 0.0f;

	Energy = DotProdSD(buffptr, buffptr, buffersize)/buffersize;

	/* Compute autocorrelation coeffs. */
	for(q=0; q<=M; q++) R[q] = DotProdSD(buffptr, buffptr+q, buffersize-q);
	
	for(i=0; i<=M; i++) R[i] = Binomial80[i]*R[i];

	/* Compute first linear predictor */
	L[0] = 1.0f;
	E[0] = R[0];

	/* Forward Levinson's recursion */
	for(p=1;p<=M;p++)
	{
		for(delta=0.0f, i=0;i<p;i++) delta += R[i+1]*L[(p-1)*offset + i]; 
		
		if (E[p-1]!=0.0) gamma = delta / E[p-1];
		else			 gamma = epsilon;
	
		L[p*offset+0] = -gamma;

		for(i=1;i<p;i++) L[p*offset + i] = L[(p-1)*offset + i-1] - gamma*L[(p-1)*offset + p-1-i];
		
		L[p*offset + p] = 1.0f;
		E[p] = E[p-1] * (1.0f-gamma*gamma);
	}
	alpha0 = -L[33];

	/* Load the calculated parameters into the SD data structure */

	/* Zero crossings */
	SD_inst->SDstate.FrameZCs = (float) zeroCross(inbuff, buffersize)/buffersize;
	/* Frame energy */
	if(Energy!=0.0f)
		SD_inst->SDstate.FrameEnergy = (float)(20.0f*log10(Energy));
	else {
		index = (SD_inst->SDFlags & MASK_SQUELCH) >> 8;
		SD_inst->SDstate.FrameEnergy = Squelch[index] - 9.0f
			+ SD_inst->SDstate.SDsettings.Energy_on
			+ SD_inst->SDstate.Mode0Ptr->Energy.Stdev;
	}

	/* First linear predictor */
	SD_inst->SDstate.FrameLinPred = 100.0f*alpha0;

#if PLOTFILE
	*p1 = SD_inst->SDstate.FrameZCs;
	*p2 = SD_inst->SDstate.FrameEnergy;
	*p3 = SD_inst->SDstate.FrameLinPred;
#endif

//end
}
/************************************************************************************************/
/************************************************************************************************/
/*******                               glblSDinitialize                              ************/
/************************************************************************************************/
/************************************************************************************************/
/* This routine is called once per session for setting global values needed for silence         */
/*	detection.																					*/
/************************************************************************************************/
/************************************************************************************************/
void glblSDinitialize(INSTNCE *SD_inst)
{
	int i, index, histSize, tauHistSize;
   	float squelch_level;

/* Set the mode pointers pointing to the mode structures - initially */
  SD_inst->SDstate.Mode0Ptr = &(SD_inst->SDstate.Mode0);
  SD_inst->SDstate.Mode1Ptr = &(SD_inst->SDstate.Mode1);

/* set history sizes based on buffersize, passed in from minifilter shell*/
  			    SD_inst->SDstate.SDsettings.BufferSize = BUFFERSIZE;
  histSize =    SD_inst->SDstate.SDsettings.HistSize = HIST_SIZE;
  tauHistSize = SD_inst->SDstate.SDsettings.TauHistSize = ENERGY_TAU_HIST_SIZE;
  				SD_inst->SDstate.SDsettings.MinStartupCount = (int)(MIN_STARTUP_TIME*8000.0/BUFFERSIZE);
  				SD_inst->SDstate.SDsettings.MaxStartupCount = (int)(MAX_STARTUP_TIME*8000.0/BUFFERSIZE);
  				SD_inst->SDstate.SDsettings.MaxSpeechFrameCount = (int)(MAX_SPEECH_TIME*8000.0/BUFFERSIZE);

  /* set silent/sound frame designation initially to silent */
  /* Class = 1, silent frame
     Class = 0, non-silent */
  SD_inst->SDstate.Class = 1;

  /*set silence detetction initally disabled */
  /* SD_enable =0, silence detection disabled - SD_initialize executes
     SD_enable =1, silence detection enabled */  
  SD_inst->SDstate.SD_enable = 0;

  /* The flags should be set in the minifilter audio format */
  //SD_inst->SDFlags = 0;
  //SD_inst->SDFlags |= MASK_SD_ENABLE;  /* set enable bit by default */

  /*The energy squelch level is acquired by unmasking some of
  the bits in SDFlags */
  index = (SD_inst->SDFlags & MASK_SQUELCH) >> 8;
  squelch_level = Squelch[index];

  SD_inst->SDstate.SDsettings.Squelch_set = squelch_level; 

  /*
   *Tau distributions initial values.  Tau is is the distance between the mean silent energy (mode 0),
   and the mean speech energy (mode 1).  It is only used in SD_initialize. 
   */
   /*TauStdev is used in SD_initialize to decide when to quit initializing*/
	SD_inst->SDstate.TauMode.TauEnergy.TauStdev = (float)INITL_STOPPING_STDEV; 

	/*Minimum acceptable Tau value used in SD_initialize to decide if silence detection is possible*/
	SD_inst->SDstate.SDsettings.Energy_MinTau 	= (float)INITL_MIN_TAU;

	for (i=0;i<tauHistSize;i++) SD_inst->SDstate.TauMode.TauEnergy.TauHistory[i] = 0.0f;

	/*Mode 0 & 1 distribution initial values.  Mode 0 is the statistical information for silence.
	Mode 1 is the statistical information for speech */ 
	for (i=0;i<histSize;i++)
	{
		SD_inst->SDstate.Mode1Ptr->Energy.History[i] = 0.0f;

		SD_inst->SDstate.Mode0Ptr->Energy.History[i] = 0.0f;
		SD_inst->SDstate.Mode0Ptr->Alpha1.History[i] = 0.0f;
		SD_inst->SDstate.Mode0Ptr->ZC.History[i] 	 = 0.0f;
	}
	/*set initial frame counts*/
	/*initFrameCount is only used to count frames in SD_initialize
	The Mode 0 and Mode 1 counters count continuous runs of 
	silent and non-silent frames, resepctively.  
	They are used in both SD_initialize and the main GSM encoder loop */
	SD_inst->SDstate.initFrameCount = 0;
    SD_inst->SDstate.Mode0Ptr->FrameCount=0;
    SD_inst->SDstate.Mode1Ptr->FrameCount=0;
	
	/*Mode 1 (speech) initial values*/
	SD_inst->SDstate.Mode1Ptr->Energy.Mean 		= squelch_level + 10.0f;
	SD_inst->SDstate.Mode1Ptr->Energy.Stdev 	= 1.0f;

	/*Mode 0 (silence) initial values*/
	SD_inst->SDstate.Mode0Ptr->Energy.Mean 		= squelch_level - 10.0f;
	SD_inst->SDstate.Mode0Ptr->Energy.Stdev 	= 1.0f;

	SD_inst->SDstate.Mode0Ptr->Alpha1.Mean 		= 0.0f;
	SD_inst->SDstate.Mode0Ptr->Alpha1.Stdev 	= 0.0f;

	SD_inst->SDstate.Mode0Ptr->ZC.Mean 			= 0.0f;
	SD_inst->SDstate.Mode0Ptr->ZC.Stdev			= 0.0f;

	/* class = 0 = speech frame = "off"
	/* class = 1 = silent frame = "on"

	/*"On" thresholds used by silence_detect and SD_initialize.
	These values either multiply or are added to the standard
	deviation of each of the three stat types.
	Making these values smaller makes the range of values
	smaller, and thus makes the transition from speech
	frame designation (Class=0) to silent frame designation (Class=1)
	less likely */
	
	SD_inst->SDstate.SDsettings.Energy_on		=INITL_ENERGY_ON;	
	SD_inst->SDstate.SDsettings.ZC_on			=INITL_ZC_ON;
	SD_inst->SDstate.SDsettings.Alpha1_on 		=INITL_ALPHA_ON;

	SD_inst->SDstate.HangCntr = 0;

	/*"Off" thresholds used by silence_detect.
	These values either multiply or are added to the standard
	deviation of each of the three stat types.
	Making these values smaller makes the transition from silent
	frame designation (Class=1) to speech frame designation (Class=0)
	harder, less likely */
	SD_inst->SDstate.SDsettings.Energy_off 		=INITL_ENERGY_OFF;
	SD_inst->SDstate.SDsettings.ZC_off 			=INITL_ZC_OFF;
	SD_inst->SDstate.SDsettings.Alpha1_off 		=INITL_ALPHA_OFF;


	/* Initialize circular buffers for prefiltering operations */
	for(i=0;i<4;i++) SD_inst->SDstate.Filt.nBuffer[i]=0.0f;
  	for(i=0;i<3;i++) SD_inst->SDstate.Filt.dBuffer[i]=0.0f;
  	for(i=0;i<6;i++){
  		SD_inst->SDstate.Filt.denom[i]=0.0f;
  		SD_inst->SDstate.Filt.num[i]=0.0f;
	}

}/*End global initalize SD*/


/***********************************************************************************************/
/************************************************************************************************/
/*******                                  silenceDetect                             ************/
/************************************************************************************************/
/************************************************************************************************/
/*	Mark R. Walker
	Copyright Intel inc., 1995*/

/*	Silence_Detect is executed once per frame if silence detection is enabled.  
	It employs three vocoder parameters (energy, zero crossings, first predictor) 
	to determine if a given frame is speech or background silence.  
	It returns the resulting frame classification. */
/************************************************************************************************/
/************************************************************************************************/
int silenceDetect(INSTNCE *SD_inst, float Energy_tx, float ZC_tx)
{	
	int	histSize, adaptEnable, i, Class;
	float	Alpha1_val, Energy_val, Zc_count;

/* set history sizes based on buffersize, passed in from minifilter shell*/
  histSize = SD_inst->SDstate.SDsettings.HistSize; 
 	
/*
 *	 -------state switch decision criteria -------
 *
 *	Class = 1, frame is silent
 *	Class = 0, frame is non-silent
 */
	adaptEnable = TRUE;

 	Alpha1_val = SD_inst->SDstate.FrameLinPred;
	Energy_val = SD_inst->SDstate.FrameEnergy;
	Zc_count   = SD_inst->SDstate.FrameZCs;

	if (Energy_val <= SD_inst->SDstate.Mode0Ptr->Energy.Mean)
	/* if current frame Energy_val <= mode0 energy mean, this is definitely a silent frame*/
	{
		/* In this case, do no further testing of the frame class */
		SD_inst->SDstate.Class = SILENCE;


		/* If the current frame energy is too low, this frame may be an
			outlier with respect to the silence statistics.  Test and
			do not allow adaptation if this is true.
		*/
		if(Energy_val < (SD_inst->SDstate.Mode0Ptr->Energy.Mean - 2.0*(SD_inst->SDstate.Mode0Ptr->Energy.Stdev))) 
			adaptEnable = FALSE;
	}
	else /* else test the frame class */
	{
		SD_inst->SDstate.Class = classify(Energy_val,Alpha1_val,Zc_count,
			SD_inst->SDstate.Mode0Ptr->Energy.Mean, SD_inst->SDstate.Mode0Ptr->Energy.Stdev,
			SD_inst->SDstate.Mode0Ptr->Alpha1.Mean, SD_inst->SDstate.Mode0Ptr->Alpha1.Stdev,
			SD_inst->SDstate.Mode0Ptr->ZC.Mean, SD_inst->SDstate.Mode0Ptr->ZC.Stdev,
			SD_inst->SDstate.Class, 
			Energy_tx, ZC_tx, SD_inst);
	}  

/*	------- update statistics-------
 *
 *	if frame class is silent, update silence stats only
 */
	if ((SD_inst->SDstate.Class!=SPEECH) && (SD_inst->SDstate.Class!=NONADAPT) && (adaptEnable==TRUE))
	{
/*		------- update history arrays------- 
 */
  		for(i=histSize-1; i>=1; i--)
		{
  			SD_inst->SDstate.Mode0Ptr->Alpha1.History[i] = SD_inst->SDstate.Mode0Ptr->Alpha1.History[i-1];
  			SD_inst->SDstate.Mode0Ptr->Energy.History[i] = SD_inst->SDstate.Mode0Ptr->Energy.History[i-1];
			SD_inst->SDstate.Mode0Ptr->ZC.History[i] 	= SD_inst->SDstate.Mode0Ptr->ZC.History[i-1];
  		}

/*		------- first linear predictor -------
 */
  		SD_inst->SDstate.Mode0Ptr->Alpha1.History[0] = Alpha1_val;
		update(SD_inst->SDstate.Mode0Ptr->Alpha1.History,histSize,
			&(SD_inst->SDstate.Mode0Ptr->Alpha1.Mean),
			&(SD_inst->SDstate.Mode0Ptr->Alpha1.Stdev));

/*		------- energy -------
 */
  		SD_inst->SDstate.Mode0Ptr->Energy.History[0] = Energy_val;
		update(SD_inst->SDstate.Mode0Ptr->Energy.History,histSize,
			&(SD_inst->SDstate.Mode0Ptr->Energy.Mean),
			&(SD_inst->SDstate.Mode0Ptr->Energy.Stdev));

/*		------- zero crossing -------
 */
  		SD_inst->SDstate.Mode0Ptr->ZC.History[0] 	= Zc_count;
		update(SD_inst->SDstate.Mode0Ptr->ZC.History,histSize,
			&(SD_inst->SDstate.Mode0Ptr->ZC.Mean),
			&(SD_inst->SDstate.Mode0Ptr->ZC.Stdev));
	}

if(SD_inst->SDstate.Class == NONADAPT)
	Class = SILENCE;
else Class = SD_inst->SDstate.Class; 
	
return(Class); /*return frame classification*/

} /*end silenceDetect*/

/************************************************************************************************/
/************************************************************************************************/
/*******                                  initializeSD                               ************/
/************************************************************************************************/
/************************************************************************************************/
/*	Mark R. Walker
	Copyright Intel inc., 1995*/

/*	 initializeSD is executed once per frame prior to the enabling of silence detection.
	It employs three vocoder parameters (energy, zero crossings, first predictor) 
		to determine if a given frame is speech or background silence.
	The first part simply fills all of the Mode 0 history arrays and the Mode 1
		energy history arrays with values.  
	The second part of SD_Initialize can take no less than MIN_STARTUP frames, and no more than
		MAX_STARTUP frames.  
	Initalization ends when the standard deviation of the distance between the Mode 0 mean
		(silence) and the Mode 1 mean (speech) drops below STOPPING_STDEV.
	When the second part of the subroutine has completed, two tests are performed before silence
		detection is enabled.  First, the distance between the Mode 0 and Mode 1 energy means must be
		greater than or equal to Energy_MinTau.  Second, the energy "on" threshold must be less
		than the energy squelch level.    */
/************************************************************************************************/
/************************************************************************************************/
/*-------------------------------------------------------------------------------------------------------------------
 */
int initializeSD(INSTNCE *SD_inst)
{
int			SD_enable, i, j;
int			mode1HistSize, mode0HistSize;
int			bufferSize, histSize, tauHistSize, minFrameCount, maxFrameCount;
float	    Energy_tau, squelch_level;
float		Alpha1_val, Energy_val, Zc_count;  
STATS	    TempPtr;


SD_inst->SDstate.initFrameCount++;

Alpha1_val = SD_inst->SDstate.FrameLinPred;
Energy_val = SD_inst->SDstate.FrameEnergy;
Zc_count   = SD_inst->SDstate.FrameZCs;

/* set local values of history size */
bufferSize = SD_inst->SDstate.SDsettings.BufferSize;
histSize = SD_inst->SDstate.SDsettings.HistSize;

/* set local values of min and max frame count */
minFrameCount = SD_inst->SDstate.SDsettings.MinStartupCount;
maxFrameCount = SD_inst->SDstate.SDsettings.MaxStartupCount;  

/*First part of SD_Initialize simply fills the history arrays with values */

if(SD_inst->SDstate.initFrameCount < SD_inst->SDstate.SDsettings.TauHistSize)
{	tauHistSize = SD_inst->SDstate.initFrameCount;
}
else
{	tauHistSize = SD_inst->SDstate.SDsettings.TauHistSize;
}

if (((SD_inst->SDstate.TauMode.TauEnergy.TauStdev > STOPPING_STDEV) || (SD_inst->SDstate.initFrameCount <= minFrameCount)) && (SD_inst->SDstate.initFrameCount <= maxFrameCount))
{
	/*-----Select Energy mode decision--------*/
	if ((Energy_val < SD_inst->SDstate.Mode0Ptr->Energy.Mean) || (fabs(Energy_val - SD_inst->SDstate.Mode0Ptr->Energy.Mean) < (SD_inst->SDstate.SDsettings.Energy_on + SD_inst->SDstate.Mode0Ptr->Energy.Stdev)))
	{ /*Energy mode = Mode0 (silence)*/
		
		/*increment mode zero frame counter*/
		SD_inst->SDstate.Mode0Ptr->FrameCount++;

		if(SD_inst->SDstate.Mode0Ptr->FrameCount < histSize)
		{	mode0HistSize = SD_inst->SDstate.Mode0Ptr->FrameCount;
		}
		else
		{	mode0HistSize = histSize;
		}

		/*update the history arrays*/
		for (i=mode0HistSize-1; i>=1; i--)
		{
  			SD_inst->SDstate.Mode0Ptr->Alpha1.History[i] = SD_inst->SDstate.Mode0Ptr->Alpha1.History[i-1];
			SD_inst->SDstate.Mode0Ptr->Energy.History[i] = SD_inst->SDstate.Mode0Ptr->Energy.History[i-1];
			SD_inst->SDstate.Mode0Ptr->ZC.History[i] 	 = SD_inst->SDstate.Mode0Ptr->ZC.History[i-1];
  		}
  		
  		/*load new frame values into history arrays and update statistics */	
		SD_inst->SDstate.Mode0Ptr->Energy.History[0] = Energy_val;
		update(SD_inst->SDstate.Mode0Ptr->Energy.History,mode0HistSize,&(SD_inst->SDstate.Mode0Ptr->Energy.Mean),&(SD_inst->SDstate.Mode0Ptr->Energy.Stdev));
			
		SD_inst->SDstate.Mode0Ptr->Alpha1.History[0] = Alpha1_val;
		update(SD_inst->SDstate.Mode0Ptr->Alpha1.History,mode0HistSize,&(SD_inst->SDstate.Mode0Ptr->Alpha1.Mean),&(SD_inst->SDstate.Mode0Ptr->Alpha1.Stdev));
			
		SD_inst->SDstate.Mode0Ptr->ZC.History[0] 	= Zc_count;
		update(SD_inst->SDstate.Mode0Ptr->ZC.History,mode0HistSize,&(SD_inst->SDstate.Mode0Ptr->ZC.Mean),&(SD_inst->SDstate.Mode0Ptr->ZC.Stdev));
	}
	else /*Energy mode = 1 (speech) - Update Mode1 energy statistics only*/
	{
		/*increment mode 1 frame counter*/
		SD_inst->SDstate.Mode1Ptr->FrameCount++;

		if(SD_inst->SDstate.Mode1Ptr->FrameCount < histSize)
		{	mode1HistSize = SD_inst->SDstate.Mode1Ptr->FrameCount;
		}
		else
		{	mode1HistSize = histSize;
		}
		/*update the history array*/
		for (i=mode1HistSize-1; i>=1; i--) SD_inst->SDstate.Mode1Ptr->Energy.History[i] = SD_inst->SDstate.Mode1Ptr->Energy.History[i-1];
		/*load new frame values into history arrays and update statistics */	
		SD_inst->SDstate.Mode1Ptr->Energy.History[0]= Energy_val;
		update(SD_inst->SDstate.Mode1Ptr->Energy.History,mode1HistSize,&(SD_inst->SDstate.Mode1Ptr->Energy.Mean),&(SD_inst->SDstate.Mode1Ptr->Energy.Stdev));
	}
	/*  ---------------------- Compute  Tau  -------------------------------- */
 	/* Tau is the difference between the Mode0 and Mode1 mean energy values */
	Energy_tau = (float)fabs(SD_inst->SDstate.Mode0Ptr->Energy.Mean - SD_inst->SDstate.Mode1Ptr->Energy.Mean);
		
	/*	---------------------- Update Tau history -------------------------- */
	for (i=tauHistSize-1; i>=1; i--) SD_inst->SDstate.TauMode.TauEnergy.TauHistory[i] = SD_inst->SDstate.TauMode.TauEnergy.TauHistory[i-1];
  	SD_inst->SDstate.TauMode.TauEnergy.TauHistory[0]= Energy_tau;
	update(SD_inst->SDstate.TauMode.TauEnergy.TauHistory,tauHistSize,&(SD_inst->SDstate.TauMode.TauEnergy.TauMean),&(SD_inst->SDstate.TauMode.TauEnergy.TauStdev));

	/*	Now check the energy means.*/  
	/*	The mode with the lowest mean energy is always set to Mode0 (silence)*/
	if((SD_inst->SDstate.Mode1Ptr->Energy.Mean) < (SD_inst->SDstate.Mode0Ptr->Energy.Mean))
	{
		TempPtr = SD_inst->SDstate.Mode0Ptr->Energy;
		SD_inst->SDstate.Mode0Ptr->Energy = SD_inst->SDstate.Mode1Ptr->Energy;
		SD_inst->SDstate.Mode1Ptr->Energy = TempPtr;
	}
	
	/* We are still initializing - silence detection is disabled */
	SD_enable = FALSE; 

} /* if TauEnergy.TauStdev > STOPPING_STDEV */
else
{
	/* At this point, either Tau stdev has dropped below STOPPING_STDEV, or
	   we have exceeded MAX_STARTUP */ 
	/* Now decide whether silence / sound discrimination is possible */
		
	/* Get the squelch level from the data structure */
	squelch_level = SD_inst->SDstate.SDsettings.Squelch_set;
	
	/* Disable silence detection if TauEnergy.TauMean is less than Energy_MinTau */
	/* Disable also if we have never seen a silent frame (Mode0) */
	/* Disable also if the difference between the silence energy mean and the squelch level */
	/*	is less than the "Energy_on" threshold */
	if(
		( SD_inst->SDstate.TauMode.TauEnergy.TauMean < SD_inst->SDstate.SDsettings.Energy_MinTau) ||
		( SD_inst->SDstate.Mode0Ptr->FrameCount	== 0) ||
		( SD_inst->SDstate.Mode1Ptr->Energy.Mean == squelch_level + 10) ||//This is the initial value
		( fabs((SD_inst->SDstate.Mode0Ptr->Energy.Mean) - squelch_level) 
			< (SD_inst->SDstate.SDsettings.Energy_on * SD_inst->SDstate.Mode0Ptr->Energy.Stdev)) 
	)   
	{
		SD_enable = FALSE;
	}
	else
	{ 
		SD_enable = TRUE;
	}

	/* If the Mode0 history arrays are not filled - fill them out by repeating the last value */
	if((SD_inst->SDstate.Mode0Ptr->FrameCount !=0) && (SD_inst->SDstate.Mode0Ptr->FrameCount < histSize))
	{
		j=SD_inst->SDstate.Mode0Ptr->FrameCount;
		for(i=j; i<histSize; i++) SD_inst->SDstate.Mode0Ptr->Energy.History[i] = SD_inst->SDstate.Mode0Ptr->Energy.History[j-1];
		for(i=j; i<histSize; i++) SD_inst->SDstate.Mode0Ptr->Alpha1.History[i] = SD_inst->SDstate.Mode0Ptr->Alpha1.History[j-1];
		for(i=j; i<histSize; i++) SD_inst->SDstate.Mode0Ptr->ZC.History[i]     = SD_inst->SDstate.Mode0Ptr->ZC.History[j-1];
		SD_inst->SDstate.Mode0Ptr->Energy.Stdev = (float)INITL_STDEV;
	}
		
	/* Set all frame counters = 0 */
	/* If SD initialization has failed, we are going to start over anyway */
	SD_inst->SDstate.initFrameCount=0;
	SD_inst->SDstate.Mode0Ptr->FrameCount=0;
	SD_inst->SDstate.Mode1Ptr->FrameCount=0;
 
} /*end if TauEnergy.TauStdev > STOPPING_STDEV */

return(SD_enable);

} /* end initializeSD */
/************************************************************************************************/
/************************************************************************************************/
/*******                                     classify                                ************/
/************************************************************************************************/
/************************************************************************************************/
/*	Mark R. Walker
	Copyright Intel inc., 1995
	
	classify is called by Silence_Detect.  */
/************************************************************************************************/
/************************************************************************************************/

 int classify(float Energy_val,float Alpha1_val,float Zc_count,
		float energy_mean,float energy_stdev,float alpha1_mean,
		float alpha1_stdev,float ZC_mean,float ZC_stdev,int s, 
		float Energy_tx, float ZC_tx, INSTNCE *SD_inst)
{
float 	C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11;
int		Class;

/*	If all decision criteria below do not apply,
	just set current frame type to previous frame type */
Class = s;

C1 = (float)fabs(Energy_val - energy_mean);
C3 = (float)fabs(ZC_mean - Zc_count);
C5 = (float)fabs(alpha1_mean - Alpha1_val);

/* Note - Energy "on" threshold is unlike alpha and zero crossing */
C2 = SD_inst->SDstate.SDsettings.Energy_on + energy_stdev;
C10=							 Energy_tx + energy_stdev;

C4 = SD_inst->SDstate.SDsettings.ZC_on * ZC_stdev;
C11=							 ZC_tx * ZC_stdev;

C6 = SD_inst->SDstate.SDsettings.Alpha1_on * alpha1_stdev;

/* Note - Energy "off" threshold is unlike alpha and zero crossing */
C7 = SD_inst->SDstate.SDsettings.Energy_off + energy_stdev;
C8 = SD_inst->SDstate.SDsettings.ZC_off * ZC_stdev;
C9 = SD_inst->SDstate.SDsettings.Alpha1_off * alpha1_stdev;


if (s==SILENCE || s==NONADAPT) /* "Off" settings */
{
	/* Energy criteria for coded-frame designation.
	 * If energy indicator is above threshold, immediately
	 * switch from silent mode to coded frame mode. Do no additional tests
	 */
	if (C1 > C10)
	{ 
		Class = SPEECH;
	}
	/* Zero-crossing criteria for coded-frame designation.
	 * If ZC indicator is high, allow switch to coded
	 * frame mode only if alpha1 indicator is also high.
	 */
	else 
		if (C1 > C2)
		{ 
			Class = NONADAPT;
		}
		else 
			if ((C3 > C11) && (C5 > C6))
			{
				Class = SPEECH;
			}
			else 
				if ((C3 > C4)  && (C5 > C6))
				{
					Class = NONADAPT;
				}
}/* "On settings */

/* Only allow transition from coded to silent frame mode only if 
 * all three statistics are below threshold.
 */
else 
	if  ((C5 < C9) && (C1 < C7) && (C3 < C8))
	{
		Class = SILENCE;
	}

return(Class);

} /*end classify*/
/************************************************************************************************/
/************************************************************************************************/
/*******                                     update                                  ************/
/************************************************************************************************/
/************************************************************************************************/
/*	Mark R. Walker
	Copyright Intel inc., 1995*/
/************************************************************************************************/
/************************************************************************************************/
void update(float *hist_array,int hist_size,float *mean,float *stdev)
{
/*subroutine update
 *Mark Walker
 *
 *	inputs:		hist_array, hist_size
 *	outputs:	mean, stdev
 */
	float	sum, inv_size;
	int		i;

	sum = 0.0f;

	inv_size = 1.0f / ((float)hist_size);

	for (i=0; i<hist_size; i++) sum += hist_array[i];

	*mean = sum * inv_size;

	sum = 0.0f;

	for (i=0; i<hist_size; i++) sum += (float)fabs(hist_array[i] - (*mean));
  
	*stdev = sum * inv_size;

} /*end update*/



//compute the zero crossing for an array of floats
//the floats are treated as signed ints (32 bit)
//the sign bits are extracted and adjacent ones xored
//the xored values are accumulated in the result

int zeroCross(float x[], int n)
{
  int sgn0, sgn1;
  int zc = 0;
  int i = 0;

  sgn1 = ((int *)x)[0] >> 31; //initialize
  for (i = 0; i < n-1; i += 2)
  {
    sgn0 = ((int *)x)[i] >> 31;
    zc += sgn0 ^ sgn1;
    sgn1 = ((int *)x)[i+1] >> 31;
    zc += sgn0 ^ sgn1;
  }
  
  if (i == n-1) //odd case?
  {
    sgn0 = ((int *)x)[i] >> 31;
    zc += sgn0 ^ sgn1;
  }

  return -zc;
}

void prefilter(INSTNCE *SD_inst, float *sbuf, float *fbuf, int buffersize)
{
  float  *nBuffer, *dBuffer,*denom, *num;
  float  x,recip;
  int i;

  nBuffer = SD_inst->SDstate.Filt.nBuffer;
  dBuffer = SD_inst->SDstate.Filt.dBuffer;
  denom = SD_inst->SDstate.Filt.denom;
  num = SD_inst->SDstate.Filt.num;

  recip = (float)(1.0/MAX_SAMPLE);

  for (i=0; i<buffersize; i++)
  {
  	nBuffer[0] = nBuffer[1];
  	nBuffer[1] = nBuffer[2];
  	nBuffer[2] = nBuffer[3];
  	nBuffer[3] = sbuf[i]*recip;

  x = 	nBuffer[0]*HhpNumer[3] + 
  		nBuffer[1]*HhpNumer[2] + 
  		nBuffer[2]*HhpNumer[1] + 
  		nBuffer[3]*HhpNumer[0] +
  		dBuffer[0]*HhpDenom[2] + 
  		dBuffer[1]*HhpDenom[1] + 
  		dBuffer[2]*HhpDenom[0];

  dBuffer[0] = dBuffer[1];
  dBuffer[1] = dBuffer[2];
  dBuffer[2] = x;

/* a low pass filter to cut off input speech frequency contents
   beyond 3.5 kHz */

   //Update FIR memory
   	num[5] = num[4];
   	num[4] = num[3];
	num[3] = num[2];
	num[2] = num[1];
	num[1] = num[0];
	num[0] = x;
   
	x = num[0]*B[0] + 
		num[1]*B[1] + 
		num[2]*B[2] + 
		num[3]*B[3] + 
		num[4]*B[4] + 
		num[5]*B[5] +
		denom[0]*A[1] + 
		denom[1]*A[2] + 
		denom[2]*A[3] + 
		denom[3]*A[4] + 
		denom[4]*A[5];

	//Update IIR memory
	denom[4] = denom[3];
	denom[3] = denom[2];
	denom[2] = denom[1];
	denom[1] = denom[0];
	denom[0] = x;

   fbuf[i] = x;
  }

  return;

}

void execSDloop(INSTNCE *SD_inst, int *frameType, float sliderInput)
{ 
	float 	squelch, e0mean, e0stdev, e_on;
	float   Energy_tx, ZC_tx;
	int		m1count, maxcount, hangtime;
		
	//Slider input 
	    if(sliderInput > SLIDER_MAX) 
	    	sliderInput = SLIDER_MAX;
		else if(sliderInput < SLIDER_MIN) 
			sliderInput = SLIDER_MIN;   

		Energy_tx = INITL_ENERGY_ON + sliderInput;
		ZC_tx	  = INITL_ZC_ON     + ZC_SLOPE * sliderInput;
		hangtime  = INITL_HANGTIME  + (int)(HANG_SLOPE * sliderInput); 

    	if ( ! SD_inst->SDstate.SD_enable) //run the initializer until SD_enable is set
    	{
       		SD_inst->SDstate.SD_enable = initializeSD(SD_inst);
			*frameType = SPEECH;
			SD_inst->SDstate.Class = SPEECH;
    	} 
    	else if (SD_inst->SDstate.SD_enable ) 
    	{
      		*frameType = silenceDetect(SD_inst,Energy_tx,ZC_tx);

   	  		if(*frameType == SILENCE) 
   	  		{
				if(	   (SD_inst->SDstate.Mode0Ptr->FrameCount==0) 
					&& (SD_inst->SDstate.Mode1Ptr->FrameCount>MIN_SPEECH_INTERVAL)
					&& (SD_inst->SDstate.HangCntr != 0) )
				{
					SD_inst->SDstate.HangCntr--;
					*frameType = SPEECH;	//force this frame to be coded
				}
				else if (SD_inst->SDstate.HangCntr == hangtime  || SD_inst->SDstate.HangCntr == 0)
				{	
					SD_inst->SDstate.Mode0Ptr->FrameCount++;
			   		SD_inst->SDstate.Mode1Ptr->FrameCount=0;
			   		SD_inst->SDstate.HangCntr = hangtime;
				}
   	  		}
   	  		else
   	  		{
				if(SD_inst->SDstate.HangCntr != hangtime)
					SD_inst->SDstate.Mode1Ptr->FrameCount=0;

   	  			SD_inst->SDstate.Mode1Ptr->FrameCount++;
   				SD_inst->SDstate.Mode0Ptr->FrameCount=0;
				SD_inst->SDstate.HangCntr = hangtime;
   	  		}
   	  		/* 
   	  		If the adaptive threshold for switching from silence to coded frame ("Off") 
   	  		has risen above the squelch level, re-initialization will occur on the next frame.
   	  		Re-initialization will also occur when the Mode1FrameCount (continuous non-silent frame count)
   	    	exceeds 4 seconds. 
   	    	*/
      		squelch	= SD_inst->SDstate.SDsettings.Squelch_set;
	  		e0mean 	= SD_inst->SDstate.Mode0Ptr->Energy.Mean;
	  		e0stdev	= SD_inst->SDstate.Mode0Ptr->Energy.Stdev; 
	  		e_on	= SD_inst->SDstate.SDsettings.Energy_on;
	  		m1count	= SD_inst->SDstate.Mode1Ptr->FrameCount;
	  		maxcount= SD_inst->SDstate.SDsettings.MaxSpeechFrameCount;  

      		if ((fabs(e0mean - squelch) < (e_on + e0stdev)) || (m1count >= maxcount))
         	{	/* reinitialization will occur on next frame - reset global values now */
          		SD_inst->SDstate.SD_enable = FALSE;
          		SD_inst->SDstate.Mode0Ptr->FrameCount=0;
   		  		SD_inst->SDstate.Mode1Ptr->FrameCount=0;
   		  		SD_inst->SDstate.Mode0Ptr->Energy.Mean = squelch;
   		  		SD_inst->SDstate.Mode0Ptr->Energy.Stdev = (float) INITL_STDEV;
				SD_inst->SDstate.HangCntr = hangtime;
				*frameType = SPEECH;
         	}
      	}//end if SD_enable
		return;
}

float DotProdSD(float *in1, float *in2, int len)
{
  int i;
  float sum;

  sum = (float)0.0;
  for (i=0; i<len; i++)
    sum += in1[i]*in2[i];

  return(sum);
}

 __inline unsigned randBit()
{
    volatile static unsigned seed = 1;
    unsigned bit, temp;

    temp = seed;
    bit = 1 & ((temp) ^ (temp >> 2) ^ (temp >> 31));
    seed = (temp << 1) | bit;

	return( bit );
}

 extern __inline unsigned short getRand()
{
  return (short)(randBit() + (randBit()<<1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\opt.h ===
#define FILEIO  0

// Assembly switches for MMX code

#ifdef _X86_
#if !defined(COMPILE_MMX)
  #define COMPILE_MMX   1
#endif
#endif

#ifdef _ALPHA_
//No MMX on Alpha
#if defined(COMPILE_MMX)
  #undef COMPILE_MMX
#endif
#endif
#if COMPILE_MMX
  #define ASM_FTOSS   1
  #define ASM_CORR    1
  #define ASM_SVQ     1
  #define ASM_FACBK   1


#else
  #define ASM_FTOSS   0
  #define ASM_CORR    0
  #define ASM_SVQ     0
  #define ASM_FACBK   0

#endif

// These don't make a numerical difference (compared to model code)
// ...
#ifdef _X86_
#define OPT_PULSE4  1
#define OPT_FLOOR   1
#define OPT_ACBKF   1
#endif

// These are the tricks from FT

#define FT_FBFILT   1   // much faster Find_Best filter that exploits 0's
#define FT_FINDL    1   // faster Find_L with OccPos test removed

// These make a minor numerical difference (max diff = 1)

#ifdef _X86_
#define OPT_DOT 1      // assembly dot product
#define OPT_REV  1      // assembly reverse dot product
#define FIND_L_OPT 1
#endif

//These can't change for alpha
#ifdef _ALPHA_
#define OPT_DOT  0      // assembly dot product
#define OPT_REV  0      // assembly reverse dot product
#define FIND_L_OPT 0
#endif //Alpha
// Bits in "shortcut" flag

#define SC_FINDB 1    // only do 1 Find_Best per subframe
//#define SC_GAIN  2    // only search every other gain
#define SC_GAIN  0
#define SC_LAG1  4    // only search lag=1 in acbk gain search
#define SC_THRES 8    // use 75% of max instead of 50% for codebook threshold

#define SC_DEF (SC_LAG1 | SC_GAIN | SC_FINDB | SC_THRES)  // use all shortcuts

#define asint(x)   (*(int *)&(x))   // look as FP value as an int

#define ASM          __asm
#define QP           QWORD PTR
#define DP           DWORD PTR
#define WP           WORD PTR
#define fxch(n)      ASM fxch ST(n)

//no ';' at end of definition so that can be used as
//  DECLARE_CHAR(mybytes, 100);
//  DECLARE_SHORT(mywords, 32);
// ...
//  ALIGN_ARRAY(mybytes);
//  ALIGN_ARRAY(mywords);
#define DECLARE_CHAR(array,size)  \
  char array##_raw[size+8/sizeof(char)]; \
  char *array

#define DECLARE_SHORT(array,size)  \
  short array##_raw[size+8/sizeof(short)]; \
  short *array

#define DECLARE_INT(array,size)  \
  int array##_raw[size+8/sizeof(int)]; \
  int *array

#define ALIGN_ARRAY(array) \
  array = array##_raw; \
  __asm mov eax,array \
  __asm add eax,7 \
  __asm and eax,0fffffff8h \
  __asm mov array,eax

  #define ALIGN_SHORT_OFFSET(array,offset) \
  array = array##_raw; \
  __asm mov eax,array \
  __asm mov ebx,offset \
  __asm shl ebx,1 \
  __asm add eax, ebx \
  __asm add eax,7 \
  __asm and eax,0fffffff8h \
  __asm sub eax,ebx \
  __asm mov array,eax

#define DECLARE_STRUCTPTR(type,array)  \
  struct {type data; char dummy[8];} array##_raw; \
  type *array

#define ALIGN_STRUCTPTR(array) \
  array = &array##_raw.data; \
  __asm mov eax,array \
  __asm add eax,7 \
  __asm and eax,0fffffff8h \
  __asm mov array,eax
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\sdstuff.h ===
int  	initializeSD(INSTNCE *SD_inst);
 int 	silenceDetect(INSTNCE *SD_inst, float Energy_tx, float ZC_tx);
 void 	glblSDinitialize(INSTNCE *SD_inst);
 int 	classify(float Energy_val,float Alpha1val,float Zc_count,
			float energymean,float energystdev,float alpha1_mean,
			float alpha1stdev,float ZC_mean,float ZC_stdev,int s, 
			float Energy_tx, float ZC_tx, INSTNCE *SD_inst);
 void 	update(float *histarray,int histsize,float *mean,float *stdev);
 int 	zeroCross(float x[], int n);
#if PLOTFILE
	void getParams(INSTNCE *SD_inst, float *storebuff, int currBuffSize, float *p1, float *p2, float *p3);
#else
	void getParams(INSTNCE *SD_inst, float *storebuff, int currBuffSize);
#endif

 void 	prefilter(INSTNCE *SD_inst, float *sbuf, float *fbuf, int buffersize);
 void	execSDloop(INSTNCE *SD_inst, int *isFrameSilent, float bigthreshold);
 float  DotProdSD(float *in1, float *in2, int len);

 extern __inline unsigned short getRand(); 
 __inline unsigned randBit();



 
/* End SDSTUFF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\tab_lbc.c ===
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"

#define 	FLOAT float
#define    	F 	float


/*
**
**
** Description: Tables used for G.723 encoding and decoding
**  
** Tables:      HammingWindowTable[180]
**
**              LPC Computation and Filtering
**
**                  BinomialWindowTable[10]
**                  BandExpTable[10]
**
**              LSP calculation and quantization
**
**                  CosineTable[512]
**                  LspDcTable[10]
**                  BandInfoTable[3][2]
**                  Band0Tb8[256*3]
**                  Band1Tb8[256*3]
**                  Band2Tb8[256*4]
**                  BandQntTable[3]
**
**              Perceptual Filtering and Post Filtering
**
**
**                  PerFiltZeroTable[10]
**                  PerFiltPoleTable[10]
**                  PostFiltZeroTable[10]
**                  PostFiltPoleTable[10]
**                  LpfConstTable[2] (pitch postfilter)
**
**              ACELP or MP-MLQ
**
**                  Nb_puls[4] (MP-MLQ)
**                  FcbkGainTable[24] (ACELP and MP-MLQ)
**                  MaxPosTable[4]  (MP-MLQ), Word32
**                  CombinatorialTable[6][30](MP-MLQ),Word32
**                  epsi170[170] (ACELP)
**                  gain170[170] (ACELP)
**
**              Pitch Prediction
**
**                  AcbkGainTable085[85*20]
**                  AcbkGainTable170[170*20]
**                  AcbkGainTablePtr[2]
**
**              Taming procedure
**
**                  tabgain170[170]
**                  tabgain85[85]
**
**              All tables are Word16 unless separately denoted
*/

/*
**  HammingWindowTable:
**
**  Hamming Window coefficients.
**
*/


int minus1mod10[LpcOrder] = {9,0,1,2,3,4,5,6,7,8};


FLOAT   HammingWindowTable[LpcFrame] = {
  (F)0.080000,
  (F)0.080283,
  (F)0.081133,
  (F)0.082548,
  (F)0.084527,
  (F)0.087067,
  (F)0.090164,
  (F)0.093816,
  (F)0.098018,
  (F)0.102764,
  (F)0.108049,
  (F)0.113866,
  (F)0.120208,
  (F)0.127067,
  (F)0.134435,
  (F)0.142303,
  (F)0.150660,
  (F)0.159498,
  (F)0.168804,
  (F)0.178567,
  (F)0.188775,
  (F)0.199417,
  (F)0.210478,
  (F)0.221944,
  (F)0.233803,
  (F)0.246039,
  (F)0.258637,
  (F)0.271582,
  (F)0.284857,
  (F)0.298447,
  (F)0.312335,
  (F)0.326502,
  (F)0.340933,
  (F)0.355609,
  (F)0.370513,
  (F)0.385625,
  (F)0.400927,
  (F)0.416401,
  (F)0.432026,
  (F)0.447785,
  (F)0.463658,
  (F)0.479624,
  (F)0.495665,
  (F)0.511761,
  (F)0.527891,
  (F)0.544037,
  (F)0.560177,
  (F)0.576292,
  (F)0.592363,
  (F)0.608369,
  (F)0.624291,
  (F)0.640109,
  (F)0.655804,
  (F)0.671356,
  (F)0.686747,
  (F)0.701956,
  (F)0.716966,
  (F)0.731758,
  (F)0.746314,
  (F)0.760616,
  (F)0.774645,
  (F)0.788386,
  (F)0.801821,
  (F)0.814933,
  (F)0.827706,
  (F)0.840125,
  (F)0.852174,
  (F)0.863839,
  (F)0.875104,
  (F)0.885957,
  (F)0.896384,
  (F)0.906371,
  (F)0.915907,
  (F)0.924980,
  (F)0.933579,
  (F)0.941693,
  (F)0.949312,
  (F)0.956426,
  (F)0.963028,
  (F)0.969109,
  (F)0.974660,
  (F)0.979677,
  (F)0.984151,
  (F)0.988079,
  (F)0.991454,
  (F)0.994273,
  (F)0.996533,
  (F)0.998230,
  (F)0.999363,
  (F)0.999929,
  (F)0.999929,
  (F)0.999363,
  (F)0.998230,
  (F)0.996533,
  (F)0.994273,
  (F)0.991454,
  (F)0.988079,
  (F)0.984151,
  (F)0.979677,
  (F)0.974660,
  (F)0.969109,
  (F)0.963028,
  (F)0.956427,
  (F)0.949312,
  (F)0.941693,
  (F)0.933579,
  (F)0.924980,
  (F)0.915907,
  (F)0.906371,
  (F)0.896384,
  (F)0.885957,
  (F)0.875104,
  (F)0.863839,
  (F)0.852174,
  (F)0.840125,
  (F)0.827706,
  (F)0.814933,
  (F)0.801821,
  (F)0.788386,
  (F)0.774645,
  (F)0.760616,
  (F)0.746314,
  (F)0.731758,
  (F)0.716966,
  (F)0.701956,
  (F)0.686747,
  (F)0.671356,
  (F)0.655804,
  (F)0.640110,
  (F)0.624291,
  (F)0.608369,
  (F)0.592363,
  (F)0.576292,
  (F)0.560177,
  (F)0.544037,
  (F)0.527891,
  (F)0.511761,
  (F)0.495665,
  (F)0.479624,
  (F)0.463658,
  (F)0.447785,
  (F)0.432027,
  (F)0.416401,
  (F)0.400927,
  (F)0.385625,
  (F)0.370513,
  (F)0.355609,
  (F)0.340933,
  (F)0.326502,
  (F)0.312335,
  (F)0.298447,
  (F)0.284857,
  (F)0.271582,
  (F)0.258637,
  (F)0.246039,
  (F)0.233803,
  (F)0.221945,
  (F)0.210478,
  (F)0.199417,
  (F)0.188775,
  (F)0.178567,
  (F)0.168804,
  (F)0.159498,
  (F)0.150660,
  (F)0.142303,
  (F)0.134435,
  (F)0.127067,
  (F)0.120208,
  (F)0.113866,
  (F)0.108049,
  (F)0.102764,
  (F)0.098018,
  (F)0.093816,
  (F)0.090164,
  (F)0.087067,
  (F)0.084527,
  (F)0.082548,
  (F)0.081133,
  (F)0.080283,
  (F)0.080000 
 } ;


/*
**  BinomialWindowTable:
**
**  Purpose:
**     Binomial Window coefficients used to weight the autocorrelation before
**     Levinson-Durbin in the LPC coefficient calculation.  
**
**
*/

FLOAT BinomialWindowTable[LpcOrder+1] = {
  (F)1.0,
  (F)0.999443,
  (F)0.997775,
  (F)0.995002,
  (F)0.991132,
  (F)0.986178,
  (F)0.980157,
  (F)0.973088,
  (F)0.964995,
  (F)0.955905,
  (F)0.945847 
  } ;

/*
**  BandExpTable:
**
**  Purpose:
**      Do bandwidth expansion on the LPC coefficients by scaling the
**      poles of the LPC synthesis filter by a factor of 0.994

**
**  Table Structure:
**      Table values correspond to (0.994) to the power of x,
**      where x = [0,..,10].
**
*/

FLOAT BandExpTable[LpcOrder] = {
  (F)0.994 ,
  (F)0.988036 ,
  (F)0.9821078 ,
  (F)0.9762151 ,
  (F)0.9703578 ,
  (F)0.9645357 ,
  (F)0.9587485 ,
  (F)0.9529960 ,
  (F)0.9472780 ,
  (F)0.9415944 ,
};



/*
**  CosineTable:
**
**  Purpose:
**      Used to evaluate polynomial for LSP-LPC conversion
**
**  Table Structure:
**      Contains one period of a cosine wave.
**
*/

FLOAT CosineTable[CosineTableSize] = {
   (F)1 ,
   (F)0.999939 ,
   (F)0.999695 ,
   (F)0.999329 ,
   (F)0.998779 ,
   (F)0.998108 ,
   (F)0.997314 ,
   (F)0.996338 ,
   (F)0.995178 ,
   (F)0.993896 ,
   (F)0.992493 ,
   (F)0.990906 ,
   (F)0.989197 ,
   (F)0.987305 ,
   (F)0.985291 ,
   (F)0.983093 ,
   (F)0.980774 ,
   (F)0.978333 ,
   (F)0.975708 ,
   (F)0.972961 ,
   (F)0.970032 ,
   (F)0.96698 ,
   (F)0.963806 ,
   (F)0.960449 ,
   (F)0.95697 ,
   (F)0.953308 ,
   (F)0.949524 ,
   (F)0.945618 ,
   (F)0.941528 ,
   (F)0.937317 ,
   (F)0.932983 ,
   (F)0.928528 ,
   (F)0.923889 ,
   (F)0.919128 ,
   (F)0.914185 ,
   (F)0.90918 ,
   (F)0.903992 ,
   (F)0.898682 ,
   (F)0.89325 ,
   (F)0.887634 ,
   (F)0.881897 ,
   (F)0.876099 ,
   (F)0.870117 ,
   (F)0.863953 ,
   (F)0.857727 ,
   (F)0.851379 ,
   (F)0.844849 ,
   (F)0.838196 ,
   (F)0.831482 ,
   (F)0.824585 ,
   (F)0.817566 ,
   (F)0.810486 ,
   (F)0.803223 ,
   (F)0.795837 ,
   (F)0.78833 ,
   (F)0.780762 ,
   (F)0.77301 ,
   (F)0.765198 ,
   (F)0.757202 ,
   (F)0.749146 ,
   (F)0.740967 ,
   (F)0.732666 ,
   (F)0.724243 ,
   (F)0.715759 ,
   (F)0.707092 ,
   (F)0.698364 ,
   (F)0.689514 ,
   (F)0.680603 ,
   (F)0.67157 ,
   (F)0.662415 ,
   (F)0.653198 ,
   (F)0.64386 ,
   (F)0.634399 ,
   (F)0.624878 ,
   (F)0.615234 ,
   (F)0.60553 ,
   (F)0.595703 ,
   (F)0.585815 ,
   (F)0.575806 ,
   (F)0.565735 ,
   (F)0.555542 ,
   (F)0.545349 ,
   (F)0.534973 ,
   (F)0.524597 ,
   (F)0.514099 ,
   (F)0.50354 ,
   (F)0.49292 ,
   (F)0.482178 ,
   (F)0.471375 ,
   (F)0.46051 ,
   (F)0.449585 ,
   (F)0.438599 ,
   (F)0.427551 ,
   (F)0.416443 ,
   (F)0.405212 ,
   (F)0.393982 ,
   (F)0.38269 ,
   (F)0.371338 ,
   (F)0.359924 ,
   (F)0.348389 ,
   (F)0.336914 ,
   (F)0.325317 ,
   (F)0.31366 ,
   (F)0.302002 ,
   (F)0.290283 ,
   (F)0.278503 ,
   (F)0.266724 ,
   (F)0.254883 ,
   (F)0.242981 ,
   (F)0.231079 ,
   (F)0.219116 ,
   (F)0.207092 ,
   (F)0.195068 ,
   (F)0.183044 ,
   (F)0.170959 ,
   (F)0.158875 ,
   (F)0.146729 ,
   (F)0.134583 ,
   (F)0.122437 ,
   (F)0.110229 ,
   (F)0.0980225 ,
   (F)0.0858154 ,
   (F)0.0735474 ,
   (F)0.0613403 ,
   (F)0.0490723 ,
   (F)0.0368042 ,
   (F)0.0245361 ,
   (F)0.0122681 ,
   (F)0 ,
   (F)-0.0122681 ,
   (F)-0.0245361 ,
   (F)-0.0368042 ,
   (F)-0.0490723 ,
   (F)-0.0613403 ,
   (F)-0.0735474 ,
   (F)-0.0858154 ,
   (F)-0.0980225 ,
   (F)-0.110229 ,
   (F)-0.122437 ,
   (F)-0.134583 ,
   (F)-0.146729 ,
   (F)-0.158875 ,
   (F)-0.170959 ,
   (F)-0.183044 ,
   (F)-0.195068 ,
   (F)-0.207092 ,
   (F)-0.219116 ,
   (F)-0.231079 ,
   (F)-0.242981 ,
   (F)-0.254883 ,
   (F)-0.266724 ,
   (F)-0.278503 ,
   (F)-0.290283 ,
   (F)-0.302002 ,
   (F)-0.31366 ,
   (F)-0.325317 ,
   (F)-0.336914 ,
   (F)-0.348389 ,
   (F)-0.359924 ,
   (F)-0.371338 ,
   (F)-0.38269 ,
   (F)-0.393982 ,
   (F)-0.405212 ,
   (F)-0.416443 ,
   (F)-0.427551 ,
   (F)-0.438599 ,
   (F)-0.449585 ,
   (F)-0.46051 ,
   (F)-0.471375 ,
   (F)-0.482178 ,
   (F)-0.49292 ,
   (F)-0.50354 ,
   (F)-0.514099 ,
   (F)-0.524597 ,
   (F)-0.534973 ,
   (F)-0.545349 ,
   (F)-0.555542 ,
   (F)-0.565735 ,
   (F)-0.575806 ,
   (F)-0.585815 ,
   (F)-0.595703 ,
   (F)-0.60553 ,
   (F)-0.615234 ,
   (F)-0.624878 ,
   (F)-0.634399 ,
   (F)-0.64386 ,
   (F)-0.653198 ,
   (F)-0.662415 ,
   (F)-0.67157 ,
   (F)-0.680603 ,
   (F)-0.689514 ,
   (F)-0.698364 ,
   (F)-0.707092 ,
   (F)-0.715759 ,
   (F)-0.724243 ,
   (F)-0.732666 ,
   (F)-0.740967 ,
   (F)-0.749146 ,
   (F)-0.757202 ,
   (F)-0.765198 ,
   (F)-0.77301 ,
   (F)-0.780762 ,
   (F)-0.78833 ,
   (F)-0.795837 ,
   (F)-0.803223 ,
   (F)-0.810486 ,
   (F)-0.817566 ,
   (F)-0.824585 ,
   (F)-0.831482 ,
   (F)-0.838196 ,
   (F)-0.844849 ,
   (F)-0.851379 ,
   (F)-0.857727 ,
   (F)-0.863953 ,
   (F)-0.870117 ,
   (F)-0.876099 ,
   (F)-0.881897 ,
   (F)-0.887634 ,
   (F)-0.89325 ,
   (F)-0.898682 ,
   (F)-0.903992 ,
   (F)-0.90918 ,
   (F)-0.914185 ,
   (F)-0.919128 ,
   (F)-0.923889 ,
   (F)-0.928528 ,
   (F)-0.932983 ,
   (F)-0.937317 ,
   (F)-0.941528 ,
   (F)-0.945618 ,
   (F)-0.949524 ,
   (F)-0.953308 ,
   (F)-0.95697 ,
   (F)-0.960449 ,
   (F)-0.963806 ,
   (F)-0.96698 ,
   (F)-0.970032 ,
   (F)-0.972961 ,
   (F)-0.975708 ,
   (F)-0.978333 ,
   (F)-0.980774 ,
   (F)-0.983093 ,
   (F)-0.985291 ,
   (F)-0.987305 ,
   (F)-0.989197 ,
   (F)-0.990906 ,
   (F)-0.992493 ,
   (F)-0.993896 ,
   (F)-0.995178 ,
   (F)-0.996338 ,
   (F)-0.997314 ,
   (F)-0.998108 ,
   (F)-0.998779 ,
   (F)-0.999329 ,
   (F)-0.999695 ,
   (F)-0.999939 ,
   (F)-1 ,
   (F)-0.999939 ,
   (F)-0.999695 ,
   (F)-0.999329 ,
   (F)-0.998779 ,
   (F)-0.998108 ,
   (F)-0.997314 ,
   (F)-0.996338 ,
   (F)-0.995178 ,
   (F)-0.993896 ,
   (F)-0.992493 ,
   (F)-0.990906 ,
   (F)-0.989197 ,
   (F)-0.987305 ,
   (F)-0.985291 ,
   (F)-0.983093 ,
   (F)-0.980774 ,
   (F)-0.978333 ,
   (F)-0.975708 ,
   (F)-0.972961 ,
   (F)-0.970032 ,
   (F)-0.96698 ,
   (F)-0.963806 ,
   (F)-0.960449 ,
   (F)-0.95697 ,
   (F)-0.953308 ,
   (F)-0.949524 ,
   (F)-0.945618 ,
   (F)-0.941528 ,
   (F)-0.937317 ,
   (F)-0.932983 ,
   (F)-0.928528 ,
   (F)-0.923889 ,
   (F)-0.919128 ,
   (F)-0.914185 ,
   (F)-0.90918 ,
   (F)-0.903992 ,
   (F)-0.898682 ,
   (F)-0.89325 ,
   (F)-0.887634 ,
   (F)-0.881897 ,
   (F)-0.876099 ,
   (F)-0.870117 ,
   (F)-0.863953 ,
   (F)-0.857727 ,
   (F)-0.851379 ,
   (F)-0.844849 ,
   (F)-0.838196 ,
   (F)-0.831482 ,
   (F)-0.824585 ,
   (F)-0.817566 ,
   (F)-0.810486 ,
   (F)-0.803223 ,
   (F)-0.795837 ,
   (F)-0.78833 ,
   (F)-0.780762 ,
   (F)-0.77301 ,
   (F)-0.765198 ,
   (F)-0.757202 ,
   (F)-0.749146 ,
   (F)-0.740967 ,
   (F)-0.732666 ,
   (F)-0.724243 ,
   (F)-0.715759 ,
   (F)-0.707092 ,
   (F)-0.698364 ,
   (F)-0.689514 ,
   (F)-0.680603 ,
   (F)-0.67157 ,
   (F)-0.662415 ,
   (F)-0.653198 ,
   (F)-0.64386 ,
   (F)-0.634399 ,
   (F)-0.624878 ,
   (F)-0.615234 ,
   (F)-0.60553 ,
   (F)-0.595703 ,
   (F)-0.585815 ,
   (F)-0.575806 ,
   (F)-0.565735 ,
   (F)-0.555542 ,
   (F)-0.545349 ,
   (F)-0.534973 ,
   (F)-0.524597 ,
   (F)-0.514099 ,
   (F)-0.50354 ,
   (F)-0.49292 ,
   (F)-0.482178 ,
   (F)-0.471375 ,
   (F)-0.46051 ,
   (F)-0.449585 ,
   (F)-0.438599 ,
   (F)-0.427551 ,
   (F)-0.416443 ,
   (F)-0.405212 ,
   (F)-0.393982 ,
   (F)-0.38269 ,
   (F)-0.371338 ,
   (F)-0.359924 ,
   (F)-0.348389 ,
   (F)-0.336914 ,
   (F)-0.325317 ,
   (F)-0.31366 ,
   (F)-0.302002 ,
   (F)-0.290283 ,
   (F)-0.278503 ,
   (F)-0.266724 ,
   (F)-0.254883 ,
   (F)-0.242981 ,
   (F)-0.231079 ,
   (F)-0.219116 ,
   (F)-0.207092 ,
   (F)-0.195068 ,
   (F)-0.183044 ,
   (F)-0.170959 ,
   (F)-0.158875 ,
   (F)-0.146729 ,
   (F)-0.134583 ,
   (F)-0.122437 ,
   (F)-0.110229 ,
   (F)-0.0980225 ,
   (F)-0.0858154 ,
   (F)-0.0735474 ,
   (F)-0.0613403 ,
   (F)-0.0490723 ,
   (F)-0.0368042 ,
   (F)-0.0245361 ,
   (F)-0.0122681 ,
   (F)0 ,
   (F)0.0122681 ,
   (F)0.0245361 ,
   (F)0.0368042 ,
   (F)0.0490723 ,
   (F)0.0613403 ,
   (F)0.0735474 ,
   (F)0.0858154 ,
   (F)0.0980225 ,
   (F)0.110229 ,
   (F)0.122437 ,
   (F)0.134583 ,
   (F)0.146729 ,
   (F)0.158875 ,
   (F)0.170959 ,
   (F)0.183044 ,
   (F)0.195068 ,
   (F)0.207092 ,
   (F)0.219116 ,
   (F)0.231079 ,
   (F)0.242981 ,
   (F)0.254883 ,
   (F)0.266724 ,
   (F)0.278503 ,
   (F)0.290283 ,
   (F)0.302002 ,
   (F)0.31366 ,
   (F)0.325317 ,
   (F)0.336914 ,
   (F)0.348389 ,
   (F)0.359924 ,
   (F)0.371338 ,
   (F)0.38269 ,
   (F)0.393982 ,
   (F)0.405212 ,
   (F)0.416443 ,
   (F)0.427551 ,
   (F)0.438599 ,
   (F)0.449585 ,
   (F)0.46051 ,
   (F)0.471375 ,
   (F)0.482178 ,
   (F)0.49292 ,
   (F)0.50354 ,
   (F)0.514099 ,
   (F)0.524597 ,
   (F)0.534973 ,
   (F)0.545349 ,
   (F)0.555542 ,
   (F)0.565735 ,
   (F)0.575806 ,
   (F)0.585815 ,
   (F)0.595703 ,
   (F)0.60553 ,
   (F)0.615234 ,
   (F)0.624878 ,
   (F)0.634399 ,
   (F)0.64386 ,
   (F)0.653198 ,
   (F)0.662415 ,
   (F)0.67157 ,
   (F)0.680603 ,
   (F)0.689514 ,
   (F)0.698364 ,
   (F)0.707092 ,
   (F)0.715759 ,
   (F)0.724243 ,
   (F)0.732666 ,
   (F)0.740967 ,
   (F)0.749146 ,
   (F)0.757202 ,
   (F)0.765198 ,
   (F)0.77301 ,
   (F)0.780762 ,
   (F)0.78833 ,
   (F)0.795837 ,
   (F)0.803223 ,
   (F)0.810486 ,
   (F)0.817566 ,
   (F)0.824585 ,
   (F)0.831482 ,
   (F)0.838196 ,
   (F)0.844849 ,
   (F)0.851379 ,
   (F)0.857727 ,
   (F)0.863953 ,
   (F)0.870117 ,
   (F)0.876099 ,
   (F)0.881897 ,
   (F)0.887634 ,
   (F)0.89325 ,
   (F)0.898682 ,
   (F)0.903992 ,
   (F)0.90918 ,
   (F)0.914185 ,
   (F)0.919128 ,
   (F)0.923889 ,
   (F)0.928528 ,
   (F)0.932983 ,
   (F)0.937317 ,
   (F)0.941528 ,
   (F)0.945618 ,
   (F)0.949524 ,
   (F)0.953308 ,
   (F)0.95697 ,
   (F)0.960449 ,
   (F)0.963806 ,
   (F)0.96698 ,
   (F)0.970032 ,
   (F)0.972961 ,
   (F)0.975708 ,
   (F)0.978333 ,
   (F)0.980774 ,
   (F)0.983093 ,
   (F)0.985291 ,
   (F)0.987305 ,
   (F)0.989197 ,
   (F)0.990906 ,
   (F)0.992493 ,
   (F)0.993896 ,
   (F)0.995178 ,
   (F)0.996338 ,
   (F)0.997314 ,
   (F)0.998108 ,
   (F)0.998779 ,
   (F)0.999329 ,
   (F)0.999695 ,
   (F)0.999939
};

/*
**  LspDcTable: LSP long term Dc component
**
*/

FLOAT LspDcTable[LpcOrder] = {
   (F)24.4609,
   (F)36.8828,
   (F)60.0781,
   (F)84.4219,
   (F)108.375,
   (F)128.867,
   (F)154.312,
   (F)173.906,
   (F)199.094,
   (F)216.547,
};

int BandInfoTable[LspQntBands][2] = {
/*
**  BandInfoTable:
**
**  Purpose:
**      Used to index in arrays. Called by LSP sub vector 
**      quantization routines.
**
**  Table Structure:
**      The unquantized LSP vector, quantized LSP vector, and residual
**      LSP error vector are each divided into three subvectors.  
**              The table format is as follows:
**
**      1st pair corresponds to subvector 0
**      2nd pair corresponds to subvector 1
**      3rd pair corresponds to subvector 2
**
**      The 1st slot in each pair is used to index the location of 
**      the vector in a 10-element array.  For example, for subvector
**      1, dimensions [0,..,2] get automatically mapped to array
**      location [3,..,5], and for subvector 3, dimensions
**      [0,..,3] automatically get mapped to array location [6,..,9].
**
**      The 2nd slot in each pair corresponds to the dimension of
**      the subvector
*/

   { 0,3},
   { 3,3},
   { 6,4}
   };

/*
**  Band0Tb8:
**
**  Purpose:
**      Vector Quantize the first 3-vector of the 10 LSP parameters.
**
**  Table Structure:
**      8 bit, 256 entry table.
*/

FLOAT Band0Tb8[LspCbSize*3] = {
	(F)0,  (F)0,  (F)0,
	(F)-2.10938,  (F)-10.7188,  (F)-8.0625,
	(F)-4.22656,  (F)-12.8906,  (F)-10.7969,
	(F)-5.64844,  (F)-15.7109,  (F)-17.2891,
	(F)-7.35156,  (F)-8.76562,  (F)-15.1719,
	(F)-6.09375,  (F)-8.94531,  (F)-19.1719,
	(F)-6.90625,  (F)-10.2266,  (F)-10.7266,
	(F)-8.21094,  (F)-11.8984,  (F)-13.7969,
	(F)-8.46094,  (F)-12.6719,  (F)-17.9688,
	(F)-6.07031,  (F)-10.7578,  (F)-16.7734,
	(F)-7.30469,  (F)-11.4609,  (F)-21.5859,
	(F)-6.26562,  (F)-10.3672,  (F)-27.1172,
	(F)-7.30469,  (F)-15.3047,  (F)-31.2422,
	(F)-1.875,  (F)-0.695312,  (F)1.73438,
	(F)-5.16406,  (F)-2.00781,  (F)-1.25,
	(F)-7.76562,  (F)-3.64062,  (F)-3.27344,
	(F)-1.46875,  (F)-1.28125,  (F)-2.17188,
	(F)-2.67188,  (F)-4,  (F)-3.24219,
	(F)-4.74219,  (F)-3.99219,  (F)-6.22656,
	(F) 0.125,  (F)0.148438,  (F)-5.59375,
	(F) 2.92188,  (F)3.32031,  (F)-7.59375,
	(F)-2.70312,  (F)1.91406,  (F)-2.20312,
	(F)-2.07031,  (F)3.95312,  (F)-5.89062,
	(F)-4.84375,  (F)-1.14844,  (F)15.2734,
	(F)-5.79688,  (F)-6.71875,  (F)20.2891,
	(F)-1.17188,  (F)-2.75,  (F)21.125,
	(F) 2.38281,  (F)6.875,  (F)15.2656,
	(F) 0.960938,  (F)5.71094,  (F)21.6094,
	(F)-2.71875,  (F)5.97656,  (F)25.9922,
	(F) 4.82812,  (F)1.72656,  (F)25.4531,
	(F)-1.39062,  (F)-0.367188,  (F)32.9609,
	(F) 3.07031,  (F)10.1875,  (F)30.0156,
	(F) 5.45312,  (F)13.2969,  (F)37.5078,
	(F) 0.492188,  (F)-4.5625,  (F)9.60156,
	(F)-1.67969,  (F)-5.71875,  (F)13.3125,
	(F) 1.34375,  (F)-2.61719,  (F)14.9141,
	(F)-0.015625,  (F)1.6875,  (F)14.0391,
	(F) 2.75781,  (F)0.992188,  (F)17.2266,
	(F)-9.4375,  (F)1.46875,  (F)0.0859375,
	(F)-4.00781,  (F)-0.585938,  (F)-5.33594,
	(F)-7.60156,  (F)1.73438,  (F)-5.04688,
	(F)-4.8125,  (F)-6.58594,  (F)-3.03125,
	(F)-7.42188,  (F)-8.69531,  (F)-2.80469,
	(F)-11.1797,  (F)-4.86719,  (F)-5.50781,
	(F)-10.9219,  (F)-8.30469,  (F)-1.39062,
	(F)-0.351562,  (F)-3.60156,  (F)0.273438,
	(F)-0.0703125,  (F)-5.13281,  (F)-1.6875,
	(F) 0.992188,  (F)-8.42188,  (F)0.742188,
	(F)-7.42188,  (F)-9.03125,  (F)4.5625,
	(F)-11.5625,  (F)-11.6719,  (F)3.50781,
	(F)-0.9375,  (F)-5.50781,  (F)4.03125,
	(F)-2.875,  (F)-7.50781,  (F)5.67969,
	(F)-2.95312,  (F)-4.10938,  (F)7.60156,
	(F)-6.19531,  (F)-4.79688,  (F)5.28125,
	(F)-6.25781,  (F)-5.89844,  (F)10.0547,
	(F)-11.5312,  (F)-2.65625,  (F)12.7812,
	(F)-3.94531,  (F)-9.79688,  (F)12.0547,
	(F)-9.71094,  (F)-12.6719,  (F)11.9688,
	(F)-6.0625,  (F)-11.5391,  (F)-5.11719,
	(F)-8.99219,  (F)-10.125,  (F)-6.42969,
	(F)-9.00781,  (F)-13.0625,  (F)-8.78125,
	(F)-10.0859,  (F)-15.6484,  (F)-13.2969,
	(F)-4.85938,  (F)-10.0234,  (F)0.445312,
	(F)-3.67969,  (F)-12.5859,  (F)3.97656,
	(F)-8.28125,  (F)-12.2656,  (F)-1.08594,
	(F)-6.82031,  (F)-16.8438,  (F)-4.1875,
	(F)-13.4062,  (F)-15.7891,  (F)-2.84375,
	(F)-16.7969,  (F)-25.1406,  (F)-10.0859,
	(F)-9.75,  (F)-15.1953,  (F)-22.6875,
	(F)-9.49219,  (F)-20.5703,  (F)-22.3047,
	(F) 1.30469,  (F)-1.90625,  (F)0.65625,
	(F) 2.72656,  (F)-3.21875,  (F)-1.69531,
	(F)-0.3125,  (F)-2.75,  (F)4.9375,
	(F) 1.77344,  (F)-4.13281,  (F)3.16406,
	(F) 0.53125,  (F)-2.99219,  (F)-3.46094,
	(F) 1.30469,  (F)-4.35938,  (F)-5.51562,
	(F)-2.14844,  (F)-6.67188,  (F)-0.109375,
	(F)-2.74219,  (F)-8.50781,  (F)-3.50781,
	(F) 2.66406,  (F)-0.5625,  (F)-2.25781,
	(F) 4.71094,  (F)-0.828125,  (F)-3.70312,
	(F) 2.51562,  (F)-1.71094,  (F)-5.07031,
	(F) 1.39844,  (F)-2.47656,  (F)-7.79688,
	(F) 3.51562,  (F)-2.27344,  (F)-7.78125,
	(F) 4.33594,  (F)1.52344,  (F)-4.10156,
	(F) 6.125,  (F)2.125,  (F)-6.49219,
	(F)-1.15625,  (F)-3,  (F)-6.63281,
	(F) 0.640625,  (F)-4.1875,  (F)-10.6016,
	(F) 1.85938,  (F)-1.34375,  (F)-10.5781,
	(F) 3.29688,  (F)-2.09375,  (F)-14.3828,
	(F) 2.32031,  (F)-5.75781,  (F)-16.2422,
	(F)-0.867188,  (F)-6.25781,  (F)-4.67188,
	(F) 0.0078125,  (F)-5.21875,  (F)-7.6875,
	(F)-1.02344,  (F)-6.39062,  (F)-10.1484,
	(F)-2.57031,  (F)-4.07031,  (F)-10.2344,
	(F)-1.17969,  (F)-6.07812,  (F)-14.3281,
	(F)-0.726562,  (F)-2.75,  (F)-13.6406,
	(F)-4.4375,  (F)-5,  (F)-14.2266,
	(F)-3.97656,  (F)-7.35156,  (F)-17.0547,
	(F) 3.625,  (F)-6.36719,  (F)-9.76562,
	(F) 0.617188,  (F)-8.85156,  (F)-12.4766,
	(F)-1.4375,  (F)-10.5703,  (F)-16.5859,
	(F)-1.53125,  (F)-3.20312,  (F)-18.9609,
	(F)-1.5,  (F)-6.50781,  (F)-21.9531,
	(F)-2.02344,  (F)-10.7969,  (F)-23.7891,
	(F)-1.69531,  (F)0.03125,  (F)-9.10938,
	(F)-6.25,  (F)-2.53906,  (F)-9.52344,
	(F)-2.83594,  (F)-6.48438,  (F)-7.01562,
	(F)-5.16406,  (F)-8.85938,  (F)-7.5,
	(F)-3.01562,  (F)-7.65625,  (F)-11.7266,
	(F)-4.89844,  (F)-9.05469,  (F)-13.4531,
	(F)-7.05469,  (F)-6.47656,  (F)-6.67969,
	(F)-5.35156,  (F)-6.47656,  (F)-10.2578,
	(F)-8.32031,  (F)-7.49219,  (F)-10.9766,
	(F) 3.44531,  (F)0.195312,  (F)-6.61719,
	(F) 5.11719,  (F)-0.210938,  (F)-9.22656,
	(F) 9.05469,  (F)-0.859375,  (F)-5.50781,
	(F) 6.6875,  (F)1.97656,  (F)-13.0547,
	(F) 3.24219,  (F)3.15625,  (F)-0.0078125,
	(F) 2.51562,  (F)7.05469,  (F)-3.10938,
	(F) 5.23438,  (F)3.89844,  (F)-2.28125,
	(F) 6.27344,  (F)4.61719,  (F)-4.76562,
	(F) 8.9375,  (F)4.61719,  (F)-6.35938,
	(F) 5.60156,  (F)1.42969,  (F)3.07031,
	(F) 6.69531,  (F)2.97656,  (F)0.828125,
	(F) 4.75781,  (F)0.484375,  (F)-0.210938,
	(F) 6.1875,  (F)1.54688,  (F)-2.53906,
	(F) 5.74219,  (F)6.28906,  (F)0.6875,
	(F) 8.92188,  (F)6.34375,  (F)0.609375,
	(F) 8.03125,  (F)2.85938,  (F)-2.28125,
	(F) 10.2266,  (F)5.80469,  (F)-1.85156,
	(F) 12.6172,  (F)4.60156,  (F)-0.617188,
	(F) 7.89062,  (F)4.99219,  (F)-1.89844,
	(F) 7.80469,  (F)7.53125,  (F)-2.42969,
	(F) 11.7188,  (F)8.88281,  (F)-4.80469,
	(F) 7.71875,  (F)2.78906,  (F)5.04688,
	(F) 9.58594,  (F)5.21094,  (F)5.33594,
	(F) 9.09375,  (F)12.2266,  (F)6.98438,
	(F) 10.875,  (F)15.7422,  (F)3.72656,
	(F) 8.89062,  (F)4.16406,  (F)1.95312,
	(F) 11.2266,  (F)7,  (F)3.05469,
	(F) 13.7891,  (F)8.73438,  (F)0.773438,
	(F) 8.6875,  (F)8.51562,  (F)6.26562,
	(F) 12.4688,  (F)6.60938,  (F)8.85938,
	(F) 7.32031,  (F)9.07031,  (F)2.17969,
	(F) 13.4297,  (F)9.79688,  (F)5.33594,
	(F) 10.4531,  (F)8.48438,  (F)0.273438,
	(F) 11.0859,  (F)10.3438,  (F)3.34375,
	(F) 11.1562,  (F)11.9062,  (F)0.3125,
	(F) 16.4688,  (F)12.4531,  (F)0.695312,
	(F) 7.92969,  (F)4.25,  (F)9.54688,
	(F) 8.75781,  (F)7.22656,  (F)9.86719,
	(F) 8.04688,  (F)10.2969,  (F)11.6016,
	(F) 10.1172,  (F)6.16406,  (F)14.1953,
	(F) 10.3359,  (F)9.9375,  (F)14.9141,
	(F) 13.4688,  (F)9.66406,  (F)14.0859,
	(F) 14.0391,  (F)13.1953,  (F)6.70312,
	(F) 16.7891,  (F)10.6797,  (F)10.1641,
	(F) 17.9844,  (F)14.5859,  (F)5.94531,
	(F) 22.3672,  (F)18.3672,  (F)8.22656,
	(F) 0.40625,  (F)1.27344,  (F)-0.59375,
	(F) 1.79688,  (F)2.41406,  (F)-3.84375,
	(F)-0.554688,  (F)4.83594,  (F)0.304688,
	(F)-1.70312,  (F)6.6875,  (F)3.89844,
	(F)-5.10938,  (F)5.75,  (F)-1.61719,
	(F)-4.17969,  (F)9.83594,  (F)1.21094,
	(F)-3.75,  (F)11.5312,  (F)5.02344,
	(F) 2.04688,  (F)8.44531,  (F)0.796875,
	(F) 2.41406,  (F)12.4375,  (F)-1.42188,
	(F) 4.89844,  (F)12.7266,  (F)4.17188,
	(F) 2.63281,  (F)5.02344,  (F)3.5625,
	(F) 5.92188,  (F)5.23438,  (F)5.57031,
	(F) 1.57812,  (F)8.79688,  (F)5.14062,
	(F) 4.78125,  (F)8.83594,  (F)5.20312,
	(F) 5.35938,  (F)9.55469,  (F)8.875,
	(F)-1.02344,  (F)2.94531,  (F)4.10156,
	(F) 0.328125,  (F)5.53125,  (F)7.08594,
	(F) 0.679688,  (F)11.625,  (F)8.08594,
	(F) 3.375,  (F)16.5391,  (F)7.0625,
	(F) 1.07031,  (F)7.66406,  (F)10.4062,
	(F)-3.49219,  (F)7.92188,  (F)8.875,
	(F)-6.55469,  (F)14.0078,  (F)9.73438,
	(F)-4.36719,  (F)2.32031,  (F)1.54688,
	(F)-6.64062,  (F)5.35156,  (F)3.48438,
	(F)-9.94531,  (F)4.9375,  (F)6.45312,
	(F)-3.13281,  (F)-4.25,  (F)1.35156,
	(F)-5.88281,  (F)-6.19531,  (F)1.125,
	(F)-3.40625,  (F)-0.0703125,  (F)6.03125,
	(F)-0.898438,  (F)-1.89844,  (F)10.2344,
	(F)-5.23438,  (F)-2.10156,  (F)2.92188,
	(F)-8.02344,  (F)-0.101562,  (F)4.99219,
	(F)-6.92969,  (F)-0.632812,  (F)8.88281,
	(F)-9.97656,  (F)-3.55469,  (F)1.23438,
	(F)-11.0234,  (F)-5.625,  (F)5.75,
	(F) 1.34375,  (F)0.6875,  (F)3.14844,
	(F) 3.01562,  (F)1.99219,  (F)5.90625,
	(F)-3.90625,  (F)4.07812,  (F)7.10938,
	(F)-7.48438,  (F)5.14844,  (F)10.8438,
	(F)-3.08594,  (F)2.35156,  (F)10.5,
	(F)-2.78125,  (F)6,  (F)14.1641,
	(F)-4.78906,  (F)6.57031,  (F)18.8984,
	(F) 3.47656,  (F)-0.953125,  (F)1.96875,
	(F) 4.91406,  (F)-0.679688,  (F)5.64844,
	(F) 2.21094,  (F)-1.97656,  (F)6.79688,
	(F) 3.5625,  (F)-0.90625,  (F)10.7891,
	(F) 5.91406,  (F)1.40625,  (F)8.27344,
	(F) 4.15625,  (F)3.1875,  (F)11.7891,
	(F) 7.39844,  (F)2.25,  (F)14.1094,
	(F) 10.3516,  (F)7.76562,  (F)19.7188,
	(F) 6.96875,  (F)9.52344,  (F)23.6172,
	(F) 10.9141,  (F)12.4688,  (F)26.6094,
	(F) 8.92969,  (F)12.125,  (F)19.8906,
	(F) 14.4531,  (F)11.1953,  (F)21.1719,
	(F)-0.078125,  (F)1.04688,  (F)7.82812,
	(F) 1.20312,  (F)3.89844,  (F)10.3359,
	(F) 3.96875,  (F)6.1875,  (F)8.72656,
	(F) 3.97656,  (F)10.4688,  (F)12.625,
	(F) 5.95312,  (F)6.73438,  (F)12.5625,
	(F) 6.14844,  (F)5.78125,  (F)18.125,
	(F) 6.20312,  (F)13.4922,  (F)10.0234,
	(F) 3.63281,  (F)16.4688,  (F)12.9688,
	(F)-0.9375,  (F)11.3359,  (F)12.6016,
	(F)-3.01562,  (F)15.75,  (F)16.9453,
	(F) 6.96094,  (F)9.57031,  (F)16.0156,
	(F) 3.5625,  (F)11.5625,  (F)17.0703,
	(F) 11.6641,  (F)10.0234,  (F)9.44531,
	(F) 10.9141,  (F)12.7812,  (F)11.8594,
	(F) 13.875,  (F)13.5781,  (F)12.125,
	(F) 12.2812,  (F)13.2656,  (F)16.7266,
	(F) 10.8516,  (F)16.6094,  (F)9.92969,
	(F) 15.3047,  (F)18.8516,  (F)8.74219,
	(F) 10.6641,  (F)22.5938,  (F)11.7578,
	(F) 17.2344,  (F)15.3984,  (F)12.6797,
	(F) 16.2188,  (F)15.2344,  (F)17.8125,
	(F) 13.4141,  (F)17.8984,  (F)14.5859,
	(F) 18.4844,  (F)19.6484,  (F)15.2578,
	(F) 22.3828,  (F)22.1719,  (F)19.7031,
	(F) 19.8047,  (F)27.0703,  (F)15.7109,
	(F) 26.4141,  (F)32.2422,  (F)20.6094,
	(F) 6.53125,  (F)20.8359,  (F)17.8828,
	(F) 13.7578,  (F)21.6641,  (F)18.2578,
	(F) 11.0547,  (F)25.9766,  (F)22.7422,
	(F) 18.3906,  (F)24.5156,  (F)24.4219,
	(F) 20.7734,  (F)32.75,  (F)31.3281,
	(F) 8.1875,  (F)13.9531,  (F)14.2031,
	(F) 9.70312,  (F)16.4922,  (F)17.5,
	(F) 11.8125,  (F)16.2422,  (F)21.7188,
	(F) 12.2891,  (F)19.4609,  (F)24.5156,
	(F) 17.4219,  (F)18.5703,  (F)21.7344,
	(F) 3.25,  (F)13.8516,  (F)21.125,
	(F) 5.66406,  (F)18.25,  (F)25.7578,
	(F) 9.78125,  (F)18.5391,  (F)31.0781,
	(F) 16.3594,  (F)17.7188,  (F)27.875,
	(F) 15.7109,  (F)21.1875,  (F)35.375,
	(F) 10.4766,  (F)27.3984,  (F)30.2812,
	(F) 9.5,  (F)30.6172,  (F)38.4531,
	(F) 13.2266,  (F)37.4453,  (F)46.9688,
};

/*
**  Band1Tb8:
**
**  Purpose:
**      Vector Quantize the second 3-vector of the 10 LSP parameters.
**
**  Table Structure:
**      8 bit, 256 entry table.
*/

FLOAT Band1Tb8[LspCbSize*3] = {
	(F)0,  (F)0,  (F)0,
	(F)-16.5156,  (F)-10.1719,  (F)0.59375,
	(F)-20.7188,  (F)-9.98438,  (F)-10.6875,
	(F)-22.2422,  (F)-6.46875,  (F)-2.72656,
	(F)-29.7812,  (F)-17.1094,  (F)-2.72656,
	(F)-30.8281,  (F)-2.84375,  (F)-3.50781,
	(F)-21.2891,  (F)-35.0938,  (F)-28.1797,
	(F)-27.3047,  (F)-37.2188,  (F)-13.625,
	(F)-0.398438,  (F)-5.90625,  (F)0.65625,
	(F)-1.19531,  (F)-9.30469,  (F)3.9375,
	(F) 0.84375,  (F)-11.0781,  (F)9.11719,
	(F)-6.52344,  (F)-7,  (F)3.04688,
	(F)-4.44531,  (F)-13.2969,  (F)0.679688,
	(F)-8.99219,  (F)-14.2031,  (F)7.28906,
	(F)-14.2656,  (F)-19.8984,  (F)3.21094,
	(F)-14.3906,  (F)-14.2031,  (F)11.3359,
	(F)-19.0469,  (F)-12.5859,  (F)6.10156,
	(F)-21.4609,  (F)-19.3516,  (F)10.2422,
	(F)-7.34375,  (F)9.78125,  (F)3.72656,
	(F)-12.7266,  (F)13.1875,  (F)4.70312,
	(F)-9.39062,  (F)4.82031,  (F)2.1875,
	(F)-13.5703,  (F)3.07031,  (F)4.53125,
	(F)-11.9375,  (F)8.41406,  (F)9.36719,
	(F)-16.9141,  (F)-1.25781,  (F)11,
	(F)-19.5625,  (F)-8.49219,  (F)18.5234,
	(F)-27.0156,  (F)-1.36719,  (F)10.8984,
	(F)-10.9141,  (F)-0.765625,  (F)-6.58594,
	(F)-17.5938,  (F)-1.38281,  (F)-8.97656,
	(F)-11.6328,  (F)-5.67188,  (F)-10.0234,
	(F)-12.1719,  (F)-2.07031,  (F)-13.625,
	(F)-14.5859,  (F)-6.41406,  (F)-14.8203,
	(F)-16.1094,  (F)-11.8438,  (F)-18.2812,
	(F)-20.2734,  (F)-8.92188,  (F)-22.3516,
	(F) 1.32812,  (F)0.359375,  (F)-6.39844,
	(F)-1.50781,  (F)-1.59375,  (F)-8.99219,
	(F) 2.54688,  (F)-1.53125,  (F)-11.9688,
	(F) 6.09375,  (F)2.57031,  (F)-6.375,
	(F) 1.57031,  (F)2.88281,  (F)-9.71094,
	(F) 5.07812,  (F)-1.63281,  (F)-8.28125,
	(F) 8.9375,  (F)-0.117188,  (F)-9.5,
	(F) 9.39844,  (F)-2.02344,  (F)-14.5859,
	(F)-6.95312,  (F)-4.40625,  (F)-11.1719,
	(F)-4.98438,  (F)-6.65625,  (F)-15.0078,
	(F) 1.38281,  (F)-5.77344,  (F)-10.6094,
	(F)-2.03906,  (F)-4.10938,  (F)-13.0156,
	(F) 1.60938,  (F)-3.17969,  (F)-17.6172,
	(F) 2.64062,  (F)-4.10938,  (F)-6.42188,
	(F) 3.28906,  (F)-8.55469,  (F)-7.88281,
	(F) 5.97656,  (F)-4.74219,  (F)-11,
	(F) 6.44531,  (F)-10.1172,  (F)-15.6562,
	(F) 2.78906,  (F)-7.07031,  (F)-14.1797,
	(F)-0.453125,  (F)-9.75,  (F)-12.4062,
	(F)-4.65625,  (F)-11.2188,  (F)-15.9844,
	(F)-0.570312,  (F)-9.05469,  (F)-16.5312,
	(F)-0.898438,  (F)-10.7969,  (F)-20.1641,
	(F)-1.25,  (F)-13.4609,  (F)-15.25,
	(F)-0.046875,  (F)-17.1562,  (F)-23.0781,
	(F)-5.07031,  (F)-13.3203,  (F)-20.3359,
	(F)-4.82031,  (F)-11.3516,  (F)-25.6406,
	(F)-7.41406,  (F)-15.7734,  (F)-24.2344,
	(F)-6.34375,  (F)12.0625,  (F)15.1328,
	(F)-14.4844,  (F)4.48438,  (F)15.625,
	(F)-11.4297,  (F)8.90625,  (F)20.6953,
	(F)-20.9609,  (F)13.6562,  (F)11.3438,
	(F)-19.4219,  (F)17.5078,  (F)19.7109,
	(F) 6.11719,  (F)14.9219,  (F)11.2109,
	(F) 4.53906,  (F)20.9531,  (F)10.75,
	(F) 1.84375,  (F)17.1641,  (F)14.7266,
	(F)-3.53906,  (F)22.9922,  (F)16.0703,
	(F)-5.32812,  (F)17.0156,  (F)20.0391,
	(F)-10.4844,  (F)25.0078,  (F)26,
	(F)-2.25,  (F)-1.4375,  (F)2.04688,
	(F) 0.945312,  (F)-1.16406,  (F)-1.42969,
	(F) 5.92188,  (F)-3.21875,  (F)1.60938,
	(F) 8.10938,  (F)-1.59375,  (F)6.66406,
	(F) 12.3203,  (F)-3.57031,  (F)5.46875,
	(F) 7.32031,  (F)-5,  (F)-4.42969,
	(F) 11.7812,  (F)-4.125,  (F)-8,
	(F)-1.75781,  (F)-4.11719,  (F)-3.33594,
	(F)-4.40625,  (F)-8.55469,  (F)-2.59375,
	(F)-5.79688,  (F)-2.75781,  (F)-1.45312,
	(F)-10.0625,  (F)-3.58594,  (F)0.65625,
	(F)-14.4766,  (F)-3.78125,  (F)-2.14062,
	(F)-12.1406,  (F)-5.71094,  (F)6.44531,
	(F)-18.9453,  (F)-1.82812,  (F)2.98438,
	(F)-13.4531,  (F)2.28906,  (F)-2.11719,
	(F)-19.6484,  (F)3.32031,  (F)-4.40625,
	(F)-20.3047,  (F)6.39062,  (F)3.625,
	(F)-2.79688,  (F)0.921875,  (F)-2.92969,
	(F)-4.78906,  (F)1.54688,  (F)-6.82812,
	(F)-5.39062,  (F)5.33594,  (F)-2.53125,
	(F)-10.5625,  (F)9.02344,  (F)-1.3125,
	(F)-8.53906,  (F)1.00781,  (F)-2.53125,
	(F)-9.25,  (F)4.77344,  (F)-6.70312,
	(F) 3.38281,  (F)3.01562,  (F)-2.90625,
	(F)-0.9375,  (F)3.79688,  (F)-4.95312,
	(F) 1.82812,  (F)6.64844,  (F)-4.92969,
	(F) 4.70312,  (F)1,  (F)0.359375,
	(F) 8.58594,  (F)3.20312,  (F)1.24219,
	(F) 5.58594,  (F)-1.13281,  (F)-3.3125,
	(F) 9.35938,  (F)-0.664062,  (F)-4.63281,
	(F) 10.8594,  (F)2.86719,  (F)-2.79688,
	(F) 13.1484,  (F)2.82812,  (F)-7.53125,
	(F) 13.3672,  (F)4.85938,  (F)0.351562,
	(F) 15.8828,  (F)6.50781,  (F)-2.99219,
	(F) 22.5781,  (F)4.28906,  (F)-3.95312,
	(F) 0.0546875,  (F)3.13281,  (F)0.40625,
	(F) 0.5625,  (F)6.33594,  (F)3.24219,
	(F) 4.42188,  (F)5.21875,  (F)0.320312,
	(F) 3.64844,  (F)9.51562,  (F)1.01562,
	(F) 0.53125,  (F)7.47656,  (F)-1.46094,
	(F)-0.195312,  (F)12.8828,  (F)-0.804688,
	(F)-5.16406,  (F)2.03125,  (F)1.67188,
	(F)-7.22656,  (F)-0.734375,  (F)4.78125,
	(F)-2.50781,  (F)-3.29688,  (F)7.53906,
	(F)-6.15625,  (F)-5.25,  (F)13.9297,
	(F) 3.125,  (F)-5.25781,  (F)6.08594,
	(F) 5.78906,  (F)-4.64844,  (F)12.7734,
	(F)-1.25781,  (F)2.39844,  (F)5.13281,
	(F)-2.98438,  (F)6.53125,  (F)6.80469,
	(F)-6.35938,  (F)3.125,  (F)9.55469,
	(F) 2.84375,  (F)4.73438,  (F)9.74219,
	(F) 0.445312,  (F)0.585938,  (F)12.2734,
	(F) 1.17969,  (F)3.67969,  (F)17.8672,
	(F)-0.632812,  (F)7.97656,  (F)11.7344,
	(F) 1.77344,  (F)11.4844,  (F)8.57031,
	(F) 5.14062,  (F)9.96094,  (F)12.9141,
	(F) 5.1875,  (F)11.5469,  (F)18.5703,
	(F) 2.05469,  (F)-0.992188,  (F)3.46875,
	(F) 2.0625,  (F)0.695312,  (F)7.57031,
	(F) 6.20312,  (F)1.33594,  (F)4.5,
	(F) 6.41406,  (F)1.45312,  (F)9.57812,
	(F) 3.15625,  (F)3.60938,  (F)4.03906,
	(F) 2.64844,  (F)7.17188,  (F)6.20312,
	(F) 10,  (F)11.1172,  (F)1.53125,
	(F) 11.3516,  (F)15.7734,  (F)2.85156,
	(F) 12.6172,  (F)11.5703,  (F)5.25,
	(F) 18.7031,  (F)13.3438,  (F)3.96875,
	(F) 6.29688,  (F)9.67188,  (F)4.47656,
	(F) 5.57031,  (F)9.04688,  (F)8.42188,
	(F) 10.0391,  (F)11.2188,  (F)9.625,
	(F) 13.9844,  (F)9.28125,  (F)8.91406,
	(F) 5.97656,  (F)5.02344,  (F)6.75,
	(F) 8.0625,  (F)6.22656,  (F)9.99219,
	(F) 7.03125,  (F)4.39844,  (F)14.2734,
	(F) 11.8281,  (F)5.25781,  (F)18.0625,
	(F) 12.0625,  (F)8.82031,  (F)25.3125,
	(F) 11.4766,  (F)8.20312,  (F)12.4531,
	(F) 15.1953,  (F)10.2969,  (F)15.5312,
	(F) 18.7266,  (F)15.8281,  (F)16.0938,
	(F) 27.6406,  (F)16.0703,  (F)20.4688,
	(F) 9.75781,  (F)-0.921875,  (F)0.578125,
	(F) 13.4922,  (F)1.51562,  (F)3.28906,
	(F) 16.2344,  (F)-0.390625,  (F)-3.61719,
	(F) 7.57812,  (F)5.375,  (F)-3.375,
	(F) 8.97656,  (F)7.4375,  (F)-0.859375,
	(F) 9.79688,  (F)9.96094,  (F)-5.08594,
	(F) 10.8281,  (F)7.25781,  (F)3.13281,
	(F) 15.3125,  (F)9.11719,  (F)1.8125,
	(F) 3.17969,  (F)-5.875,  (F)-1.89844,
	(F) 6.71094,  (F)-8.73438,  (F)1.34375,
	(F)-1.77344,  (F)-6.71875,  (F)-7.75,
	(F)-6.21875,  (F)-9.17969,  (F)-10.7812,
	(F) 0.0625,  (F)-10.0156,  (F)-3.03125,
	(F) 2.75781,  (F)-13.9141,  (F)-8.10156,
	(F)-5.71875,  (F)-3.10156,  (F)-6.30469,
	(F)-6.66406,  (F)-0.21875,  (F)-10.4844,
	(F)-9.60156,  (F)-9.42969,  (F)-15.3047,
	(F)-7.92969,  (F)-8.78906,  (F)-19.8672,
	(F)-11.3438,  (F)-13.9922,  (F)-21.2891,
	(F)-14.7734,  (F)-18.875,  (F)-25.5391,
	(F)-7.17188,  (F)-12.7266,  (F)-6.11719,
	(F)-4.53125,  (F)-16.8359,  (F)-5.45312,
	(F)-8.57031,  (F)-18.4688,  (F)-0.75,
	(F)-10.8359,  (F)-11.8203,  (F)0.0546875,
	(F)-12.4062,  (F)-16.2188,  (F)-5.1875,
	(F)-11.5078,  (F)-21.4062,  (F)-6.125,
	(F)-18.5781,  (F)-24.6016,  (F)-0.4375,
	(F)-22.3125,  (F)-16.3438,  (F)-1.32031,
	(F)-26.4922,  (F)-28.9688,  (F)2.46875,
	(F)-9.1875,  (F)-6.95312,  (F)-4.79688,
	(F)-15.1875,  (F)-8.28906,  (F)-6.25,
	(F)-2.33594,  (F)-11.8516,  (F)-7.8125,
	(F)-5,  (F)-14.4531,  (F)-11.9219,
	(F)-11.3594,  (F)-12,  (F)-9.63281,
	(F)-14.7656,  (F)-15.2734,  (F)-13.7188,
	(F)-8.48438,  (F)-15.0078,  (F)-16.5781,
	(F)-5.85938,  (F)-18.1641,  (F)-17.6562,
	(F)-10.3516,  (F)-18.8516,  (F)-20.8828,
	(F)-8.70312,  (F)-19.8594,  (F)-27.0234,
	(F)-10.4766,  (F)-22.6641,  (F)-30.9609,
	(F)-9.0625,  (F)-17.3906,  (F)-10.8828,
	(F)-7.82031,  (F)-21.6562,  (F)-12.2891,
	(F)-12.4531,  (F)-20.6328,  (F)-15.4531,
	(F)-11.9844,  (F)-23.7969,  (F)-20.5,
	(F)-17.375,  (F)-17.1562,  (F)-5.27344,
	(F)-21.9297,  (F)-23.8594,  (F)-8.60938,
	(F)-15.6875,  (F)-22.1875,  (F)-9.26562,
	(F)-15.4688,  (F)-26.0312,  (F)-13.2422,
	(F)-13.3984,  (F)-27.8281,  (F)-3.94531,
	(F)-19.7422,  (F)-31.25,  (F)-14.7422,
	(F)-18.2266,  (F)-21.3594,  (F)-17.9375,
	(F)-26.875,  (F)-18.7578,  (F)-25.0859,
	(F)-15.6875,  (F)-27.5625,  (F)-26.0703,
	(F)-17.5547,  (F)-25.7109,  (F)-35.2344,
	(F)-3.71094,  (F)7.41406,  (F)1.21094,
	(F)-1.16406,  (F)10.6641,  (F)4.25781,
	(F)-5.91406,  (F)12.8438,  (F)8.46094,
	(F)-1.69531,  (F)16.0391,  (F)10.5703,
	(F)-11.1953,  (F)17.9766,  (F)11.4219,
	(F) 3.86719,  (F)12.9766,  (F)4.13281,
	(F) 0.078125,  (F)15.9141,  (F)5.78125,
	(F) 16.2656,  (F)14.8281,  (F)7.64062,
	(F) 22.1172,  (F)17.9219,  (F)7.11719,
	(F) 6.57812,  (F)6.19531,  (F)3.28125,
	(F) 9.55469,  (F)7.99219,  (F)6.74219,
	(F) 9.66406,  (F)3.52344,  (F)6.09375,
	(F) 13.625,  (F)5.53125,  (F)6.42188,
	(F) 11.9766,  (F)2.21875,  (F)10.8125,
	(F) 16.6797,  (F)4.75781,  (F)12.0156,
	(F) 18.0078,  (F)4.89062,  (F)4.21875,
	(F) 18.5,  (F)9.27344,  (F)7.46094,
	(F) 20.2031,  (F)9.80469,  (F)-0.0546875,
	(F) 24.3438,  (F)8.83594,  (F)5.67188,
	(F) 26.8047,  (F)13.5156,  (F)3.34375,
	(F) 21.3594,  (F)12.875,  (F)10.2109,
	(F) 23.3438,  (F)9.61719,  (F)15.7031,
	(F) 27.5234,  (F)15.8125,  (F)11.625,
	(F) 8.07812,  (F)12.9453,  (F)6.80469,
	(F) 9.42188,  (F)16.8984,  (F)8.09375,
	(F) 14.1172,  (F)18.5312,  (F)9.63281,
	(F) 14.125,  (F)13.8203,  (F)11.6641,
	(F) 12.2891,  (F)18.2188,  (F)13.8984,
	(F) 9.5,  (F)12.5703,  (F)14.5781,
	(F) 11.5625,  (F)14.8281,  (F)19.6328,
	(F) 3.63281,  (F)21.1562,  (F)21.6875,
	(F) 6.02344,  (F)28.4219,  (F)26.0781,
	(F) 14.6016,  (F)20.3047,  (F)20.4922,
	(F) 22.0703,  (F)21.4453,  (F)19.2812,
	(F) 20.6094,  (F)19.0547,  (F)12.3828,
	(F) 16.3594,  (F)23.2031,  (F)10.2188,
	(F) 15.7969,  (F)23.8828,  (F)15.6172,
	(F) 26.7812,  (F)22.75,  (F)14.1875,
	(F) 35.4375,  (F)23.2344,  (F)16.6328,
	(F) 8.17188,  (F)20.0234,  (F)16.2969,
	(F) 10.6484,  (F)27.8281,  (F)18.1094,
	(F) 19.6172,  (F)14.7734,  (F)23.3125,
	(F) 14.5781,  (F)18.0156,  (F)31.1406,
	(F) 25.5625,  (F)22.8438,  (F)28.7656,
	(F) 24.5781,  (F)27.8438,  (F)17.75,
	(F) 28.0625,  (F)31,  (F)22.0469,
	(F) 18.9922,  (F)26.3203,  (F)23.9766,
	(F) 15.0859,  (F)36.7891,  (F)24.1406,
	(F) 20.5391,  (F)32.9688,  (F)31.1406,
	(F) 36.2422,  (F)31.6875,  (F)28.625,
	(F) 31.5234,  (F)41.6719,  (F)38.375,
};


/*
**  Band2Tb8:
**
**  Purpose:
**      Vector Quantize the last 4-vector of the 10 LSP parameters.
**
**  Table Structure:
**      8 bit, 256 entry table.
*/

FLOAT Band2Tb8[LspCbSize*4] = {
	(F) 0,  (F)0,  (F)0,  (F)0,
	(F) 4.69531,  (F)4,  (F)-4.23438,  (F)2.60938,
	(F) 3.34375,  (F)8.49219,  (F)-3.78125,  (F)-1.03125,
	(F) 5.09375,  (F)4.85938,  (F)-3.05469,  (F)-4.46875,
	(F) 2.95312,  (F)6.24219,  (F)1.10156,  (F)-6.71875,
	(F) 8.125,  (F)3.19531,  (F)0.875,  (F)-4.32812,
	(F) 8.77344,  (F)5.23438,  (F)-0.585938,  (F)-6.61719,
	(F) 11.1016,  (F)3.85938,  (F)-2.46094,  (F)-8.55469,
	(F) 6.14844,  (F)7.82031,  (F)0.890625,  (F)-3.59375,
	(F) 7.71875,  (F)13.0625,  (F)1.6875,  (F)-5.32031,
	(F) 7.86719,  (F)9.69531,  (F)-1.03125,  (F)-9.74219,
	(F) 8.38281,  (F)3.11719,  (F)1.45312,  (F)-0.0390625,
	(F) 9.85938,  (F)1.50781,  (F)-5.42188,  (F)-1.00781,
	(F) 2.53906,  (F)1.53125,  (F)0.398438,  (F)-5.00781,
	(F) 6.72656,  (F)-0.460938,  (F)2.73438,  (F)-3.57812,
	(F) 9.85156,  (F)4.42969,  (F)4.57812,  (F)-2.70312,
	(F) 11.9688,  (F)6.91406,  (F)1.64062,  (F)-4.03906,
	(F) 15.8359,  (F)7.32031,  (F)0.882812,  (F)-6.1875,
	(F) 10.8047,  (F)8.3125,  (F)2.60938,  (F)0.296875,
	(F) 15.3438,  (F)11.4688,  (F)3.58594,  (F)1.03906,
	(F) 16.1094,  (F)9.26562,  (F)-0.765625,  (F)-0.945312,
	(F) 20.1328,  (F)11.2891,  (F)3.95312,  (F)-2.91406,
	(F) 18.0469,  (F)13.1406,  (F)-0.015625,  (F)-7.5,
	(F) 22.4688,  (F)15.1484,  (F)5.97656,  (F)1.07812,
	(F) 27.9766,  (F)18.4375,  (F)5.07031,  (F)-3.23438,
	(F) 1.71094,  (F)1.375,  (F)-3.10938,  (F)-2.41406,
	(F) 3.39062,  (F)-0.609375,  (F)-3.39844,  (F)-6.875,
	(F)-2.6875,  (F)2.35156,  (F)2.07031,  (F)-4.3125,
	(F)-7.14844,  (F)3.67188,  (F)5.13281,  (F)-2.96875,
	(F) 3.27344,  (F)-3.375,  (F)-1.27344,  (F)-3.53906,
	(F) 2.74219,  (F)-7.44531,  (F)0.0625,  (F)-4.39062,
	(F) 6.16406,  (F)-0.335938,  (F)0.15625,  (F)-7.48438,
	(F) 2.35938,  (F)-4.64062,  (F)-2.75,  (F)-9.05469,
	(F) 8.125,  (F)0.84375,  (F)-5.21875,  (F)-7.21875,
	(F) 10.4141,  (F)1.64062,  (F)-9.50781,  (F)-12.9922,
	(F) 3.77344,  (F)4.60156,  (F)-2.73438,  (F)-8.90625,
	(F) 7.83594,  (F)6.4375,  (F)-6.26562,  (F)-9.25,
	(F) 5.82031,  (F)0.453125,  (F)-4.60156,  (F)-11.2734,
	(F) 2.70312,  (F)1.92969,  (F)-7.14844,  (F)-13.1484,
	(F) 2.10938,  (F)6.21875,  (F)-5.625,  (F)-15.9609,
	(F) 9.4375,  (F)5.64062,  (F)-1.73438,  (F)-1.50781,
	(F) 11.6094,  (F)9.21875,  (F)-3.21875,  (F)-5.25,
	(F) 13.4531,  (F)1.39844,  (F)-0.539062,  (F)-4.07031,
	(F) 15.9922,  (F)6.71875,  (F)-5.20312,  (F)-11.0156,
	(F)-1.14062,  (F)1.73438,  (F)-2.19531,  (F)-6.28906,
	(F)-1.47656,  (F)0.703125,  (F)-0.890625,  (F)-10.2109,
	(F)-1.1875,  (F)8.48438,  (F)-1.88281,  (F)-5.96875,
	(F)-3.42969,  (F)5.72656,  (F)-4.69531,  (F)-10.1719,
	(F)-6.50781,  (F)-1.30469,  (F)-2.74219,  (F)-4.69531,
	(F)-6.6875,  (F)-3.29688,  (F)-3.21094,  (F)-8.27344,
	(F)-5.83594,  (F)-2.77344,  (F)-4.54688,  (F)-12.8438,
	(F)-6.53906,  (F)1.64062,  (F)-7.15625,  (F)-8.9375,
	(F)-14.0625,  (F)0.25,  (F)-6.85938,  (F)-13.1797,
	(F)-0.375,  (F)-0.179688,  (F)-8.95312,  (F)0.40625,
	(F)-2.73438,  (F)-3.19531,  (F)-12.9375,  (F)-2.84375,
	(F) 2.07031,  (F)-5.6875,  (F)-6.70312,  (F)-4.50781,
	(F) 3.57812,  (F)-1.92969,  (F)-8.91406,  (F)-7.78906,
	(F) 5.39844,  (F)-3.17969,  (F)-15.5312,  (F)-9.07031,
	(F)-0.515625,  (F)-0.8125,  (F)-5.50781,  (F)-9.75781,
	(F)-3.36719,  (F)-0.726562,  (F)-9.30469,  (F)-14.4062,
	(F) 1.58594,  (F)-5.71875,  (F)-7.8125,  (F)-13.2266,
	(F) 0.078125,  (F)-6.5,  (F)-14.4219,  (F)-14.2109,
	(F) 3.85156,  (F)-1,  (F)-11.2188,  (F)-13.8125,
	(F) 3.8125,  (F)-2.42969,  (F)-13.5156,  (F)-19.8438,
	(F)-5.10156,  (F)-4.15625,  (F)-8.98438,  (F)-9.15625,
	(F)-8.48438,  (F)-2.25781,  (F)-13.3281,  (F)-11.9766,
	(F)-5.46094,  (F)-9.41406,  (F)-9.5,  (F)-13.7969,
	(F)-8.0625,  (F)-11.5703,  (F)-16.2031,  (F)-11.8984,
	(F)-5.63281,  (F)-9.53125,  (F)-17.7891,  (F)-20.3125,
	(F) 0.09375,  (F)-4.21094,  (F)-11.5938,  (F)-8.83594,
	(F)-0.3125,  (F)-7.11719,  (F)-16.4531,  (F)-3.44531,
	(F)-3.67969,  (F)-3.78125,  (F)-17.7109,  (F)-12.1016,
	(F)-1.10156,  (F)-7.71875,  (F)-23.4844,  (F)-13.4453,
	(F)-12.0703,  (F)-16.4219,  (F)-4.55469,  (F)2.67188,
	(F)-10.8047,  (F)-21.6562,  (F)-3.01562,  (F)-0.101562,
	(F)-16.5469,  (F)-20.2266,  (F)-9.41406,  (F)0.5625,
	(F)-16.7734,  (F)-25.2422,  (F)-7.53906,  (F)3.04688,
	(F)-23.0391,  (F)-25.7812,  (F)-4.85156,  (F)4.97656,
	(F)-30.5234,  (F)-32.3281,  (F)-6.75781,  (F)6.27344,
	(F)-10.0547,  (F)-6.60156,  (F)-2.92969,  (F)-4.28125,
	(F)-11.0625,  (F)-9.13281,  (F)-3.80469,  (F)-9.97656,
	(F)-10.9375,  (F)-13.2031,  (F)-8.02344,  (F)-3.26562,
	(F)-15.7656,  (F)-14.9141,  (F)-9.28125,  (F)-9.84375,
	(F)-11.0781,  (F)-17.3594,  (F)-15.8516,  (F)-1,
	(F)-16.1484,  (F)-23.4219,  (F)-21.0391,  (F)-2.42188,
	(F)-7.42188,  (F)-8.03125,  (F)-12.0156,  (F)1.44531,
	(F)-12.625,  (F)-7.14844,  (F)-17.2266,  (F)-4.28906,
	(F) 0.148438,  (F)-6.41406,  (F)-8.94531,  (F)2.75,
	(F) 1.4375,  (F)-9.17969,  (F)-10.5938,  (F)-4.89844,
	(F)-4.27344,  (F)-8.5,  (F)-12.9766,  (F)-7.11719,
	(F)-1.6875,  (F)-11.7344,  (F)-17.1641,  (F)-7.40625,
	(F)-6.21094,  (F)-10.2031,  (F)-18.5469,  (F)-3.52344,
	(F)-7.21875,  (F)-14.7578,  (F)-21.8438,  (F)-5.3125,
	(F)-4.6875,  (F)-12.6094,  (F)-28.1953,  (F)-6.91406,
	(F)-18.6875,  (F)-19.75,  (F)2.49219,  (F)2.36719,
	(F)-22.7188,  (F)-16.3672,  (F)-2.42188,  (F)4.47656,
	(F)-27.0312,  (F)-16.7266,  (F)0.382812,  (F)-0.882812,
	(F)-17.4297,  (F)-3.5,  (F)5.27344,  (F)-1.14062,
	(F)-21.9141,  (F)-4.15625,  (F)9.61719,  (F)3.74219,
	(F)-20.9688,  (F)-3.79688,  (F)-1.5625,  (F)4.77344,
	(F)-27.5391,  (F)-7.58594,  (F)-1.54688,  (F)5.5,
	(F)-28.9609,  (F)1.35156,  (F)2.72656,  (F)1.98438,
	(F)-36.9844,  (F)-11.3047,  (F)-0.265625,  (F)6.875,
	(F) 6.07031,  (F)-4,  (F)0.890625,  (F)-0.078125,
	(F) 9.76562,  (F)-0.515625,  (F)3.45312,  (F)-0.0390625,
	(F) 4.71875,  (F)4.78906,  (F)3.53125,  (F)-2.75,
	(F) 9.5625,  (F)6.07031,  (F)5.27344,  (F)-7.92188,
	(F)-10.7188,  (F)-0.617188,  (F)-9.4375,  (F)-1.85938,
	(F)-18.6641,  (F)-0.132812,  (F)-9.03906,  (F)-6.39062,
	(F)-11.75,  (F)-5.25781,  (F)-8.85156,  (F)-8.28125,
	(F)-15.5,  (F)-6.24219,  (F)-15.6641,  (F)-15.4141,
	(F)-15.9141,  (F)-6.23438,  (F)-8.34375,  (F)-0.820312,
	(F)-24.9219,  (F)-7.02344,  (F)-14.1953,  (F)-1.51562,
	(F)-1.21875,  (F)-6.92188,  (F)3.07812,  (F)-2.48438,
	(F)-2.01562,  (F)-10.0234,  (F)4.30469,  (F)1.57812,
	(F)-4.1875,  (F)-13.5078,  (F)7.10938,  (F)2.58594,
	(F)-6.61719,  (F)-8.66406,  (F)6.21094,  (F)-1.27344,
	(F)-9.14844,  (F)-8.8125,  (F)5.58594,  (F)4.05469,
	(F)-8.4375,  (F)-10.3047,  (F)13.1641,  (F)5.21875,
	(F)-7.8125,  (F)-15.0078,  (F)0.75,  (F)1.64844,
	(F)-11.6172,  (F)-16.7812,  (F)6.49219,  (F)1.35938,
	(F)-8.89844,  (F)-2.92188,  (F)3.23438,  (F)-0.03125,
	(F)-11.8516,  (F)-10.8047,  (F)3.09375,  (F)-2.75,
	(F)-7.90625,  (F)3.42969,  (F)-0.460938,  (F)-7.55469,
	(F)-14.1562,  (F)5.51562,  (F)-3.4375,  (F)-8.04688,
	(F)-15.3984,  (F)-2.57031,  (F)-0.265625,  (F)-6.46094,
	(F)-19.3125,  (F)-12.4062,  (F)-1.17969,  (F)-4.73438,
	(F)-16.8828,  (F)2.92188,  (F)-2.19531,  (F)0.59375,
	(F)-23.5312,  (F)1.80469,  (F)-0.117188,  (F)-5.39062,
	(F) 8.625,  (F)4.42188,  (F)5.63281,  (F)1.63281,
	(F) 13.1641,  (F)4.40625,  (F)2.99219,  (F)0.765625,
	(F) 14.8281,  (F)5.85938,  (F)6.1875,  (F)-0.757812,
	(F) 4.34375,  (F)-0.5,  (F)4.38281,  (F)-0.726562,
	(F) 6.84375,  (F)1.26562,  (F)7.13281,  (F)-0.171875,
	(F) 7.50781,  (F)5.27344,  (F)10.125,  (F)1.09375,
	(F) 5.90625,  (F)-3.09375,  (F)6.64844,  (F)4.25,
	(F) 2.8125,  (F)-2.36719,  (F)10.4766,  (F)3.09375,
	(F) 6.85938,  (F)-0.171875,  (F)11.4375,  (F)6.74219,
	(F)-2.41406,  (F)-2.13281,  (F)5.01562,  (F)-1.00781,
	(F)-5.35938,  (F)-0.640625,  (F)6.57812,  (F)3.54688,
	(F)-0.0390625,  (F)-0.367188,  (F)8.35156,  (F)7.79688,
	(F)-0.734375,  (F)7.55469,  (F)9.97656,  (F)2.32812,
	(F)-3.82031,  (F)3.00781,  (F)11.5078,  (F)5.82812,
	(F)-2.88281,  (F)-5.60156,  (F)10.4141,  (F)1.89062,
	(F) 2.19531,  (F)-7.75781,  (F)13.4844,  (F)7.21875,
	(F) 3.625,  (F)4.69531,  (F)12.3047,  (F)10.75,
	(F)-1.95312,  (F)1.60938,  (F)18.2734,  (F)9.17969,
	(F)-3.42188,  (F)2.94531,  (F)-4.66406,  (F)-2.22656,
	(F)-7.96875,  (F)6.14844,  (F)-6.17188,  (F)-2.24219,
	(F)-3.57812,  (F)-3.20312,  (F)1.67969,  (F)2.30469,
	(F)-4.60156,  (F)-6.71875,  (F)-0.945312,  (F)6.22656,
	(F)-9.17969,  (F)0.953125,  (F)-3.41406,  (F)3.64062,
	(F)-11.5625,  (F)-0.945312,  (F)2.86719,  (F)7.21875,
	(F) 1.82812,  (F)2.52344,  (F)6.01562,  (F)-4.33594,
	(F) 1.13281,  (F)0.234375,  (F)7.78125,  (F)0.203125,
	(F) 0.515625,  (F)6.63281,  (F)0.726562,  (F)-1.13281,
	(F)-0.914062,  (F)9.85156,  (F)3.70312,  (F)-3.11719,
	(F)-11.6797,  (F)8.21094,  (F)1.70312,  (F)-3.95312,
	(F)-10.8594,  (F)5.42188,  (F)7.76562,  (F)0.6875,
	(F) 4.8125,  (F)0.0546875,  (F)0.609375,  (F)2.375,
	(F) 8.28125,  (F)0.40625,  (F)-0.484375,  (F)6.52344,
	(F) 6.50781,  (F)3.54688,  (F)5.07031,  (F)10.6172,
	(F)-6.01562,  (F)3.625,  (F)0.367188,  (F)0.726562,
	(F)-4.48438,  (F)9.36719,  (F)-0.304688,  (F)2.96094,
	(F) 0.890625,  (F)-0.765625,  (F)3.8125,  (F)3.78906,
	(F) 5.67969,  (F)1.90625,  (F)4.73438,  (F)5.4375,
	(F)-0.59375,  (F)3.55469,  (F)5.24219,  (F)4.26562,
	(F)-4.41406,  (F)-0.101562,  (F)1.13281,  (F)6.39844,
	(F)-2.9375,  (F)4.44531,  (F)3.5,  (F)8.8125,
	(F) 1.70312,  (F)0.953125,  (F)2.07031,  (F)9.11719,
	(F) 1.79688,  (F)5.76562,  (F)7.28125,  (F)7.83594,
	(F) 1.07812,  (F)3.72656,  (F)0.28125,  (F)3.51562,
	(F) 3.15625,  (F)6.14844,  (F)-0.570312,  (F)7.8125,
	(F) 3.88281,  (F)9.83594,  (F)3.02344,  (F)9.61719,
	(F) 0.132812,  (F)1.61719,  (F)1.52344,  (F)-0.617188,
	(F) 4.39062,  (F)2.79688,  (F)0.414062,  (F)-1.23438,
	(F) 3.85156,  (F)3.02344,  (F)3.73438,  (F)1.47656,
	(F) 5.29688,  (F)6.49219,  (F)5,  (F)4.35938,
	(F)-1.53906,  (F)4.08594,  (F)4.78906,  (F)0.445312,
	(F) 3.35156,  (F)6.98438,  (F)6.00781,  (F)0.867188,
	(F) 0.523438,  (F)9.17188,  (F)4.4375,  (F)3.99219,
	(F) 9.70312,  (F)6.4375,  (F)1.96094,  (F)6.5625,
	(F) 11.0859,  (F)8.39062,  (F)6.75,  (F)3.75781,
	(F) 7.21875,  (F)11.5156,  (F)5.22656,  (F)5.65625,
	(F) 12.0234,  (F)14.6797,  (F)5.10938,  (F)12.4219,
	(F) 3.47656,  (F)2.63281,  (F)8.67969,  (F)4.22656,
	(F) 3.6875,  (F)11.1016,  (F)9.875,  (F)8.54688,
	(F) 6.20312,  (F)5.74219,  (F)8.61719,  (F)5.21875,
	(F) 8.24219,  (F)6.74219,  (F)9.3125,  (F)7.96875,
	(F) 6.07812,  (F)8.63281,  (F)6.29688,  (F)14.0469,
	(F) 8.21875,  (F)11.9297,  (F)12.3984,  (F)16.8047,
	(F) 6.88281,  (F)12.125,  (F)9.88281,  (F)3.05469,
	(F) 5.67188,  (F)6.8125,  (F)14.1562,  (F)4.69531,
	(F) 11.4766,  (F)2.1875,  (F)7.875,  (F)4.8125,
	(F) 10.9609,  (F)4.50781,  (F)14.0859,  (F)9.71875,
	(F) 12.8906,  (F)10.2656,  (F)8.96875,  (F)8.375,
	(F) 10.1328,  (F)13.0391,  (F)14.9297,  (F)8.01562,
	(F) 16.3516,  (F)8.15625,  (F)16.5234,  (F)9.28906,
	(F) 12.8438,  (F)15.3203,  (F)20.2109,  (F)11.8125,
	(F) 0.195312,  (F)-2.46094,  (F)-0.0703125,  (F)-0.828125,
	(F) 2.26562,  (F)-2.64844,  (F)3.34375,  (F)-3.46875,
	(F)-0.53125,  (F)-6.11719,  (F)5.74219,  (F)6.03125,
	(F) 1.91406,  (F)-4.33594,  (F)3.65625,  (F)0.367188,
	(F) 2.60938,  (F)-6.99219,  (F)6.35938,  (F)1.14062,
	(F) 1.83594,  (F)2.875,  (F)-7.53125,  (F)-7.49219,
	(F)-1.58594,  (F)2.46094,  (F)-12.2344,  (F)-9.50781,
	(F) 6.25781,  (F)0.132812,  (F)-2.15625,  (F)-2.76562,
	(F) 6.98438,  (F)-3.86719,  (F)-6.16406,  (F)-4.96094,
	(F) 5.59375,  (F)2.27344,  (F)-9.28906,  (F)-2.78906,
	(F) 4.375,  (F)-2.03125,  (F)-5.72656,  (F)-0.015625,
	(F) 5.30469,  (F)-3.96875,  (F)-11.1641,  (F)1.64844,
	(F)-0.398438,  (F)-0.484375,  (F)-3.34375,  (F)4.35156,
	(F) 2.51562,  (F)-4.98438,  (F)-1.64844,  (F)4.79688,
	(F)-6.85938,  (F)-8.25781,  (F)-0.65625,  (F)-0.554688,
	(F)-3.03125,  (F)-11.0547,  (F)-1.30469,  (F)-2.48438,
	(F)-5.89062,  (F)-12.2969,  (F)1.67188,  (F)-4.21094,
	(F)-11.0859,  (F)-15.6562,  (F)-0.71875,  (F)-6.14844,
	(F)-0.367188,  (F)-6.6875,  (F)-2.71094,  (F)-1.99219,
	(F) 0.179688,  (F)-9.46094,  (F)-1.35156,  (F)2.5,
	(F)-5.14062,  (F)-3.80469,  (F)-6.97656,  (F)2.75781,
	(F)-6.11719,  (F)-12.3984,  (F)-4.5625,  (F)3.96094,
	(F)-11.0938,  (F)-6.71094,  (F)-2.95312,  (F)3.44531,
	(F)-16.3672,  (F)-11.6484,  (F)-1.07031,  (F)3.42969,
	(F)-2.50781,  (F)-11.3281,  (F)-10.0625,  (F)-0.09375,
	(F)-2.80469,  (F)-16.5078,  (F)-4.32031,  (F)-0.0625,
	(F)-6.49219,  (F)-14.9844,  (F)-12.1953,  (F)0.25,
	(F)-7.92188,  (F)-19.4297,  (F)-10.6172,  (F)-7.33594,
	(F)-3.71094,  (F)-2.42969,  (F)-1.32031,  (F)-1.84375,
	(F)-7.08594,  (F)-3.32812,  (F)2.15625,  (F)-4.77344,
	(F)-0.75,  (F)-3.125,  (F)0.390625,  (F)-5.54688,
	(F)-3.32812,  (F)-7.98438,  (F)-0.078125,  (F)-7.69531,
	(F)-1.53906,  (F)-2.01562,  (F)-5.8125,  (F)-4.49219,
	(F)-4.77344,  (F)-7.26562,  (F)-6.02344,  (F)-3.07812,
	(F)-2.08594,  (F)-6.0625,  (F)-4.78125,  (F)-7.33594,
	(F)-2,  (F)-10.5156,  (F)-6.26562,  (F)-8.76562,
	(F)-6.21875,  (F)-12.2656,  (F)-6.44531,  (F)-5.89062,
	(F) 5.5625,  (F)6.84375,  (F)1.10156,  (F)1.77344,
	(F) 7.66406,  (F)11.7891,  (F)0.664062,  (F)0.96875,
	(F) 11.4219,  (F)9.59375,  (F)7.64844,  (F)-0.304688,
	(F) 13.5469,  (F)7.80469,  (F)11.5703,  (F)3.4375,
	(F) 17.9141,  (F)8.71875,  (F)6.00781,  (F)3.4375,
	(F) 19.5625,  (F)11.5625,  (F)9.69531,  (F)2.78125,
	(F) 19.3281,  (F)14.9141,  (F)12.1719,  (F)6.32812,
	(F) 7.16406,  (F)8.85938,  (F)4.74219,  (F)-1.04688,
	(F) 3.97656,  (F)14.1328,  (F)6.10156,  (F)-0.960938,
	(F) 13.375,  (F)11.7656,  (F)4.36719,  (F)-3.30469,
	(F) 15.9141,  (F)18.1016,  (F)5.67188,  (F)-1.21094,
	(F) 23.6797,  (F)20.9062,  (F)9.39844,  (F)2.58594,
	(F) 28.625,  (F)25.5781,  (F)13.8125,  (F)4.14844,
	(F) 12.5781,  (F)14.3672,  (F)6.77344,  (F)1.42969,
	(F) 13.8594,  (F)15.4062,  (F)12.0156,  (F)0.757812,
	(F) 14.2344,  (F)16.8594,  (F)10.0156,  (F)5.14844,
	(F) 17.3594,  (F)21.5469,  (F)14.2031,  (F)7.03125,
	(F) 25.3984,  (F)16.5938,  (F)13.4609,  (F)7.78125,
	(F) 28.3828,  (F)18.25,  (F)18.8125,  (F)11.3516,
	(F) 22.8359,  (F)27.4766,  (F)20.0547,  (F)10.2969,
};

/*
**  BandQntTable:
**
**  Purpose:
**      collects the three subvector tables.
*/

FLOAT *BandQntTable[LspQntBands] = {
   Band0Tb8 ,
   Band1Tb8 ,
   Band2Tb8 ,
   };

/*
**  PerFiltZeroTable:
**
**  Purpose:
**     Creates the FIR part of the formant perceptual weighting filter. 
**     Corresponds to gamma1 in section 2.8.
**
**  Table Structure:
**     (0.9) to the x power, where x = [1,..,10]
*/
 
FLOAT PerFiltZeroTable[LpcOrder] = {
   (F)0.9 ,
   (F)0.81 ,
   (F)0.729 ,
   (F)0.6561 ,
   (F)0.59049 ,
   (F)0.531441 ,
   (F)0.4781969 ,
   (F)0.43046721 ,
   (F)0.38742049 ,
   (F)0.34867844 ,
};

/*
**  PerFiltPoleTable:
**
**  Purpose:
**     Creates the IIR part of the formant perceptual weighting filter. 
**     Corresponds to gamma2 in section 2.8.
**
**  Table Structure:
**     (0.5) to the x power, where x = [1,..,10]
*/

FLOAT PerFiltPoleTable[LpcOrder] = {
   (F)0.5 ,
   (F)0.25 ,
   (F)0.125 ,
   (F)0.0625 ,
   (F)0.03125 ,
   (F)0.015625 ,
   (F)0.0078125 ,
   (F)0.00390625 ,
   (F)0.001953125 ,
   (F)0.0009765625 ,
};

/*
**  PostFiltZeroTable:
**
**  Purpose:
**     Creates the FIR part of the formant postfilter.  Corresponds to
**     lambda1 in section 3.8.
**
**  Table Structure:
**     (0.65) to the x power, where x = [1,..,10]
*/

//Code removed

/*
**  PostFiltPoleTable:
**
**  Purpose:
**     Creates the IIR part of the formant postfilter.  Corresponds to
**     lambda2 in section 3.8.
**
**  Table Structure:
**     (0.75) to the x power, where x = [1,..,10]
*/

//Code removed

/*
**  Nb_puls:
**
**  Purpose:
**      Indexing
**
**  Table Structure:
**      Table values are the number of non-zero pulses in the high-rate
**      excitation (MP-MLQ), indexed by subframe number (0,..,3).
*/

int Nb_puls[4] = { 6,5,6,5};

/*
**  FcbkGainTable:
**
**  Purpose:
**      Logarithmic scalar quantizer in 24 steps of 3.2 dB each
**
**  Table Structure:
**      Contains x where 20*log10(x) = 3.2*i,  i = 1,..,24
*/

float FcbkGainTable[NumOfGainLev] = {
    1.0f,
    2.0f,
    3.0f,
    4.0f,
    6.0f,
    9.0f,
   13.0f,
   18.0f,
   26.0f,
   38.0f,
   55.0f,
   80.0f,
  115.0f,
  166.0f,
  240.0f,
  348.0f,
  502.0f,
  726.0f,
 1050.0f,
 1517.0f,
 2193.0f,
 3170.0f,
 4582.0f,
 6623.0f,
   };

/*
**  MaxPosTable:
**
**  Purpose:
**      size of the high rate fixed excitation codebooks (MP-MLQ)
**
**  Table Structure:
**      Table values are the number of codewords in the high rate fixed
**      excitation codebook (MP-MLQ), indexed by subframe number (0,..,3).
**      MaxPosTable[i] is the number of combinations of i elements among 30
**      non-zero pulses in the high-rate
*/

Word32   MaxPosTable[4] = {
 0x00090f6fL,
 0x00022caaL,
 0x00090f6fL,
 0x00022caaL,
};

/*
**  CombinatorialTable:
**
**  Purpose:
**      used for the coding and the decoding of the pulses positions
**      for the high-rate fixed excitation codebook
**
**  Table Structure:
**      CombinatorialTable[i][j] is the number of combinations of
**      (MaxPulsNum-1-i) elements among (SubFrLen-2-j)
*/

Word32   CombinatorialTable[MaxPulseNum][SubFrLen/Sgrid] = {
 { 118755L,
  98280L,
  80730L,
  65780L,
  53130L,
  42504L,
  33649L,
  26334,
  20349,
  15504,
  11628,
   8568,
   6188,
   4368,
   3003,
   2002,
   1287,
    792,
	462,
    252,
	126,
     56,
     21,
      6,
      1,
      0,
      0,
	  0,
      0,
	  0 },

 { 23751,
  20475,
  17550,
  14950,
  12650,
  10626,
   8855,
   7315,
   5985,
   4845,
   3876,
   3060,
   2380,
   1820,
   1365,
   1001,
	715,
    495,
	330,
    210,
    126,
     70,
     35,
     15,
      5,
	  1,
      0,
	  0,
	  0,
	  0 },

  { 3654,
   3276,
   2925,
   2600,
   2300,
   2024,
   1771,
   1540,
   1330,
   1140,
    969,
    816,
	680,
    560,
    455,
    364,
	286,
    220,
	165,
    120,
     84,
	 56,
     35,
     20,
     10,
	  4,
      1,
	  0,
      0,
	  0 },

   {  406,
	378,
	351,
	325,
	300,
	276,
    253,
	231,
	210,
    190,
	171,
    153,
    136,
    120,
    105,
     91,
	 78,
	 66,
     55,
	 45,
     36,
     28,
     21,
     15,
     10,
	  6,
	  3,
	  1,
	  0,
	  0 },

   {   29,
     28,
     27,
	 26,
	 25,
     24,
	 23,
	 22,
     21,
	 20,
     19,
     18,
     17,
	 16,
     15,
     14,
	 13,
     12,
	 11,
     10,
      9,
      8,
	  7,
      6,
      5,
	  4,
      3,
	  2,
      1,
	  0  },

   {    1,
	  1,
	  1,
	  1,
	  1,
	  1,
      1,
      1,
      1,
      1,
      1,
      1,
	  1,
      1,
	  1,
      1,
      1,
      1,
      1,
      1,
      1,
	  1,
      1,
	  1,
      1,
      1,
      1,
      1,
      1,
	  1 }
   };

/*
**  AcbkGainTable085:
**
**  Purpose:
**      Used to calculate the error expression in pitch prediction
**      optimization (also described as an adaptive codebook approach)
**
**      Table Structure:
**      The table is structured as 85 20-element vectors.  These
**      vectors are structured as precalculated values in the error
**      expression for the pitch predictor.  Gi is the gain value
**      multiplying the signal delayed by a pitch period (+/- offset).
**      In equation 41.2, Gi would be equivalent to bij.
**      
**      1st 5 elements:   G1  G2  G3  G4  G5 in Q14
**      2nd 5 elements:  -G1^2  -G2^2  -G3^2  -G4^2  -G5^2
**      Next 10 elements: These are the off-diagonal elements
**           -G1*G2  -G1*G3  -G2*G3  -G1*G4  -G2*G4
**           -G3*G4  -G1*G5  -G2*G5  -G3*G5  -G4*G5
*/

 FLOAT   AcbkGainTable085[85*20] = {
 (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, 
(F)0.048828, (F)0.091309, (F)0.010193, (F)-0.015625, (F)-0.020630, (F)-0.002384, 
(F)-0.008337, (F)-0.000104, (F)-0.000244, (F)-0.000426, (F)-0.004458, (F)-0.000498, 
(F)-0.000931, (F)0.000763, (F)0.001427, (F)0.000159, (F)0.001007, (F)0.001884, 
(F)0.000210, (F)-0.000322, 
(F)-0.028198, (F)-0.041870, (F)0.030090, (F)0.157166, (F)0.018982, (F)-0.000795, 
(F)-0.001753, (F)-0.000905, (F)-0.024701, (F)-0.000360, (F)-0.001181, (F)0.000848, 
(F)0.001260, (F)0.004432, (F)0.006581, (F)-0.004729, (F)0.000535, (F)0.000795, 
(F)-0.000571, (F)-0.002983, 
(F)0.090515, (F)0.008789, (F)0.047852, (F)0.056641, (F)0.075867, (F)-0.008193, 
(F)-0.000077, (F)-0.002290, (F)-0.003208, (F)-0.005756, (F)-0.000796, (F)-0.004331, 
(F)-0.000421, (F)-0.005127, (F)-0.000498, (F)-0.002710, (F)-0.006867, (F)-0.000667, 
(F)-0.003630, (F)-0.004297, 
(F)-0.004700, (F)0.016785, (F)0.214966, (F)0.064453, (F)-0.076538, (F)-0.000022, 
(F)-0.000282, (F)-0.046210, (F)-0.004154, (F)-0.005858, (F)0.000079, (F)0.001010, 
(F)-0.003608, (F)0.000303, (F)-0.001082, (F)-0.013855, (F)-0.000360, (F)0.001285, 
(F)0.016453, (F)0.004933, 
(F)-0.007629, (F)-0.002441, (F)-0.016113, (F)0.023254, (F)0.306824, (F)-0.000058, 
(F)-0.000006, (F)-0.000260, (F)-0.000541, (F)-0.094141, (F)-0.000019, (F)-0.000123, 
(F)-0.000039, (F)0.000177, (F)0.000057, (F)0.000375, (F)0.002341, (F)0.000749, 
(F)0.004944, (F)-0.007135, 
(F)0.008423, (F)0.020264, (F)0.135193, (F)0.157104, (F)0.081726, (F)-0.000071, 
(F)-0.000411, (F)-0.018277, (F)-0.024682, (F)-0.006679, (F)-0.000171, (F)-0.001139, 
(F)-0.002740, (F)-0.001323, (F)-0.003184, (F)-0.021239, (F)-0.000688, (F)-0.001656, 
(F)-0.011049, (F)-0.012840, 
(F)0.224915, (F)0.175964, (F)-0.054138, (F)0.052856, (F)-0.100037, (F)-0.050587, 
(F)-0.030963, (F)-0.002931, (F)-0.002794, (F)-0.010007, (F)-0.039577, (F)0.012176, 
(F)0.009526, (F)-0.011888, (F)-0.009301, (F)0.002862, (F)0.022500, (F)0.017603, 
(F)-0.005416, (F)0.005288, 
(F)0.085205, (F)0.130981, (F)0.136414, (F)0.021057, (F)0.057495, (F)-0.007260, 
(F)-0.017156, (F)-0.018609, (F)-0.000443, (F)-0.003306, (F)-0.011160, (F)-0.011623, 
(F)-0.017868, (F)-0.001794, (F)-0.002758, (F)-0.002872, (F)-0.004899, (F)-0.007531, 
(F)-0.007843, (F)-0.001211, 
(F)0.000793, (F)0.273132, (F)0.216614, (F)-0.049072, (F)-0.039978, (F)-0.000001, 
(F)-0.074601, (F)-0.046922, (F)-0.002408, (F)-0.001598, (F)-0.000217, (F)-0.000172, 
(F)-0.059164, (F)0.000039, (F)0.013403, (F)0.010630, (F)0.000032, (F)0.010919, 
(F)0.008660, (F)-0.001962, 
(F)-0.044189, (F)0.015503, (F)0.014771, (F)0.369202, (F)0.150269, (F)-0.001953, 
(F)-0.000240, (F)-0.000218, (F)-0.136310, (F)-0.022581, (F)0.000685, (F)0.000653, 
(F)-0.000229, (F)0.016315, (F)-0.005724, (F)-0.005453, (F)0.006640, (F)-0.002330, 
(F)-0.002220, (F)-0.055479, 
(F)0.038208, (F)-0.104553, (F)0.373596, (F)0.278381, (F)-0.064758, (F)-0.001460, 
(F)-0.010931, (F)-0.139574, (F)-0.077496, (F)-0.004194, (F)0.003995, (F)-0.014274, 
(F)0.039061, (F)-0.010636, (F)0.029106, (F)-0.104002, (F)0.002474, (F)-0.006771, 
(F)0.024193, (F)0.018028, 
(F)-0.021362, (F)0.084900, (F)0.487366, (F)0.031189, (F)-0.024719, (F)-0.000456, 
(F)-0.007208, (F)-0.237525, (F)-0.000973, (F)-0.000611, (F)0.001814, (F)0.010411, 
(F)-0.041377, (F)0.000666, (F)-0.002648, (F)-0.015200, (F)-0.000528, (F)0.002099, 
(F)0.012047, (F)0.000771, 
(F)0.191895, (F)-0.032288, (F)0.037109, (F)0.154419, (F)0.236694, (F)-0.036824, 
(F)-0.001042, (F)-0.001377, (F)-0.023845, (F)-0.056024, (F)0.006196, (F)-0.007121, 
(F)0.001198, (F)-0.029632, (F)0.004986, (F)-0.005730, (F)-0.045420, (F)0.007642, 
(F)-0.008784, (F)-0.036550, 
(F)0.158020, (F)-0.042053, (F)0.185852, (F)0.341980, (F)-0.024658, (F)-0.024970, 
(F)-0.001768, (F)-0.034541, (F)-0.116950, (F)-0.000608, (F)0.006645, (F)-0.029368, 
(F)0.007816, (F)-0.054040, (F)0.014381, (F)-0.063558, (F)0.003896, (F)-0.001037, 
(F)0.004583, (F)0.008433, 
(F)0.189636, (F)0.031311, (F)0.083862, (F)-0.219360, (F)-0.300415, (F)-0.035962, 
(F)-0.000980, (F)-0.007033, (F)-0.048119, (F)-0.090249, (F)-0.005938, (F)-0.015903, 
(F)-0.002626, (F)0.041599, (F)0.006868, (F)0.018396, (F)0.056970, (F)0.009406, 
(F)0.025193, (F)-0.065899, 
(F)0.150635, (F)0.366821, (F)0.067566, (F)-0.023804, (F)0.119690, (F)-0.022691, 
(F)-0.134558, (F)-0.004565, (F)-0.000567, (F)-0.014326, (F)-0.055256, (F)-0.010178, 
(F)-0.024785, (F)0.003586, (F)0.008732, (F)0.001608, (F)-0.018029, (F)-0.043905, 
(F)-0.008087, (F)0.002849, 
(F)0.291321, (F)0.168823, (F)0.144531, (F)0.296753, (F)-0.246826, (F)-0.084868, 
(F)-0.028501, (F)-0.020889, (F)-0.088062, (F)-0.060923, (F)-0.049182, (F)-0.042105, 
(F)-0.024400, (F)-0.086450, (F)-0.050099, (F)-0.042890, (F)0.071906, (F)0.041670, 
(F)0.035674, (F)0.073246, 
(F)0.101624, (F)-0.114685, (F)0.088074, (F)0.103821, (F)0.522583, (F)-0.010327, 
(F)-0.013153, (F)-0.007757, (F)-0.010779, (F)-0.273093, (F)0.011655, (F)-0.008950, 
(F)0.010101, (F)-0.010551, (F)0.011907, (F)-0.009144, (F)-0.053107, (F)0.059932, 
(F)-0.046026, (F)-0.054255, 
(F)0.165771, (F)0.549988, (F)-0.061462, (F)0.046082, (F)-0.108948, (F)-0.027480, 
(F)-0.302487, (F)-0.003778, (F)-0.002124, (F)-0.011870, (F)-0.091172, (F)0.010189, 
(F)0.033804, (F)-0.007639, (F)-0.025344, (F)0.002832, (F)0.018060, (F)0.059920, 
(F)-0.006696, (F)0.005020, 
(F)-0.166443, (F)0.460693, (F)0.078430, (F)0.057251, (F)0.208740, (F)-0.027703, 
(F)-0.212238, (F)-0.006151, (F)-0.003278, (F)-0.043572, (F)0.076679, (F)0.013054, 
(F)-0.036132, (F)0.009529, (F)-0.026375, (F)-0.004490, (F)0.034743, (F)-0.096165, 
(F)-0.016372, (F)-0.011951, 
(F)0.224426, (F)0.053833, (F)0.247192, (F)0.073364, (F)0.141785, (F)-0.050367, 
(F)-0.002898, (F)-0.061104, (F)-0.005382, (F)-0.020103, (F)-0.012082, (F)-0.055476, 
(F)-0.013307, (F)-0.016465, (F)-0.003949, (F)-0.018135, (F)-0.031820, (F)-0.007633, 
(F)-0.035048, (F)-0.010402, 
(F)0.124878, (F)-0.045959, (F)0.007446, (F)0.616577, (F)0.036804, (F)-0.015594, 
(F)-0.002112, (F)-0.000055, (F)-0.380167, (F)-0.001355, (F)0.005739, (F)-0.000930, 
(F)0.000342, (F)-0.076997, (F)0.028338, (F)-0.004591, (F)-0.004596, (F)0.001692, 
(F)-0.000274, (F)-0.022693, 
(F)0.027405, (F)-0.110779, (F)0.652466, (F)0.236206, (F)-0.032166, (F)-0.000751, 
(F)-0.012272, (F)-0.425712, (F)-0.055793, (F)-0.001035, (F)0.003036, (F)-0.017881, 
(F)0.072279, (F)-0.006473, (F)0.026167, (F)-0.154116, (F)0.000881, (F)-0.003563, 
(F)0.020987, (F)0.007598, 
(F)-0.057434, (F)0.143555, (F)0.308167, (F)0.222778, (F)0.160950, (F)-0.003299, 
(F)-0.020608, (F)-0.094967, (F)-0.049630, (F)-0.025905, (F)0.008245, (F)0.017699, 
(F)-0.044239, (F)0.012795, (F)-0.031981, (F)-0.068653, (F)0.009244, (F)-0.023105, 
(F)-0.049599, (F)-0.035856, 
(F)-0.114685, (F)0.048584, (F)0.190247, (F)0.584045, (F)-0.024658, (F)-0.013153, 
(F)-0.002360, (F)-0.036194, (F)-0.341109, (F)-0.000608, (F)0.005572, (F)0.021818, 
(F)-0.009243, (F)0.066981, (F)-0.028375, (F)-0.111113, (F)-0.002828, (F)0.001198, 
(F)0.004691, (F)0.014402, 
(F)-0.104675, (F)0.124695, (F)-0.127930, (F)0.607056, (F)0.244202, (F)-0.010957, 
(F)-0.015549, (F)-0.016366, (F)-0.368517, (F)-0.059634, (F)0.013052, (F)-0.013391, 
(F)0.015952, (F)0.063544, (F)-0.075697, (F)0.077660, (F)0.025562, (F)-0.030451, 
(F)0.031241, (F)-0.148244, 
(F)-0.352295, (F)-0.037720, (F)-0.239319, (F)0.017334, (F)-0.192566, (F)-0.124112, 
(F)-0.001423, (F)-0.057274, (F)-0.000300, (F)-0.037082, (F)-0.013288, (F)-0.084311, 
(F)-0.009027, (F)0.006107, (F)0.000654, (F)0.004148, (F)-0.067840, (F)-0.007264, 
(F)-0.046085, (F)0.003338, 
(F)0.023315, (F)0.289795, (F)0.488464, (F)-0.125977, (F)0.134155, (F)-0.000544, 
(F)-0.083981, (F)-0.238597, (F)-0.015870, (F)-0.017998, (F)-0.006757, (F)-0.011389, 
(F)-0.141554, (F)0.002937, (F)0.036507, (F)0.061535, (F)-0.003128, (F)-0.038878, 
(F)-0.065530, (F)0.016900, 
(F)-0.052917, (F)0.184021, (F)0.727905, (F)-0.102234, (F)0.057800, (F)-0.002800, 
(F)-0.033864, (F)-0.529846, (F)-0.010452, (F)-0.003341, (F)0.009738, (F)0.038519, 
(F)-0.133950, (F)-0.005410, (F)0.018813, (F)0.074417, (F)0.003059, (F)-0.010636, 
(F)-0.042073, (F)0.005909, 
(F)-0.301086, (F)-0.026367, (F)0.412415, (F)0.230164, (F)0.082520, (F)-0.090653, 
(F)-0.000695, (F)-0.170086, (F)-0.052975, (F)-0.006809, (F)-0.007939, (F)0.124172, 
(F)0.010874, (F)0.069299, (F)0.006069, (F)-0.094923, (F)0.024846, (F)0.002176, 
(F)-0.034032, (F)-0.018993, 
(F)0.009277, (F)0.593628, (F)0.258240, (F)-0.117676, (F)0.090942, (F)-0.000086, 
(F)-0.352394, (F)-0.066688, (F)-0.013848, (F)-0.008271, (F)-0.005507, (F)-0.002396, 
(F)-0.153298, (F)0.001092, (F)0.069856, (F)0.030389, (F)-0.000844, (F)-0.053986, 
(F)-0.023485, (F)0.010702, 
(F)0.153320, (F)0.011780, (F)0.551331, (F)0.327209, (F)-0.192139, (F)-0.023507, 
(F)-0.000139, (F)-0.303965, (F)-0.107066, (F)-0.036917, (F)-0.001806, (F)-0.084530, 
(F)-0.006495, (F)-0.050168, (F)-0.003854, (F)-0.180401, (F)0.029459, (F)0.002263, 
(F)0.105932, (F)0.062870, 
(F)0.516602, (F)0.173584, (F)0.000732, (F)0.033508, (F)0.130127, (F)-0.266877, 
(F)-0.030131, (F)-0.000001, (F)-0.001123, (F)-0.016933, (F)-0.089674, (F)-0.000378, 
(F)-0.000127, (F)-0.017310, (F)-0.005817, (F)-0.000025, (F)-0.067224, (F)-0.022588, 
(F)-0.000095, (F)-0.004360, 
(F)0.130676, (F)-0.158813, (F)0.437378, (F)0.552124, (F)-0.082397, (F)-0.017076, 
(F)-0.025222, (F)-0.191299, (F)-0.304841, (F)-0.006789, (F)0.020753, (F)-0.057155, 
(F)0.069462, (F)-0.072150, (F)0.087685, (F)-0.241487, (F)0.010767, (F)-0.013086, 
(F)0.036039, (F)0.045494, 
(F)-0.014893, (F)0.016968, (F)0.812195, (F)0.074890, (F)-0.009827, (F)-0.000222, 
(F)-0.000288, (F)-0.659660, (F)-0.005609, (F)-0.000097, (F)0.000253, (F)0.012096, 
(F)-0.013781, (F)0.001115, (F)-0.001271, (F)-0.060825, (F)-0.000146, (F)0.000167, 
(F)0.007981, (F)0.000736, 
(F)-0.118835, (F)0.501526, (F)0.382629, (F)0.055969, (F)-0.156189, (F)-0.014122, 
(F)-0.251528, (F)-0.146405, (F)-0.003133, (F)-0.024395, (F)0.059599, (F)0.045470, 
(F)-0.191899, (F)0.006651, (F)-0.028070, (F)-0.021415, (F)-0.018561, (F)0.078333, 
(F)0.059762, (F)0.008742, 
(F)-0.110474, (F)0.125793, (F)-0.169739, (F)0.369629, (F)0.613892, (F)-0.012204, 
(F)-0.015824, (F)-0.028811, (F)-0.136626, (F)-0.376863, (F)0.013897, (F)-0.018752, 
(F)0.021352, (F)0.040834, (F)-0.046497, (F)0.062740, (F)0.067819, (F)-0.077224, 
(F)0.104201, (F)-0.226912, 
(F)0.477722, (F)0.559143, (F)-0.208069, (F)0.150940, (F)-0.092163, (F)-0.228218, 
(F)-0.312641, (F)-0.043293, (F)-0.022783, (F)-0.008494, (F)-0.267115, (F)0.099399, 
(F)0.116340, (F)-0.072107, (F)-0.084397, (F)0.031406, (F)0.044028, (F)0.051532, 
(F)-0.019176, (F)0.013911, 
(F)-0.087280, (F)0.507385, (F)0.582336, (F)-0.180359, (F)0.099243, (F)-0.007618, 
(F)-0.257440, (F)-0.339116, (F)-0.032529, (F)-0.009849, (F)0.044285, (F)0.050826, 
(F)-0.295469, (F)-0.015742, (F)0.091511, (F)0.105030, (F)0.008662, (F)-0.050355, 
(F)-0.057793, (F)0.017899, 
(F)0.172058, (F)-0.259216, (F)0.329041, (F)0.529358, (F)0.168213, (F)-0.029604, 
(F)-0.067193, (F)-0.108268, (F)-0.280220, (F)-0.028296, (F)0.044600, (F)-0.056614, 
(F)0.085293, (F)-0.091080, (F)0.137218, (F)-0.174180, (F)-0.028942, (F)0.043604, 
(F)-0.055349, (F)-0.089045, 
(F)0.008606, (F)0.888184, (F)0.042114, (F)0.015686, (F)-0.006836, (F)-0.000074, 
(F)-0.788870, (F)-0.001774, (F)-0.000246, (F)-0.000047, (F)-0.007644, (F)-0.000362, 
(F)-0.037405, (F)-0.000135, (F)-0.013932, (F)-0.000661, (F)0.000059, (F)0.006072, 
(F)0.000288, (F)0.000107, 
(F)0.728638, (F)-0.113464, (F)0.110229, (F)-0.058716, (F)-0.053955, (F)-0.530913, 
(F)-0.012874, (F)-0.012151, (F)-0.003448, (F)-0.002911, (F)0.082674, (F)-0.080317, 
(F)0.012507, (F)0.042783, (F)-0.006662, (F)0.006472, (F)0.039314, (F)-0.006122, 
(F)0.005947, (F)-0.003168, 
(F)0.227539, (F)0.120972, (F)0.138184, (F)0.279785, (F)0.191101, (F)-0.051774, 
(F)-0.014634, (F)-0.019095, (F)-0.078280, (F)-0.036520, (F)-0.027526, (F)-0.031442, 
(F)-0.016716, (F)-0.063662, (F)-0.033846, (F)-0.038662, (F)-0.043483, (F)-0.023118, 
(F)-0.026407, (F)-0.053467, 
(F)-0.072083, (F)0.046753, (F)0.043945, (F)0.872986, (F)-0.013184, (F)-0.005196, 
(F)-0.002186, (F)-0.001931, (F)-0.762104, (F)-0.000174, (F)0.003370, (F)0.003168, 
(F)-0.002055, (F)0.062927, (F)-0.040815, (F)-0.038364, (F)-0.000950, (F)0.000616, 
(F)0.000579, (F)0.011509, 
(F)-0.267639, (F)0.294556, (F)0.617188, (F)0.095764, (F)0.206787, (F)-0.071631, 
(F)-0.086763, (F)-0.380920, (F)-0.009171, (F)-0.042761, (F)0.078835, (F)0.165184, 
(F)-0.181796, (F)0.025630, (F)-0.028208, (F)-0.059104, (F)0.055344, (F)-0.060910, 
(F)-0.127626, (F)-0.019803, 
(F)-0.027344, (F)0.117920, (F)0.951599, (F)-0.112427, (F)0.040100, (F)-0.000748, 
(F)-0.013905, (F)-0.905541, (F)-0.012640, (F)-0.001608, (F)0.003224, (F)0.026020, 
(F)-0.112212, (F)-0.003074, (F)0.013257, (F)0.106985, (F)0.001096, (F)-0.004729, 
(F)-0.038159, (F)0.004508, 
(F)-0.252747, (F)0.112549, (F)0.241821, (F)0.336731, (F)0.379639, (F)-0.063881, 
(F)-0.012667, (F)-0.058478, (F)-0.113388, (F)-0.144126, (F)0.028446, (F)0.061120, 
(F)-0.027217, (F)0.085108, (F)-0.037899, (F)-0.081429, (F)0.095952, (F)-0.042728, 
(F)-0.091805, (F)-0.127836, 
(F)0.044495, (F)-0.140320, (F)0.900574, (F)0.223206, (F)-0.058105, (F)-0.001980, 
(F)-0.019690, (F)-0.811033, (F)-0.049821, (F)-0.003376, (F)0.006243, (F)-0.040071, 
(F)0.126368, (F)-0.009931, (F)0.031320, (F)-0.201013, (F)0.002585, (F)-0.008153, 
(F)0.052328, (F)0.012969, 
(F)-0.084534, (F)0.354065, (F)0.814148, (F)-0.191467, (F)0.082031, (F)-0.007146, 
(F)-0.125362, (F)-0.662837, (F)-0.036660, (F)-0.006729, (F)0.029930, (F)0.068823, 
(F)-0.288261, (F)-0.016185, (F)0.067792, (F)0.155883, (F)0.006934, (F)-0.029044, 
(F)-0.066786, (F)0.015706, 
(F)0.287476, (F)0.589661, (F)0.065491, (F)-0.150574, (F)0.199829, (F)-0.082642, 
(F)-0.347700, (F)-0.004289, (F)-0.022672, (F)-0.039932, (F)-0.169513, (F)-0.018827, 
(F)-0.038617, (F)0.043286, (F)0.088787, (F)0.009861, (F)-0.057446, (F)-0.117831, 
(F)-0.013087, (F)0.030089, 
(F)0.112488, (F)-0.221191, (F)0.758179, (F)0.421021, (F)-0.095154, (F)-0.012654, 
(F)-0.048926, (F)-0.574835, (F)-0.177258, (F)-0.009054, (F)0.024881, (F)-0.085286, 
(F)0.167703, (F)-0.047360, (F)0.093126, (F)-0.319209, (F)0.010704, (F)-0.021047, 
(F)0.072144, (F)0.040062, 
(F)0.087463, (F)0.146118, (F)0.153015, (F)0.084229, (F)0.535889, (F)-0.007650, 
(F)-0.021351, (F)-0.023414, (F)-0.007094, (F)-0.287177, (F)-0.012780, (F)-0.013383, 
(F)-0.022358, (F)-0.007367, (F)-0.012307, (F)-0.012888, (F)-0.046871, (F)-0.078303, 
(F)-0.081999, (F)-0.045137, 
(F)-0.104492, (F)0.788269, (F)0.359070, (F)-0.134094, (F)0.060486, (F)-0.010919, 
(F)-0.621368, (F)-0.128931, (F)-0.017981, (F)-0.003659, (F)0.082368, (F)0.037520, 
(F)-0.283044, (F)-0.014012, (F)0.105702, (F)0.048149, (F)0.006320, (F)-0.047679, 
(F)-0.021719, (F)0.008111, 
(F)0.919922, (F)0.131714, (F)-0.075989, (F)0.055542, (F)-0.030273, (F)-0.846256, 
(F)-0.017349, (F)-0.005774, (F)-0.003085, (F)-0.000916, (F)-0.121166, (F)0.069904, 
(F)0.010009, (F)-0.051094, (F)-0.007316, (F)0.004221, (F)0.027849, (F)0.003987, 
(F)-0.002300, (F)0.001681, 
(F)0.284119, (F)0.446716, (F)0.300049, (F)0.035767, (F)-0.206360, (F)-0.080723, 
(F)-0.199555, (F)-0.090029, (F)-0.001279, (F)-0.042584, (F)-0.126920, (F)-0.085249, 
(F)-0.134037, (F)-0.010162, (F)-0.015978, (F)-0.010732, (F)0.058631, (F)0.092184, 
(F)0.061918, (F)0.007381, 
(F)0.072693, (F)-0.130615, (F)0.312500, (F)0.823853, (F)-0.086548, (F)-0.005284, 
(F)-0.017060, (F)-0.097656, (F)-0.678733, (F)-0.007491, (F)0.009495, (F)-0.022717, 
(F)0.040817, (F)-0.059888, (F)0.107608, (F)-0.257454, (F)0.006291, (F)-0.011304, 
(F)0.027046, (F)0.071303, 
(F)-0.093384, (F)-0.049866, (F)0.499939, (F)0.587891, (F)-0.088623, (F)-0.008721, 
(F)-0.002487, (F)-0.249939, (F)-0.345615, (F)-0.007854, (F)-0.004657, (F)0.046686, 
(F)0.024930, (F)0.054899, (F)0.029316, (F)-0.293909, (F)-0.008276, (F)-0.004419, 
(F)0.044306, (F)0.052101, 
(F)-0.197510, (F)0.037048, (F)0.103516, (F)-0.128540, (F)0.700989, (F)-0.039010, 
(F)-0.001373, (F)-0.010715, (F)-0.016523, (F)-0.491385, (F)0.007317, (F)0.020445, 
(F)-0.003835, (F)-0.025388, (F)0.004762, (F)0.013306, (F)0.138452, (F)-0.025970, 
(F)-0.072563, (F)0.090105, 
(F)0.195496, (F)-0.116150, (F)-0.051086, (F)0.590759, (F)0.430725, (F)-0.038219, 
(F)-0.013491, (F)-0.002610, (F)-0.348997, (F)-0.185524, (F)0.022707, (F)0.009987, 
(F)-0.005934, (F)-0.115491, (F)0.068617, (F)0.030180, (F)-0.084205, (F)0.050029, 
(F)0.022004, (F)-0.254455, 
(F)0.013000, (F)-0.039978, (F)1.038513, (F)0.037842, (F)-0.023438, (F)-0.000169, 
(F)-0.001598, (F)-1.078510, (F)-0.001432, (F)-0.000549, (F)0.000520, (F)-0.013501, 
(F)0.041518, (F)-0.000492, (F)0.001513, (F)-0.039299, (F)0.000305, (F)-0.000937, 
(F)0.024340, (F)0.000887, 
(F)0.310547, (F)0.002136, (F)-0.203796, (F)0.227417, (F)0.518066, (F)-0.096439, 
(F)-0.000005, (F)-0.041533, (F)-0.051718, (F)-0.268393, (F)-0.000663, (F)0.063288, 
(F)0.000435, (F)-0.070624, (F)-0.000486, (F)0.046347, (F)-0.160884, (F)-0.001107, 
(F)0.105580, (F)-0.117817, 
(F)-0.060303, (F)0.088745, (F)-0.164062, (F)0.917908, (F)0.163696, (F)-0.003636, 
(F)-0.007876, (F)-0.026917, (F)-0.842555, (F)-0.026796, (F)0.005352, (F)-0.009893, 
(F)0.014560, (F)0.055352, (F)-0.081460, (F)0.150594, (F)0.009871, (F)-0.014527, 
(F)0.026856, (F)-0.150258, 
(F)-0.296936, (F)-0.173462, (F)-0.003235, (F)0.335388, (F)0.398132, (F)-0.088171, 
(F)-0.030089, (F)-0.000010, (F)-0.112485, (F)-0.158509, (F)-0.051507, (F)-0.000961, 
(F)-0.000561, (F)0.099589, (F)0.058177, (F)0.001085, (F)0.118220, (F)0.069061, 
(F)0.001288, (F)-0.133529, 
(F)0.187744, (F)0.919739, (F)-0.177856, (F)0.110474, (F)-0.059265, (F)-0.035248, 
(F)-0.845919, (F)-0.031633, (F)-0.012204, (F)-0.003512, (F)-0.172676, (F)0.033392, 
(F)0.163581, (F)-0.020741, (F)-0.101607, (F)0.019648, (F)0.011127, (F)0.054508, 
(F)-0.010541, (F)0.006547, 
(F)0.080017, (F)0.326843, (F)0.674683, (F)0.140320, (F)-0.223022, (F)-0.006403, 
(F)-0.106827, (F)-0.455197, (F)-0.019690, (F)-0.049739, (F)-0.026153, (F)-0.053986, 
(F)-0.220515, (F)-0.011228, (F)-0.045863, (F)-0.094671, (F)0.017846, (F)0.072893, 
(F)0.150469, (F)0.031294, 
(F)0.246277, (F)0.342957, (F)0.281860, (F)0.110779, (F)0.116699, (F)-0.060652, 
(F)-0.117619, (F)-0.079445, (F)-0.012272, (F)-0.013619, (F)-0.084462, (F)-0.069416, 
(F)-0.096666, (F)-0.027282, (F)-0.037992, (F)-0.031224, (F)-0.028740, (F)-0.040023, 
(F)-0.032893, (F)-0.012928, 
(F)-0.130066, (F)0.168091, (F)-0.274719, (F)0.786072, (F)0.453613, (F)-0.016917, 
(F)-0.028255, (F)-0.075471, (F)-0.617909, (F)-0.205765, (F)0.021863, (F)-0.035732, 
(F)0.046178, (F)0.102241, (F)-0.132131, (F)0.215949, (F)0.059000, (F)-0.076248, 
(F)0.124616, (F)-0.356573, 
(F)0.342896, (F)-0.031433, (F)0.196472, (F)-0.253235, (F)0.296448, (F)-0.117577, 
(F)-0.000988, (F)-0.038601, (F)-0.064128, (F)-0.087881, (F)0.010778, (F)-0.067369, 
(F)0.006176, (F)0.086833, (F)-0.007960, (F)0.049754, (F)-0.101651, (F)0.009318, 
(F)-0.058244, (F)0.075071, 
(F)0.112183, (F)-0.104309, (F)0.069519, (F)1.029480, (F)0.043701, (F)-0.012585, 
(F)-0.010880, (F)-0.004833, (F)-1.059829, (F)-0.001910, (F)0.011702, (F)-0.007799, 
(F)0.007251, (F)-0.115490, (F)0.107384, (F)-0.071568, (F)-0.004903, (F)0.004558, 
(F)-0.003038, (F)-0.044989, 
(F)0.120728, (F)-0.234680, (F)0.613403, (F)0.723511, (F)-0.152100, (F)-0.014575, 
(F)-0.055075, (F)-0.376264, (F)-0.523468, (F)-0.023134, (F)0.028332, (F)-0.074055, 
(F)0.143954, (F)-0.087348, (F)0.169794, (F)-0.443804, (F)0.018363, (F)-0.035695, 
(F)0.093298, (F)0.110046, 
(F)-0.158691, (F)0.686401, (F)0.689026, (F)-0.222595, (F)0.089294, (F)-0.025183, 
(F)-0.471147, (F)-0.474757, (F)-0.049549, (F)-0.007973, (F)0.108926, (F)0.109342, 
(F)-0.472948, (F)-0.035324, (F)0.152790, (F)0.153374, (F)0.014170, (F)-0.061292, 
(F)-0.061526, (F)0.019877, 
(F)0.210083, (F)0.055359, (F)0.166321, (F)0.547485, (F)0.222046, (F)-0.044135, 
(F)-0.003065, (F)-0.027663, (F)-0.299740, (F)-0.049304, (F)-0.011630, (F)-0.034941, 
(F)-0.009207, (F)-0.115017, (F)-0.030308, (F)-0.091058, (F)-0.046648, (F)-0.012292, 
(F)-0.036931, (F)-0.121567, 
(F)-0.007690, (F)1.067993, (F)0.212463, (F)-0.122253, (F)0.066528, (F)-0.000059, 
(F)-1.140609, (F)-0.045141, (F)-0.014946, (F)-0.004426, (F)0.008213, (F)0.001634, 
(F)-0.226909, (F)-0.000940, (F)0.130566, (F)0.025974, (F)0.000512, (F)-0.071052, 
(F)-0.014135, (F)0.008133, 
(F)-0.110718, (F)0.063965, (F)-0.132080, (F)0.248413, (F)0.993164, (F)-0.012258, 
(F)-0.004092, (F)-0.017445, (F)-0.061709, (F)-0.986375, (F)0.007082, (F)-0.014624, 
(F)0.008448, (F)0.027504, (F)-0.015890, (F)0.032810, (F)0.109961, (F)-0.063528, 
(F)0.131177, (F)-0.246715, 
(F)0.570923, (F)0.767822, (F)-0.114929, (F)0.058716, (F)-0.037659, (F)-0.325953, 
(F)-0.589551, (F)-0.013209, (F)-0.003448, (F)-0.001418, (F)-0.438367, (F)0.065616, 
(F)0.088245, (F)-0.033522, (F)-0.045083, (F)0.006748, (F)0.021500, (F)0.028915, 
(F)-0.004328, (F)0.002211, 
(F)0.104248, (F)0.256287, (F)0.450867, (F)0.386658, (F)0.061218, (F)-0.010868, 
(F)-0.065683, (F)-0.203281, (F)-0.149504, (F)-0.003748, (F)-0.026717, (F)-0.047002, 
(F)-0.115551, (F)-0.040308, (F)-0.099095, (F)-0.174331, (F)-0.006382, (F)-0.015689, 
(F)-0.027601, (F)-0.023671, 
(F)-0.160156, (F)0.343201, (F)1.056519, (F)-0.143616, (F)0.036133, (F)-0.025650, 
(F)-0.117787, (F)-1.116231, (F)-0.020625, (F)-0.001306, (F)0.054966, (F)0.169208, 
(F)-0.362598, (F)-0.023001, (F)0.049289, (F)0.151733, (F)0.005787, (F)-0.012401, 
(F)-0.038175, (F)0.005189, 
(F)0.073914, (F)-0.051880, (F)0.072815, (F)-0.117554, (F)0.976074, (F)-0.005463, 
(F)-0.002692, (F)-0.005302, (F)-0.013819, (F)-0.952721, (F)0.003835, (F)-0.005382, 
(F)0.003778, (F)0.008689, (F)-0.006099, (F)0.008560, (F)-0.072145, (F)0.050639, 
(F)-0.071073, (F)0.114741, 
(F)0.243103, (F)-0.125366, (F)0.702271, (F)-0.001160, (F)0.221069, (F)-0.059099, 
(F)-0.015717, (F)-0.493184, (F)-0.000001, (F)-0.048872, (F)0.030477, (F)-0.170724, 
(F)0.088041, (F)0.000282, (F)-0.000145, (F)0.000814, (F)-0.053743, (F)0.027715, 
(F)-0.155250, (F)0.000256, 
(F)-0.047974, (F)-0.082642, (F)0.982178, (F)0.442261, (F)-0.101624, (F)-0.002301, 
(F)-0.006830, (F)-0.964673, (F)-0.195595, (F)-0.010327, (F)-0.003965, (F)0.047119, 
(F)0.081169, (F)0.021217, (F)0.036549, (F)-0.434379, (F)-0.004875, (F)-0.008398, 
(F)0.099812, (F)0.044944, 
(F)-0.263428, (F)-0.031189, (F)0.407349, (F)0.711975, (F)0.282776, (F)-0.069394, 
(F)-0.000973, (F)-0.165933, (F)-0.506909, (F)-0.079962, (F)-0.008216, (F)0.107307, 
(F)0.012705, (F)0.187554, (F)0.022206, (F)-0.290022, (F)0.074491, (F)0.008819, 
(F)-0.115188, (F)-0.201329, 
(F)0.482910, (F)0.278137, (F)0.118225, (F)0.115051, (F)0.429504, (F)-0.233202, 
(F)-0.077360, (F)-0.013977, (F)-0.013237, (F)-0.184474, (F)-0.134315, (F)-0.057092, 
(F)-0.032883, (F)-0.055559, (F)-0.032000, (F)-0.013602, (F)-0.207412, (F)-0.119461, 
(F)-0.050778, (F)-0.049415, 
(F)0.209595, (F)0.181091, (F)0.358093, (F)0.500244, (F)0.535034, (F)-0.043930, 
(F)-0.032794, (F)-0.128231, (F)-0.250244, (F)-0.286262, (F)-0.037956, (F)-0.075054, 
(F)-0.064848, (F)-0.104849, (F)-0.090590, (F)-0.179134, (F)-0.112140, (F)-0.096890, 
(F)-0.191592, (F)-0.267648, 
(F)0.358948, (F)0.560059, (F)0.495544, (F)0.240112, (F)0.204773, (F)-0.128843, 
(F)-0.313666, (F)-0.245564, (F)-0.057654, (F)-0.041932, (F)-0.201032, (F)-0.177875, 
(F)-0.277534, (F)-0.086188, (F)-0.134477, (F)-0.118986, (F)-0.073503, (F)-0.114685, 
(F)-0.101474, (F)-0.049169 }; 

#if COMPILE_MMX

 short AcbkGainTable085Int[85*20] = {
     0,      0,      0,      0,      0,      0,      0,      0, 
     0,      0,      0,      0,      0,      0,      0,      0, 
     0,      0,      0,      0,    800,   1496,    167,   -256, 
  -338,    -39,   -136,     -1,     -4,     -6,    -73,     -8, 
   -15,     12,     23,      2,     16,     30,      3,     -5, 
  -462,   -686,    493,   2575,    311,    -13,    -28,    -14, 
  -404,     -5,    -19,     13,     20,     72,    107,    -77, 
     8,     13,     -9,    -48,   1483,    144,    784,    928,
  1243,   -134,     -1,    -37,    -52,    -94,    -13,    -71, 
    -6,    -84,     -8,    -44,   -112,    -10,    -59,    -70, 
   -77,    275,   3522,   1056,  -1254,      0,     -4,   -757, 
   -68,    -95,      1,     16,    -59,      4,    -17,   -227, 
    -5,     21,    269,     80,   -125,    -40,   -264,    381, 
  5027,      0,      0,     -4,     -8,  -1542,      0,     -2, 
     0,      2,      0,      6,     38,     12,     81,   -117, 
   138,    332,   2215,   2574,   1339,     -1,     -6,   -299, 
  -404,   -109,     -2,    -18,    -44,    -21,    -52,   -348,
   -11,    -27,   -181,   -210,   3685,   2883,   -887,    866, 
 -1639,   -828,   -507,    -48,    -45,   -164,   -648,    199, 
   156,   -194,   -152,     46,    368,    288,    -88,     86, 
  1396,   2146,   2235,    345,    942,   -118,   -281,   -305, 
    -7,    -54,   -182,   -190,   -292,    -29,    -45,    -47, 
   -80,   -123,   -128,    -19,     13,   4475,   3549,   -804, 
  -655,      0,  -1222,   -768,    -39,    -26,     -3,     -2, 
  -969,      0,    219,    174,      0,    179,    141,    -32, 
  -724,    254,    242,   6049,   2462,    -32,     -3,     -3, 
 -2233,   -370,     11,     10,     -3,    267,    -94,    -89, 
   108,    -38,    -36,   -909,    626,  -1713,   6121,   4561, 
 -1061,    -23,   -179,  -2287,  -1270,    -68,     65,   -233, 
   640,   -174,    477,  -1704,     40,   -111,    396,    295, 
  -350,   1391,   7985,    511,   -405,     -7,   -118,  -3892, 
   -15,    -10,     29,    170,   -678,     10,    -43,   -249, 
    -8,     34,    197,     12,   3144,   -529,    608,   2530, 
  3878,   -603,    -17,    -22,   -390,   -918,    101,   -116, 
    19,   -485,     81,    -93,   -744,    125,   -144,   -599, 
  2589,   -689,   3045,   5603,   -404,   -409,    -29,   -566, 
 -1916,    -10,    108,   -481,    128,   -885,    235,  -1041, 
    63,    -17,     75,    138,   3107,    513,   1374,  -3594, 
 -4922,   -589,    -16,   -115,   -788,  -1478,    -97,   -260, 
   -43,    681,    112,    301,    933,    154,    413,  -1079, 
  2468,   6010,   1107,   -390,   1961,   -372,  -2204,    -74, 
    -9,   -234,   -905,   -166,   -406,     58,    143,     26, 
  -295,   -719,   -132,     46,   4773,   2766,   2368,   4862, 
 -4044,  -1390,   -467,   -342,  -1443,   -998,   -806,   -690, 
  -399,  -1416,   -821,   -702,   1178,    682,    584,   1200, 
  1665,  -1879,   1443,   1701,   8562,   -169,   -215,   -127, 
  -176,  -4475,    190,   -146,    165,   -172,    195,   -149, 
  -870,    982,   -754,   -889,   2716,   9011,  -1007,    755, 
 -1785,   -450,  -4956,    -61,    -34,   -194,  -1493,    167, 
   554,   -125,   -415,     46,    296,    982,   -109,     82, 
 -2727,   7548,   1285,    938,   3420,   -453,  -3478,   -100, 
   -53,   -714,   1256,    213,   -592,    156,   -432,    -73, 
   569,  -1576,   -268,   -196,   3677,    882,   4050,   1202, 
  2323,   -825,    -47,  -1001,    -88,   -329,   -198,   -909, 
  -218,   -269,    -64,   -297,   -521,   -125,   -574,   -170, 
  2046,   -753,    122,  10102,    603,   -255,    -34,      0, 
 -6229,    -22,     94,    -15,      5,  -1261,    464,    -75, 
   -75,     27,     -4,   -372,    449,  -1815,  10690,   3870, 
  -527,    -12,   -201,  -6976,   -914,    -16,     49,   -293, 
  1184,   -106,    428,  -2525,     14,    -58,    344,    124, 
  -941,   2352,   5049,   3650,   2637,    -54,   -337,  -1556, 
  -813,   -424,    135,    290,   -725,    209,   -524,  -1125, 
   151,   -378,   -812,   -587,  -1879,    796,   3117,   9569, 
  -404,   -215,    -38,   -593,  -5589,     -9,     91,    357, 
  -151,   1097,   -464,  -1821,    -46,     19,     76,    236, 
 -1715,   2043,  -2096,   9946,   4001,   -179,   -254,   -268, 
 -6038,   -977,    213,   -219,    261,   1041,  -1240,   1272, 
   418,   -498,    511,  -2429,  -5772,   -618,  -3921,    284, 
 -3155,  -2033,    -23,   -938,     -4,   -607,   -218,  -1381, 
  -148,    100,     10,     68,  -1111,   -119,   -755,     54, 
   382,   4748,   8003,  -2064,   2198,     -8,  -1376,  -3909, 
  -260,   -294,   -110,   -186,  -2319,     48,    598,   1008, 
   -51,   -637,  -1073,    277,   -867,   3015,  11926,  -1675, 
   947,    -45,   -555,  -8681,   -171,    -54,    159,    631, 
 -2195,    -88,    308,   1219,     50,   -174,   -690,     96, 
 -4933,   -432,   6757,   3771,   1352,  -1485,    -11,  -2786, 
  -867,   -111,   -130,   2034,    178,   1135,     99,  -1555, 
   407,     35,   -557,   -311,    152,   9726,   4231,  -1928, 
  1490,     -1,  -5774,  -1092,   -226,   -135,    -90,    -39, 
 -2511,     17,   1144,    498,    -13,   -884,   -384,    175, 
  2512,    193,   9033,   5361,  -3148,   -385,     -2,  -4980, 
 -1754,   -605,    -29,  -1385,   -106,   -822,    -63,  -2956, 
   482,     37,   1735,   1030,   8464,   2844,     12,    549, 
  2132,  -4373,   -493,      0,    -18,   -277,  -1469,     -6, 
    -2,   -284,    -95,      0,  -1101,   -370,     -1,    -71, 
  2141,  -2602,   7166,   9046,  -1350,   -279,   -413,  -3134, 
 -4994,   -111,    340,   -936,   1138,  -1182,   1436,  -3957, 
   176,   -214,    590,    745,   -244,    278,  13307,   1227, 
  -161,     -3,     -4, -10808,    -91,     -1,      4,    198, 
  -226,     18,    -20,   -997,     -2,      2,    131,     12, 
 -1947,   8217,   6269,    917,  -2559,   -231,  -4121,  -2399, 
   -51,   -399,    976,    745,  -3144,    108,   -460,   -350, 
  -304,   1283,    979,    143,  -1810,   2061,  -2781,   6056, 
 10058,   -200,   -259,   -472,  -2238,  -6174,    227,   -307, 
   349,    669,   -761,   1028,   1111,  -1265,   1707,  -3717, 
  7827,   9161,  -3409,   2473,  -1510,  -3739,  -5122,   -709, 
  -373,   -139,  -4376,   1628,   1906,  -1181,  -1382,    514, 
   721,    844,   -314,    228,  -1430,   8313,   9541,  -2955, 
  1626,   -124,  -4218,  -5556,   -533,   -161,    725,    832, 
 -4841,   -257,   1499,   1721,    142,   -825,   -947,    293, 
  2819,  -4247,   5391,   8673,   2756,   -485,  -1101,  -1774, 
 -4591,   -463,    730,   -927,   1397,  -1492,   2248,  -2854, 
  -474,    714,   -907,  -1459,    141,  14552,    690,    257, 
  -112,     -1, -12926,    -29,     -4,      0,   -125,     -5, 
  -613,     -2,   -228,    -10,      0,     99,      4,      1, 
 11938,  -1859,   1806,   -962,   -884,  -8699,   -211,   -199, 
   -56,    -47,   1355,  -1316,    205,    701,   -109,    106, 
   644,   -100,     97,    -51,   3728,   1982,   2264,   4584, 
  3131,   -848,   -239,   -312,  -1282,   -598,   -451,   -515, 
  -273,  -1043,   -554,   -633,   -712,   -378,   -432,   -876, 
 -1181,    766,    720,  14303,   -216,    -85,    -35,    -31, 
-12486,     -2,     55,     51,    -33,   1031,   -668,   -628, 
   -15,     10,      9,    189,  -4385,   4826,  10112,   1569, 
  3388,  -1173,  -1421,  -6242,   -150,   -700,   1291,   2706, 
 -2979,    420,   -462,   -969,    906,   -998,  -2091,   -324, 
  -448,   1932,  15591,  -1842,    657,    -12,   -227, -14837, 
  -207,    -26,     52,    427,  -1838,    -50,    217,   1753, 
    18,    -77,   -626,     74,  -4141,   1844,   3962,   5517, 
  6220,  -1046,   -207,   -958,  -1858,  -2361,    466,   1001, 
  -446,   1394,   -621,  -1334,   1572,   -700,  -1504,  -2094, 
   729,  -2299,  14755,   3657,   -952,    -32,   -322, -13288, 
  -816,    -55,    102,   -656,   2071,   -162,    513,  -3294, 
    42,   -133,    857,    212,  -1385,   5801,  13339,  -3137, 
  1344,   -117,  -2054, -10861,   -600,   -110,    490,   1127, 
 -4723,   -265,   1111,   2554,    113,   -476,  -1094,    257, 
  4710,   9661,   1073,  -2467,   3274,  -1354,  -5697,    -70, 
  -371,   -654,  -2777,   -308,   -633,    709,   1455,    161, 
  -941,  -1930,   -214,    493,   1843,  -3624,  12422,   6898, 
 -1559,   -207,   -802,  -9419,  -2904,   -148,    407,  -1397, 
  2748,   -775,   1526,  -5230,    175,   -344,   1182,    656, 
  1433,   2394,   2507,   1380,   8780,   -125,   -349,   -383, 
  -116,  -4705,   -209,   -219,   -366,   -120,   -201,   -211, 
  -768,  -1283,  -1343,   -740,  -1712,  12915,   5883,  -2197, 
   991,   -179, -10181,  -2112,   -294,    -60,   1350,    615, 
 -4638,   -229,   1732,    789,    103,   -781,   -356,    133, 
 15072,   2158,  -1245,    910,   -496, -13865,   -284,    -94, 
   -50,    -15,  -1986,   1145,    164,   -837,   -119,     69, 
   456,     65,    -37,     27,   4655,   7319,   4916,    586, 
 -3381,  -1322,  -3270,  -1475,    -20,   -697,  -2079,  -1396, 
 -2196,   -166,   -261,   -175,    960,   1510,   1014,    120, 
  1191,  -2140,   5120,  13498,  -1418,    -86,   -279,  -1600, 
-11121,   -122,    155,   -372,    669,   -981,   1763,  -4218, 
   103,   -185,    443,   1168,  -1530,   -817,   8191,   9632, 
 -1452,   -143,    -40,  -4095,  -5663,   -128,    -76,    765, 
   408,    900,    480,  -4815,   -135,    -72,    726,    854, 
 -3236,    607,   1696,  -2106,  11485,   -639,    -22,   -175, 
  -270,  -8051,    119,    335,    -62,   -416,     78,    218, 
  2268,   -425,  -1189,   1476,   3203,  -1903,   -837,   9679, 
  7057,   -626,   -221,    -42,  -5718,  -3039,    372,    163, 
   -97,  -1892,   1124,    494,  -1380,    819,    360,  -4169, 
   213,   -655,  17015,    620,   -384,     -2,    -26, -17671, 
   -23,     -9,      8,   -221,    681,     -8,     24,   -644, 
     5,    -15,    399,     14,   5088,     35,  -3339,   3726, 
  8488,  -1580,      0,   -680,   -847,  -4397,    -10,   1037, 
     7,  -1157,     -8,    759,  -2636,    -18,   1730,  -1930, 
  -988,   1454,  -2688,  15039,   2682,    -59,   -129,   -441, 
-13805,   -439,     87,   -162,    238,    907,  -1335,   2467, 
   161,   -238,    440,  -2462,  -4865,  -2842,    -53,   5495, 
  6523,  -1445,   -493,      0,  -1843,  -2597,   -844,    -16, 
    -9,   1632,    953,     18,   1937,   1131,     21,  -2188, 
  3076,  15069,  -2914,   1810,   -971,   -577, -13860,   -518, 
  -200,    -57,  -2829,    547,   2680,   -339,  -1665,    322, 
   182,    893,   -172,    107,   1311,   5355,  11054,   2299, 
 -3654,   -105,  -1750,  -7458,   -322,   -814,   -428,   -885, 
 -3613,   -184,   -751,  -1551,    292,   1194,   2465,    512, 
  4035,   5619,   4618,   1815,   1912,   -994,  -1927,  -1301, 
  -201,   -223,  -1384,  -1137,  -1583,   -447,   -622,   -511, 
  -471,   -656,   -539,   -211,  -2131,   2754,  -4501,  12879, 
  7432,   -277,   -463,  -1236, -10124,  -3371,    358,   -585, 
   756,   1675,  -2165,   3538,    967,  -1249,   2042,  -5842, 
  5618,   -515,   3219,  -4149,   4857,  -1926,    -16,   -632, 
 -1050,  -1440,    176,  -1104,    101,   1422,   -130,    815, 
 -1666,    152,   -954,   1230,   1838,  -1709,   1139,  16867, 
   716,   -206,   -178,    -79, -17366,    -31,    191,   -127, 
   118,  -1892,   1759,  -1173,    -80,     74,    -49,   -737, 
  1978,  -3845,  10050,  11854,  -2492,   -238,   -902,  -6164, 
 -8576,   -379,    464,  -1213,   2358,  -1431,   2782,  -7271, 
   301,   -585,   1529,   1803,  -2600,  11246,  11289,  -3647, 
  1463,   -412,  -7720,  -7778,   -812,   -130,   1784,   1791, 
 -7749,   -578,   2504,   2513,    232,  -1004,  -1008,    325, 
  3442,    907,   2725,   8970,   3638,   -723,    -50,   -453, 
 -4911,   -808,   -190,   -572,   -150,  -1884,   -496,  -1492, 
  -764,   -201,   -605,  -1992,   -126,  17498,   3481,  -2003, 
  1090,      0, -18689,   -739,   -244,    -72,    135,     26, 
 -3717,    -15,   2139,    425,      8,  -1165,   -231,    133, 
 -1814,   1048,  -2164,   4070,  16272,   -200,    -67,   -285, 
 -1011, -16160,    116,   -239,    138,    450,   -260,    537, 
  1801,  -1041,   2149,  -4042,   9354,  12580,  -1883,    962, 
  -617,  -5341,  -9660,   -216,    -56,    -23,  -7183,   1075, 
  1446,   -549,   -738,    110,    352,    474,    -71,     36, 
  1708,   4199,   7387,   6335,   1003,   -178,  -1076,  -3330, 
 -2449,    -61,   -437,   -770,  -1893,   -660,  -1623,  -2856, 
  -104,   -257,   -452,   -388,  -2624,   5623,  17310,  -2353, 
   592,   -420,  -1930, -18288,   -338,    -21,    900,   2772, 
 -5941,   -376,    807,   2486,     94,   -203,   -625,     85, 
  1211,   -850,   1193,  -1926,  15992,    -89,    -44,    -86, 
  -226, -15609,     62,    -88,     61,    142,   -100,    140, 
 -1182,    830,  -1165,   1880,   3983,  -2054,  11506,    -19, 
  3622,   -968,   -257,  -8080,      0,   -801,    499,  -2797, 
  1442,      4,     -2,     13,   -880,    454,  -2544,      4, 
  -786,  -1354,  16092,   7246,  -1665,    -37,   -111, -15805, 
 -3205,   -169,    -65,    772,   1330,    348,    599,  -7117, 
   -80,   -137,   1636,    736,  -4316,   -511,   6674,  11665, 
  4633,  -1137,    -15,  -2719,  -8305,  -1310,   -134,   1758, 
   208,   3073,    364,  -4752,   1220,    144,  -1887,  -3299, 
  7912,   4557,   1937,   1885,   7037,  -3821,  -1267,   -229, 
  -216,  -3022,  -2200,   -935,   -538,   -910,   -524,   -222, 
 -3398,  -1957,   -832,   -809,   3434,   2967,   5867,   8196, 
  8766,   -720,   -537,  -2101,  -4100,  -4690,   -622,  -1230, 
 -1062,  -1718,  -1484,  -2935,  -1837,  -1588,  -3139,  -4385, 
  5881,   9176,   8119,   3934,   3355,  -2111,  -5139,  -4023, 
  -944,   -687,  -3294,  -2914,  -4547,  -1412,  -2203,  -1949, 
 -1204,  -1879,  -1662,   -805 };

#endif

/*
**  AcbkGainTable170:
**
**  Purpose:
**      Used to calculate the error expression in pitch prediction
**      optimization (also expressed as an adaptive codebook approach)
**
**  Table Structure:
**      The table is structured as 170 20-element vectors.  These
**      vectors are structured as precalculated values in the error
**      expression for the pitch
**      predictor.  Gi is the gain value multiplying the signal
**      delayed by a pitch period (+/- offset).  In equation 41.2,
**      Gi would be equivalent to bij.
**
**      1st 5 elements:   G1  G2  G3  G4  G5 in Q14
**      2nd 5 elements:  -G1^2  -G2^2  -G3^2  -G4^2  -G5^2
**      Next 10 elements: These are the off-diagonal elements
**           -G1*G2  -G1*G3  -G2*G3  -G1*G4  -G2*G4
**           -G3*G4  -G1*G5  -G2*G5  -G3*G5  -G4*G5
*/

 FLOAT   AcbkGainTable170[170*20] = {
 (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, 
(F)0.047363, (F)0.012939, (F)0.043640, (F)0.040894, (F)0.049377, (F)-0.002243, 
(F)-0.000167, (F)-0.001904, (F)-0.001672, (F)-0.002438, (F)-0.000613, (F)-0.002067, 
(F)-0.000565, (F)-0.001937, (F)-0.000529, (F)-0.001785, (F)-0.002339, (F)-0.000639, 
(F)-0.002155, (F)-0.002019, 
(F)0.079102, (F)0.080322, (F)-0.010254, (F)-0.019531, (F)-0.049744, (F)-0.006257, 
(F)-0.006452, (F)-0.000105, (F)-0.000381, (F)-0.002474, (F)-0.006354, (F)0.000811, 
(F)0.000824, (F)0.001545, (F)0.001569, (F)-0.000200, (F)0.003935, (F)0.003996, 
(F)-0.000510, (F)-0.000972, 
(F)-0.035950, (F)0.041504, (F)0.151245, (F)0.018799, (F)-0.036377, (F)-0.001292, 
(F)-0.001723, (F)-0.022875, (F)-0.000353, (F)-0.001323, (F)0.001492, (F)0.005437, 
(F)-0.006277, (F)0.000676, (F)-0.000780, (F)-0.002843, (F)-0.001308, (F)0.001510, 
(F)0.005502, (F)0.000684, 
(F)-0.044861, (F)-0.029724, (F)-0.000305, (F)0.179932, (F)0.028564, (F)-0.002012, 
(F)-0.000884, (F)0.000000, (F)-0.032375, (F)-0.000816, (F)-0.001333, (F)-0.000014, 
(F)-0.000009, (F)0.008072, (F)0.005348, (F)0.000055, (F)0.001281, (F)0.000849, 
(F)0.000009, (F)-0.005140, 
(F)0.063599, (F)0.105591, (F)0.065186, (F)0.020325, (F)0.038208, (F)-0.004045, 
(F)-0.011149, (F)-0.004249, (F)-0.000413, (F)-0.001460, (F)-0.006715, (F)-0.004146, 
(F)-0.006883, (F)-0.001293, (F)-0.002146, (F)-0.001325, (F)-0.002430, (F)-0.004034, 
(F)-0.002491, (F)-0.000777, 
(F)0.029663, (F)-0.046936, (F)0.248657, (F)0.172424, (F)-0.067566, (F)-0.000880, 
(F)-0.002203, (F)-0.061830, (F)-0.029730, (F)-0.004565, (F)0.001392, (F)-0.007376, 
(F)0.011671, (F)-0.005115, (F)0.008093, (F)-0.042875, (F)0.002004, (F)-0.003171, 
(F)0.016801, (F)0.011650, 
(F)0.092834, (F)-0.046814, (F)-0.007568, (F)0.263672, (F)0.062622, (F)-0.008618, 
(F)-0.002192, (F)-0.000057, (F)-0.069523, (F)-0.003922, (F)0.004346, (F)0.000703, 
(F)-0.000354, (F)-0.024478, (F)0.012344, (F)0.001996, (F)-0.005813, (F)0.002932, 
(F)0.000474, (F)-0.016512, 
(F)0.148010, (F)0.077332, (F)0.209900, (F)-0.005554, (F)-0.071167, (F)-0.021907, 
(F)-0.005980, (F)-0.044058, (F)-0.000031, (F)-0.005065, (F)-0.011446, (F)-0.031067, 
(F)-0.016232, (F)0.000822, (F)0.000430, (F)0.001166, (F)0.010533, (F)0.005503, 
(F)0.014938, (F)-0.000395, 
(F)-0.076355, (F)0.059509, (F)0.010559, (F)0.246521, (F)0.122375, (F)-0.005830, 
(F)-0.003541, (F)-0.000111, (F)-0.060773, (F)-0.014976, (F)0.004544, (F)0.000806, 
(F)-0.000628, (F)0.018823, (F)-0.014670, (F)-0.002603, (F)0.009344, (F)-0.007282, 
(F)-0.001292, (F)-0.030168, 
(F)0.111084, (F)0.038574, (F)0.080688, (F)0.125854, (F)0.062927, (F)-0.012340, 
(F)-0.001488, (F)-0.006511, (F)-0.015839, (F)-0.003960, (F)-0.004285, (F)-0.008963, 
(F)-0.003112, (F)-0.013980, (F)-0.004855, (F)-0.010155, (F)-0.006990, (F)-0.002427, 
(F)-0.005078, (F)-0.007920, 
(F)-0.027283, (F)0.299316, (F)0.014893, (F)-0.019226, (F)-0.124390, (F)-0.000744, 
(F)-0.089590, (F)-0.000222, (F)-0.000370, (F)-0.015473, (F)0.008166, (F)0.000406, 
(F)-0.004458, (F)-0.000525, (F)0.005755, (F)0.000286, (F)-0.003394, (F)0.037232, 
(F)0.001852, (F)-0.002392, 
(F)-0.012695, (F)-0.067261, (F)0.028259, (F)-0.027344, (F)0.345032, (F)-0.000161, 
(F)-0.004524, (F)-0.000799, (F)-0.000748, (F)-0.119047, (F)-0.000854, (F)0.000359, 
(F)0.001901, (F)-0.000347, (F)-0.001839, (F)0.000773, (F)0.004380, (F)0.023207, 
(F)-0.009750, (F)0.009434, 
(F)0.289246, (F)0.158691, (F)-0.113770, (F)0.052246, (F)-0.094849, (F)-0.083663, 
(F)-0.025183, (F)-0.012944, (F)-0.002730, (F)-0.008996, (F)-0.045901, (F)0.032907, 
(F)0.018054, (F)-0.015112, (F)-0.008291, (F)0.005944, (F)0.027435, (F)0.015052, 
(F)-0.010791, (F)0.004955, 
(F)0.115601, (F)0.215637, (F)0.002136, (F)-0.001587, (F)0.130920, (F)-0.013363, 
(F)-0.046499, (F)-0.000005, (F)-0.000003, (F)-0.017140, (F)-0.024928, (F)-0.000247, 
(F)-0.000461, (F)0.000183, (F)0.000342, (F)0.000003, (F)-0.015134, (F)-0.028231, 
(F)-0.000280, (F)0.000208, 
(F)-0.164734, (F)0.112366, (F)0.248535, (F)0.149109, (F)0.096558, (F)-0.027137, 
(F)-0.012626, (F)-0.061770, (F)-0.022233, (F)-0.009323, (F)0.018510, (F)0.040942, 
(F)-0.027927, (F)0.024563, (F)-0.016755, (F)-0.037059, (F)0.015906, (F)-0.010850, 
(F)-0.023998, (F)-0.014398, 
(F)-0.051514, (F)0.204956, (F)0.372681, (F)-0.064636, (F)-0.032776, (F)-0.002654, 
(F)-0.042007, (F)-0.138891, (F)-0.004178, (F)-0.001074, (F)0.010558, (F)0.019198, 
(F)-0.076383, (F)-0.003330, (F)0.013248, (F)0.024089, (F)-0.001688, (F)0.006718, 
(F)0.012215, (F)-0.002119, 
(F)0.076355, (F)0.062012, (F)0.184326, (F)0.134888, (F)0.088196, (F)-0.005830, 
(F)-0.003845, (F)-0.033976, (F)-0.018195, (F)-0.007778, (F)-0.004735, (F)-0.014074, 
(F)-0.011430, (F)-0.010299, (F)-0.008365, (F)-0.024863, (F)-0.006734, (F)-0.005469, 
(F)-0.016257, (F)-0.011897, 
(F)0.128113, (F)0.138977, (F)0.246460, (F)0.215637, (F)-0.175171, (F)-0.016413, 
(F)-0.019315, (F)-0.060743, (F)-0.046499, (F)-0.030685, (F)-0.017805, (F)-0.031575, 
(F)-0.034252, (F)-0.027626, (F)-0.029969, (F)-0.053146, (F)0.022442, (F)0.024345, 
(F)0.043173, (F)0.037773, 
(F)0.024414, (F)-0.067993, (F)0.519775, (F)0.147827, (F)-0.068176, (F)-0.000596, 
(F)-0.004623, (F)-0.270166, (F)-0.021853, (F)-0.004648, (F)0.001660, (F)-0.012690, 
(F)0.035341, (F)-0.003609, (F)0.010051, (F)-0.076837, (F)0.001664, (F)-0.004636, 
(F)0.035436, (F)0.010078, 
(F)-0.268433, (F)-0.122742, (F)0.238770, (F)-0.146912, (F)0.137817, (F)-0.072056, 
(F)-0.015066, (F)-0.057011, (F)-0.021583, (F)-0.018994, (F)-0.032948, (F)0.064094, 
(F)0.029307, (F)-0.039436, (F)-0.018032, (F)0.035078, (F)0.036995, (F)0.016916, 
(F)-0.032907, (F)0.020247, 
(F)0.107849, (F)-0.088318, (F)0.258789, (F)0.375977, (F)-0.046204, (F)-0.011631, 
(F)-0.007800, (F)-0.066972, (F)-0.141358, (F)-0.002135, (F)0.009525, (F)-0.027910, 
(F)0.022856, (F)-0.040549, (F)0.033205, (F)-0.097299, (F)0.004983, (F)-0.004081, 
(F)0.011957, (F)0.017371, 
(F)0.097290, (F)-0.089294, (F)0.063171, (F)0.423462, (F)0.117188, (F)-0.009465, 
(F)-0.007973, (F)-0.003991, (F)-0.179320, (F)-0.013733, (F)0.008687, (F)-0.006146, 
(F)0.005641, (F)-0.041199, (F)0.037813, (F)-0.026751, (F)-0.011401, (F)0.010464, 
(F)-0.007403, (F)-0.049624, 
(F)-0.034302, (F)0.287842, (F)0.249329, (F)-0.036072, (F)0.147766, (F)-0.001177, 
(F)-0.082853, (F)-0.062165, (F)-0.001301, (F)-0.021835, (F)0.009873, (F)0.008552, 
(F)-0.071767, (F)-0.001237, (F)0.010383, (F)0.008994, (F)0.005069, (F)-0.042533, 
(F)-0.036842, (F)0.005330, 
(F)0.094727, (F)0.535767, (F)-0.057068, (F)0.021606, (F)-0.086914, (F)-0.008973, 
(F)-0.287046, (F)-0.003257, (F)-0.000467, (F)-0.007554, (F)-0.050751, (F)0.005406, 
(F)0.030575, (F)-0.002047, (F)-0.011576, (F)0.001233, (F)0.008233, (F)0.046566, 
(F)-0.004960, (F)0.001878, 
(F)0.294861, (F)-0.270447, (F)0.002502, (F)-0.090271, (F)-0.181641, (F)-0.086943, 
(F)-0.073141, (F)-0.000006, (F)-0.008149, (F)-0.032993, (F)0.079744, (F)-0.000738, 
(F)0.000677, (F)0.026617, (F)-0.024413, (F)0.000226, (F)0.053559, (F)-0.049124, 
(F)0.000455, (F)-0.016397, 
(F)0.127563, (F)0.072754, (F)0.061401, (F)0.100403, (F)0.296204, (F)-0.016272, 
(F)-0.005293, (F)-0.003770, (F)-0.010081, (F)-0.087737, (F)-0.009281, (F)-0.007833, 
(F)-0.004467, (F)-0.012808, (F)-0.007305, (F)-0.006165, (F)-0.037785, (F)-0.021550, 
(F)-0.018187, (F)-0.029740, 
(F)0.145630, (F)0.348633, (F)0.087036, (F)-0.005737, (F)0.082397, (F)-0.021208, 
(F)-0.121545, (F)-0.007575, (F)-0.000033, (F)-0.006789, (F)-0.050771, (F)-0.012675, 
(F)-0.030344, (F)0.000836, (F)0.002000, (F)0.000499, (F)-0.012000, (F)-0.028726, 
(F)-0.007172, (F)0.000473, 
(F)-0.082336, (F)0.066589, (F)0.101257, (F)0.542664, (F)0.019104, (F)-0.006779, 
(F)-0.004434, (F)-0.010253, (F)-0.294484, (F)-0.000365, (F)0.005483, (F)0.008337, 
(F)-0.006743, (F)0.044681, (F)-0.036136, (F)-0.054949, (F)0.001573, (F)-0.001272, 
(F)-0.001934, (F)-0.010367, 
(F)0.609131, (F)0.055908, (F)-0.023254, (F)-0.049316, (F)0.005371, (F)-0.371040, 
(F)-0.003126, (F)-0.000541, (F)-0.002432, (F)-0.000029, (F)-0.034055, (F)0.014165, 
(F)0.001300, (F)0.030040, (F)0.002757, (F)-0.001147, (F)-0.003272, (F)-0.000300, 
(F)0.000125, (F)0.000265, 
(F)0.142700, (F)-0.062927, (F)-0.015137, (F)0.239746, (F)0.395752, (F)-0.020363, 
(F)-0.003960, (F)-0.000229, (F)-0.057478, (F)-0.156620, (F)0.008980, (F)0.002160, 
(F)-0.000953, (F)-0.034212, (F)0.015087, (F)0.003629, (F)-0.056474, (F)0.024904, 
(F)0.005990, (F)-0.094880, 
(F)0.376343, (F)-0.075684, (F)-0.020569, (F)0.224121, (F)-0.077942, (F)-0.141634, 
(F)-0.005728, (F)-0.000423, (F)-0.050230, (F)-0.006075, (F)0.028483, (F)0.007741, 
(F)-0.001557, (F)-0.084346, (F)0.016962, (F)0.004610, (F)0.029333, (F)-0.005899, 
(F)-0.001603, (F)0.017468, 
(F)0.267151, (F)-0.008057, (F)-0.157959, (F)0.103821, (F)0.296936, (F)-0.071370, 
(F)-0.000065, (F)-0.024951, (F)-0.010779, (F)-0.088171, (F)0.002152, (F)0.042199, 
(F)-0.001273, (F)-0.027736, (F)0.000836, (F)0.016399, (F)-0.079327, (F)0.002392, 
(F)0.046904, (F)-0.030828, 
(F)0.158325, (F)0.201111, (F)0.240723, (F)0.090393, (F)0.041626, (F)-0.025067, 
(F)-0.040446, (F)-0.057947, (F)-0.008171, (F)-0.001733, (F)-0.031841, (F)-0.038112, 
(F)-0.048412, (F)-0.014311, (F)-0.018179, (F)-0.021760, (F)-0.006590, (F)-0.008371, 
(F)-0.010020, (F)-0.003763, 
(F)0.253357, (F)0.038086, (F)0.049744, (F)0.273743, (F)0.136047, (F)-0.064190, 
(F)-0.001451, (F)-0.002474, (F)-0.074935, (F)-0.018509, (F)-0.009649, (F)-0.012603, 
(F)-0.001895, (F)-0.069355, (F)-0.010426, (F)-0.013617, (F)-0.034469, (F)-0.005181, 
(F)-0.006767, (F)-0.037242, 
(F)-0.218201, (F)-0.022034, (F)0.300537, (F)0.170349, (F)0.286743, (F)-0.047612, 
(F)-0.000485, (F)-0.090323, (F)-0.029019, (F)-0.082222, (F)-0.004808, (F)0.065577, 
(F)0.006622, (F)0.037170, (F)0.003753, (F)-0.051196, (F)0.062568, (F)0.006318, 
(F)-0.086177, (F)-0.048846, 
(F)-0.153687, (F)0.231384, (F)0.526306, (F)0.019226, (F)0.150452, (F)-0.023620, 
(F)-0.053539, (F)-0.276998, (F)-0.000370, (F)-0.022636, (F)0.035561, (F)0.080886, 
(F)-0.121779, (F)0.002955, (F)-0.004449, (F)-0.010119, (F)0.023122, (F)-0.034812, 
(F)-0.079184, (F)-0.002893, 
(F)-0.042175, (F)0.182434, (F)0.607727, (F)-0.025696, (F)-0.069702, (F)-0.001779, 
(F)-0.033282, (F)-0.369332, (F)-0.000660, (F)-0.004858, (F)0.007694, (F)0.025631, 
(F)-0.110870, (F)-0.001084, (F)0.004688, (F)0.015616, (F)-0.002940, (F)0.012716, 
(F)0.042360, (F)-0.001791, 
(F)-0.117065, (F)0.006348, (F)-0.194702, (F)-0.208130, (F)-0.270996, (F)-0.013704, 
(F)-0.000040, (F)-0.037909, (F)-0.043318, (F)-0.073439, (F)0.000743, (F)-0.022793, 
(F)0.001236, (F)-0.024365, (F)0.001321, (F)-0.040523, (F)-0.031724, (F)0.001720, 
(F)-0.052764, (F)-0.056402, 
(F)-0.205017, (F)-0.101807, (F)0.113159, (F)0.423523, (F)0.087280, (F)-0.042032, 
(F)-0.010365, (F)-0.012805, (F)-0.179372, (F)-0.007618, (F)-0.020872, (F)0.023200, 
(F)0.011520, (F)0.086829, (F)0.043117, (F)-0.047926, (F)0.017894, (F)0.008886, 
(F)-0.009877, (F)-0.036965, 
(F)0.002563, (F)0.592407, (F)0.193115, (F)-0.058105, (F)0.055359, (F)-0.000007, 
(F)-0.350946, (F)-0.037293, (F)-0.003376, (F)-0.003065, (F)-0.001519, (F)-0.000495, 
(F)-0.114403, (F)0.000149, (F)0.034422, (F)0.011221, (F)-0.000142, (F)-0.032795, 
(F)-0.010691, (F)0.003217, 
(F)0.098083, (F)0.047913, (F)0.174683, (F)0.264099, (F)0.201843, (F)-0.009620, 
(F)-0.002296, (F)-0.030514, (F)-0.069748, (F)-0.040741, (F)-0.004699, (F)-0.017133, 
(F)-0.008369, (F)-0.025904, (F)-0.012654, (F)-0.046134, (F)-0.019797, (F)-0.009671, 
(F)-0.035259, (F)-0.053307, 
(F)0.415100, (F)0.208496, (F)0.135925, (F)0.102661, (F)-0.196350, (F)-0.172308, 
(F)-0.043471, (F)-0.018476, (F)-0.010539, (F)-0.038553, (F)-0.086547, (F)-0.056423, 
(F)-0.028340, (F)-0.042615, (F)-0.021404, (F)-0.013954, (F)0.081505, (F)0.040938, 
(F)0.026689, (F)0.020158, 
(F)0.211121, (F)0.237915, (F)0.022217, (F)0.478577, (F)-0.161133, (F)-0.044572, 
(F)-0.056604, (F)-0.000494, (F)-0.229036, (F)-0.025964, (F)-0.050229, (F)-0.004690, 
(F)-0.005286, (F)-0.101037, (F)-0.113861, (F)-0.010632, (F)0.034018, (F)0.038336, 
(F)0.003580, (F)0.077114, 
(F)-0.360229, (F)-0.211060, (F)-0.150452, (F)-0.115112, (F)0.264526, (F)-0.129765, 
(F)-0.044546, (F)-0.022636, (F)-0.013251, (F)-0.069974, (F)-0.076030, (F)-0.054197, 
(F)-0.031754, (F)-0.041467, (F)-0.024296, (F)-0.017319, (F)0.095290, (F)0.055831, 
(F)0.039798, (F)0.030450, 
(F)-0.226440, (F)0.069153, (F)0.479065, (F)0.210144, (F)-0.013123, (F)-0.051275, 
(F)-0.004782, (F)-0.229503, (F)-0.044161, (F)-0.000172, (F)0.015659, (F)0.108480, 
(F)-0.033129, (F)0.047585, (F)-0.014532, (F)-0.100673, (F)-0.002971, (F)0.000907, 
(F)0.006287, (F)0.002758, 
(F)0.252197, (F)0.172607, (F)0.000122, (F)-0.257080, (F)-0.251221, (F)-0.063603, 
(F)-0.029793, (F)0.000000, (F)-0.066090, (F)-0.063112, (F)-0.043531, (F)-0.000031, 
(F)-0.000021, (F)0.064835, (F)0.044374, (F)0.000031, (F)0.063357, (F)0.043363, 
(F)0.000031, (F)-0.064584, 
(F)0.358582, (F)0.518555, (F)-0.109619, (F)0.083984, (F)-0.109009, (F)-0.128581, 
(F)-0.268899, (F)-0.012016, (F)-0.007053, (F)-0.011883, (F)-0.185944, (F)0.039307, 
(F)0.056844, (F)-0.030115, (F)-0.043550, (F)0.009206, (F)0.039089, (F)0.056527, 
(F)-0.011949, (F)0.009155, 
(F)0.191833, (F)0.212585, (F)0.216431, (F)-0.048401, (F)0.273987, (F)-0.036800, 
(F)-0.045193, (F)-0.046842, (F)-0.002343, (F)-0.075069, (F)-0.040781, (F)-0.041519, 
(F)-0.046010, (F)0.009285, (F)0.010289, (F)0.010475, (F)-0.052560, (F)-0.058246, 
(F)-0.059299, (F)0.013261, 
(F)0.173645, (F)0.486145, (F)0.225525, (F)-0.331543, (F)0.242798, (F)-0.030153, 
(F)-0.236337, (F)-0.050861, (F)-0.109921, (F)-0.058951, (F)-0.084417, (F)-0.039161, 
(F)-0.109638, (F)0.057571, (F)0.161178, (F)0.074771, (F)-0.042161, (F)-0.118035, 
(F)-0.054757, (F)0.080498, 
(F)0.093872, (F)0.009155, (F)0.435730, (F)0.125061, (F)0.189026, (F)-0.008812, 
(F)-0.000084, (F)-0.189861, (F)-0.015640, (F)-0.035731, (F)-0.000859, (F)-0.040903, 
(F)-0.003989, (F)-0.011740, (F)-0.001145, (F)-0.054493, (F)-0.017744, (F)-0.001731, 
(F)-0.082364, (F)-0.023640, 
(F)0.037720, (F)0.458984, (F)0.288635, (F)-0.014526, (F)-0.205872, (F)-0.001423, 
(F)-0.210667, (F)-0.083310, (F)-0.000211, (F)-0.042383, (F)-0.017313, (F)-0.010887, 
(F)-0.132479, (F)0.000548, (F)0.006667, (F)0.004193, (F)0.007765, (F)0.094492, 
(F)0.059422, (F)-0.002991, 
(F)0.180969, (F)-0.183899, (F)0.482910, (F)0.431885, (F)-0.121887, (F)-0.032750, 
(F)-0.033819, (F)-0.233202, (F)-0.186524, (F)-0.014856, (F)0.033280, (F)-0.087392, 
(F)0.088807, (F)-0.078158, (F)0.079423, (F)-0.208562, (F)0.022058, (F)-0.022415, 
(F)0.058861, (F)0.052641, 
(F)0.149109, (F)-0.056702, (F)-0.067932, (F)0.590637, (F)0.252563, (F)-0.022233, 
(F)-0.003215, (F)-0.004615, (F)-0.348852, (F)-0.063788, (F)0.008455, (F)0.010129, 
(F)-0.003852, (F)-0.088069, (F)0.033490, (F)0.040123, (F)-0.037659, (F)0.014321, 
(F)0.017157, (F)-0.149173, 
(F)0.119995, (F)0.201965, (F)0.615540, (F)-0.207458, (F)0.128479, (F)-0.014399, 
(F)-0.040790, (F)-0.378889, (F)-0.043039, (F)-0.016507, (F)-0.024235, (F)-0.073862, 
(F)-0.124318, (F)0.024894, (F)0.041899, (F)0.127699, (F)-0.015417, (F)-0.025948, 
(F)-0.079084, (F)0.026654, 
(F)-0.006836, (F)-0.083496, (F)0.541260, (F)0.294312, (F)0.125000, (F)-0.000047, 
(F)-0.006972, (F)-0.292962, (F)-0.086619, (F)-0.015625, (F)-0.000571, (F)0.003700, 
(F)0.045193, (F)0.002012, (F)0.024574, (F)-0.159299, (F)0.000854, (F)0.010437, 
(F)-0.067657, (F)-0.036789, 
(F)-0.158508, (F)0.026733, (F)-0.112244, (F)0.380188, (F)0.443481, (F)-0.025125, 
(F)-0.000715, (F)-0.012599, (F)-0.144543, (F)-0.196676, (F)0.004237, (F)-0.017792, 
(F)0.003001, (F)0.060263, (F)-0.010164, (F)0.042674, (F)0.070295, (F)-0.011856, 
(F)0.049778, (F)-0.168606, 
(F)0.210815, (F)0.033752, (F)0.557068, (F)0.301880, (F)-0.341553, (F)-0.044443, 
(F)-0.001139, (F)-0.310325, (F)-0.091131, (F)-0.116658, (F)-0.007116, (F)-0.117439, 
(F)-0.018802, (F)-0.063641, (F)-0.010189, (F)-0.168168, (F)0.072005, (F)0.011528, 
(F)0.190268, (F)0.103108, 
(F)-0.032471, (F)-0.040466, (F)0.748413, (F)0.152283, (F)-0.061279, (F)-0.001054, 
(F)-0.001638, (F)-0.560122, (F)-0.023190, (F)-0.003755, (F)-0.001314, (F)0.024301, 
(F)0.030286, (F)0.004945, (F)0.006162, (F)-0.113970, (F)-0.001990, (F)-0.002480, 
(F)0.045862, (F)0.009332, 
(F)-0.128174, (F)0.080383, (F)-0.092102, (F)0.697327, (F)0.182922, (F)-0.016429, 
(F)-0.006461, (F)-0.008483, (F)-0.486264, (F)-0.033461, (F)0.010303, (F)-0.011805, 
(F)0.007403, (F)0.089379, (F)-0.056053, (F)0.064225, (F)0.023446, (F)-0.014704, 
(F)0.016848, (F)-0.127557, 
(F)0.072815, (F)-0.164612, (F)0.687195, (F)0.327942, (F)-0.046570, (F)-0.005302, 
(F)-0.027097, (F)-0.472237, (F)-0.107546, (F)-0.002169, (F)0.011986, (F)-0.050038, 
(F)0.113120, (F)-0.023879, (F)0.053983, (F)-0.225360, (F)0.003391, (F)-0.007666, 
(F)0.032003, (F)0.015272, 
(F)0.146790, (F)-0.028748, (F)0.676208, (F)0.012390, (F)0.047729, (F)-0.021547, 
(F)-0.000826, (F)-0.457258, (F)-0.000154, (F)-0.002278, (F)0.004220, (F)-0.099260, 
(F)0.019439, (F)-0.001819, (F)0.000356, (F)-0.008378, (F)-0.007006, (F)0.001372, 
(F)-0.032275, (F)-0.000591, 
(F)-0.114197, (F)0.346985, (F)0.689087, (F)-0.162476, (F)0.082581, (F)-0.013041, 
(F)-0.120398, (F)-0.474841, (F)-0.026398, (F)-0.006820, (F)0.039625, (F)0.078692, 
(F)-0.239103, (F)-0.018554, (F)0.056377, (F)0.111960, (F)0.009430, (F)-0.028654, 
(F)-0.056905, (F)0.013417, 
(F)-0.229980, (F)0.361755, (F)-0.188782, (F)0.307678, (F)0.318115, (F)-0.052891, 
(F)-0.130867, (F)-0.035639, (F)-0.094666, (F)-0.101197, (F)0.083197, (F)-0.043416, 
(F)0.068293, (F)0.070760, (F)-0.111304, (F)0.058084, (F)0.073160, (F)-0.115080, 
(F)0.060054, (F)-0.097877, 
(F)-0.155396, (F)0.579956, (F)0.364319, (F)-0.148926, (F)0.117676, (F)-0.024148, 
(F)-0.336349, (F)-0.132728, (F)-0.022179, (F)-0.013848, (F)0.090123, (F)0.056614, 
(F)-0.211289, (F)-0.023142, (F)0.086370, (F)0.054256, (F)0.018286, (F)-0.068247, 
(F)-0.042872, (F)0.017525, 
(F)-0.302917, (F)0.217773, (F)0.280273, (F)0.336182, (F)0.210632, (F)-0.091759, 
(F)-0.047425, (F)-0.078553, (F)-0.113018, (F)-0.044366, (F)0.065967, (F)0.084900, 
(F)-0.061036, (F)0.101835, (F)-0.073211, (F)-0.094223, (F)0.063804, (F)-0.045870, 
(F)-0.059035, (F)-0.070811, 
(F)0.106506, (F)-0.157837, (F)0.243103, (F)0.665222, (F)-0.094666, (F)-0.011344, 
(F)-0.024912, (F)-0.059099, (F)-0.442521, (F)-0.008962, (F)0.016811, (F)-0.025892, 
(F)0.038371, (F)-0.070850, (F)0.104997, (F)-0.161718, (F)0.010082, (F)-0.014942, 
(F)0.023013, (F)0.062974, 
(F)0.052917, (F)-0.027832, (F)-0.044373, (F)0.205627, (F)0.721558, (F)-0.002800, 
(F)-0.000775, (F)-0.001969, (F)-0.042283, (F)-0.520645, (F)0.001473, (F)0.002348, 
(F)-0.001235, (F)-0.010881, (F)0.005723, (F)0.009124, (F)-0.038183, (F)0.020082, 
(F)0.032017, (F)-0.148372, 
(F)0.459900, (F)0.147827, (F)0.117554, (F)0.085754, (F)0.097595, (F)-0.211508, 
(F)-0.021853, (F)-0.013819, (F)-0.007354, (F)-0.009525, (F)-0.067986, (F)-0.054063, 
(F)-0.017378, (F)-0.039438, (F)-0.012677, (F)-0.010081, (F)-0.044884, (F)-0.014427, 
(F)-0.011473, (F)-0.008369, 
(F)0.063538, (F)-0.044861, (F)-0.008667, (F)0.806213, (F)0.092468, (F)-0.004037, 
(F)-0.002012, (F)-0.000075, (F)-0.649980, (F)-0.008550, (F)0.002850, (F)0.000551, 
(F)-0.000389, (F)-0.051225, (F)0.036167, (F)0.006987, (F)-0.005875, (F)0.004148, 
(F)0.000801, (F)-0.074549, 
(F)0.485229, (F)0.411682, (F)-0.088135, (F)-0.061523, (F)0.166077, (F)-0.235448, 
(F)-0.169482, (F)-0.007768, (F)-0.003785, (F)-0.027581, (F)-0.199760, (F)0.042766, 
(F)0.036284, (F)0.029853, (F)0.025328, (F)-0.005422, (F)-0.080585, (F)-0.068371, 
(F)0.014637, (F)0.010218, 
(F)-0.290161, (F)-0.084167, (F)0.276001, (F)-0.035278, (F)-0.349915, (F)-0.084193, 
(F)-0.007084, (F)-0.076177, (F)-0.001245, (F)-0.122440, (F)-0.024422, (F)0.080085, 
(F)0.023230, (F)-0.010236, (F)-0.002969, (F)0.009737, (F)-0.101532, (F)-0.029451, 
(F)0.096577, (F)-0.012344, 
(F)0.196533, (F)0.364868, (F)0.361511, (F)0.148315, (F)-0.164124, (F)-0.038625, 
(F)-0.133129, (F)-0.130690, (F)-0.021997, (F)-0.026937, (F)-0.071709, (F)-0.071049, 
(F)-0.131904, (F)-0.029149, (F)-0.054116, (F)-0.053618, (F)0.032256, (F)0.059883, 
(F)0.059333, (F)0.024342, 
(F)0.023010, (F)0.080078, (F)0.853149, (F)-0.089722, (F)0.041321, (F)-0.000529, 
(F)-0.006413, (F)-0.727864, (F)-0.008050, (F)-0.001707, (F)-0.001843, (F)-0.019631, 
(F)-0.068319, (F)0.002065, (F)0.007185, (F)0.076546, (F)-0.000951, (F)-0.003309, 
(F)-0.035253, (F)0.003707, 
(F)-0.209656, (F)0.413208, (F)0.019165, (F)-0.054016, (F)0.347046, (F)-0.043956, 
(F)-0.170741, (F)-0.000367, (F)-0.002918, (F)-0.120441, (F)0.086631, (F)0.004018, 
(F)-0.007919, (F)-0.011325, (F)0.022320, (F)0.001035, (F)0.072760, (F)-0.143402, 
(F)-0.006651, (F)0.018746, 
(F)0.193542, (F)0.535522, (F)-0.137939, (F)0.163513, (F)0.187317, (F)-0.037459, 
(F)-0.286784, (F)-0.019027, (F)-0.026737, (F)-0.035088, (F)-0.103646, (F)0.026697, 
(F)0.073870, (F)-0.031647, (F)-0.087565, (F)0.022555, (F)-0.036254, (F)-0.100312, 
(F)0.025838, (F)-0.030629, 
(F)0.339172, (F)0.092102, (F)0.330017, (F)-0.007629, (F)-0.450806, (F)-0.115038, 
(F)-0.008483, (F)-0.108911, (F)-0.000058, (F)-0.203226, (F)-0.031238, (F)-0.111933, 
(F)-0.030395, (F)0.002588, (F)0.000703, (F)0.002518, (F)0.152901, (F)0.041520, 
(F)0.148774, (F)-0.003439, 
(F)-0.173218, (F)0.158386, (F)0.807373, (F)0.016541, (F)0.109436, (F)-0.030004, 
(F)-0.025086, (F)-0.651851, (F)-0.000274, (F)-0.011976, (F)0.027435, (F)0.139851, 
(F)-0.127877, (F)0.002865, (F)-0.002620, (F)-0.013354, (F)0.018956, (F)-0.017333, 
(F)-0.088356, (F)-0.001810, 
(F)0.040527, (F)-0.016968, (F)0.913452, (F)0.058044, (F)-0.043396, (F)-0.001642, 
(F)-0.000288, (F)-0.834395, (F)-0.003369, (F)-0.001883, (F)0.000688, (F)-0.037020, 
(F)0.015499, (F)-0.002352, (F)0.000985, (F)-0.053021, (F)0.001759, (F)-0.000736, 
(F)0.039640, (F)0.002519, 
(F)0.049316, (F)0.108032, (F)0.528442, (F)0.357849, (F)-0.090698, (F)-0.002432, 
(F)-0.011671, (F)-0.279251, (F)-0.128056, (F)-0.008226, (F)-0.005328, (F)-0.026061, 
(F)-0.057089, (F)-0.017648, (F)-0.038659, (F)-0.189103, (F)0.004473, (F)0.009798, 
(F)0.047929, (F)0.032456, 
(F)0.186951, (F)0.093933, (F)0.122070, (F)-0.033081, (F)0.584473, (F)-0.034951, 
(F)-0.008823, (F)-0.014901, (F)-0.001094, (F)-0.341608, (F)-0.017561, (F)-0.022821, 
(F)-0.011466, (F)0.006185, (F)0.003107, (F)0.004038, (F)-0.109268, (F)-0.054901, 
(F)-0.071347, (F)0.019335, 
(F)0.031372, (F)0.859558, (F)-0.019714, (F)0.054688, (F)-0.054382, (F)-0.000984, 
(F)-0.738840, (F)-0.000389, (F)-0.002991, (F)-0.002957, (F)-0.026966, (F)0.000618, 
(F)0.016946, (F)-0.001716, (F)-0.047007, (F)0.001078, (F)0.001706, (F)0.046745, 
(F)-0.001072, (F)0.002974, 
(F)0.054443, (F)0.009644, (F)0.319641, (F)0.674866, (F)-0.097839, (F)-0.002964, 
(F)-0.000093, (F)-0.102170, (F)-0.455444, (F)-0.009573, (F)-0.000525, (F)-0.017402, 
(F)-0.003082, (F)-0.036742, (F)-0.006508, (F)-0.215715, (F)0.005327, (F)0.000944, 
(F)0.031273, (F)0.066028, 
(F)-0.098389, (F)0.156494, (F)-0.262207, (F)0.764526, (F)0.348511, (F)-0.009680, 
(F)-0.024490, (F)-0.068753, (F)-0.584501, (F)-0.121460, (F)0.015397, (F)-0.025798, 
(F)0.041034, (F)0.075221, (F)-0.119644, (F)0.200464, (F)0.034290, (F)-0.054540, 
(F)0.091382, (F)-0.266446, 
(F)0.298401, (F)-0.419800, (F)0.037354, (F)0.372864, (F)0.290100, (F)-0.089043, 
(F)-0.176232, (F)-0.001395, (F)-0.139027, (F)-0.084158, (F)0.125269, (F)-0.011146, 
(F)0.015681, (F)-0.111263, (F)0.156528, (F)-0.013928, (F)-0.086566, (F)0.121784, 
(F)-0.010836, (F)-0.108168, 
(F)0.186340, (F)-0.030884, (F)0.146667, (F)0.587463, (F)0.080688, (F)-0.034723, 
(F)-0.000954, (F)-0.021511, (F)-0.345113, (F)-0.006511, (F)0.005755, (F)-0.027330, 
(F)0.004530, (F)-0.109468, (F)0.018143, (F)-0.086162, (F)-0.015036, (F)0.002492, 
(F)-0.011834, (F)-0.047402, 
(F)-0.046021, (F)0.787598, (F)0.273438, (F)-0.128967, (F)0.089783, (F)-0.002118, 
(F)-0.620310, (F)-0.074768, (F)-0.016633, (F)-0.008061, (F)0.036246, (F)0.012584, 
(F)-0.215359, (F)-0.005935, (F)0.101574, (F)0.035264, (F)0.004132, (F)-0.070713, 
(F)-0.024550, (F)0.011579, 
(F)0.259705, (F)0.090088, (F)0.308533, (F)0.146057, (F)0.177734, (F)-0.067446, 
(F)-0.008116, (F)-0.095192, (F)-0.021333, (F)-0.031590, (F)-0.023396, (F)-0.080127, 
(F)-0.027795, (F)-0.037932, (F)-0.013158, (F)-0.045063, (F)-0.046158, (F)-0.016012, 
(F)-0.054837, (F)-0.025959, 
(F)-0.083679, (F)0.032654, (F)0.086487, (F)0.891357, (F)-0.060852, (F)-0.007002, 
(F)-0.001066, (F)-0.007480, (F)-0.794518, (F)-0.003703, (F)0.002732, (F)0.007237, 
(F)-0.002824, (F)0.074588, (F)-0.029106, (F)-0.077091, (F)-0.005092, (F)0.001987, 
(F)0.005263, (F)0.054241, 
(F)0.327637, (F)-0.106445, (F)0.249207, (F)-0.075439, (F)0.229065, (F)-0.107346, 
(F)-0.011331, (F)-0.062104, (F)-0.005691, (F)-0.052471, (F)0.034875, (F)-0.081649, 
(F)0.026527, (F)0.024717, (F)-0.008030, (F)0.018800, (F)-0.075050, (F)0.024383, 
(F)-0.057084, (F)0.017281, 
(F)0.096924, (F)-0.189026, (F)0.879822, (F)0.225769, (F)-0.071472, (F)-0.009394, 
(F)-0.035731, (F)-0.774086, (F)-0.050972, (F)-0.005108, (F)0.018321, (F)-0.085276, 
(F)0.166309, (F)-0.021882, (F)0.042676, (F)-0.198637, (F)0.006927, (F)-0.013510, 
(F)0.062883, (F)0.016136, 
(F)0.012939, (F)0.487610, (F)0.578064, (F)-0.204102, (F)0.122620, (F)-0.000167, 
(F)-0.237763, (F)-0.334158, (F)-0.041657, (F)-0.015036, (F)-0.006309, (F)-0.007480, 
(F)-0.281870, (F)0.002641, (F)0.099522, (F)0.117984, (F)-0.001587, (F)-0.059791, 
(F)-0.070882, (F)0.025027, 
(F)0.052246, (F)0.140015, (F)-0.038269, (F)0.422974, (F)0.422913, (F)-0.002730, 
(F)-0.019604, (F)-0.001465, (F)-0.178907, (F)-0.178855, (F)-0.007315, (F)0.001999, 
(F)0.005358, (F)-0.022099, (F)-0.059223, (F)0.016187, (F)-0.022096, (F)-0.059214, 
(F)0.016184, (F)-0.178881, 
(F)0.143860, (F)-0.255554, (F)0.437134, (F)0.468933, (F)0.205750, (F)-0.020696, 
(F)-0.065308, (F)-0.191086, (F)-0.219898, (F)-0.042333, (F)0.036764, (F)-0.062886, 
(F)0.111711, (F)-0.067461, (F)0.119838, (F)-0.204987, (F)-0.029599, (F)0.052580, 
(F)-0.089940, (F)-0.096483, 
(F)0.021362, (F)0.279846, (F)0.857727, (F)-0.233093, (F)0.074341, (F)-0.000456, 
(F)-0.078314, (F)-0.735696, (F)-0.054332, (F)-0.005527, (F)-0.005978, (F)-0.018323, 
(F)-0.240032, (F)0.004979, (F)0.065230, (F)0.199930, (F)-0.001588, (F)-0.020804, 
(F)-0.063764, (F)0.017328, 
(F)-0.198242, (F)0.215515, (F)0.028992, (F)0.130432, (F)0.714783, (F)-0.039300, 
(F)-0.046447, (F)-0.000841, (F)-0.017013, (F)-0.510914, (F)0.042724, (F)0.005747, 
(F)-0.006248, (F)0.025857, (F)-0.028110, (F)-0.003781, (F)0.141700, (F)-0.154046, 
(F)-0.020723, (F)-0.093231, 
(F)-0.184143, (F)0.235107, (F)0.105286, (F)0.515137, (F)0.320862, (F)-0.033909, 
(F)-0.055275, (F)-0.011085, (F)-0.265366, (F)-0.102952, (F)0.043293, (F)0.019388, 
(F)-0.024753, (F)0.094859, (F)-0.121112, (F)-0.054237, (F)0.059084, (F)-0.075437, 
(F)-0.033782, (F)-0.165288, 
(F)-0.055481, (F)0.195068, (F)0.946777, (F)-0.154297, (F)0.065063, (F)-0.003078, 
(F)-0.038052, (F)-0.896387, (F)-0.023808, (F)-0.004233, (F)0.010823, (F)0.052528, 
(F)-0.184686, (F)-0.008561, (F)0.030098, (F)0.146085, (F)0.003610, (F)-0.012692, 
(F)-0.061601, (F)0.010039, 
(F)0.058533, (F)-0.205688, (F)0.586975, (F)0.582581, (F)-0.107483, (F)-0.003426, 
(F)-0.042308, (F)-0.344540, (F)-0.339400, (F)-0.011553, (F)0.012040, (F)-0.034357, 
(F)0.120734, (F)-0.034100, (F)0.119830, (F)-0.341960, (F)0.006291, (F)-0.022108, 
(F)0.063090, (F)0.062617, 
(F)0.462341, (F)0.719971, (F)-0.295715, (F)0.198486, (F)-0.103943, (F)-0.213759, 
(F)-0.518358, (F)-0.087448, (F)-0.039397, (F)-0.010804, (F)-0.332872, (F)0.136721, 
(F)0.212906, (F)-0.091768, (F)-0.142904, (F)0.058695, (F)0.048057, (F)0.074836, 
(F)-0.030738, (F)0.020631, 
(F)0.391174, (F)0.105103, (F)0.107666, (F)-0.255798, (F)0.367126, (F)-0.153017, 
(F)-0.011047, (F)-0.011592, (F)-0.065433, (F)-0.134782, (F)-0.041113, (F)-0.042116, 
(F)-0.011316, (F)0.100062, (F)0.026885, (F)0.027541, (F)-0.143610, (F)-0.038586, 
(F)-0.039527, (F)0.093910, 
(F)-0.147705, (F)0.742249, (F)0.307495, (F)0.078491, (F)-0.128052, (F)-0.021817, 
(F)-0.550933, (F)-0.094553, (F)-0.006161, (F)-0.016397, (F)0.109634, (F)0.045419, 
(F)-0.228238, (F)0.011594, (F)-0.058260, (F)-0.024136, (F)-0.018914, (F)0.095046, 
(F)0.039375, (F)0.010051, 
(F)-0.136230, (F)-0.081848, (F)0.442261, (F)0.578003, (F)-0.120667, (F)-0.018559, 
(F)-0.006699, (F)-0.195595, (F)-0.334087, (F)-0.014560, (F)-0.011150, (F)0.060249, 
(F)0.036198, (F)0.078742, (F)0.047308, (F)-0.255628, (F)-0.016438, (F)-0.009876, 
(F)0.053366, (F)0.069746, 
(F)0.062866, (F)0.429321, (F)0.258240, (F)0.094666, (F)0.187805, (F)-0.003952, 
(F)-0.184317, (F)-0.066688, (F)-0.008962, (F)-0.035271, (F)-0.026990, (F)-0.016235, 
(F)-0.110868, (F)-0.005951, (F)-0.040642, (F)-0.024446, (F)-0.011807, (F)-0.080629, 
(F)-0.048499, (F)-0.017779, 
(F)0.312561, (F)0.722351, (F)-0.029114, (F)-0.106750, (F)0.140259, (F)-0.097694, 
(F)-0.521791, (F)-0.000848, (F)-0.011396, (F)-0.019673, (F)-0.225779, (F)0.009100, 
(F)0.021030, (F)0.033366, (F)0.077111, (F)-0.003108, (F)-0.043839, (F)-0.101316, 
(F)0.004083, (F)0.014973, 
(F)-0.203125, (F)0.233582, (F)0.361389, (F)0.608887, (F)-0.063782, (F)-0.041260, 
(F)-0.054560, (F)-0.130602, (F)-0.370743, (F)-0.004068, (F)0.047446, (F)0.073407, 
(F)-0.084414, (F)0.123680, (F)-0.142225, (F)-0.220045, (F)-0.012956, (F)0.014898, 
(F)0.023050, (F)0.038836, 
(F)0.232727, (F)0.348999, (F)-0.284790, (F)-0.208252, (F)0.346313, (F)-0.054162, 
(F)-0.121800, (F)-0.081105, (F)-0.043369, (F)-0.119933, (F)-0.081222, (F)0.066278, 
(F)0.099391, (F)0.048466, (F)0.072680, (F)-0.059308, (F)-0.080597, (F)-0.120863, 
(F)0.098627, (F)0.072120, 
(F)0.082275, (F)-0.224121, (F)0.802856, (F)0.423462, (F)-0.103149, (F)-0.006769, 
(F)-0.050230, (F)-0.644578, (F)-0.179320, (F)-0.010640, (F)0.018440, (F)-0.066055, 
(F)0.179937, (F)-0.034840, (F)0.094907, (F)-0.339979, (F)0.008487, (F)-0.023118, 
(F)0.082814, (F)0.043680, 
(F)0.131287, (F)-0.218872, (F)0.424133, (F)0.740417, (F)-0.074707, (F)-0.017236, 
(F)-0.047905, (F)-0.179889, (F)-0.548218, (F)-0.005581, (F)0.028735, (F)-0.055683, 
(F)0.092831, (F)-0.097207, (F)0.162057, (F)-0.314036, (F)0.009808, (F)-0.016351, 
(F)0.031686, (F)0.055314, 
(F)-0.176331, (F)0.588806, (F)0.627197, (F)-0.166504, (F)0.060730, (F)-0.031092, 
(F)-0.346693, (F)-0.393376, (F)-0.027724, (F)-0.003688, (F)0.103825, (F)0.110594, 
(F)-0.369298, (F)-0.029360, (F)0.098039, (F)0.104431, (F)0.010709, (F)-0.035758, 
(F)-0.038090, (F)0.010112, 
(F)0.377014, (F)0.133301, (F)0.033875, (F)0.121155, (F)0.402161, (F)-0.142140, 
(F)-0.017769, (F)-0.001147, (F)-0.014678, (F)-0.161733, (F)-0.050256, (F)-0.012771, 
(F)-0.004515, (F)-0.045677, (F)-0.016150, (F)-0.004104, (F)-0.151620, (F)-0.053608, 
(F)-0.013623, (F)-0.048724, 
(F)-0.030029, (F)0.023865, (F)1.047729, (F)-0.041565, (F)0.014648, (F)-0.000902, 
(F)-0.000570, (F)-1.097737, (F)-0.001728, (F)-0.000215, (F)0.000717, (F)0.031463, 
(F)-0.025004, (F)-0.001248, (F)0.000992, (F)0.043549, (F)0.000440, (F)-0.000350, 
(F)-0.015348, (F)0.000609, 
(F)0.770752, (F)0.332520, (F)-0.160522, (F)0.183777, (F)-0.164490, (F)-0.594059, 
(F)-0.110569, (F)-0.025767, (F)-0.033774, (F)-0.027057, (F)-0.256290, (F)0.123723, 
(F)0.053377, (F)-0.141646, (F)-0.061109, (F)0.029500, (F)0.126781, (F)0.054696, 
(F)-0.026404, (F)0.030229, 
(F)-0.221436, (F)-0.032593, (F)0.210388, (F)0.427368, (F)0.412048, (F)-0.049034, 
(F)-0.001062, (F)-0.044263, (F)-0.182644, (F)-0.169784, (F)-0.007217, (F)0.046587, 
(F)0.006857, (F)0.094635, (F)0.013929, (F)-0.089913, (F)0.091242, (F)0.013430, 
(F)-0.086690, (F)-0.176096, 
(F)-0.319763, (F)0.360168, (F)0.494812, (F)0.222778, (F)0.295776, (F)-0.102248, 
(F)-0.129721, (F)-0.244839, (F)-0.049630, (F)-0.087484, (F)0.115169, (F)0.158223, 
(F)-0.178216, (F)0.071236, (F)-0.080238, (F)-0.110233, (F)0.094578, (F)-0.106529, 
(F)-0.146354, (F)-0.065893, 
(F)0.375793, (F)0.407593, (F)0.250183, (F)-0.065552, (F)0.143311, (F)-0.141221, 
(F)-0.166132, (F)-0.062592, (F)-0.004297, (F)-0.020538, (F)-0.153171, (F)-0.094017, 
(F)-0.101973, (F)0.024634, (F)0.026718, (F)0.016400, (F)-0.053855, (F)-0.058412, 
(F)-0.035854, (F)0.009394, 
(F)0.065857, (F)0.982605, (F)0.014771, (F)-0.053772, (F)0.103149, (F)-0.004337, 
(F)-0.965513, (F)-0.000218, (F)-0.002891, (F)-0.010640, (F)-0.064711, (F)-0.000973, 
(F)-0.014514, (F)0.003541, (F)0.052837, (F)0.000794, (F)-0.006793, (F)-0.101355, 
(F)-0.001524, (F)0.005547, 
(F)-0.016968, (F)0.013855, (F)-0.063416, (F)0.099854, (F)1.034241, (F)-0.000288, 
(F)-0.000192, (F)-0.004022, (F)-0.009971, (F)-1.069654, (F)0.000235, (F)-0.001076, 
(F)0.000879, (F)0.001694, (F)-0.001383, (F)0.006332, (F)0.017549, (F)-0.014329, 
(F)0.065587, (F)-0.103273, 
(F)0.963013, (F)-0.088745, (F)0.035034, (F)-0.036804, (F)-0.006531, (F)-0.927393, 
(F)-0.007876, (F)-0.001227, (F)-0.001355, (F)-0.000043, (F)0.085463, (F)-0.033738, 
(F)0.003109, (F)0.035443, (F)-0.003266, (F)0.001289, (F)0.006289, (F)-0.000580, 
(F)0.000229, (F)-0.000240, 
(F)0.146851, (F)-0.051025, (F)0.807129, (F)0.487854, (F)-0.260376, (F)-0.021565, 
(F)-0.002604, (F)-0.651457, (F)-0.238002, (F)-0.067796, (F)0.007493, (F)-0.118527, 
(F)0.041184, (F)-0.071642, (F)0.024893, (F)-0.393761, (F)0.038236, (F)-0.013286, 
(F)0.210157, (F)0.127025, 
(F)0.194336, (F)0.876953, (F)-0.203613, (F)0.137634, (F)-0.109924, (F)-0.037766, 
(F)-0.769047, (F)-0.041458, (F)-0.018943, (F)-0.012083, (F)-0.170424, (F)0.039569, 
(F)0.178559, (F)-0.026747, (F)-0.120699, (F)0.028024, (F)0.021362, (F)0.096398, 
(F)-0.022382, (F)0.015129, 
(F)-0.103638, (F)1.042236, (F)0.152832, (F)-0.032898, (F)-0.039429, (F)-0.010741, 
(F)-1.086257, (F)-0.023358, (F)-0.001082, (F)-0.001555, (F)0.108015, (F)0.015839, 
(F)-0.159287, (F)-0.003409, (F)0.034287, (F)0.005028, (F)-0.004086, (F)0.041094, 
(F)0.006026, (F)-0.001297, 
(F)0.144958, (F)-0.048645, (F)-0.164551, (F)0.883972, (F)0.328552, (F)-0.021013, 
(F)-0.002366, (F)-0.027077, (F)-0.781407, (F)-0.107947, (F)0.007052, (F)0.023853, 
(F)-0.008005, (F)-0.128139, (F)0.043001, (F)0.145458, (F)-0.047626, (F)0.015982, 
(F)0.054064, (F)-0.290431, 
(F)-0.164246, (F)0.155884, (F)-0.275879, (F)0.584290, (F)0.650330, (F)-0.026977, 
(F)-0.024300, (F)-0.076109, (F)-0.341394, (F)-0.422929, (F)0.025603, (F)-0.045312, 
(F)0.043005, (F)0.095967, (F)-0.091081, (F)0.161193, (F)0.106814, (F)-0.101376, 
(F)0.179412, (F)-0.379981, 
(F)-0.264404, (F)-0.268494, (F)-0.101135, (F)0.297852, (F)0.450134, (F)-0.069910, 
(F)-0.072089, (F)-0.010228, (F)-0.088716, (F)-0.202621, (F)-0.070991, (F)-0.026741, 
(F)-0.027154, (F)0.078753, (F)0.079971, (F)0.030123, (F)0.119017, (F)0.120858, 
(F)0.045524, (F)-0.134073, 
(F)-0.213501, (F)0.451965, (F)0.607605, (F)0.164368, (F)-0.181335, (F)-0.045583, 
(F)-0.204273, (F)-0.369184, (F)-0.027017, (F)-0.032883, (F)0.096495, (F)0.129724, 
(F)-0.274616, (F)0.035093, (F)-0.074288, (F)-0.099871, (F)-0.038715, (F)0.081957, 
(F)0.110180, (F)0.029806, 
(F)0.409973, (F)-0.231445, (F)0.472351, (F)0.170776, (F)0.212952, (F)-0.168078, 
(F)-0.053567, (F)-0.223116, (F)-0.029165, (F)-0.045348, (F)0.094886, (F)-0.193651, 
(F)0.109323, (F)-0.070014, (F)0.039525, (F)-0.080666, (F)-0.087304, (F)0.049287, 
(F)-0.100588, (F)-0.036367, 
(F)0.321228, (F)0.596313, (F)0.211365, (F)0.065247, (F)-0.242371, (F)-0.103187, 
(F)-0.355590, (F)-0.044675, (F)-0.004257, (F)-0.058744, (F)-0.191553, (F)-0.067896, 
(F)-0.126040, (F)-0.020959, (F)-0.038907, (F)-0.013791, (F)0.077856, (F)0.144529, 
(F)0.051229, (F)0.015814, 
(F)0.075867, (F)-0.160767, (F)1.023682, (F)0.114197, (F)0.020264, (F)-0.005756, 
(F)-0.025846, (F)-1.047924, (F)-0.013041, (F)-0.000411, (F)0.012197, (F)-0.077663, 
(F)0.164574, (F)-0.008664, (F)0.018359, (F)-0.116901, (F)-0.001537, (F)0.003258, 
(F)-0.020744, (F)-0.002314, 
(F)0.164246, (F)0.173096, (F)0.189514, (F)0.348572, (F)0.294006, (F)-0.026977, 
(F)-0.029962, (F)-0.035916, (F)-0.121502, (F)-0.086440, (F)-0.028430, (F)-0.031127, 
(F)-0.032804, (F)-0.057251, (F)-0.060336, (F)-0.066059, (F)-0.048289, (F)-0.050891, 
(F)-0.055718, (F)-0.102482, 
(F)0.266479, (F)0.179688, (F)0.440063, (F)0.221375, (F)0.070862, (F)-0.071011, 
(F)-0.032288, (F)-0.193656, (F)-0.049007, (F)-0.005021, (F)-0.047883, (F)-0.117268, 
(F)-0.079074, (F)-0.058992, (F)-0.039778, (F)-0.097419, (F)-0.018883, (F)-0.012733, 
(F)-0.031184, (F)-0.015687, 
(F)0.847656, (F)0.241150, (F)-0.040955, (F)-0.140686, (F)0.204712, (F)-0.718521, 
(F)-0.058153, (F)-0.001677, (F)-0.019793, (F)-0.041907, (F)-0.204412, (F)0.034715, 
(F)0.009876, (F)0.119253, (F)0.033926, (F)-0.005762, (F)-0.173525, (F)-0.049366, 
(F)0.008384, (F)0.028800, 
(F)0.430481, (F)0.356873, (F)0.178772, (F)0.511353, (F)-0.292603, (F)-0.185314, 
(F)-0.127358, (F)-0.031959, (F)-0.261481, (F)-0.085616, (F)-0.153627, (F)-0.076958, 
(F)-0.063799, (F)-0.220128, (F)-0.182488, (F)-0.091416, (F)0.125960, (F)0.104422, 
(F)0.052309, (F)0.149623, 
(F)-0.133728, (F)0.783569, (F)0.560425, (F)-0.238953, (F)0.098694, (F)-0.017883, 
(F)-0.613981, (F)-0.314076, (F)-0.057098, (F)-0.009740, (F)0.104785, (F)0.074945, 
(F)-0.439132, (F)-0.031955, (F)0.187236, (F)0.133915, (F)0.013198, (F)-0.077333, 
(F)-0.055310, (F)0.023583, 
(F)-0.297913, (F)0.800415, (F)0.351990, (F)-0.026550, (F)0.253601, (F)-0.088752, 
(F)-0.640664, (F)-0.123897, (F)-0.000705, (F)-0.064314, (F)0.238454, (F)0.104862, 
(F)-0.281738, (F)-0.007910, (F)0.021251, (F)0.009345, (F)0.075551, (F)-0.202986, 
(F)-0.089265, (F)0.006733, 
(F)0.478699, (F)-0.076294, (F)0.012817, (F)0.433716, (F)-0.317566, (F)-0.229152, 
(F)-0.005821, (F)-0.000164, (F)-0.188109, (F)-0.100848, (F)0.036522, (F)-0.006136, 
(F)0.000978, (F)-0.207619, (F)0.033090, (F)-0.005559, (F)0.152018, (F)-0.024228, 
(F)0.004070, (F)0.137733, 
(F)-0.150330, (F)0.498535, (F)0.888123, (F)-0.238525, (F)0.111572, (F)-0.022599, 
(F)-0.248537, (F)-0.788762, (F)-0.056894, (F)-0.012448, (F)0.074945, (F)0.133511, 
(F)-0.442760, (F)-0.035857, (F)0.118913, (F)0.211840, (F)0.016773, (F)-0.055623, 
(F)-0.099090, (F)0.026613, 
(F)-0.096375, (F)0.021179, (F)-0.016602, (F)-0.166931, (F)0.978455, (F)-0.009288, 
(F)-0.000449, (F)-0.000276, (F)-0.027866, (F)-0.957373, (F)0.002041, (F)-0.001600, 
(F)0.000352, (F)-0.016088, (F)0.003535, (F)-0.002771, (F)0.094298, (F)-0.020723, 
(F)0.016244, (F)0.163335, 
(F)-0.386169, (F)0.081055, (F)0.310852, (F)-0.309998, (F)0.464905, (F)-0.149127, 
(F)-0.006570, (F)-0.096629, (F)-0.096098, (F)-0.216136, (F)0.031301, (F)0.120042, 
(F)-0.025196, (F)-0.119712, (F)0.025127, (F)0.096363, (F)0.179532, (F)-0.037683, 
(F)-0.144517, (F)0.144119, 
(F)0.200562, (F)-0.275208, (F)0.690063, (F)0.672913, (F)-0.160095, (F)-0.040225, 
(F)-0.075739, (F)-0.476188, (F)-0.452811, (F)-0.025630, (F)0.055196, (F)-0.138400, 
(F)0.189911, (F)-0.134960, (F)0.185191, (F)-0.464352, (F)0.032109, (F)-0.044059, 
(F)0.110476, (F)0.107730, 
(F)0.339783, (F)1.089661, (F)-0.229126, (F)0.071167, (F)-0.031677, (F)-0.115452, 
(F)-1.187360, (F)-0.052499, (F)-0.005065, (F)-0.001003, (F)-0.370248, (F)0.077853, 
(F)0.249670, (F)-0.024181, (F)-0.077548, (F)0.016306, (F)0.010763, (F)0.034517, 
(F)-0.007258, (F)0.002254, 
(F)-0.130371, (F)-0.025879, (F)0.933350, (F)0.311768, (F)-0.100586, (F)-0.016997, 
(F)-0.000670, (F)-0.871141, (F)-0.097199, (F)-0.010118, (F)-0.003374, (F)0.121682, 
(F)0.024154, (F)0.040645, (F)0.008068, (F)-0.290988, (F)-0.013113, (F)-0.002603, 
(F)0.093882, (F)0.031359, 
(F)0.138367, (F)-0.201233, (F)0.155579, (F)1.010925, (F)-0.048279, (F)-0.019145, 
(F)-0.040495, (F)-0.024205, (F)-1.021970, (F)-0.002331, (F)0.027844, (F)-0.021527, 
(F)0.031308, (F)-0.139878, (F)0.203431, (F)-0.157278, (F)0.006680, (F)-0.009715, 
(F)0.007511, (F)0.048806, 
(F)0.223083, (F)0.115906, (F)-0.205322, (F)0.383240, (F)0.763550, (F)-0.049766, 
(F)-0.013434, (F)-0.042157, (F)-0.146873, (F)-0.583008, (F)-0.025857, (F)0.045804, 
(F)0.023798, (F)-0.085494, (F)-0.044420, (F)0.078688, (F)-0.170335, (F)-0.088500, 
(F)0.156774, (F)-0.292623, 
(F)0.491455, (F)0.139465, (F)-0.377991, (F)0.313599, (F)0.366394, (F)-0.241528, 
(F)-0.019451, (F)-0.142877, (F)-0.098344, (F)-0.134245, (F)-0.068541, (F)0.185765, 
(F)0.052717, (F)-0.154120, (F)-0.043736, (F)0.118537, (F)-0.180066, (F)-0.051099, 
(F)0.138494, (F)-0.114901, 
(F)-0.023560, (F)-0.139832, (F)0.468689, (F)0.939148, (F)-0.166199, (F)-0.000555, 
(F)-0.019553, (F)-0.219669, (F)-0.881999, (F)-0.027622, (F)-0.003294, (F)0.011042, 
(F)0.065537, (F)0.022126, (F)0.131323, (F)-0.440168, (F)-0.003916, (F)-0.023240, 
(F)0.077896, (F)0.156085, 
(F)0.169495, (F)-0.071594, (F)0.243164, (F)0.798279, (F)0.153076, (F)-0.028728, 
(F)-0.005126, (F)-0.059129, (F)-0.637249, (F)-0.023432, (F)0.012135, (F)-0.041215, 
(F)0.017409, (F)-0.135304, (F)0.057152, (F)-0.194113, (F)-0.025946, (F)0.010959, 
(F)-0.037223, (F)-0.122197, 
(F)-0.114685, (F)0.108093, (F)-0.163818, (F)1.019592, (F)0.111877, (F)-0.013153, 
(F)-0.011684, (F)-0.026836, (F)-1.039568, (F)-0.012517, (F)0.012397, (F)-0.018788, 
(F)0.017708, (F)0.116932, (F)-0.110211, (F)0.167028, (F)0.012831, (F)-0.012093, 
(F)0.018328, (F)-0.114069, 
(F)0.064209, (F)0.274353, (F)0.947205, (F)0.089539, (F)-0.246094, (F)-0.004123, 
(F)-0.075270, (F)-0.897197, (F)-0.008017, (F)-0.060562, (F)-0.017616, (F)-0.060819, 
(F)-0.259868, (F)-0.005749, (F)-0.024565, (F)-0.084811, (F)0.015801, (F)0.067517, 
(F)0.233101, (F)0.022035, 
(F)0.183716, (F)0.155273, (F)0.425354, (F)0.461365, (F)0.121826, (F)-0.033752, 
(F)-0.024110, (F)-0.180926, (F)-0.212857, (F)-0.014842, (F)-0.028526, (F)-0.078144, 
(F)-0.066046, (F)-0.084760, (F)-0.071638, (F)-0.196243, (F)-0.022381, (F)-0.018916, 
(F)-0.051819, (F)-0.056206, 
(F)-0.317932, (F)-0.113953, (F)0.531799, (F)0.631775, (F)0.094543, (F)-0.101081, 
(F)-0.012985, (F)-0.282811, (F)-0.399140, (F)-0.008938, (F)-0.036229, (F)0.169076, 
(F)0.060600, (F)0.200862, (F)0.071992, (F)-0.335977, (F)0.030058, (F)0.010773, 
(F)-0.050278, (F)-0.059730, 
(F)-0.263306, (F)0.519592, (F)0.055725, (F)0.460632, (F)-0.166199, (F)-0.069330, 
(F)-0.269976, (F)-0.003105, (F)-0.212182, (F)-0.027622, (F)0.136812, (F)0.014673, 
(F)-0.028954, (F)0.121287, (F)-0.239341, (F)-0.025669, (F)-0.043761, (F)0.086356, 
(F)0.009261, (F)0.076557, 
(F)0.789124, (F)-0.074402, (F)0.149414, (F)0.107239, (F)0.384705, (F)-0.622716, 
(F)-0.005536, (F)-0.022325, (F)-0.011500, (F)-0.147998, (F)0.058712, (F)-0.117906, 
(F)0.011117, (F)-0.084625, (F)0.007979, (F)-0.016023, (F)-0.303579, (F)0.028623, 
(F)-0.057480, (F)-0.041255, 
(F)0.394592, (F)0.252197, (F)0.193298, (F)0.192871, (F)0.347717, (F)-0.155703, 
(F)-0.063603, (F)-0.037364, (F)-0.037199, (F)-0.120907, (F)-0.099515, (F)-0.076274, 
(F)-0.048749, (F)-0.076105, (F)-0.048642, (F)-0.037282, (F)-0.137207, (F)-0.087693, 
(F)-0.067213, (F)-0.067065, 
(F)-0.221924, (F)0.296570, (F)1.154419, (F)-0.081482, (F)0.049438, (F)-0.049250, 
(F)-0.087954, (F)-1.332683, (F)-0.006639, (F)-0.002444, (F)0.065816, (F)0.256193, 
(F)-0.342366, (F)-0.018083, (F)0.024165, (F)0.094064, (F)0.010972, (F)-0.014662, 
(F)-0.057073, (F)0.004028, 
(F)0.539795, (F)0.479980, (F)0.039917, (F)-0.247986, (F)-0.346680, (F)-0.291379, 
(F)-0.230381, (F)-0.001593, (F)-0.061497, (F)-0.120187, (F)-0.259091, (F)-0.021547, 
(F)-0.019159, (F)0.133861, (F)0.119028, (F)0.009899, (F)0.187136, (F)0.166399, 
(F)0.013838, (F)-0.085972, 
(F)0.113464, (F)0.160767, (F)0.563232, (F)0.060791, (F)0.577637, (F)-0.012874, 
(F)-0.025846, (F)-0.317231, (F)-0.003696, (F)-0.333664, (F)-0.018241, (F)-0.063907, 
(F)-0.090549, (F)-0.006898, (F)-0.009773, (F)-0.034239, (F)-0.065541, (F)-0.092865, 
(F)-0.325344, (F)-0.035115, 
(F)0.179993, (F)0.748291, (F)0.628052, (F)-0.030334, (F)-0.240662, (F)-0.032397, 
(F)-0.559939, (F)-0.394449, (F)-0.000920, (F)-0.057918, (F)-0.134687, (F)-0.113045, 
(F)-0.469965, (F)0.005460, (F)0.022699, (F)0.019052, (F)0.043317, (F)0.180085, 
(F)0.151148, (F)-0.007300, 
(F)-0.177185, (F)0.094727, (F)0.907410, (F)0.608521, (F)-0.030273, (F)-0.031395, 
(F)-0.008973, (F)-0.823392, (F)-0.370297, (F)-0.000916, (F)0.016784, (F)0.160779, 
(F)-0.085956, (F)0.107821, (F)-0.057643, (F)-0.552177, (F)-0.005364, (F)0.002868, 
(F)0.027470, (F)0.018422, 
(F)0.197937, (F)0.502563, (F)0.463013, (F)0.205872, (F)0.131287, (F)-0.039179, 
(F)-0.252570, (F)-0.214381, (F)-0.042383, (F)-0.017236, (F)-0.099476, (F)-0.091647, 
(F)-0.232693, (F)-0.040750, (F)-0.103464, (F)-0.095321, (F)-0.025986, (F)-0.065980, 
(F)-0.060787, (F)-0.027028, 
(F)-0.587830, (F)0.003662, (F)0.213684, (F)0.327087, (F)0.619507, (F)-0.345544, 
(F)-0.000013, (F)-0.045661, (F)-0.106986, (F)-0.383789, (F)0.002153, (F)0.125610, 
(F)-0.000783, (F)0.192272, (F)-0.001198, (F)-0.069893, (F)0.364164, (F)-0.002269, 
(F)-0.132379, (F)-0.202633, 
(F)-0.419556, (F)-0.155823, (F)-0.332397, (F)-0.133972, (F)-0.478577, (F)-0.176027, 
(F)-0.024281, (F)-0.110488, (F)-0.017949, (F)-0.229036, (F)-0.065376, (F)-0.139459, 
(F)-0.051795, (F)-0.056209, (F)-0.020876, (F)-0.044532, (F)-0.200790, (F)-0.074573, 
(F)-0.159078, (F)-0.064116, 
(F)-0.208313, (F)-0.069641, (F)0.282593, (F)0.830811, (F)0.481995, (F)-0.043394, 
(F)-0.004850, (F)-0.079859, (F)-0.690246, (F)-0.232319, (F)-0.014507, (F)0.058868, 
(F)0.019680, (F)0.173069, (F)0.057859, (F)-0.234781, (F)0.100406, (F)0.033567, 
(F)-0.136208, (F)-0.400446, 
(F)0.269165, (F)-0.346558, (F)0.488647, (F)-0.243652, (F)0.232605, (F)-0.072450, 
(F)-0.120102, (F)-0.238776, (F)-0.059366, (F)-0.054105, (F)0.093281, (F)-0.131527, 
(F)0.169344, (F)0.065583, (F)-0.084440, (F)0.119060, (F)-0.062609, (F)0.080611, 
(F)-0.113662, (F)0.056675, 
(F)0.345398, (F)0.704041, (F)0.134460, (F)-0.027588, (F)0.437561, (F)-0.119300, 
(F)-0.495673, (F)-0.018080, (F)-0.000761, (F)-0.191460, (F)-0.243174, (F)-0.046442, 
(F)-0.094666, (F)0.009529, (F)0.019423, (F)0.003709, (F)-0.151133, (F)-0.308061, 
(F)-0.058835, (F)0.012071, 
(F)0.177856, (F)-0.177856, (F)0.212708, (F)-0.242004, (F)0.834656, (F)-0.031633, 
(F)-0.031633, (F)-0.045244, (F)-0.058566, (F)-0.696650, (F)0.031633, (F)-0.037831, 
(F)0.037831, (F)0.043042, (F)-0.043042, (F)0.051476, (F)-0.148449, (F)0.148449, 
(F)-0.177538, (F)0.201990, 
(F)0.478699, (F)0.116394, (F)0.062378, (F)0.542114, (F)0.486572, (F)-0.229152, 
(F)-0.013548, (F)-0.003891, (F)-0.293888, (F)-0.236753, (F)-0.055718, (F)-0.029860, 
(F)-0.007260, (F)-0.259509, (F)-0.063099, (F)-0.033816, (F)-0.232922, (F)-0.056634, 
(F)-0.030351, (F)-0.263778, 
(F)0.842712, (F)0.581726, (F)0.087646, (F)0.098389, (F)0.108582, (F)-0.710164, 
(F)-0.338405, (F)-0.007682, (F)-0.009680, (F)-0.011790, (F)-0.490228, (F)-0.073861, 
(F)-0.050986, (F)-0.082913, (F)-0.057235, (F)-0.008623, (F)-0.091503, (F)-0.063165, 
(F)-0.009517, (F)-0.010683, 
(F)0.831299, (F)-0.325745, (F)0.332642, (F)-0.138123, (F)0.105164, (F)-0.691058, 
(F)-0.106110, (F)-0.110650, (F)-0.019078, (F)-0.011059, (F)0.270791, (F)-0.276525, 
(F)0.108356, (F)0.114821, (F)-0.044993, (F)0.045945, (F)-0.087422, (F)0.034256, 
(F)-0.034982, (F)0.014525, 
(F)0.323303, (F)0.511108, (F)0.541504, (F)0.469604, (F)0.399048, (F)-0.104525, 
(F)-0.261232, (F)-0.293226, (F)-0.220528, (F)-0.159239, (F)-0.165243, (F)-0.175070, 
(F)-0.276767, (F)-0.151825, (F)-0.240019, (F)-0.254293, (F)-0.129013, (F)-0.203957, 
(F)-0.216086, (F)-0.187395 };

#if COMPILE_MMX

short AcbkGainTable170Int[170*20] = {
     0,      0,      0,      0,      0,      0,      0,      0, 
     0,      0,      0,      0,      0,      0,      0,      0, 
     0,      0,      0,      0,    776,    212,    715,    670, 
   809,    -36,     -2,    -31,    -27,    -39,    -10,    -33, 
    -9,    -31,     -8,    -29,    -38,    -10,    -35,    -33, 
  1296,   1316,   -168,   -320,   -815,   -102,   -105,     -1, 
    -6,    -40,   -104,     13,     13,     25,     25,     -3, 
    64,     65,     -8,    -15,   -589,    680,   2478,    308, 
  -596,    -21,    -28,   -375,     -5,    -21,     24,     89, 
  -102,     11,    -12,    -46,    -21,     24,     90,     11, 
  -735,   -487,     -5,   2948,    468,    -33,    -14,      0, 
  -530,    -13,    -21,      0,      0,    132,     87,      0, 
    21,     13,      0,    -84,   1042,   1730,   1068,    333, 
   626,    -66,   -182,    -69,     -6,    -23,   -110,    -67, 
  -112,    -21,    -35,    -21,    -39,    -66,    -40,    -12, 
   486,   -769,   4074,   2825,  -1107,    -14,    -36,  -1013, 
  -487,    -74,     22,   -120,    191,    -83,    132,   -702, 
    32,    -52,    275,    191,   1521,   -767,   -124,   4320,
  1026,   -141,    -35,      0,  -1139,    -64,     71,     11, 
    -5,   -401,    202,     32,    -95,     48,      7,   -270, 
  2425,   1267,   3439,    -91,  -1166,   -359,    -98,   -722, 
     0,    -83,   -187,   -509,   -266,     13,      7,     19, 
   172,     90,    244,     -6,  -1251,    975,    173,   4039, 
  2005,    -95,    -58,     -1,   -996,   -245,     74,     13, 
   -10,    308,   -240,    -42,    153,   -119,    -21,   -494, 
  1820,    632,   1322,   2062,   1031,   -202,    -24,   -106, 
  -259,    -64,    -70,   -146,    -51,   -229,    -79,   -166, 
  -114,    -39,    -83,   -129,   -447,   4904,    244,   -315, 
 -2038,    -12,  -1467,     -3,     -6,   -253,    134,      6, 
   -73,     -8,     94,      4,    -55,    610,     30,    -39, 
  -208,  -1102,    463,   -448,   5653,     -2,    -74,    -13, 
   -12,  -1950,    -14,      5,     31,     -5,    -30,     12, 
    71,    380,   -159,    154,   4739,   2600,  -1864,    856, 
 -1554,  -1371,   -412,   -212,    -44,   -147,   -752,    539, 
   295,   -247,   -135,     97,    449,    246,   -176,     81, 
  1894,   3533,     35,    -26,   2145,   -219,   -762,      0, 
     0,   -280,   -408,     -4,     -7,      3,      5,      0,
  -248,   -462,     -4,      3,  -2699,   1841,   4072,   2443, 
  1582,   -444,   -207,  -1012,   -364,   -152,    303,    670, 
  -457,    402,   -274,   -607,    260,   -177,   -393,   -236, 
  -844,   3358,   6106,  -1059,   -537,    -43,   -688,  -2275, 
   -68,    -17,    173,    314,  -1251,    -54,    217,    395, 
   -27,    110,    200,    -34,   1251,   1016,   3020,   2210, 
  1445,    -95,    -63,   -556,   -298,   -127,    -77,   -230, 
  -187,   -168,   -137,   -407,   -110,    -89,   -266,   -194, 
  2099,   2277,   4038,   3533,  -2870,   -269,   -316,   -995, 
  -762,   -503,   -291,   -517,   -561,   -452,   -491,   -871, 
   367,    399,    707,    619,    400,  -1114,   8516,   2422, 
 -1117,     -9,    -75,  -4426,   -358,    -76,     27,   -208, 
   579,    -59,    164,  -1259,     27,    -75,    580,    165, 
 -4398,  -2011,   3912,  -2407,   2258,  -1180,   -247,   -934, 
  -353,   -311,   -540,   1050,    480,   -646,   -295,    575, 
   606,    277,   -539,    331,   1767,  -1447,   4240,   6160, 
  -757,   -190,   -127,  -1097,  -2316,    -35,    156,   -457, 
   374,   -664,    544,  -1594,     81,    -66,    195,    284, 
  1594,  -1463,   1035,   6938,   1920,   -155,   -130,    -65,
 -2938,   -225,    142,   -100,     92,   -675,    619,   -438, 
  -186,    171,   -121,   -813,   -562,   4716,   4085,   -591, 
  2421,    -19,  -1357,  -1018,    -21,   -357,    162,    140, 
 -1175,    -20,    170,    147,     83,   -696,   -603,     87, 
  1552,   8778,   -935,    354,  -1424,   -147,  -4703,    -53, 
    -7,   -123,   -831,     88,    501,    -33,   -189,     20, 
   134,    763,    -81,     30,   4831,  -4431,     41,  -1479, 
 -2976,  -1424,  -1198,      0,   -133,   -540,   1306,    -12, 
    11,    436,   -400,      3,    877,   -804,      7,   -268, 
  2090,   1192,   1006,   1645,   4853,   -266,    -86,    -61, 
  -165,  -1437,   -152,   -128,    -73,   -210,   -119,   -101, 
  -619,   -353,   -298,   -487,   2386,   5712,   1426,    -94, 
  1350,   -347,  -1991,   -124,      0,   -111,   -832,   -207, 
  -497,     13,     32,      8,   -196,   -470,   -117,      7, 
 -1349,   1091,   1659,   8891,    313,   -111,    -72,   -168, 
 -4825,     -5,     89,    136,   -110,    732,   -592,   -900, 
    25,    -20,    -31,   -170,   9980,    916,   -381,   -808, 
    88,  -6080,    -51,     -8,    -39,      0,   -558,    232, 
    21,    492,     45,    -18,    -53,     -4,      2,      4,
  2338,  -1031,   -248,   3928,   6484,   -333,    -64,     -3, 
  -942,  -2566,    147,     35,    -15,   -560,    247,     59, 
  -925,    408,     98,  -1555,   6166,  -1240,   -337,   3672, 
 -1277,  -2320,    -93,     -6,   -823,    -99,    466,    126, 
   -25,  -1382,    278,     75,    480,    -96,    -26,    286, 
  4377,   -132,  -2588,   1701,   4865,  -1169,     -1,   -409, 
  -176,  -1444,     35,    691,    -20,   -454,     13,    268, 
 -1299,     39,    768,   -505,   2594,   3295,   3944,   1481, 
   682,   -410,   -662,   -949,   -133,    -28,   -521,   -624, 
  -793,   -234,   -297,   -356,   -108,   -137,   -164,    -61, 
  4151,    624,    815,   4485,   2229,  -1052,    -23,    -40, 
 -1228,   -303,   -158,   -206,    -31,  -1136,   -170,   -223, 
  -565,    -84,   -111,   -610,  -3575,   -361,   4924,   2791, 
  4698,   -780,     -7,  -1480,   -475,  -1347,    -78,   1074, 
   108,    609,     61,   -839,   1025,    103,  -1412,   -800, 
 -2518,   3791,   8623,    315,   2465,   -387,   -877,  -4538, 
    -6,   -370,    582,   1325,  -1995,     48,    -73,   -166, 
   378,   -570,  -1297,    -47,   -691,   2989,   9957,   -421, 
 -1142,    -29,   -545,  -6051,    -10,    -79,    126,    420,
 -1817,    -17,     76,    256,    -48,    208,    694,    -29, 
 -1918,    104,  -3190,  -3410,  -4440,   -224,      0,   -621, 
  -709,  -1203,     12,   -373,     20,   -399,     21,   -664, 
  -519,     28,   -864,   -924,  -3359,  -1668,   1854,   6939, 
  1430,   -688,   -169,   -209,  -2939,   -124,   -341,    380, 
   188,   1422,    706,   -785,    293,    145,   -161,   -606, 
    42,   9706,   3164,   -952,    907,      0,  -5750,   -611, 
   -55,    -50,    -25,     -8,  -1874,      2,    564,    183, 
    -2,   -537,   -175,     52,   1607,    785,   2862,   4327, 
  3307,   -157,    -37,   -500,  -1143,   -667,    -77,   -280, 
  -137,   -424,   -207,   -756,   -324,   -158,   -577,   -873, 
  6801,   3416,   2227,   1682,  -3217,  -2823,   -712,   -302, 
  -172,   -631,  -1418,   -924,   -464,   -698,   -350,   -228, 
  1335,    670,    437,    330,   3459,   3898,    364,   7841, 
 -2640,   -730,   -927,     -8,  -3753,   -425,   -823,    -76, 
   -86,  -1655,  -1865,   -174,    557,    628,     58,   1263, 
 -5902,  -3458,  -2465,  -1886,   4334,  -2126,   -730,   -371, 
  -217,  -1146,  -1245,   -888,   -520,   -679,   -398,   -283, 
  1561,    915,    652,    499,  -3710,   1133,   7849,   3443,
  -215,   -840,    -78,  -3760,   -723,     -2,    256,   1777, 
  -543,    779,   -238,  -1649,    -48,     14,    103,     45, 
  4132,   2828,      2,  -4212,  -4116,  -1042,   -488,      0, 
 -1083,  -1034,   -713,      0,      0,   1062,    727,      0, 
  1038,    710,      0,  -1058,   5875,   8496,  -1796,   1376, 
 -1786,  -2107,  -4406,   -197,   -115,   -194,  -3047,    644, 
   931,   -493,   -713,    150,    640,    926,   -195,    150, 
  3143,   3483,   3546,   -793,   4489,   -603,   -740,   -767, 
   -38,  -1230,   -668,   -680,   -754,    152,    168,    171, 
  -861,   -954,   -971,    217,   2845,   7965,   3695,  -5432, 
  3978,   -494,  -3873,   -833,  -1801,   -966,  -1383,   -641, 
 -1796,    943,   2641,   1225,   -691,  -1934,   -897,   1319, 
  1538,    150,   7139,   2049,   3097,   -144,     -1,  -3110, 
  -256,   -585,    -14,   -670,    -65,   -192,    -18,   -892, 
  -290,    -28,  -1349,   -387,    618,   7520,   4729,   -238, 
 -3373,    -23,  -3452,  -1365,     -3,   -694,   -283,   -178, 
 -2170,      8,    109,     68,    127,   1548,    973,    -49, 
  2965,  -3013,   7912,   7076,  -1997,   -536,   -554,  -3821, 
 -3056,   -243,    545,  -1431,   1455,  -1280,   1301,  -3417,
   361,   -367,    964,    862,   2443,   -929,  -1113,   9677, 
  4138,   -364,    -52,    -75,  -5716,  -1045,    138,    166, 
   -63,  -1443,    549,    657,   -617,    234,    281,  -2444, 
  1966,   3309,  10085,  -3399,   2105,   -236,   -668,  -6207, 
  -705,   -270,   -397,  -1210,  -2037,    408,    686,   2092, 
  -252,   -425,  -1295,    436,   -112,  -1368,   8868,   4822, 
  2048,      0,   -114,  -4800,  -1419,   -256,     -9,     61, 
   740,     33,    402,  -2610,     14,    171,  -1108,   -602, 
 -2597,    438,  -1839,   6229,   7266,   -411,    -11,   -206, 
 -2368,  -3223,     69,   -291,     49,    987,   -166,    699, 
  1152,   -194,    816,  -2763,   3454,    553,   9127,   4946, 
 -5596,   -728,    -18,  -5084,  -1493,  -1911,   -116,  -1924, 
  -308,  -1042,   -166,  -2755,   1179,    188,   3117,   1689, 
  -532,   -663,  12262,   2495,  -1004,    -17,    -26,  -9177, 
  -380,    -61,    -21,    398,    496,     81,    101,  -1867, 
   -32,    -40,    751,    152,  -2100,   1317,  -1509,  11425, 
  2997,   -269,   -105,   -139,  -7967,   -548,    168,   -193, 
   121,   1464,   -918,   1052,    384,   -240,    276,  -2090, 
  1193,  -2697,  11259,   5373,   -763,    -86,   -444,  -7737,
 -1762,    -35,    196,   -819,   1853,   -391,    884,  -3692, 
    55,   -125,    525,    250,   2405,   -471,  11079,    203, 
   782,   -353,    -13,  -7491,     -2,    -37,     69,  -1626, 
   318,    -29,      5,   -137,   -114,     22,   -529,     -9, 
 -1871,   5685,  11290,  -2662,   1353,   -213,  -1972,  -7780, 
  -432,   -111,    649,   1289,  -3917,   -304,    923,   1834, 
   154,   -469,   -932,    220,  -3768,   5927,  -3093,   5041, 
  5212,   -866,  -2144,   -584,  -1551,  -1658,   1363,   -711, 
  1119,   1159,  -1824,    951,   1198,  -1885,    984,  -1603, 
 -2546,   9502,   5969,  -2440,   1928,   -395,  -5511,  -2175, 
  -363,   -226,   1477,    927,  -3462,   -379,   1415,    889, 
   299,  -1118,   -702,    287,  -4963,   3568,   4592,   5508, 
  3451,  -1503,   -777,  -1287,  -1851,   -727,   1080,   1391, 
 -1000,   1668,  -1199,  -1543,   1045,   -751,   -967,  -1160, 
  1745,  -2586,   3983,  10899,  -1551,   -186,   -408,   -968, 
 -7250,   -146,    275,   -424,    628,  -1161,   1720,  -2649, 
   165,   -244,    377,   1032,    867,   -456,   -727,   3369, 
 11822,    -45,    -12,    -32,   -692,  -8531,     24,     38, 
   -20,   -178,     93,    149,   -625,    329,    525,  -2431,
  7535,   2422,   1926,   1405,   1599,  -3466,   -358,   -226, 
  -120,   -156,  -1114,   -886,   -284,   -646,   -207,   -165, 
  -735,   -236,   -188,   -137,   1041,   -735,   -142,  13209, 
  1515,    -66,    -33,     -1, -10649,   -140,     46,      9, 
    -6,   -839,    593,    114,    -96,     68,     13,  -1222, 
  7950,   6745,  -1444,  -1008,   2721,  -3857,  -2777,   -127, 
   -62,   -452,  -3273,    700,    594,    489,    415,    -88, 
 -1320,  -1120,    239,    167,  -4754,  -1379,   4522,   -578, 
 -5733,  -1379,   -116,  -1248,    -20,  -2006,   -400,   1312, 
   380,   -167,    -48,    159,  -1663,   -482,   1582,   -202, 
  3220,   5978,   5923,   2430,  -2689,   -633,  -2181,  -2141, 
  -360,   -441,  -1175,  -1164,  -2161,   -477,   -886,   -878, 
   528,    981,    972,    398,    377,   1312,  13978,  -1470, 
   677,     -8,   -105, -11925,   -132,    -28,    -30,   -321, 
 -1119,     33,    117,   1254,    -15,    -54,   -577,     60, 
 -3435,   6770,    314,   -885,   5686,   -720,  -2797,     -6, 
   -47,  -1973,   1419,     65,   -129,   -185,    366,     16, 
  1192,  -2349,   -109,    307,   3171,   8774,  -2260,   2679, 
  3069,   -613,  -4699,   -312,   -438,   -575,  -1698,    437,
  1210,   -518,  -1435,    369,   -594,  -1643,    423,   -501, 
  5557,   1509,   5407,   -125,  -7386,  -1884,   -139,  -1784, 
     0,  -3330,   -511,  -1834,   -498,     42,     11,     41, 
  2505,    680,   2438,    -56,  -2838,   2595,  13228,    271, 
  1793,   -491,   -411, -10680,     -4,   -196,    449,   2291, 
 -2095,     47,    -42,   -219,    310,   -284,  -1447,    -29, 
   664,   -278,  14966,    951,   -711,    -26,     -4, -13672, 
   -55,    -30,     11,   -606,    253,    -38,     16,   -869, 
    28,    -12,    650,     41,    808,   1770,   8658,   5863, 
 -1486,    -39,   -191,  -4576,  -2098,   -134,    -87,   -427, 
  -935,   -289,   -633,  -3098,     73,    160,    785,    531, 
  3063,   1539,   2000,   -542,   9576,   -572,   -144,   -244, 
   -17,  -5597,   -287,   -374,   -188,    101,     51,     66, 
 -1790,   -900,  -1169,    317,    514,  14083,   -323,    896, 
  -891,    -16, -12106,     -6,    -49,    -48,   -442,     10, 
   277,    -28,   -770,     17,     27,    766,    -17,     48, 
   892,    158,   5237,  11057,  -1603,    -48,     -1,  -1674, 
 -7462,   -156,     -8,   -285,    -50,   -602,   -106,  -3534, 
    87,     15,    512,   1082,  -1612,   2564,  -4296,  12526,
  5710,   -158,   -401,  -1126,  -9576,  -1990,    252,   -422, 
   672,   1232,  -1960,   3284,    561,   -893,   1497,  -4365, 
  4889,  -6878,    612,   6109,   4753,  -1459,  -2887,    -22, 
 -2277,  -1379,   2052,   -182,    257,  -1823,   2564,   -228, 
 -1418,   1995,   -177,  -1772,   3053,   -506,   2403,   9625, 
  1322,   -569,    -15,   -352,  -5655,   -106,     94,   -448, 
    74,  -1794,    297,  -1412,   -246,     40,   -194,   -777, 
  -754,  12904,   4480,  -2113,   1471,    -34, -10163,  -1225, 
  -272,   -132,    594,    206,  -3529,    -97,   1664,    577, 
    67,  -1159,   -402,    189,   4255,   1476,   5055,   2393, 
  2912,  -1105,   -132,  -1559,   -349,   -517,   -383,  -1313, 
  -455,   -621,   -215,   -738,   -756,   -262,   -898,   -425, 
 -1371,    535,   1417,  14604,   -997,   -114,    -17,   -122, 
-13017,    -60,     44,    118,    -46,   1222,   -477,  -1263, 
   -83,     32,     86,    888,   5368,  -1744,   4083,  -1236, 
  3753,  -1758,   -185,  -1017,    -93,   -860,    571,  -1338, 
   434,    405,   -131,    308,  -1229,    399,   -935,    283, 
  1588,  -3097,  14415,   3699,  -1171,   -154,   -585, -12683, 
  -835,    -83,    300,  -1397,   2725,   -358,    699,  -3255,
   113,   -221,   1030,    264,    212,   7989,   9471,  -3344, 
  2009,     -2,  -3895,  -5475,   -682,   -246,   -103,   -123, 
 -4618,     43,   1630,   1933,    -26,   -979,  -1161,    410, 
   856,   2294,   -627,   6930,   6929,    -44,   -321,    -24, 
 -2931,  -2930,   -119,     32,     87,   -362,   -970,    265, 
  -362,   -970,    265,  -2931,   2357,  -4187,   7162,   7683, 
  3371,   -339,  -1070,  -3131,  -3603,   -693,    602,  -1030, 
  1830,  -1105,   1963,  -3359,   -485,    861,  -1474,  -1581, 
   350,   4585,  14053,  -3819,   1218,     -7,  -1283, -12054, 
  -890,    -90,    -97,   -300,  -3933,     81,   1068,   3275, 
   -26,   -341,  -1045,    284,  -3248,   3531,    475,   2137, 
 11711,   -644,   -761,    -13,   -278,  -8372,    700,     94, 
  -102,    423,   -460,    -62,   2322,  -2524,   -340,  -1528, 
 -3017,   3852,   1725,   8440,   5257,   -555,   -905,   -181, 
 -4348,  -1686,    709,    317,   -405,   1554,  -1984,   -889, 
   968,  -1236,   -553,  -2708,   -909,   3196,  15512,  -2528, 
  1066,    -50,   -623, -14686,   -390,    -69,    177,    861, 
 -3026,   -140,    493,   2393,     59,   -208,  -1009,    164, 
   959,  -3370,   9617,   9545,  -1761,    -56,   -693,  -5645,
 -5561,   -189,    197,   -563,   1978,   -558,   1963,  -5603, 
   103,   -362,   1034,   1026,   7575,  11796,  -4845,   3252, 
 -1703,  -3502,  -8493,  -1433,   -645,   -177,  -5454,   2240, 
  3488,  -1503,  -2341,    961,    787,   1226,   -503,    338, 
  6409,   1722,   1764,  -4191,   6015,  -2507,   -181,   -189, 
 -1072,  -2208,   -673,   -690,   -185,   1639,    440,    451, 
 -2353,   -632,   -647,   1538,  -2420,  12161,   5038,   1286, 
 -2098,   -357,  -9027,  -1549,   -100,   -268,   1796,    744, 
 -3740,    190,   -954,   -395,   -310,   1557,    645,    164, 
 -2232,  -1341,   7246,   9470,  -1977,   -304,   -109,  -3204, 
 -5474,   -238,   -182,    987,    593,   1290,    775,  -4188, 
  -269,   -161,    874,   1143,   1030,   7034,   4231,   1551, 
  3077,    -64,  -3019,  -1093,   -146,   -577,   -442,   -266, 
 -1816,    -97,   -666,   -400,   -193,  -1321,   -794,   -291, 
  5121,  11835,   -477,  -1749,   2298,  -1601,  -8549,    -13, 
  -186,   -322,  -3699,    149,    344,    546,   1264,    -50, 
  -718,  -1660,     66,    245,  -3328,   3827,   5921,   9976, 
 -1045,   -676,   -894,  -2140,  -6075,    -66,    777,   1203, 
 -1383,   2027,  -2330,  -3605,   -212,    244,    377,    636,
  3813,   5718,  -4666,  -3412,   5674,   -887,  -1995,  -1329, 
  -710,  -1965,  -1331,   1086,   1628,    794,   1191,   -972, 
 -1320,  -1980,   1616,   1181,   1348,  -3672,  13154,   6938, 
 -1690,   -110,   -823, -10561,  -2938,   -174,    302,  -1082, 
  2948,   -570,   1555,  -5570,    139,   -379,   1357,    716, 
  2151,  -3586,   6949,  12131,  -1224,   -282,   -785,  -2947, 
 -8982,    -91,    470,   -912,   1521,  -1592,   2655,  -5145, 
   160,   -268,    519,    906,  -2889,   9647,  10276,  -2728, 
   995,   -509,  -5680,  -6445,   -454,    -60,   1701,   1812, 
 -6051,   -481,   1606,   1711,    175,   -586,   -624,    165, 
  6177,   2184,    555,   1985,   6589,  -2329,   -291,    -18, 
  -240,  -2650,   -823,   -209,    -74,   -748,   -264,    -67, 
 -2484,   -878,   -223,   -798,   -492,    391,  17166,   -681, 
   240,    -14,     -9, -17987,    -28,     -3,     11,    515, 
  -410,    -20,     16,    713,      7,     -5,   -252,     10, 
 12628,   5448,  -2630,   3011,  -2695,  -9733,  -1811,   -422, 
  -553,   -443,  -4199,   2027,    874,  -2321,  -1001,    483, 
  2077,    896,   -432,    495,  -3628,   -534,   3447,   7002, 
  6751,   -803,    -17,   -725,  -2992,  -2782,   -118,    763,
   112,   1550,    228,  -1473,   1495,    220,  -1420,  -2885, 
 -5239,   5901,   8107,   3650,   4846,  -1675,  -2125,  -4012, 
  -813,  -1433,   1887,   2592,  -2920,   1167,  -1315,  -1806, 
  1550,  -1745,  -2398,  -1080,   6157,   6678,   4099,  -1074, 
  2348,  -2314,  -2722,  -1025,    -70,   -336,  -2509,  -1540, 
 -1670,    403,    437,    268,   -882,   -957,   -587,    153, 
  1079,  16099,    242,   -881,   1690,    -71, -15820,     -3, 
   -47,   -174,  -1060,    -16,   -238,     58,    865,     13, 
  -111,  -1661,    -25,     90,   -278,    227,  -1039,   1636, 
 16945,     -4,     -3,    -65,   -163, -17526,      3,    -17, 
    14,     27,    -22,    103,    287,   -234,   1074,  -1693, 
 15778,  -1454,    574,   -603,   -107, -15195,   -129,    -20, 
   -22,      0,   1400,   -553,     51,    581,    -53,     21, 
   103,     -9,      3,     -3,   2406,   -836,  13224,   7993, 
 -4266,   -353,    -42, -10673,  -3899,  -1111,    122,  -1942, 
   674,  -1174,    407,  -6451,    626,   -217,   3443,   2081, 
  3184,  14368,  -3336,   2255,  -1801,   -619, -12600,   -679, 
  -310,   -198,  -2793,    648,   2926,   -438,  -1977,    459, 
   350,   1580,   -366,    247,  -1698,  17076,   2504,   -539,
  -646,   -176, -17798,   -382,    -17,    -25,   1770,    259, 
 -2610,    -55,    561,     82,    -67,    673,     98,    -21, 
  2375,   -797,  -2696,  14483,   5383,   -344,    -38,   -443, 
-12803,  -1769,    115,    391,   -131,  -2100,    705,   2384, 
  -780,    262,    886,  -4759,  -2691,   2554,  -4520,   9573, 
 10655,   -442,   -398,  -1247,  -5594,  -6930,    419,   -742, 
   704,   1572,  -1492,   2641,   1750,  -1661,   2939,  -6226, 
 -4332,  -4399,  -1657,   4880,   7375,  -1145,  -1181,   -167, 
 -1453,  -3319,  -1163,   -438,   -444,   1290,   1310,    493, 
  1950,   1980,    745,  -2196,  -3498,   7405,   9955,   2693, 
 -2971,   -746,  -3347,  -6049,   -442,   -538,   1581,   2125, 
 -4499,    575,  -1217,  -1636,   -634,   1342,   1805,    488, 
  6717,  -3792,   7739,   2798,   3489,  -2754,   -877,  -3655, 
  -477,   -743,   1554,  -3173,   1791,  -1147,    647,  -1321, 
 -1430,    807,  -1648,   -595,   5263,   9770,   3463,   1069, 
 -3971,  -1690,  -5826,   -732,    -69,   -962,  -3138,  -1112, 
 -2065,   -343,   -637,   -226,   1275,   2368,    839,    259, 
  1243,  -2634,  16772,   1871,    332,    -94,   -423, -17169, 
  -213,     -6,    199,  -1273,   2696,   -142,    300,  -1915,
   -25,     53,   -339,    -37,   2691,   2836,   3105,   5711, 
  4817,   -442,   -491,   -588,  -1991,  -1416,   -465,   -510, 
  -537,   -938,   -988,  -1082,   -791,   -834,   -913,  -1679, 
  4366,   2944,   7210,   3627,   1161,  -1163,   -529,  -3172, 
  -803,    -82,   -784,  -1921,  -1295,   -966,   -651,  -1596, 
  -309,   -208,   -511,   -257,  13888,   3951,   -671,  -2305, 
  3354, -11773,   -953,    -27,   -324,   -686,  -3349,    569, 
   161,   1954,    556,    -94,  -2843,   -809,    137,    472, 
  7053,   5847,   2929,   8378,  -4794,  -3036,  -2086,   -523, 
 -4284,  -1403,  -2517,  -1261,  -1045,  -3607,  -2990,  -1498, 
  2064,   1711,    857,   2451,  -2191,  12838,   9182,  -3915, 
  1617,   -293, -10059,  -5146,   -935,   -159,   1717,   1228, 
 -7195,   -523,   3068,   2194,    216,  -1267,   -906,    386, 
 -4881,  13114,   5767,   -435,   4155,  -1454, -10498,  -2030, 
   -11,  -1054,   3907,   1718,  -4616,   -129,    348,    153, 
  1238,  -3326,  -1462,    110,   7843,  -1250,    210,   7106, 
 -5203,  -3754,    -95,     -2,  -3082,  -1652,    598,   -100, 
    16,  -3402,    542,    -91,   2491,   -397,     66,   2257, 
 -2463,   8168,  14551,  -3908,   1828,   -370,  -4072, -12923,
  -932,   -204,   1228,   2188,  -7254,   -587,   1948,   3471, 
   274,   -911,  -1623,    436,  -1579,    347,   -272,  -2735, 
 16031,   -152,     -7,     -4,   -456, -15686,     33,    -26, 
     5,   -263,     58,    -45,   1545,   -340,    266,   2676, 
 -6327,   1328,   5093,  -5079,   7617,  -2443,   -107,  -1583, 
 -1574,  -3541,    513,   1967,   -413,  -1961,    411,   1578, 
  2941,   -617,  -2367,   2361,   3286,  -4509,  11306,  11025, 
 -2623,   -659,  -1241,  -7802,  -7419,   -420,    904,  -2267, 
  3112,  -2211,   3034,  -7608,    526,   -722,   1810,   1765, 
  5567,  17853,  -3754,   1166,   -519,  -1892, -19455,   -860, 
   -83,    -16,  -6067,   1275,   4090,   -396,  -1271,    267, 
   176,    566,   -119,     37,  -2136,   -424,  15292,   5108, 
 -1648,   -278,    -10, -14273,  -1593,   -165,    -55,   1993, 
   396,    666,    132,  -4768,   -214,    -42,   1538,    514, 
  2267,  -3297,   2549,  16563,   -791,   -313,   -663,   -396, 
-16745,    -38,    456,   -352,    513,  -2291,   3333,  -2576, 
   109,   -159,    123,    799,   3655,   1899,  -3364,   6279, 
 12510,   -815,   -220,   -690,  -2406,  -9552,   -423,    750, 
   390,  -1400,   -728,   1289,  -2791,  -1450,   2568,  -4794,
  8052,   2285,  -6193,   5138,   6003,  -3957,   -318,  -2341, 
 -1611,  -2199,  -1123,   3044,    864,  -2525,   -716,   1942, 
 -2950,   -837,   2269,  -1882,   -386,  -2291,   7679,  15387, 
 -2723,     -9,   -320,  -3599, -14452,   -452,    -54,    181, 
  1074,    362,   2152,  -7212,    -64,   -380,   1276,   2557, 
  2777,  -1173,   3984,  13079,   2508,   -470,    -84,   -969, 
-10440,   -384,    198,   -675,    285,  -2217,    936,  -3180, 
  -425,    179,   -610,  -2002,  -1879,   1771,  -2684,  16705, 
  1833,   -215,   -191,   -439, -17032,   -205,    203,   -308, 
   290,   1916,  -1805,   2736,    210,   -198,    300,  -1869, 
  1052,   4495,  15519,   1467,  -4032,    -67,  -1233, -14700, 
  -131,   -992,   -288,   -997,  -4257,    -94,   -402,  -1389, 
   259,   1106,   3819,    361,   3010,   2544,   6969,   7559, 
  1996,   -553,   -395,  -2964,  -3487,   -243,   -467,  -1280, 
 -1082,  -1388,  -1174,  -3215,   -366,   -310,   -849,   -921, 
 -5209,  -1867,   8713,  10351,   1549,  -1656,   -212,  -4634, 
 -6540,   -146,   -593,   2770,    993,   3291,   1180,  -5505, 
   492,    176,   -824,   -979,  -4314,   8513,    913,   7547, 
 -2723,  -1135,  -4423,    -50,  -3476,   -452,   2241,    240,
  -474,   1987,  -3921,   -420,   -717,   1415,    151,   1254, 
 12929,  -1219,   2448,   1757,   6303, -10204,    -90,   -365, 
  -188,  -2425,    962,  -1932,    182,  -1386,    130,   -262, 
 -4974,    469,   -941,   -676,   6465,   4132,   3167,   3160, 
  5697,  -2551,  -1042,   -612,   -609,  -1981,  -1630,  -1249, 
  -798,  -1247,   -797,   -611,  -2248,  -1437,  -1101,  -1099, 
 -3636,   4859,  18914,  -1335,    810,   -807,  -1441, -21836, 
  -108,    -40,   1078,   4198,  -5609,   -296,    396,   1541, 
   179,   -240,   -936,     66,   8844,   7864,    654,  -4063, 
 -5680,  -4774,  -3774,    -26,  -1007,  -1969,  -4245,   -353, 
  -314,   2193,   1950,    162,   3066,   2726,    226,  -1408, 
  1859,   2634,   9228,    996,   9464,   -211,   -423,  -5197, 
   -60,  -5467,   -299,  -1047,  -1483,   -113,   -160,   -561, 
 -1074,  -1521,  -5330,   -575,   2949,  12260,  10290,   -497, 
 -3943,   -530,  -9174,  -6463,    -15,   -949,  -2206,  -1852, 
 -7700,     89,    372,    312,    709,   2950,   2476,   -119, 
 -2903,   1552,  14867,   9970,   -496,   -514,   -147, -13491, 
 -6068,    -15,    275,   2634,  -1408,   1766,   -944,  -9047, 
   -87,     47,    450,    302,   3243,   8234,   7586,   3373,
  2151,   -642,  -4138,  -3512,   -694,   -282,  -1630,  -1501, 
 -3812,   -667,  -1695,  -1561,   -425,  -1081,   -996,   -442, 
 -9631,     60,   3501,   5359,  10150,  -5662,      0,   -748, 
 -1752,  -6288,     35,   2058,    -12,   3150,    -19,  -1145, 
  5967,    -37,  -2169,  -3320,  -6874,  -2553,  -5446,  -2195, 
 -7841,  -2884,   -397,  -1810,   -294,  -3753,  -1071,  -2285, 
  -848,   -921,   -342,   -729,  -3290,  -1221,  -2606,  -1050, 
 -3413,  -1141,   4630,  13612,   7897,   -711,    -79,  -1308, 
-11310,  -3806,   -237,    964,    322,   2836,    948,  -3847, 
  1645,    550,  -2231,  -6561,   4410,  -5678,   8006,  -3992, 
  3811,  -1187,  -1968,  -3912,   -973,   -886,   1528,  -2155, 
  2775,   1074,  -1383,   1951,  -1025,   1321,  -1862,    928, 
  5659,  11535,   2203,   -452,   7169,  -1954,  -8121,   -296, 
   -12,  -3137,  -3984,   -761,  -1551,    156,    318,     60, 
 -2476,  -5048,   -964,    197,   2914,  -2914,   3485,  -3965, 
 13675,   -518,   -518,   -741,   -959, -11414,    518,   -620, 
   620,    705,   -705,    843,  -2433,   2432,  -2909,   3310, 
  7843,   1907,   1022,   8882,   7972,  -3755,   -222,    -63, 
 -4815,  -3879,   -913,   -489,   -119,  -4252,  -1034,   -554,
 -3816,   -928,   -497,  -4322,  13807,   9531,   1436,   1612,
  1779, -11636,  -5544,   -125,   -158,   -193,  -8032,  -1210,
  -835,  -1358,   -938,   -141,  -1499,  -1035,   -156,   -175,
 13620,  -5337,   5450,  -2263,   1723, -11322,  -1738,  -1813,
  -312,   -181,   4436,  -4531,   1775,   1881,   -737,    752,
 -1432,    561,   -573,    238,   5297,   8374,   8872,   7694,
  6538,  -1712,  -4280,  -4804,  -3613,  -2609,  -2707,  -2868,
 -4534,  -2487,  -3932,  -4166,  -2113,  -3341,  -3540,  -3070 };

#endif


 float AcbkGainTable170subset[85*20] = {
 0.323303f, 0.511108f, 0.541504f, 0.469604f, 0.399048f,
-0.104492f,-0.261230f,-0.293213f,-0.220520f,-0.159241f,
-0.165222f,-0.175049f,-0.276733f,-0.151794f,-0.239990f,
-0.254272f,-0.128967f,-0.203918f,-0.216064f,-0.187378f,
 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f,
 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f,
 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f,
 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f,
 0.096924f,-0.189026f, 0.879822f, 0.225769f,-0.071472f,
-0.009399f,-0.035706f,-0.774109f,-0.050964f,-0.005066f,
 0.018311f,-0.085266f, 0.166321f,-0.021851f, 0.042664f,
-0.198669f, 0.006897f,-0.013489f, 0.062866f, 0.016113f,
 0.082275f,-0.224121f, 0.802856f, 0.423462f,-0.103149f,
-0.006714f,-0.050232f,-0.644592f,-0.179321f,-0.010620f,
 0.018433f,-0.066040f, 0.179932f,-0.034790f, 0.094910f,
-0.339966f, 0.008484f,-0.023132f, 0.082825f, 0.043701f,
-0.133728f, 0.783569f, 0.560425f,-0.238953f, 0.098694f,
-0.017883f,-0.613953f,-0.314087f,-0.057068f,-0.009705f,
 0.104797f, 0.074951f,-0.439148f,-0.031921f, 0.187256f,
 0.133911f, 0.013184f,-0.077332f,-0.055298f, 0.023560f,
-0.419556f,-0.155823f,-0.332397f,-0.133972f,-0.478577f,
-0.176025f,-0.024231f,-0.110474f,-0.017944f,-0.229065f,
-0.065369f,-0.139465f,-0.051758f,-0.056213f,-0.020874f,
-0.044495f,-0.200806f,-0.074524f,-0.159058f,-0.064087f,
-0.030029f, 0.023865f, 1.047729f,-0.041565f, 0.014648f,
-0.000854f,-0.000549f,-1.097839f,-0.001709f,-0.000183f,
 0.000671f, 0.031433f,-0.025024f,-0.001221f, 0.000977f,
 0.043518f, 0.000427f,-0.000305f,-0.015381f, 0.000610f,
-0.055481f, 0.195068f, 0.946777f,-0.154297f, 0.065063f,
-0.003052f,-0.038025f,-0.896362f,-0.023804f,-0.004211f,
 0.010803f, 0.052551f,-0.184692f,-0.008545f, 0.030090f,
 0.146057f, 0.003601f,-0.012695f,-0.061584f, 0.010010f,
-0.268433f,-0.122742f, 0.238770f,-0.146912f, 0.137817f,
-0.072021f,-0.015076f,-0.057007f,-0.021545f,-0.018982f,
-0.032959f, 0.064087f, 0.029297f,-0.039429f,-0.018005f,
 0.035095f, 0.036987f, 0.016907f,-0.032898f, 0.020203f,
-0.130371f,-0.025879f, 0.933350f, 0.311768f,-0.100586f,
-0.016968f,-0.000610f,-0.871155f,-0.097229f,-0.010071f,
-0.003357f, 0.121643f, 0.024170f, 0.040649f, 0.008057f,
-0.291016f,-0.013062f,-0.002563f, 0.093872f, 0.031372f,
 0.294861f,-0.270447f, 0.002502f,-0.090271f,-0.181641f,
-0.086914f,-0.073120f, 0.000000f,-0.008118f,-0.032959f,
 0.079712f,-0.000732f, 0.000671f, 0.026611f,-0.024414f,
 0.000183f, 0.053528f,-0.049072f, 0.000427f,-0.016357f,
-0.044861f,-0.029724f,-0.000305f, 0.179932f, 0.028564f,
-0.002014f,-0.000854f, 0.000000f,-0.032349f,-0.000793f,
-0.001282f, 0.000000f, 0.000000f, 0.008057f, 0.005310f,
 0.000000f, 0.001282f, 0.000793f, 0.000000f,-0.005127f,
-0.027283f, 0.299316f, 0.014893f,-0.019226f,-0.124390f,
-0.000732f,-0.089539f,-0.000183f,-0.000366f,-0.015442f,
 0.008179f, 0.000366f,-0.004456f,-0.000488f, 0.005737f,
 0.000244f,-0.003357f, 0.037231f, 0.001831f,-0.002380f,
 0.075867f,-0.160767f, 1.023682f, 0.114197f, 0.020264f,
-0.005737f,-0.025818f,-1.047913f,-0.013000f,-0.000366f,
 0.012146f,-0.077698f, 0.164551f,-0.008667f, 0.018311f,
-0.116882f,-0.001526f, 0.003235f,-0.020691f,-0.002258f,
 0.079102f, 0.080322f,-0.010254f,-0.019531f,-0.049744f,
-0.006226f,-0.006409f,-0.000061f,-0.000366f,-0.002441f,
-0.006348f, 0.000793f, 0.000793f, 0.001526f, 0.001526f,
-0.000183f, 0.003906f, 0.003967f,-0.000488f,-0.000916f,
 0.047363f, 0.012939f, 0.043640f, 0.040894f, 0.049377f,
-0.002197f,-0.000122f,-0.001892f,-0.001648f,-0.002380f,
-0.000610f,-0.002014f,-0.000549f,-0.001892f,-0.000488f,
-0.001770f,-0.002319f,-0.000610f,-0.002136f,-0.002014f,
-0.290161f,-0.084167f, 0.276001f,-0.035278f,-0.349915f,
-0.084167f,-0.007080f,-0.076172f,-0.001221f,-0.122437f,
-0.024414f, 0.080078f, 0.023193f,-0.010193f,-0.002930f,
 0.009705f,-0.101501f,-0.029419f, 0.096558f,-0.012329f,
-0.098389f, 0.156494f,-0.262207f, 0.764526f, 0.348511f,
-0.009644f,-0.024475f,-0.068726f,-0.584473f,-0.121460f,
 0.015381f,-0.025757f, 0.041016f, 0.075195f,-0.119629f,
 0.200439f, 0.034241f,-0.054504f, 0.091370f,-0.266418f,
 0.179993f, 0.748291f, 0.628052f,-0.030334f,-0.240662f,
-0.032349f,-0.559937f,-0.394470f,-0.000916f,-0.057922f,
-0.134644f,-0.113037f,-0.469971f, 0.005432f, 0.022705f,
 0.019043f, 0.043274f, 0.180054f, 0.151123f,-0.007263f,
-0.114685f, 0.108093f,-0.163818f, 1.019592f, 0.111877f,
-0.013123f,-0.011658f,-0.026794f,-1.039551f,-0.012512f,
 0.012390f,-0.018799f, 0.017700f, 0.116943f,-0.110168f,
 0.166992f, 0.012817f,-0.012085f, 0.018311f,-0.114075f,
 0.138367f,-0.201233f, 0.155579f, 1.010925f,-0.048279f,
-0.019104f,-0.040466f,-0.024170f,-1.022034f,-0.002319f,
 0.027832f,-0.021484f, 0.031311f,-0.139832f, 0.203430f,
-0.157227f, 0.006653f,-0.009705f, 0.007507f, 0.048767f,
 0.040527f,-0.016968f, 0.913452f, 0.058044f,-0.043396f,
-0.001587f,-0.000244f,-0.834473f,-0.003357f,-0.001831f,
 0.000671f,-0.036987f, 0.015442f,-0.002319f, 0.000977f,
-0.053040f, 0.001709f,-0.000732f, 0.039673f, 0.002502f,
 0.063599f, 0.105591f, 0.065186f, 0.020325f, 0.038208f,
-0.004028f,-0.011108f,-0.004211f,-0.000366f,-0.001404f,
-0.006714f,-0.004089f,-0.006836f,-0.001282f,-0.002136f,
-0.001282f,-0.002380f,-0.004028f,-0.002441f,-0.000732f,
-0.173218f, 0.158386f, 0.807373f, 0.016541f, 0.109436f,
-0.029968f,-0.025085f,-0.651855f,-0.000244f,-0.011963f,
 0.027405f, 0.139832f,-0.127869f, 0.002869f,-0.002563f,
-0.013367f, 0.018921f,-0.017334f,-0.088318f,-0.001770f,
 0.146851f,-0.051025f, 0.807129f, 0.487854f,-0.260376f,
-0.021545f,-0.002563f,-0.651428f,-0.237976f,-0.067810f,
 0.007446f,-0.118530f, 0.041138f,-0.071655f, 0.024841f,
-0.393738f, 0.038208f,-0.013245f, 0.210144f, 0.127014f,
 0.023010f, 0.080078f, 0.853149f,-0.089722f, 0.041321f,
-0.000488f,-0.006409f,-0.727844f,-0.008057f,-0.001709f,
-0.001831f,-0.019592f,-0.068298f, 0.002014f, 0.007141f,
 0.076538f,-0.000916f,-0.003296f,-0.035217f, 0.003662f,
-0.150330f, 0.498535f, 0.888123f,-0.238525f, 0.111572f,
-0.022583f,-0.248535f,-0.788757f,-0.056885f,-0.012451f,
 0.074951f, 0.133545f,-0.442749f,-0.035828f, 0.118896f,
 0.211853f, 0.016724f,-0.055603f,-0.099060f, 0.026611f,
-0.218201f,-0.022034f, 0.300537f, 0.170349f, 0.286743f,
-0.047607f,-0.000427f,-0.090332f,-0.028992f,-0.082214f,
-0.004761f, 0.065552f, 0.006592f, 0.037170f, 0.003723f,
-0.051208f, 0.062561f, 0.006287f,-0.086182f,-0.048828f,
-0.012695f,-0.067261f, 0.028259f,-0.027344f, 0.345032f,
-0.000122f,-0.004517f,-0.000793f,-0.000732f,-0.119019f,
-0.000854f, 0.000305f, 0.001892f,-0.000305f,-0.001831f,
 0.000732f, 0.004333f, 0.023193f,-0.009705f, 0.009399f,
 0.131287f,-0.218872f, 0.424133f, 0.740417f,-0.074707f,
-0.017212f,-0.047913f,-0.179871f,-0.548218f,-0.005554f,
 0.028687f,-0.055664f, 0.092834f,-0.097168f, 0.162048f,
-0.314026f, 0.009766f,-0.016357f, 0.031677f, 0.055298f,
-0.221924f, 0.296570f, 1.154419f,-0.081482f, 0.049438f,
-0.049255f,-0.087952f,-1.332764f,-0.006592f,-0.002441f,
 0.065796f, 0.256226f,-0.342346f,-0.018066f, 0.024170f,
 0.094055f, 0.010925f,-0.014648f,-0.057129f, 0.004028f,
-0.360229f,-0.211060f,-0.150452f,-0.115112f, 0.264526f,
-0.129761f,-0.044556f,-0.022644f,-0.013245f,-0.069946f,
-0.075989f,-0.054199f,-0.031738f,-0.041443f,-0.024292f,
-0.017273f, 0.095276f, 0.055847f, 0.039795f, 0.030457f,
-0.208313f,-0.069641f, 0.282593f, 0.830811f, 0.481995f,
-0.043396f,-0.004822f,-0.079834f,-0.690308f,-0.232300f,
-0.014465f, 0.058838f, 0.019653f, 0.173096f, 0.057861f,
-0.234802f, 0.100403f, 0.033569f,-0.136169f,-0.400452f,
 0.158325f, 0.201111f, 0.240723f, 0.090393f, 0.041626f,
-0.025024f,-0.040405f,-0.057922f,-0.008118f,-0.001709f,
-0.031799f,-0.038086f,-0.048401f,-0.014282f,-0.018127f,
-0.021729f,-0.006592f,-0.008362f,-0.010010f,-0.003723f,
 0.065857f, 0.982605f, 0.014771f,-0.053772f, 0.103149f,
-0.004333f,-0.965576f,-0.000183f,-0.002869f,-0.010620f,
-0.064697f,-0.000977f,-0.014526f, 0.003540f, 0.052795f,
 0.000793f,-0.006775f,-0.101379f,-0.001526f, 0.005493f,
 0.021362f, 0.279846f, 0.857727f,-0.233093f, 0.074341f,
-0.000427f,-0.078308f,-0.735718f,-0.054321f,-0.005493f,
-0.005920f,-0.018311f,-0.240051f, 0.004944f, 0.065186f,
 0.199890f,-0.001587f,-0.020813f,-0.063782f, 0.017334f,
-0.035950f, 0.041504f, 0.151245f, 0.018799f,-0.036377f,
-0.001282f,-0.001709f,-0.022888f,-0.000305f,-0.001282f,
 0.001465f, 0.005432f,-0.006226f, 0.000671f,-0.000732f,
-0.002808f,-0.001282f, 0.001465f, 0.005493f, 0.000671f,
 0.098083f, 0.047913f, 0.174683f, 0.264099f, 0.201843f,
-0.009583f,-0.002258f,-0.030518f,-0.069763f,-0.040710f,
-0.004700f,-0.017090f,-0.008362f,-0.025879f,-0.012634f,
-0.046143f,-0.019775f,-0.009644f,-0.035217f,-0.053284f,
 0.377014f, 0.133301f, 0.033875f, 0.121155f, 0.402161f,
-0.142151f,-0.017761f,-0.001099f,-0.014648f,-0.161743f,
-0.050232f,-0.012756f,-0.004517f,-0.045654f,-0.016113f,
-0.004089f,-0.151611f,-0.053589f,-0.013611f,-0.048706f,
 0.842712f, 0.581726f, 0.087646f, 0.098389f, 0.108582f,
-0.710205f,-0.338379f,-0.007629f,-0.009644f,-0.011780f,
-0.490234f,-0.073853f,-0.050964f,-0.082886f,-0.057251f,
-0.008606f,-0.091492f,-0.063171f,-0.009521f,-0.010681f,
 0.269165f,-0.346558f, 0.488647f,-0.243652f, 0.232605f,
-0.072449f,-0.120117f,-0.238770f,-0.059387f,-0.054077f,
 0.093262f,-0.131531f, 0.169373f, 0.065552f,-0.084412f,
 0.119080f,-0.062561f, 0.080627f,-0.113647f, 0.056641f,
-0.032471f,-0.040466f, 0.748413f, 0.152283f,-0.061279f,
-0.001038f,-0.001587f,-0.560120f,-0.023193f,-0.003723f,
-0.001282f, 0.024292f, 0.030273f, 0.004944f, 0.006165f,
-0.113953f,-0.001953f,-0.002441f, 0.045837f, 0.009277f,
-0.117065f, 0.006348f,-0.194702f,-0.208130f,-0.270996f,
-0.013672f, 0.000000f,-0.037903f,-0.043274f,-0.073425f,
 0.000732f,-0.022766f, 0.001221f,-0.024353f, 0.001282f,
-0.040527f,-0.031677f, 0.001709f,-0.052734f,-0.056396f,
 0.177856f,-0.177856f, 0.212708f,-0.242004f, 0.834656f,
-0.031616f,-0.031616f,-0.045227f,-0.058533f,-0.696655f,
 0.031616f,-0.037842f, 0.037842f, 0.043030f,-0.043030f,
 0.051453f,-0.148499f, 0.148438f,-0.177551f, 0.202026f,
 0.143860f,-0.255554f, 0.437134f, 0.468933f, 0.205750f,
-0.020691f,-0.065308f,-0.191101f,-0.219910f,-0.042297f,
 0.036743f,-0.062866f, 0.111694f,-0.067444f, 0.119812f,
-0.205017f,-0.029602f, 0.052551f,-0.089966f,-0.096497f,
 0.186951f, 0.093933f, 0.122070f,-0.033081f, 0.584473f,
-0.034912f,-0.008789f,-0.014893f,-0.001038f,-0.341614f,
-0.017517f,-0.022827f,-0.011475f, 0.006165f, 0.003113f,
 0.004028f,-0.109253f,-0.054932f,-0.071350f, 0.019348f,
-0.083679f, 0.032654f, 0.086487f, 0.891357f,-0.060852f,
-0.006958f,-0.001038f,-0.007446f,-0.794495f,-0.003662f,
 0.002686f, 0.007202f,-0.002808f, 0.074585f,-0.029114f,
-0.077087f,-0.005066f, 0.001953f, 0.005249f, 0.054199f,
-0.046021f, 0.787598f, 0.273438f,-0.128967f, 0.089783f,
-0.002075f,-0.620300f,-0.074768f,-0.016602f,-0.008057f,
 0.036255f, 0.012573f,-0.215393f,-0.005920f, 0.101563f,
 0.035217f, 0.004089f,-0.070740f,-0.024536f, 0.011536f,
-0.319763f, 0.360168f, 0.494812f, 0.222778f, 0.295776f,
-0.102234f,-0.129700f,-0.244873f,-0.049622f,-0.087463f,
 0.115173f, 0.158203f,-0.178223f, 0.071228f,-0.080261f,
-0.110229f, 0.094604f,-0.106506f,-0.146362f,-0.065918f,
 0.148010f, 0.077332f, 0.209900f,-0.005554f,-0.071167f,
-0.021912f,-0.005981f,-0.044067f, 0.000000f,-0.005066f,
-0.011414f,-0.031067f,-0.016235f, 0.000793f, 0.000427f,
 0.001160f, 0.010498f, 0.005493f, 0.014893f,-0.000366f,
 0.391174f, 0.105103f, 0.107666f,-0.255798f, 0.367126f,
-0.153015f,-0.011047f,-0.011536f,-0.065430f,-0.134766f,
-0.041077f,-0.042114f,-0.011292f, 0.100037f, 0.026855f,
 0.027527f,-0.143616f,-0.038574f,-0.039490f, 0.093872f,
 0.076355f, 0.062012f, 0.184326f, 0.134888f, 0.088196f,
-0.005798f,-0.003845f,-0.033936f,-0.018188f,-0.007751f,
-0.004700f,-0.014038f,-0.011414f,-0.010254f,-0.008362f,
-0.024841f,-0.006714f,-0.005432f,-0.016235f,-0.011841f,
 0.267151f,-0.008057f,-0.157959f, 0.103821f, 0.296936f,
-0.071350f,-0.000061f,-0.024963f,-0.010742f,-0.088135f,
 0.002136f, 0.042175f,-0.001221f,-0.027710f, 0.000793f,
 0.016357f,-0.079285f, 0.002380f, 0.046875f,-0.030823f,
 0.266479f, 0.179688f, 0.440063f, 0.221375f, 0.070862f,
-0.070984f,-0.032288f,-0.193604f,-0.049011f,-0.005005f,
-0.047852f,-0.117249f,-0.079041f,-0.058960f,-0.039734f,
-0.097412f,-0.018860f,-0.012695f,-0.031189f,-0.015686f,
 0.183716f, 0.155273f, 0.425354f, 0.461365f, 0.121826f,
-0.033752f,-0.024109f,-0.180908f,-0.212830f,-0.014832f,
-0.028503f,-0.078125f,-0.066040f,-0.084717f,-0.071655f,
-0.196228f,-0.022339f,-0.018921f,-0.051819f,-0.056213f,
 0.164246f, 0.173096f, 0.189514f, 0.348572f, 0.294006f,
-0.026978f,-0.029968f,-0.035889f,-0.121521f,-0.086426f,
-0.028381f,-0.031128f,-0.032776f,-0.057251f,-0.060303f,
-0.066040f,-0.048279f,-0.050903f,-0.055725f,-0.102478f,
 0.186340f,-0.030884f, 0.146667f, 0.587463f, 0.080688f,
-0.034729f,-0.000916f,-0.021484f,-0.345154f,-0.006470f,
 0.005737f,-0.027344f, 0.004517f,-0.109497f, 0.018127f,
-0.086182f,-0.015015f, 0.002441f,-0.011841f,-0.047424f,
 0.321228f, 0.596313f, 0.211365f, 0.065247f,-0.242371f,
-0.103149f,-0.355591f,-0.044678f,-0.004211f,-0.058716f,
-0.191528f,-0.067871f,-0.126038f,-0.020935f,-0.038879f,
-0.013794f, 0.077820f, 0.144531f, 0.051208f, 0.015808f,
 0.144958f,-0.048645f,-0.164551f, 0.883972f, 0.328552f,
-0.020996f,-0.002319f,-0.027039f,-0.781433f,-0.107971f,
 0.007019f, 0.023865f,-0.007996f,-0.128174f, 0.043030f,
 0.145508f,-0.047607f, 0.015991f, 0.054077f,-0.290466f,
 0.339172f, 0.092102f, 0.330017f,-0.007629f,-0.450806f,
-0.114990f,-0.008484f,-0.108887f, 0.000000f,-0.203247f,
-0.031189f,-0.111938f,-0.030396f, 0.002563f, 0.000671f,
 0.002502f, 0.152893f, 0.041504f, 0.148804f,-0.003418f,
 0.200562f,-0.275208f, 0.690063f, 0.672913f,-0.160095f,
-0.040222f,-0.075745f,-0.476196f,-0.452820f,-0.025635f,
 0.055176f,-0.138367f, 0.189941f,-0.134949f, 0.185181f,
-0.464355f, 0.032104f,-0.044067f, 0.110474f, 0.107727f,
 0.058533f,-0.205688f, 0.586975f, 0.582581f,-0.107483f,
-0.003418f,-0.042297f,-0.344543f,-0.339417f,-0.011536f,
 0.012024f,-0.034363f, 0.120728f,-0.034058f, 0.119812f,
-0.341980f, 0.006287f,-0.022095f, 0.063110f, 0.062622f,
-0.177185f, 0.094727f, 0.907410f, 0.608521f,-0.030273f,
-0.031372f,-0.008972f,-0.823425f,-0.370361f,-0.000916f,
 0.016785f, 0.160767f,-0.085938f, 0.107788f,-0.057617f,
-0.552185f,-0.005310f, 0.002869f, 0.027466f, 0.018433f,
-0.103638f, 1.042236f, 0.152832f,-0.032898f,-0.039429f,
-0.010742f,-1.086304f,-0.023315f,-0.001038f,-0.001526f,
 0.108032f, 0.015808f,-0.159302f,-0.003357f, 0.034241f,
 0.005005f,-0.004089f, 0.041077f, 0.005981f,-0.001282f,
-0.114197f, 0.346985f, 0.689087f,-0.162476f, 0.082581f,
-0.013000f,-0.120361f,-0.474854f,-0.026367f,-0.006775f,
 0.039612f, 0.078674f,-0.239075f,-0.018555f, 0.056335f,
 0.111938f, 0.009399f,-0.028625f,-0.056885f, 0.013428f,
-0.176331f, 0.588806f, 0.627197f,-0.166504f, 0.060730f,
-0.031067f,-0.346680f,-0.393372f,-0.027710f,-0.003662f,
 0.103821f, 0.110596f,-0.369324f,-0.029358f, 0.098022f,
 0.104431f, 0.010681f,-0.035767f,-0.038086f, 0.010071f,
-0.302917f, 0.217773f, 0.280273f, 0.336182f, 0.210632f,
-0.091736f,-0.047424f,-0.078552f,-0.112976f,-0.044373f,
 0.065918f, 0.084900f,-0.061035f, 0.101807f,-0.073181f,
-0.094177f, 0.063782f,-0.045837f,-0.059021f,-0.070801f,
-0.317932f,-0.113953f, 0.531799f, 0.631775f, 0.094543f,
-0.101074f,-0.012939f,-0.282837f,-0.399170f,-0.008911f,
-0.036194f, 0.169067f, 0.060608f, 0.200867f, 0.072021f,
-0.335999f, 0.030029f, 0.010742f,-0.050293f,-0.059753f,
-0.155396f, 0.579956f, 0.364319f,-0.148926f, 0.117676f,
-0.024109f,-0.336365f,-0.132751f,-0.022156f,-0.013794f,
 0.090149f, 0.056580f,-0.211304f,-0.023132f, 0.086365f,
 0.054260f, 0.018250f,-0.068237f,-0.042847f, 0.017517f,
 0.252197f, 0.172607f, 0.000122f,-0.257080f,-0.251221f,
-0.063599f,-0.029785f, 0.000000f,-0.066101f,-0.063110f,
-0.043518f, 0.000000f, 0.000000f, 0.064819f, 0.044373f,
 0.000000f, 0.063354f, 0.043335f, 0.000000f,-0.064575f,
 0.052917f,-0.027832f,-0.044373f, 0.205627f, 0.721558f,
-0.002747f,-0.000732f,-0.001953f,-0.042236f,-0.520691f,
 0.001465f, 0.002319f,-0.001221f,-0.010864f, 0.005676f,
 0.009094f,-0.038147f, 0.020081f, 0.032043f,-0.148376f,
-0.164734f, 0.112366f, 0.248535f, 0.149109f, 0.096558f,
-0.027100f,-0.012634f,-0.061768f,-0.022217f,-0.009277f,
 0.018494f, 0.040894f,-0.027893f, 0.024536f,-0.016724f,
-0.037048f, 0.015869f,-0.010803f,-0.023987f,-0.014404f,
-0.184143f, 0.235107f, 0.105286f, 0.515137f, 0.320862f,
-0.033875f,-0.055237f,-0.011047f,-0.265381f,-0.102905f,
 0.043274f, 0.019348f,-0.024719f, 0.094849f,-0.121094f,
-0.054260f, 0.059082f,-0.075439f,-0.033752f,-0.165283f,
 0.253357f, 0.038086f, 0.049744f, 0.273743f, 0.136047f,
-0.064209f,-0.001404f,-0.002441f,-0.074951f,-0.018494f,
-0.009644f,-0.012573f,-0.001892f,-0.069336f,-0.010376f,
-0.013611f,-0.034485f,-0.005127f,-0.006775f,-0.037231f,
 0.169495f,-0.071594f, 0.243164f, 0.798279f, 0.153076f,
-0.028687f,-0.005127f,-0.059143f,-0.637207f,-0.023438f,
 0.012085f,-0.041199f, 0.017395f,-0.135315f, 0.057129f,
-0.194092f,-0.025940f, 0.010925f,-0.037231f,-0.122192f,
 0.491455f, 0.139465f,-0.377991f, 0.313599f, 0.366394f,
-0.241516f,-0.019409f,-0.142883f,-0.098328f,-0.134216f,
-0.068542f, 0.185791f, 0.052734f,-0.154114f,-0.043701f,
 0.118530f,-0.180054f,-0.051086f, 0.138489f,-0.114868f,
 0.063538f,-0.044861f,-0.008667f, 0.806213f, 0.092468f,
-0.004028f,-0.002014f,-0.000061f,-0.649963f,-0.008545f,
 0.002808f, 0.000549f,-0.000366f,-0.051208f, 0.036194f,
 0.006958f,-0.005859f, 0.004150f, 0.000793f,-0.074585f,
-0.264404f,-0.268494f,-0.101135f, 0.297852f, 0.450134f,
-0.069885f,-0.072083f,-0.010193f,-0.088684f,-0.202576f,
-0.070984f,-0.026733f,-0.027100f, 0.078735f, 0.079956f,
 0.030090f, 0.119019f, 0.120850f, 0.045471f,-0.134033f,
-0.203125f, 0.233582f, 0.361389f, 0.608887f,-0.063782f,
-0.041260f,-0.054565f,-0.130615f,-0.370789f,-0.004028f,
 0.047424f, 0.073425f,-0.084412f, 0.123718f,-0.142212f,
-0.220032f,-0.012939f, 0.014893f, 0.023010f, 0.038818f,
 0.478699f,-0.076294f, 0.012817f, 0.433716f,-0.317566f,
-0.229126f,-0.005798f,-0.000122f,-0.188110f,-0.100830f,
 0.036499f,-0.006104f, 0.000977f,-0.207642f, 0.033081f,
-0.005554f, 0.152039f,-0.024231f, 0.004028f, 0.137756f,
 0.142700f,-0.062927f,-0.015137f, 0.239746f, 0.395752f,
-0.020325f,-0.003906f,-0.000183f,-0.057495f,-0.156616f,
 0.008972f, 0.002136f,-0.000916f,-0.034180f, 0.015076f,
 0.003601f,-0.056458f, 0.024902f, 0.005981f,-0.094910f,
 0.149109f,-0.056702f,-0.067932f, 0.590637f, 0.252563f,
-0.022217f,-0.003174f,-0.004578f,-0.348877f,-0.063782f,
 0.008423f, 0.010132f,-0.003845f,-0.088074f, 0.033508f,
 0.040100f,-0.037659f, 0.014282f, 0.017151f,-0.149170f,
 0.259705f, 0.090088f, 0.308533f, 0.146057f, 0.177734f,
-0.067444f,-0.008057f,-0.095154f,-0.021301f,-0.031555f,
-0.023376f,-0.080139f,-0.027771f,-0.037903f,-0.013123f,
-0.045044f,-0.046143f,-0.015991f,-0.054810f,-0.025940f,
 0.064209f, 0.274353f, 0.947205f, 0.089539f,-0.246094f,
-0.004089f,-0.075256f,-0.897217f,-0.007996f,-0.060547f,
-0.017578f,-0.060852f,-0.259827f,-0.005737f,-0.024536f,
-0.084778f, 0.015808f, 0.067505f, 0.233093f, 0.022034f,
 0.289246f, 0.158691f,-0.113770f, 0.052246f,-0.094849f,
-0.083679f,-0.025146f,-0.012939f,-0.002686f,-0.008972f,
-0.045898f, 0.032898f, 0.018005f,-0.015076f,-0.008240f,
 0.005920f, 0.027405f, 0.015015f,-0.010742f, 0.004944f,
};

#if COMPILE_MMX

short AcbkGainTable170subsetInt[85 *20] =
  {-83,	  -187,	  -509,	  -266,	    13,	     7,	    19,	   172,	    90,	   244,	
    -6,	 -1251,	   975,	   173,	  4039,	  2005,	   -95,	   -58,	    -1,	  -996,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
   -21,	     0,	     0,	   132,	    87,	     0,	    21,	    13,	     0,	   -84,	
  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	   -69,	    -6,	   -23,	
   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	
   -66,	   -40,	   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	
   -83,	   132,	  -702,	    32,	   -52,	   275,	   191,	  1521,	  -767,	  -124,	
  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	
  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	  -187,	
  -509,	  -266,	    13,	     7,	    19,	   172,	    90,	   244,	    -6,	 -1251,	
   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	   -40,	   -12,	   486,	
  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	
    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	
   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	
   776,	   212,	   715,	   670,	   809,	   -36,	    -2,	   -31,	   -27,	   -39,	
   -10,	   -33,	    -9,	   -31,	    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	
  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	    71,	
    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	  -270,	  2425,	
   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	   -33,	    -9,	   -31,	    -8,	
   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	  -168,	  -320,	  -815,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	   670,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	
   212,	   715,	   670,	   809,	   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	
  -487,	   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	
   275,	   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	
    89,	  -102,	    11,	   -12,	   -46,	   -21,	    24,	    90,	    11,	  -735,	
  -487,	    -5,	  2948,	   468,	   -33,	   -14,	     0,	  -530,	   -13,	   -21,	
  2948,	   468,	   -33,	   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	
   132,	    87,	     0,	    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	
    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	
  -722,	     0,	   -83,	  -187,	  -509,	  -266,	    13,	     7,	    19,	   172,	
     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	
    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	
  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	    71,	    11,	
    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	  -270,	  2425,	  1267,	
    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	     0,	
  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	    21,	    13,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	   670,	   809,	
    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	
     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	    21,	
   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	
   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	
    11,	   -12,	   -46,	   -21,	    24,	    90,	    11,	  -735,	  -487,	    -5,	
  2948,	   468,	   -33,	   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	
    32,	   -52,	   275,	   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	
   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	
   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	  -168,	  -320,	  -815,	
  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	    25,	    25,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	
   715,	   670,	   809,	   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	   -33,	
    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	
   -40,	   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	
   202,	    32,	   -95,	    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	
 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	  -187,	  -509,	  -266,	    13,	
  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	    25,	
    25,	    -3,	    64,	    65,	    -8,	   -15,	  -589,	   680,	  2478,	   308,	
  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	  -187,	  -509,	
  -266,	    13,	     7,	    19,	   172,	    90,	   244,	    -6,	 -1251,	   975,	
   -31,	    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	  -168,	
  -320,	  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	
   -39,	   -66,	   -40,	   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	
   -36,	 -1013,	  -487,	   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	
    87,	     0,	    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	
   626,	   -66,	  -182,	   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	
  1316,	  -168,	  -320,	  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	
    13,	    13,	    25,	    25,	    -3,	    64,	    65,	    -8,	   -15,	  -589,	
  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	   -40,	   -12,	
   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	
  -722,	     0,	   -83,	  -187,	  -509,	  -266,	    13,	     7,	    19,	   172,	
    90,	   244,	    -6,	 -1251,	   975,	   173,	  4039,	  2005,	   -95,	   -58,	
   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	  -187,	  -509,	  -266,	
    13,	     7,	    19,	   172,	    90,	   244,	    -6,	 -1251,	   975,	   173,	
    -8,	   -15,	  -589,	   680,	  2478,	   308,	  -596,	   -21,	   -28,	  -375,	
    -5,	   -21,	    24,	    89,	  -102,	    11,	   -12,	   -46,	   -21,	    24,	
   -35,	   -33,	  1296,	  1316,	  -168,	  -320,	  -815,	  -102,	  -105,	    -1,	
    -6,	   -40,	  -104,	    13,	    13,	    25,	    25,	    -3,	    64,	    65,	
  -359,	   -98,	  -722,	     0,	   -83,	  -187,	  -509,	  -266,	    13,	     7,	
    19,	   172,	    90,	   244,	    -6,	 -1251,	   975,	   173,	  4039,	  2005,	
   132,	    87,	     0,	    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	
   333,	   626,	   -66,	  -182,	   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	
  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	     0,	  -530,	   -13,	
   -21,	     0,	     0,	   132,	    87,	     0,	    21,	    13,	     0,	   -84,	
  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	    21,	    13,	
     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	   -69,	
   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	
    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	
   -35,	   -21,	   -39,	   -66,	   -40,	   -12,	   486,	  -769,	  4074,	  2825,	
 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	  -120,	   191,	   -83,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	   776,	   212,	   715,	   670,	   809,	   -36,	    -2,	   -31,	
  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	   -69,	    -6,	   -23,	
  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	   -40,	   -12,	
     0,	     0,	     0,	   776,	   212,	   715,	   670,	   809,	   -36,	    -2,	
   -31,	   -27,	   -39,	   -10,	   -33,	    -9,	   -31,	    -8,	   -29,	   -38,	
    -9,	   -31,	    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	
  -168,	  -320,	  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	
    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	   191,	
  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	
   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	
  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	
   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	
   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	
   -33,	   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	
     0,	    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	
 -1013,	  -487,	   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	
   -52,	   275,	   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	
  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	  -120,	
   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	   191,	  1521,	  -767,	
   -21,	    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	
   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	
   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	
   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	
     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	   -69,	
    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	
     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	
     0,	   -83,	  -187,	  -509,	  -266,	    13,	     7,	    19,	   172,	    90,	
  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	
  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	   191,	  1521,	
  2478,	   308,	  -596,	   -21,	   -28,	  -375,	    -5,	   -21,	    24,	    89,	
  -102,	    11,	   -12,	   -46,	   -21,	    24,	    90,	    11,	  -735,	  -487,	
   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	   -40,	
   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	
   -21,	   -28,	  -375,	    -5,	   -21,	    24,	    89,	  -102,	    11,	   -12,	
   -46,	   -21,	    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	
    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	  -270,	
  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	
  -596,	   -21,	   -28,	  -375,	    -5,	   -21,	    24,	    89,	  -102,	    11,	
   -12,	   -46,	   -21,	    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	
  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	    25,	    25,	    -3,	
    64,	    65,	    -8,	   -15,	  -589,	   680,	  2478,	   308,	  -596,	   -21,	
  -375,	    -5,	   -21,	    24,	    89,	  -102,	    11,	   -12,	   -46,	   -21,	
    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	
     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	   670,	   809,	
   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	   -33,	    -9,	   -31,	    -8,	
    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	
  -182,	   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	
    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	  -168,	  -320,	
  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	    25,	
   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	
   -95,	    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	
  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	
   202,	    32,	   -95,	    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	
   -21,	    24,	    89,	  -102,	    11,	   -12,	   -46,	   -21,	    24,	    90,	
    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	     0,	  -530,	
 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	  -120,	   191,	   -83,	
   132,	  -702,	    32,	   -52,	   275,	   191,	  1521,	  -767,	  -124,	  4320,	
   -66,	  -182,	   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	
   -21,	   -39,	   -66,	   -40,	   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	
  -702,	    32,	   -52,	   275,	   191,	  1521,	  -767,	  -124,	  4320,	  1026,	
  -141,	   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	
   -10,	   -33,	    -9,	   -31,	    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	
  1296,	  1316,	  -168,	  -320,	  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	
    25,	    25,	    -3,	    64,	    65,	    -8,	   -15,	  -589,	   680,	  2478,	
   308,	  -596,	   -21,	   -28,	  -375,	    -5,	   -21,	    24,	    89,	  -102,	
     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	    21,	
    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	
 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	
     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	
   670,	   809,	   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	   -33,	    -9
   };	

#endif

/*
**  AcbkGainTablePtr:
**
**  Purpose:
**      Contains pointers to 85 and 170 element codebooks
**
*/
  float *AcbkGainTablePtr[3] = {
   AcbkGainTable085,
   AcbkGainTable170,
   AcbkGainTable170subset,
   };

#if COMPILE_MMX

short *AcbkGainTablePtrInt[3] = {
   AcbkGainTable085Int,
   AcbkGainTable170Int,
   AcbkGainTable170subsetInt,
   };

#endif

/*
**  LpfConstTable:
**
**  Purpose:
**      Sets the postfilter gain weighting factor.
**
**  Table Structure:
**      (0.1875 , 0.25) in Q15 ( i.e. scale by 32768 ).

*/

//Code removed

/*
**  epsi170:
**
**  Purpose:
**      At the lower bitrate, the pitch contribution is added
**      into the output vector of ACELP when the pitch period is
**      less than 60 samples (one subframe). The pitch contribution
**      is estimated by a 1 tap long term predictor (LTP) instead of
**      the 5 tap LTP used in pitch prediction. The values in epsi170
**      effectively choose one of the 5 vectors used in the 5 tap LTP.
**
**  Table Structure:
**      The table is indexed by the index into the AcbkGainTable170
**      table (determined in Find_Acbk). The value, 60, is used only
**      as a place holder. They correspond to zeros in the gain170
**      table, which is the coefficient of the 1 tap long term
**      preditor (LTP).  The rest of the values range from -2 to +2.
**      These values pick one vector among the 5 vectors centered one
**      pitch period behind the current vector. (In contrast, the 5
**      tap LTP uses all five vectors centered one pitch period back.)
*/

int epsi170[170] = {
    60,      0,     60,      0,      1,      0,      0,      1, 
    -1,      1,      0,     -1,      2,     -2,      0,      1, 
     0,      0,     -1,      0,      0,      0,      1,      0, 
    -1,     -1,      1,     -1,      1,     -2,      1,     -1,
    60,      0,      0,      1,      1,      0,      1,      1, 
    -1,      1,     -1,     -1,     -1,      0,     60,     -2, 
     0,      1,      0,     -1,      1,      1,      0,      1, 
     2,     -1,      0,      1,      0,      0,      0,     60, 
    -1,      1,      1,      2,     -1,      1,     -1,     60,
    -1,      0,      1,      0,     -1,      0,      0,      0, 
     1,     -1,      0,      1,     -1,      0,     -1,      0, 
     1,     60,      0,      0,      1,      1,      0,      2, 
     1,      0,      1,     -2,      0,     -1,      1,      0, 
    -1,      1,      0,      0,      1,      0,      0,      0, 
    60,      1,      1,     -1,     -1,      2,     -2,      0,
    -1,     -1,     60,      2,     60,      0,      0,     60, 
     0,      0,      0,     -2,     60,     -1,      0,     60,
     0,      2,      0,      0,     -1,      0,      1,      2,
    60,      1,      1,      1,      0,      0,     60,      0,
    60,      0,      0,     60,     60,     -1,      0,      0,
    60,     60,      1,      0,     60,      2,     60,     -2,
    -2,      0 };

/*
**  gain170:
**
**  Purpose:
**      At the lower bitrate, the pitch contribution is added into
**      the output vector of ACELP when the pitch period is less than
**      60 samples (one subframe). The pitch contribution
**      is estimated by a 1 tap long term predictor (LTP) instead of
**      the 5 tap LTP used in pitch prediction. This table holds the
**      coefficient for the one tap filter.
**      
**  Table Structure:
**      The table is indexed by the index into the AcbkGainTable170
**      table (determined in Find_Acbk). The values are in Q12.
*/

 FLOAT gain170[170] = {
(F)0.000000, 
(F)0.075958, 
(F)0.000000, 
(F)0.159210, 
(F)0.188324, 
(F)0.120636, 
(F)0.316284, 
(F)0.285553, 
(F)0.269867, 
(F)0.286743, 
(F)0.176819, 
(F)0.330078, 
(F)0.354187, 
(F)0.368408, 
(F)0.262939, 
(F)0.371399, 
(F)0.440674, 
(F)0.237640, 
(F)0.418732, 
(F)0.555573, 
(F)0.441620, 
(F)0.482391, 
(F)0.466156, 
(F)0.411377, 
(F)0.560760, 
(F)0.000000, 
(F)0.341614, 
(F)0.397034, 
(F)0.574829, 
(F)0.621155, 
(F)0.495392, 
(F)0.000000, 
(F)0.000000, 
(F)0.370178, 
(F)0.408478, 
(F)0.544250, 
(F)0.637054, 
(F)0.671265, 
(F)0.000000, 
(F)0.557770, 
(F)0.650665, 
(F)0.419250, 
(F)0.582703, 
(F)0.622162, 
(F)0.000000, 
(F)0.641113, 
(F)0.000000, 
(F)0.696014, 
(F)0.485229, 
(F)0.000000, 
(F)0.548981, 
(F)0.679291, 
(F)0.744476, 
(F)0.706116, 
(F)0.730835, 
(F)0.701813, 
(F)0.689819, 
(F)0.791687, 
(F)0.800964, 
(F)0.772736, 
(F)0.806366, 
(F)0.734283, 
(F)0.831512, 
(F)0.000000, 
(F)0.780396, 
(F)0.729919, 
(F)0.791321, 
(F)0.805908, 
(F)0.581329, 
(F)0.834869, 
(F)0.748840, 
(F)0.000000, 
(F)0.765778, 
(F)0.871246, 
(F)0.000000, 
(F)0.695587, 
(F)0.783051, 
(F)0.896515, 
(F)0.923950, 
(F)0.799500, 
(F)0.687286, 
(F)0.882538, 
(F)0.835693, 
(F)0.920471, 
(F)0.000000, 
(F)0.739655, 
(F)0.917419, 
(F)0.664154, 
(F)0.943512, 
(F)0.000000, 
(F)0.954712, 
(F)0.898224, 
(F)0.818512, 
(F)0.874481, 
(F)0.956024, 
(F)0.939911, 
(F)0.957916, 
(F)0.986389, 
(F)0.969238, 
(F)0.971375, 
(F)0.822021, 
(F)0.951538, 
(F)0.942230, 
(F)0.850616, 
(F)0.928619, 
(F)0.947571, 
(F)0.000000, 
(F)0.973877, 
(F)0.964691, 
(F)0.963287, 
(F)0.779938, 
(F)0.956940, 
(F)0.000000, 
(F)0.901367, 
(F)0.884552, 
(F)0.823486, 
(F)0.963959, 
(F)0.941040, 
(F)0.950104, 
(F)0.922943, 
(F)0.938171, 
(F)0.979309, 
(F)0.000000, 
(F)0.943054, 
(F)0.000000, 
(F)0.916351, 
(F)0.886292, 
(F)0.000000, 
(F)0.969116, 
(F)0.749298, 
(F)0.782349, 
(F)0.930817, 
(F)0.000000, 
(F)0.903839, 
(F)0.935333, 
(F)0.000000, 
(F)0.893372, 
(F)0.928192, 
(F)0.838623, 
(F)0.952545, 
(F)0.858978, 
(F)0.933838, 
(F)0.965942, 
(F)0.887085, 
(F)0.000000, 
(F)0.871918, 
(F)0.876770, 
(F)0.958923, 
(F)0.862335, 
(F)0.756744, 
(F)0.000000, 
(F)0.000000, 
(F)0.000000, 
(F)0.674591, 
(F)0.849976, 
(F)0.000000, 
(F)0.000000, 
(F)0.738953, 
(F)0.752014, 
(F)0.711212, 
(F)0.000000, 
(F)0.000000, 
(F)0.698334, 
(F)0.659210, 
(F)0.000000, 
(F)0.782776, 
(F)0.000000, 
(F)0.953766, 
(F)0.767334, 
(F)0.549255 };


/*
**  tabgain170:
**
**  Purpose:
**      In the taming procedure at the encoder the 170 5-taps LT filters
**      are modelled as 1-tap filter. This table gives the gain
**      value attributed to each filter as a worst case gain
**
**  Table Structure:
**      The table is indexed by the index into the AcbkGainTable170
**      table (determined in Find_Acbk). The values are in Q13.
*/

FLOAT tabgain170[170] = {
(F)0.125000,
(F)0.194214,
(F)0.204834,
(F)0.230835,
(F)0.258789,
(F)0.292847,
(F)0.362061,
(F)0.372192,
(F)0.388794,
(F)0.404907,
(F)0.419067,
(F)0.430054,
(F)0.455200,
(F)0.461304,
(F)0.462524,
(F)0.520264,
(F)0.543213,
(F)0.545532,
(F)0.575317,
(F)0.603516,
(F)0.604248,
(F)0.607910,
(F)0.611572,
(F)0.614258,
(F)0.646851,
(F)0.657837,
(F)0.657837,
(F)0.657837,
(F)0.689209,
(F)0.695923,
(F)0.699829,
(F)0.703735,
(F)0.732056,
(F)0.732056,
(F)0.750732,
(F)0.758179,
(F)0.773438,
(F)0.776367,
(F)0.783081,
(F)0.783081,
(F)0.784912,
(F)0.786133,
(F)0.788696,
(F)0.788696,
(F)0.794922,
(F)0.805786,
(F)0.828491,
(F)0.838867,
(F)0.846069,
(F)0.851074,
(F)0.852539,
(F)0.861328,
(F)0.861328,
(F)0.867310,
(F)0.868774,
(F)0.869507,
(F)0.871094,
(F)0.874146,
(F)0.874878,
(F)0.876465,
(F)0.876465,
(F)0.886475,
(F)0.892090,
(F)0.895264,
(F)0.895264,
(F)0.901733,
(F)0.904175,
(F)0.907471,
(F)0.908325,
(F)0.908325,
(F)0.913208,
(F)0.919922,
(F)0.923340,
(F)0.926758,
(F)0.938110,
(F)0.941650,
(F)0.947021,
(F)0.948730,
(F)0.951416,
(F)0.952393,
(F)0.954224,
(F)0.956909,
(F)0.960571,
(F)0.962524,
(F)0.965210,
(F)0.969971,
(F)0.975586,
(F)0.981323,
(F)0.984253,
(F)0.987183,
(F)0.987183,
(F)0.996948,
(F)0.999023,
(F)1.000977,
(F)1.000977,
(F)1.005981,
(F)1.009033,
(F)1.011108,
(F)1.014160,
(F)1.014160,
(F)1.017334,
(F)1.022461,
(F)1.025635,
(F)1.033081,
(F)1.039551,
(F)1.040527,
(F)1.041626,
(F)1.054810,
(F)1.058228,
(F)1.061523,
(F)1.068359,
(F)1.069458,
(F)1.074097,
(F)1.077637,
(F)1.091675,
(F)1.112305,
(F)1.113525,
(F)1.114868,
(F)1.117310,
(F)1.133789,
(F)1.135132,
(F)1.144165,
(F)1.145508,
(F)1.145508,
(F)1.148071,
(F)1.149414,
(F)1.156128,
(F)1.160034,
(F)1.166870,
(F)1.169556,
(F)1.179199,
(F)1.179199,
(F)1.186279,
(F)1.196167,
(F)1.199097,
(F)1.201904,
(F)1.201904,
(F)1.212158,
(F)1.225464,
(F)1.240723,
(F)1.248413,
(F)1.256226,
(F)1.273926,
(F)1.282104,
(F)1.283691,
(F)1.285400,
(F)1.293701,
(F)1.295288,
(F)1.296997,
(F)1.347656,
(F)1.351318,
(F)1.354980,
(F)1.356812,
(F)1.381226,
(F)1.383179,
(F)1.440918,
(F)1.477051,
(F)1.496948,
(F)1.496948,
(F)1.501465,
(F)1.505981,
(F)1.517456,
(F)1.562500,
(F)1.582275,
(F)1.594849,
(F)1.647461,
(F)1.686401,
(F)1.721191,
(F)1.733154,
(F)2.247192 };

/*
**  tabgain85:
**
**  Purpose:
**      In the taming procedure at the encoder the 85 5-taps LT filters
**      are modelled as 1-tap filter. This table gives the gain
**      value attributed to each filter as a worst case gain
**
**  Table Structure:
**      The table is indexed by the index into the AcbkGainTable085
**      table (determined in Find_Acbk). The values are in Q13.
*/


FLOAT tabgain85[85] = {
(F)0.125000,
(F)0.159668,
(F)0.232666,
(F)0.279663,
(F)0.306519,
(F)0.333984,
(F)0.402588,
(F)0.425903,
(F)0.431030,
(F)0.469238,
(F)0.532227,
(F)0.554321,
(F)0.571777,
(F)0.587524,
(F)0.618774,
(F)0.674805,
(F)0.680786,
(F)0.697388,
(F)0.723022,
(F)0.727295,
(F)0.727295,
(F)0.740234,
(F)0.748535,
(F)0.772827,
(F)0.777588,
(F)0.796753,
(F)0.797485,
(F)0.802612,
(F)0.809692,
(F)0.814331,
(F)0.833984,
(F)0.833984,
(F)0.851074,
(F)0.854004,
(F)0.878784,
(F)0.879517,
(F)0.905029,
(F)0.919067,
(F)0.920776,
(F)0.920776,
(F)0.938965,
(F)0.947021,
(F)0.956909,
(F)0.956909,
(F)0.960571,
(F)0.975586,
(F)0.976563,
(F)0.978516,
(F)0.983276,
(F)0.986206,
(F)0.991089,
(F)1.001953,
(F)1.007080,
(F)1.009033,
(F)1.012085,
(F)1.013184,
(F)1.016235,
(F)1.025635,
(F)1.030884,
(F)1.050415,
(F)1.052612,
(F)1.060425,
(F)1.068359,
(F)1.078735,
(F)1.079956,
(F)1.095337,
(F)1.098877,
(F)1.100098,
(F)1.121094,
(F)1.171021,
(F)1.180664,
(F)1.190430,
(F)1.201904,
(F)1.218018,
(F)1.237671,
(F)1.245361,
(F)1.259399,
(F)1.278809,
(F)1.293701,
(F)1.293701,
(F)1.305542,
(F)1.394653,
(F)1.424561,
(F)1.785767,
(F)1.862183 } ;

#if COMPILE_MMX

short LspTableInt[LspCbSize*12+4] = {
     0,  -540, -1082, -1446,
     0, -2744, -3300, -4022,
     0, -2064, -2764, -4426,
     0,     0,     0,     0,
 -1882, -1560, -1768, -2102,
 -2244, -2290, -2618, -3046,
 -3884, -4908, -2746, -3532,
     0,     0,     0,     0,
 -2166, -1554, -1870, -1604,
 -3244, -2754, -2934, -2654,
 -4600, -4294, -5526, -6942,
     0,     0,     0,     0,
 -1870,  -480, -1322, -1988,
 -3918,  -178,  -514,  -932,
 -7998,   444,  -320,  -838,
     0,     0,     0,     0,
  -376,  -684, -1214,    32,
  -328, -1024, -1022,    38,
  -556,  -830, -1594, -1432,
     0,     0,     0,     0,
   748,  -692,  -530, -1240,
   850,   490,  1012,  -294,
 -1944,  -564, -1508,  3910,
     0,     0,     0,     0,
 -1484,  -300,   610,   246,
 -1720,  -704,  1760,  1462,
  5194,  5408,  3908,  5532,
     0,     0,     0,     0,
  -696,  1236,  -356,   786,
  1530,   442,   -94,  2608,
  6654,  6516,  8438,  7684,
     0,     0,     0,     0,
  1396,   126,  -430,   344,
  3404, -1168, -1464,  -670,
  9602,  2458,  3408,  3818,
     0,     0,     0,     0,
    -4,   706, -2416, -1026,
   432,   254,   376,  -150,
  3594,  4410,    22, -1366,
     0,     0,     0,     0,
 -1946, -1232, -1900, -2862,
   444, -1686, -2226, -1246,
 -1292,  -776,  -718, -1410,
     0,     0,     0,     0,
 -2796,   -90,   -18,   254,
 -2126,  -922, -1314, -2156,
  -356,    70,  -432,   190,
     0,     0,     0,     0,
 -1900, -2960,  -240,  -736,
 -2312, -2988, -1410, -1922,
  1168,   898,  1032,  1454,
     0,     0,     0,     0,
  -756, -1586, -1602, -2952,
 -1052, -1228, -1510,  -680,
  1946,  1352,  2574,  3272,
     0,     0,     0,     0,
 -1010, -2486, -1552, -2302,
 -2508, -3244, -2954, -2592,
  3086,  3064, -1310, -1646,
     0,     0,     0,     0,
 -2306, -2582, -1244,  -942,
 -3344, -4006, -2566, -3222,
 -2248, -3404,   114,  1018,
     0,     0,     0,     0,
 -2120, -1746, -3432, -4300,
 -3140, -4312, -4042, -6436,
  -278, -1072,  -728, -2582,
     0,     0,     0,     0,
 -2496, -2430,   334,   698,
 -3890, -5266,  -488,  -824,
 -5808, -5710,   168,  -434,
     0,     0,     0,     0,
   -80,   454,   136,   334,
  -704, -1058,  -766, -1116,
  1264,   810,  -886, -1412,
     0,     0,     0,     0,
  -550,  -702,   682,  1206,
 -1708, -2178,  -144,  -212,
   -28,  -898,  -578,  -948,
     0,     0,     0,     0,
   644,   358,   900,  1110,
  -438,  -634,  -582,   390,
 -1298, -1996, -1992, -1050,
     0,     0,     0,     0,
  1568,  -296,   164,   476,
   544,  -768, -1072,  -344,
 -1662, -1698, -2714, -2708,
     0,     0,     0,     0,
   844,   594,  -222,     2,
  -536, -1474, -1602, -1336,
 -3682, -4158, -1196, -1968,
     0,     0,     0,     0,
  -262,  -658,  -302,  -186,
 -1636, -1042, -1556,  -704,
 -2598, -2620, -3668, -3492,
     0,     0,     0,     0,
 -1136, -1018,   928,   158,
 -1280, -1882, -1630, -2266,
 -3642, -4366, -2500, -3194,
     0,     0,     0,     0,
  -368,  -392,  -384,  -518,
 -2706,  -820, -1666, -2764,
 -4246, -4854, -5620, -6090,
     0,     0,     0,     0,
  -434, -1600,  -726, -1322,
     8,  -650, -1660, -2268,
 -2332, -2438, -1796, -1920,
     0,     0,     0,     0,
  -772, -1254, -1806, -1370,
 -1960, -2318, -1658, -1658,
 -3002, -3444, -1710, -2626,
     0,     0,     0,     0,
 -2130,   882,  1310,  2318,
 -1918,    50,   -54,  -220,
 -2810, -1694, -2362, -1410,
     0,     0,     0,     0,
  1712,   830,   644,  1340,
   506,   808,  1806,   998,
 -3342,    -2,  -796,  -584,
     0,     0,     0,     0,
  1606,  2288,  1434,  1714,
  1182,  1182,   366,   762,
 -1220, -1628,   786,   212,
     0,     0,     0,     0,
  1218,  1584,  1470,  2284,
   124,   396,  1610,  1624,
   -54,  -650,   176,   156,
     0,     0,     0,     0,
  2056,  2618,  3230,  2020,
   732,  1486,  1178,  1278,
  -584,  -474,  -158,  -486,
     0,     0,     0,     0,
  1998,  3000,  1976,  2454,
  1928,  2274,   714,  1334,
  -622, -1230,  1292,  1366,
     0,     0,     0,     0,
  2328,  2784,  2276,  2874,
  3130,  4030,  1066,  1792,
  1788,   954,   500,   782,
     0,     0,     0,     0,
  3530,  2224,  3192,  1874,
  2236,  2180,  1692,  2322,
   198,  1604,  2268,   558,
     0,     0,     0,     0,
  3438,  2676,  2838,  2856,
  2508,  2172,  2648,  3048,
  1366,    70,   856,    80,
     0,     0,     0,     0,
  4216,  2030,  2242,  2060,
  3188,  1088,  1850,  2636,
   178,  2444,  2526,  2970,
     0,     0,     0,     0,
  2590,  2646,  3448,  3594,
  1578,  2544,  2474,  3378,
  3634,  3818,  3606,  1716,
     0,     0,     0,     0,
  4298,  4604,  5726,   104,
  2734,  3734,  4702,   326,
  2602,  1522,  2106,  -152,
     0,     0,     0,     0,
   460,  -142,  -436, -1308,
   618,  1238,  1712,  1472,
  -984,    78,   998,  -414,
     0,     0,     0,     0,
 -1070,  -960,   524,   618,
  2518,  2952,  2162,  3184,
   310,  1286,   204,  -364,
     0,     0,     0,     0,
  1254,   674,  1516,   404,
  3258,  1286,  1340,  2252,
  1068,   912,  1426,  1316,
     0,     0,     0,     0,
  1224,  1372,  -262,    84,
  2262,  2446,   754,  1416,
  1332,  2272,  1050,  1814,
     0,     0,     0,     0,
   174,   864,   274,  -894,
  2976,  4234,  1962,  2028,
  2070,  1808,  2664,  2272,
     0,     0,     0,     0,
 -1678, -1118, -1700, -2546,
  3586,   594,  1370,  1264,
  2492,   396,   892,  1652,
     0,     0,     0,     0,
  -802, -1506,  -872,  -230,
 -1088, -1586,   -18,  -486,
   346,   288,  1544,  2620,
     0,     0,     0,     0,
 -1340, -2054, -1774, -2554,
  -538,   -26,  -162,  -910,
   748,  1278,  2274,   316,
     0,     0,     0,     0,
 -2822,   344,   772, -1000,
 -1440,   176,   510,  1044,
  1472,   806,  1512,  1820,
     0,     0,     0,     0,
 -1916,  -790,  -712, -1226,
  1318,   602,  1536,  1682,
  2776,  2688,  3626,  4838,
     0,     0,     0,     0,
   890,  1258,   566,   912,
  -244,  -174,  -506,  -232,
   504,  1446,  1740,  2762,
     0,     0,     0,     0,
  1514,  1064,  1894,  2650,
   360,   816,   576,  1988,
  2118,  3018,  3612,  5048,
     0,     0,     0,     0,
  1784,  2794,  2286,  3700,
  2438,  3192,  3104,  2866,
  6046,  6812,  5092,  5420,
     0,     0,     0,     0,
   -20,   308,  1016,  1018,
   268,   998,  1584,  2680,
  2004,  2646,  2234,  3232,
     0,     0,     0,     0,
  1524,  1574,  1588,   930,
  1724,  1480,  3454,  4216,
  3216,  4640,  2566,  3320,
     0,     0,     0,     0,
  -240,  -772,  1782,   912,
  2902,  4032,  2450,  2960,
  3226,  4338,  4100,  4370,
     0,     0,     0,     0,
  2986,  2794,  3552,  3144,
  2566,  3272,  3476,  3396,
  2418,  3036,  3104,  4282,
     0,     0,     0,     0,
  2778,  3918,  2730,  4412,
  4252,  4826,  5784,  3942,
  2542,  2238,  3010,  3246,
     0,     0,     0,     0,
  4152,  3434,  4732,  5730,
  3900,  4582,  5030,  5676,
  4560,  3734,  3906,  5044,
     0,     0,     0,     0,
  5070,  6762,  1672,  3522,
  6930,  8254,  5334,  5546,
  4022,  5276,  4578,  4674,
     0,     0,     0,     0,
  2830,  4708,  5318,  2096,
  6650,  6276,  8384,  3572,
  5822,  6252,  8020,  3636,
     0,     0,     0,     0,
  2484,  3024,  3146,  4460,
  4222,  4158,  4982,  4754,
  4480,  5560,  6276,  5564,
     0,     0,     0,     0,
   832,  1450,  2504,  4188,
  3546,  4672,  4746,  4536,
  5408,  6594,  7956,  7136,
     0,     0,     0,     0,
  4022,  2682,  2432,  3386,
  5424,  7014,  7838,  9586,
  9056,  7752,  9844, 12024,
     0,     0,     0,     0,
     0, -4228, -5304, -5694,
     0, -2604, -2556, -1656,
     0,   152, -2736,  -698,
     0,     0,     0,     0,
 -7624, -7892, -5450, -6990,
 -4380,  -728, -8984, -9528,
  -698,  -898, -7214, -3488,
     0,     0,     0,     0,
  -102,  -306,   216, -1670,
 -1512, -2382, -2836, -1792,
   168,  1008,  2334,   780,
     0,     0,     0,     0,
 -1138, -2302, -3652, -3684,
 -3404, -3636, -5094, -3636,
   174,  1866,   822,  2902,
     0,     0,     0,     0,
 -4876, -5494, -1880, -3258,
 -3222, -4954,  2504,  3376,
  1562,  2622,   954,  1204,
     0,     0,     0,     0,
 -2404, -3474, -3056, -4330,
  1234,   786,  2154,  -322,
   560,  1160,  2398,  2816,
     0,     0,     0,     0,
 -5008, -6916, -2794, -4504,
 -2174,  -350,  -196,  -354,
  4742,  2790, -1686, -2298,
     0,     0,     0,     0,
 -2978, -3116, -3734, -4124,
 -1452,  -530, -1642, -3032,
 -2566, -3488, -3794, -4680,
     0,     0,     0,     0,
 -5190,   340,  -386,   652,
 -2284,    92,  -408,  -392,
 -5722, -1638, -2302, -3064,
     0,     0,     0,     0,
  1560,   402,  1300,  2288,
   658,   738,  -418,   -30,
 -1632, -2486, -2120, -2432,
     0,     0,     0,     0,
  2406, -1780, -1276,   354,
  -518, -1128, -1704, -1478,
 -3734, -2860, -3842, -2716,
     0,     0,     0,     0,
  -522,   412,   676,   842,
 -1052,  -814, -1052, -2190,
 -3332, -4510, -1644, -2018,
     0,     0,     0,     0,
  1530,  1650,   714,  -116,
 -1214, -2590, -1810, -2496,
 -2816, -4008, -3630, -3176,
     0,     0,     0,     0,
 -1192,  -146,  -230,  -320,
 -2872, -2318, -2764, -3446,
 -4092, -4232, -5162, -3904,
     0,     0,     0,     0,
   -12, -1298, -1234, -1898,
 -4392, -3410, -2906, -4038,
 -5908, -5206, -6564, -6204,
     0,     0,     0,     0,
 -1624, -3708, -2926, -5366,
  3088,  1148,  2280,  3496,
  3874,  4000,  5298,  2904,
     0,     0,     0,     0,
 -4972,  1566,  1162,   472,
  4482,  3820,  5364,  4394,
  5046,  2870,  2752,  3770,
     0,     0,     0,     0,
  -906, -1364, -2684,  -576,
  5886,  4356,  6402,  -368,
  4114,  5130,  6656,   524,
     0,     0,     0,     0,
   242,  1516,  2076,  3154,
  -298,  -824,  -408,  -914,
  -366,   412,  1706,  1400,
     0,     0,     0,     0,
  1874,  3016,  -450, -1128,
 -1280, -1056, -1054, -2190,
 -1134, -2048,  -854,  -664,
     0,     0,     0,     0,
 -1484, -2576, -3706, -3108,
  -706,  -918,  -968, -1462,
  -372,   168,  -548,  1650,
     0,     0,     0,     0,
 -4850, -3444, -5030, -5198,
  -468,   586,   850,  1636,
   764,  -542, -1128,   928,
     0,     0,     0,     0,
  -716, -1226, -1380, -2704,
   236,   396,  1366,  2310,
  -750, -1748,  -648,  -336,
     0,     0,     0,     0,
 -2186, -2368,   866,  -240,
   258,  1222,   772,   972,
  -648, -1716,  -744, -1268,
     0,     0,     0,     0,
   468,  1204,  2198,  1430,
  1702,   256,   820,  -290,
 -1262,    92,   318,  -848,
     0,     0,     0,     0,
  2396,  2780,  3366,  3422,
  -170,   734,   724,  1244,
 -1186,  -716, -1928,    90,
     0,     0,     0,     0,
  4066,  5780,    14,   144,
  1666,  1098,   802,  1622,
  -766, -1012,   104,   830,
     0,     0,     0,     0,
  1132,   934,   136,   -50,
  1336,  2436,  1914,  3298,
    82,   260,  -374,  -206,
     0,     0,     0,     0,
 -1322, -1850,  -642, -1576,
   520,  -188,  -844, -1344,
   428,  1224,  1930,  3566,
     0,     0,     0,     0,
   800,  1482,  -322,  -764,
 -1346, -1190,   614,  1672,
  1558,  3270,  1314,  1742,
     0,     0,     0,     0,
 -1628,   728,   114,   302,
   800,  1212,   150,   942,
  2446,  2494,  3142,  4574,
     0,     0,     0,     0,
  -162,   454,  1316,  1328,
  2042,  2940,  2550,  2956,
  3004,  2194,  3306,  4754,
     0,     0,     0,     0,
   526,   528,  1588,  1642,
  -254,   178,   342,   372,
   888,  1938,  1152,  2452,
     0,     0,     0,     0,
   808,   678,  2560,  2906,
   924,  1836,  2846,  4038,
  1034,  1588,   392,   730,
     0,     0,     0,     0,
  3230,  4788,  1612,  1426,
  2962,  3416,  2476,  2316,
  1344,  1016,  1146,  2156,
     0,     0,     0,     0,
  2570,  3580,  1530,  2064,
  2872,  2376,  1286,  1594,
  2464,  2282,  1728,  2558,
     0,     0,     0,     0,
  1800,  3028,  3088,  2938,
  1126,  1346,  2258,  2100,
  3654,  4624,  6480,  3188,
     0,     0,     0,     0,
  3890,  4794,  7076,  2498,
  2636,  4052,  4114,  -236,
  3976,  4120,  5240,   148,
     0,     0,     0,     0,
  3454,  4156,  1940,  2298,
   388,  -100,  1376,  1904,
   842,  -926,  -864,  -220,
     0,     0,     0,     0,
  2508,  2772,  3920,   814,
  2550,  1858,  2334, -1504,
 -1302,   802,   464,  -486,
     0,     0,     0,     0,
  1718,  -454, -1592,    16,
 -2236, -1720, -2350, -2564,
   344, -1984, -2760,  -776,
     0,     0,     0,     0,
   706, -1464, -1706, -2458,
 -3562,  -794,   -56, -2414,
 -2074, -1614, -2684, -3918,
     0,     0,     0,     0,
 -2030, -2904, -3782, -1836,
 -2250, -3582, -4832, -3258,
 -5086, -5450, -6538, -1566,
     0,     0,     0,     0,
 -1160, -2194, -2774, -3176,
 -4310, -4728, -3026, -4152,
 -1396,  -192,    14, -1328,
     0,     0,     0,     0,
 -2946, -4756, -5712, -6782,
 -5480, -6298, -4184, -7416,
 -1568,  -112,  -338,   632,
     0,     0,     0,     0,
 -2352, -3888,  -598, -1280,
 -1780, -2122, -3034, -3700,
 -1228, -1600, -2000, -3052,
     0,     0,     0,     0,
 -2908, -3780, -2172, -1500,
 -3072, -3910, -3842, -4650,
 -2466, -3512, -4244, -4520,
     0,     0,     0,     0,
 -2650, -2228, -2682, -2320,
 -4826, -5084, -5802, -4452,
 -5346, -6918, -7926, -2786,
     0,     0,     0,     0,
 -2002, -3188, -3068, -4448,
 -5544, -5282, -6092, -4392,
 -3146, -3956, -5248, -1350,
     0,     0,     0,     0,
 -5614, -4016, -3960, -3430,
 -6108, -5680, -6664, -7124,
 -2204, -2372, -3390, -1010,
     0,     0,     0,     0,
 -5054, -4666, -6880, -4016,
 -8000, -5468, -4802, -7056,
 -3774, -4592, -6422, -6674,
     0,     0,     0,     0,
 -4494,  -950,  -298, -1514,
 -6582,  1898,  2730,  3288,
 -9020,   310,  1090,  2166,
     0,     0,     0,     0,
  -434, -2866,   990,    20,
  4106,  4602,  3322,  4074,
  2706,  2924,  1058,  1480,
     0,     0,     0,     0,
  4164,  5662,  1684,  2446,
  3796,  4588,  1586,  2046,
  1956,  1822,   840,  1726,
     0,     0,     0,     0,
  2474,  3488,  3066,  4270,
   902,  1416,   568,  1218,
  1560,  1644,  2768,  3076,
     0,     0,     0,     0,
  4610,  4736,  5172,  6232,
  1252,  2374,  2510,  2262,
  1080,  1910,   -14,  1452,
     0,     0,     0,     0,
  6862,  5468,  5976,  7046,
  3460,  3296,  2462,  4048,
   856,  2614,  4020,  2976,
     0,     0,     0,     0,
  2068,  2412,  3614,  3616,
  3314,  4326,  4744,  3538,
  1742,  2072,  2466,  2986,
     0,     0,     0,     0,
  3146,  2432,  2960,   930,
  4664,  3218,  3796,  5416,
  3558,  3732,  5026,  5552,
     0,     0,     0,     0,
  1542,  3738,  5650,  5276,
  7276,  5198,  5490,  4878,
  6676,  5246,  4936,  3170,
     0,     0,     0,     0,
  4188,  4044,  6856,  9072,
  5940,  6114,  5824,  5948,
  2616,  3998,  3632,  4258,
     0,     0,     0,     0,
  2092,  2726,  5022,  3732,
  5126,  7124,  3782,  4612,
  4172,  4636,  5968,  7972,
     0,     0,     0,     0,
  6544,  6292,  7184,  4862,
  5848,  7128,  7936,  6738,
  7364,  4544,  5644,  6138,
     0,     0,     0,     0,
  3862,  5258,  9278,  8070,
  9418,  8440,  8112, 10668,
  6180,  7972,  7328,  9824,
     0,     0,     0,     0,
     0,  1202,   856,  1304,
     0,  1024,  2174,  1244,
     0, -1084,  -968,  -782,
     0,   668,  -264, -1144,
   756,  2080,  2246,  2842,
  1598,   818,  1340,   988,
   282,   224,  -150,  -630,
 -1720, -1108, -1694, -2190,
  1574,  1976,  2014,  2146,
  2002,  3344,  2482,   798,
   228,   432,  -264,   372,
  -920, -1362, -2494,   -10,
  2524,   650,  1722,  2522,
   386,   392,  -118,  1134,
 -1388,   102,   700,  1172,
  -258, -1282,  -916,  -692,
  3064,  4054,  2766,  3928,
  1770,  1874,  2128,  2936,
   420,   226,   668,   918,
 -1034, -1584,    76,   266,
  4124,  5154,  4620,  5752,
  2372,  2890,  3364,  3878,
  -196,  1012,    -4,  1530,
  -242,  -746, -1920,   276,
  7162,   438,   868,  -688,
  4720,   352,  -156,   602,
  1298,  -796,  -870,   530,
  -828,  -618, -1760, -1104,
 -1830,   838,   702,  1578,
   940,  -864, -1906,   -86,
  1314,  -326,    16,    40,
  -760,  -906, -1124, -1916,
   604,  2080,  2666,   966,
 -1188,   216,   420,  1178,
  -704, -1336, -2434,  -700,
 -2318, -1848, -3326, -2280,
  2006,  1490,   692,   540,
  1648,   116,   494,  1592,
 -1604, -1178, -1830, -1440,
 -2368, -2886, -3366, -4086,
  2416,  2972,  3444,  4094,
  1444,  2360,   358,  1720,
  -444,  -824,  -138, -1332,
  -386, -1344, -1042, -2820,
  -292,  -378,  -304,  -878,
   444,   180,  2172,  1466,
  -562,  -228,  -482, -1202,
 -1610, -2614, -1528, -2604,
 -1666, -1712, -1494, -1674,
  -334,  -844,  -710,   420,
  -702,  -822, -1164, -1832,
 -1202, -2118, -3288, -2288,
 -3600,   -96,  -700,   530,
    64,   -46,  -818, -1456,
 -1756, -2292, -3312, -1716,
 -3374,   104,  -728, -1154,
   916,  1382,  -132,  -862,
  -494,  -814,  -208,  -186,
 -2282, -3976, -1410, -2382,
 -1994, -2322, -2498, -3688,
   406,    20,   986,   976,
 -1464, -1664,  -256,  -622,
 -2000, -3692, -2872, -3460,
 -3386, -3638, -3536, -5080,
 -1306, -2172, -1398, -2064,
 -1064,  -578, -2410, -2962,
 -2300, -3412, -2432, -4148,
 -2344, -3066, -3532, -3046,
 -1442,    24,   -80,  -942,
 -2440, -1078, -1822,  -968,
 -4554, -2968, -4212, -4534,
 -5200, -2262,  -882, -3098,
  -282, -3090, -2766, -4236,
 -1976, -4204, -5544, -5178,
 -6012, -1166,  -772, -2410,
 -3442,   684,   -26,   144,
 -4294, -5898, -7814, -2574,
 -6462, -6600, -8276, -1690,
 -1930, -1242, -1730,  -750,
   780,  1274,  1606, -1096,
 -2832, -2800, -4036, -2836,
 -2338, -3380, -3818, -4444,
  -974, -2054, -2376, -4058,
 -2554,  -836, -2520,  -256,
 -4134, -1900, -3232,    38,
 -5996, -2056, -1830, -1642,
 -5386, -3076, -4410, -2290,
  -620,   370, -1098,   704,
   368, -1094,  -432, -1590,
 -2350, -2176, -3004, -2612,
 -2712, -3322, -4394, -4748,
 -1254, -1822, -1896,  -902,
 -1848, -1200, -4784, -5816,
 -3778, -3228, -5056, -4190,
 -5592, -7218,   638,  -620,
 -1360, -1770,   606,  1146,
 -6920, -4462, -5610, -5368,
 -4282,  -896, -1064,  -972,
    98,  1350,  2462,  -400,
  -226,  -292,   958,  1222,
 -7050, -7414, -9468,  1554,
 -1942,   346, -2894, -1024,
  -396,   698,   -68,   228,
  1408,   508,  1760,   -20,
  2500,  1208,  2448, -2744,
  -132,  1226,  1554,  -158,
   884,   904,  1350, -2416,
   -10,  -704, -2028,  -476,
 -4778, -3008, -3968, -4074,
   -34, -1346, -1598, -1596,
 -2314, -2266, -4010, -2136,
 -1636, -2120, -3946,  -210,
 -6380,  -312,  -516, -1072,
 -1798, -1772, -2566, -3458,
 -3634,   788,  1102,  1820,
  -388,  -636,   404,   662,
 -1694, -2342, -2160, -2000,
 -2218, -2256, -2638, -3842,
  1590,  1430,  3370,   192,
  -326,  1038,  1336,   422,
 -2974, -2278, -3034, -2024,
 -4296,  -748, -2766,   878,
  1662,   828,   792,  -118,
   348,    -8,  -704, -1934,
 -3624, -3942, -4944, -4322,
  1412,  -658, -3176,   748,
  -880,   -68,  -302,  -562,
 -2060, -1654, -1212,   152,
 -6024,  2208,  3370,  3796,
   462,  1132,  1128,  1500,
   -30,  1442,   766,  1584,
 -1380,   418,   196,  -194,
  1112,  1752,  1922,  1512,
  -128,   324,  1350,  -792,
  1122,  1826,  2592,  1702,
  -186,   -44,   280,  1088,
   720,  1756,  -618, -1372,
  -606,   -44,  -546,  -164,
  2682,  2928,  1284,  1684,
   792,  1726,  -258,   908,
   -10,  -188,  -978,  -738,
   -94,  1934,   770, -1434,
  2138,  2554,  2946,  2666,
  1996,   596,  1492,   484,
   562,   928,  -500,  -876,
 -1986,  1202,   412,   754,
  3452,  3150,  4678, -1194,
  1848,  2752,  2350,  -570,
 -2040,  -916, -1178, -2350,
  1574,  -820, -1720,   244,
 -1580,   430,  -242,  -874,
  -574,   590,  1594,   932,
 -2960,   468,   290,   132,
  -242,   646,    60,  1698,
   734,  1540,  1992,   186,
  1848, -1110,    52,  -290,
  -234, -2990, -2780,  1232,
  2522,  2102,  1388,    14,
   948,   436,  1988,   156,
  -798, -1012,   176,   608,
  2120,  1666, -1540, -1148,
   104,   908,   928,  2398,
  -124,  1298,    94,   -78,
  1670,  2718,   186,   758,
   228,  1454,  -152, -1130,
  -196,   488,   910,   -26,
   976,  1212,  1342,   290,
   970,  1392,  1092,  1638,
  -752,   436,   460,   276,
  1138,   244,  1476,   954,
   896,   530,  1864,    72,
  2256,  2334,  2006,   900,
   808,   994,    34,  1124,
  1574,  2518,   414,   716,
  -146,   774,   390,   106,
  2000,  2462,  -158,  -316,
   986,  1356,  -394,   858,
   774,  1662,  1046,  1788,
   956,  1280,  1226,  1538,
   378,  1116,   114,   222,
   134,  2484,  2838,  1848,
  2348,  1648,  2148,  2948,
  1136,   502,  1728,  1338,
  1022,  1680,   962,  1448,
  3078,   890,   944,  1588,
  3758,   674,  2842,  1470,
  1308,  2222,  2528,  2206,
  3180,  1082,  2188,  1336,
  2110,  1556,  2104,  1762,
  1726,  2210,  3054,  3104,
  2384,  1612,  3174,  2530,
  2040,  3596,  4302,   782,
  1452,  2938,  2806,  3300,
  1744,   560,  1154,  2628,
  3624,  2016,  3606,  2296,
  1202,  1232,  2488,  2144,
  2594,  4186,  3288,    50,
  3338,  2088,  3922,  -630,
  3822,  4230,  5174,   -18,
  2052,  2378,  3024,  -212,
   580,  -136,   490,   668,
  -678, -1566, -1110, -1790,
   856,  1470,   936,  1628,
  -888,  1544,    94,   292,
   470,  -406,  1602,  1788,
   736,   630,    34,  -990,
 -1928, -3132,  -552, -1578,
 -1918, -2434,  -708, -1270,
  1432,  1120,  1358,  -102,
   582,  -520, -1016,  -124,
 -2378, -1466, -2858,  -856,
  -714,    -4,   422,  1114,
   644, -1756,  -776, -1508,
 -1276, -2114, -2830, -3148,
  -422,  -168,  -334,   428,
  1228,  -142,  -636, -1078,
 -2838,   -94,    46, -1316,
 -4008, -1712, -2422,  -974,
  -184,  -694,  -346, -1786,
 -1574,  -510,   640,   706,
 -1566, -2840, -4190,  -642,
 -3174, -1718, -2982, -2900,
 -1168,  -756,  -274, -2576,
  1014,   882,   878,   -24,
  -718, -1662, -2028,  -950,
 -4226, -3836, -4974,  -622,
 -1106, -3122, -2718,  -338,
   -16,    64, -1878,  -472,
 -1814,  -192,  -852,  -394,
  -852,  -800, -2044,  -516,
   552,   100,   -20, -1488,
 -1222, -1420, -1970, -1150,
 -1222,  -534,  -512, -1592,
 -1860, -1552, -2692, -3140,
 -1542, -1224, -1604, -1650,
  -788, -1878, -2244, -1508,
  1424,  1962,  2924,  3468,
  1752,  3018,  2456,  1998,
   282,   170,  1958,  2962,
   454,   248,   -78,   880,
  4586,  5008,  4948,  1834,
  2232,  2960,  3818,  2268,
  1538,  2482,  3116,  1214,
   880,   712,  1620,  -268,
  1018,  3424,  4074,  6062,
  3618,  3012,  4634,  5352,
  1562,  1118,  1452,  2406,
  -246,  -846,  -310,   662,
  7328,  3220,  3548,  3644,
  6548,  3678,  3944,  4316,
  3536,  1734,  3076,  2564,
  1062,   366,   194,  1318,
  4444,  6502,  7266,  5846,
  5516,  4248,  4672,  7034,
  3636,  3446,  4816,  5134,
  1800,  1992,  2906,  2636,
     0,     0,     0,     0   // dummys for pipelined read past end
  };

#endif

int GainScramble[85] = {
169,	0,		90,		107,	133,	161,	111,	97,		20,		141,	
25,		4,		11,		128,	2,		1,		71,		83,		157,	147,	
142,	78,		5,		77,		119,	73,		136,	35,		12,		108,	
154,	44,		162,	33,		116,	94,		3,		41,		110,	167,	
163,	58,		38,		165,	93,		80,		88,		86,		114,	8,	
100,	17,		32,		130,	149,	129,	85,		127,	122,	76,	
139,	98,		158,	121,	62,		109,	65,		150,	64,		46,	
67,		15,		96,		34,		146,	144,	69,		124,	105,	135,	
30,		53,		87,		148,	13
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\tab_lbc.h ===
/*
**
** File:        "tab_lbc.h"
**
** Description:  This file contains extern declarations tha tables used by
**              the SG15 LBC Coder for 6.3/5.3 kbps.
**
*/

/*
  	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 3.01

    Original fixed-point code copyright (c) 1995,
    AudioCodes, DSP Group, France Telecom, Universite de Sherbrooke.
    All rights reserved.

    Floating-point code copyright (c) 1995,
    Intel Corporation and France Telecom (CNET).
    All rights reserved.

*/

//This array is not part of the ITU 723 std.
extern int     minus1mod10[LpcOrder];

extern float   HammingWindowTable[LpcFrame];
extern float   BinomialWindowTable[LpcOrder+1] ;
extern float   BandExpTable[LpcOrder] ;
extern float   CosineTable[CosineTableSize] ;
extern float   LspDcTable[LpcOrder] ;
extern int     BandInfoTable[LspQntBands][2] ;
extern float   Band0Tb8[LspCbSize*3] ;
extern float   Band1Tb8[LspCbSize*3] ;
extern float   Band2Tb8[LspCbSize*4] ;
extern short   LspTableInt[LspCbSize*12+4] ;
extern float  *BandQntTable[LspQntBands] ;
extern float   PerFiltZeroTable[LpcOrder] ;
extern float   PerFiltPoleTable[LpcOrder] ;
//PostFiltZeroTable
//PostFiltPoleTable
extern int     Nb_puls[4];
extern float    FcbkGainTable[NumOfGainLev] ;
extern Word32   MaxPosTable[4] ;
extern Word32   CombinatorialTable[MaxPulseNum][SubFrLen/Sgrid] ;
extern float    AcbkGainTable085[85*20] ;
extern float    AcbkGainTable170[170*20] ;
extern float   *AcbkGainTablePtr[3] ;
extern int      AcbkGainBound[3] ;
extern int      GainScramble[85];
//LpfConstTable
extern int      epsi170[170] ;
extern float    gain170[170] ;
extern float   tabgain170[170];
extern float   tabgain85[85];


 extern short AcbkGainTable085Int[85*20] ;
 extern short AcbkGainTable170Int[170*20] ;
 extern short AcbkGainTable170subsetInt[85 *20]  ;
 extern short *AcbkGainTablePtrInt[3]  ;
 extern short LspTableInt[LspCbSize*12+4] ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\tabl_ns.h ===
// PhilF: Remove the three following arrays since the SID
// code does not know how to make a good use of them today.
#if 0
extern const unsigned r53Noise[6*4];
extern const unsigned r63Noise[6*4];
extern const unsigned SIDFrame[1];
#endif
extern const float Squelch[16];
extern const float A[6];
extern const float B[6];
extern const float HhpNumer[4];
extern const float HhpDenom[3];
extern const float Binomial80[11];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\typedef.h ===
//  typedef.h

/*	Original fixed-point code copyright (c) 1995,
    AudioCodes, DSP Group, France Telecom, Universite de Sherbrooke.
    All rights reserved.

    Floating-point code copyright (c) 1995,
    Intel Corporation and France Telecom (CNET).
    All rights reserved.
*/

/*
   Types definitions
*/
#if defined(__BORLANDC__) || defined (__WATCOMC__) || defined(_MSC_VER) || defined(__ZTC__)	|| defined(__HIGHC__)
typedef  long  int   Word32   ;
typedef  short int   Word16   ;
typedef  short int   Flag  ;
#define TST_COMPIL
#endif
#ifdef __sun
typedef short  Word16;
typedef long  Word32;
typedef int   Flag;
#define TST_COMPIL
#endif
#ifdef __unix__
typedef short Word16;
typedef int   Word32;
typedef int   Flag;
#define TST_COMPIL
#endif
#ifndef TST_COMPIL
#error  COMPILER NOT TESTED typedef.h needs to be updated, see readme
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\tabl_ns.c ===
//No CRC codes
// PhilF: Remove the three following arrays since the SID
// code does not know how to make a good use of them today.
#if 0
extern const unsigned r63Noise[6*4]={
 	
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,

	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,

	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,

	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000
 } ;

//padded with ABABABAB
extern const unsigned r53Noise[6*4] = {
 	
	0x00000001,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xABABABAB,

	0x00000001,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xABABABAB,

	0x00000001,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xABABABAB,

	0x00000001,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xABABABAB,
		   
 } ;

extern const unsigned SIDFrame[1] = { 0x00000002 };
#endif

 const float Squelch[16] = {70.0f, /* default */
 10.0f, 20.0f, 30.0f, 40.0f, 50.0f, 60.0f, 70.0f, 80.0f,
 90.0f, 100.0f, 110.0f, 120.0f, 130.0f, 140.0f, 150.0f};
 
const float A[6] = 
	{1.0f,
	-2.554910873842f,
	-3.054788425308f,
	-1.813794458661f,
	-0.521075856868f,
	0.0055927932689f};

const float B[6] = 
	{0.290838380294f,
	1.407780344969f,
	2.770702115733f,
	2.770702115733f,
	1.407780344969f,
	0.290838380294f};

const float HhpNumer[4]={
        0.959696f, -2.879088f, 2.879088f, -0.959696f};

const float HhpDenom[3]={
        2.918062872f, -2.838800222f, 0.9207012679f};	 

const float Binomial80[] = {
	1.000000f, 
	0.999644f, 0.998577f, 0.996802f, 0.994321f, 0.991141f, 
	0.987268f, 0.982710f, 0.977478f, 0.971581f, 0.965032f
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\timer.h ===
//timer.h
#if TIMEIT	

  #if !defined(TIMEIT_STAMP) || TIMEIT_STAMP
    #define TimeStamp(n) TimerStamp(n) //for hands on types
    #define TIMER_STAMP(symb) {\
      extern const int TimerSymb ## symb ## Stamp; \
      extern const int TimerSymb ## TimerOverhead ## Stamp; \
	  TimerStamp(TimerSymb ## symb ## Stamp);\
	  TimerStamp(TimerSymb ## TimerOverhead ## Stamp);\
	  }

    void TimerStamp(int n);
  #else
    #define TIMER_STAMP(s) 
  #endif //TIMEIT_STAMP

  #if !defined(TIMEIT_SPOT) || TIMEIT_SPOT
    #define TIMER_SPOT_ON(symb) {\
      extern const int TimerSymb ## symb ## Spot; \
	  TimerSpotOn(TimerSymb ## symb ## Spot);\
	  }
    #define TIMER_SPOT_OFF(symb) {\
      extern const int TimerSymb ## symb ## Spot; \
	  TimerSpotOff(TimerSymb ## symb ## Spot);\
	  }

    void TimerSpotOn(int n);
    void TimerSpotOff(int n);
  #else
    #define TIMER_SPOT_ON(s)
    #define TIMER_SPOT_OFF(s)
  #endif //TIMEIT_SPOT

  #define TIMER_INITIALIZE TimerInitialize()
  #define TIMER_ON TimerBegin()
  #define TIMER_OFF TimerEnd()
  #define TIMER_REPORT(unitString, scale) TimerReport((unitString), (double)(scale), 1.)

  void TimerInitialize(void);
  void TimerBegin(void);
  void TimerEnd(void);
  void TimerReport(const char *unitName, double scaleSum, double scaleRatio);

#else
  #define TimeStamp(n)
  #define TIMER_INITIALIZE 
  #define TIMER_STAMP(s) 
  #define TIMER_SPOT_ON(s) 
  #define TIMER_SPOT_OFF(s) 
  #define TIMER_ON
  #define TIMER_OFF
  #define TIMER_REPORT(u,s)
#endif //TIMEIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\util_lbc.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

int  MyFloor (float);
#if NOTMINI
void Read_lbc ( float *Dpnt, int Len, FILE *Fp );
void Write_lbc( float *Dpnt, int Len, FILE *Fp );
#endif
void Rem_Dc( float *Dpnt, CODDEF *CodStat);
void Mem_Shift( float *PrevDat, float *DataBuff );
void Line_Pack( LINEDEF *Line, Word32 *Vout,int *VadAct, enum Crate WrkRate);
void Line_Unpk( LINEDEF *Line, Word32 *Vinp, enum Crate *WrkRatePtr, Word16 Crc );
int Rand_lbc( int *p );
//void Scale
float DotProd(register const float in1[], register const float in2[], register int npts);
float DotRev(register const float in1[], register const float in2[], register int npts);
float Dot10(float in1[], float in2[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\util_lbc.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

//no return value and unreferenced label are not interesting warnings
//occur in asm dot product because the compiler doesn't look at the asm code.
#pragma warning(4: 4035 4102) 

#include "opt.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>

#include "typedef.h"
#include "cst_lbc.h"
#include "sdstruct.h"

#include "coder.h"
#include "decod.h"
#include "tabl_ns.h"

#include "sdstuff.h"
#include "util_lbc.h"

//-----------------------------------------------------
int MyFloor(float x)
{
// Note: We fiddle with the FP control word to force it to round
// to -inf.  This way we get the right floor for either positive or
// negative x.

#if OPT_FLOOR

  int retu,fc_old,fc;

  ASM
  {
    fnstcw fc_old;
    mov eax,fc_old;
    and eax, 0f3ffh;
    or  eax, 00400h;
    mov fc,eax;
    fldcw fc;
    
    fld x;            // do the floor
    fistp retu;

    fldcw fc_old;
  }
  return(retu);

#else
  
  float f;

  f = (float)floor(x);
  return((int) f);
  
#endif
}
#if NOTMINI
//-----------------------------------------------------
void  Read_lbc (float *Dpnt, int Len, FILE *Fp)
{
  short Ibuf[Frame];
  int  i,n;

  n = fread (Ibuf, sizeof(short), Len, Fp);
  for (i=0; i<n; i++)
    Dpnt[i] = (float) Ibuf[i];
  for (i=n; i<Len; i++)
    Dpnt[i] = 0.0f;
}

//-----------------------------------------------------
void  Write_lbc(float *Dpnt, int Len, FILE *Fp)
{
  short Obuf[Frame];
  int i;

  for (i=0; i<Len; i++)
  {
    if (Dpnt[i] < -32768.)
      Obuf[i] = -32768;
    else if (Dpnt[i] > 32767)
      Obuf[i] = 32767;
    else
    {
      if (Dpnt[i] < 0)
        Obuf[i] = (short) (Dpnt[i]-0.5);
      else
        Obuf[i] = (short) (Dpnt[i]+0.5);

    }
  }
      
  fwrite(Obuf, sizeof(short), Len, Fp);
}

void	Line_Wr( char *Line, FILE *Fp )
{
	Word16	FrType ;
	int		Size  ;

	FrType = Line[0] & (Word16)0x0003 ;

	/* Check for Sid frame */
	if ( FrType == (Word16) 0x0002 ) {
		return ;
	}

	if ( FrType == (Word16) 0x0000 )
		Size = 24 ;
	else
		Size = 20 ;

	fwrite( Line, Size, 1, Fp ) ;
}

void	Line_Rd( char *Line, FILE *Fp )
{
	Word16	FrType ;
	int		Size  ;

	fread( Line, 1,1, Fp ) ;

	FrType = Line[0] & (Word16)0x0003 ;

	/* Check for Sid frame */
	if ( FrType == (Word16) 0x0002 ) {
		Size = 3 ;
		fread( &Line[1], Size, 1, Fp ) ;
		return ;
	}

	if ( FrType == (Word16) 0x0000 )
		Size = 23 ;
	else
		Size = 19 ;

	fread( &Line[1], Size, 1, Fp ) ;
}
#endif

//-----------------------------------------------------
void  Rem_Dc(float *Dpnt, CODDEF *CodStat)
{
  int  i;
  float acc0;

  if (CodStat->UseHp)
  {
    for (i=0; i < Frame; i++)
    {
      acc0 = (Dpnt[i] - CodStat->HpfZdl)*0.5f;
      CodStat->HpfZdl = Dpnt[i];
      
      Dpnt[i] = CodStat->HpfPdl = acc0 + CodStat->HpfPdl*(127.0f/128.0f);
  }
  }
  else
    for (i=0; i < Frame; i++)
      Dpnt[i] *= 0.5f;
}


//-----------------------------------------------------
void  Mem_Shift(float *PrevDat, float *DataBuff)
{
  int  i;

  float Dpnt[Frame+LpcFrame-SubFrLen];

// Form Buffer

  for (i=0; i < LpcFrame-SubFrLen; i++)
	  Dpnt[i] = PrevDat[i];
  for (i=0; i < Frame; i++)
    Dpnt[i+LpcFrame-SubFrLen] = DataBuff[i];

// Update PrevDat
  
  for (i=0; i < LpcFrame-SubFrLen; i++)
    PrevDat[i] = Dpnt[Frame+i];

// Update DataBuff
  
  for (i=0; i < Frame; i++)
    DataBuff[i] = Dpnt[(LpcFrame-SubFrLen)/2+i];
}

/*
**
** Function:        Line_Pack()
**
** Description:     Packing coded parameters in bitstream of 16-bit words
**
** Links to text:   Section 4
**
** Arguments:
**
**  LINEDEF *Line   Coded parameters for a frame
**  Word32 *Vout    bitstream words
**  Word16 VadAct   Voice Activity Indicator
**
** FILEIO - if defined, bitstream is generated as Big Endian words but little
**          endian bytes.  If not, then it is all little endian.
** 
** Outputs:
**
**  Word32 *Vout
**
** Return value:    None
**
*/
#define bswap(s) ASM mov eax,s ASM bswap eax ASM mov s,eax

//STUFF n bits of x at bit position k of *lp
//      if you fill up *lp, *++lp = leftovers
//WARNING!: as a side effect lp may be changed!
//lp must have an lvalue
//n and k must be compile time constants
#define OPT_STUFF 1
#if OPT_STUFF
#define STUFF(x, lp, n_in, k_in) {\
  register unsigned temp;\
  const int n = (n_in);\
  const int k = (k_in) & 31;\
  temp = (x) & ((1 << n) - 1);\
  *(lp) |= temp << k;\
  if (n+k >= 32)\
    *(++lp) |= temp >> (32-k);\
  }
#else
#define STUFF(x, lp, n_in, k_in) stuff(x, &(lp), n_in, k_in)
void stuff(unsigned x, unsigned **ptrlp, int n, int k_in) {
  unsigned temp;
  int k;

  k = k_in & 31;

  temp = (x) & ((1 << n) - 1);
  *(*ptrlp) |= temp << k;
  if (n+k >= 32)
    *(++*ptrlp) |= temp >> (32-k);
  
  return;
  }
#endif

#define DEBUG_DUMPLINE 0
#if DEBUG_DUMPLINE
#define DUMPLINE(lp) dumpline(lp)
void dumpsfs(SFSDEF *sfsptr)
{
  fprintf(stdout, "%1x ", sfsptr->AcLg);
  fprintf(stdout, "%2x ", sfsptr->AcGn);
  fprintf(stdout, "%2x", sfsptr->Mamp);
  fprintf(stdout, "%1x", sfsptr->Grid);
  fprintf(stdout, "%1x", sfsptr->Tran);
  fprintf(stdout, "%1x ", sfsptr->Pamp);
  fprintf(stdout, "%3x ", sfsptr->Ppos);
//  fprintf(stdout, "\n"); 
  return;
}

void dumpline(LINEDEF *lineptr)
{
  fprintf(stdout, "%6x ", lineptr->LspId);
  fprintf(stdout, "%2x ", lineptr->Olp[0]);
  fprintf(stdout, "%2x ", lineptr->Olp[1]);
//  fprintf(stdout, "\n"); 
  dumpsfs(&lineptr->Sfs[0]); 
  dumpsfs(&lineptr->Sfs[1]); 
  dumpsfs(&lineptr->Sfs[2]); 
  dumpsfs(&lineptr->Sfs[3]); 
  fprintf(stdout, "\n"); 
  return;
}
#else 
#define DUMPLINE(lp)
#endif


void Line_Pack( LINEDEF *Line, Word32 *Vout, int *VadBit, enum Crate WrkRate )
//4.0f void	Line_Pack( LINEDEF *Line, char *Vout, Word16 VadBit )
{
	int		i ;

	Word32 *Bsp;
	Word32	Temp ;

	/* Clear the output vector */
        if ( WrkRate == Rate63 )
	{
	  for ( i = 0 ; i < 6 ; i ++ )
	    Vout[i] = 0 ;
	}
	else
	{
	  for ( i = 0 ; i < 5 ; i ++ )
	    Vout[i] = 0 ;
	}

	Bsp = Vout; //running pointer into output buffer as Word32's

	/* 
	Add the coder rate info and the VAD status to the 2 msb
        of the first word of the frame.

	The signalling is as follows:
        00  :   High Rate
        01  :   Low Rate
        10  :   Non-speech
        11  :   Reserved for future use
	*/

	Temp = 0L ;
	if ( *VadBit == 1 ) {
		if ( WrkRate == Rate63 )
			Temp = 0x00000000L ;
		else
			Temp = 0x00000001L ;
	}

	/* Serialize Control info */
	STUFF( Temp, Bsp, 2, 0 ) ;

	/* 24 bit LspId */
	Temp = (*Line).LspId ;
	STUFF( Temp, Bsp, 24, 2 ) ;

	/* Check for Speech/NonSpeech case */
	if ( *VadBit == 1 ) {

		/*
		 	Do the part common to both rates
		*/

		/* Adaptive code book lags */
		Temp = (Word32) (*Line).Olp[0] - (Word32) PitchMin ;
		STUFF( Temp, Bsp, 7, 26 ) ;

		Temp = (Word32) (*Line).Sfs[1].AcLg ;
		STUFF( Temp, Bsp, 2, 33 ) ;

		Temp = (Word32) (*Line).Olp[1] - (Word32) PitchMin ;
		STUFF( Temp, Bsp, 7, 35 ) ;

		Temp = (Word32) (*Line).Sfs[3].AcLg ;
		STUFF( Temp, Bsp, 2, 42 ) ;

		/* Write combined 12 bit index of all the gains */
		Temp = (*Line).Sfs[0].AcGn*NumOfGainLev + (*Line).Sfs[0].Mamp ;
		if ( WrkRate == Rate63 )
			Temp += (Word32) (*Line).Sfs[0].Tran << 11 ;
		STUFF( Temp, Bsp, 12, 44 ) ;

		Temp = (*Line).Sfs[1].AcGn*NumOfGainLev + (*Line).Sfs[1].Mamp ;
		if ( WrkRate == Rate63 )
			Temp += (Word32) (*Line).Sfs[1].Tran << 11 ;
		STUFF( Temp, Bsp, 12, 56 ) ;

		Temp = (*Line).Sfs[2].AcGn*NumOfGainLev + (*Line).Sfs[2].Mamp ;
		if ( WrkRate == Rate63 )
			Temp += (Word32) (*Line).Sfs[2].Tran << 11 ;
		STUFF( Temp, Bsp, 12, 68 ) ;

		Temp = (*Line).Sfs[3].AcGn*NumOfGainLev + (*Line).Sfs[3].Mamp ;
		if ( WrkRate == Rate63 )
			Temp += (Word32) (*Line).Sfs[3].Tran << 11 ;
		STUFF( Temp, Bsp, 12, 80 ) ;

		/* Write all the Grid indices */
		STUFF( (*Line).Sfs[0].Grid, Bsp, 1, 92 ) ;
		STUFF( (*Line).Sfs[1].Grid, Bsp, 1, 93 ) ;
		STUFF( (*Line).Sfs[2].Grid, Bsp, 1, 94 ) ;
		STUFF( (*Line).Sfs[3].Grid, Bsp, 1, 95 ) ;

		/* High rate only part */
		if ( WrkRate == Rate63 ) {

			/* Write the reserved bit as 0 */
    		STUFF( 0, Bsp, 1, 96 ) ;

			/* Write 13 bit combined position index */
			Temp = (*Line).Sfs[0].Ppos >> 16 ;
			Temp = Temp * 9 + ( (*Line).Sfs[1].Ppos >> 14) ;
			Temp *= 90 ;
			Temp += ((*Line).Sfs[2].Ppos >> 16) * 9 + ( (*Line).Sfs[3].Ppos >> 14 ) ;
			STUFF( Temp, Bsp, 13, 97 ) ;

			/* Write all the pulse positions */
			Temp = (*Line).Sfs[0].Ppos & 0x0000ffffL ;
			STUFF( Temp, Bsp, 16, 110 ) ;

			Temp = (*Line).Sfs[1].Ppos & 0x00003fffL ;
			STUFF( Temp, Bsp, 14, 126 ) ;

			Temp = (*Line).Sfs[2].Ppos & 0x0000ffffL ;
			STUFF( Temp, Bsp, 16, 140 ) ;

			Temp = (*Line).Sfs[3].Ppos & 0x00003fffL ;
			STUFF( Temp, Bsp, 14, 156 ) ;

			/* Write pulse amplitudes */
			Temp = (Word32) (*Line).Sfs[0].Pamp ;
			STUFF( Temp, Bsp, 6, 170 ) ;

			Temp = (Word32) (*Line).Sfs[1].Pamp ;
			STUFF( Temp, Bsp, 5, 176 ) ;

			Temp = (Word32) (*Line).Sfs[2].Pamp ;
			STUFF( Temp, Bsp, 6, 181 ) ;

			Temp = (Word32) (*Line).Sfs[3].Pamp ;
			STUFF( Temp, Bsp, 5, 187 ) ;
		}
		/* Low rate only part */
		else {

			/* Write 12 bits of positions */
			STUFF( (*Line).Sfs[0].Ppos, Bsp, 12, 96 ) ;
			STUFF( (*Line).Sfs[1].Ppos, Bsp, 12, 108 ) ;
			STUFF( (*Line).Sfs[2].Ppos, Bsp, 12, 120 ) ;
			STUFF( (*Line).Sfs[3].Ppos, Bsp, 12, 132 ) ;

			/* Write 4 bit Pamps */
			STUFF( (*Line).Sfs[0].Pamp, Bsp, 4, 144 ) ;
			STUFF( (*Line).Sfs[1].Pamp, Bsp, 4, 148 ) ;
			STUFF( (*Line).Sfs[2].Pamp, Bsp, 4, 152 ) ;
			STUFF( (*Line).Sfs[3].Pamp, Bsp, 4, 156 ) ;
		}

	}
	else {
		/* Do Sid frame gain */
		
	}

	DUMPLINE(Line);
}

//UNSTUFF n bits of *lp at bit position k into x
//      if you run out of *lp, use *++lp for leftovers
//WARNING!: as a side effect lp may be changed!
//lp and x must have an lvalue
//n and k must be compile time constants
//temp must be unsigned for shifts to be logical
#define UNSTUFF(x, lp, n_in, k_in) {\
  register unsigned temp;\
  const int n = (n_in);\
  const int k = (k_in) & 31;\
  temp = *(lp);\
  temp=temp >> k;\
  if (n+k >= 32)\
    temp |= *(++lp) << (32-k);\
  temp &= ((1 << n) - 1);\
  (x) = temp;\
  }


/*
**
** Function:        Line_Upck()
**
** Description:     unpacking of bitstream, gets coding parameters for a frame
**
** Links to text:   Section 4
**
** Arguments:
**
**  Word32 *Vinp        bitstream words
**  int    *VadAct      Voice Activity Indicator
**
** Outputs:
**
**  Word16 *VadAct
**
** Return value:
**
**  LINEDEF             coded parameters
**     Word16   Crc
**     Word32   LspId
**     Word16   Olp[SubFrames/2]
**     SFSDEF   Sfs[SubFrames]
**
*/

void Line_Unpk(LINEDEF *LinePtr, Word32 *Vinp, enum Crate *WrkRatePtr, Word16 Crc )
{
	Word32 *Bsp;
	int	FrType ;
	Word32	Temp ;
	int		BadData = 0; //Set to TRUE if invalid data discovered
	Word16  Bound_AcGn ;

	//short index;

	LinePtr->Crc = Crc;
	if(Crc !=0) {
		*WrkRatePtr = Lost;
		return; //This occurs when external erasure file is used
	}

	Bsp = Vinp;

	/* Decode the first two bits */
	UNSTUFF( Temp, Bsp, 2, 0 ) ;
	FrType = Temp;

	/* Decode the LspId */
	UNSTUFF( LinePtr->LspId, Bsp, 24, 2 ) ;
										 
	switch ( FrType ) {
	    case 0:
                *WrkRatePtr = Rate63;
                    break;
	    case 1:
	        *WrkRatePtr = Rate53;
		    break;
	    case 2:
	        *WrkRatePtr = Silent;
            //return; //no need to unpact the rest
			//HACK: for SID frame handling
			//Keep WrkRate set to whatever the previous frame was
			//	and decode in a normal fashion
			 
			 //index=getRand();
			 //if(*WrkRatePtr==Rate53)
			 //{
                //memcpy((char *)(Vinp),&r53Noise[index*6],24);
             //}
             //else if(*WrkRatePtr==Rate63)
             //{
            	//memcpy((char *)(Vinp),&r63Noise[index*6],24);
           	 //}
			//Burn first two bits again, since we already got the frame type
			//UNSTUFF( Temp, Bsp, 2, 0 );
			  return;

            default:
                *WrkRatePtr = Lost;
                //??? unpack to rest to guess from?
				return;
	}

	/*
		Decode the common information to both rates
	*/

	/* Decode the adaptive codebook lags */
	UNSTUFF( Temp, Bsp, 7, 26 ) ;
	/* TEST if forbidden code */
    if( Temp <= 123) {
        LinePtr->Olp[0] = (Word16) Temp + (Word16)PitchMin ;
    }
    else {
        /* transmission error */
        LinePtr->Crc = 1;
        return;	/*what happens in the minfilter?*/
    }

	UNSTUFF( Temp, Bsp, 2, 33 ) ;
	LinePtr->Sfs[1].AcLg = Temp ;

	UNSTUFF( Temp, Bsp, 7, 35 ) ;
	/* TEST if forbidden code */
    if( Temp <= 123) {
        LinePtr->Olp[1] = (Word16) Temp + (Word16)PitchMin ;
    }
    else {
        /* transmission error */
        LinePtr->Crc = 1;
        return;
    }

	//UNSTUFF( Temp, Bsp, 2, 41 ) ;
	UNSTUFF( Temp, Bsp, 2, 42 ) ;
	LinePtr->Sfs[3].AcLg = (Word16) Temp ;

	LinePtr->Sfs[0].AcLg = 1 ;
	LinePtr->Sfs[2].AcLg = 1 ;

	/* Decode the combined gains accordingly to the rate */
	UNSTUFF( Temp, Bsp, 12, 44 ) ;
	LinePtr->Sfs[0].Tran = 0 ;

	Bound_AcGn = NbFilt170 ;
	if ( (*WrkRatePtr == Rate63) && (LinePtr->Olp[0>>1] < (SubFrLen-2) ) ) {
		LinePtr->Sfs[0].Tran = (Word16)(Temp >> 11) ;
		Temp &= 0x000007ffL ;
		Bound_AcGn = NbFilt085 ;
	}
	LinePtr->Sfs[0].AcGn = (Word16)(Temp / (Word16)NumOfGainLev) ;

	if(LinePtr->Sfs[0].AcGn < Bound_AcGn ) {
            LinePtr->Sfs[0].Mamp = (Word16)(Temp % (Word16)NumOfGainLev) ;
    }
    else {
            /* error detected */
            LinePtr->Crc = 1;
            return ;
    }

	UNSTUFF( Temp, Bsp, 12, 56 ) ;
	LinePtr->Sfs[1].Tran = 0 ;

	Bound_AcGn = NbFilt170 ;
	if ( (*WrkRatePtr == Rate63) && (LinePtr->Olp[1>>1] < (SubFrLen-2) ) ) {
		LinePtr->Sfs[1].Tran = (Word16)(Temp >> 11) ;
		Temp &= 0x000007ffL ;
		Bound_AcGn = NbFilt085 ;
	}
	LinePtr->Sfs[1].AcGn = (Word16)(Temp / (Word16)NumOfGainLev) ;

	if(LinePtr->Sfs[1].AcGn < Bound_AcGn ) {
            LinePtr->Sfs[1].Mamp = (Word16)(Temp % (Word16)NumOfGainLev) ;
    }
    else {
            /* error detected */
            LinePtr->Crc = 1;
            return ;
    }

	UNSTUFF( Temp, Bsp, 12, 68 ) ;
	LinePtr->Sfs[2].Tran = 0 ;

	Bound_AcGn = NbFilt170 ;
	if ( (*WrkRatePtr == Rate63) && (LinePtr->Olp[2>>1] < (SubFrLen-2) ) ) {
		LinePtr->Sfs[2].Tran = (Word16)(Temp >> 11) ;
		Temp &= 0x000007ffL ;
		Bound_AcGn = NbFilt085 ;
	}
	LinePtr->Sfs[2].AcGn = (Word16)(Temp / (Word16)NumOfGainLev) ;

	if(LinePtr->Sfs[2].AcGn < Bound_AcGn ) {
            LinePtr->Sfs[2].Mamp = (Word16)(Temp % (Word16)NumOfGainLev) ;
    }
    else {
            /* error detected */
            LinePtr->Crc = 1;
            return ;
    }

	UNSTUFF( Temp, Bsp, 12, 80 ) ;
	LinePtr->Sfs[3].Tran = 0 ;

	Bound_AcGn = NbFilt170 ;
	if ( (*WrkRatePtr == Rate63) && (LinePtr->Olp[3>>1] < (SubFrLen-2) ) ) {
		LinePtr->Sfs[3].Tran = (Word16)(Temp >> 11) ;
		Temp &= 0x000007ffL ;
		Bound_AcGn = NbFilt085 ;
	}
	LinePtr->Sfs[3].AcGn = (Word16)(Temp / (Word16)NumOfGainLev) ;

	if(LinePtr->Sfs[3].AcGn < Bound_AcGn ) {
            LinePtr->Sfs[3].Mamp = (Word16)(Temp % (Word16)NumOfGainLev) ;
    }
    else {
            /* error detected */
            LinePtr->Crc = 1;
            return ;
    }


	/* Decode the grids */
	UNSTUFF( LinePtr->Sfs[0].Grid, Bsp, 1, 92 ) ;
	UNSTUFF( LinePtr->Sfs[1].Grid, Bsp, 1, 93 ) ;
	UNSTUFF( LinePtr->Sfs[2].Grid, Bsp, 1, 94 ) ;
	UNSTUFF( LinePtr->Sfs[3].Grid, Bsp, 1, 95 ) ;

	if ( *WrkRatePtr == Rate63 ) {

		/* Skip the reserved bit */
   		UNSTUFF( Temp, Bsp, 1, 96 ) ;
		if(Temp != 0) 
		  BadData = 1;

		/* Decode 13 bit combined position index */
   		UNSTUFF( Temp, Bsp, 13, 97 ) ;
		LinePtr->Sfs[0].Ppos = ( Temp/90 ) / 9 ;
		LinePtr->Sfs[1].Ppos = ( Temp/90 ) % 9 ;
		LinePtr->Sfs[2].Ppos = ( Temp%90 ) / 9 ;
		LinePtr->Sfs[3].Ppos = ( Temp%90 ) % 9 ;

		/* Decode all the pulse positions */
   		UNSTUFF( Temp, Bsp, 16, 110 ) ;
		LinePtr->Sfs[0].Ppos = ( LinePtr->Sfs[0].Ppos << 16 ) + Temp ;
   		UNSTUFF( Temp, Bsp, 14, 126 ) ;
		LinePtr->Sfs[1].Ppos = ( LinePtr->Sfs[1].Ppos << 14 ) + Temp ;
   		UNSTUFF( Temp, Bsp, 16, 140 ) ;
		LinePtr->Sfs[2].Ppos = ( LinePtr->Sfs[2].Ppos << 16 ) + Temp ;
   		UNSTUFF( Temp, Bsp, 14, 156 ) ;
		LinePtr->Sfs[3].Ppos = ( LinePtr->Sfs[3].Ppos << 14 ) + Temp ;
		
		/* Decode pulse amplitudes */
   		UNSTUFF( LinePtr->Sfs[0].Pamp, Bsp, 6, 170 ) ;
   		UNSTUFF( LinePtr->Sfs[1].Pamp, Bsp, 5, 176 ) ;
   		UNSTUFF( LinePtr->Sfs[2].Pamp, Bsp, 6, 181 ) ;
   		UNSTUFF( LinePtr->Sfs[3].Pamp, Bsp, 5, 187 ) ;
	}

	else {
		/* Decode the positions */
   		UNSTUFF( LinePtr->Sfs[0].Ppos, Bsp, 12, 96 ) ;
   		UNSTUFF( LinePtr->Sfs[1].Ppos, Bsp, 12, 108 ) ;
   		UNSTUFF( LinePtr->Sfs[2].Ppos, Bsp, 12, 120 ) ;
   		UNSTUFF( LinePtr->Sfs[3].Ppos, Bsp, 12, 132 ) ;

		/* Decode the amplitudes */
   		UNSTUFF( LinePtr->Sfs[0].Pamp, Bsp, 4, 144 ) ;
   		UNSTUFF( LinePtr->Sfs[1].Pamp, Bsp, 4, 148 ) ;
   		UNSTUFF( LinePtr->Sfs[2].Pamp, Bsp, 4, 152 ) ;
   		UNSTUFF( LinePtr->Sfs[3].Pamp, Bsp, 4, 156 ) ;
	}
   DUMPLINE(LinePtr);
   return;
}


//-------------------------------------------
int Rand_lbc(int *p)
{
  *p = ((*p)*521L + 259) << 16 >> 16;
  return(*p);
}

//-------------------------------------------
//Scale


float DotProd(register const float in1[], register const float in2[], register int npts)
/************************************************************************/
/* in1[],in2[]; Input arrays                                            */
/* npts;        Number of samples in each (vector dimension)            */
/************************************************************************/
{
#if OPT_DOT
#define array1 esi
#define array2 edi
#define idx    ebx
#define prod2(n) ASM fld DP[array1+4*idx+4*n]  ASM fmul DP[array2+4*idx+4*n]
#define faddp(n) ASM faddp ST(n),ST(0)

// Do in groups of 8.  We do 4 before the loop, then groups
// of 8, and then the final leftovers.

ASM
{
#if 0 //npts of type short
  mov idx,0;
  mov bx,npts;
#else
  mov idx,npts;
#endif
mov array1,in1;
mov array2,in2;
sub idx,12;
jle small;
}

prod2(11);
prod2(10);
prod2(9)   fxch(2)  faddp(1);
prod2(8)   fxch(2)  faddp(1);

looop:
prod2(7)  fxch(2)   faddp(1);
prod2(6)  fxch(2)   faddp(1);
prod2(5)  fxch(2)   faddp(1);
prod2(4)  fxch(2)   faddp(1);
prod2(3)  fxch(2)   faddp(1);
prod2(2)  fxch(2)   faddp(1);
prod2(1)  fxch(2)   faddp(1);
prod2(0)  fxch(2)   faddp(1);
ASM sub idx,8;
ASM  jge looop;


ASM add idx,7;
ASM  jl done;

loop2:
prod2(0)  fxch(2)   faddp(1);
ASM dec idx;
ASM  jge loop2;

done:
faddp(1);
ASM jmp alldone;

small:   // handle Len<12 cases here
ASM add idx,9
ASM cmp idx,-1
ASM  jg MoreThan2
ASM je  Exactly2


prod2(2);
ASM jmp alldone;

Exactly2:
prod2(2);
prod2(1);
faddp(1);
ASM jmp alldone;

MoreThan2:
prod2(2);
prod2(1);
ASM jmp loop2;

alldone: ;
#else

 	register float accum;  /* Internal accumulator                 */
	int n=npts,i;

	accum = 0.0f;
	for (i=0; i<n; i++)
		accum += in1[i] * in2[i];
	return(accum);
#endif
//Ignore warning C4035 and C4102 for da_dot and da_dotr: due to use of __asm

}


//-------------------------------------------------------------
float DotRev(register const float in1[], register const float in2[], register int npts)
/************************************************************************/
/* in1[],in2[]; Input arrays                                            */
/* npts;        Number of samples in each (vector dimension)            */
/************************************************************************/
{
#if OPT_REV
#define array1 esi
#define array2 edi
#define idx    ebx
#define prod3(n) ASM fld DP[array1+4*idx+4*n]  ASM fmul DP[array2-4*n]
#define faddp(n) ASM faddp ST(n),ST(0)

// Do in groups of 8.  We do 4 before the loop, then groups
// of 8, and then the final leftovers.

ASM
{
mov idx,npts;
mov array1,in1;
mov array2,in2;
lea array2,[array2+4*11];   // point element array2[11]
sub idx,12;                 // point to array1[end-11]
jle small;
}

prod3(11);
prod3(10);
prod3(9)   fxch(2)  faddp(1);
prod3(8)   fxch(2)  faddp(1);

looop:
prod3(7)  fxch(2)   faddp(1);
prod3(6)  fxch(2)   faddp(1);
prod3(5)  fxch(2)   faddp(1);
prod3(4)  fxch(2)   faddp(1);
prod3(3)  fxch(2)   faddp(1);
prod3(2)  fxch(2)   faddp(1);
prod3(1)  fxch(2)   faddp(1);
prod3(0)  fxch(2)   faddp(1);
ASM add array2,32
ASM sub idx,8;
ASM  jge looop;

cleanup:
ASM sub array2,28
ASM add idx,7;
ASM  jl done;

loop2:
prod3(0)  fxch(2)   faddp(1);
ASM add array2,4
ASM dec idx;
ASM  jge loop2;

done:
faddp(1);
ASM jmp alldone;

small:   // handle Len<12 cases here
ASM sub array2,36
ASM add idx,9
ASM cmp idx,-1
ASM  jg MoreThan2
ASM je  Exactly2

Exactly1:
prod3(2);
ASM jmp alldone;

Exactly2:
prod3(2);
prod3(1);
faddp(1);
ASM jmp alldone;

MoreThan2:
prod3(2);
prod3(1);
ASM jmp loop2;

alldone: ;
#else
         
	register float accum;  /* Internal accumulator                 */
	int i;

	in2 += npts-1;
	accum = 0.0f;
	for (i=0; i<npts; i++)
		accum += in1[i] * (*in2--);
	return(accum);

#endif
//Ignore warning C4035 and C4102 for da_dotr: due to use of __asm

}

//-------------------------------------------------------------
float Dot10(float *in1, float *in2)
{
  return(
    in1[0]*in2[0] +
    in1[1]*in2[1] +
    in1[2]*in2[2] +
    in1[3]*in2[3] +
    in1[4]*in2[4] +
    in1[5]*in2[5] +
    in1[6]*in2[6] +
    in1[7]*in2[7] +
    in1[8]*in2[8] +
    in1[9]*in2[9]
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\ccodecid.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:11:46  $
// $Archive:   S:\h26x\src\common\ccodecid.h_v  $
// $Header:   S:\h26x\src\common\ccodecid.h_v   1.2   27 Dec 1995 14:11:46   RMCKENZX  $
// $Log:   S:\h26x\src\common\ccodecid.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:11:46   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////
#ifndef __CODECID_H__
#define __CODECID_H__

#define YVU9_CODEC   0
#define H263_CODEC   1
#define YUV12_CODEC  2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\c1rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   RHAZRA  $
// $Date:   07 Nov 1996 14:47:44  $
// $Archive:   S:\h26x\src\common\c1rtp.h_v  $
// $Header:   S:\h26x\src\common\c1rtp.h_v   1.1   07 Nov 1996 14:47:44   RHAZRA  $
// $Log:   S:\h26x\src\common\c1rtp.h_v  $
;// 
;//    Rev 1.1   07 Nov 1996 14:47:44   RHAZRA
;// Added function prototype for RTP buffer overhead estimation function
;// 
;//    Rev 1.0   21 Aug 1996 18:29:44   RHAZRA
;// Initial revision.
;// 
;//    Rev 1.1   03 May 1996 13:09:58   CZHU
;// 
;// 
;//    Rev 1.0   22 Apr 1996 16:38:30   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.6   10 Apr 1996 13:32:50   CZHU
;// 
;// Moved testing packet loss into this module for common use by encoder or dec
;// 
;//    Rev 1.5   29 Mar 1996 13:33:16   CZHU
;// 
;// Moved bitstream verification from d3rtp.cpp to c3rtp.cpp
;// 
;//    Rev 1.4   23 Feb 1996 18:01:48   CZHU
;// 
;//    Rev 1.3   23 Feb 1996 17:23:58   CZHU
;// 
;// Changed packet size adjustment
;// 
;//    Rev 1.2   15 Feb 1996 12:02:14   CZHU
;// 
;//    Rev 1.1   14 Feb 1996 15:01:34   CZHU
;// clean up
;// 
;//    Rev 1.0   12 Feb 1996 17:06:42   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   29 Jan 1996 13:50:26   CZHU
;// Initial revision.
;// 
;//    Rev 1.2   04 Dec 1995 16:50:52   CZHU
;// 
;//    Rev 1.1   01 Dec 1995 15:54:12   CZHU
;// Included Init() and Term() functions.
;// 
;//    Rev 1.0   01 Dec 1995 15:31:10   CZHU
;// Initial revision.

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#ifndef _H261_RTP_C1RTP_
#define  _H261_RTP_C1RTP_

const U32  DEFAULT_PACKET_SIZE               = 512;		        //over IP
const U32  DEFAULT_PACKET_SIZE_VARIANCE      = 100;
const U32  DEFAULT_FRAME_SIZE                = 64 * 1024 / 5;	//64KB at 5 fps

const U32  H261_RTP_BS_START_CODE = FOURCC_H263; 

const U32  RTP_H26X_INTRA_CODED   = 0x00000001;

const U32 H26X_RTP_PAYLOAD_VERSION=0;
const U32 RTP_H26X_PACKET_LOST   =0x00000001;

typedef struct {
  U32 uVersion;
  U32 uFlags;
  U32 uUniqueCode;
  U32 uCompressedSize;
  U32 uNumOfPackets;
  U8  u8Src;
  U8  u8TR;
  U8  u8TRB;
  U8  u8DBQ;

} T_H26X_RTP_BSINFO_TRAILER;


typedef struct {
	U32 uFlags;
	U32 uBitOffset;
	 U8 u8MBA;
	 U8 u8Quant;
	 U8 u8GOBN;
	 I8 i8HMV;
	 I8 i8VMV;
     U8 u8Padding0;
    U16 u16Padding1;
	 
} T_RTP_H261_BSINFO	;

extern  I32 H26XRTP_VerifyBsInfoStream(T_H263DecoderCatalog *,U8 *, U32 );
extern  DWORD H261EstimateRTPOverhead(LPCODINST, LPBITMAPINFOHEADER);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\g723\verinfo.h ===
//
//    INTEL Corporation Proprietary Information
//
//    This listing is supplied under the terms of a license
//    agreement with INTEL Corporation and may not be copied
//    nor disclosed except in accordance with the terms of
//    that agreement.
//
//    Copyright (c) 1996 Intel Corporation.
//    All Rights Reserved.
//


#define APPVERSION		4
#define APPREVISION		0
#define APPRELEASE		0

#define VERSIONPRODUCTNAME	"Intel G.723 ACM Driver\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Intel Corp. 1995-1999\0"

#define VERSIONSTR		"1.00.017\0"

#define VERSIONCOMPANYNAME	"Intel Corporation\0"

#ifndef OFFICIAL
#define VER_PRIVATEBUILD	VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD	0
#endif

#ifndef FINAL
#define VER_PRERELEASE		VS_FF_PRERELEASE
#else
#define VER_PRERELEASE		0
#endif

#if defined(DEBUG_RETAIL)
#define VER_DEBUG		VS_FF_DEBUG    
#elif defined(DEBUG)
#define VER_DEBUG		VS_FF_DEBUG    
#else
#define VER_DEBUG		0
#endif

#define VERSIONFLAGS		(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\c1rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Header:   S:\h26x\src\common\c1rtp.cpv   1.5   02 Dec 1996 16:13:38   RHAZRA  $
// $Log:   S:\h26x\src\common\c1rtp.cpv  $
# 
#    Rev 1.5   02 Dec 1996 16:13:38   RHAZRA
# More adjustment to the H.261 RTp overhead estimation routine.
# 
#    Rev 1.4   22 Nov 1996 14:52:22   RHAZRA
# Changed RTP overhead estimation routine slightly.
# 
#    Rev 1.3   18 Nov 1996 17:10:48   MBODART
# Replaced all debug message invocations with Active Movie's DbgLog.
# 
#    Rev 1.2   07 Nov 1996 14:46:32   RHAZRA
# Added function to guestimate RTP overhead in bitstream buffer.
# 
#    Rev 1.1   23 Aug 1996 13:05:54   RHAZRA
# Added #ifdef RING0 .. #endif to avoid wsprintf and GlobalAlloc
# problems in RING0
# 
#    Rev 1.0   21 Aug 1996 18:29:04   RHAZRA
# Initial revision.
// 
//    Rev 1.2   02 May 1996 13:27:04   CZHU
// Adjust for merging with main database in the decoder
// 
//    Rev 1.1   28 Apr 1996 20:34:50   BECHOLS
// 
// Removed IFDEF -- RTP_HEADER.
// 
//    Rev 1.0   22 Apr 1996 17:47:54   BECHOLS
// Initial revision.
// 
//    Rev 1.3   10 Apr 1996 13:32:08   CZHU
// 
// Moved testing packet loss into this module 
// for common use by encoder or dec
// 
//    Rev 1.2   29 Mar 1996 14:45:06   CZHU
// 
//    Rev 1.1   29 Mar 1996 14:39:34   CZHU
// Some cleaning
// 
//    Rev 1.0   29 Mar 1996 13:32:42   CZHU
// Initial revision.
// 
*/
#include "precomp.h"

I32 H26XRTP_VerifyBsInfoStream(
	T_H263DecoderCatalog *DC,
    U8 *pu8Src,
    U32 uSize
)
{
  T_H26X_RTP_BSINFO_TRAILER *pBsTrailer;
  T_RTP_H261_BSINFO *pBsInfo;

#ifndef RING0
 #ifdef _DEBUG
  int  i;
 #endif
#endif

  ASSERT(!DC->iVerifiedBsExt);

  DC->iVerifiedBsExt=TRUE;
  pBsTrailer =(T_H26X_RTP_BSINFO_TRAILER *)(pu8Src + uSize);
  pBsTrailer--;

#ifndef RING0
 #ifdef _DEBUG
  {char msg[120];
   int iused;

   iused= wsprintf(msg,"StartCode = %ld, CompSize=%ld, No.Pack=%ld, SRC=%d, TR=%d, TRB=%d, DBQ=%d",
            pBsTrailer->uUniqueCode, pBsTrailer->uCompressedSize,
            pBsTrailer->uNumOfPackets,pBsTrailer->u8Src,
            pBsTrailer->u8TR,pBsTrailer->u8TRB,pBsTrailer->u8DBQ );
   ASSERT(iused < 120);
   DBOUT(msg);  
  }
  #endif
#endif          

  if (pBsTrailer->uUniqueCode != H261_RTP_BS_START_CODE)
  {
//#ifdef LOSS_RECOVERY
#ifndef RING0
 #ifdef _DEBUG
   DBOUT("No RTP BS Extension found");
 #endif
#endif
   DC->iValidBsExt   = FALSE;
   DC->uNumOfPackets = 0;
   DC->pBsInfo       = NULL;
   DC->pBsTrailer    = NULL;

//#endif

   goto ret;
  }
  //bitstream is valid, so...
  pBsInfo = (T_RTP_H261_BSINFO *)pBsTrailer; 
  pBsInfo -= pBsTrailer->uNumOfPackets;

//#ifdef LOSS_RECOVERY
  DC->pBsTrailer = (void *)pBsTrailer;
  DC->uNumOfPackets = pBsTrailer->uNumOfPackets;
  DC->iValidBsExt =TRUE;
  DC->pBsInfo     = (void *)pBsInfo;
//#endif

#ifndef RING0
 #ifdef _DEBUG
  for (i=0; i< (int)pBsTrailer->uNumOfPackets; i++)
  {
   char msg[120];
   int iused;

   iused= wsprintf(msg, 
       "uFlag =%d,BitOffset=%d, MBA=%d, uQuant=%d,GOBN=%d",
                 pBsInfo->uFlags,
                 pBsInfo->uBitOffset,
                 pBsInfo->u8MBA,
                 pBsInfo->u8Quant,
                 pBsInfo->u8GOBN);

	  ASSERT(iused < 120);
    DBOUT(msg);


	pBsInfo++;
  }
  #endif
#endif

ret:
 return TRUE;
}

DWORD H261EstimateRTPOverhead(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1)
{
	DWORD dExtendedSize;
	DWORD dTargetFrameSize;
	DWORD dEffectivePacketSize;
    BOOL  bTargetSizeOK;
	DWORD dNumberOfGOBs;
	DWORD dNumberOfPacketsPerGOB;
	DWORD dGOBSize;
	DWORD dNormalBufferSize;

	extern U32 getRTPPacketSizeThreshold(U32);

	if (lParam1->biHeight == 288 && lParam1->biWidth == 352)
	{
		dNumberOfGOBs = 12;
		dNormalBufferSize = 32*1024;
	}
	else
	{
		dNumberOfGOBs = 3;
        dNormalBufferSize = 8 * 1024;
	}

	dEffectivePacketSize = getRTPPacketSizeThreshold(lpInst->Configuration.unPacketSize);
	if ( (lpInst->FrameRate > 0 ) && (lpInst->DataRate > 0) )
	{
		dTargetFrameSize = (DWORD) (lpInst->DataRate / lpInst->FrameRate);
        bTargetSizeOK = TRUE;
	}
	else
    {   
		bTargetSizeOK = FALSE;
	}
	
	if (bTargetSizeOK)
	{
		dGOBSize = dTargetFrameSize/dNumberOfGOBs;

		dNumberOfPacketsPerGOB = __max(1, dGOBSize/dEffectivePacketSize);
		dExtendedSize = ( dNumberOfPacketsPerGOB * dNumberOfGOBs * sizeof(T_RTP_H261_BSINFO) +
			             sizeof(T_H26X_RTP_BSINFO_TRAILER) ) * 2;
		
	}
	else

		dExtendedSize = dNormalBufferSize; 

	return (dExtendedSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cdialogs.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * cdialog.h
 *
 * DESCRIPTION:
 *		Interface to the dialog functions.
 *
 */

// $Header:   S:\h26x\src\common\cdialogs.h_v   1.11   05 Feb 1997 12:14:20   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdialogs.h_v  $
;// 
;//    Rev 1.11   05 Feb 1997 12:14:20   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.10   16 Dec 1996 17:36:24   JMCVEIGH
;// Added custom messages for H.263+ options.
;// 
;//    Rev 1.9   11 Dec 1996 14:54:42   JMCVEIGH
;// Prototypes for setting/getting in-the-loop deblocking filter and
;// true B-frame modes.
;// 
;//    Rev 1.8   13 Nov 1996 00:33:30   BECHOLS
;// Removed registry stuff.
;// 
;//    Rev 1.7   16 Oct 1996 15:09:28   SCDAY
;// Added support for RTP AM interface
;// 
;//    Rev 1.6   10 Sep 1996 16:13:02   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.5   10 Jul 1996 08:26:38   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.4   22 May 1996 18:46:54   BECHOLS
;// 
;// Added CustomResetToFactoryDefaults.
;// 
;//    Rev 1.3   06 May 1996 00:41:20   BECHOLS
;// 
;// Added bit rate control stuff for the configure dialog.
;// 
;//    Rev 1.2   26 Apr 1996 11:08:58   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.1   17 Oct 1995 15:07:10   DBRUCKS
;// add about box files
;//
;// Added declarations to support Encoder Control messages.
;// Add Configure dialog
;// 

#ifndef __CDIALOG_H__
#define __CDIALOG_H__

#define DLG_DRIVERCONFIGURE         300

extern I32 About(HWND hwnd);
extern I32 DrvConfigure(HWND hwnd);

extern void GetConfigurationDefaults(T_CONFIGURATION * pConfiguration);

LRESULT CustomGetRTPHeaderState(LPCODINST, DWORD FAR *);
LRESULT CustomGetResiliencyState(LPCODINST, DWORD FAR *);
LRESULT CustomGetBitRateState(LPCODINST, DWORD FAR *);
LRESULT CustomGetPacketSize(LPCODINST, DWORD FAR *);
LRESULT CustomGetPacketLoss(LPCODINST, DWORD FAR *);
LRESULT CustomGetBitRate(LPCODINST, DWORD FAR *);

LRESULT CustomSetRTPHeaderState(LPCODINST, DWORD);
LRESULT CustomSetResiliencyState(LPCODINST, DWORD);
LRESULT CustomSetBitRateState(LPCODINST, DWORD);
LRESULT CustomSetPacketSize(LPCODINST, DWORD);
LRESULT CustomSetPacketLoss(LPCODINST, DWORD);
LRESULT CustomSetBitRate(LPCODINST, DWORD);

#ifdef H263P
LRESULT CustomGetH263PlusState(LPCODINST, DWORD FAR *);
LRESULT CustomGetDeblockingFilterState(LPCODINST, DWORD FAR *);

LRESULT CustomSetH263PlusState(LPCODINST, DWORD);
LRESULT CustomSetDeblockingFilterState(LPCODINST, DWORD);
#endif // H263P

extern LRESULT CustomResetToFactoryDefaults(LPCODINST);

extern LRESULT CustomSetBlockEdgeFilter(LPDECINST, DWORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cdialogs.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#ifndef MF_SHELL
#ifndef RING0
extern HINSTANCE hDriverModule;
#endif
#endif

/*****************************************************************************
 *
 * cdialog.cpp
 *
 * DESCRIPTION:
 *		Dialog functions.
 *
 * Routines:					Prototypes in:
 *  About						cdialog.h
 *  DrvConfigure				cdialog.h			
 *  GetConfigurationDefaults	cdialogs.h
 */

// $Header:   S:\h26x\src\common\cdialogs.cpv   1.25   06 Mar 1997 14:48:58   KLILLEVO  $
// $Log:   S:\h26x\src\common\cdialogs.cpv  $
// 
//    Rev 1.25   06 Mar 1997 14:48:58   KLILLEVO
// Added check for valid pComp for release version.
// 
//    Rev 1.24   05 Mar 1997 16:17:10   JMCVEIGH
// No longer support configuration dialog box.
// 
//    Rev 1.23   13 Feb 1997 14:13:34   MBODART
// 
// Made Active Movie constant definitions consistent with those in cdialogs.
// 
//    Rev 1.22   12 Feb 1997 15:51:10   AGUPTA2
// Decreased minimum packet size allowed to 64.
// 
//    Rev 1.21   05 Feb 1997 12:13:58   JMCVEIGH
// Support for improved PB-frames custom message handling.
// 
//    Rev 1.20   16 Dec 1996 17:37:28   JMCVEIGH
// Setting/getting of H.263+ optional mode states.
// 
//    Rev 1.19   11 Dec 1996 14:55:26   JMCVEIGH
// 
// Functions for setting/getting in-the-loop deblocking filter and
// true B-frame mode states.
// 
//    Rev 1.18   04 Dec 1996 14:38:18   RHAZRA
// Fixed a couple of bugs: (1) SetResiliencyParameters was never called when
// an application sent a custom message to us turning on resiliency and
// (ii) in ReadDialogBox() the resiliency parameters were being set from
// the defaults rather than the values set by the user.
// 
// Upon Chad's suggestion, I have decided NOT to tie RTP header generation
// and resiliency as per discussion with Ben. This is to stay compliant with
// existing applications such as AV phone and XnetMM that haven't gone to
// ActiveMovie yet.
// 
//    Rev 1.17   25 Nov 1996 09:12:40   BECHOLS
// Bumped packet size to 9600.
// 
//    Rev 1.16   13 Nov 1996 00:33:50   BECHOLS
// 
// Removed registry persistance.
// 
//    Rev 1.15   31 Oct 1996 10:12:46   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.14   21 Oct 1996 10:50:08   RHAZRA
// fixed a problem with H.261 initialization of RTP BS info call
// 
//    Rev 1.13   16 Sep 1996 16:38:46   CZHU
// Extended the minimum packet size to 128 bytes. Fixed buffer overflow bug
// 
//    Rev 1.12   10 Sep 1996 16:13:00   KLILLEVO
// added custom message in decoder to turn block edge filter on or off
// 
//    Rev 1.11   29 Aug 1996 09:27:18   CZHU
// Simplified handling of packet loss settings.
// 
//    Rev 1.10   26 Aug 1996 13:38:18   BECHOLS
// Fixed 2 bugs: The first was where if -1 was entered, it would be changed
// to (unsigned) -1, both of which are illegal values.  The second is where
// if an invalid value is entered, and the checkbox is unchecked, the user
// would be required to check the box, enter a valid value, and then uncheck
// the checkbox.  The fixed code notifies the user of the problem if the box
// is checked, and fills in the previous good value.  If the box is unchecked
// it fills in the previous good value, and doesn't notify the user, since
// the value being unchecked is of no concern to the user.
// Finally, I added an IFDEF H261 to the Key path assignment so that H261
// would use a separate Registry Entry.
// 
//    Rev 1.9   21 Aug 1996 18:53:42   RHAZRA
// 
// Added #ifdef s to accomodate both H.261 and H.263 in RTP related
// tasks.
// 
//    Rev 1.7   13 Jun 1996 14:23:36   CZHU
// Fix bugs in custom message handing for RTP related tasks.
// 
//    Rev 1.6   22 May 1996 18:46:02   BECHOLS
// Added CustomResetToFactoryDefaults.
// 
//    Rev 1.5   08 May 1996 10:06:42   BECHOLS
// 
// Changed the checking of the Packet size raising the minimum acceptable to 
// 256 vs. 64.  This will hopefully kludge around a known bug.  I also fixed a
// by preventing field overflow on the numerics.
// 
//    Rev 1.4   06 May 1996 12:53:56   BECHOLS
// Changed the bits per second to bytes per second.
// 
//    Rev 1.3   06 May 1996 00:40:04   BECHOLS
// 
// Added code to support the bit rate control stuff in the resource file.
// I also added the code necessary to handle messages to control the new
// dialog features.
// 
//    Rev 1.2   28 Apr 1996 20:24:54   BECHOLS
// 
// Merged RTP code into the Main Base.
// 
//    Rev 1.1   17 Nov 1995 14:50:54   BECHOLS
// Made modifications to make this file as a mini-filter.  The flags
// RING0 and MF_SHELL were added.
// 
//    Rev 1.0   17 Oct 1995 15:07:22   DBRUCKS
// add about box files
// 
// Added code to process Custom messages, and also code to differentiate
//  between different values for packet loss, and set the defaults for no
//  RTP header or resiliency.
// Modified RTP dialog box.
// Add Configure dialog
// 

static INT_PTR CALLBACK AboutDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

extern void SetResiliencyParams(T_CONFIGURATION * pConfiguration);

#define VALID_BOOLEAN(v) (v == 0 || v == 1)
#if defined(H261)
#define VALID_PACKET_SIZE(v) ((v) >= 128 && (v) <= 9600)
#else
#define VALID_PACKET_SIZE(v) ((v) >= 64 && (v) <= 9600)
#endif
#define VALID_PACKET_LOSS(v) (v >= 0 && v <= 100)
#define VALID_BITRATE(v) (v >= 1024 && v <= 13312)

/**************************************************************************
 * CustomGetRTPHeaderState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bRTPHeader.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetRTPHeaderState(LPCODINST pComp, DWORD FAR *pRTPHeaderState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pRTPHeaderState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetRTPHeaderState;
   }
   if(pComp && pRTPHeaderState)
   {
      *pRTPHeaderState = (DWORD)pComp->Configuration.bRTPHeader;
      lRet = ICERR_OK;
   }

EXIT_GetRTPHeaderState:
   return(lRet);
}

/**************************************************************************
 * CustomGetResiliencyState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bEncoderResiliency.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetResiliencyState(LPCODINST pComp, DWORD FAR *pResiliencyState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pResiliencyState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetResiliencyState;
   }
   if(pComp && pResiliencyState)
   {
      *pResiliencyState = (DWORD)pComp->Configuration.bEncoderResiliency;
      lRet = ICERR_OK;
   }

EXIT_GetResiliencyState:
   return(lRet);
}

/**************************************************************************
 * CustomGetBitRateState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bBitRateState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetBitRateState(LPCODINST pComp, DWORD FAR *pBitRateState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pBitRateState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetBitRateState;
   }
   if(pComp && pBitRateState)
   {
      *pBitRateState = (DWORD)pComp->Configuration.bBitRateState;
      lRet = ICERR_OK;
   }

EXIT_GetBitRateState:
   return(lRet);
}

/**************************************************************************
 * CustomGetPacketSize() is called from CDRVPROC.CPP.
 *
 * Returns the Packet Size.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetPacketSize(LPCODINST pComp, DWORD FAR *pPacketSize)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pPacketSize);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetPacketSize;
   }
   if(pComp && pPacketSize)
   {
      *pPacketSize = (DWORD)pComp->Configuration.unPacketSize;
      lRet = ICERR_OK;
   }

EXIT_GetPacketSize:
   return(lRet);
}

/**************************************************************************
 * CustomGetPacketLoss() is called from CDRVPROC.CPP.
 *
 * Returns the Packet Loss.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetPacketLoss(LPCODINST pComp, DWORD FAR *pPacketLoss)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pPacketLoss);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetPacketLoss;
   }
   if(pComp && pPacketLoss)
   {
      *pPacketLoss = (DWORD)pComp->Configuration.unPacketLoss;
      lRet = ICERR_OK;
   }

EXIT_GetPacketLoss:
   return(lRet);
}

/**************************************************************************
 * CustomGetBitRate() is called from CDRVPROC.CPP.
 *
 * Returns the Bit Rate in bytes per second.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetBitRate(LPCODINST pComp, DWORD FAR *pBitRate)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pBitRate);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetBitRate;
   }
   if(pComp && pBitRate)
   {
      *pBitRate = (DWORD)pComp->Configuration.unBytesPerSecond;
      lRet = ICERR_OK;
   }

EXIT_GetBitRate:
   return(lRet);
}

#ifdef H263P
/**************************************************************************
 * CustomGetH263PlusState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bH263Plus
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetH263PlusState(LPCODINST pComp, DWORD FAR *pH263PlusState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pH263PlusState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetH263PlusState;
   }
   if(pComp && pH263PlusState)
   {
      *pH263PlusState = (DWORD)pComp->Configuration.bH263PlusState;
      lRet = ICERR_OK;
   }

EXIT_GetH263PlusState:
   return(lRet);
}

/**************************************************************************
 * CustomGetImprovedPBState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bImprovedPBState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetImprovedPBState(LPCODINST pComp, DWORD FAR *pImprovedPBState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pImprovedPBState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetImprovedPBState;
   }
   if(pComp && pImprovedPBState)
   {
      *pImprovedPBState = (DWORD)pComp->Configuration.bImprovedPBState;
      lRet = ICERR_OK;
   }

EXIT_GetImprovedPBState:
   return(lRet);
}

/**************************************************************************
 * CustomGetDeblockingFilterState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bDeblockingFilterState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetDeblockingFilterState(LPCODINST pComp, DWORD FAR *pDeblockingFilterState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pDeblockingFilterState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetDeblockingFilterState;
   }
   if(pComp && pDeblockingFilterState)
   {
      *pDeblockingFilterState = (DWORD)pComp->Configuration.bDeblockingFilterState;
      lRet = ICERR_OK;
   }

EXIT_GetDeblockingFilterState:
   return(lRet);
}

#endif // H263P

/**************************************************************************
 * CustomSetRTPHeaderState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bRTPHeader.
 *
 * Returns ICERR_BADPARAM if pComp is zero or RTPHeaderState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetRTPHeaderState(LPCODINST pComp, DWORD RTPHeaderState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)RTPHeaderState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetRTPHeaderState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
    T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    LPVOID         EncoderInst;
  
    EncoderInst = pComp->hEncoderInst;
    if (EncoderInst == NULL)
    {
        DBOUT("ERROR :: H26XCompress :: ICERR_MEMORY");
        lRet = ICERR_MEMORY;
        goto  EXIT_SetRTPHeaderState;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/

#ifndef H261
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#else
   P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) pComp->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#endif
    EC = &(P32Inst->EC);

    // Get pointer to encoder catalog.
  
   	if (!pComp->Configuration.bRTPHeader && bState)
	{ 
#ifndef H261    
	   H263RTP_InitBsInfoStream(pComp,EC);
#else
       H261RTP_InitBsInfoStream(EC,pComp->Configuration.unPacketSize);
#endif
    }
   	if (pComp->Configuration.bRTPHeader && !bState)
	{ 
#ifndef H261
	   H263RTP_TermBsInfoStream(EC);
#else
       H261RTP_TermBsInfoStream(EC);
#endif

	}

    pComp->Configuration.bRTPHeader = bState;
    lRet = ICERR_OK;
   }

EXIT_SetRTPHeaderState:
   return(lRet);
}

/**************************************************************************
 * CustomSetResiliencyState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bEncoderResiliency.
 *
 * Returns ICERR_BADPARAM if pComp is zero or ResiliencyState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetResiliencyState(LPCODINST pComp, DWORD ResiliencyState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)ResiliencyState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetResiliencyState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bEncoderResiliency = bState;
	  SetResiliencyParams(&(pComp->Configuration));
      lRet = ICERR_OK;
   }

EXIT_SetResiliencyState:
   return(lRet);
}

/**************************************************************************
 * CustomSetBitRateState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bBitRateState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRateState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetBitRateState(LPCODINST pComp, DWORD BitRateState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)BitRateState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetBitRateState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bBitRateState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetBitRateState:
   return(lRet);
}

/**************************************************************************
 * CustomSetPacketSize() is called from CDRVPROC.CPP.
 *
 * Sets the size of ->unPacketSize.
 *
 * Returns ICERR_BADPARAM if pComp is zero or PacketSize is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetPacketSize(LPCODINST pComp, DWORD PacketSize)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unSize;

   unSize = (UINT)PacketSize;
   ASSERT(pComp);
   ASSERT(VALID_PACKET_SIZE(unSize));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetPacketSize;
   }
   if(pComp && VALID_PACKET_SIZE(unSize))
   {
   	T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    LPVOID         EncoderInst;
  
    EncoderInst = pComp->hEncoderInst;
    if (EncoderInst == NULL)
    {
        DBOUT("ERROR :: H26XCompress :: ICERR_MEMORY");
        lRet = ICERR_MEMORY;
        goto  EXIT_SetPacketSize;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/
#ifndef H261
  	P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#else
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) pComp->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#endif
    // Get pointer to encoder catalog.
    EC = &(P32Inst->EC);
  
   	if (!pComp->Configuration.bRTPHeader)
	{   lRet = ICERR_ERROR;
        goto  EXIT_SetPacketSize;
    }
 
	if (pComp->Configuration.unPacketSize != unSize )
	{
#ifndef H261
		H263RTP_TermBsInfoStream(EC);
#else
        H261RTP_TermBsInfoStream(EC);
#endif
		pComp->Configuration.unPacketSize = unSize;
#ifndef H261
        H263RTP_InitBsInfoStream(pComp,EC);
#else
        H261RTP_InitBsInfoStream(EC,pComp->Configuration.unPacketSize);
#endif
	}

    lRet = ICERR_OK;
   }

EXIT_SetPacketSize:
   return(lRet);
}

/**************************************************************************
 * CustomSetPacketLoss() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unPacketLoss.
 *
 * Returns ICERR_BADPARAM if pComp is zero or PacketLoss is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetPacketLoss(LPCODINST pComp, DWORD PacketLoss)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unLoss;

   unLoss = (UINT)PacketLoss;
   ASSERT(pComp);
//   ASSERT(VALID_PACKET_LOSS(unLoss)); Always True
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetPacketLoss;
   }
   if(pComp) // && VALID_PACKET_LOSS(unLoss)) Always True
   {
      pComp->Configuration.unPacketLoss = unLoss;
	  SetResiliencyParams(&(pComp->Configuration));
      lRet = ICERR_OK;
   }

EXIT_SetPacketLoss:
   return(lRet);
}

/**************************************************************************
 * CustomSetBitRate() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unBytesPerSecond.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRate is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetBitRate(LPCODINST pComp, DWORD BitRate)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unBitRate;

   unBitRate = (UINT)BitRate;
   ASSERT(pComp);
   ASSERT(VALID_BITRATE(unBitRate));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetBitRate;
   }
   if(pComp && VALID_BITRATE(unBitRate))
   {
      pComp->Configuration.unBytesPerSecond = unBitRate;
      lRet = ICERR_OK;
   }

EXIT_SetBitRate:
   return(lRet);
}

#ifdef H263P
/**************************************************************************
 * CustomSetH263PlusState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bH263PlusState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or H263PlusState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetH263PlusState(LPCODINST pComp, DWORD H263PlusState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)H263PlusState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetH263PlusState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bH263PlusState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetH263PlusState:
   return(lRet);
}

/**************************************************************************
 * CustomSetImprovedPBState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bImprovedPBState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or ImprovedPB is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetImprovedPBState(LPCODINST pComp, DWORD ImprovedPBState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;
   BOOL bH263PlusState;

   bState = (BOOL)ImprovedPBState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   // ->bH263PlusState must be TRUE
   if(pComp && (pComp->Configuration.bInitialized == FALSE) ||
	  (CustomGetH263PlusState(pComp, (DWORD FAR *)&bH263PlusState) != ICERR_OK) ||
	  (bH263PlusState == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetImprovedPBState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bImprovedPBState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetImprovedPBState:
   return(lRet);
}

/**************************************************************************
 * CustomSetDeblockingFilterState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bDeblockingFilterState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or DeblockingFilter is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetDeblockingFilterState(LPCODINST pComp, DWORD DeblockingFilterState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;
   BOOL bH263PlusState;

   bState = (BOOL)DeblockingFilterState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   // ->bH263PlusState must be TRUE
   if(pComp && (pComp->Configuration.bInitialized == FALSE) ||
	  (CustomGetH263PlusState(pComp, (DWORD FAR *)&bH263PlusState) != ICERR_OK) ||
	  (bH263PlusState == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetDeblockingFilterState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bDeblockingFilterState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetDeblockingFilterState:
   return(lRet);
}
#endif // H263P

/**************************************************************************
 * CustomResetToFactoryDefaults() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unBytesPerSecond.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRate is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomResetToFactoryDefaults(LPCODINST pComp)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);

   if(pComp)
   {
      GetConfigurationDefaults(&pComp->Configuration); /* Overwrite the configuration data */
      lRet = ICERR_OK;
   }

   return(lRet);
}

/**************************************************************************
 * CustomSetBlockEdgeFilter() is called from CDRVPROC.CPP.
 *
 * Turns block edge filter on or off.
 *
 * Returns ICERR_OK if successfull, ICERR_BADPARAM otherwise 
 */
LRESULT CustomSetBlockEdgeFilter(LPDECINST pDeComp, DWORD dwValue)
{
	LRESULT lRet = ICERR_BADPARAM;

	if (dwValue == 1) {
		pDeComp->bUseBlockEdgeFilter = 1;
		lRet = ICERR_OK;
	}
	else if (dwValue == 0) {
		pDeComp->bUseBlockEdgeFilter = 0;
		lRet = ICERR_OK;
	}
	return(lRet);
}

/**************************************************************************
 *
 * About() implements the ICM_ABOUT message.
 *
 * Puts up an about box.
 *
 */
I32 
About(
	HWND hwnd)
{
    int inResult = 0;
    I32 iStatus = ICERR_OK;
#ifndef MF_SHELL
#ifndef RING0
    
    if (hwnd != ((HWND)-1))
    {
        inResult = DialogBox(hDriverModule, "AboutDlg", hwnd, AboutDialogProc);
		if (inResult == -1) 
		{
			iStatus = ICERR_ERROR;
			DBOUT("\n DialogBox returned -1");
		}
    }
#endif
#endif
    return iStatus;
} /* end About() */

#ifdef QUARTZ
 void QTZAbout(U32 uData)
 {
	 About((HWND) uData);
 }
#endif

/**************************************************************************
 *
 * DrvConfigure() is called from the DRV_CONFIGURE message.
 *
 * Puts up an about box.
 *
 * Always returns DRV_CANCEL as nothing has changed and no action is required. 
 */
I32 DrvConfigure(
	HWND hwnd)
{  
	I32 iStatus = DRV_CANCEL;
#ifndef MF_SHELL
#ifndef RING0
	int inResult;

    inResult = DialogBox(hDriverModule, "SetupDlg", hwnd, AboutDialogProc);
	if (inResult == -1) 
	{
		DBOUT("\n DialogBox returned -1");
	}
#endif
#endif

    return iStatus;
} /* end DrvConfigure() */

/************************************************************************
 *
 * SetResiliencyParams
 *
 * If ->bEncoderResiliency is TRUE, then set the configuration
 * parameters according to the expected packet loss.
 */
extern void SetResiliencyParams(T_CONFIGURATION * pConfiguration)
{
   if (pConfiguration->bEncoderResiliency)
   {
      if(pConfiguration->unPacketLoss > 30)
      {	pConfiguration->bDisallowPosVerMVs = 1;
        pConfiguration->bDisallowAllVerMVs = 1;
        pConfiguration->unPercentForcedUpdate = 100; // rather severe eh Jeeves ?
        pConfiguration->unDefaultIntraQuant = 8;
        pConfiguration->unDefaultInterQuant = 16;
      }
      else if(pConfiguration->unPacketLoss > 0 )
      {	 
		pConfiguration->bDisallowPosVerMVs = 0;
        pConfiguration->bDisallowAllVerMVs = 0;
        pConfiguration->unPercentForcedUpdate = pConfiguration->unPacketLoss;
        pConfiguration->unDefaultIntraQuant = 16;
        pConfiguration->unDefaultInterQuant = 16;
      }
	  else // no packet loss
	  {	pConfiguration->bDisallowPosVerMVs = 0;
        pConfiguration->bDisallowAllVerMVs = 0;
        pConfiguration->unPercentForcedUpdate = 0;
        pConfiguration->unDefaultIntraQuant = 16;
        pConfiguration->unDefaultInterQuant = 16;
      }
   }

   return;
}

/************************************************************************
 *
 * GetConfigurationDefaults
 *
 * Get the hard-coded configuration defaults
 */
void GetConfigurationDefaults(
	T_CONFIGURATION * pConfiguration)
{
   pConfiguration->bRTPHeader = 0;
   pConfiguration->unPacketSize = 512L;
   pConfiguration->bEncoderResiliency = 0;
   //Moji says to tune the encoder for 10% packet loss.
   pConfiguration->unPacketLoss = 10L;
   pConfiguration->bBitRateState = 0;
   pConfiguration->unBytesPerSecond = 1664L;
   SetResiliencyParams(pConfiguration);  // Determine config values from packet loss.
   pConfiguration->bInitialized = TRUE;

#ifdef H263P
   pConfiguration->bH263PlusState = 0;
   pConfiguration->bImprovedPBState = 0;
   pConfiguration->bDeblockingFilterState = 0;
#endif 

} /* end GetConfigurationDefaults() */

/**************************************************************************
 *
 *  AboutDialogProc
 *
 *  Display the about box.
 */
static INT_PTR CALLBACK AboutDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
#ifndef MF_SHELL
#ifndef RING0
    switch(message) {
      case WM_INITDIALOG:
		return TRUE;
		break;

      case WM_CLOSE:
        PostMessage(hDlg, WM_COMMAND, IDOK, 0L);
        return TRUE;
		
      case WM_COMMAND:
		switch(wParam) {
		  case IDOK:
			EndDialog(hDlg, TRUE);
			return TRUE;
		}
		
    }
    return FALSE;
#else
   return TRUE;
#endif
#else
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\ccustmsg.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
////////////////////////////////////////////////////////////////////////////
//
// $Author:   KLILLEVO  $
// $Date:   10 Sep 1996 16:13:10  $
// $Archive:   S:\h26x\src\common\ccustmsg.h_v  $
// $Header:   S:\h26x\src\common\ccustmsg.h_v   1.10   10 Sep 1996 16:13:10   KLILLEVO  $
//	$Log:   S:\h26x\src\common\ccustmsg.h_v  $
;// 
;//    Rev 1.10   10 Sep 1996 16:13:10   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.9   22 Jul 1996 14:46:16   BECHOLS
;// 
;// fixed last comment.
;// 
;//    Rev 1.8   22 Jul 1996 14:38:08   BECHOLS
;// 
;// Wrapped the comment section with /* ... */ /* so that Steve Ing won't
;// be hassled with changing this.
;// 
;//    Rev 1.7   22 May 1996 18:47:32   BECHOLS
;// 
;// Added EC_RESET_TO_FACTORY_DEFAULTS.
;// 
;//    Rev 1.6   28 Apr 1996 17:48:04   BECHOLS
;// Added CODEC_CUSTOM_ENCODER_CONTROL.
;// 
;//    Rev 1.5   04 Jan 1996 10:09:16   TRGARDOS
;// Added bit flag to signal still image.
;// 
;//    Rev 1.4   27 Dec 1995 14:11:52   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.3   18 Dec 1995 13:49:06   TRGARDOS
// Added bit flags for H.263 options.
// 
//    Rev 1.2   01 Dec 1995 12:37:12   TRGARDOS
// Added defines for h.263 options.
// 
//    Rev 1.1   25 Oct 1995 20:12:42   TRGARDOS
// Added bit field mask for bitrate controller.
// 
//    Rev 1.0   31 Jul 1995 12:55:18   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:43:54   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:18   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
//
//  CODECUST.H include file for use with the Indeo codec.
//
//  This file defines custom messages that the driver recognizes.
//
//  Copyright 1994 - Intel Corporation
//
// ---------------------------------------------------------------------
*/

//  DRV_USER is defined in windows.h and mmsystem.h as 0x4000
#define ICM_RESERVED_HIGH			(DRV_USER+0x2000)
#define CUSTOM_START				(ICM_RESERVED_HIGH+1)

// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// CODEC_CUSTOM_VIDEO_EFFECTS:
//    This message is used to control custom video effects, most of
//    which are common between the capture drivers and the codec drivers.
//
//    See drvcomon.h (Supplied and maintained by Video Manager team)
// --------------------------------------------------------------------- 

#define CODEC_CUSTOM_VIDEO_EFFECTS      (CUSTOM_START+ 8)
#define CODEC_CUSTOM_ENCODER_CONTROL    (CUSTOM_START+ 9)
#define APPLICATION_IDENTIFICATION_CODE (CUSTOM_START+10)
#define CODEC_CUSTOM_DECODER_CONTROL    (CUSTOM_START+11)
#define CUSTOM_ENABLE_CODEC				(CUSTOM_START+200)

#define CODEC_CUSTOM_RATE_CONTROL	     0x10000
#define CODEC_CUSTOM_PB		 		     0x20000
#define CODEC_CUSTOM_AP				     0x40000
#define CODEC_CUSTOM_UMV			     0x80000
#define CODEC_CUSTOM_SAC			    0x100000
#define CODEC_CUSTOM_STILL              0x200000

#define	G723MAGICWORD1					0xf7329ace
#define	G723MAGICWORD2					0xacdeaea2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cdrvbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   31 Oct 1996 10:12:46  $
// $Archive:   S:\h26x\src\common\cdrvbase.cpv  $
// $Header:   S:\h26x\src\common\cdrvbase.cpv   1.25   31 Oct 1996 10:12:46   KLILLEVO  $
//	$Log:   S:\h26x\src\common\cdrvbase.cpv  $
// 
//    Rev 1.25   31 Oct 1996 10:12:46   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.24   04 Oct 1996 16:11:54   JMCVEIGH
// In DrvOpen(), DecompPtr is now allocated if dwFlags indicate
// ICMODE_DECOMPRESS *and* ICMODE_COMPRESS. After installing the ClearVideo
// encoder, Adobe's Premiere would crash when compressing with the off-line.
// Crash was due to accessing an unallocated version of DecompPtr.
// Raj believes ClearVideo installed DCI. Possible penalty of this fix
// is that we might allocate a decoder instance that is never used.
// 
//    Rev 1.23   26 Sep 1996 14:46:48   MBODART
// Simplified version number definitions.
// Bumped H.261 major version number to 4, reset build number to 001.
// 
//    Rev 1.22   12 Sep 1996 13:54:06   KLILLEVO
// changed to Win32 memory allocation
// 
//    Rev 1.21   03 Sep 1996 16:17:58   PLUSARDI
// updated for version 2.50 of 263 net 
// 
//    Rev 1.20   23 Aug 1996 13:44:56   SCDAY
// added version numbers for Quartz using #ifdef QUARTZ
// 
//    Rev 1.19   22 Aug 1996 10:17:14   PLUSARDI
// updated for quartz version 3.05 for h261
// 
//    Rev 1.18   16 Aug 1996 11:31:28   CPERGIEX
// updated not non-quartz build
// 
//    Rev 1.17   30 Jul 1996 12:57:22   PLUSARDI
// updated for RTP version string
// 
//    Rev 1.16   11 Jul 1996 07:54:18   PLUSARDI
// change the version number for h261 v3.05.003
// 
//    Rev 1.15   12 Jun 1996 09:47:22   KLILLEVO
// updated version number
// 
//    Rev 1.14   28 Apr 1996 20:25:36   BECHOLS
// 
// Merged the RTP code into the Main Base.
// 
//    Rev 1.13   21 Feb 1996 11:40:58   SCDAY
// cleaned up compiler build warnings by putting ifdefs around definition of b
// 
//    Rev 1.12   02 Feb 1996 18:52:22   TRGARDOS
// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
// 
//    Rev 1.11   27 Dec 1995 14:11:36   RMCKENZX
// 
// Added copyright notice
// 
//    Rev 1.10   13 Dec 1995 13:21:52   DBRUCKS
// changed the h261 version string defintions to use V3.00
// 
//    Rev 1.9   01 Dec 1995 15:16:34   DBRUCKS
// added VIDCF_QUALITY to support the quality slider.
// 
//    Rev 1.8   15 Nov 1995 15:58:56   AKASAI
// Remove YVU9 from get info and return error "0" when unsupported.
// (Integration point)
// 
//    Rev 1.7   09 Oct 1995 11:46:56   TRGARDOS
// 
// Set VIDCF_CRUNCH flag to support bit rate control.
// 
//    Rev 1.6   20 Sep 1995 12:37:38   DBRUCKS
// save the fcc in uppercase
// 
//    Rev 1.5   19 Sep 1995 15:41:00   TRGARDOS
// Fixed four cc comparison code.
// 
//    Rev 1.4   19 Sep 1995 13:19:50   TRGARDOS
// Changed drv_open to check ICOPEN flags.
// 
//    Rev 1.3   12 Sep 1995 15:45:38   DBRUCKS
// add H261 ifdef to desc and name
// 
//    Rev 1.2   25 Aug 1995 11:53:00   TRGARDOS
// Debugging key frame encoder.
// 
//    Rev 1.1   23 Aug 1995 12:27:16   DBRUCKS
// 
// turn on color converter init
// 
//    Rev 1.0   31 Jul 1995 12:56:10   DBRUCKS
// rename files
// 
//    Rev 1.1   21 Jul 1995 18:20:36   DBRUCKS
// IsBadReadPtr fails with a NULL - protect against
// 
//    Rev 1.0   17 Jul 1995 14:43:58   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:28   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef H261
	#ifdef QUARTZ
		char    szDescription[] = "Microsoft H.261 Video Codec";
		char    szDesc_i420[] = "Intel 4:2:0 Video V3.05";
		char    szName[]        = "MS H.261";
	#else
		char    szDescription[] = "Microsoft H.261 Video Codec";
		char    szDesc_i420[] = "Intel 4:2:0 Video V3.00";
		char    szName[]        = "MS H.261";
	#endif
#else // is H263
	#ifdef QUARTZ
                char    szDescription[] = "Microsoft H.263 Video Codec";
                char    szDesc_i420[] = "Intel 4:2:0 Video V2.55";
                char    szName[]        = "MS H.263";
	#else
                char    szDescription[] = "Microsoft H.263 Video Codec";
                char    szDesc_i420[] = "Intel 4:2:0 Video V2.50";
                char    szName[]        = "MS H.263";
	#endif
#endif

static U32 MakeFccUpperCase(U32 fcc);

void MakeCode32(U16 selCode16)
{
    BYTE    desc[8];

#define DSC_DEFAULT     0x40
#define dsc_access      6

    GlobalReAlloc((HGLOBAL)selCode16, 0, GMEM_MODIFY|GMEM_MOVEABLE);

    _asm
    {
        mov     bx, selCode16       ; bx = selector

        lea     di, word ptr desc   ; ES:DI --> desciptor
        mov     ax,ss
        mov     es,ax

        mov     ax, 000Bh           ; DPMI get descriptor
        int     31h

        ; set DEFAULT bit to make it a 32-bit code segment
        or      desc.dsc_access,DSC_DEFAULT

        mov     ax,000Ch            ; DPMI set descriptor
        int     31h
    }
}

/******************************************************
 * DrvLoad()
 ******************************************************/
BOOL PASCAL DrvLoad(void)
{
    static int AlreadyInitialised = 0;

    if (!AlreadyInitialised) {
      AlreadyInitialised = 1;

//      H263InitDecoderGlobal();
      H263InitColorConvertorGlobal ();
      H263InitEncoderGlobal();

    }
    return TRUE;
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       void PASCAL DrvFree(void);
;//
;// Description:    Added header.
;//
;// History:        02/23/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
void PASCAL DrvFree(void)
{
    return;
}

/**********************************************************
 * DrvOpen()
 * Arguments:
 * 	Pointer to ICOPEN data structure passed by
 *	the system.
 * Returns:
 *  If successful, returns a pointer to our INSTINFO data structure. That
 *  will be passed back to us in the dwDriverID parameter on subsequent
 *  system calls.
 *  If unsuccessful, it returns NULL.
 **********************************************************/
LPINST PASCAL DrvOpen(ICOPEN FAR * icinfo)
{
    INSTINFO  *lpInst;
#ifdef _DEBUG
	char buf80[80];
#endif

    // Allocate memory for our instance information structure, INSTINFO.
    if((lpInst = (INSTINFO *) HeapAlloc(GetProcessHeap(), 0, sizeof(INSTINFO))) == NULL){
      DBOUT("DrvOpen: Unable to ALLOC INSTINFO")
      return NULL;
    }

    /*
	 * Store the four cc so we know which codec is open.
	 * TODO: handle both lower case and upper case fourcc's.
	 */
    lpInst->fccHandler = MakeFccUpperCase(icinfo->fccHandler);
#ifdef _DEBUG
	wsprintf(buf80,"fccHandler=0x%lx",lpInst->fccHandler);
	DBOUT(buf80);
#endif

    lpInst->CompPtr = NULL;
	lpInst->DecompPtr = NULL;

	// Check if being opened for decompression.
    if ( ((icinfo->dwFlags & ICMODE_DECOMPRESS) == ICMODE_DECOMPRESS) ||
		((icinfo->dwFlags & ICMODE_FASTDECOMPRESS) == ICMODE_FASTDECOMPRESS) ){

	  	// Allocate memory for our decompressor specific instance data, DECINSTINFO.
      	if((lpInst->DecompPtr = (DECINSTINFO *) 
				HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DECINSTINFO))) == NULL){
        	DBOUT("DrvOpen: Unable to ALLOC DECINSTINFO")
        	HeapFree(GetProcessHeap(),0,lpInst);
        	return NULL;
      	}

	  	// Set flag indicating decoder instance is unitialized.
      	lpInst->DecompPtr->Initialized = FALSE;
	} 


	// Check if being opened for compression as H.263.
    if( (((icinfo->dwFlags & ICMODE_COMPRESS) == ICMODE_COMPRESS) ||
		((icinfo->dwFlags & ICMODE_FASTCOMPRESS) == ICMODE_FASTCOMPRESS)) &&
        (lpInst->fccHandler == FOURCC_H263) )
        {

		// Allocate memory for our compressor specific instance data, COMPINSTINFO.
      	if((lpInst->CompPtr = (COMPINSTINFO*) 
				HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(COMPINSTINFO))) == NULL){
        	DBOUT("DrvOpen: Unable to ALLOC COMPINSTINFO")
			if (lpInst->DecompPtr != NULL)
        		HeapFree(GetProcessHeap(),0,lpInst->DecompPtr);
        	HeapFree(GetProcessHeap(),0,lpInst);
        	return NULL;
      	}

	  	// Set flag indicating encoder instance is uninitialized.
      	lpInst->CompPtr->Initialized = FALSE;
		lpInst->CompPtr->FrameRate = (float) 0;
		lpInst->CompPtr->DataRate = 0;
#if 0
	  	// Allocate memory for our decompressor specific instance data, DECINSTINFO.
		// Previously we didn't force this - assumed application specified 
		// decompressor needed to be allocated in dwFlags.
		// After installing ClearVideo encoder, Adobe Premiere crashed using off-line without this code.
		// Put same work around here (DECINSTINFO is fairly small)
		// Might be due to installation of DCI? JM
		if (lpInst->DecompPtr == NULL) {
      		if((lpInst->DecompPtr = (DECINSTINFO *) 
					HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DECINSTINFO))) == NULL){
        		DBOUT("DrvOpen: Unable to ALLOC DECINSTINFO")
       			HeapFree(GetProcessHeap(),0,lpInst);
       			return NULL;
    		}

	  		// Set flag indicating decoder instance is unitialized.
      		lpInst->DecompPtr->Initialized = FALSE;
		} 
#endif
	}

	// Assign instance info flag with ICOPEN flag.
    lpInst->dwFlags = icinfo->dwFlags;

	// Disable codec by default. The client will send us a private message
	// to enable it.
	lpInst->enabled = FALSE;

    return lpInst;
}

DWORD PASCAL DrvClose(LPINST lpInst)
{
    
    if(IsBadReadPtr((LPVOID)lpInst, sizeof(INSTINFO))){
      DBOUT("DrvClose: instance NULL")
      return 1;
    }

    if(lpInst->DecompPtr &&   // IsBadReadPtr errors on NT with NULL
       !IsBadReadPtr((LPVOID)lpInst->DecompPtr, sizeof(DECINSTINFO))){
      if(lpInst->DecompPtr->Initialized){
	    H263TermDecoderInstance(lpInst->DecompPtr);
      }
      HeapFree(GetProcessHeap(),0,lpInst->DecompPtr);
      lpInst->DecompPtr = NULL;
    }

    if(lpInst->CompPtr &&    // IsBadReadPtr errors on NT with NULL
       !IsBadReadPtr((LPVOID)lpInst->CompPtr, sizeof(COMPINSTINFO))){
      if(lpInst->CompPtr->Initialized){
	    H263TermEncoderInstance(lpInst->CompPtr);
      }
      HeapFree(GetProcessHeap(),0,lpInst->CompPtr);
      lpInst->CompPtr = NULL;
    }

    HeapFree(GetProcessHeap(),0,lpInst);
    
    return 1;
}


DWORD PASCAL DrvGetState(LPINST lpInst, LPVOID pv, DWORD dwSize)
{
    // Return current state of compression options
    if (pv == NULL) return (sizeof(COMPINSTINFO));
    
    // check that incoming buffer is big enough
    if (dwSize < sizeof(COMPINSTINFO)) return 0;

	// Check instance pointer
	if (lpInst && lpInst->CompPtr)
	{
		// fill the incoming buffer
		_fmemcpy(pv, lpInst->CompPtr, (int)sizeof(COMPINSTINFO));
		return sizeof(COMPINSTINFO);
	}
	else
		return 0;
}

DWORD PASCAL DrvSetState(LPINST lpInst, LPVOID pv, DWORD dwSize) 
{
    // check that there is enough incoming data
    if (dwSize < sizeof(COMPINSTINFO)) return 0;

	// Check instance pointer
	if (lpInst && lpInst->CompPtr && pv)
	{
		// get data out of incoming buffer
		_fmemcpy(lpInst->CompPtr, pv, (int)sizeof(COMPINSTINFO));
		return sizeof(COMPINSTINFO);
	}
	else
		return 0;
}

DWORD PASCAL DrvGetInfo(LPINST lpInst, ICINFO FAR *icinfo, DWORD dwSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    if (!lpInst)
        return 0;

    icinfo->dwSize	= sizeof(ICINFO);
    icinfo->fccType	= ICTYPE_VIDEO;
    icinfo->fccHandler	= lpInst->fccHandler;
    icinfo->dwVersion	= 9002;
	MultiByteToWideChar(CP_ACP,0,szName,-1,icinfo->szName,16);
		
    if(lpInst->fccHandler == FOURCC_H263)
	{
    	icinfo->dwFlags	=  VIDCF_TEMPORAL;		// We support inter frame compression.
    	icinfo->dwFlags |= VIDCF_FASTTEMPORALC; // We do not need ICM to provide previous frames on compress
    	icinfo->dwFlags |= VIDCF_CRUNCH; 		// We support bit rate control
		icinfo->dwFlags |= VIDCF_QUALITY; 		// We support Quality
		MultiByteToWideChar(CP_ACP,0,szDescription,-1,icinfo->szDescription,128);
	}
    else if ((lpInst->fccHandler == FOURCC_YUV12) || (lpInst->fccHandler == FOURCC_IYUV))
	{
    	icinfo->dwFlags	=  0;
		MultiByteToWideChar(CP_ACP,0,szDesc_i420,-1,icinfo->szDescription,128);
	}
	else
	{
		DBOUT("Error: unsupported four cc.")
		return(0);
	}

    return sizeof(ICINFO);
}


/**************************************************************************
 *
 * MakeFccUpperCase().
 *
 * Convert the passed parameter to upper case. No change to chars not in
 * the set [a..z].
 *
 * returns input parameter in all upper case
 */
static U32
MakeFccUpperCase(
	U32 fcc)
{
U32 ret;
	unsigned char c;

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret = toupper(c);

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret += toupper(c) << 8;

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret += ((U32)toupper(c)) << 16;

	c = (unsigned char)(fcc & 0xFF);
	ret += ((U32)toupper(c)) << 24;
	return ret;
} /* end MakeFccUpperCase() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cdrvdefs.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   JMCVEIGH  $
// $Date:   05 Feb 1997 12:14:24  $
// $Archive:   S:\h26x\src\common\cdrvdefs.h_v  $
// $Header:   S:\h26x\src\common\cdrvdefs.h_v   1.39   05 Feb 1997 12:14:24   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdrvdefs.h_v  $
;// 
;//    Rev 1.39   05 Feb 1997 12:14:24   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.38   14 Jan 1997 11:17:14   JMCVEIGH
;// Put flag for old still-frame mode backward compatibility under
;// #ifdef H263P
;// 
;//    Rev 1.37   06 Jan 1997 17:38:08   JMCVEIGH
;// Added flag in LPDECINST to ensure backward compatibility with
;// old still-frame mode (crop CIF image to 320x240).
;// 
;//    Rev 1.36   16 Dec 1996 17:37:00   JMCVEIGH
;// Added H263Plus state and changed name for true B-frame mode.
;// 
;//    Rev 1.35   16 Dec 1996 13:40:46   MDUDA
;// Added compression and bit width fields to compress info.
;// 
;//    Rev 1.34   11 Dec 1996 14:56:46   JMCVEIGH
;// 
;// Added H.263+ options to frame header structure and flags in
;// configuration structure.
;// 
;//    Rev 1.33   09 Dec 1996 17:43:10   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 
;//    Rev 1.32   09 Dec 1996 09:24:42   MDUDA
;// 
;// Re-arranged for H263P.
;// 
;//    Rev 1.31   10 Sep 1996 16:13:06   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.30   10 Sep 1996 10:32:10   KLILLEVO
;// changed GlobalAlloc/GlobalLock to HeapAlloc
;// 
;//    Rev 1.29   06 Sep 1996 15:00:20   MBODART
;// Added performance counters for NT's perfmon.
;// New files:  cxprf.cpp, cxprf.h and cxprf.cpp.
;// New directory:  src\perf
;// Updated files:  e1enc.{h,cpp}, d1dec.{h,cpp}, cdrvdefs.h, h261* makefiles.
;// 
;//    Rev 1.28   10 Jul 1996 08:26:38   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.27   19 Jun 1996 14:37:26   RHAZRA
;// added #define FOURCC_YUY2
;// 
;//    Rev 1.26   06 May 1996 12:56:34   BECHOLS
;// changed unbitspersecond to unBytesPerSecond.
;// 
;//    Rev 1.25   06 May 1996 00:42:36   BECHOLS
;// 
;// Added support for the bit rate control in the configure dialog.
;// 
;//    Rev 1.24   26 Apr 1996 11:09:18   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.23   02 Feb 1996 18:52:52   TRGARDOS
;// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
;// 
;//    Rev 1.22   19 Jan 1996 15:32:50   TRGARDOS
;// Added TRPrev field to PictureHeader structure.
;// 
;//    Rev 1.21   11 Jan 1996 16:52:24   DBRUCKS
;// added variables to store the aspect ratio correction boolean
;// 
;//    Rev 1.20   04 Jan 1996 18:07:54   TRGARDOS
;// Added boolean for 320x240 input into COMPINSTINFO.
;// 
;//    Rev 1.19   27 Dec 1995 14:11:54   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.18   06 Dec 1995 09:22:56   DBRUCKS
// 
// Added blazer data rate, frame rate, and quality variables to 
// COMPINSTINFO inside an H261 ifdef
// 
//    Rev 1.17   30 Oct 1995 12:02:12   TRGARDOS
// Modified compressor instance structure to add
// 240x180 support.
// 
//    Rev 1.16   27 Sep 1995 19:09:30   TRGARDOS
// Changed enumeration name for picture code type.
// 
//    Rev 1.15   20 Sep 1995 12:37:40   DBRUCKS
// save the fcc in uppercase
// 
//    Rev 1.14   19 Sep 1995 15:41:28   TRGARDOS
// Fixed four cc comparison code.
// 
//    Rev 1.13   18 Sep 1995 08:42:46   CZHU
// 
// Define FOURCC for YUV12
// 
//    Rev 1.12   13 Sep 1995 17:08:26   TRGARDOS
// Finished adding encoder support for YVU9 160x120 frames.
// 
//    Rev 1.11   12 Sep 1995 17:01:38   DBRUCKS
// add twocc
// 
//    Rev 1.10   11 Sep 1995 11:14:48   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.9   29 Aug 1995 17:18:48   TRGARDOS
// Padded H263HeaderStruct
// 
//    Rev 1.8   28 Aug 1995 17:45:04   DBRUCKS
// add size defines
// 
//    Rev 1.7   28 Aug 1995 11:45:52   TRGARDOS
// 
// Updated frame size bit field in PTYPE.
// 
//    Rev 1.6   25 Aug 1995 10:37:12   CZHU
// Changed PITCH from const int to #define, because of compiler bug for inline
// 
//    Rev 1.5   25 Aug 1995 09:02:32   TRGARDOS
// 
// Modified picture header structure.
// 
//    Rev 1.4   14 Aug 1995 11:34:52   TRGARDOS
// Finished writing picture frame header.
// 
//    Rev 1.3   11 Aug 1995 17:27:56   TRGARDOS
// Added bitstream writing and defined bitstream fields.
// 
//    Rev 1.2   07 Aug 1995 16:25:28   TRGARDOS
// 
// Moved PITCH definition here from c3dec.h.
// 
//    Rev 1.1   03 Aug 1995 10:38:40   TRGARDOS
// 
// Put picture header structure definition and GOB header 
// definition in here.
// 
//    Rev 1.0   31 Jul 1995 12:56:14   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:43:58   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:32   CZHU
// Initial revision.
;// 
;// Added encoder controls message support.
;// Modified RTP dialog box.
;// Change to PercentForcedUpdate
;// add T_CONFIGURATION
;// Integrate with build 29
;// 
////////////////////////////////////////////////////////////////////////////
#ifndef DRV_DEFS_H
#define DRV_DEFS_H

#ifndef WIN32

/*
 * Define standard data types.
 */
typedef BYTE __huge* HPBYTE;
typedef WORD __huge* HPWORD;
typedef BYTE __far*  LPBYTE;
typedef WORD __far*  LPWORD;
typedef int  __far*  LPSHORT;

typedef unsigned char U8;
#ifndef I8
typedef signed char I8;
#endif
#ifndef U16
typedef unsigned int  U16;
#endif
#ifndef I16
typedef signed int I16;
#endif
#ifndef U32
typedef unsigned long U32;
#endif
#ifndef INT
#define INT short int        /* signed 16 bit */
#endif
#else //WIN32
typedef BYTE        * HPBYTE;
typedef WORD        * HPWORD;
typedef BYTE        *  LPBYTE;
typedef WORD        *  LPWORD;
typedef short int   *  LPSHORT;

typedef unsigned char U8;
#ifndef I8
typedef signed char I8;
#endif
#ifndef U16
typedef unsigned short int  U16;
#endif
#ifndef I16
typedef signed short int I16;
#endif
#ifndef U32
typedef unsigned long U32;
#endif
#ifndef INT
#define INT int        /* signed 16 bit */
#endif
#endif //WIN32

/*
 * Define custom DRVPROC messages for playback.
 */
#define PLAYBACK_CUSTOM_START            (ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_END            (PLAYBACK_CUSTOM_START + 9)
#define PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS    (PLAYBACK_CUSTOM_START + 0)
#define PLAYBACK_CUSTOM_CHANGE_CONTRAST        (PLAYBACK_CUSTOM_START + 1)
#define PLAYBACK_CUSTOM_CHANGE_SATURATION    (PLAYBACK_CUSTOM_START + 2)
#define PLAYBACK_CUSTOM_RESET_BRIGHTNESS    (PLAYBACK_CUSTOM_START + 3)
#define PLAYBACK_CUSTOM_RESET_SATURATION    (PLAYBACK_CUSTOM_START + 4)
#define PLAYBACK_CUSTOM_CHANGE_TINT        (PLAYBACK_CUSTOM_START + 5)
#define PLAYBACK_CUSTOM_RESET_TINT        (PLAYBACK_CUSTOM_START + 6)
#define PLAYBACK_CUSTOM_COLOR_CONVERT        (PLAYBACK_CUSTOM_START + 7)

typedef struct { char name[5]; HANDLE h; U16 FAR *log; U16 err; } TimeLog;

/*
 * Define various constants.
 */
#define TOTAL 0
#define OVERHEAD 1
#define HUFF 2
#define YSLANT 3
#define VSLANT 4
#define USLANT 5
#define YDIFF 6
#define VDIFF 7
#define UDIFF 8
#define TORQUE 9
#define FILTER 10
#define CSC 11

#ifdef H263P
enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5, CUSTOM=6, EPTYPE=7};
#else
enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5};
#endif

#define MAX_WIDTH 	352	   // CIF
#define MAX_HEIGHT	288	   // CIF
#define PITCH 		(MAX_WIDTH+32)

//** Decompressor Instance information
typedef struct {
    BOOL    Initialized;
	BOOL	bProposedCorrectAspectRatio;	// proposed
	BOOL    bCorrectAspectRatio;	// whether to correct the aspect ratio
#ifdef H263P
	BOOL    bCIFto320x240;          // whether to crop CIF frames to 320x240 (old still-frame mode)
#endif
    WORD    xres, yres;             // size of image within movie
	FrameSize FrameSz;		// Which of the supported frame sizes.
    int     pXScale, pYScale;       // proposed scaling (Query)
    int     XScale, YScale;         // current scaling (Begin)  
    UINT    uColorConvertor;        // Current Color Convertor
    WORD    outputDepth;            // and bit depth
    LPVOID  pDecoderInst;
    BOOL 				UseActivePalette;	/* decompress to active palette == 1 */
	BOOL				InitActivePalette;	/* active palette initialized == 1 */
	BOOL				bUseBlockEdgeFilter;/* switch for block edge filter */
	RGBQUAD     		ActivePalette[256];	/* stored active palette */
} DECINSTINFO, FAR *LPDECINST;

//** Configuration Information
typedef struct {
   BOOL    	bInitialized;               // Whether custom msgs can be rcv'd.
   BOOL		bCompressBegin;				// Whether the CompressBegin msg was rcv'd.
   BOOL    	bRTPHeader;                 // Whether to generate RTP header info
   /* used if bRTPHeader */
   UINT     unPacketSize;               // Maximum packet size
   BOOL     bEncoderResiliency;         // Whether to use resiliency restrictions
   /* used if bEncoderResiliency */
   UINT    	unPacketLoss;
   BOOL		bBitRateState;
   /* used if bBitRateState */
   UINT		unBytesPerSecond;
   /* The following information is determined from the packet loss value.   */
   /*  These values are calculated each time we receive a resiliency msg or */
   /*  the value is changed through the dialog box.  They are not stored in */
   /*  the registry.  Only the above elements are stored in the registry.   */
	BOOL    bDisallowPosVerMVs;   		// if true, disallow positive vertical MVs
	BOOL    bDisallowAllVerMVs;   		// if true, disallow all vertical MVs
	UINT    unPercentForcedUpdate;      // Percent Forced Update per Frame
	UINT    unDefaultIntraQuant;        // Default Intra Quant
	UINT    unDefaultInterQuant;        // Default Inter Quant

#ifdef H263P
	BOOL    bH263PlusState;				// Whether to use H.263+
	BOOL    bImprovedPBState;			// Whether to use improved PB-frames
	BOOL    bDeblockingFilterState;		// Whether to use in-the-loop deblocking filter
#endif
} T_CONFIGURATION;

//** Compressor Instance information
typedef struct{
    BOOL    Initialized;
    WORD    xres, yres;
	FrameSize FrameSz;		// Which of the supported frame sizes.
	float	FrameRate;
	U32		DataRate;		// Data rate in bytes per second.
    HGLOBAL hEncoderInst;   // Instance data private to encoder.
    LPVOID  EncoderInst;
    WORD    CompressedSize;
	BOOL	Is160x120;
	BOOL 	Is240x180;
	BOOL	Is320x240;
#if defined(H263P)
	U32		InputCompression;
	U32		InputBitWidth;
#endif
	T_CONFIGURATION Configuration;
} COMPINSTINFO, FAR *LPCODINST;

//**
//** Instance information
//**
typedef struct tagINSTINFO {
    DWORD   dwFlags;
	DWORD	fccHandler;		// So we know what codec has been opened.
	BOOL	enabled;
    LPCODINST CompPtr;          // ICM
    LPDECINST DecompPtr;        // ICM
} INSTINFO, FAR *LPINST;

//**  local name definitions ***
#ifdef H261
#ifdef QUARTZ
#define FOURCC_H26X mmioFOURCC('M','2','6','1')
#endif /* QUARTZ */
#define FOURCC_H263 mmioFOURCC('M','2','6','1')

#else /* is H263 */
#ifdef QUARTZ
#define FOURCC_H26X mmioFOURCC('M','2','6','3')
#endif /* QUARTZ */
#define FOURCC_H263 mmioFOURCC('M','2','6','3')
#endif /* else is H263 */

#define FOURCC_YUV12 mmioFOURCC('I','4','2','0')
#define FOURCC_IYUV  mmioFOURCC('I','Y','U','V')
#define FOURCC_YVU9  mmioFOURCC('Y','V','U','9')
#define FOURCC_IF09  mmioFOURCC('I','F','0','9')
#define FOURCC_YUY2  mmioFOURCC('Y','U','Y','2')
#define FOURCC_UYVY  mmioFOURCC('U','Y','V','Y')
#define TWOCC_H26X aviTWOCC('i','v');

#define MOD4(a)     ((a/4)*4)

typedef struct {
    unsigned short PictureStartCodeZeros:16;
    unsigned short PictureStartCode:6;
    unsigned short TR:8;
    unsigned short Const:2;
    unsigned short Split:1;
    unsigned short DocCamera:1;
    unsigned short PicFreeze:1;
    unsigned short SrcFormat:3;
    unsigned short Inter:1;
    unsigned short UMV:1;
    unsigned short SAC:1;
    unsigned short AP:1;
    unsigned short PB:1;
	unsigned short CPM:1;
} T_H263FrameHeader;

enum EnumPicCodType	{INTRAPIC=0, INTERPIC=1};
enum EnumOnOff	{OFF=0, ON=1};

/*
 * If the size of T_H263FrameHeaderStruct is changed, then
 * that change must be updated in T_H263EncoderCatalog in e3enc.h
 */
typedef struct {
    U32	PictureStartCodeZeros;	// 0..3
    U8 	TR;						// 4
   	// PTYPE;
	U8	Const;					// 5 -- two bit constant: 10
    U8	SrcFormat;				// 6 -- source format
	U8	Unassigned1;			// 7
 	EnumOnOff	Split;			// 8..11 -- split screen indicator
    EnumOnOff	DocCamera;		// 12..15 -- document camera indicator
    EnumOnOff	PicFreeze;		// 16..19 -- freeze picture release
    EnumPicCodType	PicCodType;	// 20 -- picture coding type
    EnumOnOff	UMV;			// 24 -- optional unrestricted motion vector mode
    EnumOnOff	SAC;			// 28 -- optional syntax-based arithmetic coding mode
    EnumOnOff	AP;				// 32 -- optional advanced prediction mode
    EnumOnOff	PB;				// 36 -- optional PB frames mode
	//
	U8	PQUANT;			// 40
	U8	CPM;			// 41
	U8	PLCI;			// 42
	U8	TRB;			// 43
	U8	DBQUANT;		// 44
	U8	PEI;			// 45
	U8	PSPARE;			// 46
	U8	TRPrev;			// 47	Temporal Reference of Previous frame

#ifdef H263P
	// H.263+ encoding options, document LBC-96-358
	EnumOnOff   CustomPCF;			// 48 Custom PCF
	EnumOnOff   AdvancedIntra;		// 52 Advanced intra coding (Annex I)
	EnumOnOff   DeblockingFilter;	// 56 In-the-loop deblocking filter (Annex J)
	EnumOnOff   SliceStructured;	// 60 Slice-structured (Annex K)
	EnumOnOff   ImprovedPB;         // 64 Improved PB-frame mode (Annex M)
	EnumOnOff   BackChannel;		// 68 Back-channel operation (Annex N)
	EnumOnOff   Scalability;		// 72 SNR and spatial scalability (Annex O)
	EnumOnOff   TrueBFrame;			// 76 True B-frame mode (Annex O)
	EnumOnOff   RefPicResampling;	// 80 Reference-picture resampling (Annex P)
	EnumOnOff   RedResUpdate;		// 84 Reduced-resolution update (Annex Q)
#endif

} T_H263FrameHeaderStruct;

#ifdef H263P
const int sizeof_T_H263FrameHeaderStruct = 88;
#else
const int sizeof_T_H263FrameHeaderStruct = 48;
#endif

typedef struct {
    unsigned short StartCodeZeros:16;
    unsigned short StartCode:1;
    unsigned short GN:5;
    unsigned short GLCI:2;
    unsigned short GFID:2;
	unsigned short GQUANT:5;
} T_H263GOBHeader;

#endif /* multi inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cdrvproc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//
//  This module is based on drvmain.c, Rev 1.24, 28 Apr 1995, from the
//  MRV video codec driver.
//
// $Author:   JMCVEIGH  $
// $Date:   17 Apr 1997 17:04:04  $
// $Archive:   S:\h26x\src\common\cdrvproc.cpv  $
// $Header:   S:\h26x\src\common\cdrvproc.cpv   1.39   17 Apr 1997 17:04:04   JMCVEIGH  $
// 
////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <oprahcom.h>

//  #define TIMING       1
                        //  Timing process  - for decode turn on in
                        //  CDRVPROC.CPP and D1DEC.CPP
#if TIMING
char            szTMsg[80];
unsigned long   tmr_time = 0L;
unsigned long   tmr_frms = 0L;
#endif

HINSTANCE hDriverModule; // the instance-handle of this driver set in LibMain

#if defined(H263P)
extern BOOL MMX_Enabled;
BOOL MMXDecoder_Enabled;
#define _PENTIUM_PROCESSOR           1
#define _PENTIUM_PRO_PROCESSOR       2
#define _PENTIUM_MMX_PROCESSOR       3
#define _PENTIUM_PRO_MMX_PROCESSOR   4
#endif

/* load free handshake */
static int Loaded = 0;    /* 0 prior to first DRV_LOAD and after DRV_FREE */

#ifdef DEBUG
HDBGZONE  ghDbgZoneH261 = NULL;
static PTCHAR _rgZonesH261[] = {
	TEXT("M261"),
	TEXT("Bitrate Control"),
	TEXT("Bitrate Control Details")
};

int WINAPI H261DbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("M261", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}
#endif /* DEBUG */

#if (defined(H261) || defined(H263))
/* Suppress FP thunking for now, for H261 and H263.
   Thunking currently has the side effect of masking floating point exceptions,
   which can cause exceptions like divide by zero to go undetected.
 */
#define FPThunking 0
#else
#define FPThunking 1
#endif

#if FPThunking
////////////////////////////////////////////////////////////////////////////
// These two routines are necessary to permit a 16 bit application call   //
// a 32 bit codec under Windows /95.  The Windows /95 thunk doesn't save  //
// or restore the Floating Point State. -Ben- 07/12/96                    //
//                                                                        //
U16 ThnkFPSetup(void)													  //
{																		  //
	U16	wOldFPState;													  //
	U16	wNewFPState = 0x027f;											  //
																		  //
	__asm																  //
	{																	  //
		fnstcw	WORD PTR [wOldFPState]									  //
		fldcw	WORD PTR [wNewFPState]									  //
	}																	  //
																		  //
	return(wOldFPState);												  //
}																		  //
																		  //
void ThnkFPRestore(U16 wFPState)										  //
{																		  //
	__asm																  //
	{																	  //
		fldcw	WORD PTR [wFPState]										  //
	}																	  //
																		  //
	return;																  //
}																		  //
////////////////////////////////////////////////////////////////////////////
#endif /* FPThunking */

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT WINAPI _loadds DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
;//
;// Description:    Added Header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI DriverProc(
				DWORD dwDriverID,
				HDRVR hDriver,
				UINT uiMessage,
				LPARAM lParam1,
				LPARAM lParam2
			)
{
    SYSTEM_INFO sysinfo;

    LRESULT rval = 0;
    LPINST  pi;

    ICDECOMPRESSEX ICDecExSt;
    ICDECOMPRESSEX DefaultICDecExSt = {
        0,
        NULL, NULL,
        NULL, NULL,
        0, 0, 0, 0,
        0, 0, 0, 0
    };
	int nOn486;

#if FPThunking
	U16	u16FPState = ThnkFPSetup();
#endif

  try
  {

    pi = (LPINST)dwDriverID;

    switch(uiMessage)
        {
        case DRV_LOAD:
            DBOUT("DRV_LOAD");
            /*
               Sent to the driver when it is loaded. Always the first
               message received by a driver.

               dwDriverID is 0L. 
               lParam1 is 0L.
               lParam2 is 0L.
                
               Return 0L to fail the load.

            */

            // put global initialization here...

            if(Loaded) {
                /* We used to return an undefined value here.  It's unclear
                 * whether this load should succeed, and if so, how or if
                 * we need to modify our memory usage to be truly reentrant.
                 * For now, let's explicitly fail this load attempt.
                 */
                rval = 0;
                break;
            }
            Loaded = 1;

            if(!DrvLoad())
            {
                rval = 0;
                Loaded = 0;
                break;
            }

            rval = (LRESULT)TRUE;
            break;

        case DRV_FREE:
            DBOUT("DRV_FREE");
            /*
               Sent to the driver when it is about to be discarded. This
               will always be the last message received by a driver before
               it is freed. 

               dwDriverID is 0L. 
               lParam1 is 0L.
               lParam2 is 0L.
                
               Return value is ignored.
            */

            // put global de-initialization here...

            if(!Loaded)
                break;
                
            Loaded = 0;
            DrvFree();
            rval = (LRESULT)TRUE;
            break;

        /*********************************************************************
         *     standard driver messages
         *********************************************************************/
        case DRV_DISABLE:
        case DRV_ENABLE:
            DBOUT("DRV_ENABLE / DRV_DISABLE");
            rval = (LRESULT)1L;
            break;
        
        case DRV_INSTALL:
        case DRV_REMOVE:
            DBOUT("DRV_INSTALL / DRV_REMOVE");
            rval = (LRESULT)DRV_OK;
            break;


        case DRV_OPEN:
        	DBOUT("DRV_OPEN");

             /*
               Sent to the driver when it is opened. 

               dwDriverID is 0L.
               
               lParam1 is a far pointer to a zero-terminated string
               containing the name used to open the driver.
               
               lParam2 is passed through from the drvOpen call. It is
               NULL if this open is from the Drivers Applet in control.exe
               It is a far pointer to an ICOPEN data structure otherwise.
                
               Return 0L to fail the open. Otherwise return a value that the
			   system will use for dwDriverID in subsequent messages. In our
			   case, we return a pointer to our INSTINFO data structure.
             */

           	if (lParam2 == 0)
            {    /* indicate we do process DRV_OPEN */
                rval = 0xFFFF0000;
                break;
            }

            /* if asked to draw, fail */
            if(((ICOPEN FAR *)lParam2)->dwFlags & ICMODE_DRAW)
            {
                DBOUT("DrvOpen wants ICMODE_DRAW");
                rval = 0L;
                break;
            }

            if((pi = DrvOpen((ICOPEN FAR *) lParam2)) == NULL)
            {
                DBOUT("DrvOpen failed ICERR_MEMORY");
				// We must return NULL on failure. We used to return
				// ICERR_MEMORY = -3, which implies a driver was opened
				rval = (LRESULT)0L;
                break;
            }
			rval = (LRESULT)pi;
            break;

        case DRV_CLOSE:
            DBOUT("DRV_CLOSE");

            if(pi != (tagINSTINFO*)0 && pi != (tagINSTINFO*)0xFFFF0000)
                DrvClose(pi);

            rval = (LRESULT)1L;
            break;

    //**************************
    //    state messages
    //**************************
        case DRV_QUERYCONFIGURE:// configuration from drivers applet
            DBOUT("DRV_QUERYCONFIGURE");
	    	// this is a GLOBAL query configure
            rval = (LRESULT)0L;
            break;
       
        case DRV_CONFIGURE:
			DBOUT("DRV_CONFIGURE");
			rval = DrvConfigure((HWND)lParam1);
			break;

        case ICM_CONFIGURE:
            DBOUT("ICM_CONFIGURE");
			//#ifndef H261
			   // This message is used to add extensions to the encode dialog box.
				// rval = Configure((HWND)lParam1);
		//	#else
				rval = ICERR_UNSUPPORTED;
		//	#endif
            break;
        
        case ICM_ABOUT:
			DBOUT("ICM_ABOUT");
			rval = About((HWND)lParam1);
			break;

        case ICM_GETSTATE:
            DBOUT("ICM_GETSTATE");
            rval = DrvGetState(pi, (LPVOID)lParam1, (DWORD)lParam2);
            break;
        
        case ICM_SETSTATE:
            DBOUT("ICM_SETSTATE");
            rval = DrvSetState(pi, (LPVOID)lParam1, (DWORD)lParam2);
            break;
        
        case ICM_GETINFO:
            DBOUT("ICM_GETINFO");
            rval = DrvGetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);
            break;

    //***************************
    //  compression messages
    //***************************
        case ICM_COMPRESS_QUERY:
            DBOUT("ICM_COMPRESS_QUERY");
#ifdef ENCODER_DISABLED
// This disables the encoder, as the debug message states.
            DBOUT("ENCODER DISABLED");
            rval = ICERR_UNSUPPORTED;
#else
            if(pi && pi->enabled && (pi->fccHandler == FOURCC_H263))
              	rval = CompressQuery(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
			else
			  	rval = ICERR_UNSUPPORTED;
#endif
            break;

		/*
		 * ICM Compress Frames Info Structure
		 */

		 case ICM_COMPRESS_FRAMES_INFO:
		 	DBOUT("ICM_COMPRESS_FRAMES_INFO");
			if (pi)
				rval = CompressFramesInfo((LPCODINST) pi->CompPtr, (ICCOMPRESSFRAMES *) lParam1, (int) lParam2);
			else
			  	rval = ICERR_UNSUPPORTED;
			break;

		/*
		 * ICM messages in support of quality.
		 */
		case ICM_GETDEFAULTQUALITY:
			DBOUT("ICM_GETDEFAULTQUALITY");
			rval = ICERR_UNSUPPORTED;
			break;

		case ICM_GETQUALITY:
			DBOUT("ICM_GETQUALITY");
			rval = ICERR_UNSUPPORTED;
			break;

		case ICM_SETQUALITY:
			DBOUT("ICM_SETQUALITY");
			rval = ICERR_UNSUPPORTED;
			break;

        case ICM_COMPRESS_BEGIN:
		    /*
			 * Notify driver to prepare to compress data by allocating and 
			 * initializing any memory it needs for compressing. Note that
			 * ICM_COMPRESS_BEGIN and ICM_COMPRESS_END do not nest.
			 *
			 * Should return ICERR_OK if the specified compression is supported
			 * or ICERR_BADFORMAT if the input or output format is not supported.
			 */
            DBOUT("ICM_COMPRESS_BEGIN");
			if (pi && pi->enabled)
				rval = CompressBegin(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_GET_FORMAT:
            DBOUT("ICM_COMPRESS_GET_FORMAT");
			if (pi)
				rval = CompressGetFormat(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_GET_SIZE:
            DBOUT("ICM_COMPRESS_GET_SIZE");
			if (pi && lParam1)
				rval = CompressGetSize(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS:
			/*
			 * Returns ICERR_OK if successful or an error code otherwise.
			 */
            DBOUT("ICM_COMPRESS");
			if (pi && pi->enabled)
				rval = Compress(
            			pi->CompPtr,				// ptr to Compressor instance information.
            			(ICCOMPRESS FAR *)lParam1,	// ptr to ICCOMPRESS structure.
            			(DWORD)lParam2				// size in bytes of the ICCOMPRESS structure.
            		   );
	        else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_END:
            DBOUT("ICM_COMPRESS_END");
			if (pi && pi->enabled)
				rval = CompressEnd(pi->CompPtr);
			else
				rval = ICERR_UNSUPPORTED;
            break;

    //***************************
    //    decompress messages
    //***************************
        case ICM_DECOMPRESS_QUERY:
            DBOUT("ICM_DECOMPRESS_QUERY");
            ICDecExSt = DefaultICDecExSt;
            ICDecExSt.lpbiSrc = (LPBITMAPINFOHEADER)lParam1;
            ICDecExSt.lpbiDst = (LPBITMAPINFOHEADER)lParam2;
			if (pi)
				rval = DecompressQuery(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_BEGIN:
            DBOUT("ICM_DECOMPRESS_BEGIN");
            ICDecExSt = DefaultICDecExSt;
            ICDecExSt.lpbiSrc = (LPBITMAPINFOHEADER)lParam1;
            ICDecExSt.lpbiDst = (LPBITMAPINFOHEADER)lParam2;
			if (pi)
				rval = DecompressBegin(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_GET_FORMAT:
            DBOUT("ICM_DECOMPRESS_GET_FORMAT");
			if (pi)
				rval = DecompressGetFormat(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_GET_PALETTE:
            DBOUT("ICM_DECOMPRESS_GET_PALETTE");
			if (pi)
				rval = DecompressGetPalette(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
			else
				rval = ICERR_UNSUPPORTED;
            break;
  	   case ICM_DECOMPRESS_SET_PALETTE:
		    DBOUT("ICM_DECOMPRESS_SET_PALETTE : not supported");
	        rval = ICERR_UNSUPPORTED;
	 //       rval = DecompressSetPalette(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
	        break;
 
        case ICM_DECOMPRESS:
            DBOUT("ICM_DECOMPRESS");
			if (pi && (pi->enabled || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_YUV12) || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_IYUV)))
			{
				ICDecExSt = DefaultICDecExSt;
				ICDecExSt.dwFlags = ((ICDECOMPRESS FAR *)lParam1)->dwFlags;
				ICDecExSt.lpbiSrc = ((ICDECOMPRESS FAR *)lParam1)->lpbiInput;
				ICDecExSt.lpSrc = ((ICDECOMPRESS FAR *)lParam1)->lpInput;
				ICDecExSt.lpbiDst = ((ICDECOMPRESS FAR *)lParam1)->lpbiOutput;
				ICDecExSt.lpDst = ((ICDECOMPRESS FAR *)lParam1)->lpOutput;
				rval = Decompress(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, (DWORD)lParam2, FALSE);

#if TIMING              // Output Timing Results in VC++ 2.0 Debug Window
				wsprintf(szTMsg, "Total Decode Time = %ld ms", tmr_time);
				TOUT(szTMsg);

				wsprintf(szTMsg, "Total Frames = %ld", tmr_frms);
				TOUT(szTMsg);

				wsprintf(szTMsg, "Average Frame Decode = %ld.%ld ms",
						 tmr_time / tmr_frms,
						 ((tmr_time % tmr_frms) * 1000) / tmr_frms);
				TOUT(szTMsg);
#endif
			}
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_END:
        case ICM_DECOMPRESSEX_END:
            DBOUT("ICM_DECOMPRESS_END / ICM_DECOMPRESSEX_END");
			if (pi)
				rval = DecompressEnd(pi->DecompPtr);
			else
				rval = ICERR_UNSUPPORTED;
            break;

    //***************************
    //    decompress X messages
    //***************************
        case ICM_DECOMPRESSEX:
            DBOUT("ICM_DECOMPRESSEX");
			if (pi && (pi->enabled || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_YUV12) || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_IYUV)))
				rval = Decompress(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, (DWORD)lParam2, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESSEX_BEGIN:
            DBOUT("ICM_DECOMPRESSEX_BEGIN");
			if (pi)
				rval = DecompressBegin(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESSEX_QUERY:
            DBOUT("ICM_DECOMPRESSEX_QUERY");
#ifdef TURN_OFF_DECOMPRESSEX
			rval = ICERR_UNSUPPORTED;
#else
			if (pi)
				rval = DecompressQuery(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
#endif
            break;

    
    // *********************************************************************
    // custom driver messages for bright/cont/sat
    // *********************************************************************

        case CODEC_CUSTOM_VIDEO_EFFECTS:
            DBOUT("CODEC_CUSTOM_VIDEO_EFFECTS");
            if(LOWORD(lParam1) == VE_HUE) {
				DBOUT("  VE_HUE : Unsupported");
                rval = ICERR_UNSUPPORTED;
                break;
            }
            switch(HIWORD(lParam1))
                {
                case    VE_GET_FACTORY_DEFAULT:
					DBOUT("  VE_GET_FACTORY_DEFAULT");
                    *((WORD FAR *)lParam2) = 128;
                    rval = ICERR_OK;
                    break;
                case    VE_GET_FACTORY_LIMITS:
					DBOUT("  VE_GET_FACTORY_LIMITS");
                    *((DWORD FAR *)lParam2) = 0x00FF0000;
                    rval = ICERR_OK;
                    break;
                case    VE_SET_CURRENT:
					DBOUT("  VE_SET_CURRENT");
                    if(LOWORD(lParam1) == VE_BRIGHTNESS)
					{
						DBOUT("    CustomChangeBrightness()");
                        rval = CustomChangeBrightness(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    if(LOWORD(lParam1) == VE_SATURATION)
					{
						DBOUT("    CustomChangeSaturation()");
                        rval = CustomChangeSaturation(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    if(LOWORD(lParam1) == VE_CONTRAST)
					{
						DBOUT("    CustomChangeContrast()");
                        rval = CustomChangeContrast(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    break;
                case    VE_RESET_CURRENT:
					DBOUT("  VE_RESET_CURRENT");
                    if(LOWORD(lParam1) == VE_BRIGHTNESS)
					{
						DBOUT("    CustomResetBrightness()");
                        rval = CustomResetBrightness(pi->DecompPtr);
					}
                    if(LOWORD(lParam1) == VE_CONTRAST)
					{
						DBOUT("    CustomResetContrast()");
                        rval = CustomResetContrast(pi->DecompPtr);
					}
                    if(LOWORD(lParam1) == VE_SATURATION)
					{
						DBOUT("    CustomResetSaturation()");
                        rval = CustomResetSaturation(pi->DecompPtr);
					}
                    break;
                default:
                    rval = ICERR_UNSUPPORTED;
                    break;
                }
            break;

         case CODEC_CUSTOM_ENCODER_CONTROL:
            DBOUT("CODEC_CUSTOM_ENCODER_CONTROL");
            switch(HIWORD(lParam1))
            {
               case EC_GET_FACTORY_DEFAULT:
				  DBOUT("  EC_GET_FACTORY_DEFAULT");
                  rval = ICERR_OK;
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_RESILIENCY:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_BITRATE_CONTROL:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_PACKET_SIZE:
                        *((DWORD FAR *)lParam2) = 512L;    
                        break;
                     case EC_PACKET_LOSS:
                        *((DWORD FAR *)lParam2) = 10L;
                        break;
                     case EC_BITRATE:
                        *((DWORD FAR *)lParam2) = 1664L;
                        break;
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_RESET_TO_FACTORY_DEFAULTS:
                  DBOUT("EC_RESET_TO_FACTORY_DEFAULTS");
                  rval = CustomResetToFactoryDefaults(pi->CompPtr);
                  break;
               case EC_GET_FACTORY_LIMITS:
				  DBOUT("  EC_GET_FACTORY_LIMITS");
                  rval = ICERR_OK;
                  switch(LOWORD(lParam1))
                  {
                     case EC_PACKET_SIZE:
                        *((DWORD FAR *)lParam2) = 0x05DC0100;
                        break;
                     case EC_PACKET_LOSS:
                        *((DWORD FAR *)lParam2) = 0x00640000;
                        break;
                     case EC_BITRATE:						  /* Bit rate limits are returned as */
                        *((DWORD FAR *)lParam2) = 0x34000400; /* the number of bytes per second  */
                        break;
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_GET_CURRENT:
				  DBOUT("  EC_GET_CURRENT");
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
                        rval = CustomGetRTPHeaderState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_RESILIENCY:
                        rval = CustomGetResiliencyState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_BITRATE_CONTROL:
                        rval = CustomGetBitRateState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_PACKET_SIZE:
                        rval = CustomGetPacketSize(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_PACKET_LOSS:
                        rval = CustomGetPacketLoss(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_BITRATE: /* Bit rate is returned in bits per second */
                        rval = CustomGetBitRate(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
#ifdef H263P
                     case EC_H263_PLUS:
                        rval = CustomGetH263PlusState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_IMPROVED_PB_FRAMES:
                        rval = CustomGetImprovedPBState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_DEBLOCKING_FILTER:
                        rval = CustomGetDeblockingFilterState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
					 case EC_MACHINE_TYPE:
						 // Return the machine type in (reference param) lParam2
						 // This message should not be invoked until after CompressBegin
						 // since this is where GetEncoderOptions is called, and the
						 // MMX version is properly set (via init file check).
						rval = ICERR_OK;
						if (ProcessorVersionInitialized) {
							if (MMX_Enabled) {
								if (P6Version) {
									*(int *)lParam2 = _PENTIUM_PRO_MMX_PROCESSOR;
								} else {
									*(int *)lParam2 = _PENTIUM_MMX_PROCESSOR;
								}
							} else {
								if (P6Version) {
									*(int *)lParam2 = _PENTIUM_PRO_PROCESSOR;
								} else {
									*(int *)lParam2 = _PENTIUM_PROCESSOR;
								}
							}
						} else {
							rval = ICERR_UNSUPPORTED;
						}
						break;
#endif
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_SET_CURRENT:
				  DBOUT("  EC_SET_CURRENT");
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
					    DBOUT("    EC_RTP_HEADER");
                        rval = CustomSetRTPHeaderState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_RESILIENCY:
					    DBOUT("    EC_RESILIENCY");
                        rval = CustomSetResiliencyState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_BITRATE_CONTROL:
					    DBOUT("    EC_BITRATE_CONTROL");
                        rval = CustomSetBitRateState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_PACKET_SIZE:
					    DBOUT("    EC_PACKET_SIZE");
                        rval = CustomSetPacketSize(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_PACKET_LOSS:
					    DBOUT("    EC_PACKET_LOSS");
                        rval = CustomSetPacketLoss(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_BITRATE: /* Bit rate is set in bits per second */
					    DBOUT("    EC_BITRATE");
                        rval = CustomSetBitRate(pi->CompPtr, (DWORD)lParam2);
                        break;
#ifdef H263P
                     case EC_H263_PLUS:
                        rval = CustomSetH263PlusState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_IMPROVED_PB_FRAMES:
                        rval = CustomSetImprovedPBState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_DEBLOCKING_FILTER:
                        rval = CustomSetDeblockingFilterState(pi->CompPtr, (DWORD)lParam2);
                        break;
#endif
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               default:
                    rval = ICERR_UNSUPPORTED;
                  break;
               }
               break;

		// custom decoder control
		case CODEC_CUSTOM_DECODER_CONTROL:
            DBOUT("CODEC_CUSTOM_DECODER_CONTROL");
			switch (HIWORD(lParam1))
			{
			case DC_SET_CURRENT:
				switch (LOWORD(lParam1))
				{
				case DC_BLOCK_EDGE_FILTER:
					rval = CustomSetBlockEdgeFilter(pi->DecompPtr,(DWORD)lParam2);
					break;
				default:
					rval = ICERR_UNSUPPORTED;
					break;
				}
				break;
#if defined(H263P)
			case DC_GET_CURRENT:
				switch (LOWORD(lParam1))
				{
				case DC_MACHINE_TYPE:
					// Return the machine type in (reference param) lParam2
					// This message should not be invoked until after DecompressBegin
					// since this is where GetDecoderOptions is called, and the
					// MMX version is properly set (via init file check). Note
					// that the DecoderContext flag is not used here. GetDecoderOptions has
					// been modified to supply the MMX flag in both DC->bMMXDecoder
					// and MMX_Enabled.
					rval = ICERR_OK;
					if (ProcessorVersionInitialized) {
						if (MMXDecoder_Enabled) {
							if (P6Version) {
								*(int *)lParam2 = _PENTIUM_PRO_MMX_PROCESSOR;
							} else {
								*(int *)lParam2 = _PENTIUM_MMX_PROCESSOR;
							}
						} else {
							if (P6Version) {
								*(int *)lParam2 = _PENTIUM_PRO_PROCESSOR;
							} else {
								*(int *)lParam2 = _PENTIUM_PROCESSOR;
							}
						}
					}
					break;
				default:
					rval = ICERR_UNSUPPORTED;
					break;
				}
				break;
#endif
			default:
				rval = ICERR_UNSUPPORTED;
				break;
			}
			break;

        case PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS:
            DBOUT("PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS");
            rval = CustomChangeBrightness(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_CHANGE_CONTRAST:
            DBOUT("PLAYBACK_CUSTOM_CHANGE_CONTRAST");
            rval = CustomChangeContrast(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_CHANGE_SATURATION:
            DBOUT("PLAYBACK_CUSTOM_CHANGE_SATURATION");
            rval = CustomChangeSaturation(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_RESET_BRIGHTNESS:
            DBOUT("PLAYBACK_CUSTOM_RESET_BRIGHTNESS");
            rval = CustomResetBrightness(pi->DecompPtr);
            rval |= CustomResetContrast(pi->DecompPtr);
            break;

        case PLAYBACK_CUSTOM_RESET_SATURATION:
            DBOUT("PLAYBACK_CUSTOM_RESET_SATURATION");
            rval = CustomResetSaturation(pi->DecompPtr);
            break;

    // *********************************************************************
    // custom application identification message
    // *********************************************************************
        case APPLICATION_IDENTIFICATION_CODE:
            DBOUT("APPLICATION_IDENTIFICATION_CODE");
            rval = ICERR_OK;
            break;

        case CUSTOM_ENABLE_CODEC:
            DBOUT("CUSTOM_ENABLE_CODEC");
			if (pi)
			{
				if (lParam1 == G723MAGICWORD1 && lParam2 == G723MAGICWORD2)
					pi->enabled = TRUE;
				else
					pi->enabled = FALSE;
			}
			rval = ICERR_OK;
			break;

        default:
            if (uiMessage < DRV_USER)
                {
                if(dwDriverID == 0)
                    rval = ICERR_UNSUPPORTED;
                else
                    rval = DefDriverProc(dwDriverID, hDriver, uiMessage,
                        lParam1, lParam2);
                }
            else
                rval = ICERR_UNSUPPORTED;
        }    
  }
  catch (...)
  {
#if defined(DEBUG) || defined(_DEBUG)
	// For a DEBUG build, display a message and pass the exception up.
	DBOUT("Exception during DriverProc!!!");
	throw;
#else
	// For a release build, stop the exception here and return an error
	// code.  This gives upstream code a chance to gracefully recover.
	// We also need to clear the floating point status word, otherwise
	// the upstream code may incur an exception the next time it tries
	// a floating point operation (presuming this exception was due
	// to a floating point problem).
	_clearfp();
	rval = (DWORD) ICERR_INTERNAL;
#endif
  }

#if FPThunking
	ThnkFPRestore(u16FPState);
#endif

    return(rval);
}


#ifdef WIN32
#ifndef QUARTZ
/****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL    | DllMain    | Library initialization & exit code.
 *
 * @parm HANDLE | hModule    | Our module handle.
 *
 * @parm DWORD  | dwReason   | The function being requested.
 *
 * @parm LPVOID | lpReserved | Unused at this time.
 *
 * @rdesc Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)
{
BOOL rval = TRUE;
 
/* DO NOT INSTALL PROFILE PROBES HERE. IT IS CALLED PRIOR TO THE LOAD message */
 
	switch(dwReason)
	{
		case DLL_PROCESS_ATTACH:
			/*======================================================*\
			/* A new instance is being invoked.
			/* Allocate data to be used by this instance, 1st thread
			/* lpReserved = NULL for dynamic loads, !NULL for static
			/* Use TlsAlloc() to create a TlsIndex for this instance
			/* The TlsIndex can be stored in a simple global variable
			/* as data allocated to each process is unique.
			/* Return TRUE upon success, FALSE otherwise.
			/*======================================================*/
			hDriverModule = hModule;
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Process Attach"));
#endif /* DEBUG */
			DBGINIT(&ghDbgZoneH261, _rgZonesH261);
            DBG_INIT_MEMORY_TRACKING(hModule);
			break;
		case DLL_PROCESS_DETACH:
			/*======================================================*\
			/* An instance is being terminated.
			/* Deallocate memory used by all threads in this instance
			/* lpReserved =  NULL if called by FreeLibrary()
			/*              !NULL if called at process termination
			/* Use TlsFree() to return TlsIndex to the pool.
			/* Clean up all known threads.
			/* May match many DLL_THREAD_ATTACHes.
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\nMRV DllMain Process Detach"));
#endif /* DEBUG */
            DBG_CHECK_MEMORY_TRACKING(hModule);
			DBGDEINIT(&ghDbgZoneH261);
			break;
		case DLL_THREAD_ATTACH:
			/*======================================================*\
			/* A new thread within the specified instance is being invoked.
			/* Allocate data to be used by this thread.
			/* Use the TlsIndex to access instance data.
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\nMRV DllMain Thread Attach"));
#endif /* DEBUG */
			break;
		case DLL_THREAD_DETACH:
			/*======================================================*\
			/* A thread within the specified instance is being terminated.
			/* Deallocate memory used by this thread.
			/* Use the TlsIndex to access instance data.
			/* May match DLL_PROCESS_ATTACH instead of DLL_THREAD_ATTACH
			/* Will be called even if DLL_THREAD_ATTACH failed or wasn't called
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Thread Detach"));
#endif /* DEBUG */
			break;
		default:
			/*======================================================*\
			/* Don't know the reason the DLL Entry Point was called.
			/* Return FALSE to be safe.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Reason Unknown"));
#endif /* DEBUG */
			rval = FALSE; /* indicate failure with 0 as
					   * (NULL can't be used in WIN32
					   */
	}
return(rval);
}
#endif	/* end #ifndef QUARTZ */
#else	/* else not #ifdef WIN32 */

;////////////////////////////////////////////////////////////////////////////
;// Function:       int NEAR PASCAL LibMain(HANDLE, WORD, LPSTR);
;//
;// Description:    Added header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
INT WINAPI LibMain(HANDLE hModule, WORD wHeapSize, LPSTR lpCmdLine)
    {
    hDriverModule = hModule;
    return 1;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cldebug.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  cldebug.cpp
 *
 *  Description:
 *		This modules contains the debug support routines
 *
 *	Routines:
 *		AssertFailed
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\common\cldebug.cpv   1.3   31 Oct 1996 10:12:50   KLILLEVO  $
 * $Log:   S:\h26x\src\common\cldebug.cpv  $
// 
//    Rev 1.3   31 Oct 1996 10:12:50   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.2   27 Dec 1995 14:11:42   RMCKENZX
// 
// Added copyright notice
 */

#include "precomp.h"

#ifdef _DEBUG

UINT DebugH26x = 0;

/*****************************************************************************
 *
 *  AssertFailed
 *
 *  Print out a message indicating that the assertion failed.  If in Ring3
 *  give the user the option of aborting.  Otherwise just output the message.
 */
extern void 
AssertFailed(
	void FAR * fpFileName, 
	int iLine, 
	void FAR * fpExp)
{
#ifndef RING0
	char szBuf[500];
	int n;

	wsprintf(szBuf,"Assertion (%s) failed in file '%s' at line %d - Abort?",
	    	 fpExp, fpFileName, iLine);
	DBOUT(szBuf);
	n = MessageBox(GetFocus(), szBuf, "Assertion Failure", 
				   MB_ICONSTOP | MB_YESNO | MB_SETFOREGROUND);
	if (n == IDYES) 
		abort();
#else
	SYS_printf("Assertion (%s) failed in file '%s' at line %d",
	    	   fpExp, fpFileName, iLine);
   _asm int 3;
#endif
} /* end AssertFailed() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cresourc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Cq_h26x.rc
//
#define IDS_YVU9_DESC                   1
#define IDS_YVU9_NAME                   2
#define IDS_DRV_NAME                    5
#define IDS_INCOMPAT                    6
#define IDS_ERR_PACKET_SIZE             7
#define IDS_ERR_PACKET_LOSS             8
#define IDS_ERR_BITRATE                 9
#define IDS_ERR_TITLE                   11
#define IDS_ERR_NON_NUMERIC             12
#define IDS_QTZ_ERR_BRIGHTNESS_TITLE    13
#define IDS_QTZ_ERR_SATURATION_TITLE    14
#define IDS_QTZ_ERR_CONTRAST_TITLE      15
#define IDS_QTZ_ERR_BRIGHTNESS_MESSAGE  16
#define IDS_QTZ_ERR_SATURATION_MESSAGE  17
#define IDS_QTZ_ERR_CONTRAST_MESSAGE    18
#define IDS_QTZ_ERR_NON_NUMERIC_TITLE   19
#define IDS_QTZ_ERR_NON_NUMERIC_MESSAGE 20
#define IDS_QTZ_VIDEO_EFFECTS           21
#define IDS_QTZ_DIALOG_COMPRESS_NAME    22
#define IDS_QTZ_ERR_FRAMERATE_TITLE     23
#define IDS_QTZ_ERR_DATARATE_TITLE      24
#define IDS_QTZ_ERR_QUALITY_TITLE       25
#define IDS_QTZ_ERR_KEY_FRAME_INTERVAL_TITLE 26
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_TITLE 27
#define IDS_QTZ_ERR_FRAMERATE_MESSAGE   28
#define IDS_QTZ_ERR_DATARATE_MESSAGE    29
#define IDS_QTZ_ERR_QUALITY_MESSAGE     30
#define IDS_QTZ_ERR_KEY_FRAME_INTERVAL_MESSAGE 31
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_FCIF_MESSAGE 32
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_QCIF_MESSAGE 33
#define IDS_QTZ_RTP_COMPRESS_NAME       34
#define IDS_QTZ_ERR_PACKET_SIZE_TITLE   35
#define IDS_QTZ_ERR_PACKET_SIZE_MESSAGE 36
#define IDS_QTZ_ERR_PACKET_LOSS_TITLE   37
#define IDS_QTZ_ERR_PACKET_LOSS_MESSAGE 38
#define IDS_QTZ_ENCODE_OPTIONS          39
#define IDS_QTZ_ERR_ENCODE_OPTIONS_TITLE 40
#define IDS_QTZ_ERR_EXTENDEDMV          41
#define IDS_QTZ_ERR_EXTENDEDMV_MESSAGE  42
#define IDS_QTZ_ERR_PBFRAMES            43
#define IDS_QTZ_ERR_PBFRAMES_MESSAGE    44
#define IDS_QTZ_ERR_ADVPREDICTION       45
#define IDS_QTZ_ERR_ADVPREDICTION_MESSAGE 46
#define IDD_DIALOG1                     101
#define IDD_QTZ_VIDEO_EFFECTS           102
#define IDD_QTZ_DIALOG_COMPRESS         103
#define IDD_QTZ_RTP_COMPRESS            104
#define IDD_QTZ_ENCODE_OPTIONS          105
#define IDC_PACKET_SIZE                 1006
#define IDC_PACKET_SIZE_TEXT            1007
#define IDC_RTP_HEADER                  1008
#define IDC_ENCODER_RESILIENCY          1009
#define IDC_PACKET_LOSS                 1010
#define IDC_PACKET_LOSS_TEXT            1011
#define IDD_ABOUT                       1012
#define IDABOUT                         1013
#define IDDEFAULT                       1014
#define IDC_RESILIENCY_OPTIONS          1015
#define IDC_RTP_OPTIONS                 1016
#define IDC_ENCODER_BITRATE_CONTROL     1017
#define IDC_BITRATE_CONTROL             1018
#define IDC_BITRATE_CONTROL_TEXT        1019
#define IDC_QTZ_RESET                   1020
#define IDC_QTZ_LOAD_DEFAULT            1021
#define IDC_QTZ_ABOUT                   1022
#define IDC_QTZ_VE_BRIGHTNESS           1023
#define IDC_QTZ_VE_SATURATION           1024
#define IDC_QTZ_VE_CONTRAST             1025
#define IDC_QTZ_VE_MIRROR				1026
#define IDC_QTZ_SATURATION_TEXT         1029
#define IDC_QTZ_CONTRAST_TEXT           1030
#define IDC_QTZ_TEXT                    1031
#define IDC_QTZ_BRIGHTNESS_TEXT         1032
#define IDC_CMP_KEYFRAME_RATE_TEXT      1033
#define IDC_CMP_KEYFRAME_RATE           1034
#define IDC_CMP_DATA_RATE_TEXT          1035
#define IDC_CMP_DATA_RATE               1036
#define IDC_CMP_FRAME_RATE_TEXT         1037
#define IDC_CMP_FRAME_RATE              1038
#define IDC_CMP_QUALITY_TEXT            1039
#define IDC_CMP_QUALITY                 1040
#define IDC_CMP_GENERATE_KEY            1041
#define IDC_CMP_TARGET_TEXT             1042
#define IDC_CMP_TARGET_FRAME_SIZE       1043
#define IDC_CMP_FSIZE_BRC               1044
#define IDC_CMP_FRATE_BRC               1045
#define IDC_QTZ_RTP_HEADER              1046
#define IDC_QTZ_PACKET_SIZE             1047
#define IDC_QTZ_PACKET_SIZE_TEXT        1048
#define IDC_QTZ_PACKET_LOSS             1049
#define IDC_QTZ_PACKET_LOSS_TEXT        1050
#define IDC_QTZ_EXTENDEDMV              1051
#define IDC_QTZ_PBFRAMES                1052
#define IDC_QTZ_ADVPREDICTION			1053
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1054
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\ctypedef.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:12:02  $
// $Archive:   S:\h26x\src\common\ctypedef.h_v  $
// $Header:   S:\h26x\src\common\ctypedef.h_v   1.2   27 Dec 1995 14:12:02   RMCKENZX  $
// $Log:   S:\h26x\src\common\ctypedef.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:12:02   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////
#ifndef __TYPEDEFS_H__
#define __TYPEDEFS_H__

typedef unsigned char       U8;
typedef signed   char       I8;

typedef unsigned short      U16;
typedef short               I16;

typedef long                I32;
typedef unsigned long       U32;

typedef unsigned int        UN;
typedef int                 IN;

typedef unsigned short int  X16;  /* Used for offsets of per-instance data < 64K */
typedef unsigned long       X32;  /* Used for offsets of per-instance data >= 64K */

#ifndef WIN32
#define BIGG _huge
#define FAR  _far
#else
#define BIGG 
#define _huge
#define _far
#ifndef FAR
#define FAR
#endif
#ifndef BIGG
#define BIGG
#endif
#endif

/* #define HUGE _huge // name conflict with name used in <math.h> */

#define TRUE  1
#define FALSE 0


#if defined WIN32
#define ASM_CALLTYPE _stdcall
#else
#define ASM_CALLTYPE
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cproto.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   30 Dec 1996 19:59:06  $
// $Archive:   S:\h26x\src\common\cproto.h_v  $
// $Header:   S:\h26x\src\common\cproto.h_v   1.9   30 Dec 1996 19:59:06   MDUDA  $
// $Log:   S:\h26x\src\common\cproto.h_v  $
;// 
;//    Rev 1.9   30 Dec 1996 19:59:06   MDUDA
;// Modified H263InitEncoderInstance prototype.
;// 
;//    Rev 1.8   25 Sep 1996 17:23:28   BECHOLS
;// Added Snapshot declaration.
;// 
;//    Rev 1.7   24 Sep 1996 13:49:06   BECHOLS
;// Added Snapshot() prototype.
;// 
;//    Rev 1.6   10 Jul 1996 08:26:42   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.5   02 Feb 1996 18:52:56   TRGARDOS
;// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
;// 
;//    Rev 1.4   27 Dec 1995 14:11:58   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////

/*
 * Prototypes for Low Bitrate VFW Codec
 */

#ifndef LB3PROTOIZE_H
#define LB3PROTOIZE_H

#ifndef VOID
#define VOID void
#endif

#ifndef WIN32
#ifndef FAR
#define FAR __far
#endif
#endif



#ifndef INLINE
#define INLINE __inline
#endif

#ifndef STATIC
#define STATIC static
#endif

#ifndef SHORT
#define SHORT short
#endif

#ifndef S8
#define S8 signed char
#endif

DWORD PASCAL CompressBegin(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressFramesInfo( LPCODINST, ICCOMPRESSFRAMES *, int);

DWORD PASCAL CompressGetFormat(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL Compress(LPCODINST, ICCOMPRESS FAR *, DWORD );

DWORD PASCAL CompressGetSize(LPCODINST, LPBITMAPINFOHEADER,
    LPBITMAPINFOHEADER);

DWORD PASCAL CompressEnd(LPCODINST);

DWORD PASCAL DecompressQuery(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);

DWORD PASCAL DecompressGetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER); 

DWORD PASCAL DecompressSetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);

DWORD PASCAL DecompressGetFormat(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);

DWORD PASCAL DecompressBegin(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);

DWORD PASCAL Decompress(LPDECINST, ICDECOMPRESSEX FAR *, DWORD, BOOL);

DWORD PASCAL DecompressEnd(LPDECINST);

DWORD PASCAL Snapshot(LPDECINST, LPVOID, DWORD);

VOID MakeCode32(U16);

BOOL PASCAL DrvLoad(VOID);

VOID PASCAL DrvFree(VOID);

LPINST PASCAL DrvOpen(ICOPEN FAR *);

DWORD PASCAL DrvClose(LPINST);

DWORD PASCAL DrvGetState(LPINST, LPVOID, DWORD);

DWORD PASCAL DrvSetState(LPINST, LPVOID, DWORD);

DWORD PASCAL DrvGetInfo(LPINST, ICINFO FAR *, DWORD);

#ifdef WIN32
LRESULT WINAPI DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
#else
LRESULT FAR PASCAL _loadds DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
#endif


LPCODINST PASCAL CompressOpen(VOID);

DWORD PASCAL CompressEnd(LPCODINST);

DWORD PASCAL CompressClose(DWORD);

// controls.c
#ifdef QUARTZ
LRESULT __cdecl CustomChangeBrightness(LPDECINST, BYTE);
LRESULT __cdecl CustomChangeContrast(LPDECINST, BYTE);
LRESULT __cdecl CustomChangeSaturation(LPDECINST, BYTE);
LRESULT __cdecl CustomGetBrightness(LPDECINST, BYTE *);
LRESULT __cdecl CustomGetContrast(LPDECINST, BYTE *);
LRESULT __cdecl CustomGetSaturation(LPDECINST, BYTE *);
LRESULT __cdecl CustomResetBrightness(LPDECINST);
LRESULT __cdecl CustomResetContrast(LPDECINST);
LRESULT __cdecl CustomResetSaturation(LPDECINST);
#else
LRESULT CustomChangeBrightness(LPDECINST, BYTE);
LRESULT CustomChangeContrast(LPDECINST, BYTE);
LRESULT CustomChangeSaturation(LPDECINST, BYTE);
LRESULT CustomResetBrightness(LPDECINST);
LRESULT CustomResetContrast(LPDECINST);
LRESULT CustomResetSaturation(LPDECINST);
#endif

#ifdef WIN32
//BOOL  DriverDialogProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY DllMain(HINSTANCE , DWORD , LPVOID );
#else
INT WINAPI LibMain(HANDLE, WORD, LPSTR);
//BOOL FAR PASCAL _loadds _export DriverDialogProc(HWND, UINT, UINT, LONG);
#endif 

;// D3DEC.CPP 
LRESULT H263InitDecoderGlobal(void);
LRESULT H263Decompress(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);
LRESULT H263InitDecoderInstance(LPDECINST, int);
LRESULT H263TermDecoderInstance(LPDECINST);

void FAR H26332BitEncoderCodeSegment (void);
void FAR H26332BitDecoderCodeSegment (void);
void FAR H26332BitColorConvertCodeSegment (void);

;// E3ENC.CPP
LRESULT H263InitEncoderGlobal(void);
LRESULT H263Compress(LPCODINST, ICCOMPRESS FAR *);
#if defined(H263P)
LRESULT H263InitEncoderInstance(LPBITMAPINFOHEADER, LPCODINST);
#else
LRESULT H263InitEncoderInstance(LPCODINST);
#endif
LRESULT H263TermEncoderInstance(LPCODINST);

;// D3COLOR.C
LRESULT H263InitColorConvertorGlobal (void);
LRESULT H263InitColorConvertor(LPDECINST, UINT);
LRESULT H263TermColorConvertor(LPDECINST);
#endif /* multi-inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cdrvcom.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
////////////////////////////////////////////////////////////////////////////
//
// $Author:   JMCVEIGH  $
// $Date:   05 Feb 1997 12:14:22  $
// $Archive:   S:\h26x\src\common\cdrvcom.h_v  $
// $Header:   S:\h26x\src\common\cdrvcom.h_v   1.21   05 Feb 1997 12:14:22   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdrvcom.h_v  $
;// 
;//    Rev 1.21   05 Feb 1997 12:14:22   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.20   19 Dec 1996 16:44:08   MDUDA
;// Added custom messages to get machine type information.
;// 
;//    Rev 1.19   16 Dec 1996 17:36:46   JMCVEIGH
;// H.263+ custom message definitions.
;// 
;//    Rev 1.18   11 Dec 1996 14:56:08   JMCVEIGH
;// 
;// Added H.263+ field lengths for EPTYPE and custom message definitions.
;// 
;//    Rev 1.17   09 Dec 1996 17:42:46   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 
;//    Rev 1.16   09 Dec 1996 09:25:22   MDUDA
;// 
;// Modified _CODEC_STATS stuff.
;// 
;//    Rev 1.15   11 Oct 1996 16:01:46   MDUDA
;// 
;// Added initial _CODEC_STATS stuff.
;// 
;//    Rev 1.14   10 Sep 1996 16:13:04   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.13   22 Jul 1996 14:44:36   BECHOLS
;// fixed last comment.
;// 
;//    Rev 1.12   22 Jul 1996 14:36:20   BECHOLS
;// Wrapped the comment section with /* ... */ /* so that Steve Ing won't
;// be hassled with changing this.
;// 
;//    Rev 1.11   22 May 1996 18:48:08   BECHOLS
;// 
;// Added APPLICATION_IDENTIFICATION_CODE.
;// 
;//    Rev 1.10   06 May 1996 00:41:50   BECHOLS
;// 
;// Added the necessary message constants to allow the app to control
;// the bit rate dialog stuff.
;// 
;//    Rev 1.9   26 Apr 1996 11:10:44   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.8   27 Dec 1995 14:11:54   RMCKENZX
;// Added copyright notice
;// 
;// Added CODEC_CUSTOM_ENCODER_CONTROL.
;// Integrate with build 29
//
////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_VIDEO_EFFECTS:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = VE_SET_CURRENT:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = value of corresponding value..
//
//    HIWORD(lParam1) = VE_GET_FACTORY_DEFAULT:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = (WORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = VE_GET_FACTORY_LIMITS:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = (DWORD FAR *)Address of the return value.
//            LOWORD(*lParam2) = lower limit
//            HIWORD(*lParam2) = upper limit
//
//    HIWORD(lParam1) = VE_SET_INPUT_CONNECTOR:
//        LOWORD(lParam1) = VE_INPUT_COMPOSITE_1, VE_INPUT_SVIDEO_1
//        lParam2 = 0 
// --------------------------------------------------------------------- 
*/

// CUSTOM_VIDEO_EFFECTS: LOWORD(lParam1)
#define VE_CONTRAST                 0
#define VE_HUE                      1
#define VE_SATURATION               2
#define VE_BRIGHTNESS               3

// CUSTOM_VIDEO_EFFECTS: HIWORD(lParam1)
#define VE_SET_CURRENT              0
#define VE_GET_FACTORY_DEFAULT      1
#define VE_GET_FACTORY_LIMITS       2
#define VE_SET_INPUT_CONNECTOR      3
#define VE_RESET_CURRENT            4

// CUSTOM_SET_INPUT_CONNECTOR: LOWORD(lParam1)
#define VE_INPUT_COMPOSITE_1        0
#define VE_INPUT_SVIDEO_1           1

////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_ENCODER_CONTROL:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = EC_GET_FACTORY_DEFAULT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = VE_GET_FACTORY_LIMITS:
//        LOWORD(lParam1) = EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//            LOWORD(*lParam2) = lower limit
//            HIWORD(*lParam2) = upper limit
//
//    HIWORD(lParam1) = EC_GET_CURRENT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = EC_SET_CURRENT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = value of corresponding value..
// --------------------------------------------------------------------- 

// CUSTOM_ENCODER_CONTROL: LOWORD(lParam1)
#define EC_RTP_HEADER                0
#define EC_RESILIENCY                1
#define EC_PACKET_SIZE               2
#define EC_PACKET_LOSS               3
#define EC_BITRATE_CONTROL			 4
#define EC_BITRATE					 5

#ifdef H263P
// H.263+ options
#define EC_H263_PLUS				1000	// Must be sent before any option messages sent

// Numbering convention:
//	1xxx: H.263+ option
//  xBBx: Bit number of option in extended PTYPE field
// Numbers are spaced by 10 to allow for additional parameters related to each option
//#define EC_ADVANCED_INTRA			1040
#define EC_DEBLOCKING_FILTER		1050
//#define EC_SLICE_STRUCTURED		1060
//#define EC_CUSTOM_PCF				1070
//#define EC_BACK_CHANNEL			1080
//#define EC_SCALABILITY			1090	
//#define EC_TRUE_BFRAMES			1100
//#define EC_REF_RESAMPLING			1110
//#define EC_RES_UPDATE				1120
#define EC_IMPROVED_PB_FRAMES		1130

// Test support, stats monitoring, etc. messages are isolated here.
#define EC_MACHINE_TYPE				2000

// The use of the improved PB-frame mode is currently not signaled in the picture header.
// We assume that if EPTYPE is present and the frame was signaled as a PB-frame
// in PTYPE, then the improved PB-frame mode is used.

// end H.263+ options
#endif // H263P

// CUSTOM_ENCODER_CONTROL: HIWORD(lParam1)
#define EC_SET_CURRENT               0
#define EC_GET_FACTORY_DEFAULT       1
#define EC_GET_FACTORY_LIMITS        2
#define EC_GET_CURRENT               3
#define EC_RESET_TO_FACTORY_DEFAULTS 4

////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_DECODER_CONTROL:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = DC_SET_CURRENT:
//        LOWORD(lParam1) = DC_BLOCK_EDGE_FILTER;
//        lParam2 = 0:off, 1:on

// CUSTOM_DECODER_CONTROL: LOWORD(lParam1)
#define DC_BLOCK_EDGE_FILTER         0
#if defined(H263P)
// Test support, stats monitoring, etc. messages are isolated here.
#define DC_MACHINE_TYPE           2000
#endif

// CUSTOM_DECODER_CONTROL: HIWORD(lParam1)
#define DC_SET_CURRENT               0
#if defined(H263P)
// This was added simply to provide a consistent way to access
// machine type (see DC_MACHINE_TYPE).
#define DC_GET_CURRENT               1
#endif


/*
 * Bit stream field sizes
 */
#ifdef H261
const unsigned int FIELDLEN_PSC = 20;
const unsigned int FIELDLEN_TR = 5;		// temporal reference

const unsigned int FIELDLEN_PTYPE = 6;	// picture type
const unsigned int FIELDLEN_PTYPE_SPLIT = 1;
const unsigned int FIELDLEN_PTYPE_DOC = 1;
const unsigned int FIELDLEN_PTYPE_RELEASE = 1;
const unsigned int FIELDLEN_PTYPE_SRCFORMAT = 1;
const unsigned int FIELDLEN_PTYPE_STILL = 1;
const unsigned int FIELDLEN_PTYPE_SPARE = 1;
const unsigned int FIELDLEN_PEI = 1;	// extra insertion information.
const unsigned int FIELDLEN_PSPARE = 8;	// spare information

const unsigned int FIELDLEN_GBSC = 16;
const unsigned int FIELDLEN_GN = 4;
const unsigned int FIELDLEN_GQUANT = 5;
const unsigned int FIELDLEN_GEI = 1;

const unsigned int FIELDLEN_MQUANT = 5;
const unsigned int FIELDLEN_MBA_STUFFING = 11;

#else
const unsigned int FIELDLEN_PSC = 22;
const unsigned int FIELDLEN_TR = 8;		// temporal reference

const unsigned int FIELDLEN_PTYPE = 13;	// picture type
const unsigned int FIELDLEN_PTYPE_CONST = 2;
const unsigned int FIELDLEN_PTYPE_SPLIT = 1;
const unsigned int FIELDLEN_PTYPE_DOC = 1;
const unsigned int FIELDLEN_PTYPE_RELEASE = 1;
const unsigned int FIELDLEN_PTYPE_SRCFORMAT = 3;
const unsigned int FIELDLEN_PTYPE_CODINGTYPE = 1;
const unsigned int FIELDLEN_PTYPE_UMV = 1;
const unsigned int FIELDLEN_PTYPE_SAC = 1;
const unsigned int FIELDLEN_PTYPE_AP = 1;
const unsigned int FIELDLEN_PTYPE_PB = 1;

#ifdef H263P

const unsigned int FIELDLEN_EPTYPE_SRCFORMAT = 3;
const unsigned int FIELDLEN_EPTYPE_CPCF = 1;
const unsigned int FIELDLEN_EPTYPE_AI = 1;
const unsigned int FIELDLEN_EPTYPE_DF = 1;
const unsigned int FIELDLEN_EPTYPE_SS = 1;
const unsigned int FIELDLEN_EPTYPE_IPB = 1;
const unsigned int FIELDLEN_EPTYPE_BCO = 1;
const unsigned int FIELDLEN_EPTYPE_SCALE = 1;
const unsigned int FIELDLEN_EPTYPE_TB = 1;
const unsigned int FIELDLEN_EPTYPE_RPR = 1;
const unsigned int FIELDLEN_EPTYPE_RRU = 1;
const unsigned int FIELDLEN_EPTYPE_CONST = 5;

const unsigned int FIELDLEN_CSFMT_PARC = 4;
const unsigned int FIELDLEN_CSFMT_FWI = 9;
const unsigned int FIELDLEN_CSFMT_CONST = 1;
const unsigned int FIELDLEN_CSFMT_FHI = 9;

const unsigned int FIELDLEN_EPAR_WIDTH = 8;
const unsigned int FIELDLEN_EPAR_HEIGHT = 8;

#endif

const unsigned int FIELDLEN_PQUANT = 5;	// picture quant value
const unsigned int FIELDLEN_CPM = 1;	// continuous presence multipoint indicator
const unsigned int FIELDLEN_PLCI = 2;	// picture logical channel indicator.
const unsigned int FIELDLEN_TRB = 3;	// temporal reference for B frames
const unsigned int FIELDLEN_DBQUANT = 2;// B frame differential quant value
const unsigned int FIELDLEN_PEI = 1;	// extra insertion information.
const unsigned int FIELDLEN_PSPARE = 8;	// spare information

const unsigned int FIELDLEN_GBSC = 17;	// Group of blocks start code
const unsigned int FIELDLEN_GN = 5;		// GOB number.
const unsigned int FIELDLEN_GLCI = 2;	// GOB logical channel indicator
const unsigned int FIELDLEN_GFID = 2;	// GOB Frame ID
const unsigned int FIELDLEN_GQUANT = 5;	// GQUANT
#endif

/*
 * Bit stream field values
 */
#ifdef H261
const unsigned int FIELDVAL_PSC  = 0x00010;
const unsigned int FIELDVAL_GBSC = 0x0001;
const unsigned int FIELDVAL_MBA_STUFFING = 0x00F;
#else
const unsigned int FIELDVAL_PSC = 0x000020;
const unsigned int FIELDVAL_GBSC = 1;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cldebug.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   31 Oct 1996 10:21:06  $
// $Archive:   S:\h26x\src\common\cldebug.h_v  $
// $Header:   S:\h26x\src\common\cldebug.h_v   1.10   31 Oct 1996 10:21:06   KLILLEVO  $
// $Log:   S:\h26x\src\common\cldebug.h_v  $
;// 
;//    Rev 1.10   31 Oct 1996 10:21:06   KLILLEVO
;// removed DBOUT definition to verify that all occurences in the code
;// have been removed, and to prevent future usage of DBOUT
;// 
;//    Rev 1.9   18 Oct 1996 18:50:14   AGUPTA2
;// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
;// 
;// 
;//    Rev 1.8   18 Oct 1996 14:30:52   MDUDA
;// Added YUY2toYUV12 enumeration.
;// 
;//    Rev 1.7   11 Oct 1996 16:01:28   MDUDA
;// 
;// Added initial _CODEC_STATS stuff.
;// 
;//    Rev 1.6   27 Dec 1995 14:11:58   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.5   17 Nov 1995 15:13:02   BECHOLS
// 
// Made modifications for ring 0.
// 
//    Rev 1.4   16 Nov 1995 17:34:08   AGANTZX
// Added TOUT macro to output timing data
// 
//    Rev 1.3   12 Sep 1995 15:44:50   DBRUCKS
// add H261 ifdef for debug statements
// 
//    Rev 1.2   03 Aug 1995 14:57:02   DBRUCKS
// Add ASSERT macro
// 
//    Rev 1.1   01 Aug 1995 12:24:40   DBRUCKS
// added TBD()
// 
//    Rev 1.0   31 Jul 1995 12:56:16   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:44:04   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:48   CZHU
// Initial revision.

/*
 * Copyright (C) 1992, 1993 Intel Corporation.
 */
extern UINT DebugH26x;
extern void AssertFailed(void FAR * fpFileName, int iLine, void FAR * fpExp);

#ifndef __CLDEBUG_H__
#define __CLDEBUG_H__

  #ifdef _DEBUG
    #ifdef RING0
      #define DBOUT(x) {SYS_printf(x);}
      #define TOUT(x) {SYS_printf(x);}
    #else
      #ifdef H261
        #define DBOUT(x)  { if (DebugH26x) { \
                             OutputDebugString((LPSTR)"M261 : "); \
                             OutputDebugString((LPSTR)x);         \
                             OutputDebugString((LPSTR)"\n"); }}
      #else
         #define DBOUT(x) { if (DebugH26x) { \
                             OutputDebugString((LPSTR)"M263 : "); \
                             OutputDebugString((LPSTR)x);         \
                             OutputDebugString((LPSTR)"\n"); }}
      #endif
      #define TOUT(x)  { if (DebugH26x) { \
                          OutputDebugString((LPSTR)"TIMING : "); \
                          OutputDebugString((LPSTR)x);          \
                          OutputDebugString((LPSTR)"\n"); }}
    #endif //RING0
	#ifdef ASSERT
	#undef ASSERT
	#endif
    #define ASSERT(x) { if(!(x)) AssertFailed(__FILE__,__LINE__,#x); }
  #else
    #define TOUT(x) { } //  /##/
    #define DBOUT(x) { } //  /##/
	#ifdef ASSERT
	#undef ASSERT
	#endif
    #define ASSERT(x) { } //  /##/ 
  #endif
 
  #define TBD(s) DBOUT(s)

#ifdef _DEBUG // { _DEBUG

int WINAPI H261DbgPrintf ( LPTSTR lpszFormat, ... );
extern HDBGZONE  ghDbgZoneH261;

#define ZONE_BITRATE_CONTROL (GETMASK(ghDbgZoneH261) & 0x0001)
#define ZONE_BITRATE_CONTROL_DETAILS (GETMASK(ghDbgZoneH261) & 0x0002)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (H261DbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (H261DbgPrintf m)
#else // }{ _DEBUG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)
#endif // } _DEBUG

#endif /* multi-inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\cversion.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*
 * $Header:   S:\h26x\src\common\cversion.h_v   1.65.1.0.1.1   17 Oct 1996 08:41:58   PLUSARDI  $
 * $Log:   S:\h26x\src\common\cversion.h_v  $
;// 
;//    Rev 1.65.1.0.1.1   17 Oct 1996 08:41:58   PLUSARDI
;// updated for version VH263.v2.55.103e
;// 
;//    Rev 1.65.1.0.1.0   08 Oct 1996 12:52:48   PLUSARDI
;// updated for H263.2.55.103d
;// 
;//    Rev 1.65.1.0   27 Sep 1996 07:04:38   PLUSARDI
;// updated for version 103 of h263
;// 
;//    Rev 1.65   24 Sep 1996 14:45:12   PLUSARDI
;// updated for version 102 of h263
;// 
;//    Rev 1.64   17 Sep 1996 09:06:00   PLUSARDI
;// updated for version 101 of h263 and rtp263
;// 
;//    Rev 1.63   12 Sep 1996 10:23:30   PLUSARDI
;// updated for version 2.55.100 for h263 and rtp263
;// 
;//    Rev 1.62   06 Sep 1996 14:40:22   BECHOLS
;// Removed the distinction between RTP and nonRTP.  I also updated the
;// release number to 2.55.016.
;// 
;//    Rev 1.61   05 Sep 1996 14:38:36   PLUSARDI
;// No change.
;// 
;//    Rev 1.60   04 Sep 1996 20:32:42   PLUSARDI
;// 
;// updated for 261 build 1.05.009 and 1.00.030
;// 
;//    Rev 1.59   03 Sep 1996 16:12:14   PLUSARDI
;// updated for 2.50.016 version of h263
;// 
;//    Rev 1.58   03 Sep 1996 16:05:06   PLUSARDI
;// updated for v2.50.015  263 internet 
;// 
;//    Rev 1.57   22 Aug 1996 10:02:04   PLUSARDI
;// updated for version 006 of h261 quartz
;// 
;//    Rev 1.56   22 Aug 1996 09:15:22   CPERGIEX
;// Rev'd H261 to version 029
;// 
;//    Rev 1.55   16 Aug 1996 11:27:14   CPERGIEX
;// updated for version 028 of h261
;// 
;//    Rev 1.54   15 Aug 1996 11:25:32   PLUSARDI
;// update the version build 004 quartz
;// 
;//    Rev 1.53   05 Aug 1996 16:57:56   CPERGIEX
;// Change version number to 027.
;// 
;//    Rev 1.52   01 Aug 1996 13:13:30   PLUSARDI
;// updated for build 14 of H263 RTP
;// 
;//    Rev 1.51   31 Jul 1996 18:44:16   PLUSARDI
;// updated for version 13 of net H263
;// 
;//    Rev 1.50   30 Jul 1996 12:52:04   PLUSARDI
;// updated for build 12 of net263
;// 
;//    Rev 1.49   11 Jul 1996 14:31:52   PLUSARDI
;// Build 026 of H261 Version 3.00 (not Quartz). C. Pergiel.
;// 
;//    Rev 1.48   11 Jul 1996 09:52:42   PLUSARDI
;// Change the version number for h261 v3.05.004
;// 
;//    Rev 1.47   11 Jul 1996 07:53:14   PLUSARDI
;// change the version number for h261 v3.05.003
;// 
;//    Rev 1.46   10 Jul 1996 17:17:56   PLUSARDI
;// updated to version 003 of H261 quartz
;// 
;//    Rev 1.45   10 Jul 1996 08:26:44   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.44   21 Jun 1996 10:53:44   AGANTZX
;// Revved Version String to Build 025
;// ]
;// 
;// 
;//    Rev 1.43   20 Jun 1996 14:10:50   AGANTZX
;// Revved to correct version string ...024
;// 
;//    Rev 1.42   06 Jun 1996 06:36:56   PLUSARDI
;// changed mmx version numbers to 1.5.xx
;// 
;//    Rev 1.41   31 May 1996 10:15:48   PLUSARDI
;// updated for verison 45 of mmx 236
;// 
;//    Rev 1.40   08 May 1996 11:50:42   PLUSARDI
;// updated for ver 009 of net263
;// 
;//    Rev 1.39   07 May 1996 21:11:02   PLUSARDI
;// updated for version 1.20.008 for net263
;// 
;//    Rev 1.38   07 May 1996 09:49:42   BECHOLS
;// Added ifdef RTP_HEADER for separate version control.
;// 
;//    Rev 1.37   24 Apr 1996 13:51:42   AGANTZX
;// Reved Version string to Build 022
;// 
;//    Rev 1.36   22 Apr 1996 11:54:34   AGANTZX
;// Revved Version strin to build 021
;// 
;//    Rev 1.35   05 Apr 1996 12:06:26   AGANTZX
;// Revved Version String to: "020"
;// 
;//    Rev 1.34   04 Apr 1996 16:52:08   AGANTZX
;// Revved Version Number to H261 to Build 019
;// 
;//    Rev 1.33   21 Mar 1996 14:47:12   unknown
;// Updated H261 Version Label to V3.00.018
;// 
;//    Rev 1.32   15 Feb 1996 16:52:46   RHAZRA
;// updated for versionb 28 of h263
;// 
;//    Rev 1.31   14 Feb 1996 17:11:14   AKASAI
;// Corrected CODEC_RELEASE to 15 was 14.
;// 
;//    Rev 1.30   14 Feb 1996 17:04:40   AGANTZX
;// none
;// 
;//    Rev 1.29   14 Feb 1996 09:36:08   AGANTZX
;// Incremented Build version to 014
;// 
;//    Rev 1.28   08 Feb 1996 14:46:00   AGANTZX
;// Rolled Build Revision to 013
;// 
;//    Rev 1.27   06 Feb 1996 14:41:06   PLUSARDI
;// Changed Build version to 012
;// 
;//    Rev 1.26   23 Jan 1996 17:52:30   PLUSARDI
;// No change.
;// 
;//    Rev 1.25   22 Jan 1996 18:50:24   PLUSARDI
;// No change.
;// 
;//    Rev 1.24   16 Jan 1996 13:37:56   AGANTZX
;// Changed Build Revision Number to 011
;// 
;//    Rev 1.23   15 Jan 1996 16:48:46   AGANTZX
;// Reved Version to Build 10
;// 
;//    Rev 1.22   15 Jan 1996 15:16:54   PLUSARDI
;// updated for version 016 of H263
;// 
;//    Rev 1.21   09 Jan 1996 13:49:00   AGANTZX
;// Updated H261 Version Number to 009
;// 
;//    Rev 1.20   08 Jan 1996 13:02:08   DBRUCKS
;// advance copyright to 1996
;// 
;//    Rev 1.19   03 Jan 1996 09:14:02   DKAYNORX
;// No change.
;// 
;//    Rev 1.18   27 Dec 1995 15:01:06   DKAYNORX
;// Edited H261 Version Number to "008"
;// 
;//    Rev 1.17   27 Dec 1995 14:12:04   RMCKENZX
;// 
;// Added copyright notice
 */

//////////////////////////////////////////////////////////////////////////////
//
// Version
//
#if defined(H261)

#define CODEC_VERSION       4
#define CODEC_REVISION      50
#define CODEC_RELEASE       014
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.261 Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.261 Video Codec\0" 
#endif
#define VERSIONNAME         "MSH261.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.261 Video Codec\0"

#elif defined(H263P)

#define CODEC_VERSION       3
#define CODEC_REVISION      55
#define CODEC_RELEASE       211
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263P Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263P Video Codec\0" 
#endif
#define VERSIONNAME         "MSH263P.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.263P Video Codec\0"

#else	// is H263

#define CODEC_VERSION       2
#define CODEC_REVISION      55
#define CODEC_RELEASE       115
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263 Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263 Video Codec\0" 
#endif
#define VERSIONNAME         "MSH263.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.263 Video Codec\0"

#endif //end else is H263

#define VERSIONCOMPANYNAME  "Microsoft Corp. and Intel Corporation\0"
#define VERSIONCOPYRIGHT    "Microsoft Corp. and Intel Corporation\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1addsp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AKASAI  $
// $Date:   18 Mar 1996 10:47:48  $
// $Archive:   S:\h26x\src\dec\d1addsp.cpv  $
// $Header:   S:\h26x\src\dec\d1addsp.cpv   1.1   18 Mar 1996 10:47:48   AKASAI  $
// $Log:   S:\h26x\src\dec\d1addsp.cpv  $
// 
//    Rev 1.1   18 Mar 1996 10:47:48   AKASAI
// Deleted ClampTblSpecial so now uses common table ClipPixIntra.
// Added pragma code_seg("IACODE2").
// 
//    Rev 1.0   01 Nov 1995 13:37:58   AKASAI
// Initial revision.
// 


// -------------------------------------------------------------------------
// ROUTINE NAME: BlockAddSpecial
// FILE NAME:    d1addsp.cpp
//
// This routine performs a block(8 8) addition.
//       output = clamp[reference + current]
//
// Input I32 *current (output of FMIDCT)
//       U8  *reference (Motion Compensated address of reference)
//       U8  *output  (Output buffer)
//
// Assumption:  reference uses 8 as pitch, output use PITCH,  
//              current has some other pitch, TEMPPITCH4
//
// Registers used: eax, ebx, ecx, edx, esi, edi, ebp
//
// -------------------------------------------------------------------------


#include "precomp.h"

#define TEMPPITCH4 32

extern U8 ClipPixIntra[];

#define FRAMEPOINTER        esp
#define L_LOOPCOUNTER       FRAMEPOINTER    +    0    // 4 byte
#define LOCALSIZE           4                         // keep aligned
 
#pragma code_seg("IACODE2")
__declspec(naked)
void BlockAddSpecial (U32 uResidual, U32 uRefBlock,U32 uDstBlock)
{        
__asm {
    push    ebp                  ;// save callers frame pointer
     mov    ebp,esp              ;// make parameters accessible 
    push    esi                  ;// assumed preserved 
     push   edi            
    push    ebx             
     sub    esp,LOCALSIZE        ;// reserve local storage 

    mov     esi, uRefBlock;      ;// esi gets Base addr of Current
      mov   edi, uDstBlock       ;// edi gets Base addr of OutputBuffer
    mov     ebp, uResidual       ;// ebp gets Base addr of Reference
      mov   ecx, 8
    xor     eax, eax             

// Cylces counts: 26 x 8=208 without cache miss
//                czhu, 9/25/95
ALIGN 4
loop_for_i:
    mov     [L_LOOPCOUNTER], ecx        ; save loop counter in temporary
      mov   ebx, [ebp+8]                ; 1) fetch current[i+2]
    mov     al, BYTE PTR[esi+2]         ; 1) fetch ref[i+2]
      xor   ecx, ecx                    ; 2)
    mov     cl, BYTE PTR[esi+3]         ; 2) fetch ref[i+3]
      mov   edx, [ebp+12]               ; 2) fetch current[i+3]
    add     eax, ebx                    ; 1) result2 = ref[i+2] + current[i+2]
      xor   ebx, ebx                    ; 3)
    add     ecx, edx                    ; 2) result3= ref[i+3] + current[i+3]
      mov   bl, BYTE PTR[esi]           ; 3) fetch ref[i]
    mov     dl, ClipPixIntra[1024+eax]  ; 1) fetch clamp[result2]
      mov   eax, [ebp]                  ; 3) fetch current[i]
    add     ebx, eax                    ; 3) result0 = ref[i] + current[i]
      xor   eax, eax                    ; 4)
    mov     dh, ClipPixIntra[1024+ecx]  ; 2) fetch clamp[result3]
      mov   al, [esi+1]                 ; 4) fetch ref[i+1]
    shl     edx, 16                     ; move 1st 2 results to high word
      mov   ecx, [ebp+4]                ; 4) fetch current[i+1]
    mov     dl, ClipPixIntra[1024+ebx]  ; 3) fetch clamp[result0]
      add   eax, ecx                    ; 4) result1 = ref[i+1] + current[i+1]
    xor     ecx, ecx                    ; 4+1)
      mov   ebx, [ebp+24]               ; 4+1) fetch current[i+6]
    mov     dh, ClipPixIntra[1024+eax]  ; 4) fetch clamp[result1]
      mov   cl, BYTE PTR[esi+6]         ; 4+1) fetch ref[i+6]
    mov     [edi], edx                  ; store 4 output pixels
      xor   eax, eax                    ; 4+2)
    mov     al, BYTE PTR[esi+7]         ; 4+2) fetch ref[i+7]
      mov   edx, [ebp+28]               ; 4+2) fetch current[i+7]
    add     ecx, ebx                    ; 4+1) result6 = ref[i+6] + current[i+6]
      xor   ebx, ebx                    ; 4+3)
    add     eax, edx                    ; 4+2) result7= ref[i+7] + current[i+7]
      mov   bl, BYTE PTR[esi+4]         ; 4+3) fetch ref[i+4]
    mov     dl, ClipPixIntra[1024+ecx]  ; 4+1) fetch clamp[result6]
      mov   ecx, [ebp+16]               ; 4+3) fetch current[i+4]
    add     ebx, ecx                    ; 4+3) result4 = ref[i+4] + current[i+4]
      xor   ecx, ecx                    ; 4+4)
    mov     dh, ClipPixIntra[1024+eax]  ; 4+2) fetch clamp[result7]
      mov   cl, [esi+5]                 ; 4+4) fetch ref[i+5]
    shl     edx, 16                     ; move 3rd 2 results to high word
      mov   eax, [ebp+20]               ; 4+4) fetch current[i+5]
    add     ecx, eax                    ; 4+4) result5 = ref[i+5] + current[i+5]
      add   esi, 8                      ; Update address of next line
    mov     dl, ClipPixIntra[1024+ebx]  ; 4+3) fetch clamp[result4]
      add   ebp, TEMPPITCH4             ; Update address of current to next line
    mov     dh, ClipPixIntra[1024+ecx]  ; 4+4) fetch clamp[result5]
      mov   ecx, [L_LOOPCOUNTER]        ; get loop counter
    mov     [edi+4], edx                ; store 4 output pixels
      add   edi, PITCH                  ; Update address of output to next line
    xor     eax, eax                    ; 1)
      dec   ecx
    jnz     loop_for_i


    add     esp,LOCALSIZE               // free locals 
      pop   ebx 
    pop     edi
      pop   esi
    pop     ebp
      ret   
  }     //end of asm, BlockAddSpecial

}   // End of BlockAddSpecial
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1bef.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * d1bef.cpp
 *
 * DESCRIPTION: Performs post filter on block edges of decompressed Y Plane.
 *		This is a 1:2:1 filter.
 *		Edges are processed in macroblock order across the width.
 *		That is for FCIF GOB's 1&2 are processed across the width not
 *		GOB 1 followed by GOB 2.
 *	
 *		A series of tests determine if an edge should be filtered.
 *		Edge of Y Plane edges are not filtered.
 *		For blocks 1-4:
 *			if block type == empty
 *				if MV != 0 && Quant > INTER_QUANT_THRESHOLD
 *					want to filter 
 *			else if block type == INTRA
 *				if Quant > INTRA_QUANT_THRESHOLD && 
 *				   total run length < HIGH_FREQ_CUTOFF
 *					want to filter
 *			else
 *				if Quant > INTER_QUANT_THRESHOLD &&
 *				   total run lenght < HIGH_FREQ_CUTOFF
 *					want to filter
 *
 *		Examine edges in pairs, top and left that is:
 *		
 *		-----------------------
 *              | 1 | 2 | 1 | 2 |	to filter top of block 1 edge 
 *		-----------------------  examine block 1 if want filter and
 *		| 3 | 4 | 3 | 4 |	 previous row block 3 if want filter
 *		----------------------- to filter left of block 1 edge
 *              | 1 | 2 | 1 | 2 |	 examine block 1 if want filter and
 *		-----------------------  previous in current row block 2 if
 *		| 3 | 4 | 3 | 4 |	 want filter
 *		-----------------------
 *
 *		Filter all edges that want to be filtered except Plane
 *		edges.
 *
 * Routine:	BlockEdgeFilter 
 *
 * Inputs:	Pointer to decompressed Y Plane, Y Plane height and width,
 *			decompressed Y Plane pitch, pointer to block 
 *			action stream.
 *		Whether an block was under the HIGH_FREQ_CUTOFF was
 *		determined in d1block (variable length decode) and
 *		overloaded in Block type field of block action stream.
 *
 * Notes:	Investigate 1:6:1 filter as possible intermediate strength.
 *
 *****************************************************************************
 */

// $Header:   S:\h26x\src\dec\d1bef.cpv   1.0   05 Apr 1996 13:25:28   AKASAI  $
//
// $Log:   S:\h26x\src\dec\d1bef.cpv  $
// 
//    Rev 1.0   05 Apr 1996 13:25:28   AKASAI
// Initial revision.
// 
     
#include "precomp.h"

#define INTER_QUANT_THRESHOLD 18 - 8
#define INTRA_QUANT_THRESHOLD 14 - 6

     
void BlockEdgeFilter(U8 * YPlane, int height, int width, int Pitch,
					T_BlkAction *lpBlockAction)
{
  T_BlkAction *fpBlockAction;
  I32 Pitch16 = (Pitch<<4);
  I32 Pitch8  = (Pitch<<3);
  I32 i,j,k;
  I8 do_filter_1;
  I8 do_filter_2;								 
  I8 do_filter_3;
  I8 do_filter_4;

  I8 Prev_row_BEF_descr[2*22];	/* 2 Y block * 22 (MB) */
  I8 Prev2, Prev4;
  U8 *r_2, *r_1, *r, *r1;
  U8 *rb_2, *rb_1, *rb, *rb1;

  U8 *col, *lcol;
     
  /* horizontal edges */
  r = YPlane;
  r_2 = r - 2*Pitch;
  r_1 = r - Pitch;
  r1 = r + Pitch;

  rb = r + 8*Pitch;
  rb_2 = rb - 2*Pitch;
  rb_1 = rb - Pitch;
  rb1 = rb + Pitch;
  fpBlockAction = lpBlockAction;

  col = YPlane;

	for (i = 0; i<44; i++)
	{
		Prev_row_BEF_descr[i] = -1;
	}
     
	if (width > 176) {
		fpBlockAction += 198;		/* predecrement pointer */
	}
	for (j = 0; j < height; j += 16)
	{
		Prev2 = -1;
		Prev4 = -1;
     
		for (i = 0; i < width; i += 16)	/* do left & top of blks 1,2,3,4 */
		{
			if (width > 176) {
				if (i == 0) fpBlockAction -= 198;
				else if (i == 176) fpBlockAction +=132;
			}
			do_filter_1 = 0;
			do_filter_2 = 0;
			do_filter_3 = 0;
			do_filter_4 = 0;
     
			if ((fpBlockAction->u8BlkType & 0x7f) == BT_EMPTY)
			{
				if ( ((fpBlockAction->i8MVX != 0) || 
					(fpBlockAction->i8MVY != 0))   &&
				    (fpBlockAction->u8Quant > INTER_QUANT_THRESHOLD) )
						do_filter_1 = 1;
			}
			else if ((fpBlockAction->u8BlkType & 0x7f) == BT_INTRA)
			{
				if ((fpBlockAction->u8Quant > INTRA_QUANT_THRESHOLD) &&
                    ((fpBlockAction->u8BlkType & 0x80) == 0x80))
						do_filter_1 = 1;
			}
			else	/* know inter block */
			{
				if ((fpBlockAction->u8Quant > INTER_QUANT_THRESHOLD) &&
                    ((fpBlockAction->u8BlkType & 0x80) == 0x80))
						do_filter_1 = 1;
			}
	     
			if (((fpBlockAction+1)->u8BlkType & 0x7f )== BT_EMPTY)
			{
				if ( (((fpBlockAction+1)->i8MVX != 0) || 
					((fpBlockAction+1)->i8MVY != 0))   &&
				    ((fpBlockAction+1)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+1)->u8BlkType & 0x80) == 0x80))
						do_filter_2 = 1;
			}
			else if (((fpBlockAction+1)->u8BlkType & 0x7f) == BT_INTRA)
			{
				if (((fpBlockAction+1)->u8Quant > INTRA_QUANT_THRESHOLD) &&
                    (((fpBlockAction+1)->u8BlkType & 0x80) == 0x80))
						do_filter_2 = 1;
			}
			else	/* know inter block */
			{
				if (((fpBlockAction+1)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+1)->u8BlkType & 0x80) == 0x80))
						do_filter_2 = 1;
			}
	     
			if (((fpBlockAction+2)->u8BlkType & 0x7f) == BT_EMPTY)
			{
				if ( (((fpBlockAction+2)->i8MVX != 0) || 
					((fpBlockAction+2)->i8MVY != 0))   &&
				    ((fpBlockAction+2)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+2)->u8BlkType & 0x80) == 0x80))
						do_filter_3 = 1;
			}
			else if (((fpBlockAction+2)->u8BlkType & 0x7f) == BT_INTRA)
			{
				if (((fpBlockAction+2)->u8Quant > INTRA_QUANT_THRESHOLD) &&
                    (((fpBlockAction+2)->u8BlkType & 0x80) == 0x80))
						do_filter_3 = 1;
			}
			else	/* know inter block */
			{
				if (((fpBlockAction+2)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+2)->u8BlkType & 0x80) == 0x80))
						do_filter_3 = 1;
			}
	     
			if (((fpBlockAction+3)->u8BlkType & 0x7f) == BT_EMPTY)
			{
				if ( (((fpBlockAction+3)->i8MVX != 0) || 
					((fpBlockAction+3)->i8MVY != 0))   &&
				    ((fpBlockAction+3)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+3)->u8BlkType & 0x80) == 0x80))
						do_filter_4 = 1;
			}
			else if (((fpBlockAction+3)->u8BlkType & 0x7f)== BT_INTRA)
			{
				if (((fpBlockAction+3)->u8Quant > INTRA_QUANT_THRESHOLD) &&
                    (((fpBlockAction+3)->u8BlkType & 0x80) == 0x80))
						do_filter_4 = 1;
			}
			else	/* know inter block */
			{
				if (((fpBlockAction+3)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+3)->u8BlkType & 0x80) == 0x80))
						do_filter_4 = 1;
			}
	     
			/* Process block 1 top */
			if (do_filter_1 + Prev_row_BEF_descr[(i>>3)] > 0) {
				for (k = i; k < i+8; k++) {
					#ifdef BLACK_LINE_H
					*(r_1 + k) = 60;
					*(r + k)   = 10; 
					#else
					*(r_1 + k) = (*(r_2 + k) + ((*(r_1+k))<<1)  + *(r + k))>>2;
					*(r + k)   = (*(r_1 + k) + ((*(r + k))<<1) + *(r1 + k))>>2; 
					#endif
     
				}
			}
			lcol = col;
			/* Process block 1 left */
			if (do_filter_1 + Prev2 > 0) {
				for (k = 0; k < 8; k++) {
     
					#ifdef BLACK_LINE_V
					*(lcol + i-1   ) = 10;
					*(lcol + i ) = 60;
					#else
					*(lcol + i-1 ) = (*(lcol + i-2) + ((*(lcol + i-1))<<1) + *(lcol + i))>>2;
					*(lcol + i   ) = (*(lcol + i-1) + ((*(lcol + i))<<1) + *(lcol + i+1))>>2;
					#endif
					lcol   += Pitch;
				}
			}
			/* Process block 2 top */
			if (do_filter_2 + Prev_row_BEF_descr[((i+8)>>3)] > 0) {
				for (k = i+8; k < i+16; k++) {
					#ifdef BLACK_LINE_H
					*(r_1 + k) = 60;
					*(r + k)   = 10; 
					#else
					*(r_1 + k) = (*(r_2 + k) + ((*(r_1+k))<<1) + *(r + k))>>2;
					*(r + k)   = (*(r_1 + k) + ((*(r + k))<<1) + *(r1 + k))>>2; 
					#endif
    	 
				}
			}
			lcol = col;
			/* Process block 2 left */
			if (do_filter_2 + do_filter_1 > 0) {
				for (k = 0; k < 8; k++) {
     
					#ifdef BLACK_LINE_V
					*(lcol + i+8-1   ) = 10;
					*(lcol + i+8 ) = 60;
					#else
					*(lcol + i+8-1 ) = (*(lcol + i+8-2) + ((*(lcol + i+8-1))<<1) + *(lcol + i+8))>>2;
					*(lcol + i+8   ) = (*(lcol + i+8-1) + ((*(lcol + i+8))<<1) + *(lcol + i+8+1))>>2;
					#endif
					lcol   += Pitch;
				}
			}

			/* bottom row of blocks in macro block */
			if (j+8 < height)
			{
				/* Process Block 3 top */
				if (do_filter_3 + do_filter_1 > 0) {
					for (k = i; k < i+8; k++) {
						#ifdef BLACK_LINE_H
						*(rb_1 + k) = 60;
						*(rb + k)   = 10; 
						#else
						*(rb_1+k) = (*(rb_2+k) + ((*(rb_1+k))<<1) + *(rb+k))>>2;
						*(rb + k) = (*(rb_1 + k) + ((*(rb + k))<<1) + *(rb1 + k))>>2; 
						#endif
     
					}
				}
				lcol = col + Pitch8;
				/* Process Block 3 left */
				if (do_filter_3 + Prev4 > 0) {
					for (k = 0; k < 8; k++) {
     
						#ifdef BLACK_LINE_V
						*(lcol + i-1   ) = 10;
						*(lcol + i ) = 60;
						#else
						*(lcol + i-1 ) = (*(lcol + i-2) + ((*(lcol + i-1))<<1) + *(lcol + i))>>2;
						*(lcol + i   ) = (*(lcol + i-1) + ((*(lcol + i))<<1) + *(lcol + i+1))>>2;
						#endif
						lcol   += Pitch;
					}
				}
	     		/* Process block 4 top */
		       	if (do_filter_4 + do_filter_2 > 0) {
					for (k = i+8; k < i+16; k++) {
						#ifdef BLACK_LINE_H
						*(rb_1 + k) = 60;
						*(rb + k)   = 10; 
						#else
						*(rb_1 + k) = (*(rb_2 + k) + ((*(rb_1+k))<<1) + *(rb + k))>>2;
						*(rb + k)   = (*(rb_1 + k) + ((*(rb + k))<<1) + *(rb1 + k))>>2; 
						#endif
    	 
					}
				}
				lcol = col + Pitch8;
				/* Process block 4 left */
				if (do_filter_4 + do_filter_3 > 0) {
					for (k = 0; k < 8; k++) {
     
						#ifdef BLACK_LINE_V
						*(lcol + i+8-1   ) = 10;
						*(lcol + i+8 ) = 60;
						#else
						*(lcol + i+8-1 ) = (*(lcol + i+8-2) + ((*(lcol + i+8-1))<<1) + *(lcol + i+8))>>2;
						*(lcol + i+8   ) = (*(lcol + i+8-1) + ((*(lcol + i+8))<<1) + *(lcol + i+8+1))>>2;
						#endif
						lcol   += Pitch;
					}
				}
			}
			fpBlockAction+=6;
			Prev_row_BEF_descr[(i>>3)] = do_filter_1;
			Prev_row_BEF_descr[((i+8)>>3)] = do_filter_2;
			Prev2 = do_filter_2;
			Prev4 = do_filter_4;
		}
		col += Pitch16;
		r   += Pitch16;
        r1  += Pitch16;
        r_1 += Pitch16;
        r_2 += Pitch16;
        rb   += Pitch16;
        rb1  += Pitch16;
        rb_1 += Pitch16;
        rb_2 += Pitch16;
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1blkadd.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   AKASAI  $
// $Date:   18 Mar 1996 09:30:48  $
// $Archive:   S:\h26x\src\dec\d1blkadd.cpv  $
// $Header:   S:\h26x\src\dec\d1blkadd.cpv   1.0   18 Mar 1996 09:30:48   AKASAI  $
// $Log:   S:\h26x\src\dec\d1blkadd.cpv  $
// 
//    Rev 1.0   18 Mar 1996 09:30:48   AKASAI
// Initial revision.
// 
//    Rev 1.4   22 Dec 1995 13:52:16   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.3   25 Sep 1995 09:03:36   CZHU
// Added comments on cycle counts
// 
//    Rev 1.2   13 Sep 1995 08:46:44   AKASAI
// Set loopcounter back to 8.  Intermediate is 8x8 of DWORDS so TEMPPITCH4
// should be 32 not 64.
// 
//    Rev 1.1   12 Sep 1995 18:19:20   CZHU
// 
// Changed loop from 8 to 7 to start with.
// 
//    Rev 1.0   11 Sep 1995 16:52:20   CZHU
// Initial revision.


// -------------------------------------------------------------------------
// T is routine performs a block(8 8) addition.
//       output = clamp[reference + current]
//
// Input I32 *current (output of FMIDCT)
//       U8  *reference (Motion Compensated address of reference)
//       U8  *output  (Output buffer)
//
// Assumption:  reference and output use PITCH  
//              current  as some other pitch 
//
// Registers used: eax, ebx, ecx, edx, esi, edi, ebp
//
// -------------------------------------------------------------------------


#include "precomp.h"

#define TEMPPITCH4 32

extern U8 ClipPixIntra[];

#define FRAMEPOINTER		esp
#define L_LOOPCOUNTER    	FRAMEPOINTER	+    0	// 4 byte
#define LOCALSIZE		    4		                // keep aligned
 
#pragma code_seg("IACODE2")
__declspec(naked)
void BlockAdd (U32 uResidual, U32 uRefBlock, U32 uDstBlock)
{		
__asm {
	push    ebp			             ;// save callers frame pointer
	  mov	ebp,esp		             ;// make parameters accessible 
    push    esi			             ;// assumed preserved 
	  push  edi			
    push    ebx 			
	  sub	esp,LOCALSIZE	         ;// reserve local storage 

    mov     edi, uDstBlock           ;// edi gets Base addr of OutputBuffer
      mov   esi, uRefBlock;          ;// esi gets Base addr of Current
    mov     ebp, uResidual           ;// ebp gets Base addr of Reference
      mov   ecx, 8
    xor     eax, eax             

// Cylces counts: 26 x 8=208 without cache miss
//                czhu, 9/25/95
ALIGN 4
loop_for_i:
    mov     [L_LOOPCOUNTER], ecx        ; save loop counter in temporary
      mov   ebx, [ebp+8]                ; 1) fetch current[i+2]
    mov     al, BYTE PTR[esi+2]         ; 1) fetch ref[i+2]
      xor   ecx, ecx                    ; 2)
    mov     cl, BYTE PTR[esi+3]         ; 2) fetch ref[i+3]
      mov   edx, [ebp+12]               ; 2) fetch current[i+3]
    add     eax, ebx                    ; 1) result2 = ref[i+2] + current[i+2]
      xor   ebx, ebx                    ; 3)
    add     ecx, edx                    ; 2) result3= ref[i+3] + current[i+3]
      mov   bl, BYTE PTR[esi]           ; 3) fetch ref[i]
    mov     dl, ClipPixIntra[1024+eax]  ; 1) fetch clamp[result2]
      mov   eax, [ebp]                  ; 3) fetch current[i]
    add     ebx, eax                    ; 3) result0 = ref[i] + current[i]
      xor   eax, eax                    ; 4)
    mov     dh, ClipPixIntra[1024+ecx]  ; 2) fetch clamp[result3]
      mov   al, [esi+1]                 ; 4) fetch ref[i+1]
    shl     edx, 16                     ; move 1st 2 results to high word
      mov   ecx, [ebp+4]                ; 4) fetch current[i+1]
    mov     dl, ClipPixIntra[1024+ebx]  ; 3) fetch clamp[result0]
      add   eax, ecx                    ; 4) result1 = ref[i+1] + current[i+1]
    xor     ecx, ecx                    ; 4+1)
      mov   ebx, [ebp+24]               ; 4+1) fetch current[i+6]
    mov     dh, ClipPixIntra[1024+eax]  ; 4) fetch clamp[result1]
      mov   cl, BYTE PTR[esi+6]         ; 4+1) fetch ref[i+6]
    mov     [edi], edx                  ; store 4 output pixels
      xor   eax, eax                    ; 4+2)
    mov     al, BYTE PTR[esi+7]         ; 4+2) fetch ref[i+7]
      mov   edx, [ebp+28]               ; 4+2) fetch current[i+7]
    add     ecx, ebx                    ; 4+1) result6 = ref[i+6] + current[i+6]
      xor   ebx, ebx                    ; 4+3)
    add     eax, edx                    ; 4+2) result7= ref[i+7] + current[i+7]
      mov   bl, BYTE PTR[esi+4]         ; 4+3) fetch ref[i+4]
    mov     dl, ClipPixIntra[1024+ecx]  ; 4+1) fetch clamp[result6]
      mov   ecx, [ebp+16]               ; 4+3) fetch current[i+4]
    add     ebx, ecx                    ; 4+3) result4 = ref[i+4] + current[i+4]
      xor   ecx, ecx                    ; 4+4)
    mov     dh, ClipPixIntra[1024+eax]  ; 4+2) fetch clamp[result7]
      mov   cl, [esi+5]                 ; 4+4) fetch ref[i+5]
    shl     edx, 16                     ; move 3rd 2 results to high word
      mov   eax, [ebp+20]               ; 4+4) fetch current[i+5]
    add     ecx, eax                    ; 4+4) result5 = ref[i+5] + current[i+5]
      add   esi, PITCH                  ; Update address of next line
    mov     dl, ClipPixIntra[1024+ebx]  ; 4+3) fetch clamp[result4]
      add   ebp, TEMPPITCH4             ; Update address of current to next line
    mov     dh, ClipPixIntra[1024+ecx]  ; 4+4) fetch clamp[result5]
      mov   ecx, [L_LOOPCOUNTER]        ; get loop counter
    mov     [edi+4], edx                ; store 4 output pixels
      add   edi, PITCH                  ; Update address of output to next line
    xor     eax, eax                    ; 1)
      dec   ecx
    jnz     loop_for_i


	add     esp,LOCALSIZE	           // free locals 
     pop	ebx 
	pop     edi
	 pop	esi
	pop     ebp
	 ret   
  }	 //end of asm, BlockAdd

}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1bvriq.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
// $Author:$
// $Date:$
// $Archive:$
// $Header:$
// $Log:$
////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  d1bvriq.cpp
//
//  Description:
//    This routine performs run length decoding and inverse quantization
//    of transform coefficients for one non-empty block.
//
//  Routines:
//    VLD_RLD_IQ_Block
//
//  Inputs (dwords pushed onto stack by caller):
//    lpBlockAction             pointer to Block action stream for current blk.
//
//    lpSrc                     The input bitstream.
//
//    uBitsInOut                Number of bits already read.
//
//    pIQ_INDEX                 Pointer to coefficients and indices.
//
//    pN                        Pointer to number of coefficients read.
//
//  Returns:
//    0              on bit stream error, otherwise total number of bits read
//			(including number read prior to call).
//
//  Note: 
//    This has not been verfied as layout!!!
//          The structure of gTAB_TCOEFF_MAJOR is as follows:
//		bits    name:    description
//		----    -----	 -----------
//		25-18   bits:    number of bitstream bits used
//		17      last:    flag for last coefficient
//		16-9    run:     number of preceeding 0 coefficients plus 1
//		8-2     level:   absolute value of coefficient
//		1       sign:    sign of coefficient
//		0       hit:     1 = major table miss, 0 = major table hit
//
//     The structure of gTAB_TCOEFF_MINOR is the same, right shifted by 1 bit. 
//     A gTAB_TCOEFF_MAJOR value of 00000001h indicates the escape code.
//
//--------------------------------------------------------------------------

//Block level decoding for H.261 decoder
#include "precomp.h"

#define HIGH_FREQ_CUTOFF  6	+ 4

// local variable definitions
#define FRAMEPOINTER        esp
#define L_BITSUSED          FRAMEPOINTER    +    0    // 4 byte
#define L_QUANT             L_BITSUSED      +    4 
#define L_RUNCUM            L_QUANT         +    4
#define L_EVENT             L_RUNCUM        +    4
#define L_BLOCKTYPE         L_EVENT         +    4
#define L_COEFFINDEX        L_BLOCKTYPE     +    4
#define L_INPUTSRC          L_COEFFINDEX    +    4
#define L_LPACTION          L_INPUTSRC      +    4
#define L_ecx               L_LPACTION      +    4
#define L_NUMOFBYTES        L_ecx           +    4
#define L_NUMOFBITS         L_NUMOFBYTES    +    4

#ifdef CHECKSUM_MACRO_BLOCK
  #define L_SAVEREG           L_NUMOFBITS     +    4
  #define L_SAVEREG2          L_SAVEREG       +    4
  #define L_CHECKSUM          L_SAVEREG2      +    4
  #define L_CHECKSUMADDR      L_CHECKSUM      +    4
  #define L_COEFFCOUNT        L_CHECKSUMADDR  +    4
  #define L_COEFFVALUE        L_COEFFCOUNT    +    4
#else
  #define L_COEFFCOUNT        L_NUMOFBITS     +    4
  #define L_COEFFVALUE        L_COEFFCOUNT    +    4
#endif


#define L_END_OF_FRAME      FRAMEPOINTER    +   128  // nothing  
#define LOCALSIZE           ((128+3)&~3)             // keep aligned 

#define HUFFMAN_ESCAPE 0x5f02                        // Huffman escape code

////////////////////////////////////////////////////////////////
// Decode a none empty block
//
////////////////////////////////////////////////////////////////

#pragma code_seg("IACODE1")
extern "C" __declspec(naked)
U32 VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX)
{
    __asm {
        push  ebp                           // save callers frame pointer
        mov   ebp, esp                      // make parameters accessible 
         push esi                           // assumed preserved 
        push  edi            
         push ebx            
        xor   eax, eax        
         xor  edx, edx

        sub   esp, LOCALSIZE                // reserve local storage 
         mov  esi, lpSrc  

#ifdef CHECKSUM_MACRO_BLOCK
        mov   edi, uCheckSum
        ;
        mov   ecx, [edi]
         mov  [L_CHECKSUMADDR], edi
        ;
        mov   [L_CHECKSUM], ecx
#endif
        // zero out the BLOCKSTORE , 64*2 /32 load, 64*2/4 writes
        // it is very likely that the cache has been loaded for 
        // the stack. Need to find out this later.

        mov   edi, lpBlockAction            //pair with operation above
         xor  ecx, ecx

        mov   [L_INPUTSRC], esi
         mov  eax, uBitsread

        mov   [L_LPACTION], edi

         mov  [L_COEFFCOUNT], ecx          // zero out coefficient counter
        mov   [L_COEFFVALUE], ecx          // zero out coefficient value
         mov  [L_NUMOFBYTES], ecx          // zero out number of bytes used

        mov   dl, [edi]T_BlkAction.u8Quant
         mov  cl, al                        // init cl to no. of bits used
                   
        shl   edx, 6                        // leave room for val later, 
                                            // quant*32 shift by 6 because, 
                                            // 5-bits for quant look up & 
                                            // it's a word table.  Don't need 
                                            // to multiply by 2 later
         mov  [L_BITSUSED], eax             // init the counter
        mov   bl, [edi]T_BlkAction.u8BlkType
         mov  edi, pIQ_INDEX                // Load edi with address of output
                                            // array
        mov   [L_QUANT], edx                // save quant for this block;
         mov  [L_BLOCKTYPE], ebx            // save block type
          ;

/////////////////////////////////////////////////////////////////////
// registers: 
//      eax: 4 bytes input bits
//      ebx: block type
//      ecx: bits count
//      edx: quant*64
//      esi: input source
//      edi: output array address
//      ebp: bits count >>4

        mov   DWORD PTR [L_RUNCUM], 0ffh   // Adjust total  run for INTER Blocks

        cmp   bl, 1                        // bl has block type
         ja   ac_coeff                     // jump if not INTRA coded
       
//decode DC first, and invserse quanitzation, 13 clocks
        mov   ah,[esi]
         xor  ebx, ebx
        mov   al,[esi+1]
         mov  DWORD PTR [L_RUNCUM], ebx
        shl   eax, cl
         ;
        and   eax, 0ffffh
         ;
        shr   eax, 8
         ;

#ifdef CHECKSUM_MACRO_BLOCK
        mov   [L_SAVEREG], eax         // save eax in temp
         mov  edi, [L_CHECKSUM]
        shl   eax, 8
        and   eax, 0000ff00h           // just get DC
        ;
        cmp   eax, 0000ff00h           // special case when INTRADC==ff, use 80
        jne   not_255_chk
        mov   eax, 00008000h

not_255_chk:
        add   edi, eax                 // add to DC checksum
        ;
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  eax, [L_SAVEREG]         // restore eax
#endif

        shl   eax, 3                   // INTRADC*8
         xor  ecx, ecx
        cmp   eax, 7f8h                // take out 11111111 code word.
         jne  not_255
        mov   eax, 0400h

not_255:
        mov  ebx, eax                  // inversed quantized DC

        // save in output array value and index
        mov   [edi], eax               // DC inversed quantized value
         mov  [edi+4], ecx             // index 0
        add   edi, 8                   // increment output address

        mov   ecx,[L_COEFFCOUNT]       // get coefficient counter
        mov   ebx,[L_BLOCKTYPE]
         inc  ecx
        mov   [L_COEFFCOUNT], ecx      // save updated coef counter
         mov  ecx,[L_BITSUSED]
        test  bl,bl
         jz   done_dc                   // jump if only the INTRADC present
        add   cl, 8                     // Add 8 to bits used counter for DC
         jmp  vld_code                  // Skip around 1s special case

ac_coeff:
        nop
         mov  ah,[esi]
        mov   al,[esi+1]
         mov  dh,[esi+2]
        shl   eax,16
         mov  dl,[esi+3]
        mov   ax, dx
        shl   eax, cl
         mov  [L_ecx], ecx
        mov   edx, eax                  //save in edx
        shr   eax, 24                   //mask of  high order 24 bits
        ;
        ; // agi
        ;
         mov  bh, gTAB_TCOEFF_tc1a[eax*2]    //get the codewords
        mov   bl, gTAB_TCOEFF_tc1a[eax*2+1]  //get the codewords
         jmp  InFrom1stac

 vld_code:     
        mov   ah,[esi]
         mov  dh,[esi+2]
        mov   al,[esi+1]
         mov  dl,[esi+3]
        shl   eax,16
        mov   ax, dx
        shl   eax, cl
        mov   [L_ecx], ecx
         mov  edx, eax                  //save in edx
        shr   eax, 24                   //mask of  high order 24 bits
        ;
        ; // agi
        ;
        mov   bh, gTAB_TCOEFF_tc1[eax*2]    //get the codewords
        mov   bl, gTAB_TCOEFF_tc1[eax*2+1]  //get the codewords

InFrom1stac:
        mov   ax, bx
         cmp  bx, HUFFMAN_ESCAPE
        mov   [L_EVENT], eax            // 3-bits lenght-1,1-bit if code>8bits,
                                        // 4-bits run,8-bits val
         je   Handle_Escapes

        sar   ax, 12                    // if 12th bit NOT set, code <= 8-bits
        mov   [L_NUMOFBITS], ax         // save for later the number of bits
         js   Gt8bits                   // jump

        mov   eax, [L_EVENT]
         mov  ebx, [L_QUANT]            //bx:4::8 quant has val
        and   eax, 0ffh
        movsx eax, al                   //sign extend level
        add   eax, eax
          jns AROUND                    // if positive jump
        neg   eax                       // convert neg to positive
        inc   eax                       // increment

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in sign to checksum */

        mov   [L_SAVEREG2], edi        // save edi in temp
         mov  edi, [L_CHECKSUM]
        inc  edi                       // add 1 to checksum when sign negative

/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
        mov   eax, [L_EVENT]
        and   eax, 0ffh
        neg   eax
        and   eax, 0ffh
        shl   eax, 8                   // shift level left 8
        add   edi, eax                 // add to level checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
        jmp   NEG_AROUND
#endif

AROUND:

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        mov   eax, [L_EVENT]
        shl   eax, 8                   // shift level left 8
         mov  edi, [L_CHECKSUM]
        and   eax, 0000ff00h           // just get level
        ;
        add   edi, eax                 // add to level checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
NEG_AROUND:
#endif

        mov   bx, gTAB_INVERSE_Q[2*eax+ebx] //ebx has the inverse quant
         mov  eax, [L_EVENT]
        shr   eax, 8                   //leave RUN at al 
        ;
        and   eax, 0fh                 // RUN is just 4-bits

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in run, shift left 24 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        shl   eax, 24                  // shift run left 24
         mov  edi, [L_CHECKSUM]
        add   edi, eax                 // add run to checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
#endif

        mov   edx, [L_RUNCUM]          // Zig-zag and run length decode
         inc  al                       // run+1
        add   dl, al                   // dl cumulated run
        mov   [L_RUNCUM], edx          // update the cumulated run ;
        mov   ecx, gTAB_ZZ_RUN[edx*4] 
         mov   edx, [L_EVENT]          // restore run, level to temp
        movsx ebx,bx        
        and   edx, 0ffh                // get just level    
        add   edx, edx                 // For EOB level will be zero
         jz   last_coeff               // jump to last_coeff if EOB

        // save in output array value and index
        mov   [edi], ebx               // save inversed quantized value
         mov  [edi+4], ecx             // save index 

        mov   ecx,[L_COEFFCOUNT]       // get coefficient counter
        inc   ecx
        mov   [L_COEFFCOUNT], ecx      // save updated coef counter

        mov   ecx, [L_ecx]
         mov  eax, [L_NUMOFBITS]       // fetch num of bits-1
        inc   al
         add  edi, 8                   // increment output address
        add   cl, al                   //adjust bits used,
         mov  ebx, [L_NUMOFBYTES]      // fetch number of bytes used
        test  al, al
         jz   error
        cmp   cl, 16
         jl   vld_code                 //if needs to save ebx, and edx, jump
        add   esi, 2                   //to vld_code to reload 
         inc  ebx                      // increment number of bytes used
        mov   [L_NUMOFBYTES], ebx      // store updated number of bytes used
         ;
        sub   cl, 16
         jmp  vld_code    

/////////
Gt8bits:

// code > 8-bits

        neg   ax                       // -(no of bits -1)
        shl   edx, 8                   // shift of just used 8 bits
         add  ecx, 8                   // Update bit counter by 8
        add   cx, ax                   // Update by extra bits
         and  ebx, 0ffh
        dec   ecx                      // dec because desired value is no of 
                                       //    bits -1
        mov   [L_ecx], ecx             // store
         mov  cl, 32                   // 32
        sub   cl, al                   // get just the extra bits
        shr   edx, cl
        add   bx, dx
         xor  ecx, ecx
        movzx ebx, bx
        shl   edx, 3                   //do this even if hit major
         mov  [L_NUMOFBITS], ecx       // set num of bits for codes > 8 to 0
                                       //   because already updated ecx.
        mov   ah,gTAB_TCOEFF_tc2[ebx*2]//use minor table with 10 bits
        mov   al, gTAB_TCOEFF_tc2[ebx*2+1]
         mov  ebx, [L_QUANT]           //bx:4::8 quant has val
        mov   [L_EVENT], eax
                                       // RLD+ ZZ    and Inverse quantization 
         and  eax, 0ffh
        movsx eax, al                  //sign extend level
        add   eax, eax
         jns  AROUND1                  // if positive jump
        neg   eax                      // convert neg to positive
        inc   eax                      // increment

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in sign to checksum */

        mov   [L_SAVEREG2], edi        // save edi in temp
         mov  edi, [L_CHECKSUM]
        inc  edi                       // add 1 to checksum when sign negative

/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
        mov   eax, [L_EVENT]
        and   eax, 0ffh
        neg   eax
        and   eax, 0ffh
        shl   eax, 8                   // shift level left 8
        add   edi, eax                 // add to level checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
        jmp   NEG_AROUND1
#endif

AROUND1:

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        mov   eax, [L_EVENT]
        shl   eax, 8                   // shift level left 8
         mov  edi, [L_CHECKSUM]
        and   eax, 0000ff00h           // just get level
        ;
        add   edi, eax                 // add to level checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
NEG_AROUND1:
#endif

        mov   bx, gTAB_INVERSE_Q[2*eax+ebx] //ebx has the inverse quant
         mov  eax, [L_EVENT]
        shr   eax, 8                   //leave RUN at al 
        and   eax, 01fh                // RUN is just 5-bits

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in run, shift left 24 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        shl   eax, 24                  // shift run left 24
         mov  edi, [L_CHECKSUM]
        add   edi, eax                 // add run to checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
#endif

         mov  edx, [L_RUNCUM]          //Zig-zag and run length decode
        inc   al                       // run+1
        add   dl, al                   //dl cumulated run
        movsx ebx,bx        
        mov   [L_RUNCUM], edx          //update the cumulated run ;
         mov  ecx, gTAB_ZZ_RUN[edx*4]
        mov   edx, [L_EVENT]           // restore run, level to temp
        and   edx, 0ffh                // get just level    
        add   edx, edx                 // For EOB level will be zero
         jz   last_coeff               // jump to last_coeff if EOB

        // save in output array value and index
        mov   [edi], ebx               // store inversed quantized value
         mov  [edi+4], ecx             // store index 

        mov   ecx,[L_COEFFCOUNT]       // get coefficient counter
        inc   ecx
        mov   [L_COEFFCOUNT], ecx      // save updated coef counter

        mov   ecx, [L_ecx]
         mov  eax, [L_NUMOFBITS]       // fetch num of bits-1
        inc   al
         add  edi, 8                   // increment output address
        add   cl, al                   //adjust bits used,
         mov  ebx, [L_NUMOFBYTES]      // fetch num of bytes used
        test  al, al
         jz   error
        cmp   cl, 16
         jl   vld_code                 //if needs to save ebx, and edx, jump
        add   esi, 2                   //to vld_code to reload 
         inc  ebx                      // increment number of bytes used
        mov   [L_NUMOFBYTES], ebx      // store updated number of bytes used
         ;
        sub   cl, 16
         jmp  vld_code    

 last_coeff:   //need to tell it is INTRA or INTER coded
        mov   ecx, [L_ecx]             // restore no of bits used
         mov  eax, [L_NUMOFBITS]       // get no of bits-1
        inc   al
        add   cl,al                    //update bits used count
        mov   [L_ecx], ecx

#ifdef CHECKSUM_MACRO_BLOCK
        mov   ecx, [L_CHECKSUM]
         mov  edi, [L_CHECKSUMADDR]
        mov   [edi], ecx
#endif
//      Add in High Frequency Cutoff check
//
        mov   eax, [L_RUNCUM]          // Total run 
         mov  edx, [L_LPACTION]            //pair with operation above
	cmp   eax, HIGH_FREQ_CUTOFF
         jg   No_set

        mov   bl, [edx]T_BlkAction.u8BlkType
        or    bl, 80h                     // set hi bit
        mov   [edx]T_BlkAction.u8BlkType, bl

//
No_set:
        mov   eax, pN
        mov   ecx,[L_COEFFCOUNT]       // get coefficient counter
        mov   [eax], ecx               // return number of coef
//akk
        mov   edi,[L_NUMOFBYTES]
         mov  eax,[L_ecx]
        shl   edi, 4                   // convert bytes used to bits used
        add   esp,LOCALSIZE            // free locals          
         add  eax,edi                  // add bits used to last few bits used
        pop   ebx
         pop  edi
        pop   esi
         pop  ebp
        ret
                
error:  
#ifdef CHECKSUM_MACRO_BLOCK
        mov   ecx, [L_CHECKSUM]
         mov  edi, [L_CHECKSUMADDR]
        mov   [edi], ecx
#endif
        xor   eax,eax
         add  esp,LOCALSIZE            // free locals 
        pop   ebx
         pop  edi
        pop   esi
         pop  ebp
        ret
            
        //NOTES: 1. the following codes need to be optimized later.
        //       2. the codes will be rarely used. 
        //          at this point: eax has 32bits - cl valid bits
        //          first cl+7 bits 
Handle_Escapes:                        //process escape code separately
        add   cl, 6                    // escape 6-bit code
         mov  ebx, [L_NUMOFBYTES]      // fetch number of bytes used
        cmp   cl, 16
         jl   less_16
        add   esi, 2
         sub  cl, 16
        inc   ebx                      // increment number of bytes used
         mov  [L_NUMOFBYTES], ebx      // store updated number of bytes used
less_16:
        mov   ah,[esi]                 // these codes will be further
         mov  dh,[esi+2]
        mov   al,[esi+1]
         mov  dl,[esi+3]
        shl   eax,16
         mov  ebx, [L_RUNCUM]
        mov   ax, dx
         inc  bl                       //increae the total run
        shl   eax, cl
        mov   edx,eax
        shr   eax, 32-6                //al has run

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in run, shift left 24 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        shl   eax, 24                  // shift run left 24
         mov  edi, [L_CHECKSUM]
        add   edi, eax                 // add run to checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
#endif

        shl   edx, 6                   // cl < 6, cl+6 < 16
         add  al,bl
        sar   edx, 32-8                //8 bits level, keep the sign
          mov [L_RUNCUM], eax
        ;  // agi
        ;
        mov    ebx, gTAB_ZZ_RUN[eax*4] //run length decode
         mov   eax, [L_QUANT]          //bx:4::8 quant has val
        shr    eax, 6                  //recover quant
         mov   [L_COEFFINDEX], ebx

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], edx         // save edx in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        mov  edi, [L_CHECKSUM]
		cmp   edx, 0				   // test level
         jns  Pos_Level
        neg   edx
         inc  edi                      // add 1 when sign negative
Pos_Level:
        shl   edx, 8                   // shift level left 8
        and   edx, 0000ff00h           // just get level
        ;
        add  edi, edx                  // add to level checksum
         mov  edx, [L_SAVEREG]         // restore edx
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
#endif

// new code
        test  edx, 7fh                 // test for invalid codes
         jz   error
        imul  edx, eax                 // edx = L*Q
         ;
        dec   eax                      // Q-1
         mov  ebx, edx                 // mask = LQ
        sar   ebx, 31                  // -l if L neq, else 0
         or   eax, 1                   // Q-1 if Even, else Q 
        xor   eax, ebx                 // -Q[-1] if L neg, else = Q[-1]
         add  edx, edx                 // 2*L*Q
        sub   eax, ebx                 // -(Q[-1]) if L neg, else = Q[-1]
         add  edx, eax                 // 2LQ +- Q[-1]

// now clip to -2048 ... +2047 (12 bits: 0xfffff800 <= res <= 0x000007ff)
        cmp   edx, -2048
         jge  skip1
        mov   edx, -2048
         jmp  run_zz_q_fixed
skip1:
        cmp   edx, +2047
         jle  run_zz_q_fixed
        mov   edx, +2047

run_zz_q_fixed:
        mov ebx, [L_COEFFINDEX]

        // save in output array value and index
         mov  [edi], edx               // save inversed quantized value
        mov   [edi+4], ebx             // save index 

        mov   ebx,[L_COEFFCOUNT]       // get coefficient counter
        inc   ebx
        mov   [L_COEFFCOUNT], ebx      // save updated coef counter

         add  cl, 14
        add   edi, 8                   // increment output address
         mov  ebx, [L_NUMOFBYTES]      // fetch number of bytes used
        cmp   cl, 16
         jl   vld_code
        add   esi, 2
         sub  cl, 16
        inc   ebx                      // increment number of bytes used
         mov  [L_NUMOFBYTES], ebx      // store updated number of bytes used
        jmp   vld_code

        // 18 clocks without cache misses in the inner loop for
        // the most frequenctly used events 8/2/95
        // the above numbers changed becuase of integration with
        // bitstream parsing and IDCT. 8/21/95
        
done_dc://intra coded block
        add ecx, 8                      

#ifdef CHECKSUM_MACRO_BLOCK
        mov   ecx, [L_CHECKSUM]
         mov  edi, [L_CHECKSUMADDR]
        mov   [edi], ecx
#endif
//      Add in High Frequency Cutoff check
//
        mov   edx, [L_RUNCUM]          // Total run 
         mov  eax, lpBlockAction            //pair with operation above
	cmp   edx, HIGH_FREQ_CUTOFF
         jg   No_set_Intra

        mov   bl, [eax]T_BlkAction.u8BlkType
        or    bl, 80h                     // set hi bit
        mov   [eax]T_BlkAction.u8BlkType, bl

//
No_set_Intra:
        mov   eax, pN
        mov   ebx,[L_COEFFCOUNT]       // get coefficient counter
        mov   [eax], ebx               // return number of coef

         add  esp,LOCALSIZE            // free locals 
        mov   eax,ecx        
         pop  ebx
        pop   edi
         pop  esi
        pop   ebp
        ret
    } //end of asm

} // end of VLD_RLD_IQ_Block
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1blkcpy.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   AKASAI  $
// $Date:   15 Mar 1996 08:48:06  $
// $Archive:   S:\h26x\src\dec\d1blkcpy.cpv  $
// $Header:   S:\h26x\src\dec\d1blkcpy.cpv   1.0   15 Mar 1996 08:48:06   AKASAI  $
// $Log:   S:\h26x\src\dec\d1blkcpy.cpv  $
// 
//    Rev 1.0   15 Mar 1996 08:48:06   AKASAI
// Initial revision.
//
//    Rev 1.3   31 Jan 1996 13:15:14   RMCKENZX
// Rewrote file to avoid bank conflicts.  Fully unrolled the loop.
// Module now really will execute in 52 cycles if the cache is hot.
// 
//    Rev 1.2   22 Dec 1995 13:51:06   KMILLS
// added new copyright notice
// 
//    Rev 1.1   25 Sep 1995 09:03:22   CZHU
// Added comments on cycle counts
// 
//    Rev 1.0   11 Sep 1995 16:52:26   CZHU
// Initial revision.
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
// BlockCopy reads reference in BYTES and writes DWORDS.  Read of BYTES
//   is to avoid data alignment problems from motion compensated previous.
//
// Input  U8  *reference (Motion Compensated address of reference)
// Output U8  *output  (Output buffer)
//
// Registers used: 
//	eax			source address
//  ebx         temp
//	ecx, edx	accumulators
//	edi			destination address
//  esi         PITCH
//
// Assumption:  reference and output use PITCH 
//
// Cycle count:  
//
//------------------------------------------------------------------------------

#include "precomp.h"

#pragma code_seg("IACODE2")
__declspec(naked)
void BlockCopy (U32 uDstBlock, U32 uSrcBlock)
{		
__asm {
	mov 	eax, [esp+8]			// eax gets Base addr of uSrcBlock
	 push 	edi			
	push    esi						// avoid Address Generation Interlocks
     push   ebx

	mov 	cl, 2[eax]				// ref[0][2]
	 mov 	edi, [esp+16]			// edi gets Base addr of uDstBlock
    mov     ch, 3[eax]				// ref[0][3]
	 mov 	dh, 7[eax]				// ref[0][7]
    shl 	ecx, 16
	 mov 	dl, 6[eax]				// ref[0][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov     esi, PITCH
	 mov 	cl, 0[eax]				// ref[0][0]
	mov 	dh, 5[eax]				// ref[0][5]
	 mov 	ch, 1[eax]				// ref[0][1]
 	mov 	dl, 4[eax]				// ref[0][4]
     add    eax, esi
 	mov 	0[edi], ecx				// row 0, bytes 0-3
	 mov 	4[edi], edx				// row 0, bytes 4-7

	mov 	cl, 2[eax]      		// ref[1][2]
	 mov 	dh, 7[eax]      		// ref[1][7]
    mov     ch, 3[eax]      		// ref[1][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dl, 6[eax]      		// ref[1][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov 	cl, 0[eax]      		// ref[1][0]
	 mov 	dh, 5[eax]      		// ref[1][5]
	mov 	ch, 1[eax]      		// ref[1][1]
 	 mov 	dl, 4[eax]      		// ref[1][4]
    add     eax, esi
 	 mov 	0[edi], ecx			// row 1, bytes 0-3
 
	mov 	cl, 2[eax]        		// ref[2][2]
	 mov 	4[edi], edx			// row 1, bytes 4-7
    mov     ch, 3[eax]        		// ref[2][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dh, 7[eax]        		// ref[2][7]
	mov 	dl, 6[eax]        		// ref[2][6]
     mov    ebx, [edi]              // heat output cache
	shl 	edx, 16
	 mov 	cl, 0[eax]        		// ref[2][0]
	mov 	dh, 5[eax]        		// ref[2][5]
	 mov 	ch, 1[eax]        		// ref[2][1]
 	mov 	dl, 4[eax]        		// ref[2][4]
     add    eax, esi
 	mov 	0[edi], ecx		// row 2, bytes 0-3
	 mov 	4[edi], edx		// row 2, bytes 4-7

	mov 	cl, 2[eax]        		// ref[3][2]
	 mov 	dh, 7[eax]        		// ref[3][7]
    mov     ch, 3[eax]        		// ref[3][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dl, 6[eax]        		// ref[3][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov 	cl, 0[eax]        		// ref[3][0]
	 mov 	dh, 5[eax]        		// ref[3][5]
	mov 	ch, 1[eax]        		// ref[3][1]
 	 mov 	dl, 4[eax]        		// ref[3][4]
    add     eax, esi
 	 mov 	0[edi], ecx		// row 3, bytes 0-3
 
	mov 	cl, 2[eax]        		// ref[4][2]
	 mov 	4[edi],edx		// row 3, bytes 4-7
    mov     ch, 3[eax]        		// ref[4][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dh, 7[eax]        		// ref[4][7]
	mov 	dl, 6[eax]        		// ref[4][6]
     mov    ebx, [edi]              // heat output cache
	shl 	edx, 16
	 mov 	cl, 0[eax]        		// ref[4][0]
	mov 	dh, 5[eax]        		// ref[4][5]
	 mov 	ch, 1[eax]        		// ref[4][1]
 	mov 	dl, 4[eax]        		// ref[4][4]
     add    eax, esi
 	mov 	0[edi], ecx		// row 4, bytes 0-3
	 mov 	4[edi], edx		// row 4, bytes 4-7

	mov 	cl, 2[eax]        		// ref[5][2]
	 mov 	dh, 7[eax]        		// ref[5][7]
    mov     ch, 3[eax]        		// ref[5][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dl, 6[eax]        		// ref[5][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov 	cl, 0[eax]        		// ref[5][0]
	 mov 	dh, 5[eax]        		// ref[5][5]
	mov 	ch, 1[eax]        		// ref[5][1]
 	 mov 	dl, 4[eax]        		// ref[5][4]
    add     eax, esi
 	 mov 	0[edi], ecx		// row 5, bytes 0-3

	mov 	cl, 2[eax]        		// ref[6][2]
	 mov 	4[edi], edx		// row 5, bytes 4-7
    mov     ch, 3[eax]        		// ref[6][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dh, 7[eax]        		// ref[6][7]
	mov 	dl, 6[eax]        		// ref[6][6]
     mov    ebx, [edi]              // heat output cache
	shl 	edx, 16
	 mov 	cl, 0[eax]        		// ref[6][0]
	mov 	dh, 5[eax]        		// ref[6][5]
	 mov 	ch, 1[eax]        		// ref[6][1]
 	mov 	dl, 4[eax]        		// ref[6][4]
     add    eax, esi
 	mov 	0[edi], ecx		// row 6, bytes 0-3
	 mov 	4[edi], edx		// row 6, bytes 4-7

	mov 	cl, 2[eax]        		// ref[7][2]
	 mov 	dh, 7[eax]        		// ref[7][7]
    mov     ch, 3[eax]        		// ref[7][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dl, 6[eax]        		// ref[7][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov 	cl, 0[eax]        		// ref[7][0]
	 mov 	dh, 5[eax]        		// ref[7][5]
	mov 	ch, 1[eax]        		// ref[7][1]
 	 mov 	dl, 4[eax]        		// ref[7][4]
 	mov 	0[edi], ecx		// row 7, bytes 0-3
	 mov 	4[edi], edx		// row 7, bytes 4-7

    pop     ebx
	 pop    esi
	pop 	edi
	 ret
	    
  }	 // end of asm BlockCopy
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1coltbl.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
////////////////////////////////////////////////////////////////////////////
//
// D1COLTBL.H - The color tables need to be declared here in order that the
//              assembly object files can find them.  If they are declared
//              in a CPP file the names will be mangled.   This table was
//				taken from part of MRV's COLOR.C.
//
// $Header:   S:\h26x\src\dec\d1coltbl.h_v   1.4   14 Feb 1996 11:57:02   AKASAI  $
//
// $Log:   S:\h26x\src\dec\d1coltbl.h_v  $
;// 
;//    Rev 1.4   14 Feb 1996 11:57:02   AKASAI
;// 
;// Update for fix to color convertor palette flash.
;// 
;//    Rev 1.3   09 Jan 1996 09:41:52   AKASAI
;// Updated copyright notice.
;// 
;//    Rev 1.2   15 Nov 1995 14:23:00   AKASAI
;// New tables for 12-bit color converters.  Copied with file name changes
;// directly from d3coltbl files.
;// (Integration point)
;// 
;//    Rev 1.5   03 Nov 1995 11:49:46   BNICKERS
;// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
;// 
;//    Rev 1.4   30 Oct 1995 17:15:40   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.3   27 Oct 1995 17:30:58   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.2   26 Oct 1995 18:54:40   BNICKERS
;// Fix color shift in recent YUV12 to RGB color convertors.
;// 
;//    Rev 1.1   25 Oct 1995 18:05:46   BNICKERS
;// 
;// Change to YUV12 color convertors.
;// 
;//    Rev 1.0   23 Aug 1995 12:35:12   DBRUCKS
;// Initial revision.

#ifndef __D1COLTBL_H__
#define __D1COLTBL_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
	   
U32 UVDitherLine01[64];
U32 UVDitherLine23[64];
U8  YDither[262];
U8  Padding1[26];
U32 YDitherZ2[256];
#ifdef WIN32
U8  RValLo555[304];
U8  GValLo555[262];
U8  BValLo555[350];
U8  RValHi555[304];
U8  GValHi555[262];
U8  BValHi555[350];
U8  Padding2[216];
U8  RValLo565[304];
U8  GValLo565[262];
U8  BValLo565[350];
U8  RValHi565[304];
U8  GValHi565[262];
U8  BValHi565[350];
U8  Padding3[216];
U8  RValLo655[304];
U8  GValLo655[262];
U8  BValLo655[350];
U8  RValHi655[304];
U8  GValHi655[262];
U8  BValHi655[350];
U8  Padding4[216];
U8  RValLo664[304];
U8  GValLo664[262];
U8  BValLo664[350];
U8  RValHi664[304];
U8  GValHi664[262];
U8  BValHi664[350];
U8  Padding5[24];
U32 UVContrib[512];
U32 RValZ2555[304];
U32 GValZ2555[262];
U32 BValZ2555[350];
U32 Padding6[108];
U32 RValZ2565[304];
U32 GValZ2565[262];
U32 BValZ2565[350];
U32 Padding7[108];
U32 RValZ2655[304];
U32 GValZ2655[262];
U32 BValZ2655[350];
U32 Padding8[108];
U32 RValZ2664[304];
U32 GValZ2664[262];
U32 BValZ2664[350];
U8  Padding9[16];
U8  B24Value[701];
U8  Padding10[3];
U32 UV24Contrib[512];
#endif
int dummy;

} T_H26xColorConvertorTables;

extern T_H26xColorConvertorTables H26xColorConvertorTables;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1color.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//
//  D1COLOR.CPP - the color conveter interface routines.  This code was
//				  copied from COLOR.C in MRV.

// $Header:   S:\h26x\src\dec\d1color.cpv   1.15   11 Dec 1996 17:47:14   MBODART  $
//
// $Log:   S:\h26x\src\dec\d1color.cpv  $
// 
//    Rev 1.15   11 Dec 1996 17:47:14   MBODART
// For consistency with d3color.cpp, fixed an unitialized variable bug in
// YUV_Init and YUY2_Init.  This bug never showed up in H.261 because when
// we allocate the decoder catalog, we zero its memory.  H.263 does not do thi
// so failure to initialize CCOffsetToLine0 to 0 was biting them.
// 
//    Rev 1.14   18 Nov 1996 17:12:06   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.13   29 Oct 1996 13:49:12   MDUDA
// Added support for MMX version of YUY2 output color converter.
// 
//    Rev 1.12   26 Sep 1996 12:32:18   RHAZRA
// Added MMX and PentiumPro CCs to the CC catalog.
// 
//    Rev 1.11   16 Sep 1996 10:05:14   RHAZRA
// Fixed a bug in RGB32_InitColorConvertor's heap allocation call.
// 
//    Rev 1.10   12 Sep 1996 14:23:14   MBODART
// Replaced GlobalAlloc family with HeapAlloc in the H.261 decoder.
// 
//    Rev 1.9   14 Aug 1996 08:40:36   RHAZRA
// Added YUV12 (ASM) and YUY2 color convertors
// 
//    Rev 1.8   05 Aug 1996 15:59:36   RHAZRA
// 
// Added RGB32 CC's to CC table; added RGB32 initialization function.
// 
// 
//    Rev 1.7   10 Jul 1996 08:21:08   SCDAY
// Added support for I420
// 
//    Rev 1.6   26 Feb 1996 09:35:26   AKASAI
// Changes made to d1color.cpp to correspond with new cx512162.asm
// Initial testing is strange.  Not ready to move tip at this time.
// 
//    Rev 1.5   14 Feb 1996 11:56:02   AKASAI
// 
// Update color convertor to fix palette flash problem.
// 
//    Rev 1.4   22 Dec 1995 14:24:32   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.3   17 Nov 1995 15:21:22   BECHOLS
// Added ring 0 stuff.
// 
//    Rev 1.2   15 Nov 1995 14:34:56   AKASAI
// New routine to support YUV12 color converters.  Copied for d3color.cpp.
// (Integration point)
// 
//    Rev 1.10   03 Nov 1995 11:49:42   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.9   31 Oct 1995 11:48:42   TRGARDOS
// 
// Fixed exception by not trying to free a zero handle.
// 
//    Rev 1.8   30 Oct 1995 17:15:36   BNICKERS
// Fix color shift in RGB24 color convertors.
// 
//    Rev 1.7   27 Oct 1995 17:30:56   BNICKERS
// Fix RGB16 color convertors.
// 
//    Rev 1.6   26 Oct 1995 18:54:38   BNICKERS
// Fix color shift in recent YUV12 to RGB color convertors.
// 
//    Rev 1.5   26 Oct 1995 11:24:34   BNICKERS
// Fix quasi color convertor for encoder's decoder;  bugs introduced when
// adding YUV12 color convertors.
// 
//    Rev 1.4   25 Oct 1995 18:05:30   BNICKERS
// 
// Change to YUV12 color convertors.
// 
//    Rev 1.3   19 Sep 1995 16:04:08   DBRUCKS
// changed to yuv12forenc
// 
//    Rev 1.2   28 Aug 1995 17:45:58   DBRUCKS
// add yvu12forenc
// 
//    Rev 1.1   25 Aug 1995 13:58:04   DBRUCKS
// integrate MRV R9 changes
// 
//    Rev 1.0   23 Aug 1995 12:21:48   DBRUCKS
// Initial revision.

// Notes:
// * The H26X decoders use the MRV color converters.  In order to avoid 
//   unnecessary modification the function names were not changed.

#include "precomp.h"

static LRESULT ComputeDynamicClut(unsigned char BIGG *table, unsigned char FAR *APalette, int APaletteSize);

// The table of color converters.  
//
// Note: The YVU12ForEnc color converter is special as it needs different parameters.
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
  { &H26X_YVU12ForEnc_Init,
    { NULL,      			NULL,			        NULL			       }},	   
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,        &YUV12ToCLUT8,          &YUV12ToCLUT8          }},
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,        &YUV12ToCLUT8,          &YUV12ToCLUT8          }},
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &YUV12ToCLUT8ZoomBy2   }},
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &YUV12ToCLUT8ZoomBy2   }},
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,        &YUV12ToRGB24,          &YUV12ToRGB24          }},
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,        &YUV12ToRGB24,          &YUV12ToRGB24          }},
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &YUV12ToRGB24ZoomBy2   }},
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &YUV12ToRGB24ZoomBy2   }},
  { &H26X_RGB16_Init,   // 555
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_CLUT8_Init,
    { &YUV12ToIF09,         &YUV12ToIF09,           &YUV12ToIF09           }},
  { &H26X_RGB16_Init,   // 664
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
    
  { &H26X_RGB16_Init,   // 565
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
    
  { &H26X_RGB16_Init,   // 655
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
 
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8AP,      &YUV12ToCLUT8AP,        &YUV12ToCLUT8AP        }},
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2
    }},
/* for RGB32 color convertors */
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,        &YUV12ToRGB32,          &YUV12ToRGB32          }},
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,        &YUV12ToRGB32,          &YUV12ToRGB32          }},
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &YUV12ToRGB32ZoomBy2   }},
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &YUV12ToRGB32ZoomBy2   }},
/* for YUV12 output */
  { &H26X_YUV_Init, // this is for YUV12 output ("NoColorConversion")
    { &YUV12ToYUV,			&YUV12ToYUV,			&YUV12ToYUV	}},
/* DDRAW YUY2 ouput */
	{	&H26X_YUY2_Init,
	{ &YUV12ToYUY2,         &YUV12ToYUY2,           &YUV12ToYUY2           }}
};

/*******************************************************************************

H263InitColorConvertorGlobal -- This function initializes the global tables used
                               by the MRV color convertors.  Note that in 16-bit
                               Windows, these tables are copied to the
                               per-instance data segment, so that they can be
                               used without segment override prefixes.  In
                               32-bit Windows, the tables are left in their
                               staticly allocated locations.

*******************************************************************************/

LRESULT H263InitColorConvertorGlobal ()
{
LRESULT ret;

  ret = ICERR_OK;

  return ret;
}


/*******************************************************************************

H26X_Adjust_Init -- This function builds the adjustment tables for a
    particular instance of a color convertor based on values in the
    decoder instance to which this color convertor instance is attached.
    The external functions are located in CONTROLS.C. -BEN-

*******************************************************************************/
extern LRESULT CustomChangeBrightness(LPDECINST, BYTE);
extern LRESULT CustomChangeContrast(LPDECINST, BYTE);
extern LRESULT CustomChangeSaturation(LPDECINST, BYTE);

LRESULT H26X_Adjust_Init(LPDECINST lpInst, T_H263DecoderCatalog FAR *DC)
{
LRESULT lRet=ICERR_OK;
  lRet = CustomChangeBrightness(lpInst, (BYTE)DC->BrightnessSetting);
  lRet |= CustomChangeContrast(lpInst, (BYTE)DC->ContrastSetting);
  lRet |= CustomChangeSaturation(lpInst, (BYTE)DC->SaturationSetting);

return(lRet);
}

/*******************************************************************************

H263InitColorConvertor -- This function initializes a color convertor.

*******************************************************************************/

LRESULT H263InitColorConvertor(LPDECINST lpInst, UN ColorConvertor)
{    
  LRESULT ret=ICERR_OK;
  T_H263DecoderCatalog FAR * DC;

  DBOUT("H263InitColorConvertor...\n");     

  if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
  {
    DBOUT("ERROR :: H263InitColorConvertor :: ICERR_BADPARAM");
    return ICERR_BADPARAM;
  }
  if(lpInst->Initialized == FALSE)
  {
    DBOUT("ERROR :: H263InitColorConvertor :: ICERR_ERROR");
    return ICERR_ERROR;
  }
  DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

 // trick the compiler to pass instance info to the color convertor catalog.
  if (ColorConvertor== CLUT8APDCI || ColorConvertor== CLUT8APZoomBy2DCI) 
   {// check whether this AP instance is the previous 
    if ((ColorConvertor == DC->iAPColorConvPrev) && (DC->pAPInstPrev !=NULL) && lpInst->InitActivePalette)
      { //??? check whether the palette is still the same;
        //DC->a16InstPostProcess = DC->pAPInstPrev;
        ret= H26X_CLUT8AP_InitReal(lpInst,DC, ColorConvertor, TRUE); 
        DBOUT("Decided to use previous AP Instance...");
      }
      else
        ret= H26X_CLUT8AP_InitReal(lpInst,DC, ColorConvertor, FALSE); 
   }
   else  
    ret = ColorConvertorCatalog[ColorConvertor].Initializer (DC, ColorConvertor);
 
  if (ColorConvertor != YUV12ForEnc && ColorConvertor != YUV12NOPITCH)
    ret |= H26X_Adjust_Init(lpInst, DC);
  DC->ColorConvertor = ColorConvertor;

  return ret;
}

/*******************************************************************************

H263TermColorConvertor -- This function deallocates a color convertor.

*******************************************************************************/

LRESULT H263TermColorConvertor(LPDECINST lpInst)
{    
  T_H263DecoderCatalog FAR * DC;
  
  DBOUT("H263TermColorConvertor.....TERMINATION...\n");
  
  if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
  {
    DBOUT("ERROR :: H263TermColorConvertor :: ICERR_BADPARAM");
    return ICERR_BADPARAM;
  }
  if(lpInst->Initialized == FALSE)
  {
    DBOUT("ERROR :: H263TermColorConvertor :: ICERR_ERROR");
    return ICERR_ERROR;
  }
  DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
  // save the active palette instance for future use
  if (DC->ColorConvertor == CLUT8APDCI || DC->ColorConvertor ==  CLUT8APZoomBy2DCI)
  {
    DC->iAPColorConvPrev = DC->ColorConvertor;
    DC->pAPInstPrev = DC->a16InstPostProcess;
    DBOUT("Saved Previous AP instance...");    
  }
  else
  {
    if(DC->a16InstPostProcess != NULL)
    {
      HeapFree(GetProcessHeap(),0,DC->a16InstPostProcess);
      DC->a16InstPostProcess = NULL;
    }
  }

  DC->p16InstPostProcess = NULL;
  DC->ColorConvertor = 0;  

  return ICERR_OK;
}

/* *********************************************************************
   H26x_YUY2_Init function
   ********************************************************************* */

LRESULT H26X_YUY2_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
LRESULT ret;

//int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;
int  i;
U8   FAR  * InitPtr;

  switch (ColorConvertor)
  {
    case YUY2DDRAW:
      
      //IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOffsetToLine0 = 0;
      DC->CCOutputPitch   = 0;
        // Seems to me that DC->CCOutputPitch is never used, for any
        // color convertor.
      break;

    
    default:
      DBOUT("ERROR :: H26X_YUY2_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                 Sz_SpaceBeforeYPlane :
                 Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_RGB32_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.
*/

  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

/*
   Space for BEFApplicationList.
*/

  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
  
/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

ret = ICERR_OK;

done:  

return ret;


}



/* *********************************************************************
   H26x_YUV_Init function
   ********************************************************************* */

LRESULT H26X_YUV_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
LRESULT ret;

//int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;
int  i;
U8   FAR  * InitPtr;

  switch (ColorConvertor)
  {
    case YUV12NOPITCH:
      
      //IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOffsetToLine0 = 0;
      DC->CCOutputPitch   = 0;
        // Seems to me that DC->CCOutputPitch is never used, for any
        // color convertor.
      break;

    
    default:
      DBOUT("ERROR :: H26X_YUV_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                 Sz_SpaceBeforeYPlane :
                 Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_YUV_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.
*/

  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

/*
   Space for BEFApplicationList.
*/

  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
  
/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

ret = ICERR_OK;

done:  

return ret;


}



/*******************************************************************************

H26X_CLUT8_Init -- This function initializes for the CLUT8 color convertors.

*******************************************************************************/

LRESULT H26X_CLUT8_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{    
LRESULT ret;

int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;

int  i;
U8   FAR  * InitPtr;
#ifdef WIN32
#else
U8   FAR  * PQuantV;
U8   FAR  * PQuantU;
U32  FAR  * PUVDitherPattern;
U32  FAR  * PYDithered0132;
#endif

  switch (ColorConvertor)
  {
    case CLUT8:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 1568;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break;

    case CLUT8DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 1568;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break;

    case CLUT8ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 1568;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
      break;

    case CLUT8ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 1568;
      DC->CCOutputPitch   = - 9999 * 2; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
      break;
      
    case IF09:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 1296;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break; 

    default:
      DBOUT("ERROR :: H26X_CLUT8_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

#ifdef WIN32
  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
  Sz_FixedSpace = CLUT8SizeOf_FixedPart();             /* Space for locals. */
  Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */
  Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */   //fixfix
  Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                          ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?                //fixfix
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_CLUT8_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames, with one extra max-width line
   above for color conversion's scratch space for UVDitherPattern indices.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only copied for 16-bit Windows (tm)).
*/

#ifdef WIN32
  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
  DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

#ifdef WIN32
  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
#else
  DC->X32_BEFApplicationList = Offset;
  Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
            ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif
  
  

/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

/*
   Space for U and V quant.  Init them.
*/

#ifdef WIN32
#else
  PQuantU   = (U8  FAR *) (DC->p16InstPostProcess + CLUT8Offset_QuantU());
  PQuantV   = (U8  FAR *) (DC->p16InstPostProcess + CLUT8Offset_QuantV());
  for (i = 0; i < 256; i++)
  {
    PQuantU  [i]   = H26xColorConvertorTables.QuantU  [i];
    PQuantV  [i]   = H26xColorConvertorTables.QuantV  [i];
  }
  PUVDitherPattern =
    (U32 FAR *) (DC->p16InstPostProcess + CLUT8Offset_UVDitherPattern());
  for (i = 0; i < 324; i++)
    PUVDitherPattern[i] =
      ((U32 FAR *) (H26xColorConvertorTables.UVDitherPattern))[i];
#endif

/*
   Space for luma dither patterns for zoom-by-2 color convertor.
   Pattern 6204 is interleaved with pattern 04__.  Pattern 62__ is alone.
*/

#ifdef WIN32
#else
  PYDithered0132 =
    (U32 FAR *) (DC->p16InstPostProcess + CLUT8Offset_YDithered0132());
  for (i = 0; i < 256; i++)
    PYDithered0132[i] = H26xColorConvertorTables.YDithered0132[i];
#endif

ret = ICERR_OK;

done:  

return ret;

}

/*******************************************************************************

H26X_RGB24_Init -- This function initializes for the RGB24 color convertors.

*******************************************************************************/

LRESULT H26X_RGB24_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
LRESULT ret;

int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;

U8   FAR  * PRGBValue;
U32  FAR  * PUVContrib;
int   i;
I32  ii,jj;
U8   FAR  * InitPtr;

  switch (ColorConvertor)
  {
    case RGB24:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 3;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 3L;
      break;

    case RGB24DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 3L;
      break;

    case RGB24ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 4640;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 9;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 3L;
      break;

    case RGB24ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 4640;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 3L;
      break;

    default:
      DBOUT("ERROR :: H26X_RGB24_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

#ifdef WIN32
  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
  Sz_FixedSpace = RGB24SizeOf_FixedPart();             /* Space for locals. */
  Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */
  Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */
  Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                          ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_RGB24_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames, with four extra max-width lines
   above for color conversion's scratch space for preprocessed chroma data.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only copied for 16-bit Windows (tm)).
*/

#ifdef WIN32
  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
  DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

#ifdef WIN32
  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
#else
  DC->X32_BEFApplicationList = Offset;
  Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
            ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

  
/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

/*
   Space for R, G, and B clamp tables and U and V contribs to R, G, and B.
*/

#ifdef WIN32
  PRGBValue    = H26xColorConvertorTables.B24Value;
  PUVContrib   = (U32 *) H26xColorConvertorTables.UV24Contrib;
#else
  PRGBValue    = (U8  FAR *) (DC->p16InstPostProcess+RGB24Offset_B24Value());
  PUVContrib   = (U32 FAR *) (DC->p16InstPostProcess+RGB24Offset_UV24Contrib());
#endif

/*
 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
 *
 * The formulae published by the CCIR committee for
 *      Y        = 16..235
 *      U & V    = 16..240
 *      R, G & B =  0..255 are:
 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
 *
 * The coefficients are all multiplied by 65536 to accomodate integer only
 * math.
 *
 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
 *
 * Mathematically this is equivalent to (and computationally this is nearly
 * equivalent to):
 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
 *
 * which, in integer arithmetic, and eliminating the insignificant parts, is:
 *
 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
*/

  for (i = 0; i < 256; i++)
  {
    ii = ((-22015L*(i-128L))>>16L)+41L  + 1L;  /* biased U contribution to G. */
    if (ii < 1) ii = 1;
    if (ii > 83) ii = 83;
    jj = ((113562L*(i-128L))>>17L)+111L + 1L;  /* biased U contribution to B. */
    *PUVContrib++ = (ii << 16L) + (jj << 24L);
    ii = ((-45774L*(i-128L))>>16L)+86L;        /* biased V contribution to G. */
    if (ii < 0) ii = 0;
    if (ii > 172) ii = 172;
    jj = (( 89858L*(i-128L))>>16L)+176L + 1L;  /* biased V to contribution R. */
    *PUVContrib++ = (ii << 16L) + jj;
  }

  for (i = 0; i < 701; i++)
  {
    ii = (((I32) i - 226L - 16L) * 610271L) >> 19L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    PRGBValue[i] = (U8) ii;
  }

ret = ICERR_OK;

done:  

return ret;

}

/*******************************************************************************
 *  H26X_RGB32_Init
 *    This function initializes for the RGB32 color convertors.
 *******************************************************************************/
LRESULT H26X_RGB32_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
  LRESULT ret;

  int  IsDCI;
  U32  Sz_FixedSpace;
  U32  Sz_SpaceBeforeYPlane;
  U32  Sz_AdjustmentTables;
  U32  Sz_BEFApplicationList;
  U32  Sz_BEFDescrCopy;
  U32  Offset;

  U8   FAR  * PRGBValue;
  U32  FAR  * PUVContrib;
  int   i;
  I32  ii,jj;
  U8   FAR  * InitPtr;

  switch (ColorConvertor)
  {
    case RGB32:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 4L;
//      DC->CCOffset320x240 = 305920;     // (240-1) * 320 * 4;
      break;

    case RGB32DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 4L;
  //    DC->CCOffset320x240 = 305920;     // (240-1) * 320 * 4;
      break;

    case RGB32ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 12;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 4L;
    //  DC->CCOffset320x240 = 1226240;    // (2*240-1) * (2*320) * 4;
      break;

    case RGB32ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOutputPitch   = (U16) (0xbeef);
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 4L;
   //   DC->CCOffset320x240 = 1226240;    // (2*240-1) * (2*320) * 4;
      break;

    default:
      DBOUT("ERROR :: H26X_RGB32_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_RGB32_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

  //  Space for tables to adjust brightness, contrast, and saturation.

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

  //  Space for post processing Y, U, and V frames, with four extra max-width lines
  //  above for color conversion's scratch space for preprocessed chroma data.

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
    DC->PostFrame.X32_VPlane = Offset;
    DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
    DC->PostFrame.X32_UPlane = Offset;
    DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

  //  Space for copy of BEF Descriptor.

  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

  //  Space for BEFApplicationList.

  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
  
  // Init tables to adjust brightness, contrast, and saturation.

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

  //  Space for R, G, and B clamp tables and U and V contribs to R, G, and B.

  PRGBValue    = H26xColorConvertorTables.B24Value;
  PUVContrib   = (U32 *) H26xColorConvertorTables.UV24Contrib;

  /*
   * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
   *
   * The formulae published by the CCIR committee for
   *      Y        = 16..235
   *      U & V    = 16..240
   *      R, G & B =  0..255 are:
   * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
   * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
   * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
   *
   * The coefficients are all multiplied by 65536 to accomodate integer only
   * math.
   *
   * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
   * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
   * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
   *
   * Mathematically this is equivalent to (and computationally this is nearly
   * equivalent to):
   * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
   * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
   * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
   *
   * which, in integer arithmetic, and eliminating the insignificant parts, is:
   *
   * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
   * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
   * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
  */

  for (i = 0; i < 256; i++)
  {
    ii = ((-22015L*(i-128L))>>16L)+41L  + 1L;  /* biased U contribution to G. */
    if (ii < 1) ii = 1;
    if (ii > 83) ii = 83;
    jj = ((113562L*(i-128L))>>17L)+111L + 1L;  /* biased U contribution to B. */
    *PUVContrib++ = (ii << 16L) + (jj << 24L);
    ii = ((-45774L*(i-128L))>>16L)+86L;        /* biased V contribution to G. */
    if (ii < 0) ii = 0;
    if (ii > 172) ii = 172;
    jj = (( 89858L*(i-128L))>>16L)+176L + 1L;  /* biased V to contribution R. */
    *PUVContrib++ = (ii << 16L) + jj;
  }

  for (i = 0; i < 701; i++)
  {
    ii = (((I32) i - 226L - 16L) * 610271L) >> 19L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    PRGBValue[i] = (U8) ii;
  }

  ret = ICERR_OK;

done:  

  return ret;

}


/*******************************************************************************

H26X_RGB16_Init -- This function initializes for the RGB16 color convertors.

*******************************************************************************/

LRESULT H26X_RGB16_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
LRESULT ret;

int  IsDCI;
int  RNumBits;
int  GNumBits;
int  BNumBits;
int  RFirstBit;
int  GFirstBit;
int  BFirstBit;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;
int  TableNumber;

U8   FAR  * PRValLo;
U8   FAR  * PGValLo;
U8   FAR  * PBValLo;
U8   FAR  * PRValHi;
U8   FAR  * PGValHi;
U8   FAR  * PBValHi;
U32  FAR  * PUVContrib;
U32  FAR  * PRValZ2;
U32  FAR  * PGValZ2;
U32  FAR  * PBValZ2;
U8   FAR  * InitPtr;
int  i;
I32  ii, jj;

  switch (ColorConvertor)
  {
    case RGB16555:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  5;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 0;
      break;

    case RGB16555DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  5;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 0;
      break;

    case RGB16555ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  5;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 0;
      break;

    case RGB16555ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  5;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 0;
      break;
    
      case RGB16565:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  5;
      GNumBits  =  6;
      BNumBits  =  5;
      RFirstBit = 11;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 1;
      break;

    case RGB16565DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  5;
      GNumBits  =  6;
      BNumBits  =  5;
      RFirstBit = 11;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 1;
      break;

    case RGB16565ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  5;
      GNumBits  =  6;
      BNumBits  =  5;
      RFirstBit = 11;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 1;
      break;

    case RGB16565ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  5;
      GNumBits  =  6;
      BNumBits  =  5;
      RFirstBit = 11;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 1;
      break;
   
    case RGB16664:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  6;
      GNumBits  =  6;
      BNumBits  =  4;
      RFirstBit = 10;
      GFirstBit =  4;
      BFirstBit =  0;
      TableNumber = 3;
      break;

    case RGB16664DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  6;
      GNumBits  =  6;
      BNumBits  =  4;
      RFirstBit = 10;
      GFirstBit =  4;
      BFirstBit =  0;
      TableNumber = 3;
      break;

    case RGB16664ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  6;
      GNumBits  =  6;
      BNumBits  =  4;
      RFirstBit = 10;
      GFirstBit =  4;
      BFirstBit =  0;
      TableNumber = 3;
      break;

    case RGB16664ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  6;
      GNumBits  =  6;
      BNumBits  =  4;
      RFirstBit = 10;
      GFirstBit =  4;
      BFirstBit =  0;
      TableNumber = 3;
      break;   
      
     case RGB16655:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  6;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 2;
      break;

    case RGB16655DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  6;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 2;
      break;

    case RGB16655ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  6;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 2;
      break;

    case RGB16655ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  6;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 2;
      break;   

    default:
      DBOUT("ERROR :: H26X_RGB16_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

#ifdef WIN32
  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
  Sz_FixedSpace = RGB16SizeOf_FixedPart();             /* Space for locals. */
  Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */
  Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */
  Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                          ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList + 
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_RGB16_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames, with four extra max-width lines
   above for color conversion's scratch space for preprocessed chroma data.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  if (DC->DecoderType == H263_CODEC)
  {
  	DC->PostFrame.X32_VPlane = Offset;
  	DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
   	DC->PostFrame.X32_UPlane = Offset;
  	DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only copied for 16-bit Windows (tm)).
*/

#ifdef WIN32
  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
  DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

#ifdef WIN32
  DC->X32_BEFApplicationList =DC->X16_BlkActionStream;// DC->X32_BlockActionStream;
#else
  DC->X32_BEFApplicationList = Offset;
  Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
            ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

/*
   Space for R, G, and B clamp tables and U and V contribs to R, G, and B.
*/

#ifdef WIN32
  PRValLo      = H26xColorConvertorTables.RValLo555;
  PGValLo      = H26xColorConvertorTables.GValLo555;
  PBValLo      = H26xColorConvertorTables.BValLo555;
  PRValHi      = H26xColorConvertorTables.RValHi555;
  PGValHi      = H26xColorConvertorTables.GValHi555;
  PBValHi      = H26xColorConvertorTables.BValHi555;
  PUVContrib   = H26xColorConvertorTables.UVContrib;
  PRValZ2      = H26xColorConvertorTables.RValZ2555;
  PGValZ2      = H26xColorConvertorTables.GValZ2555;
  PBValZ2      = H26xColorConvertorTables.BValZ2555;
#else
  PRValLo      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_RValLo());
  PGValLo      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_GValLo());
  PBValLo      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_BValLo());
  PRValHi      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_RValHi());
  PGValHi      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_GValHi());
  PBValHi      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_BValHi());
  PUVContrib   = (U32 FAR *) (DC->p16InstPostProcess+RGB16Offset_UVContrib());
  PRValZ2      = (U32 FAR *) (DC->p16InstPostProcess+RGB16Offset_RValZ2());
  PGValZ2      = (U32 FAR *) (DC->p16InstPostProcess+RGB16Offset_GValZ2());
  PBValZ2      = (U32 FAR *) (DC->p16InstPostProcess+RGB16Offset_BValZ2());
#endif
  PRValLo      += TableNumber*2048;
  PGValLo      += TableNumber*2048;
  PBValLo      += TableNumber*2048;
  PRValHi      += TableNumber*2048;
  PGValHi      += TableNumber*2048;
  PBValHi      += TableNumber*2048;
  PRValZ2      += TableNumber*1024;
  PGValZ2      += TableNumber*1024;
  PBValZ2      += TableNumber*1024;

/*
 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
 *
 * The formulae published by the CCIR committee for
 *      Y        = 16..235
 *      U & V    = 16..240
 *      R, G & B =  0..255 are:
 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
 *
 * The coefficients are all multiplied by 65536 to accomodate integer only
 * math.
 *
 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
 *
 * Mathematically this is equivalent to (and computationally this is nearly
 * equivalent to):
 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
 *
 * which, in integer arithmetic, and eliminating the insignificant parts, is:
 *
 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
*/


  for (i = 0; i < 256; i++)
  {
    ii = ((-22015L*(i-128L))>>17L)+22L  + 1L;  /* biased U contribution to G. */
    jj = ((113562L*(i-128L))>>17L)+111L + 1L;  /* biased U contribution to B. */
    *PUVContrib++ = (ii << 8L) + jj;
    ii = ((-45774L*(i-128L))>>17L)+45L;        /* biased V contribution to G. */
    jj = (( 89858L*(i-128L))>>17L)+88L  + 1L;  /* biased V to contribution R. */
    *PUVContrib++ = (ii << 8L) + (jj << 16L);
  }

  for (i = 0; i < 304; i++)
  {
    ii = (((I32) i - 88L - 1L - 16L) * 76284L) >> 15L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    jj = ii + (1 << (7 - RNumBits));
    if (jj > 255L) jj = 255L;
    PRValLo[i] = ((U8) ((ii >> (8-RNumBits)) << (RFirstBit-8)));
    PRValHi[i] = ((U8) ((jj >> (8-RNumBits)) << (RFirstBit-8)));
    PRValZ2[i] = ((ii >> (8-RNumBits)) << (RFirstBit   )) |
                 ((jj >> (8-RNumBits)) << (RFirstBit+16));
  }

  for (i = 0; i < 262; i++)
  {
    ii = (((I32) i - 67L - 1L - 16L) * 76284L) >> 15L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    jj = ii + (1 << (7 - GNumBits));
    if (jj > 255L) jj = 255L;
    PGValLo[i] = ((U8) ((ii >> (8-GNumBits)) << (GFirstBit-4)));
    PGValHi[i] = ((U8) ((jj >> (8-GNumBits)) << (GFirstBit-4)));
    PGValZ2[i] = ((jj >> (8-GNumBits)) << (GFirstBit   )) |
                 ((ii >> (8-GNumBits)) << (GFirstBit+16));
  }

  for (i = 0; i < 350; i++)
  {
    ii = (((I32) i - 111L - 1L - 16L) * 76284L) >> 15L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    jj = ii + (1 << (7 - BNumBits));
    if (jj > 255L) jj = 255L;
    PBValLo[i] = ((U8) ((ii >> (8-BNumBits)) << (BFirstBit  )));
    PBValHi[i] = ((U8) ((jj >> (8-BNumBits)) << (BFirstBit  )));
    PBValZ2[i] = ((ii >> (8-BNumBits)) << (BFirstBit   )) |
                 ((jj >> (8-BNumBits)) << (BFirstBit+16));
  }

ret = ICERR_OK;

done:  

return ret;

}

/****************************************************************************

H26X_YVU12ForEnc_Init -- This function initializes for the "color convertor"
                  that provides a reconstructed YVU12 image back to the encode

*****************************************************************************/

LRESULT H26X_YVU12ForEnc_Init (T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{    
LRESULT ret;

// added for I420 output support
// maybe this should be a separate init routine???
// in the I420 output case, DC->a16InstPostProcess wasn't being initialized
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane = 0;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;
int	i;
U8	FAR * InitPtr;

// ******************************************
// original YVU12ForEnc_Init
  DC->a16InstPostProcess    = NULL;
  DC->p16InstPostProcess     = NULL;
  DC->PostFrame.X32_YPlane     = 0xDEADBEEF;
  DC->X32_BEFDescrCopy       = 0xDEADBEEF;
  DC->X32_BEFApplicationList = 0xDEADBEEF;
  DC->PostFrame.X32_VPlane     = 0xDEADBEEF;
  DC->PostFrame.X32_UPlane     = 0xDEADBEEF;
// ******************************************

// added for I420 output support
#ifdef WIN32
  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
  Sz_FixedSpace = YVU12SizeOf_FixedPart();             /* Space for locals. */
  Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */
  Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */   //fixfix
  Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                          ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

// added for I420 output support
  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?                //fixfix
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_YVU12ForEnc_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames, with one extra max-width line
   above for color conversion's scratch space for UVDitherPattern indices.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only copied for 16-bit Windows (tm)).
*/

#ifdef WIN32
  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
  DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

#ifdef WIN32
  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
#else
  DC->X32_BEFApplicationList = Offset;
  Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
            ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

// ******************************************
// original YVU12ForEnc_Init
ret = ICERR_OK;

done:

return ret;

}
// **********************************


// this is just a place holder, the real work is done in H26X_CLUT8AP_InitReal()
LRESULT H26X_CLUT8AP_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
  return ICERR_OK;
}


LRESULT H26X_CLUT8AP_InitReal(LPDECINST lpInst,T_H263DecoderCatalog FAR * DC, UN ColorConvertor, BOOL bReuseAPInst)
{    
LRESULT ret;

int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_AdjustmentTables;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_BEFDescrCopy;
U32  Sz_BEFApplicationList;
//U32  Sz_UVDitherPattern; 
U32  Sz_ClutIdxTable;     /* for Active Palette */
U32  Offset;
//X32  X32_UVDitherPattern;
int  i;
U8   FAR  * InitPtr;
U8   BIGG * lpClutIdxTable;

  switch (ColorConvertor)
  {
/*
    case CLUT8APZoomBy2:
      IsDCI = TRUE; 
      Sz_SpaceBeforeYPlane = MMxVersion ? 0 : P6Version ? 648*4 : 648*4;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
	((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
      break;

    case CLUT8AP:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = MMxVersion ? 0 : P6Version ? 648*4 : 648*4;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
      DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break;   
 */
    case CLUT8APZoomBy2DCI:
      IsDCI = TRUE; 
      Sz_SpaceBeforeYPlane = 648*4;
 //    Sz_SpaceBeforeYPlane = MMxVersion ? 0 : P6Version ? 2592 : 648;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
	((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
      break;

    case CLUT8APDCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 648*4;
 //     Sz_SpaceBeforeYPlane = MMxVersion ? 0 : P6Version ? 1296 : 648;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
      DC->CCOffsetToLine0 =  ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break; 
    default:
      DBOUT("ERROR :: H26X_CLUT8AP_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

  if (((DC->uYActiveWidth > 352) || (DC->uYActiveHeight > 288)) && (DC->DecoderType != YUV12_CODEC))
      return ICERR_MEMORY;
  else
  {
#ifdef WIN32
    Sz_FixedSpace = 0L;          /* Locals go on stack; tables staticly alloc. */
    Sz_AdjustmentTables = 1056L; /* Adjustment tables are instance specific.   */  
    Sz_ClutIdxTable=65536L+2048L;/* dynamic CLUT8 tables, 2**14                */
				 /* and UDither (128*4), VDither(512) tables   */
    Sz_BEFDescrCopy = 0L;        /* Don't need to copy BEF descriptor.         */
    Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
    Sz_FixedSpace = CLUT8APSizeOf_FixedPart();             /* Space for locals. */
    Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */ 
    Sz_ClutIdxTable=0x10800;          /* dynamic CLUT8 tables, 2**16         */
				                     /* and UDither (256*4), VDither(1024) tables   */
    Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */
    Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                            ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif
   if (!bReuseAPInst ) 
   {
    DC->a16InstPostProcess =
      HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
		  (Sz_FixedSpace +
		   Sz_ClutIdxTable+
		   Sz_AdjustmentTables +   
		   (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) +
		   DC->uSz_YPlane +
		   DC->uSz_VUPlanes +
           Sz_BEFApplicationList+
		   31)
		 );
    if (DC->a16InstPostProcess == NULL)
    {
      DBOUT("ERROR :: H26X_CLUT8_Init :: ICERR_MEMORY");
      ret = ICERR_MEMORY;
      goto  done;
    }
   }
   else //reuse AP instance
      DC->a16InstPostProcess = DC->pAPInstPrev;

    DC->p16InstPostProcess =
      (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);
   
   
/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

    Offset = Sz_FixedSpace; 
    lpClutIdxTable = ( U8 BIGG * ) (DC->p16InstPostProcess + Offset);  
    Offset += Sz_ClutIdxTable; 
    
    DC->X16_LumaAdjustment   = ((U16) Offset);
    DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
    Offset += Sz_AdjustmentTables;  
/* space for Dynamic CLUT8 tables */

  //  DC->X16_ClutIdxTable = Offset;
   
    
    
/*
   Space for post processing Y, U, and V frames, with one extra max-width line
   above for color conversion's scratch space for UVDitherPattern indices.
*/
    DC->PostFrame.X32_YPlane = Offset +  
                              (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                               Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy);
   //   Offset + (Sz_BEFDescrCopy < 648L*4L ? 648L*4L : Sz_BEFDescrCopy);
    Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
    if (DC->DecoderType == H263_CODEC)
    {
		DC->PostFrame.X32_VPlane = Offset;
  		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  	}
	else
	{
   		DC->PostFrame.X32_UPlane = Offset;
  		DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
	}
    Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only applicable for 16-bit Windows (tm)).
*/

#ifdef WIN32
    DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
    DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

    //Offset += DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
#ifdef WIN32
    DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
#else
    DC->X32_BEFApplicationList = Offset;
    Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
	      ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif
  }

  if (!bReuseAPInst)
  {  
/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;       
 
/*
  compute the dynamic ClutIdxTable
  ComputeDynamicClut(lpClutIdxTable, pInst->ActivePalette,256);  
*/                                  
  ComputeDynamicClut(lpClutIdxTable,(U8 FAR *)(lpInst->ActivePalette),sizeof(lpInst->ActivePalette));
  }
 
ret = ICERR_OK;

done:  

return ret;

}

// ComputeDynamicClut8 Index and UV dither table

#define NCOL 256
#define YSIZ   8
#define YSTEP 16
//#define USE_744

#if defined USE_744
/* table index is vvvvuuuuxyyyyyyy */
#define UVSTEP  8
#define YGAP    1
//#define TBLIDX(y,u,v) (((v)>>3<<4) + ((u)>>3) + ((y)<<8))
#define TBLIDX(y,u,v) (((v)>>3<<12) + ((u)>>3<<8) + (y))
#else
/* table index is 00vvvuuu0yyyyyyy */
#define UVSTEP  16
#define YGAP    1  
//#define TBLIDX(y,u,v) (((v)>>4<<4) + ((u)>>4) + ((y)<<8))
#define TBLIDX(y,u,v) (((v)>>4<<11) + ((u)>>4<<8) + (y))
#endif /* USE_744 */

#define YFROM(R, G, B) ( int)(( 0.257 * R) + ( 0.504 * G) + ( 0.098 * B) + 16.)
#define UFROM(R, G, B) ( int)((-0.148 * R) + (-0.291 * G) + ( 0.439 * B) + 128.)
#define VFROM(R, G, B) ( int)(( 0.439 * R) + (-0.368 * G) + (-0.071 * B) + 128.)

/* parameters for generating the U and V dither magnitude and bias */
#define MAG_NUM_NEAREST         6       /* # nearest neighbors to check */
#define MAG_PAL_SAMPLES         32      /* # random palette samples to check */
#define BIAS_PAL_SAMPLES        128     /* number of pseudo-random RGB samples to check */

#define RANDOM(x) (int)((((long)(x)) * (long)rand())/(long)RAND_MAX)

typedef struct {  int palindex; long  distance; } close_t;
typedef struct {  int y,u,v; } Color;
/* squares[] is constant values are filled in at run time, so can be global */
static unsigned int squares[256];
static struct { unsigned char Udither, Vdither; } dither[4] = {{2, 1}, {1, 2}, {0, 3}, {3, 0}};


;/***************************************************************************/
;/* ComputeDymanicClut() computes the clut tables on the fly, based on the  */
;/* current palette[];                                                      */
;/* called from InitColorConvertor, when CLUTAP is selected                 */
;/***************************************************************************/
static LRESULT ComputeDynamicClut(unsigned char BIGG *table, unsigned char FAR *APalette, int APaletteSize)
{  

   /* 
    * The dynamic clut consists of 4 entries which MUST be
    * contiguous in memory:
    *
    *    ClutTable: 16384 1-byte entries
    *               Each entry is the closest palette entry, as
    *               indexed by a 14 bit value: 00uuuvvv0yyyyyyy,
    *               dithered
    *
    *    TableU:    128   4-byte entries
    *               Each entry is 00uuu000:00uuu000:00uuu000:00uuu000,
    *               each uuuu is a 4 bit dithered u value for the
    *               index, which is a u value in the range 8-120
    *
    *    TableV:    128   4-byte entries
    *               Same as TableU, except the values are arranged
    *               00000vvv:00000vvv:00000vvv:00000vvv.
    */

	Color *palette;
	unsigned char BIGG *tptr; 
	unsigned char BIGG *htptr;
	DWORD BIGG *hUptr, BIGG *hVptr; 
	unsigned char yslice[YSIZ][256], FAR *yyptr;
	int FAR *ycnt;
	unsigned int FAR *diff, FAR *dptr, FAR *delta, FAR *deptr;
	int i,j,yseg,y,u,v,mini,yo,uo,vo,ycount,yi; 
	unsigned int addr1,addr2,ind;
	unsigned int d,min;     // since 3*128^2 = 49K
        
    PALETTEENTRY FAR *lpPal, FAR *palptr;
    Color FAR *colptr;
    int Y, U, V;
    int U_0, U_1, U_2, U_3;
    int V_0, V_1, V_2, V_3;
       
    /* Umag and Vmag max is (128 * sqrt(3) * MAG_NUM_NEAREST) = ~1330 */
    int Umag, Vmag;
    /* dist max is 128*128*3 = 49152 */
    unsigned int dist;
    unsigned int close_dist[MAG_NUM_NEAREST];
    int palindex;
    int R, G, B;
    int k, p, tmp, iu, iv;
    /* Ubias and Vbias max is (128 * 4 * BIAS_PAL_SAMPLES) = 65536 */
    /* even the worst palette (all black except the reserved colors) */
    /* would not achieve this. */
    int Ubias, Vbias;
    unsigned long Udither, Vdither;
    DWORD BIGG *TableUptr, BIGG *TableVptr;
	

    DBOUT("ComputeDynamic CLUT8 index tables........\n");
	/* allocate some memory */
	palette = (Color *)        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(Color)*NCOL);
	ycnt    = (int*)           HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(int)*YSIZ);
	diff    = (unsigned int*)  HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(unsigned int) * 256);
	delta   = (unsigned int*)  HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(unsigned int) * 256);
	lpPal   = (PALETTEENTRY *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(PALETTEENTRY) * 256);

	if (!palette || !ycnt || !diff || !delta || !lpPal)
		return (ICERR_MEMORY);

	for (i=-128; i<128; i++)
		squares[128+i] = i*i;

	_fmemcpy((unsigned char FAR *)lpPal, APalette, APaletteSize);

    palptr = lpPal;
    colptr = palette;
    for (i = 0; i < 256; i++) {
		/* In BGR (RGBQuad) order. */
	 B = palptr->peRed;
	 G = palptr->peGreen;
	 R = palptr->peBlue; 
	 
	 colptr->y = YFROM(R, G, B)/2;
	 colptr->u = UFROM(R, G, B)/2;
	 colptr->v = VFROM(R, G, B)/2;
	palptr++;
	colptr++;
    }

	for (i=0; i<YSIZ; i++)
		ycnt[i] = 0;

	for (i=0; i<NCOL; i++)
	{
		yseg = palette[i].y >> 4;
		yslice[yseg][ycnt[yseg]++] = (unsigned char) i;
	}


// Do exhaustive search on all U,V points and a coarse grid in Y

	for (u=0; u<128; u+=UVSTEP)
	{
		for (v=0; v<128; v+=UVSTEP)
		{
			ind = TBLIDX(0,u,v);
			tptr = table+ind;
			for (y=0; y<128; y+=YSTEP)
			{
				colptr = palette;
				min = 55555L;
				for (i=0; i<NCOL; i++, colptr++)
				{
					d = (3*squares[128+y - colptr->y])>>1;
					if (d > min)
						continue;
					
					d += squares[128+u - colptr->u];
					if (d > min)
						continue;

					d += squares[128+v - colptr->v];
					if (d < min)
					{
						min = d;
						mini = i;
					}
				}
				*tptr = (unsigned char) mini;  
				htptr = (unsigned char BIGG *)(tptr + 128);                      
			    *htptr = (unsigned char) mini;
			
			    tptr += YSTEP;

			}
		}
	}
#ifdef STATISTICS
#if defined USE_STAT_BOARD
	dwStopTime = ReadElapsed()>>2;
#else
	dwStopTime = bentime();
#endif /* USE_STAT_BOARD */
	dwElapsedTime = dwStopTime - dwStartTime2 - dwOverheadTime;
	DPF("CoarseSearch() time = %lu microseconds",dwElapsedTime);
#endif

// Go thru points not yet done, and search
//  (1) The closest point to the prev and next Y in coarse grid
//  (2) All the points in this Y slice
//
// Also, take advantage of the fact that we can do distance computation
// incrementally.  Keep all N errors in an array, and update each
// time we change Y.


	for (u=0; u<128; u+=UVSTEP)
	{
		for (v=0; v<128; v+=UVSTEP)
		{
			for (y=YGAP; y<128; y+=YSTEP)
			{
				yseg = y >> 4;
				ycount = ycnt[yseg] + 2;  // +2 is 'cause we add 2 Y endpoints

				yyptr = (unsigned char FAR *)yslice[yseg];
				
				addr1 = TBLIDX(yseg*16,u,v);
				yyptr[ycount-2] = *(U8 BIGG *)(table +addr1);

				addr2 = TBLIDX((yseg+(yseg < 7))*16,u,v);
				yyptr[ycount-1] = *(U8 BIGG *)(table +addr2);

				dptr  = diff;
				deptr = delta;
				for (i=0; i<ycount; i++, yyptr++, dptr++, deptr++)
				{
					j = *yyptr; /* yslice[yseg][i]; */
					colptr = palette+j;
					yo = colptr->y;
					uo = colptr->u;
					vo = colptr->v;
					*dptr = ( 3*squares[128+y-yo] + 2*(squares[128+u-uo] + squares[128+v-vo]));
					*deptr =( 3*(((y-yo)<<1) + 1));
				}

				ind = TBLIDX(y,u,v);
				tptr = table+ind;
				for (yi=0; yi<YSTEP-1; yi += YGAP)
				{
					min = 55555;
					yyptr = (unsigned char FAR *)yslice[yseg];
					dptr  = diff;
					deptr = delta;
					for (i=0; i<ycount; i++, yyptr++, dptr++, deptr++)
					{
						if (*dptr < min)
						{
							min = *dptr;
							mini = *yyptr; /* yslice[yseg][i]; */
						}
						*dptr += *deptr;
						*deptr += 6;
					}
					*tptr = (unsigned char) mini;
					htptr = (unsigned char BIGG *)(tptr + 128);                      
				   *htptr = (unsigned char) mini;

					tptr++;

				}
			}
		}
	}

       /* now do U and V dither tables and shift lookup table*/
       /* NOTE: All Y, U, V values are 7 bits */

	Umag = Vmag = 0;
	Ubias = Vbias = 0;

	/* use srand(0) and rand() to generate a repeatable series of */
	/* pseudo-random numbers */
	srand((unsigned)1);
	
	for (p = 0; p < MAG_PAL_SAMPLES; ++p)               // 32
	{
	   for (i = 0; i < MAG_NUM_NEAREST; ++i)            // 6
	   {
	      close_dist[i] = 0x7FFFL;
	   }
	    
	   palindex = RANDOM(235) + 10; /* random palette index, unreserved colors */
	   colptr = &palette[palindex];
	   Y = colptr->y;
	   U = colptr->u;
	   V = colptr->v;
	    
	   colptr = palette;
	   for (i = 0; i < 255; ++i)
	   {
	      if (i != palindex)
	      {
		   dist = squares[128+(Y - colptr->y)] +
			      squares[128+(U - colptr->u)] +
			      squares[128+(V - colptr->v)];
	       
		 /* keep a sorted list of the nearest MAG_NUM_NEAREST entries */
		 for (j = 0; j < MAG_NUM_NEAREST; ++j)         //6
		 {
		    if (dist < close_dist[j])
		    {
		       /* insert new entry; shift others down */
		       for (k = (MAG_NUM_NEAREST-1); k > j; k--)
		       {
			      close_dist[k] = close_dist[k-1];
		       }
		       close_dist[j] = dist;
		       break; /* out of for j loop */
		    }
		 } /* for j */
	      } /* if i */
	      ++colptr;
	   } /* for i */
	   
	   /* now calculate Umag as the average of (U - U[1-6]) */
	   /* calculate Vmag in the same way */
	   
	   for (i = 0; i < MAG_NUM_NEAREST; ++i)
	   {
	      /* there are (MAG_PAL_SAMPLES * MAG_NUM_NEAREST) sqrt() */
	      /* calls in this method */
	      Umag += (int)sqrt((double)close_dist[i]);
	   }
	} /* for p */

	Umag /= (MAG_NUM_NEAREST * MAG_PAL_SAMPLES);
	Vmag = Umag;
	
	for (p = 0; p < BIAS_PAL_SAMPLES; ++p)            //132
	{

		/* now calculate the average bias (use random RGB points) */
		R = RANDOM(255);
		G = RANDOM(255);
		B = RANDOM(255);
	   
		Y = YFROM(R, G, B)/2;
		U = UFROM(R, G, B)/2;
		V = VFROM(R, G, B)/2;
	   
		for (d = 0; d < 4; d++)   
		{
			U_0 = U + (dither[d].Udither*Umag)/3;
			V_0 = V + (dither[d].Vdither*Vmag)/3;
	      
			/* Clamp values */
			if (U_0 > 127) U_0 = 127;
			if (V_0 > 127) V_0 = 127;
					
			/* (Y, U_0, V_0) is the dithered YUV for the RGB point */
			/* colptr points to the closest palette entry to the dithered */
			/* RGB */
			/* colptr = &palette[table[TBLIDX(Y, U_0+(UVSTEP>>1), V_0+(UVSTEP>>1))]]; */
		    tptr= (unsigned char BIGG *)(table + (unsigned int)TBLIDX(Y, U_0, V_0)) ;
		    palindex=*tptr;
		    colptr = &palette[palindex];
      
			Ubias +=  (U - colptr->u);
			Vbias +=  (V - colptr->v);
		}
	} /* for p */
	
	Ubias =(int) (Ubias+BIAS_PAL_SAMPLES*2)/(int)(BIAS_PAL_SAMPLES * 4);
	Vbias =(int) (Vbias+BIAS_PAL_SAMPLES*2)/(int)(BIAS_PAL_SAMPLES * 4);
	

#define CLAMP7(x) (unsigned char)((x) > 127 ? 127 : ((x) < 0 ? 0 : (x)))

    U_0 = (2*(int)Umag/3); V_0 = (1*(int)Vmag/3);
    U_1 = (1*(int)Umag/3); V_1 = (2*(int)Vmag/3);
    U_2 = (0*(int)Umag/3); V_2 = (3*(int)Vmag/3);
    U_3 = (3*(int)Umag/3); V_3 = (0*(int)Vmag/3);

    TableUptr = (DWORD BIGG *)(table+ (U32)65536L);
    TableVptr = TableUptr + 128+128;  // duplicate for MSB 
    hUptr=(DWORD BIGG *)(TableUptr+ 128);
    hVptr=(DWORD BIGG *)(TableVptr+ 128);
       
    iu = Ubias /* + (UVSTEP>>1) */;
    iv = Vbias /* + (UVSTEP>>1) */;

    for (i = 0; i < 128; i++, iu++, iv++)
    {
		/* dither: vvvv0000, 0000uuuu */
		tmp = iu + U_0; 
		Udither  = CLAMP7(tmp); 
		Udither <<= 8;
		tmp = iu + U_1; Udither |= CLAMP7(tmp); Udither <<= 8;
		tmp = iu      ; Udither |= CLAMP7(tmp); Udither <<= 8; /* U_2 == 0 */
		tmp = iu + U_3; Udither |= CLAMP7(tmp);
		
		*TableUptr++ = *hUptr++ = (Udither >> 3) & 0x0F0F0F0FL;
	  
		tmp = iv + V_0; Vdither  = CLAMP7(tmp); Vdither <<= 8;
		tmp = iv + V_1; Vdither |= CLAMP7(tmp); Vdither <<= 8;
		tmp = iv + V_2; Vdither |= CLAMP7(tmp); Vdither <<= 8;
		tmp = iv      ; Vdither |= CLAMP7(tmp);                /* V_3 == 0 */ 
		*TableVptr++ = *hVptr++ = (Vdither << 1) & 0xF0F0F0F0L;

    }

DBOUT("Completed ComputeClut8Idx()...\n");

	HeapFree(GetProcessHeap(), 0, lpPal);
	HeapFree(GetProcessHeap(), 0, delta);
	HeapFree(GetProcessHeap(), 0, diff);
	HeapFree(GetProcessHeap(), 0, ycnt);
	HeapFree(GetProcessHeap(), 0, palette);

	return (ICERR_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1const.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;////////////////////////////////////////////////////////////////////////////
;//
;// $Author:   AKASAI  $
;// $Date:   09 Jan 1996 09:41:56  $
;// $Archive:   S:\h26x\src\dec\d1const.h_v  $
;// $Header:   S:\h26x\src\dec\d1const.h_v   1.1   09 Jan 1996 09:41:56   AKASAI  $
;// $Log:   S:\h26x\src\dec\d1const.h_v  $
;// 
;//    Rev 1.1   09 Jan 1996 09:41:56   AKASAI
;// Updated copyright notice.
;// 
;//    Rev 1.0   11 Sep 1995 13:51:06   SCDAY
;// Initial revision.
;// 
;//    Rev 1.0   31 Jul 1995 13:00:02   DBRUCKS
;// Initial revision.
;// 
;//    Rev 1.0   17 Jul 1995 14:46:20   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   17 Jul 1995 14:14:26   CZHU
;// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#ifndef __DECCONST_H__
#define __DECCONST_H__

/*
  This file declares symbolic constants used by the MRV decoder, post filtering
  functions, and color convertors.
*/

#define BEFTRIGGER       143 /* See bef.asm for the magic behind these values.*/
#define BEFWILLING       125
#define BEFUNWILLING      10
#define BEFENDOFLINE      21
#define BEFENDOFFRAME    246

#define INVALIDINTERBLOCK 0
#define INVALIDCOPYBLOCK  1
#define NOMOREBLOCKS      2
// Already defined in e1enc.h
//#define INTRABLOCK        3
//#define INTERBLOCK        4
#define COPYBLOCK         5

#define OFFSETTOYARCHIVE  311688L /* Distance from FrmPost to FrmArch in Y.
                                     That's 648 * 481.  648 to allow maximum
                                     width of 640, plus 1 column for some useful
                                     zoom-by-2 color convertors.  8 instead of
                                     1 to stay longword aligned, and instead of
                                     4 to stay quadword aligned for possible
                                     benefit of future processors.  481 to allow
                                     extra line for some useful zoom-by-2 color
                                     convertors. */
#define VPITCH 336               /* U & V interleaved, with constant pitch of */
                                 /* 336.  This makes color conversion easier. */
#define OFFSETV2U 168            /* Distance from V pel to corresponding U    */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1coltbl.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
////////////////////////////////////////////////////////////////////////////
//
// D1COLTBL.C - The color tables need to be declared here in order that the
//              assembly object files can find them.  If they are declared
//              in a CPP file the names will be mangled.  This file was
//			    taken from part of MRV's COLOR.C.
//
// $Header:   S:\h26x\src\dec\d1coltbl.c_v   1.3   09 Jan 1996 10:50:48   AKASAI  $
//
// $Log:   S:\h26x\src\dec\d1coltbl.c_v  $
;// 
;//    Rev 1.3   09 Jan 1996 10:50:48   AKASAI
;// Added correct copyright.
;// 
;//    Rev 1.2   15 Nov 1995 14:22:06   AKASAI
;// New tables for 12-bit color converters.  Copied with file name changes
;// directly from d3coltbl files.
;// (Integration point)
;// 
;//    Rev 1.2   03 Nov 1995 11:49:44   BNICKERS
;// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
;// 
;//    Rev 1.1   30 Oct 1995 17:15:42   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.0   23 Aug 1995 12:22:28   DBRUCKS
;// Initial revision.

#include "precomp.h"

#pragma data_seg ("H26xColorConvertorTbl")
#ifdef WIN32
extern
#endif

T_H26xColorConvertorTables H26xColorConvertorTables = {

{ // UVDitherLine01 (for CLUT8 and CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00001A00, 0x00001A00, 0x1A001A00,
  0x1A001A00, 0x1A1A1A00, 0x1A1A1A00, 0x1A1A1A1A,
  0x1A1A1A1A, 0x1A1A341A, 0x1A1A341A, 0x341A341A,
  0x341A341A, 0x3434341A, 0x3434341A, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434 
},
{ // UVDitherLine23 (for CLUT8 and CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x0000001A, 0x0000001A, 0x001A001A,
  0x001A001A, 0x1A1A001A, 0x1A1A001A, 0x1A1A1A1A,
  0x1A1A1A1A, 0x1A1A1A34, 0x1A1A1A34, 0x1A341A34,
  0x1A341A34, 0x34341A34, 0x34341A34, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434 
},
{ // YDither (for CLUT8)
  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,
  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,
  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,
 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25
},
{ 0 }, // Padding1
{ // YDitherZ2 (for CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00010000, 0x00010000, 0x00010001,
  0x00010001, 0x00010101, 0x00010101, 0x01010101,
  0x01010101, 0x01020101, 0x01020101, 0x01020102,
  0x01020102, 0x01020202, 0x01020202, 0x02020202,
  0x02020202, 0x02030202, 0x02030202, 0x02030203,
  0x02030203, 0x02030303, 0x02030303, 0x03030303,
  0x03030303, 0x03040303, 0x03040303, 0x03040304,
  0x03040304, 0x03040404, 0x03040404, 0x04040404,
  0x04040404, 0x04050404, 0x04050404, 0x04050405,
  0x04050405, 0x04050505, 0x04050505, 0x05050505,
  0x05050505, 0x05060505, 0x05060505, 0x05060506,
  0x05060506, 0x05060606, 0x05060606, 0x06060606,
  0x06060606, 0x06070606, 0x06070606, 0x06070607,
  0x06070607, 0x06070707, 0x06070707, 0x07070707,
  0x07070707, 0x07080707, 0x07080707, 0x07080708,
  0x07080708, 0x07080808, 0x07080808, 0x08080808,
  0x08080808, 0x08090808, 0x08090808, 0x08090809,
  0x08090809, 0x08090909, 0x08090909, 0x09090909,
  0x09090909, 0x090A0909, 0x090A0909, 0x090A090A,
  0x090A090A, 0x090A0A0A, 0x090A0A0A, 0x0A0A0A0A,
  0x0A0A0A0A, 0x0A0B0A0A, 0x0A0B0A0A, 0x0A0B0A0B,
  0x0A0B0A0B, 0x0A0B0B0B, 0x0A0B0B0B, 0x0B0B0B0B,
  0x0B0B0B0B, 0x0B0C0B0B, 0x0B0C0B0B, 0x0B0C0B0C,
  0x0B0C0B0C, 0x0B0C0C0C, 0x0B0C0C0C, 0x0C0C0C0C,
  0x0C0C0C0C, 0x0C0D0C0C, 0x0C0D0C0C, 0x0C0D0C0D,
  0x0C0D0C0D, 0x0C0D0D0D, 0x0C0D0D0D, 0x0D0D0D0D,
  0x0D0D0D0D, 0x0D0E0D0D, 0x0D0E0D0D, 0x0D0E0D0E,
  0x0D0E0D0E, 0x0D0E0E0E, 0x0D0E0E0E, 0x0E0E0E0E,
  0x0E0E0E0E, 0x0E0F0E0E, 0x0E0F0E0E, 0x0E0F0E0F,
  0x0E0F0E0F, 0x0E0F0F0F, 0x0E0F0F0F, 0x0F0F0F0F,
  0x0F0F0F0F, 0x0F100F0F, 0x0F100F0F, 0x0F100F10,
  0x0F100F10, 0x0F101010, 0x0F101010, 0x10101010,
  0x10101010, 0x10111010, 0x10111010, 0x10111011,
  0x10111011, 0x10111111, 0x10111111, 0x11111111,
  0x11111111, 0x11121111, 0x11121111, 0x11121112,
  0x11121112, 0x11121212, 0x11121212, 0x12121212,
  0x12121212, 0x12131212, 0x12131212, 0x12131213,
  0x12131213, 0x12131313, 0x12131313, 0x13131313,
  0x13131313, 0x13141313, 0x13141313, 0x13141314,
  0x13141314, 0x13141414, 0x13141414, 0x14141414,
  0x14141414, 0x14151414, 0x14151414, 0x14151415,
  0x14151415, 0x14151515, 0x14151515, 0x15151515,
  0x15151515, 0x15161515, 0x15161515, 0x15161516,
  0x15161516, 0x15161616, 0x15161616, 0x16161616,
  0x16161616, 0x16171616, 0x16171616, 0x16171617,
  0x16171617, 0x16171717, 0x16171717, 0x17171717,
  0x17171717, 0x17181717, 0x17181717, 0x17181718,
  0x17181718, 0x17181818, 0x17181818, 0x18181818,
  0x18181818, 0x18191818, 0x18191818, 0x18191819,
  0x18191819, 0x18191919, 0x18191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919
},
#if WIN32
{ 0 }, // RValLo       (for RGB16)
{ 0 }, // GValLo       (for RGB16)
{ 0 }, // BValLo       (for RGB16)
{ 0 }, // RValHi       (for RGB16)
{ 0 }, // GValHi       (for RGB16)
{ 0 }, // BValHi       (for RGB16)
{ 0 }, // Padding2
{ 0 }, // UVContrib    (for RGB16)
{ 0 }, // RValZ2       (for RGB16ZoomBy2)
{ 0 }, // GValZ2       (for RGB16ZoomBy2)
{ 0 }, // BValZ2       (for RGB16ZoomBy2)
{ 0 }, // Padding3
{ 0 }, // B24Value     (for RGB24)
{ 0 }, // Padding4
{ 0 }, // UV24Contrib  (for RGB24)
#endif
0 };

#pragma data_seg ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1cpysp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AKASAI  $
// $Date:   15 Mar 1996 09:00:42  $
// $Archive:   S:\h26x\src\dec\d1cpysp.cpv  $
// $Header:   S:\h26x\src\dec\d1cpysp.cpv   1.3   15 Mar 1996 09:00:42   AKASAI  $
// $Log:   S:\h26x\src\dec\d1cpysp.cpv  $
// 
//    Rev 1.3   15 Mar 1996 09:00:42   AKASAI
// 
// Added 1996 to copyright.
// 
//    Rev 1.2   14 Mar 1996 16:58:08   AKASAI
// Changed code, basically a re-write for optimization of code
// space and to use DWORD reads.
// Added pragma for gather MB processing into one code segment.
// 
//    Rev 1.1   01 Nov 1995 13:38:38   AKASAI
// 
// Made changes to enable Log, Header... fields.
// 

//////////////////////////////////////////////////////////////////////////
// ROUTINE NAME: BlockCopySpecial
// FILE NAME:    d1cpysp.cpp
//
// BlockCopySpecial reads reference in DWORDS and writes DWORDS.  Read of 
//   DWORD is ok because LoopFilter buffer should be DWORD aligned.
//
// Input  U8  *reference (Loop Filtered Buffer)
// Output U8  *output  (Output buffer)
//
// Registers used: eax, ebx, ecx, edx, edi
//
// Assumption:  reference uses pitch of 8 and output use pitch of PITCH 
//
//////////////////////////////////////////////////////////////////////////


#include "precomp.h"

#pragma code_seg("IACODE2")
__declspec(naked)
void BlockCopySpecial (U32 uDstBlock,U32 uSrcBlock)
{		
__asm {
	mov 	eax, [esp+8]			// eax gets Base addr of uSrcBlock
	 push 	edi			
	mov 	edi, [esp+8]			// edi gets Base addr of uDstBlock
     push   ebx

	mov     ebx, PITCH

	 mov 	ecx, [eax]				// ref[0][0]
	mov 	edx, 4[eax]				// ref[0][4]
 	 mov 	0[edi], ecx				// row 0, bytes 0-3

	mov 	ecx, [eax+8]      		// ref[1][0]
	 mov 	4[edi], edx				// row 0, bytes 4-7
    add     edi, ebx
	 mov 	edx, 4[eax+8]      		// ref[1][4]
 	mov 	0[edi], ecx				// row 1, bytes 0-3
 
	 mov 	ecx, [eax+16]        	// ref[2][0]
	mov 	4[edi], edx				// row 1, bytes 4-7
     add    edi, ebx
	mov 	edx, 4[eax+16]       	// ref[2][4]
     ; agi
 	 mov 	0[edi], ecx				// row 2, bytes 0-3

	mov 	ecx, [eax+24]        	// ref[3][0]
	 mov 	4[edi], edx				// row 2, bytes 4-7
    add     edi, ebx
	 mov 	edx, 4[eax+24]       	// ref[3][4]
     ; agi
 	mov 	0[edi], ecx				// row 3, bytes 0-3
 
	 mov 	ecx, [eax+32]        	// ref[4][0]
	mov 	4[edi],edx				// row 3, bytes 4-7
     add    edi, ebx
	mov 	edx, 4[eax+32]       	// ref[4][4]
     ; agi
 	 mov 	0[edi], ecx				// row 4, bytes 0-3

	mov 	ecx, [eax+40]        	// ref[5][0]
	 mov 	4[edi], edx				// row 4, bytes 4-7
    add     edi, ebx
	 mov 	edx, 4[eax+40]       	// ref[5][4]
     ; agi
 	mov 	0[edi], ecx				// row 5, bytes 0-3

	 mov 	ecx, [eax+48]        	// ref[6][0]
	mov 	4[edi], edx				// row 5, bytes 4-7
     add     edi, ebx
	mov 	edx, 4[eax+48]       	// ref[6][4]
     ; agi
 	 mov 	0[edi], ecx				// row 6, bytes 0-3

	mov 	ecx, [eax+56]        	// ref[7][0]
	 mov 	4[edi], edx				// row 6, bytes 4-7
    add     edi, ebx
	 mov 	edx, 4[eax+56]        	// ref[7][4]
     ; agi
 	mov 	0[edi], ecx				// row 7, bytes 0-3

	 mov 	4[edi], edx				// row 7, bytes 4-7

    pop     ebx
	 pop 	edi
	ret
	    
  }	 // end of asm
}   // End of BlockCopySpecial
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1dec.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * d1dec.cpp
 *
 * DESCRIPTION:
 *		H261 decoder top level functions
 *
 * Routines:						Prototypes in:
 *		H263InitDecoderGlobal		d1dec.h
 *		H263InitDecoderInstance		d1dec.h
 *      H263Decompress				d1dec.h
 *      H263TermDecoderInstance     d1dec.h
 */

// $Header:   S:\h26x\src\dec\d1dec.cpv   1.69   24 Mar 1997 11:34:36   mbodart  $
// $Log:   S:\h26x\src\dec\d1dec.cpv  $
// 
//    Rev 1.69   24 Mar 1997 11:34:36   mbodart
// Added check for PREROLL, if so don't display.
// 
//    Rev 1.68   19 Mar 1997 16:24:36   mbodart
// Fixed potential problem where aspect ratio adjustment to uNewOffsetToLine0
// should not occur for positive pitches.
// 
//    Rev 1.67   19 Mar 1997 15:01:46   mbodart
// Changes to DibXY to support RGB output with a negative bitmap height.
// 
//    Rev 1.66   24 Jan 1997 17:05:16   RHAZRA
// RTP change: we now look for an EBS for every frame. If there is one
// then we copy the H.261 bits and the EBS separately into our local
// bitstream buffer, inserting two zero bytes between the H261 bits and
// the EBS. We need the two zero bytes to mark the end of the frame for
// the pass 1 code. If there is no EBS, then we proceed as before by
// copying the bitstream and then adding two zero bytes at the end.
// 
//    Rev 1.65   22 Jan 1997 13:33:40   RHAZRA
// Since PPM now fills in the source format even for a PSC packet loss,
// the check for format change has been moved back into d1pict.cpp. This
// was how the check was initially designed in the pre-RTP era.
// 
//    Rev 1.64   23 Dec 1996 16:32:38   MBODART
// Fixed a bug where we allowed more than 33 macro blocks to be present
// in a GOB.  Now we return an error in this case.
// Also removed some dead code involving mb_start.
// 
//    Rev 1.63   16 Dec 1996 14:41:08   RHAZRA
// Changed a bitstream error ASSERT to a bonafide error.
// 
//    Rev 1.62   16 Dec 1996 09:09:42   RHAZRA
// Now LOSS_RECOVERY mode is turned on by default in Pass 1
// 
//    Rev 1.61   12 Dec 1996 09:36:04   SCDAY
// 
// Changed size of a couple of data structures in H263InitDecoderInstance
// to improve memory footprint
// 
//    Rev 1.60   18 Nov 1996 17:12:38   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.59   13 Nov 1996 11:35:56   RHAZRA
// Added MMX_autosensing.
// 
//    Rev 1.58   11 Nov 1996 11:03:28   MBODART
// Fixed bug where block action block type was not explicitly initialized for
// skipped macro blocks.  This led to the block edge filter being used more
// often than needed.
// 
//    Rev 1.57   04 Nov 1996 08:43:18   RHAZRA
// Fixed setting MMX on or off via the INI file when the MMX key
// has an illegal value (<0 or > 1) assigned to it.
// 
//    Rev 1.56   31 Oct 1996 08:58:34   SCDAY
// Raj added support for MMX decoder
// 
//    Rev 1.55   30 Oct 1996 09:59:46   MBODART
// Fixed mirroring.  Need to use absolute value of dst biWidth in most context
// Also made cosmetic changes to DibXY.  It's identical to H.263's DibXY, we
// should probably put it into a common file.
// 
//    Rev 1.54   27 Sep 1996 14:59:32   MBODART
// DECODE_STATS enabled build will now compile, but numbers aren't accurate.
// 
//    Rev 1.53   26 Sep 1996 12:30:00   RHAZRA
// Added (i) MMX sensing in the decoder and ini file reading (requires a new
// "MMX" section in h263test.ini to turn off MMX on a MMX CPU) and (ii)
// MMX & PentiumPro CCs.
// 
//    Rev 1.52   25 Sep 1996 17:35:20   BECHOLS
// 
// Added code just prior to color conversion that will perform the
// Snapshot copy on request.
// 
//    Rev 1.51   24 Sep 1996 13:52:24   RHAZRA
// Changed fpBlockAction synchronization to deal with MBAP being biased
// by -1 in the RTP extension.
// 
//    Rev 1.50   17 Sep 1996 22:08:36   RHAZRA
// Added code in RTP packet loss recovery to read GOB number from the
// bitstream when the packet following the lost packet starts with a
// GOB start code. 
// 
//    Rev 1.49   16 Sep 1996 09:28:56   RHAZRA
// Fixed a bug in MB-level fragmentation recovery.
// 
//    Rev 1.48   12 Sep 1996 14:23:12   MBODART
// Replaced GlobalAlloc family with HeapAlloc in the H.261 decoder.
// 
//    Rev 1.47   10 Sep 1996 15:51:42   RHAZRA
// Bug fixes in RTP packet loss recovery when bad GBSC or MBA is
// detected in the PPM generated lost packet.
// 
//    Rev 1.45   04 Sep 1996 09:52:32   RHAZRA
// Added a new pass 1 function to enable RTp decoder resiliency when
// LOSS_RECOVERY is defined.
// 
//    Rev 1.44   14 Aug 1996 08:41:04   RHAZRA
// 
// Added support for YUV12 and YUY2 color convertors
// 
//    Rev 1.43   09 Aug 1996 17:23:10   MBODART
// Fixed uninitialized variable bugs:  one in decoder rearchitecture, where
// MB type needed to be defined for skipped blocks; and one previously
// existing bug where the block action u8BlkType needed to be defined
// for skip blocks, in order to suppress the BEF on those blocks.
// These bugs render build 027 of H.261 broken.
// 
//    Rev 1.42   05 Aug 1996 11:00:30   MBODART
// 
// H.261 decoder rearchitecture:
// Files changed:  d1gob.cpp, d1mblk.{cpp,h}, d1dec.{cpp,h},
//                 filelist.261, h261_32.mak
// New files:      d1bvriq.cpp, d1idct.cpp
// Obsolete files: d1block.cpp
// Work still to be done:
//   Update h261_mf.mak
//   Optimize uv pairing in d1bvriq.cpp and d1idct.cpp
//   Fix checksum code (it doesn't work now)
//   Put back in decoder stats
// 
//    Rev 1.41   10 Jul 1996 08:20:44   SCDAY
// Increased memory allocation for I420
// 
//    Rev 1.40   03 Jun 1996 12:21:52   AKASAI
// Initialized DC = NULL and added tests so that don't try to free
// and unlock if DC == NULL.  This effected the "done" return area
// of H263Decompress and one other place.
// 
// Also added checking of return status from reading GOB start code.
// 
//    Rev 1.39   03 May 1996 15:54:26   AKASAI
// Eliminate allocating space for B frame in decoder.  This frame is 
// not used.
// 
//    Rev 1.38   17 Apr 1996 18:36:30   AKASAI
// Updates to use non-distructive color convertors.
// Color Convertor has modified parameter list.
// FrameCopy is called only when BlockEdgeFilter is enabled or
//   AdjustPels is enabled or when mirroring is enabled. 
//   For H.261 bitstreams.
// A frame copy is used for YUV12 when mirroring is enabled or
//   AdjustPels is enabled.
// 
// Basically normal processing without BEF you don't have to do
//   a frame copy which saves ~2msec per frame QCIF.
// 
//    Rev 1.37   05 Apr 1996 14:22:18   AKASAI
// 
// Added support for BlockEdgeFilter.
// Need to change where ReInitializeBlockActionStream was called.
// 
//    Rev 1.36   21 Mar 1996 16:59:54   AKASAI
// Needed to move location of picture checksum calculation because
// of the swap of Previous and Current Frames.
// 
//    Rev 1.35   18 Mar 1996 15:52:06   AKASAI
// Many, many changes.
// 1) To optimize for performance eliminated memcpy of current to
//    previous frame.  Now switch the pointers and re-initialize
//    block Action stream.  New routine H263ReInitializeBlockActionStream
//    written and called after each frame is compressed.  This
//    change accounted to 3-4 of the 4-5 msec improvment.
// 2) Needed to add call to BlockCopy (NOTE: maybe BlockCopySpecial would
//    be faster) to copy any skip blocks at the end of a GOB from
//    previous to current.  Change was necessary after 1).
// 3) Deleted some dead code 
// 4) Changed timing statistic code some.
// 
//    Rev 1.34   29 Feb 1996 09:20:30   SCDAY
// Added support for mirroring
// 
//    Rev 1.33   14 Feb 1996 11:54:26   AKASAI
// Update to use new color convertors that fix palette flash.
// Also corrected data alignment problem which improves performance
// of decoder.
// 
//    Rev 1.32   09 Feb 1996 13:33:36   AKASAI
// 
// Updated interface to call new AdjustPels routine.  CustomChange
// Brightness, Saturation and Contrast seem to be working but very
// little testing has been done.
// 
//    Rev 1.31   12 Jan 1996 15:12:34   AKASAI
// Fixed pink blocks in RING0 QCIF TO FCIF by fixing static initialzation
// of GOBUpdate arrays.  Was based on input parameter but now on constant.
// 
//    Rev 1.30   11 Jan 1996 16:57:00   DBRUCKS
// 
// added GetDecoderOptions
// added use of bUseBlockEdgeFilter
// added use of bForceOnAspectRatioCorrection
// Changed to do aspect ratio correction for both I420 and H261 if either
// forced or specified by result of the DecompressQuery
// 
//    Rev 1.29   26 Dec 1995 17:40:54   DBRUCKS
// 
// changed bTimerIsOn to bTimingThisFrame because it is used after STOP_TIMER
// fixed YUV12 decode when timer ifdefs are defined
// 
//    Rev 1.28   26 Dec 1995 12:48:18   DBRUCKS
// remove TIMING code
// add general purpose timing code using d1stat.*
// 
//    Rev 1.26   21 Dec 1995 17:49:06   AKASAI
// Replaced an uninitialized variable to AdjustPels with the correct on.
// Change of Contrast, Brightness and Saturation is not working correctly.
// 
//    Rev 1.25   13 Dec 1995 14:23:52   AKASAI
// Deleted setting of Initialized to False; Added calling of H263TermDecoderIn
// if Initialized == True.
// 
//    Rev 1.24   05 Dec 1995 10:20:12   SCDAY
// Cleaned up warnings
// 
//    Rev 1.23   17 Nov 1995 15:21:48   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.22   17 Nov 1995 15:13:18   SCDAY
// 
// Added key field to picture checksum data
// 
//    Rev 1.21   16 Nov 1995 18:11:42   AGANTZX
// Added p5 timing code (#define TIMING) 
// 
//    Rev 1.20   15 Nov 1995 19:04:12   AKASAI
// Should now be able to play raw YUV12 files.  Note: funny white stop
// when I play downriv4.avi.
// 
//    Rev 1.19   15 Nov 1995 14:27:22   AKASAI
// Added support for YUV12 "if 0" old code with aspec correction and
// 8 to 7 bit conversion.  Added FrameCopy calls and DispFrame into structure.
// (Integration point)
// 
//    Rev 1.18   08 Nov 1995 14:58:02   SCDAY
// Added picture layer checksums
// 
//    Rev 1.17   03 Nov 1995 11:42:54   AKASAI
// 
// Added and changed code to handle MB checksum hopefully better.
// 
//    Rev 1.16   01 Nov 1995 13:46:02   AKASAI
// 
// Added allocation of temporary buffer for loop filter.  uFilterBBuffer
// right after uMBBuffer.
// 
//    Rev 1.15   30 Oct 1995 16:20:26   AKASAI
// Fixed up extra bytes some more.  Doug and Sylvia had already decided
// on 2 extra bytes for the decoder instead of 4.  We now copy 2 zeros
// at the end of the biSizeImage.
// 
//    Rev 1.14   30 Oct 1995 15:38:22   AKASAI
// Frame 94 of grouch read past the end of the bit stream finding junk.
// Enabled code Sylvia had put in to copy 4 bytes of zero after biSizeImage.
// This seems to fix the problem playing grouch.avi.
// 
//    Rev 1.13   27 Oct 1995 19:11:26   AKASAI
// Added some special case code to handle when skip macroblock is last
// in a gob.
// 
//    Rev 1.12   27 Oct 1995 18:17:22   AKASAI
// 
// Put in fix "hack" to keep the block action stream pointers
// in sync between d1dec and d1mblk.  With skip macro blocks some
// macroblocks were being processed multiple times.  Still a problem
// when gob ends with a skip macroblock.
// 
//    Rev 1.11   26 Oct 1995 15:33:10   SCDAY
// 
// Delta frames partially working -- changed main loops to accommodate
// skipped macroblocks by detecting next startcode
// 
//    Rev 1.10   16 Oct 1995 13:53:46   SCDAY
// 
// Added macroblock level checksum
// 
//    Rev 1.9   10 Oct 1995 15:44:02   SCDAY
// clean up
// 
//    Rev 1.8   10 Oct 1995 14:58:10   SCDAY
// 
// added support for FCIF
// 
//    Rev 1.7   06 Oct 1995 15:32:28   SCDAY
// 
// Integrated with latest AKK d1block
// 
//    Rev 1.6   04 Oct 1995 15:24:46   SCDAY
// changed test pattern stuff
// 
//    Rev 1.5   22 Sep 1995 15:07:02   SCDAY
// Doug fixed ASSERT bug, scd debug changes
// 
//    Rev 1.2   19 Sep 1995 15:25:32   SCDAY
// 
// added H261 pict, GOB, MB/MBA parsing
// 
//    Rev 1.1   12 Sep 1995 15:52:24   DBRUCKS
// add SKIP_DECODE option for encoder work
// 
//    Rev 1.0   11 Sep 1995 13:51:48   SCDAY
// Initial revision.
// 
//    Rev 1.18   05 Sep 1995 17:22:12   DBRUCKS
// u & v are offset by 8 from Y in YVU12ForEnc
// 
//    Rev 1.17   01 Sep 1995 17:13:52   DBRUCKS
// add adjustpels
// 
//    Rev 1.16   01 Sep 1995 09:49:34   DBRUCKS
// checkin partial ajdust pels changes
// 
//    Rev 1.15   29 Aug 1995 16:50:40   DBRUCKS
// add support for YVU9 playback
// 
//    Rev 1.14   28 Aug 1995 17:45:58   DBRUCKS
// add yvu12forenc
// 
//    Rev 1.13   28 Aug 1995 10:15:14   DBRUCKS
// update to 5 July Spec and 8/25 Errata
// 
//    Rev 1.12   24 Aug 1995 08:51:30   CZHU
// Turned off apsect ratio correction. 
// 
//    Rev 1.11   23 Aug 1995 12:25:10   DBRUCKS
// Turn on the color converters
// 
//    Rev 1.10   14 Aug 1995 16:40:34   DBRUCKS
// initialize block action stream
// 
//    Rev 1.9   11 Aug 1995 17:47:58   DBRUCKS
// cleanup
// 
//    Rev 1.8   11 Aug 1995 17:30:00   DBRUCKS
// copy source to bitstream
// 
//    Rev 1.7   11 Aug 1995 16:12:14   DBRUCKS
// add ptr check to MB data and add #ifndef early exit
// 
//    Rev 1.6   11 Aug 1995 15:10:18   DBRUCKS
// get ready to integrate with block level code and hook up macro block level code
// 
//    Rev 1.5   03 Aug 1995 14:57:56   DBRUCKS
// Add ASSERT macro
// 
//    Rev 1.4   02 Aug 1995 15:31:34   DBRUCKS
// added GOB header parsing
// 
//    Rev 1.3   01 Aug 1995 12:27:38   DBRUCKS
// add PSC parsing
// 
//    Rev 1.2   31 Jul 1995 16:28:00   DBRUCKS
// move loacl BITS defs to D3DEC.CPP
// 
//    Rev 1.1   31 Jul 1995 15:32:22   CZHU
// Moved global tables to d3tables.h
// 
//    Rev 1.0   31 Jul 1995 13:00:04   DBRUCKS
// Initial revision.
// 
//    Rev 1.3   28 Jul 1995 13:57:36   CZHU
// Started to add picture level decoding of fixed length codes.
// 
//    Rev 1.2   24 Jul 1995 14:57:52   CZHU
// Added global tables for VLD decoding. Also added instance initialization
// and termination. Several data structures are updated for H.263.
// 
//    Rev 1.1   17 Jul 1995 14:46:20   CZHU
// 
// 
//    Rev 1.0   17 Jul 1995 14:14:40   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////// 

#include "precomp.h"

static int iNumberOfGOBsBySourceFormat[2] = {
	 3, /* QCIF */
//	 10,
	12, /* CIF */
};

static int iNumberOfMBsInAGOBBySourceFormat[2] = {
	33, /* QCIF */
	33, /* CIF */
};

// rearch
//#ifndef LOSS_RECOVERY
#if 0
static LRESULT IAPass1ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start
);
#else
static LRESULT IAPass1ProcessFrameRTP(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start
);
#endif

static void IAPass2ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs
);
// rearch

static long DibXY(ICDECOMPRESSEX FAR *lpicDecEx, LPINT lpiPitch, UINT yScale, BOOL bIsDCI);

static void GetDecoderOptions(T_H263DecoderCatalog *);

#define START_CODE 0xff18

static void ZeroFill(HPBYTE hpbY, HPBYTE hpbU, HPBYTE hpbV, int iPitch, U32 uWidth, U32 uHeight);

extern T_H263ColorConvertorCatalog ColorConvertorCatalog[];

extern void BlockCopy(
            U32 uDstBlock, 
            U32 uSrcBlock);

extern void BlockEdgeFilter(U8 *YPlane, int Height, int Width, int Pitch, T_BlkAction *lpBlockAction);

LRESULT H263InitDecoderGlobal(void)
{ //For 32-bit decoder, this is empty for now, 7/29/95
  //need to add code for 16 bit version.

 return ICERR_OK;
}



/////////////////////////////////////////////////////////////////////////
//
//  H263InitializeBlockActionStream
//
//  Initialize the block action stream
//
static void H263InitializeBlockActionStream(
	T_H263DecoderCatalog * DC)
{
	U8 FAR * pu8;
	U32 uFrameHeight = DC->uFrameHeight;
	U32 uFrameWidth = DC->uFrameWidth;
	U32 uCurBlock; 
	U32 uRefBlock;
	U32 uBBlock;
	U32 uYOffset;
	U32 uUOffset;
	U32 uVOffset;
	U32 x; 
	U32 y;
	U32 g;
	U32 uPitch16;
	U32 uPitch8;
	U32 uYUpdate;
	U32 uUVUpdate;
	U32 uBlkNumber;
	T_BlkAction FAR * fpBlockAction;

	// Offsets for stepping thru GOBs for FCIF processing
	static U32 uYGOBFCIFUpdate[12] = 
	{
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
	};
	static U32 uUVGOBFCIFUpdate[12] = 
	{
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
	};

	// assume that the width and height are multiples of 16
	ASSERT((uFrameHeight & 0xF) == 0);
	ASSERT((uFrameWidth & 0xF) == 0);

	// Init uPitch16 and uPitch8
	uPitch16 = PITCH*16;
	uPitch8 = PITCH*8;
	
	// Point to the allocated space
	pu8 = (U8 FAR *) DC;
	uCurBlock = (U32) (pu8 + DC->CurrFrame.X32_YPlane); 
	uRefBlock = (U32) (pu8 + DC->PrevFrame.X32_YPlane);
	uBBlock = (U32) (pu8 + DC->PBFrame.X32_YPlane);

	// skip the padding used for unconstrained motion vectors
	uYOffset = Y_START;
	uUOffset = DC->uSz_YPlane + UV_START;
	uVOffset = uUOffset + (PITCH >> 1);
	
	// start with block zero
	uBlkNumber = 0;
	
	if (uFrameWidth == QCIF_WIDTH)
	{ /* if QCIF */
		// calculate distance to the next row.
		uYUpdate = (16 * PITCH) - uFrameWidth;
		uUVUpdate = (8 * PITCH) - (uFrameWidth >> 1);

		// Initialize the array
		fpBlockAction = (T_BlkAction FAR *) (pu8 + DC->X16_BlkActionStream);
		for (y = 0 ; y < uFrameHeight ; y += 16) {
			for (x = 0 ; x < uFrameWidth ; x += 16) {
				// Four Y Blocks
				//     Y0 Y1
				//     Y2 Y3
				fpBlockAction->pCurBlock = uCurBlock + uYOffset;
				fpBlockAction->pRefBlock = uRefBlock + uYOffset;
				fpBlockAction->pBBlock = uBBlock + uYOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uYOffset += 8;
				fpBlockAction++;
			
				fpBlockAction->pCurBlock = uCurBlock + uYOffset;
				fpBlockAction->pRefBlock = uRefBlock + uYOffset;
				fpBlockAction->pBBlock = uBBlock + uYOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uYOffset = uYOffset - 8 + (8 * PITCH);
				fpBlockAction++;
			
				fpBlockAction->pCurBlock = uCurBlock + uYOffset;
				fpBlockAction->pRefBlock = uRefBlock + uYOffset;
				fpBlockAction->pBBlock = uBBlock + uYOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uYOffset += 8;
				fpBlockAction++;
			
				fpBlockAction->pCurBlock = uCurBlock + uYOffset;
				fpBlockAction->pRefBlock = uRefBlock + uYOffset;
				fpBlockAction->pBBlock = uBBlock + uYOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uYOffset = uYOffset + 8 - (8 * PITCH);
				fpBlockAction++;
			
				// One CR (V) Block
				fpBlockAction->pCurBlock = uCurBlock + uVOffset;
				fpBlockAction->pRefBlock = uRefBlock + uVOffset;
				fpBlockAction->pBBlock = uBBlock + uVOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uVOffset += 8;
				fpBlockAction++;
			
				// One CB (U) Block
				fpBlockAction->pCurBlock = uCurBlock + uUOffset;
				fpBlockAction->pRefBlock = uRefBlock + uUOffset;
				fpBlockAction->pBBlock = uBBlock + uUOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uUOffset += 8;
				fpBlockAction++;
				
			}
			uYOffset += uYUpdate;
			uUOffset += uUVUpdate;
			uVOffset += uUVUpdate;
		}
	} /* end if QCIF */
	if (uFrameWidth == FCIF_WIDTH)
	{ /* if FCIF */
		// calculate distance to the next row.
		uYUpdate = (16 * PITCH) - (uFrameWidth >> 1);
		uUVUpdate = (8 * PITCH) - (uFrameWidth >> 2);

		// Initialize the array
		fpBlockAction = (T_BlkAction FAR *) (pu8 + DC->X16_BlkActionStream);
		for (g = 0; g < 12; g++) { /* for each GOB */
			
			for (y = 0 ; y < 3 ; y++) { /* for each row in GOB */
				for (x = 0 ; x < (uFrameWidth >> 1) ; x += 16) {
					// Four Y Blocks
					//     Y0 Y1
					//     Y2 Y3
					fpBlockAction->pCurBlock = uCurBlock + uYOffset;
					fpBlockAction->pRefBlock = uRefBlock + uYOffset;
					fpBlockAction->pBBlock = uBBlock + uYOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uYOffset += 8;
					fpBlockAction++;
			
					fpBlockAction->pCurBlock = uCurBlock + uYOffset;
					fpBlockAction->pRefBlock = uRefBlock + uYOffset;
					fpBlockAction->pBBlock = uBBlock + uYOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uYOffset = uYOffset - 8 + (8 * PITCH);
					fpBlockAction++;
					
					fpBlockAction->pCurBlock = uCurBlock + uYOffset;
					fpBlockAction->pRefBlock = uRefBlock + uYOffset;
					fpBlockAction->pBBlock = uBBlock + uYOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uYOffset += 8;
					fpBlockAction++;
					
					fpBlockAction->pCurBlock = uCurBlock + uYOffset;
					fpBlockAction->pRefBlock = uRefBlock + uYOffset;
					fpBlockAction->pBBlock = uBBlock + uYOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uYOffset = uYOffset + 8 - (8 * PITCH);
					fpBlockAction++;
			
					// One CR (V) Block
					fpBlockAction->pCurBlock = uCurBlock + uVOffset;
					fpBlockAction->pRefBlock = uRefBlock + uVOffset;
					fpBlockAction->pBBlock = uBBlock + uVOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uVOffset += 8;
					fpBlockAction++;
					
					// One CB (U) Block
					fpBlockAction->pCurBlock = uCurBlock + uUOffset;
					fpBlockAction->pRefBlock = uRefBlock + uUOffset;
					fpBlockAction->pBBlock = uBBlock + uUOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uUOffset += 8;
					fpBlockAction++;
					
				}
				uYOffset += uPitch16 - (uFrameWidth >> 1);
				uUOffset += uPitch8 - (uFrameWidth >> 2);
				uVOffset += uPitch8 - (uFrameWidth >> 2);
			}
			uYOffset -= uYGOBFCIFUpdate[g];
			uUOffset -= uUVGOBFCIFUpdate[g];
			uVOffset -= uUVGOBFCIFUpdate[g];
		}
	} /* end if FCIF */

} // end H263InitializeBlockActionStream() 

/////////////////////////////////////////////////////////////////////////
//
//  H261ReInitializeBlockActionStream
//
//  ReInitialize the block action stream
//
static void H261ReInitializeBlockActionStream(
	T_H263DecoderCatalog * DC)
{
	U8 FAR * pu8;
	U32 uFrameHeight = DC->uFrameHeight;
	U32 uFrameWidth = DC->uFrameWidth;
	U32 utemp;
	U32 x; 
	U32 y;
	U32 g;
	T_BlkAction FAR * fpBlockAction;

	pu8 = (U8 FAR *) DC;

	if (uFrameWidth == QCIF_WIDTH)
	{ /* if QCIF */

		// Initialize the array
		fpBlockAction = (T_BlkAction FAR *) (pu8 + DC->X16_BlkActionStream);
		for (y = 0 ; y < uFrameHeight ; y += 16) {
			for (x = 0 ; x < uFrameWidth ; x += 16) {
				// Four Y Blocks
				//     Y0 Y1
				//     Y2 Y3

				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				// One CR (V) Block
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				// One CB (U) Block
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
			}
		}
	} /* end if QCIF */
	if (uFrameWidth == FCIF_WIDTH)
	{ /* if FCIF */

		// Initialize the array
		fpBlockAction = (T_BlkAction FAR *) (pu8 + DC->X16_BlkActionStream);
		for (g = 0; g < 12; g++) { /* for each GOB */
			
			for (y = 0 ; y < 3 ; y++) { /* for each row in GOB */
				for (x = 0 ; x < (uFrameWidth >> 1) ; x += 16) {
					// Four Y Blocks
					//     Y0 Y1
					//     Y2 Y3

					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					// One CR (V) Block
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					// One CB (U) Block
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
				}
			}
		}
	} /* end if FCIF */

} // end H261ReInitializeBlockActionStream() 

//////////////////////////////////////////////////////////////////////////////
//
//  H263InitDecoderInstance 
//
//  This function allocates and initializes the per-instance tables used by 
//  the H263 decoder. Note that in 16-bit Windows, the non-instance-specific
//  global tables are copied to the per-instance data segment, so that they 
//  can be used without segment override prefixes.
//
LRESULT H263InitDecoderInstance(LPDECINST lpInst, int CodecID)
{ 
	U32 u32YActiveHeight, u32YActiveWidth;
	U32 u32UVActiveHeight, u32UVActiveWidth;
	U32 u32YPlane, u32VUPlanes ,u32YVUPlanes,u32SizeBlkActionStream;
	U32 uSizeBitStreamBuffer;
	U32 uSizeDecTimingInfo;
	U32 lOffset=0;
	U32 u32TotalSize;
	LRESULT iReturn= ICERR_OK;
	U32 * pInitLimit;
	U32 * pInitPtr;

	// rearch
    U32 u32SizeT_IQ_INDEXBuffer, u32SizepNBuffer, u32SizeMBInfoStream;  // NEW
	// rearch

	T_H263DecoderCatalog * DC;
	U8 * P32Inst;

	SECURITY_ATTRIBUTES EventAttributes;	// Used with Snapshot.

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
	{
		DBOUT("ERROR :: H263InitDecoderInstance :: ICERR_BADPARAM");
		iReturn = ICERR_BADPARAM;
		goto done;
	}

	if ((CodecID == YUV12_CODEC && (lpInst->yres > 480 || lpInst->xres > 640)) ||
	  (CodecID ==  H263_CODEC && (lpInst->yres > 288 || lpInst->xres > 352)))
	{
		DBOUT("ERROR :: H263InitDecoderInstance :: ICERR_BADSIZE");
		iReturn = ICERR_BADSIZE;
		goto done;
	}

	if (CodecID == YUV12_CODEC) 
	{
		/* The active height and width must be padded to a multiple of 8
		 * since the adjustpels routine relies on it.
		 */
		u32YActiveHeight  = ((lpInst->yres + 0x7) & (~ 0x7));
		u32YActiveWidth   = ((lpInst->xres + 0x7) & (~ 0x7));
		u32UVActiveHeight = ((lpInst->yres + 0xF) & (~ 0xF)) >> 1;
		u32UVActiveWidth  = ((lpInst->xres + 0xF) & (~ 0xF)) >> 1;

		u32YPlane         = u32YActiveWidth  * u32YActiveHeight;
		u32VUPlanes       = u32UVActiveWidth * u32UVActiveHeight * 2;
		u32YVUPlanes      = u32YPlane + u32VUPlanes;
// added for I420 output support
// wasn't allocating enough memory for YUV12 output, no color convert case

		// calculate the block action stream size.  The Y portion has one block for
		// every 8x8 region.  The U and V portion has one block for every 16x16 region.
		// We also want to make sure that the size is aligned to a cache line.
		u32SizeBlkActionStream = (lpInst->xres >> 3) * (lpInst->yres >> 3);
		u32SizeBlkActionStream += ((lpInst->xres >> 4) * (lpInst->yres >> 4)) * 2;
		u32SizeBlkActionStream *= sizeof (T_BlkAction);
		u32SizeBlkActionStream = (u32SizeBlkActionStream + 31) & ~0x1F;	 

		// calculate the bitstream buffer size.  We copy the input data to a buffer
		// in our space because we read ahead up to 4 bytes beyond the end of the 
		// input data.  The input data size changes for each frame.  So the following 
		// is a very safe upper bound estimate.	
		// Add + 2 for extra zeros for start code emulation.  AKK
		uSizeBitStreamBuffer = lpInst->yres * lpInst->xres + 2;
	
		#ifdef DECODE_STATS
			uSizeDecTimingInfo = DEC_TIMING_INFO_FRAME_COUNT * sizeof (DEC_TIMING_INFO);
		#else
			uSizeDecTimingInfo = 0;
		#endif

		u32TotalSize = INSTANCE_DATA_FIXED_SIZE +
		               u32SizeBlkActionStream +
		               u32YVUPlanes +			// current frame
					   u32YVUPlanes +			// prev frame
					   BLOCK_BUFFER_SIZE +
					   FILTER_BLOCK_BUFFER_SIZE +
					   uSizeBitStreamBuffer + 	// input data
					   uSizeDecTimingInfo + 
					   0x1F;

//    	u32TotalSize = 512L + 0x1FL;   /* Just enough space for Decoder Catalog. */
	}
	else
	{
		ASSERT(CodecID == H263_CODEC);
		u32YActiveHeight  = lpInst->yres + UMV_EXPAND_Y + UMV_EXPAND_Y ;
		u32YActiveWidth   = lpInst->xres + UMV_EXPAND_Y + UMV_EXPAND_Y ;
		u32UVActiveHeight = u32YActiveHeight/2;
		u32UVActiveWidth  = u32YActiveWidth /2;

		u32YPlane         = PITCH * u32YActiveHeight;
		u32VUPlanes       = PITCH * u32UVActiveHeight;
		u32YVUPlanes      = u32YPlane + u32VUPlanes;

		// calculate the block action stream size.  The Y portion has one block for
		// every 8x8 region.  The U and V portion has one block for every 16x16 region.
		// We also want to make sure that the size is aligned to a cache line.
		u32SizeBlkActionStream = (lpInst->xres >> 3) * (lpInst->yres >> 3);
		u32SizeBlkActionStream += ((lpInst->xres >> 4) * (lpInst->yres >> 4)) * 2;
		u32SizeBlkActionStream *= sizeof (T_BlkAction);
		u32SizeBlkActionStream = (u32SizeBlkActionStream + 31) & ~0x1F;	 

		// calculate the bitstream buffer size.  We copy the input data to a buffer
		// in our space because we read ahead up to 4 bytes beyond the end of the 
		// input data.  The input data size changes for each frame.  So the following 
		// is a very safe upper bound estimate.	
		// Add + 2 for extra zeros for start code emulation.  AKK
		
		// Add some additional to make sure stay dword align (rearch)
		uSizeBitStreamBuffer = (lpInst->yres * lpInst->xres + 2 + 4) & ~0x3;
			
		// rearch
        // calculate sizes of NEW data structures     
        u32SizeT_IQ_INDEXBuffer = (lpInst->xres)*(lpInst->yres*2)*
                                                 sizeof(T_IQ_INDEX);
        u32SizepNBuffer = (lpInst->xres>>4)*(lpInst->yres>>4)*sizeof(U32)*6;
        u32SizeMBInfoStream = (lpInst->xres>>4)*(lpInst->yres>>4)*
                                                 sizeof(T_MBInfo);
		// rearch

		#ifdef DECODE_STATS
			uSizeDecTimingInfo = DEC_TIMING_INFO_FRAME_COUNT * sizeof (DEC_TIMING_INFO);
		#else
			uSizeDecTimingInfo = 0;
		#endif

		u32TotalSize = INSTANCE_DATA_FIXED_SIZE +
		               u32SizeBlkActionStream +
		               u32YVUPlanes +			// current frame
					   u32YVUPlanes +			// prev frame
					   BLOCK_BUFFER_SIZE +
					   FILTER_BLOCK_BUFFER_SIZE +
					   uSizeBitStreamBuffer + 	// input data
                       u32SizeT_IQ_INDEXBuffer + // NEW
                       u32SizepNBuffer         + // NEW
                       u32SizeMBInfoStream     + // PB-NEW
					   uSizeDecTimingInfo + 
					   0x1F;
	}

	/* If already initialized, terminate this instance before allocating
	 * another.
	 */
	if(lpInst->Initialized == TRUE)
	{
	    H263TermDecoderInstance(lpInst);
	}

	// allocate the memory for the instance
	lpInst->pDecoderInst = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                 u32TotalSize);
	if (lpInst->pDecoderInst == NULL)
	{
		DBOUT("ERROR :: H263InitDecoderInstance :: ICERR_MEMORY");
		iReturn = ICERR_MEMORY;
		goto  done;
	}

	//build the decoder catalog 
	P32Inst = (U8 *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
 
	//The catalog of per-instance data is at the start of the per-instance data.
	DC = (T_H263DecoderCatalog *) P32Inst;

	DC->DecoderType       = CodecID;
	DC->uFrameHeight      = lpInst->yres;
	DC->uFrameWidth       = lpInst->xres;
	DC->uYActiveHeight    = u32YActiveHeight;
	DC->uYActiveWidth     = u32YActiveWidth;
	DC->uUVActiveHeight   = u32UVActiveHeight;
	DC->uUVActiveWidth    = u32UVActiveWidth;
	DC->uSz_YPlane        = u32YPlane;
	DC->uSz_VUPlanes      = u32VUPlanes;
	DC->uSz_YVUPlanes     = u32YVUPlanes;
	DC->BrightnessSetting = H26X_DEFAULT_BRIGHTNESS;
	DC->ContrastSetting   = H26X_DEFAULT_CONTRAST;
	DC->SaturationSetting = H26X_DEFAULT_SATURATION;
	DC->iAPColorConvPrev  = 0;
	DC->pAPInstPrev       = NULL; // assume no previous AP instance.
	DC->p16InstPostProcess = NULL;
	DC->a16InstPostProcess = NULL;
	DC->bReadSrcFormat = 0;

	EventAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	EventAttributes.lpSecurityDescriptor = NULL;
	EventAttributes.bInheritHandle = FALSE;
	DC->SnapshotEvent = CreateEvent(&EventAttributes, TRUE, FALSE, NULL);



	/* Get the Options
	 */
	GetDecoderOptions(DC);

	if (CodecID == H263_CODEC)
	{

		lOffset =  INSTANCE_DATA_FIXED_SIZE;
		DC->Ticker = 127;

		//instance dependent table here
		DC->X16_BlkActionStream = lOffset;
		lOffset += u32SizeBlkActionStream;

		DC-> CurrFrame.X32_YPlane = lOffset;
		lOffset += DC->uSz_YPlane;

		DC->CurrFrame.X32_VPlane = lOffset;
		DC->CurrFrame.X32_UPlane = DC->CurrFrame.X32_VPlane + U_OFFSET;
		lOffset += DC->uSz_VUPlanes;

		//no padding is needed 
		DC->PrevFrame.X32_YPlane = lOffset;
		lOffset += DC->uSz_YPlane;

		DC->PrevFrame.X32_VPlane = lOffset;
		DC->PrevFrame.X32_UPlane = DC->PrevFrame.X32_VPlane + U_OFFSET;
		lOffset += DC->uSz_VUPlanes;

		DC->uMBBuffer = lOffset;
		lOffset += BLOCK_BUFFER_SIZE;
		
		DC->uFilterBBuffer = lOffset;
		lOffset += FILTER_BLOCK_BUFFER_SIZE;
		
		// Bitstream
	    ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_BitStream = lOffset;
		lOffset += uSizeBitStreamBuffer;
		DC->uSizeBitStreamBuffer = uSizeBitStreamBuffer;

		// rearch
        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_InverseQuant = lOffset; 
        lOffset += u32SizeT_IQ_INDEXBuffer; 

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_pN = lOffset; 
        lOffset += u32SizepNBuffer; 

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_uMBInfoStream = lOffset; 
        lOffset += u32SizeMBInfoStream; 
		// rearch

		#ifdef DECODE_STATS
		// Decode Timing Info
		DC->X32_DecTimingInfo = lOffset;
		lOffset += uSizeDecTimingInfo;
		#endif

		// init the data
		ASSERT((U32)lOffset <= u32TotalSize);
		pInitLimit = (U32  *) (P32Inst + lOffset);
		pInitPtr = (U32  *) (P32Inst + DC->CurrFrame.X32_YPlane);
		for (;pInitPtr < pInitLimit;pInitPtr++)	*pInitPtr =0;

		// Fill the Y,U,V Previous Frame space with black, this way
		// even if we lost an I frame, the background will remain black
		ZeroFill((HPBYTE)P32Inst + DC->PrevFrame.X32_YPlane + Y_START,
				(HPBYTE)P32Inst + DC->PrevFrame.X32_UPlane + UV_START,
				(HPBYTE)P32Inst + DC->PrevFrame.X32_VPlane + UV_START,           
				PITCH,
				DC->uFrameWidth,
				DC->uFrameHeight);

		H263InitializeBlockActionStream(DC);

	} // not YVU9

	lpInst->Initialized = TRUE;
	iReturn = ICERR_OK;

done:
	return iReturn;
}

/***********************************************************************
 *  ZeroFill
 *    Fill the YVU data area with black.
 ***********************************************************************/
static void	ZeroFill(HPBYTE hpbY, HPBYTE hpbU, HPBYTE hpbV, int iPitch, U32 uWidth, U32 uHeight)
{
    U32 w,h;
    int y,u,v;
    U32 uNext;
    HPBYTE pY, pU, pV;

    y = 32;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pY = hpbY;
        for (w = 0; w < uWidth ; w++) {
            *hpbY++ = (U8)16;
        }
        hpbY += uNext;
    }
    uWidth = uWidth / 2;
    uHeight = uHeight / 2;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pV = hpbV;
        pU = hpbU;
        for (w = 0; w < uWidth ; w++) {
            *hpbV++ = (U8)128;
            *hpbU++ = (U8)128;
        }
        hpbV += uNext;
        hpbU += uNext;
    }
}

//***********************************************************************
//
//  TestFill
//
//  Fill the YVU data area with a test pattern.
//
#if 0
static void
TestFill(
	HPBYTE hpbY,
	HPBYTE hpbU,
	HPBYTE hpbV,
	int iPitch,
	U32 uWidth,
	U32 uHeight)
{
	U32 w,h;
	int y,u,v;
	U32 uNext;
	HPBYTE pY, pU, pV;

	y = 32;
	uNext = iPitch - uWidth;
	for (h = 0 ; h < uHeight ; h++) {
		pY = hpbY;
		for (w = 0; w < uWidth ; w++) {
			*hpbY++ = (U8) (y + (w & ~0xF));
		}
		hpbY += uNext;
	}
	uWidth = uWidth / 2;
	uHeight = uHeight / 2;
	u = 0x4e * 2;
	v = 44;
	uNext = iPitch - uWidth;
	for (h = 0 ; h < uHeight ; h++) {
		pV = hpbV;
		pU = hpbU;
		for (w = 0; w < uWidth ; w++) {
			*hpbV++ = (U8) v;
			*hpbU++ = (U8) u;
		}
		hpbV += uNext;
		hpbU += uNext;
	}
} /* end TestFill */
static void
TestFillUV(
	HPBYTE hpbU,
	HPBYTE hpbV,
	int iPitch,
	U32 uWidth,
	U32 uHeight)
{
	U32 w,h;
	int u,v;
	U32 uNext;
	HPBYTE pU, pV;

	uWidth = uWidth / 2;
	uHeight = uHeight / 2;
	u = 128;
	v = 128;
	uNext = iPitch - uWidth;
	for (h = 0 ; h < uHeight ; h++) {
		pV = hpbV;
		pU = hpbU;
		for (w = 0; w < uWidth ; w++) {
			*hpbV++ = (U8) v;
			*hpbU++ = (U8) u;
		}
		hpbV += uNext;
		hpbU += uNext;
	}
} /* end TestFill */
#endif


//*********************************************************************
//H263Decompress -- This function drives the decompress 
//                  and display of one frame
//*********************************************************************
LRESULT H263Decompress(
	LPDECINST lpInst, 
		ICDECOMPRESSEX FAR * lpicDecEx, 
		BOOL bIsDCI)
{
	LRESULT iReturn = ICERR_ERROR;
	U8 FAR * fpSrc; 
	U8 FAR * P32Inst;
	U8 FAR * fpu8MaxPtr;
	T_H263DecoderCatalog * DC = NULL;
	int iNumberOfGOBs;
	int iNumberOfMBs;
	T_BlkAction FAR * fpBlockAction;
	LONG lOutput;
	int intPitch; 
	U32 uNewOffsetToLine0;
	U16 u16NewFrameHeight;
	int bShapingFlag;
	int uYPitch;
	int uUVPitch;
	U8 bMirror;
	HPBYTE pSource, pDestination;
	U32 utemp;

	// rearch
    T_IQ_INDEX           * pRUN_INVERSE_Q;  
    U32                  * pN;                     
    T_MBInfo FAR         * fpMBInfo;  
    I32                    gob_start = 1, mb_start = 1;    
	// rearch

	/* new variables added when change to color convertor/bef */
	U32 uYPlane, uVPlane, uUPlane;
	U8  *pFrame, *lpAligned;
    T_H26X_RTP_BSINFO_TRAILER *pBsTrailer;

	/* the following is for MB Checksum */
	U32 uReadChecksum = 0;

	#ifdef DECODE_STATS
	U32 uStartLow;
	U32 uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32	uDecodeFrameSum = 0;
	U32 uHeadersSum = 0;
	U32 uMemcpySum = 0;
	U32 uFrameCopySum = 0;
	U32 uOutputCCSum = 0;
	U32 uInitBlkActStrSum = 0;
	U32 uBEFSum = 0;
	int bTimingThisFrame = 0;
	DEC_TIMING_INFO * pDecTimingInfo = NULL;
	#endif

#ifdef CHECKSUM_PICTURE
	/* the following is for Picture Checksum */
	YVUCheckSum pReadYVUCksum;
	YVUCheckSum YVUChkSum;
	U32 uCheckSumValid = 0;		// flag to skip checksum check if
					// encoder calling decoder before
					// checksum valid
#endif

	/* The following are used for reading bits */
	U32 uWork;
	U32 uBitsReady;
	BITSTREAM_STATE bsState;
	BITSTREAM_STATE FAR * fpbsState = &bsState;
        
#ifdef SKIP_DECODE
TBD("Skipping Decode");
iReturn = ICERR_OK;
goto done;
#endif

  	/* check the input pointers
	 */
	if (IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO))||
		IsBadReadPtr((LPVOID)lpicDecEx, sizeof(ICDECOMPRESSEX)))
	{
		DBOUT("ERROR :: H263Decompress :: ICERR_BADPARAM");
    	iReturn = ICERR_BADPARAM;
    	goto done;
	}
    
	/* Check for a bad length
	 */
	if (lpicDecEx->lpbiSrc->biSizeImage == 0) {
		DBOUT("ERROR :: H263Decompress :: ICERR_BADIMAGESIZE");
		iReturn = ICERR_BADIMAGESIZE;	
		goto done;
	}
    
    /* Lock the memory
     */
	if (lpInst->pDecoderInst == NULL)
	{
		DBOUT("ERROR :: H263Decompress :: ICERR_MEMORY");
		iReturn = ICERR_MEMORY;
		goto  done;
	}

	/* Set the frame mirroring flag
	 */
	bMirror = FALSE;
	if (lpicDecEx->lpbiDst != 0)
	{
		if(lpicDecEx->lpbiSrc->biWidth * lpicDecEx->lpbiDst->biWidth < 0)
			bMirror = TRUE;
	}
/* for testing */
/*	bMirror = TRUE; */ 

	/* Build the decoder catalog pointer 
	 */
	P32Inst = (U8 FAR *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
	DC = (T_H263DecoderCatalog FAR *) P32Inst;
 
	if (DC->DecoderType == H263_CODEC)
	{
		#ifdef DECODE_STATS
			if ((DC->uStatFrameCount < DEC_TIMING_INFO_FRAME_COUNT) && 
			    (DC->ColorConvertor != YUV12ForEnc))
			{
				ASSERT(DC->X32_DecTimingInfo > 0);
				DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *)( ((U8 FAR *)P32Inst) + DC->X32_DecTimingInfo );
				TIMER_START(bTimingThisFrame,uStartLow,uStartHigh);
				ASSERT(bTimingThisFrame);
				DC->uStartLow = uStartLow;
				DC->uStartHigh = uStartHigh;
			}
			else
			{	
				DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *) NULL;
				ASSERT(!bTimingThisFrame);
			}
			DC->bTimingThisFrame = bTimingThisFrame;
		#endif

		/* Is there room to copy the bitstream? We could at most add 2 (zeros) and 3
		   padding bytes for DWORD alignment to the original bitstream */\
		ASSERT(lpicDecEx->lpbiSrc->biSizeImage + 5 <= DC->uSizeBitStreamBuffer);
		if ((lpicDecEx->lpbiSrc->biSizeImage + 5) > DC->uSizeBitStreamBuffer)
		{
			DBOUT("ERROR :: H263Decompress :: ICERR_ERROR: not enough room for bitstream");
			iReturn = ICERR_ERROR;
			goto done;
		}

		/* Copy the source data to the bitstream region.
		 * OPTIMIZE: Integrate MRV's BLKCOPY.ASM
		 */
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
		fpSrc = (U8 FAR *)(P32Inst + DC->X32_BitStream);

		// New: we will first look for an EBS from the PPM. If there is one, then we will
		//      insert two bytes of zero between the H.261 bistream and the EBS part with
		//      DWORD alignment and update the total bitstream size. If no EBS is found,
		//      then we proceed as before.
		DC->iVerifiedBsExt = FALSE;
        DC->Sz_BitStream = lpicDecEx->lpbiSrc->biSizeImage ;

		H26XRTP_VerifyBsInfoStream(DC,(U8 *) lpicDecEx->lpSrc,lpicDecEx->lpbiSrc->biSizeImage);
		
		if (!DC->iValidBsExt)
		{
			memcpy((char FAR *)fpSrc, (const char FAR *) lpicDecEx->lpSrc, lpicDecEx->lpbiSrc->biSizeImage);  

			// also copy 16 bits of zero for end of frame detection 

		    fpSrc[lpicDecEx->lpbiSrc->biSizeImage] = 0;
		    fpSrc[lpicDecEx->lpbiSrc->biSizeImage+1] = 0;

			DC->Sz_BitStream += 2;
			
			fpu8MaxPtr = fpSrc;
		    fpu8MaxPtr += (lpicDecEx->lpbiSrc->biSizeImage + 2 - 1);  

		}
		else
		{
			// First the H.261 stream data - relying on PPM to fill the compressed size correctly
			// in the trailer.

			pBsTrailer = ( (T_H26X_RTP_BSINFO_TRAILER *)(DC->pBsTrailer) );
            memcpy((char FAR *)fpSrc, (const char FAR *) lpicDecEx->lpSrc, pBsTrailer->uCompressedSize);

			// Now write out two bytes of zeros at the end of the H.261 bitstream

			fpSrc[pBsTrailer->uCompressedSize] = 0;
			fpSrc[pBsTrailer->uCompressedSize + 1] = 0;

			// Now tack on the EBS after DWORD alignment.

		
            lpAligned  = (U8 *) ( (U32) (fpSrc + (pBsTrailer->uCompressedSize + 2) + 3) &
				                        0xfffffffc);

			memcpy(lpAligned, DC->pBsInfo, DC->uNumOfPackets*sizeof(T_RTP_H261_BSINFO));

			memcpy(lpAligned + DC->uNumOfPackets*sizeof(T_RTP_H261_BSINFO), DC->pBsTrailer,
				   sizeof(T_H26X_RTP_BSINFO_TRAILER));

		   // update lpicDecEx->lpbiSrc->biSizeImage

		   DC->Sz_BitStream = lpAligned + DC->uNumOfPackets*sizeof(T_RTP_H261_BSINFO) + 
			                  sizeof(T_H26X_RTP_BSINFO_TRAILER) - fpSrc;
           

           fpu8MaxPtr = fpSrc;
		   fpu8MaxPtr += (pBsTrailer->uCompressedSize + 2 - 1); 

        }

		#ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMemcpySum)
		#endif
		
		/* Initialize the bit stream reader 
		 */
		GET_BITS_INIT(uWork, uBitsReady);

		// rearch
		//  Initialize pointers to data structures which carry info 
		//  between passes
		pRUN_INVERSE_Q = (T_IQ_INDEX *)(P32Inst + DC->X32_InverseQuant);
		pN             = (U32 *)(P32Inst + DC->X32_pN);
		fpMBInfo       = (T_MBInfo FAR *) (P32Inst + DC->X32_uMBInfoStream);
		// rearch

// #ifdef LOSS_RECOVERY
#if 1
		DC->iVerifiedBsExt = FALSE;
#endif

		/* Decode the Picture Header */
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
#ifdef CHECKSUM_PICTURE
		iReturn = H263DecodePictureHeader(DC, fpSrc, uBitsReady, uWork, fpbsState, &pReadYVUCksum, &uCheckSumValid);
#else
		iReturn = H263DecodePictureHeader(DC, fpSrc, uBitsReady, uWork, fpbsState);
#endif
		if (iReturn != ICERR_OK)
		{
			DBOUT("ERROR :: H263Decompress :: Error reading the picture header");
			goto done;
		}
		#ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
		#endif
	
		/* Set a limit for testing for bitstream over-run
		 */

		/* For each GOB do... */
		iNumberOfGOBs = iNumberOfGOBsBySourceFormat[DC->uSrcFormat];
		iNumberOfMBs = iNumberOfMBsInAGOBBySourceFormat[DC->uSrcFormat];

 		/* In H263 a GOB is a single row of MB, and a MB is 16x16 */
		/* In H261 a GOB is 33 MBs, and a MB is 16x16 */
		/* Order of GOBs depends on source format */

		if (DC->uSrcFormat == SRC_FORMAT_QCIF)
		{
			ASSERT(((U32)iNumberOfGOBs * 3 * 16) == DC->uFrameHeight);
			if (((U32)iNumberOfGOBs * 3 * 16) != DC->uFrameHeight)
			{
				DBOUT("ERROR :: H263Decompress :: Error matching picture header SRC field and actual frame height");
				iReturn = ICERR_ERROR;
				goto done;
			}
			ASSERT(((U32)iNumberOfMBs / 3 * 16) == DC->uFrameWidth); 
			if (((U32)iNumberOfMBs / 3 * 16) != DC->uFrameWidth)
			{
				DBOUT("ERROR :: H263Decompress :: Error matching picture header SRC field and actual frame width");
				iReturn = ICERR_ERROR;
				goto done;
			}
		}
		if (DC->uSrcFormat == SRC_FORMAT_CIF)
		{
			ASSERT(((U32)iNumberOfGOBs / 2 * 3 * 16) == DC->uFrameHeight);
			if (((U32)iNumberOfGOBs / 2 * 3 * 16) != DC->uFrameHeight)
			{
				DBOUT("ERROR :: H263Decompress :: Error matching picture header SRC field and actual frame height");
				iReturn = ICERR_ERROR;
				goto done;
			}
			ASSERT(((U32)iNumberOfMBs / 3 * 2 * 16) == DC->uFrameWidth); 
			if (((U32)iNumberOfMBs / 3 * 2 * 16) != DC->uFrameWidth)
			{
				DBOUT("ERROR :: H263Decompress :: Error matching picture header SRC field and actual frame width");
				iReturn = ICERR_ERROR;
				goto done;
			}
		}

		fpBlockAction = (T_BlkAction FAR *) (P32Inst + DC->X16_BlkActionStream);

		// rearch
		// H261, re initialize the block action stream for entire Frame
		// at end of H263Decompress.  High bit is set in BlockType to
		// indicate if need to do BEF so can't re-init between GOBs.
		// H261ReInitializeBlockActionStream(DC);
		/*****************************************************************
		  FIRST PASS - bitream parsing and IDCT prep work
		 ***************************************************************/
// #ifndef LOSS_RECOVERY
#if 0
		iReturn = IAPass1ProcessFrame(DC, 
                                          fpBlockAction, 
                                          fpMBInfo,
                                          fpbsState,
                                          fpu8MaxPtr,
                                          pN,
                                          pRUN_INVERSE_Q,
                                          iNumberOfGOBs,
                                          iNumberOfMBs,
                                          gob_start, 
                                          mb_start);
#else
       iReturn = IAPass1ProcessFrameRTP(DC, 
                                          fpBlockAction, 
                                          fpMBInfo,
                                          fpbsState,
                                          fpu8MaxPtr,
                                          pN,
                                          pRUN_INVERSE_Q,
                                          iNumberOfGOBs,
                                          iNumberOfMBs,
                                          gob_start, 
                                          mb_start);
#endif
		if (iReturn != ICERR_OK) {
			DBOUT("H261Decompress : Pass 1 error");
			goto done;
		}

		/*****************************************************************
		  SECOND PASS - IDCT and motion compensation (MC)
		 *****************************************************************/

		fpBlockAction  = (T_BlkAction FAR *)(P32Inst + DC->X16_BlkActionStream);
		pRUN_INVERSE_Q = (T_IQ_INDEX *)(P32Inst + DC->X32_InverseQuant);  
		pN             = (U32 *)(P32Inst + DC->X32_pN); 
		fpMBInfo       = (T_MBInfo FAR *)(P32Inst + DC->X32_uMBInfoStream);

		IAPass2ProcessFrame(DC,
                                fpBlockAction,
                                fpMBInfo,
                                pN,
                                pRUN_INVERSE_Q,
                                iNumberOfGOBs,
                                iNumberOfMBs);
	// rearch

		//Prepare which frame to display for inter frames
		DC->DispFrame.X32_YPlane = DC->CurrFrame.X32_YPlane;
		DC->DispFrame.X32_VPlane = DC->CurrFrame.X32_VPlane;
		DC->DispFrame.X32_UPlane = DC->CurrFrame.X32_UPlane;

        utemp                    = DC->CurrFrame.X32_YPlane;
        DC->CurrFrame.X32_YPlane = DC->PrevFrame.X32_YPlane;
        DC->PrevFrame.X32_YPlane = utemp;

        utemp                    = DC->CurrFrame.X32_VPlane ;
        DC->CurrFrame.X32_VPlane = DC->PrevFrame.X32_VPlane;
        DC->PrevFrame.X32_VPlane = utemp;

        utemp                    = DC->CurrFrame.X32_UPlane ;
        DC->CurrFrame.X32_UPlane = DC->PrevFrame.X32_UPlane;
        DC->PrevFrame.X32_UPlane = utemp;

		#ifdef CHECKSUM_PICTURE
			if (uCheckSumValid)
			{
		/* compute and compare picture checksum data */
				iReturn = H261ComputePictureCheckSum(P32Inst, &YVUChkSum);
				iReturn = H261ComparePictureCheckSum(&YVUChkSum, &pReadYVUCksum);
			}
		#endif
	} /* end if (DC->DecoderType == H263_CODEC) */
	else 
	{
		ASSERT(DC->DecoderType == YUV12_CODEC);
		DC->DispFrame.X32_YPlane = DC->CurrFrame.X32_YPlane;
		DC->DispFrame.X32_VPlane = DC->CurrFrame.X32_VPlane;
		DC->DispFrame.X32_UPlane = DC->CurrFrame.X32_UPlane;
	}

	/* Return if there is no need to update screen yet.
	 */
    if ((lpicDecEx->dwFlags & ICDECOMPRESS_HURRYUP)
	    || (lpicDecEx->dwFlags & ICDECOMPRESS_PREROLL))
    {
		DBOUT("H261Decompress : Display suppressed, HURRYUP or PREROLL");
        iReturn = ICERR_DONTDRAW;
		goto done;
    }

#if 0
	/* Fill the Y,U,V Current Frame space with a test pattern
	 */
	TestFill((HPBYTE)P32Inst + DC->CurrFrame.X32_YPlane + Y_START,
		     (HPBYTE)P32Inst + DC->CurrFrame.X32_UPlane + UV_START,
		     (HPBYTE)P32Inst + DC->CurrFrame.X32_VPlane + UV_START,	       
	   	 	 PITCH,
	         DC->uFrameWidth,
	         DC->uFrameHeight);
#endif

#if MAKE_GRAY
	/* Fill the U,V Current Frame space with a test pattern
	 */
	TestFillUV((HPBYTE)P32Inst + DC->CurrFrame.X32_UPlane + UV_START,
		       (HPBYTE)P32Inst + DC->CurrFrame.X32_VPlane + UV_START,	       
	   	 	   PITCH,
	           DC->uFrameWidth,
	           DC->uFrameHeight);
#endif

	/* Special case the YUV12 for the encoder because it should not include 
	 * BEF, Shaping or aspect ratio correction...
	 */
	if (DC->ColorConvertor == YUV12ForEnc) 
	{
	    H26x_YUV12ForEnc ((HPBYTE)P32Inst,
			             DC->PrevFrame.X32_YPlane + Y_START,
			             DC->PrevFrame.X32_VPlane + UV_START,
			             DC->PrevFrame.X32_UPlane + UV_START,
			             DC->uFrameWidth,
			             DC->uFrameHeight,
			             PITCH,
			             (HPBYTE)lpicDecEx->lpDst,
			             (DWORD)Y_START,
			             (DWORD)(MAX_HEIGHT + 2L*UMV_EXPAND_Y) * PITCH + 8 + UV_START + PITCH / 2,
			             (DWORD)(MAX_HEIGHT + 2L*UMV_EXPAND_Y) * PITCH + 8 + UV_START);
		iReturn = ICERR_OK;
		goto done;
	}

	/* Copy Planes to Post Processing area if mirror and/or block edge filter.
	 */
	if (DC->DecoderType == H263_CODEC)
	{
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif

		if(bMirror) { // copy with mirroring

			pFrame = (U8 *)DC->p16InstPostProcess;
			uYPlane = DC->PostFrame.X32_YPlane;
			uUPlane = DC->PostFrame.X32_UPlane;
			uVPlane = DC->PostFrame.X32_VPlane;

			FrameMirror(((HPBYTE) P32Inst) + DC->DispFrame.X32_YPlane + Y_START,
				((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
				DC->uFrameHeight,
				DC->uFrameWidth,
				PITCH);
			FrameMirror(((HPBYTE) P32Inst)+ DC->DispFrame.X32_UPlane + UV_START,
				((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_UPlane,
				DC->uFrameHeight/2,
				DC->uFrameWidth/2,
				PITCH);
			FrameMirror(((HPBYTE) P32Inst)+ DC->DispFrame.X32_VPlane + UV_START,
				((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_VPlane,
				DC->uFrameHeight/2,
				DC->uFrameWidth/2,
				PITCH);
		}
		else 
		{ /* no mirroring */

			if ((DC->bUseBlockEdgeFilter) || (DC->bAdjustLuma) ||
				(DC->bAdjustChroma)) 
			{
				/* copy for BEF */
				pFrame = (U8 *)DC->p16InstPostProcess;
				uYPlane = DC->PostFrame.X32_YPlane;
				uUPlane = DC->PostFrame.X32_UPlane;
				uVPlane = DC->PostFrame.X32_VPlane;

				FrameCopy (((HPBYTE) P32Inst) +DC->DispFrame.X32_YPlane+Y_START,
					((HPBYTE) DC->p16InstPostProcess) +DC->PostFrame.X32_YPlane,
						DC->uFrameHeight,
						DC->uFrameWidth,
						PITCH);
				FrameCopy (((HPBYTE) P32Inst)+DC->DispFrame.X32_UPlane+UV_START,
					((HPBYTE) DC->p16InstPostProcess) +DC->PostFrame.X32_UPlane,
						DC->uFrameHeight/2,
						DC->uFrameWidth/2,
						PITCH);
				FrameCopy (((HPBYTE) P32Inst)+DC->DispFrame.X32_VPlane+UV_START,
					((HPBYTE) DC->p16InstPostProcess) +DC->PostFrame.X32_VPlane,
						DC->uFrameHeight/2,
						DC->uFrameWidth/2,
						PITCH);
			} /* end if BEF on */
			else
			{
				/* no BEF or mirror so don't need copy */
				pFrame = (U8 *) DC;
				uYPlane = DC->DispFrame.X32_YPlane + Y_START;
				uUPlane = DC->DispFrame.X32_UPlane + UV_START;
				uVPlane = DC->DispFrame.X32_VPlane + UV_START;

			} /* end of else no BEF */

		} /* end else no mirroring */
		#ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopySum)
		#endif

		
		uYPitch  = PITCH;
		uUVPitch = PITCH;

		if (DC->bUseBlockEdgeFilter)
		{
			#ifdef DECODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif
				fpBlockAction=(T_BlkAction FAR *) (P32Inst+DC->X16_BlkActionStream);
				BlockEdgeFilter(((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
							DC->uFrameHeight,
							DC->uFrameWidth,
							PITCH,
							fpBlockAction);
			
			#ifdef DECODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uBEFSum)
			#endif
		}
	}
	else
	{  /* YUV12 */
		const U32 uHeight = DC->uFrameHeight;
		const U32 uWidth  = DC->uFrameWidth;
		const U32 uYPlaneSize = uHeight*uWidth;

		if(bMirror) // mirroring and YUV12 need to do copy
		{
			pFrame = (U8 *)DC->p16InstPostProcess;
			uYPlane = DC->PostFrame.X32_YPlane;
			uUPlane = uYPlane + uYPlaneSize;
			uVPlane = uUPlane + (uYPlaneSize>>2);

			pSource = (HPBYTE)lpicDecEx->lpSrc;
			pDestination = (HPBYTE)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane);
			FrameMirror (pSource, pDestination, uHeight, uWidth, uWidth);
	    	
			pSource += uYPlaneSize;
			pDestination += uYPlaneSize;
			FrameMirror (pSource, pDestination, (uHeight>>1), (uWidth>>1), (uWidth>>1));

			pSource += (uYPlaneSize>>2);
			pDestination += (uYPlaneSize>>2);
			FrameMirror (pSource, pDestination, (uHeight>>1), (uWidth>>1), (uWidth>>1));
		}
		else // no mirroring
		{
		    if ((DC->bAdjustLuma)||(DC->bAdjustChroma)) // copy when adjust pels
			{
				pFrame = (U8 *)DC->p16InstPostProcess;
				//uYPlane = 0;
				uYPlane = DC->PostFrame.X32_YPlane;
				uUPlane = uYPlane + uYPlaneSize;
				uVPlane = uUPlane + (uYPlaneSize>>2);

				pSource = (HPBYTE)lpicDecEx->lpSrc;
				pDestination = (HPBYTE)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane);
				FrameCopy (pSource, pDestination, uHeight, uWidth, uWidth);
	    	
				pSource += uYPlaneSize;
				pDestination += uYPlaneSize;
				FrameCopy (pSource, pDestination, (uHeight>>1), (uWidth>>1), (uWidth>>1));

				pSource += (uYPlaneSize>>2);
				pDestination += (uYPlaneSize>>2);
				FrameCopy (pSource, pDestination, (uHeight>>1), (uWidth>>1), (uWidth>>1));
			}
			else
			{
			/* Do not have to do memcpy because color convertors don't
			 * destroy input planes.
			 */
				pFrame = (HPBYTE)lpicDecEx->lpSrc;
				uYPlane = 0;
				uUPlane = uYPlane + uYPlaneSize;
				uVPlane = uUPlane + (uYPlaneSize>>2);

				//memcpy(((char FAR *)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane)),
				 //  (const char FAR *)lpicDecEx->lpSrc,
			      // lpicDecEx->lpbiSrc->biSizeImage);  
			}
	    } /* end else if no mirroring */
	       
	       uYPitch  = DC->uFrameWidth;
	       uUVPitch = DC->uFrameWidth >> 1;
	} /* end else YUV12 */

	if (DC->bForceOnAspectRatioCorrection || lpInst->bCorrectAspectRatio) {
		bShapingFlag = 1;
		u16NewFrameHeight = (U16) (DC->uFrameHeight * 11 / 12);
	} else {
		bShapingFlag = 0;
		u16NewFrameHeight = (U16) DC->uFrameHeight;
	}

	/* Do the PEL color adjustments if necessary.
	 */
    if(DC->bAdjustLuma) {
		/* width is rounded up to a multiple of 8
		 */
        AdjustPels(pFrame,
                   uYPlane,
                   DC->uFrameWidth,
                   uYPitch,
                   DC->uFrameHeight,
                   (U32) DC->X16_LumaAdjustment);
    }
    if(DC->bAdjustChroma) {
		/* width = Y-Width / 4 and then rounded up to a multiple of 8
		 */
        AdjustPels(pFrame,
                   uUPlane,
                   (DC->uFrameWidth >> 1),
                   uUVPitch,
                   (DC->uFrameHeight >> 1),
                   (U32) DC->X16_ChromaAdjustment);
        AdjustPels(pFrame,
                   uVPlane,
                   (DC->uFrameWidth >> 1),
                   uUVPitch,
                   (DC->uFrameHeight >> 1),
                   (U32) DC->X16_ChromaAdjustment);
    }

    /* Determine parameters (lOutput, intPitch, uNewOffsetToLine0)
     * needed for color conversion.
     */

    if (lpicDecEx->lpbiDst->biCompression == FOURCC_YUY2)
    {
        // We are assuming here a positive pitch for YUY2.
        // This typically corresponds to a negative value for
        // the destination bit map height.
        // If we're ever asked to use YUY2 with a positive bit map
        // height, we'll have to revisit these calculations.

        intPitch = (lpicDecEx->lpbiDst->biBitCount >> 3)
                    * abs ((int)(lpicDecEx->lpbiDst->biWidth));
        lOutput = 0;
        uNewOffsetToLine0 = 0;
#if 0
        // Aspect ratio correction is now supported for YUY2.
        // This is necessary to enable direct draw under Active Movie 1.0.
        bShapingFlag=FALSE;
#endif
		DBOUT("Using YUY2 ........");      
    }
    else if ((lpicDecEx->lpbiDst->biCompression == FOURCC_YUV12) || (lpicDecEx->lpbiDst->biCompression == FOURCC_IYUV))
    {
        intPitch = 0xdeadbeef;  // should not be used
        lOutput = 0;
        uNewOffsetToLine0 = DC->CCOffsetToLine0;
        bShapingFlag=FALSE;
		DBOUT("Using YUV ........");      
    }
    else if (lpicDecEx->lpbiDst->biCompression == FOURCC_IF09)
    {
        lOutput=0;
        intPitch = abs((int)(lpicDecEx->lpbiDst->biWidth));
        uNewOffsetToLine0 = DC->CCOffsetToLine0;
        DBOUT("USing IF09........");      
    }
    else
    {
        lOutput = DibXY(lpicDecEx, &intPitch, lpInst->YScale, bIsDCI);

        uNewOffsetToLine0 = DC->CCOffsetToLine0;

        if (!bIsDCI)
        {
            // DC->CCOffsetToLine0 was initialized without taking into
            // account the sign of the destination bitmap height.  Let's
            // compensate for that here.

            if (lpicDecEx->lpbiDst->biHeight < 0)
                uNewOffsetToLine0 = 0;

            // Adjust uNewOffsetToLine0 for aspect ratio correction.

            if (uNewOffsetToLine0 > 0)
            {
                ASSERT(intPitch < 0);

                if (lpInst->YScale == 2)
                {
                    uNewOffsetToLine0 += 2 * (U32)intPitch *
                        ((U32)DC->uFrameHeight - (U32)u16NewFrameHeight);
                }
                else
                {
                    uNewOffsetToLine0 += (U32)intPitch *
                        ((U32)DC->uFrameHeight - (U32)u16NewFrameHeight);
                }
            }
        }
    }

	/* Call the color convertors 
	 */

/////////////////////////////////////////////////////////////////////////////
//	Check to see if we need to copy a Snapshot into the output buffer.
//	I added new fields to the Decoder Catalog to permit asynchronous 
//	transfer of data.  These fields are:
//		DC->SnapshotRequest
//		DC->SnapshotBuffer
//		DC->SnapshotEvent
//	Ben - 09/25/96
/////////////////////////////////////////////////////////////////////////////
	if(DC->SnapshotRequest == SNAPSHOT_REQUESTED)
	{
		UINT uiSZ_Snapshot;

        DBOUT("D1DEC:DECOMPRESS::Snapshot requested");      
		uiSZ_Snapshot = (DC->uFrameWidth * DC->uFrameHeight * 12) >> 3;

		if(!(IsBadWritePtr(DC->SnapshotBuffer, uiSZ_Snapshot)))
		{
			DC->SnapshotRequest = SNAPSHOT_COPY_STARTED;
	        DBOUT("D1DEC:DECOMPRESS::Snapshot copy started");      

			ColorConvertorCatalog[YUV12NOPITCH].ColorConvertor[0]
			(
				(LPSTR) pFrame + uYPlane,
				(LPSTR) pFrame + uVPlane,
				(LPSTR) pFrame + uUPlane,
				(UN) DC->uFrameWidth,
				(UN) DC->uFrameHeight,
				(UN) uYPitch,
				(UN) uUVPitch,
				(UN) (bShapingFlag ? 12 : 9999),
				(LPSTR) DC->SnapshotBuffer,
				0,
				0,
				(int) DC->uFrameWidth,
				YUV12NOPITCH
			);
			DC->SnapshotRequest = SNAPSHOT_COPY_FINISHED;
	        DBOUT("D1DEC:DECOMPRESS::Snapshot copy finished");      
		}
		else
		{
			DC->SnapshotRequest = SNAPSHOT_COPY_REJECTED;
	        DBOUT("D1DEC:DECOMPRESS::Snapshot copy rejected");      
		}
		SetEvent(DC->SnapshotEvent);
	}

#ifndef RING0
#ifdef _DEBUG
	{
	char msg[180];
	wsprintf(msg, "Decompress before CC: (%d,%d,%d,%d) (%d,%d,%d,%d) lOut %ld, NewOff %ld, DC->Off %ld, pitch %ld",
        lpicDecEx->xSrc, lpicDecEx->ySrc, lpicDecEx->dxSrc, lpicDecEx->dySrc,
        lpicDecEx->xDst, lpicDecEx->yDst, lpicDecEx->dxDst, lpicDecEx->dyDst,
        lOutput, uNewOffsetToLine0, DC->CCOffsetToLine0, intPitch);
	DBOUT(msg);
	}
#endif
#endif

	#ifdef DECODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
    ColorConvertorCatalog[DC->ColorConvertor].ColorConvertor[PENTIUM_CC](
        (LPSTR) pFrame + uYPlane,
        (LPSTR) pFrame + uVPlane,
        (LPSTR) pFrame + uUPlane,
        (UN) DC->uFrameWidth,
        (UN) DC->uFrameHeight,
        (UN) uYPitch,
        (UN) uUVPitch,                  // ??? BSE ??? //
        (UN) (bShapingFlag ? 12 : 9999),  // ??? BSE ??? //
        (LPSTR) lpicDecEx->lpDst,
        (U32) lOutput,
        (U32) uNewOffsetToLine0,
        (int) intPitch,								  // Color converter pitch
        DC->ColorConvertor);
	#ifdef DECODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uOutputCCSum);
	#endif

	iReturn = ICERR_OK;

done:
    if (DC != NULL)
	{
		if (DC->DecoderType == H263_CODEC)
		{
			#ifdef DECODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif
				H261ReInitializeBlockActionStream(DC);
			#ifdef DECODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uInitBlkActStrSum)
			#endif
		} /* end if (DC->DecoderType == H263_CODEC) */

		#ifdef DECODE_STATS

			TIMER_STOP(bTimingThisFrame,uStartLow,uStartHigh,uDecodeFrameSum);
			if (bTimingThisFrame)
			{
				pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount;
				pDecTimingInfo->uDecodeFrame = uDecodeFrameSum;
				pDecTimingInfo->uHeaders += uHeadersSum;
				pDecTimingInfo->uMemcpy = uMemcpySum;
				pDecTimingInfo->uFrameCopy = uFrameCopySum;
				pDecTimingInfo->uOutputCC = uOutputCCSum;
				pDecTimingInfo->uInitBlkActStr = uInitBlkActStrSum;
				pDecTimingInfo->uBEF = uBEFSum;
				DC->uStatFrameCount++;
				/* Verify that we have time for all the required steps 
				 */
				ASSERT(pDecTimingInfo->uDecodeFrame);
				ASSERT(pDecTimingInfo->uHeaders);
				ASSERT(pDecTimingInfo->uMemcpy);
				ASSERT(pDecTimingInfo->uFrameCopy);
				ASSERT(pDecTimingInfo->uOutputCC);
				/* ASSERT(pDecTimingInfo->uDecodeBlock); 0 if all are empty */
				ASSERT(pDecTimingInfo->uInitBlkActStr);
				ASSERT(pDecTimingInfo->uBEF);
			}
		#endif
	}

	return iReturn;
}

//************************************************************************
//
//H263TermDecoderInstance -- This function frees the space allocated for an
//                           instance of the H263 decoder.
//
//************************************************************************

LRESULT H263TermDecoderInstance(LPDECINST lpInst)
{
  LRESULT iReturn = ICERR_OK;
  T_H263DecoderCatalog * DC;

  if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
  {
    DBOUT("ERROR :: H263TermDecoderInstance :: ICERR_BADPARAM");
    iReturn = ICERR_BADPARAM;
  }
  if(lpInst->Initialized == FALSE)
  {
    DBOUT("Warning: H263TermDecoderInstance(): Uninitialized instance")
    return(ICERR_OK);
  }

  lpInst->Initialized = FALSE;

  DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

  CloseHandle(DC->SnapshotEvent);

  if (DC->a16InstPostProcess != NULL)
  {
	HeapFree(GetProcessHeap(), 0, DC->a16InstPostProcess);
	// PhilF: Also freed in H263TerminateDecoderInstance! For now set to NULL to avoid second HeapFree.
	// Investigate reason for 2nd call later...
	DC->a16InstPostProcess = NULL;
  }

  HeapFree(GetProcessHeap(), 0, lpInst->pDecoderInst);

  return iReturn;
}


//****************************************************************************
//DibXY -- This function is used to map color converted output to the screen.
//note: this function came from the H261 code base.
//****************************************************************************

static long DibXY(ICDECOMPRESSEX FAR *lpicDecEx, LPINT lpiPitch, UINT yScale, BOOL bIsDCI)
{
    int                 iPitch;             /* width of DIB                */
    long                lOffset = 0;
    LPBITMAPINFOHEADER  lpbi = lpicDecEx->lpbiDst;

    iPitch = (((abs((int)lpbi->biWidth) * (int)lpbi->biBitCount) >> 3) + 3) & ~3;

    // The source and destination rectangles in lpicDecEx are only
    // meaningful if bIsDCI is true (because throughout our codec, if bIsDCI
    // is FALSE, we put zeroes in these rectangles).  This may change, at
    // some later point, if we decide (or are required) to make use of the
    // rcSource and rcTarget rectangles that are associated with an Active
    // Movie media sample.

    if (!bIsDCI)
    {
        if (lpbi->biHeight >= 0)
        {
    	    // Typically for RGB, a positive bitmap height corresponds
    	    // to a negative pitch.
    	    iPitch = -iPitch;
        }
    }
    else
    {
        if(lpicDecEx->xDst > 0)             /* go to proper X position     */
            lOffset += ((long)lpicDecEx->xDst * (long)lpbi->biBitCount) >> 3;

        if(lpbi->biHeight * lpicDecEx->dxSrc < 0)
        { /* DIB is bottom to top    */
            lOffset += (long) abs((int)lpbi->biWidth) *
                       (long) abs((int)lpbi->biHeight) *
                       ((long) lpbi->biBitCount >> 3) -
                       (long) iPitch;

/***************************************************************************/
/***** This next line is used to subtract the amount that Brian added  *****/
/***** to CCOffsetToLine0 in COLOR.C during initialization.  This is   *****/
/***** needed because for DCI, the pitch he used is incorrect.         *****/
/***************************************************************************/

            lOffset -= ((long) yScale * (long)lpicDecEx->dySrc - 1) *
                       (long) lpicDecEx->dxDst * ((long) lpbi->biBitCount >> 3);

            iPitch = -iPitch;
        }

        if(lpicDecEx->yDst > 0)             /* go to proper Y position     */
            lOffset += ((long)lpicDecEx->yDst * (long)iPitch);

        if(lpicDecEx->dxSrc > 0) {
            lOffset += ((long)lpicDecEx->dyDst * (long)iPitch) - (long)iPitch;
            iPitch = -iPitch;
        }

        if((lpicDecEx->dxDst == 0) && (lpicDecEx->dyDst == 0))
            iPitch = -iPitch;
    }

    *lpiPitch = iPitch;

    return(lOffset);
}


/************************************************************************
 *
 *  GetDecoderOptions
 *
 *  Get the options, saving them in the catalog
 */
static void GetDecoderOptions(
	T_H263DecoderCatalog * DC)
{
	int bSetOptions = 1;

	/* Default Options
	 */
	const int bDefaultForceOnAspectRatioCorrection = 0;
	const int bDefaultUseBlockEdgeFilter = 1;
	
	/* INI file variables
	 */
	#ifndef RING0
	UN unResult;
	#define SECTION_NAME	"Decode"
	#define INI_FILE_NAME	"h261test.ini"
	#ifdef _DEBUG
	char buf132[132];
	#endif
	#endif

	/* Read the options from the INI file
	 */
	#ifndef RING0
	{
		DBOUT("Getting decode options from the ini file h261test.ini");
	
		/* BlockEdgeFilter 
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "BlockEdgeFilter", bDefaultUseBlockEdgeFilter, INI_FILE_NAME);
		if (unResult != 0  && unResult != 1)
		{
			#ifdef _DEBUG
			wsprintf(buf132,"BlockEdgeFilter ini value error (should be 0 or 1) - using default=%d", 
				     (int) bDefaultUseBlockEdgeFilter);
			DBOUT(buf132);
			#endif
			
			unResult = bDefaultUseBlockEdgeFilter;
		}
		DC->bUseBlockEdgeFilter = unResult;

		/* Force on aspect ratio correction.
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "ForceOnAspectRatioCorrection", bDefaultForceOnAspectRatioCorrection, INI_FILE_NAME);
		if (unResult != 0  && unResult != 1)
		{
			#ifdef _DEBUG
			wsprintf(buf132,"ForceOnAspectRatioCorrection ini value error (should be 0 or 1) - using default=%d",
				  (int) bDefaultForceOnAspectRatioCorrection);
			DBOUT(buf132);
			#endif
			
			unResult = bDefaultForceOnAspectRatioCorrection;
		}
		DC->bForceOnAspectRatioCorrection = unResult;


		bSetOptions = 0;
	}
	#endif
	
	if (bSetOptions)
	{
		DC->bUseBlockEdgeFilter = bDefaultUseBlockEdgeFilter;
		DC->bForceOnAspectRatioCorrection = bDefaultForceOnAspectRatioCorrection;
	} 

	/* Can only use force aspect ratio correction on if SQCIF, QCIF, or CIF
	 */
	if (DC->bForceOnAspectRatioCorrection)
	{
		if (! ( ((DC->uFrameWidth == 128) && (DC->uFrameHeight ==  96)) ||
		        ((DC->uFrameWidth == 176) && (DC->uFrameHeight == 144)) ||
		        ((DC->uFrameWidth == 352) && (DC->uFrameHeight == 288)) ) )
		{
			DBOUT("Aspect ratio correction can not be forced on unless the dimensions are SQCIF, QCIF, or CIF");
			DC->bForceOnAspectRatioCorrection = 0;
		}
	}

	/* Display the options
	 */
	if (DC->bUseBlockEdgeFilter)
	{
		DBOUT("Decoder option (BlockEdgeFilter) is ON");
	}
	else
	{
		DBOUT("Decoder option (BlockEdgeFilter) is OFF");
	}
	if (DC->bForceOnAspectRatioCorrection)
	{
		DBOUT("Decoder option (ForceOnAspectRatioCorrection) is ON");
	}
	else
	{
		DBOUT("Decoder option (ForceOnAspectRatioCorrection) is OFF");
	}
	DBOUT("Decoder option (MMX) is OFF: get a life, get MMX");
} /* end GetDecoderOptions() */



/***********************************************************************
 *  Description:
 *    This routine parses the bit-stream and initializes two major streams:
 *      1) pN: no of coefficients in each of the block (biased by 65 for INTRA)
 *      2) pRun_INVERSE_Q: de-quantized coefficient stream for the frame;
 *           MMX stream is scaled because we use scaled IDCT.
 *    Other information (e.g. MVs) is kept in decoder catalog, block action 
 *    stream, and MB infor stream.
 *  Parameters:
 *    DC:            Decoder catalog ptr
 *    fpBlockAction: block action stream ptr
 *    fpMBInfo:      Macroblock info ptr
 *    fpbsState:     bit-stream state pointer
 *    fpu8MaxPtr:    sentinel value to check for bit-stream overruns
 *    pN:            stream of no. of coeffs (biased by block type) for each block
 *    pRun_INVERSE_Q:stream of de-quantized (and scaled if using MMX) coefficients
 *    iNumberOfGOBs: no. of GOBs in the frame
 *    iNumberOfMBs:  no. of MBs in a GOB in the frame
 *    iGOB_start:    
 *    iMB_start:     
 *  Note:
 ***********************************************************************/

#pragma code_seg("IACODE1")

// #ifndef LOSS_RECOVERY
#if 0
static LRESULT IAPass1ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start
)
{
    I32 g, iReturn, iBlockNumber = 0 ;
    I32 mb_start = iMB_start;
    U32 *pNnew;
	U32 uReadChecksum = 0;
	I8 i;
	I8 tmpcnt;

	#ifdef DECODE_STATS
	U32 uStartLow = DC->uStartLow;
	U32 uStartHigh = DC->uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uHeadersSum = 0;
	int bTimingThisFrame = DC->bTimingThisFrame;
	DEC_TIMING_INFO *pDecTimingInfo = NULL;
	#endif

	#ifdef DECODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
	/* move decode of GOB start code outside of GOB header processing      */
	/* because if processing skipped macroblocks, looking for the last MBA */
	/* will find the next start code                                       */
	iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	if (iReturn != ICERR_OK)
	{
		DBOUT("ERROR :: H263Decompress :: Error reading the GOB StartCode");
		goto done;
	}
	#ifdef DECODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
	#endif
		
	for (g = 1 ; g <= iNumberOfGOBs; g++)
	{
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
		iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
		if (iReturn != ICERR_OK)
		{
			DBOUT("ERROR :: H263Decompress :: Error reading the GOB header");
			goto done;
		}
		#ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
		#endif

		DC->i16LastMBA = -1;
		DC->i8MVDH = DC->i8MVDV = 0;
		
        //  re-sync iBlockNumber, fpBlockAction, fpMBInfo at this point
        
		iBlockNumber  = (g - 1) * iNumberOfMBs*6;
        fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
        fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
        fpBlockAction += iBlockNumber;
        fpMBInfo      += iBlockNumber/6;
        pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
        while (pN < pNnew ) *pN++ = 0;
        
        /* For each MB until START_CODE detected do ...
         */
        for (; ; iBlockNumber += 6, fpBlockAction += 6, fpMBInfo++) 
        {
            #ifdef DECODE_STATS
                TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
            #endif
            iReturn = H263DecodeMBHeader(DC, fpbsState, &uReadChecksum);
            #ifdef DECODE_STATS
			    TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
            #endif

			if (iReturn == START_CODE)
					break;

            /* If we didn't see a start code, then we either got an error,
             * or we have another MBA delta in DC->uMBA.
             */
            if (iReturn != ICERR_OK) {
                DBOUT("ERROR :: H263Decompress (First Pass) :: Error reading MB header");
                goto error;
            }
			/* Update MBA */
			DC->i16LastMBA += (I16)DC->uMBA;
			if (DC->i16LastMBA > 32)
			{
				DBOUT("ERROR :: H263Decompress :: Bad Macro Block Address");
				goto done;
			}

			/* New for rearch */
			/* adjust for empty macroblocks */

			for ( tmpcnt = (I8)DC->uMBA; tmpcnt > 1; tmpcnt--) 
			{
				for (i=0; i<6; i++)
				{
					*pN = 0;
					pN++;
				}
				iBlockNumber  += 6;
				fpBlockAction += 6;
				/* Default fpBlockAction values were already initialized
				 * in (Re)InitializeBlockActionStream.
				 */
				fpMBInfo->i8MBType = 2;
				fpMBInfo++;
			}
			fpMBInfo->i8MBType = (I8)DC->uMBType; // New rearch
			/* end of new rearch */

            // decode and inverse quantize the transform coefficients
			iReturn = H263DecodeMBData(DC, 
                                       fpBlockAction, 
                                       iBlockNumber, 
                                       fpbsState, 
                                       fpu8MaxPtr, 
                                       &uReadChecksum,
                                       &pN,
                                       &pRUN_INVERSE_Q);
            if (iReturn != ICERR_OK) {
                DBOUT("ERROR :: H263Decompress (First Pass) :: Error parsing MB data");
                goto error;
            }
        } // end for each MB

		/* Fill in arrays and advance Block Action stream when there
           are skip MB at the end of each GOB
        */
		while (iBlockNumber != (I32)g*198) {
			for (i=0; i<6; i++)
			{
				*pN = 0;
				pN++;
			}
			iBlockNumber += 6;
			fpBlockAction+= 6;
			/* Default fpBlockAction values were already initialized
			 * in (Re)InitializeBlockActionStream.
			 */
			fpMBInfo->i8MBType = 2;
			fpMBInfo++;
		}

        /* allow the pointer to address up to four beyond the end - reading
         * by DWORD using postincrement.
         */
        // ASSERT(fpbsState->fpu8 <= fpu8MaxPtr+4);

		if (fpbsState->fpu8 > fpu8MaxPtr+4)
            goto error;

    } // End for each GOB

    #ifdef DECODE_STATS
    if (bTimingThisFrame)
    {
        pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount; 
        pDecTimingInfo->uHeaders += uHeadersSum;
    }
    #endif

done:
    return ICERR_OK;

error:
    return ICERR_ERROR;
}
#else
static LRESULT IAPass1ProcessFrameRTP(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start
)
{
    BITSTREAM_STATE fpbsStateSave;
    I32 g, current_g, iReturn, iBlockNumber = 0 ;
    I32 mb_start = iMB_start;
    U32 *pNnew;
	U32 uReadChecksum = 0;
	I8 i;
	I8 tmpcnt;
	I32 g_skip, gtmp;
    I32 uMaxGOBNumber, uGOBStep, uMaxBlockNumber;

	#ifdef DECODE_STATS
	U32 uStartLow = DC->uStartLow;
	U32 uStartHigh = DC->uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uHeadersSum = 0;
	int bTimingThisFrame = DC->bTimingThisFrame;
	DEC_TIMING_INFO *pDecTimingInfo = NULL;
	#endif

	#ifdef DECODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
	/* move decode of GOB start code outside of GOB header processing      */
	/* because if processing skipped macroblocks, looking for the last MBA */
	/* will find the next start code                                       */
	iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	if (iReturn != ICERR_OK)
	{
		DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		goto done;
	}
	#ifdef DECODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
	#endif
	
    if (iNumberOfGOBs == 3)
    {
        uMaxGOBNumber = 5;
        uGOBStep = 2;
    }
    else
    {
        uMaxGOBNumber = 12;
        uGOBStep = 1;
    }
	for (g = 1; g <= uMaxGOBNumber; g+=uGOBStep)
	{
        current_g = g;
         
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
		iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        
//        #ifndef LOSS_RECOVERY 
        #if 0
		if (iReturn != ICERR_OK)
		{
			DBOUT("ERROR :: H261Decompress :: Error reading the GOB header");
			goto done;
		}
        #else
        
        if (iReturn == PACKET_FAULT_AT_MB_OR_GOB)
        {
            DBOUT("Packet fault at MBA or GBSC detected.");

            current_g -= uGOBStep;  // back up to previous GOB
            
            iReturn = RtpH261FindNextPacket(DC, fpbsState, &pN, 
                      (U32 *)&(DC->uPQuant), (int *)&mb_start, (int *) &g
                      );
            
            switch (iReturn)
            {
                case NEXT_MODE_STARTS_GOB:
                     // Next packet is the start of a GOB; mark missing
                     // macroblocks as skipped, then read GOB start code,
                     // and continue in the GOB loop.
         
                     // Save bitstream state

					 DBOUT("Next packet is NEXT_MODE_STARTS_GOB");

                     fpbsStateSave.fpu8 = fpbsState->fpu8;
                     fpbsStateSave.uWork = fpbsState->uWork;
                     fpbsStateSave.uBitsReady = fpbsState->uBitsReady;

                     // Read GOB start code
                     iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	                 if (iReturn != ICERR_OK)
	                 {
		                 DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		                 goto done;
	                 }

                     // Read GOB Header
                     iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        
                	 if (iReturn != ICERR_OK)
		             {
			             DBOUT("ERROR :: H261Decompress :: Error reading the GOB header");
			             goto done;
		             }

                     g = DC->uGroupNumber;

                     //  Restore bitstream state
                     
                     fpbsState->fpu8 = fpbsStateSave.fpu8;
                     fpbsState->uWork = fpbsStateSave.uWork;
                     fpbsState->uBitsReady = fpbsStateSave.uBitsReady;

                     //  re-sync iBlockNumber, fpBlockAction, fpMBInfo at this point
         

                     if (DC->uSrcFormat == SRC_FORMAT_QCIF)
                         g_skip = (g - 1) >> 1;
                     else
                         g_skip = g - 1 ;

                     
                     iBlockNumber  = g_skip * iNumberOfMBs * 6;
                     fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
                     fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
                     fpBlockAction += iBlockNumber;
                     fpMBInfo      += iBlockNumber/6;
                     pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;

                     // Now read the GOB start code and get ready to
                     // process the new GOB.

                     iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	                 if (iReturn != ICERR_OK)
	                 {
		                 DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		                 goto done;
	                 }
                     g -= uGOBStep;
                     continue;
                     break;
                
                case NEXT_MODE_STARTS_MB :

                     // Next packet starts with a macroblock; check the
                     // GOB Number and mark all lost macroblocks as 
                     // skipped; initialize MBA and motion vector 
                     // predictors from the block action stream and
                     // jump to the macroblock loop

					 DBOUT("Next packet is NEXT_MODE_STARTS_MB"); 

                     if (DC->uSrcFormat == SRC_FORMAT_QCIF)
                         g_skip = (g - 1) >> 1;
                     else
                         g_skip = g - 1;

                     iBlockNumber = iNumberOfMBs * g_skip * 6 +
                                    (mb_start+1) * 6;
                     fpBlockAction  = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
                     fpMBInfo       = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
                     fpBlockAction += iBlockNumber;
                     fpMBInfo      += iBlockNumber/6;
                     
                     DC->uMQuant = DC->uPQuant;
                     //DC->i16LastMBA = (U16) (mb_start - 1);
                       DC->i16LastMBA = (U16) (mb_start);


                     pNnew = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;
                     goto MB_LOOP;
                     break;

                case NEXT_MODE_LAST: // all remaining packets in frame lost !!

					 DBOUT("Next packet is NEXT_MODE_LAST");

                     uMaxBlockNumber = iNumberOfMBs * iNumberOfGOBs * 6;
                     pNnew = (U32 *)((U8 *)DC + DC->X32_pN) + uMaxBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;
                     iReturn = ICERR_OK;
                     goto done;
                     break;
                
                default: // should never happen !!
                     iReturn = ICERR_ERROR;
                     goto done;
           } // end switch

        }
        else
        {
        if (iReturn == PACKET_FAULT_AT_PSC)   // can only happen for the PSC packet
        {
			DBOUT("PSC packet fault detected");

            iReturn = RtpGetPicHeaderFromBsExt(DC);
            if (iReturn != ICERR_OK)
            {
               DBOUT("ERROR:: cannot read Picture Header from RTP Trailer");
               goto done;
            }


            iReturn = RtpH261FindNextPacket(DC, fpbsState, &pN, 
                      (U32 *)&(DC->uPQuant), (int *)&mb_start, (int *) &g);
            
            switch (iReturn)
            {
                case NEXT_MODE_STARTS_GOB:
                     // Next packet is the start of a GOB; mark missing
                     // macroblocks as skipped, then read GOB start code,
                     // and continue in the GOB loop.

                     //  re-sync iBlockNumber, fpBlockAction, fpMBInfo at this point
                     
                     // Save bitstream state

					 DBOUT("Next packet is NEXT_MODE_STARTS_GOB");

                     fpbsStateSave.fpu8 = fpbsState->fpu8;
                     fpbsStateSave.uWork = fpbsState->uWork;
                     fpbsStateSave.uBitsReady = fpbsState->uBitsReady;

                     // Read GOB start code
                     iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	                 if (iReturn != ICERR_OK)
	                 {
		                 DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		                 goto done;
	                 }

                     // Read GOB Header
                     iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        
                	 if (iReturn != ICERR_OK)
		             {
			             DBOUT("ERROR :: H261Decompress :: Error reading the GOB header");
			             goto done;
		             }

                     g = DC->uGroupNumber;

                     //  Restore bitstream state
                     
                     fpbsState->fpu8 = fpbsStateSave.fpu8;
                     fpbsState->uWork = fpbsStateSave.uWork;
                     fpbsState->uBitsReady = fpbsStateSave.uBitsReady;

                     if (DC->uSrcFormat == SRC_FORMAT_QCIF)
                         g_skip = (g - 1) >> 1;
                     else
                         g_skip = g - 1;

                     iBlockNumber  = g_skip * iNumberOfMBs * 6;
                     fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
                     fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
                     fpBlockAction += iBlockNumber;
                     fpMBInfo      += iBlockNumber/6;
                     pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;

                     // Now read the GOB start code and get ready to
                     // process the new GOB.

                     iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	                 if (iReturn != ICERR_OK)
	                 {
		                 DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		                 goto done;
	                 }
                     g -= uGOBStep;
                     continue;
                     break;
                
                case NEXT_MODE_STARTS_MB :

                     // Next packet starts with a macroblock; check the
                     // GOB Number and mark all lost macroblocks as 
                     // skipped; initialize MBA and motion vector 
                     // predictors from the block action stream and
                     // jump to the macroblock loop

					 DBOUT("Next packet is NEXT_MODE_STARTS_MB");

                     if (DC->uSrcFormat == SRC_FORMAT_QCIF)
                         g_skip = (g - 1) >> 1;
                     else
                         g_skip = g - 1;

                     iBlockNumber = iNumberOfMBs * g_skip * 6 +
                                    (mb_start+1) * 6;
                     fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
                     fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
                     fpBlockAction += iBlockNumber;
                     fpMBInfo      += iBlockNumber/6;

                     DC->uMQuant = DC->uPQuant;
                     //DC->i16LastMBA = (U16) (mb_start - 1);
                     DC->i16LastMBA = (U16) (mb_start);
                     pNnew = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
                     
                     while (pN < pNnew ) 
                            *pN++ = 0;
                     goto MB_LOOP;
                     
                     break;

                case NEXT_MODE_LAST: // all remaining packets in frame lost !!

					 DBOUT("Next packet is NEXT_MODE_LAST");

                     uMaxBlockNumber = iNumberOfMBs * iNumberOfGOBs * 6;
                     pNnew = (U32 *)((U8 *)DC + DC->X32_pN) + uMaxBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;
                     iReturn = ICERR_OK;
                     goto done;
                     break;
                
                default: // should never happen !!
                     iReturn = ICERR_ERROR;
                     goto done;
           } // end switch
        } // if .. PACKET_FAULT_AT_PSC
        else
        {
            if (iReturn == ICERR_ERROR)
            {
            DBOUT("ERROR :: H261Decompress :: Error reading GOB header");
            DBOUT("                           Packet fault not detected");
            goto done;
            }
            
            // Outdated: Do the source format check here when it is known that
            // the PSC was not the canned one from the PPM.

            /* if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat)
	        {
                DBOUT("ERROR::src format changed detected with no packet loss");
                DBOUT("       not supported ... bailing out");
		        iReturn=ICERR_ERROR;
		        goto done;
	        }  
            DC->uPrevSrcFormat = DC->uSrcFormat;
			DC->bReadSrcFormat = TRUE; */
        }
       }
       #endif
	   #ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
	   #endif

		DC->i16LastMBA = -1;
		DC->i8MVDH = DC->i8MVDV = 0;
		
        //  re-sync iBlockNumber, fpBlockAction, fpMBInfo at this point
		if (DC->uSrcFormat == SRC_FORMAT_QCIF)
		   iBlockNumber  = ((g - 1)>>1) * iNumberOfMBs*6;
		else
           iBlockNumber  = (g - 1)* iNumberOfMBs*6;
   
		fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
        fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
        fpBlockAction += iBlockNumber;
        fpMBInfo      += iBlockNumber/6;
        pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
        while (pN < pNnew ) *pN++ = 0;
        
        /* For each MB until START_CODE detected do ...
         */
MB_LOOP:
        
        for (; ; iBlockNumber += 6, fpBlockAction += 6, fpMBInfo++) 
        {
            #ifdef DECODE_STATS
                TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
            #endif
            iReturn = H263DecodeMBHeader(DC, fpbsState, &uReadChecksum);
            #ifdef DECODE_STATS
                TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
            #endif

			if (iReturn == START_CODE)
					break;

            /* If we didn't see a start code, then we either got an error,
             * or we have another MBA delta in DC->uMBA.
             */
            if (iReturn != ICERR_OK) {
                DBOUT("ERROR :: H263Decompress (First Pass) :: Error reading MB header");
                goto error;
            }
			/* Update MBA */
			DC->i16LastMBA += (I16)DC->uMBA;
			if (DC->i16LastMBA > 32)
			{
				DBOUT("ERROR :: H263Decompress :: Bad Macro Block Address");
				goto done;
			}

			/* New for rearch */
			/* adjust for empty macroblocks */

			for ( tmpcnt = (I8)DC->uMBA; tmpcnt > 1; tmpcnt--) 
			{
				for (i=0; i<6; i++)
				{
					*pN = 0;
					pN++;
				}
				iBlockNumber  += 6;
				fpBlockAction += 6;
			    /* Default fpBlockAction values were already initialized
			     * in (Re)InitializeBlockActionStream.
			     */
				fpMBInfo->i8MBType = 2;
				fpMBInfo++;
			}
			fpMBInfo->i8MBType = (I8)DC->uMBType; // New rearch
			/* end of new rearch */

            // decode and inverse quantize the transform coefficients
			iReturn = H263DecodeMBData(DC, 
                                       fpBlockAction, 
                                       iBlockNumber, 
                                       fpbsState, 
                                       fpu8MaxPtr, 
                                       &uReadChecksum,
                                       &pN,
                                       &pRUN_INVERSE_Q);
            if (iReturn != ICERR_OK) {
                DBOUT("ERROR :: H263Decompress (First Pass) :: Error parsing MB data");
                goto error;
            }
        } // end for each MB

		/* Fill in arrays and advance Block Action stream when there
           are skip MB at the end of each GOB
        */
        if (DC->uSrcFormat == SRC_FORMAT_QCIF)
        {
            switch (g)
            {
               case 1:
                    gtmp = 1;
                    break;
               case 3:
                    gtmp = 2;
                    break;
               case 5:
                    gtmp = 3;
                    break;
               default:
                    DBOUT("Bad GOB Number");
                    iReturn = ICERR_ERROR;
                    goto error;
                    break;
            }
        }
        else
            gtmp = g;
		while (iBlockNumber != (I32)gtmp*198) {
			for (i=0; i<6; i++)
			{
				*pN = 0;
				pN++;
			}
			iBlockNumber += 6;
			fpBlockAction+= 6;
			/* Default fpBlockAction values were already initialized
			 * in (Re)InitializeBlockActionStream.
			 */
			fpMBInfo->i8MBType = 2;
			fpMBInfo++;
		}

        /* allow the pointer to address up to four beyond the end - reading
         * by DWORD using postincrement.
         */
        ASSERT(fpbsState->fpu8 <= fpu8MaxPtr+4);

    } // End for each GOB

    #ifdef DECODE_STATS
    if (bTimingThisFrame)
    {
        pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount; 
        pDecTimingInfo->uHeaders += uHeadersSum;
    }
    #endif

done:
    return ICERR_OK;

error:
    return ICERR_ERROR;
}
#endif
#pragma code_seg()


/***********************************************************************
 *  Description:
 *    This routines does IDCT and motion compensation.
 *  Parameters:
 *    DC:            Decoder catalog ptr
 *    fpBlockAction: block action stream ptr
 *    fpMBInfo:      Macroblock info ptr
 *    pN:            stream of no. of coeffs (biased by block type) for each block
 *    pRun_INVERSE_Q:stream of de-quantized (and scaled if using MMX) coefficients
 *    iNumberOfGOBs: no. of GOBs in the frame
 *    iNumberOfMBs:  no. of MBs in a GOB in the frame
 *  Note:
 ***********************************************************************/
#pragma code_seg("IACODE2")
static void IAPass2ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs
)
{
    I32 g, m, b, iEdgeFlag=0;

    // for each GOB do
    for (g = 1 ; g <= iNumberOfGOBs; g++) 
    {
        // for each MB do
        for (m = 1; m <= iNumberOfMBs; m++, fpBlockAction+=6, fpMBInfo++) 
        {
            // for each block do
            for (b = 0; b < 6; b++) {     // AP-NEW
                // do inverse transform & motion compensation for the block
                H263IDCTandMC(DC, fpBlockAction, b, m, g, pN, pRUN_INVERSE_Q, 
                              fpMBInfo, iEdgeFlag); // AP-NEW
                // Adjust pointers for next block     
                if ( *pN >= 65 )
                    pRUN_INVERSE_Q += *pN - 65;
                else
                    pRUN_INVERSE_Q += *pN;
                pN++;
            }  // end for each block
            
        }  // end for each MB
    }  // End for each GOB
}
#pragma code_seg()

// rearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1dec.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;////////////////////////////////////////////////////////////////////////////
;//
;// $Author:   SCDAY  $
;// $Date:   31 Oct 1996 08:58:32  $
;// $Archive:   S:\h26x\src\dec\d1dec.h_v  $
;// $Header:   S:\h26x\src\dec\d1dec.h_v   1.17   31 Oct 1996 08:58:32   SCDAY  $
;//	$Log:   S:\h26x\src\dec\d1dec.h_v  $
;// 
;//    Rev 1.17   31 Oct 1996 08:58:32   SCDAY
;// Raj added support for MMX decoder
;// 
;//    Rev 1.16   25 Sep 1996 17:34:02   BECHOLS
;// Added Snapshot fields to the Decoder Catalog.
;// 
;//    Rev 1.15   12 Sep 1996 14:22:50   MBODART
;// Replaced GlobalAlloc family with HeapAlloc in the H.261 decoder.
;// 
;//    Rev 1.14   06 Sep 1996 15:03:00   MBODART
;// Added performance counters ffor NT's perfmon.
;// New files:  cxprf.cpp, cxprf.h, cxprfmac.h.
;// New directory:  src\perf
;// Updated files:  e1enc.{h,cpp}, d1dec.{h,cpp}, cdrvdefs.h, h261* makefiles.
;// 
;//    Rev 1.13   21 Aug 1996 18:59:36   RHAZRA
;// Added RTP fields to decoder catalog.
;// 
;//    Rev 1.12   05 Aug 1996 11:00:30   MBODART
;// 
;// H.261 decoder rearchitecture:
;// Files changed:  d1gob.cpp, d1mblk.{cpp,h}, d1dec.{cpp,h},
;//                 filelist.261, h261_32.mak
;// New files:      d1bvriq.cpp, d1idct.cpp
;// Obsolete files: d1block.cpp
;// Work still to be done:
;//   Update h261_mf.mak
;//   Optimize uv pairing in d1bvriq.cpp and d1idct.cpp
;//   Fix checksum code (it doesn't work now)
;//   Put back in decoder stats
;// 
;//    Rev 1.11   29 Feb 1996 09:20:04   SCDAY
;// Added support for mirroring
;// 
;//    Rev 1.10   11 Jan 1996 16:53:26   DBRUCKS
;// 
;// added flags to the DC structure (force on aspect ratio correction and
;// use block edge filter).
;// 
;//    Rev 1.9   09 Jan 1996 09:41:50   AKASAI
;// Updated copyright notice.
;// 
;//    Rev 1.8   26 Dec 1995 17:42:14   DBRUCKS
;// changed bTimerIsOn to bTimingThisFrame
;// 
;//    Rev 1.7   26 Dec 1995 12:49:00   DBRUCKS
;// 
;// add timing variables to the catalog
;// 
;//    Rev 1.6   15 Nov 1995 14:28:46   AKASAI
;// Added support for YUV12 "if 0" old code with aspec correction and
;// 8 to 7 bit conversion.  Added FrameCopy calls and DispFrame into structure.
;// (Integration point)
;// 
;//    Rev 1.5   01 Nov 1995 13:46:44   AKASAI
;// Added new element to T_H263DecoderCatalog, uFilterBBuffer, space for the
;// result of loop filter.
;// 
;//    Rev 1.4   26 Oct 1995 15:31:44   SCDAY
;// 
;// Delta frames partially working -- changed main loops to accommodate
;// skipped macroblocks by detecting next startcode
;// 
;//    Rev 1.3   10 Oct 1995 14:57:42   SCDAY
;// added support for FCIF
;// 
;//    Rev 1.2   06 Oct 1995 15:31:22   SCDAY
;// Integrated with latest AKK d1block
;// 
;//    Rev 1.1   19 Sep 1995 15:25:00   SCDAY
;// 
;// added H261 pict, GOB, MB/MBA parsing
;// 
;//    Rev 1.0   11 Sep 1995 13:51:08   SCDAY
;// Initial revision.
;// 
;//    Rev 1.13   01 Sep 1995 09:49:12   DBRUCKS
;// checkin partial ajdust pels changes
;// 
;//    Rev 1.12   29 Aug 1995 16:48:12   DBRUCKS
;// add YVU9_VPITCH
;// 
;//    Rev 1.11   28 Aug 1995 10:15:04   DBRUCKS
;// update to 5 July Spec and 8/25 Errata
;// 
;//    Rev 1.10   23 Aug 1995 12:25:10   DBRUCKS
;// Turn on the color converters
;// 
;//    Rev 1.9   14 Aug 1995 16:38:30   DBRUCKS
;// add hung type and clarify pCurBlock
;// 
;//    Rev 1.8   11 Aug 1995 17:30:00   DBRUCKS
;// copy source to bitstream
;// 
;//    Rev 1.7   11 Aug 1995 15:13:00   DBRUCKS
;// ready to integrate block level
;// 
;//    Rev 1.6   04 Aug 1995 15:56:32   TRGARDOS
;// 
;// Put definition of PITCH into CDRVDEFS.H so that encoder
;// doesn't get a redefinition of MACRO warning.
;// 
;//    Rev 1.5   03 Aug 1995 10:37:54   TRGARDOS
;// 
;// Moved picture header structure definition to cdrvsdef.h.
;// 
;//    Rev 1.4   02 Aug 1995 15:31:02   DBRUCKS
;// added GOB header fields and cleaned up comments
;// 
;//    Rev 1.3   01 Aug 1995 16:24:58   DBRUCKS
;// add the picture header fields
;// 
;//    Rev 1.2   31 Jul 1995 16:28:12   DBRUCKS
;// move loacl BITS defs to D3DEC.CPP
;// 
;//    Rev 1.1   31 Jul 1995 15:51:12   CZHU
;// 
;// added quant field in the BlockActionStream structure.
;// 
;//    Rev 1.0   31 Jul 1995 13:00:06   DBRUCKS
;// Initial revision.
;// 
;//    Rev 1.2   28 Jul 1995 13:59:54   CZHU
;// 
;// Added block action stream definition and defines for constants
;// 
;//    Rev 1.1   24 Jul 1995 14:59:30   CZHU
;// 
;// Defined decoder catalog for H.263. Also defined block action stream
;// 
;//    Rev 1.0   17 Jul 1995 14:46:24   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   17 Jul 1995 14:14:40   CZHU
;// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#ifndef __DECLOCS_H__
#define __DECLOCS_H__

/*
  This file declares structs which catalog the locations of various
  tables, structures, and arrays needed by the H263 decoder.
*/
#define QCIF_WIDTH	176
#define FCIF_WIDTH	352
//#define PITCH         384
#define YVU9_VPITCH	336 
#define U_OFFSET      192 
#define UMV_EXPAND_Y  16
#define UMV_EXPAND_UV 8	   // expanding for Unrestricted MV in each direction
#define Y_START		(UMV_EXPAND_Y * PITCH + UMV_EXPAND_Y)
#define UV_START	(UMV_EXPAND_UV * PITCH + UMV_EXPAND_UV)
#define INSTANCE_DATA_FIXED_SIZE  512
#define BLOCK_BUFFER_SIZE	PITCH*8 ////// 8*8*4*6
#define FILTER_BLOCK_BUFFER_SIZE	8*8	// 64 bytes for 8x8 block of U8

#define BLOCK_BUFFER_OFFSET  (6*8)		// New

typedef struct {

    U32 X32_YPlane;              /* X32_-pointer to Y, V, and U planes */
    U32 X32_VPlane;              /* Base plus offset is 32-bit aligned for */
    U32 X32_UPlane;              /* all planes                             */

} YUVFrame;

#define SRC_FORMAT_QCIF  	 0
#define SRC_FORMAT_CIF		 1 

typedef struct {
    /* Here's the data about the frame shape and location                  */

    YUVFrame CurrFrame;		 /* Current frame                          */
    YUVFrame PrevFrame;		 /* Previous frame                         */
    YUVFrame PBFrame;		 /* frame to hold B blocks for H.263       */
	YUVFrame DispFrame;			 /* current frame being displayed             */

    YUVFrame PostFrame;          /* Buffer for post process and color convert */

    U8 *     p16InstPostProcess; /* Segment containing PostFrm and ArchFrm  */
    LPVOID   a16InstPostProcess; /* Original alloc'd pointer for Post/ArchFrm.
                                  * p16InstPostProcess is a16InstPostProcess
                                  * rounded up to a 32-byte boundary.
                                  */

    U32 uFrameHeight;            /* Actual dimensions of image.             */
    U32 uFrameWidth;			 
    U32 uYActiveHeight;          /* Dimensions of image for which blocks are */
    U32 uYActiveWidth;           /* actually encoded.  I.e. height and width */
    U32 uUVActiveHeight;         /* padded to multiple of eight             */
    U32 uUVActiveWidth;
    U32 uSz_VUPlanes;            /* Space allocated for V and U planes      */
    U32 uSz_YPlane;              /* Space allocated for Y plane             */
    U32 uSz_YVUPlanes;           /* Space allocated for all planes          */

	/************************************************************************/
	/* These three fields are needed for implementing Snapshot.             */
	U32 SnapshotRequest;         /* Flags defined below                     */
	HANDLE SnapshotEvent;        /* Event for synchronization of Snapshot   */
	LPVOID SnapshotBuffer;       /* This is the buffer where Snapshot goes  */
	/************************************************************************/
    
    /* The data pointed to below is NOT instance specific.  On 16-bit Windows
       it is copied to the per-instance data segment.  On 32-bit Windows, it
       is in the one and only data segment, and is just pointed to here.    */
	
    U32 uMBBuffer;		/* storage for a block */
    U32 uFilterBBuffer;	         /* storage for a block after loop filter */
    U32 X16_BlkDir;		/* Ptr array of type T_BlkDir */
    U32 X16_BlkActionStream;	/* Params for each block */
    
    X32 X32_BEFDescr;            /* Catalogs eagerness & willingness to BEF */
    X32 X32_BEFDescrCopy;        /* Address of copy of BEFDescr in BEF seg  */
    X32 X32_BEFApplicationList;  /* List of blocks to do Block Edge Filter  */

    U32 X32_BitStream;           /* Huffman encoded bitstream for one frame */
    U32 uSizeBitStreamBuffer;	 /* Number of bytes allocated for this frame */

	U32 uSrcFormat;			/* Picture header information */
	U32 uPrevSrcFormat;
	U32 uTempRef;	
	U32 uBFrameTempRef;	 
	U32 uPQuant;
	U32 uDBQuant;
	U16 bSplitScreen;				 
	U16 bCameraOn;
	U16 bFreezeRelease;
	U16 bKeyFrame;
	U16 bUnrestrictedMotionVectors;
	U16 bArithmeticCoding;
	U16 bAdvancedPrediction;
	U16 bPBFrame;
	U16 bCPM;
	U16 bReadSrcFormat;
	U16 bHiResStill;
	U16 bUnused;
	
	U32 uGroupNumber;		 /* GOB header information */
	U32 uGOBFrameID;
	U32 uGQuant;
	U16 bFoundGOBFrameID;
	
	U16 bCoded;			 /* MB header information  */
	U32 uMBA;
	U32 uMBType;
	U32 uCBPC;
	U32 uCBPY;
	U32 uDQuant;			
	U32 uMQuant;
	I8  i8MVDH;
	I8  i8MVDV;
	U32 uCBP;
	I16 i16LastMBA;
	
    U16 bPrevFrameLost;          /* Flag affecting temporal filter         */
		
    U32 Sz_BitStream;            /* Space allocated for copy of BitStream  */
    U32 Ticker;                  /* Frame counter                          */
    
    U16 ColorConvertor;          /* Index of color convertor to use        */
    int CCOutputPitch;           /* Pitch for color converted output frame */
    U32 CCOffsetToLine0;         /* Offest to first line of color conv frame */
    
    U16 DecoderType;             /* Pick from H263, YUV9                   */

    X16 X16_LumaAdjustment;      /* Table to adjust brightness and contrast */
    X16 X16_ChromaAdjustment;    /* Table to adjust saturation             */
	/* The control code points to the flags with pointer to a BOOL     */
    BOOL bAdjustLuma;            /* Set if adjusting brightness and contrast */
    BOOL bAdjustChroma;          /* Set if adjusting saturation            */
    U16 BrightnessSetting;       /* Value used to build adjustment tables  */
    U16 ContrastSetting;         /* Value used to build adjustment tables  */
    U16 SaturationSetting;       /* Value used to build adjustment tables  */
    U16 SuppressChecksum;        /* Flag indicates if should skip checksum */
    U16 iAPColorConvPrev;
    LPVOID  pAPInstPrev;         /* Handle  PostFrm and ArchFrm for prev AP */
	
	// rearch
	X32 X32_InverseQuant;               //  NEW
	X32 X32_pN;					        //  NEW
	X32 X32_uMBInfoStream;              //  PB-NEW
	// rearch

	/* Timing Statistics Variables */
	X32 X32_DecTimingInfo;		 		/* Offset to */
	U32 uStatFrameCount;				/* statistics frame counter */
	/* The following are needed in lower level routines */
	int bTimingThisFrame;						
	U32 uStartLow;
	U32 uStartHigh;		

//#ifdef LOSS_RECOVERY

    I32    iVerifiedBsExt;
    I32    iValidBsExt;
    void   *pBsTrailer;
    void   *pBsInfo;
    U32    uNumOfPackets;

//#endif

	/* Options */
	int bForceOnAspectRatioCorrection;
	int bUseBlockEdgeFilter;

} T_H263DecoderCatalog;

/////////////////////////////////////////////////////////////////////////////
// Snapshot request flags, Ben - 09/25/96                                  //
#define SNAPSHOT_REQUESTED      0xFFFFFFF0                                 //
#define SNAPSHOT_COPY_STARTED   0xFFFFFFEF                                 //
#define SNAPSHOT_COPY_FINISHED  0xFFFFFFEE                                 //
#define SNAPSHOT_COPY_REJECTED  0xFFFFFFED                                 //
/////////////////////////////////////////////////////////////////////////////

// rearch
// ?? U32 or U8??
typedef struct {                           // NEW
	U32   dInverseQuant;                   // NEW
    U32   dTotalRun;                       // NEW
} T_IQ_INDEX;							   // NEW

/* MBInfo
 *
 * A stream of T_MBInfo structs provides a place to hold information 
 * about the macroblocks gathered during the first pass so it can
 * be used during the second pass for B-frame bi-directional motion
 * prediction.  Each struct deals with one macroblock.
 */
typedef struct {                            // PB-NEW
    I8  i8MBType;                           // AP-NEW added by Raj
	I8  i8MVDBx2;
	I8  i8MVDBy2;
} T_MBInfo;                                 // PB-NEW
// rearch

/* Block Type defines
 */
#define BT_INTRA_DC		0	// Intra block without TCOEFF
	// assembly code assumes INTRA_DC is zero
#define BT_INTRA		1  	// Intra block
#define BT_INTER		2	// Inter block
#define BT_EMPTY		3	// Inter block without TCOEFF
#define BT_ERROR		4


/* T_BlkAction
 * 
 * A stream of T_BlkAction structs provides information about the blocks to
 * be processed for a slice.  Each struct deals with one block.
 */
typedef struct {
    U8 	u8BlkType;			/* block type */ 
    I8  i8MVX; 				/* horizontal motion - mult by two for half pel */
    I8  i8MVY;				/* vertical motion - mult by two for half pel */
	/* rename to u8Quant */
	U8  u8Quant;				/* quantization level for this block */
    U32 pCurBlock;			/* current image. */
    U32 pRefBlock;			/* reference image. */
    U32 pBBlock;		  	/* B block image */
    U32 uBlkNumber;			/* for debugging */
 } T_BlkAction;


typedef struct {

    X32 X32_BlkAddr;              /* Addr of block in current frame buffer. */
    
} T_BlkDir;

#ifdef WIN32
#else

/* Return offsets for these structures. */

U32 FAR H263DOffset_DequantizerTables ();

/* Return size of fixed-size tables at start of instance data. */

U32 FAR H263DSizeOf_FixedPart();

#endif

X32 FAR ASM_CALLTYPE DecodeVLC (
            U8 FAR *P16Instance,        /* Base of instance data.          */
            X16 X16_VLCStateTrans,      /* Offset to State Transition tbl. */
            U16  FirstBitPosition,      /* a.k.a. first state number.      */
            X32 X32_SliceBase,          /* Offset to Stream to decode.     */
            X16 X16_CodeBookStream);    /* Offset to place to put output.  */

#ifdef WIN32
/*IN FAR ASM_CALLTYPE BlkCopy (
                void * SourceAddr,
                void * DestinationAddr,
                U32 TransferLength);
*/
#else
/*
IN FAR ASM_CALLTYPE BlkCopy (
                X32 SourceAddr,
                unsigned int SourceSegNum,
                X32 DestinationAddr,
                unsigned int DestinationSegNum,
                U32 TransferLength);
*/
#endif

void FAR ASM_CALLTYPE MassageYVU9Format (
              U8 FAR * P16Instance,        /* Base of instance data        */
              U8 FAR * InputImage);        /* Address of input YUV9 image  */

X32  FAR ASM_CALLTYPE DecodeSlice (
              U8 FAR * P16Instance,        /* Base of instance data        */
              U16 NumberOfMacroBlkRows,     /* Number of rows in slice     */
              U16 MacroBlkRowNum);          /* First row in slice          */

void FAR ASM_CALLTYPE DequantizeAndInverseSlant (
              U8 FAR * P16Instance,        /* Base of instance data        */
              X32 BlkCodePtr,              /* Offset to Block Codes        */
              X16 X16_BlkActionStream,     /* Offset to stream of descriptors */
              X16 X16_DQMatrices);         /* Offset to the 63 DQ matrices */

extern "C" {
void FAR ASM_CALLTYPE FrameCopy (
		HPBYTE InputPlane,	   /* Address of input data.       */
		HPBYTE OuptutPlane,        /* Address of output data.      */
		UN FrameHeight,            /* Lines to copy.               */
		UN FrameWidth,             /* Columns to copy.             */
		UN Pitch);                 /* Pitch.                       */

void FAR ASM_CALLTYPE FrameMirror (
		HPBYTE InputPlane,	   /* Address of input data.       */
		HPBYTE OuptutPlane,        /* Address of output data.      */
		UN FrameHeight,            /* Lines to copy.               */
		UN FrameWidth,             /* Columns to copy.             */
		UN Pitch);                 /* Pitch.                       */
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1gob.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * 
 *  d1gob.h
 *
 *  Description:
 *		Interface to GOB header processing.  
 */

/* $Header:   S:\h26x\src\dec\d1gob.h_v   1.3   09 Jan 1996 09:41:46   AKASAI  $
 */

#ifndef __D1GOB_H__
#define __D1GOB_H__

extern I32 H263DecodeGOBHeader(T_H263DecoderCatalog FAR * DC, 
					   BITSTREAM_STATE FAR * fpbsState,
					   U32 uAssumedGroupNumber);

extern I32 H263DecodeGOBStartCode(T_H263DecoderCatalog FAR * DC, 
					   BITSTREAM_STATE FAR * fpbsState);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1fm.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AKASAI  $
// $Date:   18 Mar 1996 10:52:28  $
// $Archive:   S:\h26x\src\dec\d1fm.h_v  $
// $Header:   S:\h26x\src\dec\d1fm.h_v   1.1   18 Mar 1996 10:52:28   AKASAI  $
// $Log:   S:\h26x\src\dec\d1fm.h_v  $
;// 
;//    Rev 1.1   18 Mar 1996 10:52:28   AKASAI
;// 
;// Fixed pvcs comment from ;// to //.
// 
//    Rev 1.0   18 Mar 1996 10:51:12   AKASAI
// Initial revision.
// 
//    Rev 1.3   27 Dec 1995 14:36:20   RMCKENZX
// Added copyright notice
// 
//    Rev 1.2   12 Sep 1995 13:40:40   AKASAI
// 
// Changed ClipPix to ClipPixIntra and added ClipPixInter.
// 
//    Rev 1.1   22 Aug 1995 10:29:32   CZHU
// 
// Added #define to prevent multiple inclusion.
// 
//    Rev 1.0   21 Aug 1995 14:38:48   CZHU
// Initial revision.

#ifndef _DXFMIDCT_
#define _DXFMIDCT_


#define NUM_ELEM	64	// Number of elements in the block (8x8)
#define KERNEL_SIZE	16		// Number of elements needed in kernel
#define CLIP_RANGE	2048
                        
#define SCALER 13

extern const I32 	ROUNDER;

extern I8  Unique[];
extern I8  PClass[];
extern I32 KernelCoeff[NUM_ELEM][10];
extern I8  MapMatrix[NUM_ELEM][KERNEL_SIZE];
extern U8  ClipPixIntra[];
extern I32 ClipPixInter[];

#endif //_DXFMIDCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1idctab.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   AKASAI  $
// $Date:   18 Mar 1996 11:01:24  $
// $Archive:   S:\h26x\src\dec\d1idctab.cpv  $
// $Header:   S:\h26x\src\dec\d1idctab.cpv   1.1   18 Mar 1996 11:01:24   AKASAI  $
// $Log:   S:\h26x\src\dec\d1idctab.cpv  $
// 
//    Rev 1.1   18 Mar 1996 11:01:24   AKASAI
// 
// Changed include from dxfm.h to d1fm.h
// 
//    Rev 1.0   15 Mar 1996 09:07:26   AKASAI
// Initial revision.
// 
//    Rev 1.3   22 Dec 1995 13:55:56   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.2   12 Sep 1995 13:39:18   AKASAI
// 
// Changed ClipPix tables to ClipPixIntra table and added
// ClipPixInter table.
// 
//    Rev 1.1   22 Aug 1995 10:29:08   CZHU
// Fixed include file dxfm.h instead of fm.h
// 
//    Rev 1.0   21 Aug 1995 14:39:02   CZHU
// Initial revision.


// FMapIDCT tables

#include "precomp.h"

const I32 ROUNDER = 0x801000;

I8  Unique[NUM_ELEM] = {
0x1, 0x4, 0x2, 0x4, 0x2, 0x4, 0x2, 0x4,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x8, 0x3, 0x8, 0x2, 0x8, 0x3, 0x8,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x4, 0x2, 0x4, 0x2, 0x4, 0x2, 0x4,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x8, 0x3, 0x8, 0x2, 0x8, 0x3, 0x8,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
};    // 64 elements


I8  PClass[NUM_ELEM] = {
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
};    // 64 elements


I32 KernelCoeff[NUM_ELEM][10] = {
0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x07b2, 0x0686, 0x045b, 0x0187, 0x0587, 0x03b2, 0x014c, 0x0278, 0x00dd, 0x004d,
0x073f, 0x0300, 0x0625, 0x028b, 0x041b, 0x01b3, 0x0171, 0x0098, 0x0000, 0x0000,
0x0686, 0x0187, 0x07b2, 0x045b, 0x0587, 0x014c, 0x03b2, 0x00dd, 0x0278, 0x004d,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x045b, 0x07b2, 0x0187, 0x0686, 0x03b2, 0x014c, 0x0587, 0x0278, 0x00dd, 0x004d,
0x0300, 0x073f, 0x028b, 0x0625, 0x01b3, 0x041b, 0x0098, 0x0171, 0x0000, 0x0000,
0x0187, 0x045b, 0x0686, 0x07b2, 0x014c, 0x03b2, 0x0587, 0x00dd, 0x0278, 0x004d,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x073f, 0x0625, 0x041b, 0x0171, 0x0300, 0x028b, 0x01b3, 0x0098, 0x0000, 0x0000,
0x06d4, 0x02d4, 0x012b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0625, 0x0171, 0x073f, 0x041b, 0x028b, 0x0098, 0x0300, 0x01b3, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x041b, 0x073f, 0x0171, 0x0625, 0x01b3, 0x0300, 0x0098, 0x028b, 0x0000, 0x0000,
0x02d4, 0x06d4, 0x012b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0171, 0x041b, 0x0625, 0x073f, 0x0098, 0x01b3, 0x028b, 0x0300, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0686, 0x0587, 0x03b2, 0x014c, 0x0187, 0x00dd, 0x004d, 0x07b2, 0x045b, 0x0278,
0x0625, 0x028b, 0x0171, 0x0098, 0x073f, 0x0300, 0x041b, 0x01b3, 0x0000, 0x0000,
0x0587, 0x014c, 0x0686, 0x03b2, 0x004d, 0x0187, 0x00dd, 0x07b2, 0x045b, 0x0278,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x03b2, 0x0686, 0x014c, 0x0587, 0x00dd, 0x0187, 0x004d, 0x045b, 0x07b2, 0x0278,
0x028b, 0x0625, 0x0098, 0x0171, 0x0300, 0x073f, 0x01b3, 0x041b, 0x0000, 0x0000,
0x014c, 0x03b2, 0x0587, 0x0686, 0x004d, 0x00dd, 0x0187, 0x045b, 0x07b2, 0x0278,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x045b, 0x03b2, 0x0278, 0x00dd, 0x07b2, 0x0686, 0x0187, 0x014c, 0x004d, 0x0587,
0x041b, 0x01b3, 0x073f, 0x0300, 0x0171, 0x0098, 0x0625, 0x028b, 0x0000, 0x0000,
0x03b2, 0x00dd, 0x045b, 0x0278, 0x0686, 0x0187, 0x07b2, 0x014c, 0x004d, 0x0587,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0278, 0x045b, 0x00dd, 0x03b2, 0x07b2, 0x0187, 0x0686, 0x004d, 0x014c, 0x0587,
0x01b3, 0x041b, 0x0300, 0x073f, 0x0098, 0x0171, 0x028b, 0x0625, 0x0000, 0x0000,
0x00dd, 0x0278, 0x03b2, 0x045b, 0x0187, 0x0686, 0x07b2, 0x004d, 0x014c, 0x0587,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0300, 0x028b, 0x01b3, 0x0098, 0x073f, 0x0625, 0x041b, 0x0171, 0x0000, 0x0000,
0x02d4, 0x012b, 0x06d4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x028b, 0x0098, 0x0300, 0x01b3, 0x0625, 0x0171, 0x073f, 0x041b, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x01b3, 0x0300, 0x0098, 0x028b, 0x041b, 0x073f, 0x0171, 0x0625, 0x0000, 0x0000,
0x012b, 0x02d4, 0x06d4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0098, 0x01b3, 0x028b, 0x0300, 0x0171, 0x041b, 0x0625, 0x073f, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0187, 0x014c, 0x00dd, 0x004d, 0x045b, 0x03b2, 0x0278, 0x0686, 0x0587, 0x07b2,
0x0171, 0x0098, 0x041b, 0x01b3, 0x0625, 0x028b, 0x073f, 0x0300, 0x0000, 0x0000,
0x014c, 0x004d, 0x0187, 0x00dd, 0x03b2, 0x045b, 0x0278, 0x0587, 0x0686, 0x07b2,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x00dd, 0x0187, 0x004d, 0x014c, 0x0278, 0x045b, 0x03b2, 0x0686, 0x0587, 0x07b2,
0x0098, 0x0171, 0x01b3, 0x041b, 0x028b, 0x0625, 0x0300, 0x073f, 0x0000, 0x0000,
0x004d, 0x00dd, 0x014c, 0x0187, 0x0278, 0x03b2, 0x045b, 0x0587, 0x0686, 0x07b2,
};    // [64][10] elements


I8 MapMatrix[NUM_ELEM][KERNEL_SIZE] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x03, 0x02,
0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x03, 0x02,
0x00, 0x05, 0x06, 0x07, 0x00, 0x05, 0x06, 0x07,
0x00, 0x05, 0x06, 0x07, 0x00, 0x05, 0x06, 0x07,
0x00, 0x02, 0x02, 0x01, 0x00, 0x02, 0x02, 0x01,
0x00, 0x02, 0x02, 0x01, 0x00, 0x02, 0x02, 0x01,
0x00, 0x05, 0x02, 0x03, 0x00, 0x05, 0x02, 0x03,
0x00, 0x05, 0x02, 0x03, 0x00, 0x05, 0x02, 0x03,
0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x01, 0x02,
0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x01, 0x02,
0x00, 0x05, 0x02, 0x07, 0x00, 0x05, 0x02, 0x07,
0x00, 0x05, 0x02, 0x07, 0x00, 0x05, 0x02, 0x07,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
0x00, 0x01, 0x02, 0x03, 0x01, 0x04, 0x05, 0x06,
0x02, 0x05, 0x07, 0x08, 0x03, 0x06, 0x08, 0x09,
0x00, 0x01, 0x09, 0x08, 0x02, 0x03, 0x0b, 0x0a,
0x04, 0x05, 0x0d, 0x0c, 0x06, 0x07, 0x0f, 0x0e,
0x00, 0x0b, 0x0c, 0x0d, 0x04, 0x0f, 0x0a, 0x10,
0x06, 0x11, 0x0d, 0x12, 0x05, 0x13, 0x0b, 0x11,
0x00, 0x04, 0x04, 0x00, 0x01, 0x05, 0x05, 0x01,
0x02, 0x06, 0x06, 0x02, 0x03, 0x07, 0x07, 0x03,
0x00, 0x0b, 0x02, 0x03, 0x04, 0x0d, 0x05, 0x06,
0x07, 0x0a, 0x08, 0x04, 0x08, 0x0c, 0x09, 0x05,
0x00, 0x09, 0x01, 0x08, 0x02, 0x0b, 0x03, 0x0a,
0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e,
0x00, 0x0b, 0x02, 0x0d, 0x04, 0x0f, 0x06, 0x0c,
0x07, 0x12, 0x05, 0x0b, 0x09, 0x11, 0x04, 0x0a,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x0c, 0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x0b,
0x00, 0x01, 0x04, 0x03, 0x01, 0x02, 0x05, 0x04,
0x04, 0x05, 0x02, 0x01, 0x03, 0x04, 0x01, 0x00,
0x00, 0x09, 0x0a, 0x0b, 0x04, 0x0d, 0x0e, 0x0f,
0x0c, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03,
0x00, 0x02, 0x02, 0x00, 0x01, 0x03, 0x03, 0x01,
0x03, 0x01, 0x01, 0x03, 0x02, 0x00, 0x00, 0x02,
0x00, 0x09, 0x02, 0x03, 0x04, 0x0d, 0x06, 0x07,
0x0c, 0x05, 0x0e, 0x0f, 0x08, 0x01, 0x0a, 0x0b,
0x00, 0x04, 0x01, 0x03, 0x02, 0x03, 0x00, 0x05,
0x05, 0x00, 0x03, 0x02, 0x03, 0x01, 0x04, 0x00,
0x00, 0x09, 0x02, 0x0b, 0x04, 0x0d, 0x06, 0x0f,
0x0c, 0x05, 0x0e, 0x07, 0x08, 0x01, 0x0a, 0x03,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0d, 0x0f, 0x10,
0x11, 0x0a, 0x12, 0x0e, 0x12, 0x0c, 0x13, 0x0f,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x0c, 0x0d, 0x05, 0x04, 0x0e, 0x0f, 0x07, 0x06,
0x00, 0x0b, 0x0c, 0x0d, 0x0b, 0x04, 0x05, 0x06,
0x0c, 0x05, 0x07, 0x08, 0x0d, 0x06, 0x08, 0x09,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x06, 0x02, 0x02, 0x06, 0x07, 0x03, 0x03, 0x07,
0x00, 0x0b, 0x02, 0x03, 0x0e, 0x05, 0x10, 0x0c,
0x11, 0x08, 0x0f, 0x0b, 0x13, 0x07, 0x0e, 0x0a,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x0c, 0x05, 0x0d, 0x04, 0x0e, 0x07, 0x0f, 0x06,
0x00, 0x0b, 0x02, 0x0d, 0x0e, 0x05, 0x0a, 0x06,
0x10, 0x07, 0x0d, 0x08, 0x0f, 0x09, 0x0b, 0x07,
0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x03, 0x02, 0x02, 0x03, 0x01, 0x00,
0x02, 0x03, 0x01, 0x00, 0x00, 0x01, 0x03, 0x02,
0x00, 0x05, 0x06, 0x07, 0x04, 0x01, 0x02, 0x03,
0x04, 0x01, 0x02, 0x03, 0x00, 0x05, 0x06, 0x07,
0x00, 0x02, 0x02, 0x01, 0x03, 0x01, 0x00, 0x03,
0x02, 0x00, 0x00, 0x02, 0x01, 0x03, 0x03, 0x01,
0x00, 0x05, 0x02, 0x03, 0x04, 0x01, 0x06, 0x07,
0x04, 0x01, 0x06, 0x07, 0x00, 0x05, 0x02, 0x03,
0x00, 0x03, 0x01, 0x02, 0x02, 0x01, 0x03, 0x00,
0x02, 0x01, 0x03, 0x00, 0x00, 0x03, 0x01, 0x02,
0x00, 0x05, 0x02, 0x07, 0x04, 0x01, 0x06, 0x03,
0x04, 0x01, 0x06, 0x03, 0x00, 0x05, 0x02, 0x07,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0f, 0x0a, 0x10,
0x06, 0x07, 0x03, 0x08, 0x05, 0x09, 0x01, 0x07,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x04, 0x05, 0x0d, 0x0c, 0x06, 0x07, 0x0f, 0x0e,
0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x05, 0x06, 0x02,
0x07, 0x12, 0x0f, 0x0b, 0x09, 0x11, 0x0e, 0x0a,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x02, 0x06, 0x06, 0x02, 0x03, 0x07, 0x07, 0x03,
0x00, 0x0b, 0x02, 0x03, 0x0b, 0x04, 0x0f, 0x10,
0x02, 0x0f, 0x07, 0x08, 0x03, 0x10, 0x08, 0x09,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e,
0x00, 0x0b, 0x02, 0x0d, 0x0e, 0x03, 0x0f, 0x06,
0x07, 0x0a, 0x08, 0x0e, 0x08, 0x0c, 0x09, 0x0f,
0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03,
0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,
0x00, 0x01, 0x02, 0x03, 0x0c, 0x0d, 0x0e, 0x0f,
0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
0x00, 0x01, 0x04, 0x03, 0x05, 0x03, 0x00, 0x02,
0x02, 0x00, 0x03, 0x05, 0x03, 0x04, 0x01, 0x00,
0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x05, 0x06, 0x07,
0x04, 0x0d, 0x0e, 0x0f, 0x08, 0x01, 0x02, 0x03,
0x00, 0x02, 0x02, 0x00, 0x03, 0x01, 0x01, 0x03,
0x01, 0x03, 0x03, 0x01, 0x02, 0x00, 0x00, 0x02,
0x00, 0x09, 0x02, 0x03, 0x0c, 0x05, 0x0e, 0x0f,
0x04, 0x0d, 0x06, 0x07, 0x08, 0x01, 0x0a, 0x0b,
0x00, 0x04, 0x01, 0x03, 0x04, 0x02, 0x05, 0x01,
0x01, 0x05, 0x02, 0x04, 0x03, 0x01, 0x04, 0x00,
0x00, 0x09, 0x02, 0x0b, 0x0c, 0x05, 0x0e, 0x07,
0x04, 0x0d, 0x06, 0x0f, 0x08, 0x01, 0x0a, 0x03,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x02, 0x02, 0x02, 0x02, 0x07, 0x07, 0x07, 0x07,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0f, 0x10, 0x0c,
0x07, 0x08, 0x05, 0x01, 0x13, 0x11, 0x0e, 0x0a,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x04, 0x05, 0x0d, 0x0c, 0x0e, 0x0f, 0x07, 0x06,
0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x03, 0x05, 0x06,
0x07, 0x0a, 0x12, 0x0e, 0x12, 0x02, 0x09, 0x05,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x02, 0x06, 0x06, 0x02, 0x07, 0x03, 0x03, 0x07,
0x00, 0x0b, 0x02, 0x03, 0x0e, 0x05, 0x0a, 0x10,
0x06, 0x11, 0x03, 0x08, 0x0f, 0x09, 0x0b, 0x11,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x04, 0x0d, 0x05, 0x0c, 0x0e, 0x07, 0x0f, 0x06,
0x00, 0x0b, 0x02, 0x0d, 0x0b, 0x04, 0x0f, 0x06,
0x02, 0x0f, 0x07, 0x12, 0x0d, 0x06, 0x12, 0x09,
};    // [64][16] elements


U8 ClipPixIntra[CLIP_RANGE] = {
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x02, 0x03,
0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b,
0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13,
0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0x1b,
0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23,
0x24, 0x25, 0x26, 0x27,
0x28, 0x29, 0x2a, 0x2b,
0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33,
0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3a, 0x3b,
0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43,
0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b,
0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53,
0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x5b,
0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63,
0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b,
0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73,
0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x7b,
0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83,
0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8a, 0x8b,
0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93,
0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9a, 0x9b,
0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3,
0xa4, 0xa5, 0xa6, 0xa7,
0xa8, 0xa9, 0xaa, 0xab,
0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3,
0xb4, 0xb5, 0xb6, 0xb7,
0xb8, 0xb9, 0xba, 0xbb,
0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3,
0xc4, 0xc5, 0xc6, 0xc7,
0xc8, 0xc9, 0xca, 0xcb,
0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3,
0xd4, 0xd5, 0xd6, 0xd7,
0xd8, 0xd9, 0xda, 0xdb,
0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3,
0xe4, 0xe5, 0xe6, 0xe7,
0xe8, 0xe9, 0xea, 0xeb,
0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3,
0xf4, 0xf5, 0xf6, 0xf7,
0xf8, 0xf9, 0xfa, 0xfb,
0xfc, 0xfd, 0xfe, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
};    // 2048 elements


I32 ClipPixInter[CLIP_RANGE] = {
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff01, 0xffffff02, 0xffffff03,
0xffffff04, 0xffffff05, 0xffffff06, 0xffffff07,
0xffffff08, 0xffffff09, 0xffffff0a, 0xffffff0b,
0xffffff0c, 0xffffff0d, 0xffffff0e, 0xffffff0f,
0xffffff10, 0xffffff11, 0xffffff12, 0xffffff13,
0xffffff14, 0xffffff15, 0xffffff16, 0xffffff17,
0xffffff18, 0xffffff19, 0xffffff1a, 0xffffff1b,
0xffffff1c, 0xffffff1d, 0xffffff1e, 0xffffff1f,
0xffffff20, 0xffffff21, 0xffffff22, 0xffffff23,
0xffffff24, 0xffffff25, 0xffffff26, 0xffffff27,
0xffffff28, 0xffffff29, 0xffffff2a, 0xffffff2b,
0xffffff2c, 0xffffff2d, 0xffffff2e, 0xffffff2f,
0xffffff30, 0xffffff31, 0xffffff32, 0xffffff33,
0xffffff34, 0xffffff35, 0xffffff36, 0xffffff37,
0xffffff38, 0xffffff39, 0xffffff3a, 0xffffff3b,
0xffffff3c, 0xffffff3d, 0xffffff3e, 0xffffff3f,
0xffffff40, 0xffffff41, 0xffffff42, 0xffffff43,
0xffffff44, 0xffffff45, 0xffffff46, 0xffffff47,
0xffffff48, 0xffffff49, 0xffffff4a, 0xffffff4b,
0xffffff4c, 0xffffff4d, 0xffffff4e, 0xffffff4f,
0xffffff50, 0xffffff51, 0xffffff52, 0xffffff53,
0xffffff54, 0xffffff55, 0xffffff56, 0xffffff57,
0xffffff58, 0xffffff59, 0xffffff5a, 0xffffff5b,
0xffffff5c, 0xffffff5d, 0xffffff5e, 0xffffff5f,
0xffffff60, 0xffffff61, 0xffffff62, 0xffffff63,
0xffffff64, 0xffffff65, 0xffffff66, 0xffffff67,
0xffffff68, 0xffffff69, 0xffffff6a, 0xffffff6b,
0xffffff6c, 0xffffff6d, 0xffffff6e, 0xffffff6f,
0xffffff70, 0xffffff71, 0xffffff72, 0xffffff73,
0xffffff74, 0xffffff75, 0xffffff76, 0xffffff77,
0xffffff78, 0xffffff79, 0xffffff7a, 0xffffff7b,
0xffffff7c, 0xffffff7d, 0xffffff7e, 0xffffff7f,
0xffffff80, 0xffffff81, 0xffffff82, 0xffffff83,
0xffffff84, 0xffffff85, 0xffffff86, 0xffffff87,
0xffffff88, 0xffffff89, 0xffffff8a, 0xffffff8b,
0xffffff8c, 0xffffff8d, 0xffffff8e, 0xffffff8f,
0xffffff90, 0xffffff91, 0xffffff92, 0xffffff93,
0xffffff94, 0xffffff95, 0xffffff96, 0xffffff97,
0xffffff98, 0xffffff99, 0xffffff9a, 0xffffff9b,
0xffffff9c, 0xffffff9d, 0xffffff9e, 0xffffff9f,
0xffffffa0, 0xffffffa1, 0xffffffa2, 0xffffffa3,
0xffffffa4, 0xffffffa5, 0xffffffa6, 0xffffffa7,
0xffffffa8, 0xffffffa9, 0xffffffaa, 0xffffffab,
0xffffffac, 0xffffffad, 0xffffffae, 0xffffffaf,
0xffffffb0, 0xffffffb1, 0xffffffb2, 0xffffffb3,
0xffffffb4, 0xffffffb5, 0xffffffb6, 0xffffffb7,
0xffffffb8, 0xffffffb9, 0xffffffba, 0xffffffbb,
0xffffffbc, 0xffffffbd, 0xffffffbe, 0xffffffbf,
0xffffffc0, 0xffffffc1, 0xffffffc2, 0xffffffc3,
0xffffffc4, 0xffffffc5, 0xffffffc6, 0xffffffc7,
0xffffffc8, 0xffffffc9, 0xffffffca, 0xffffffcb,
0xffffffcc, 0xffffffcd, 0xffffffce, 0xffffffcf,
0xffffffd0, 0xffffffd1, 0xffffffd2, 0xffffffd3,
0xffffffd4, 0xffffffd5, 0xffffffd6, 0xffffffd7,
0xffffffd8, 0xffffffd9, 0xffffffda, 0xffffffdb,
0xffffffdc, 0xffffffdd, 0xffffffde, 0xffffffdf,
0xffffffe0, 0xffffffe1, 0xffffffe2, 0xffffffe3,
0xffffffe4, 0xffffffe5, 0xffffffe6, 0xffffffe7,
0xffffffe8, 0xffffffe9, 0xffffffea, 0xffffffeb,
0xffffffec, 0xffffffed, 0xffffffee, 0xffffffef,
0xfffffff0, 0xfffffff1, 0xfffffff2, 0xfffffff3,
0xfffffff4, 0xfffffff5, 0xfffffff6, 0xfffffff7,
0xfffffff8, 0xfffffff9, 0xfffffffa, 0xfffffffb,
0xfffffffc, 0xfffffffd, 0xfffffffe, 0xffffffff,
0x00000000, 0x00000001, 0x00000002, 0x00000003,
0x00000004, 0x00000005, 0x00000006, 0x00000007,
0x00000008, 0x00000009, 0x0000000a, 0x0000000b,
0x0000000c, 0x0000000d, 0x0000000e, 0x0000000f,
0x00000010, 0x00000011, 0x00000012, 0x00000013,
0x00000014, 0x00000015, 0x00000016, 0x00000017,
0x00000018, 0x00000019, 0x0000001a, 0x0000001b,
0x0000001c, 0x0000001d, 0x0000001e, 0x0000001f,
0x00000020, 0x00000021, 0x00000022, 0x00000023,
0x00000024, 0x00000025, 0x00000026, 0x00000027,
0x00000028, 0x00000029, 0x0000002a, 0x0000002b,
0x0000002c, 0x0000002d, 0x0000002e, 0x0000002f,
0x00000030, 0x00000031, 0x00000032, 0x00000033,
0x00000034, 0x00000035, 0x00000036, 0x00000037,
0x00000038, 0x00000039, 0x0000003a, 0x0000003b,
0x0000003c, 0x0000003d, 0x0000003e, 0x0000003f,
0x00000040, 0x00000041, 0x00000042, 0x00000043,
0x00000044, 0x00000045, 0x00000046, 0x00000047,
0x00000048, 0x00000049, 0x0000004a, 0x0000004b,
0x0000004c, 0x0000004d, 0x0000004e, 0x0000004f,
0x00000050, 0x00000051, 0x00000052, 0x00000053,
0x00000054, 0x00000055, 0x00000056, 0x00000057,
0x00000058, 0x00000059, 0x0000005a, 0x0000005b,
0x0000005c, 0x0000005d, 0x0000005e, 0x0000005f,
0x00000060, 0x00000061, 0x00000062, 0x00000063,
0x00000064, 0x00000065, 0x00000066, 0x00000067,
0x00000068, 0x00000069, 0x0000006a, 0x0000006b,
0x0000006c, 0x0000006d, 0x0000006e, 0x0000006f,
0x00000070, 0x00000071, 0x00000072, 0x00000073,
0x00000074, 0x00000075, 0x00000076, 0x00000077,
0x00000078, 0x00000079, 0x0000007a, 0x0000007b,
0x0000007c, 0x0000007d, 0x0000007e, 0x0000007f,
0x00000080, 0x00000081, 0x00000082, 0x00000083,
0x00000084, 0x00000085, 0x00000086, 0x00000087,
0x00000088, 0x00000089, 0x0000008a, 0x0000008b,
0x0000008c, 0x0000008d, 0x0000008e, 0x0000008f,
0x00000090, 0x00000091, 0x00000092, 0x00000093,
0x00000094, 0x00000095, 0x00000096, 0x00000097,
0x00000098, 0x00000099, 0x0000009a, 0x0000009b,
0x0000009c, 0x0000009d, 0x0000009e, 0x0000009f,
0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3,
0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7,
0x000000a8, 0x000000a9, 0x000000aa, 0x000000ab,
0x000000ac, 0x000000ad, 0x000000ae, 0x000000af,
0x000000b0, 0x000000b1, 0x000000b2, 0x000000b3,
0x000000b4, 0x000000b5, 0x000000b6, 0x000000b7,
0x000000b8, 0x000000b9, 0x000000ba, 0x000000bb,
0x000000bc, 0x000000bd, 0x000000be, 0x000000bf,
0x000000c0, 0x000000c1, 0x000000c2, 0x000000c3,
0x000000c4, 0x000000c5, 0x000000c6, 0x000000c7,
0x000000c8, 0x000000c9, 0x000000ca, 0x000000cb,
0x000000cc, 0x000000cd, 0x000000ce, 0x000000cf,
0x000000d0, 0x000000d1, 0x000000d2, 0x000000d3,
0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7,
0x000000d8, 0x000000d9, 0x000000da, 0x000000db,
0x000000dc, 0x000000dd, 0x000000de, 0x000000df,
0x000000e0, 0x000000e1, 0x000000e2, 0x000000e3,
0x000000e4, 0x000000e5, 0x000000e6, 0x000000e7,
0x000000e8, 0x000000e9, 0x000000ea, 0x000000eb,
0x000000ec, 0x000000ed, 0x000000ee, 0x000000ef,
0x000000f0, 0x000000f1, 0x000000f2, 0x000000f3,
0x000000f4, 0x000000f5, 0x000000f6, 0x000000f7,
0x000000f8, 0x000000f9, 0x000000fa, 0x000000fb,
0x000000fc, 0x000000fd, 0x000000fe, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
};    // 2048 elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1idct.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   MBODART  $
// $Date:   05 Aug 1996 11:03:52  $
// $Archive:   S:\h26x\src\dec\d1idct.cpv  $
// $Header:   S:\h26x\src\dec\d1idct.cpv   1.0   05 Aug 1996 11:03:52   MBODART  $
// $Log:   S:\h26x\src\dec\d1idct.cpv  $
// 
//    Rev 1.0   05 Aug 1996 11:03:52   MBODART
// Initial revision.
//
// Started from d3idct.cpp
//
//    Rev 1.8   08 Mar 1996 16:46:20   AGUPTA2
// Added pragma code_seg.  Rolled the initialization code.  Got rid of most
// of 32-bit displacements in instructions.  Aligned frequently executed loops
// at 4-byte boundary.  Made changes to reflect new size of MapMatrix.  Removed
// nop instructions.  Deleted code that prefetches output lines in case of
// INTRA blocks. Use ClampTbl instead of ClipPixIntra.  Do not clip output
// of INTER blocks; clipping is done in dxblkadd().
//
//
//Block level decoding for H.261 decoder

#include "precomp.h"

/////////////////////////////////////////////////////////////////////////
// Decode each none-empty block
// Input:  lpInst:       decoder instance,
//         lpSrc:        input bitstream,
//         lpBlockAction:
//                       the pointer to the block action stream structure
//         bitsread:     number of bits in the buffer already,
/////////////////////////////////////////////////////////////////////////

// local variable definitions
#define FRAMEPOINTER		esp
#define L_BITSUSED	    	FRAMEPOINTER	+    0	// 4 byte
#define L_ACCUM             L_BITSUSED      +    4  //
#define L_DESTBLOCK         L_ACCUM         +  256	//64 DWORD
#define L_NO_COEFF          L_DESTBLOCK     +    4
#define L_PRODUCT           L_NO_COEFF      +    4

#define L_LOOPCOUNTER       L_PRODUCT       +   80  //20 DWORD
#define L_INPUT_INTER       L_LOOPCOUNTER   +    4
#define L_esi           	L_INPUT_INTER   +    4

#define L_DESTBLOCK_1       L_esi           +    4  // akk
#define L_DESTBLOCK_2       L_DESTBLOCK_1   +    4  // akk

#ifdef PTEL_WORK_AROUND
#define L_COEFFCOUNT        L_DESTBLOCK_1   +    4  //akk
#define L_COEFFVALUE        L_COEFFCOUNT    +    4  //akk
#endif

#define L_END_OF_FRAME		FRAMEPOINTER	+  512
#define LOCALSIZE		    ((512+3)&~3)		     // keep aligned

////////////////////////////////////////////////////////////////////////////////
// Input:
//       pIQ_INDEX,   pointer to pointer for Inverse quantization and index
//                    for the current block.
//       No_Coeff,    A 32 bit number indicate block types, etc.
//                    0--63,   inter block, number of coeff
//                    64--127  64+ intra block, number of coeff
//       pIntraBuf,   Buffer pointer for intra blocks.
//
//       pInterBuf,   Buffer pointer for inter blocks.
//
//
// return:
//
//////////////////////////////////////////////////////////////////////////////////
#pragma code_seg("IACODE2")
__declspec(naked)
U32 DecodeBlock_IDCT ( U32 pIQ_INDEX,
                       U32 No_Coeff,
                       U32 pIntraBuf,
                       U32 pInterBuf)
{
__asm
 {
    push    ebp                     // save callers frame pointer
      mov	ebp, esp                // make parameters accessible
    push    esi			            // assumed preserved
      push  edi
    push    ebx
      sub   esp, LOCALSIZE          // reserve local storage
    mov     eax, pInterBuf
      lea   edi, [L_ACCUM+128]
    mov     [L_INPUT_INTER], eax
      ;add   edi, 128                      // Adjust offset to save code space
    mov     edx, No_Coeff
	;

    ////////////////////////////////////////////////////////////////////////
    //  Initialize accumulators for IDCT
    //  ROUNDER was pre-computed.
    //
    //  C code:
    //
    //  for (x=0; x<16; x++)
    //      acc[x] = rounder;
    //  for (x=16; x<64; x++)
    //      acc[x] = 0L;
    //
    mov     esi, [edi-128]           ; pre-fetch accumulators
      mov   ebx, [edi-96]            ; pre-fetch
    mov     esi, [edi-64]            ; pre-fetch more
     mov    ebx, [edi-32]            ; pre-fetch more
    mov     esi, [edi]               ; pre-fetch more
     mov    ebx, [edi+32]            ; pre-fetch more
    mov     esi, [edi+64]            ; pre-fetch more
     mov    ebx, [edi+96]            ; pre-fetch more
    xor     esi, esi

    sub     edi, 128
     mov    eax, ROUNDER
    mov     ebx, 64
loop_for_init:
    mov   [edi], eax
    mov     [edi+4], eax
      mov   [edi+ebx], esi
    mov     [edi+ebx+4], esi
    mov     [edi+ebx+8], esi
    mov     [edi+ebx+12], esi
    mov     [edi+ebx+16], esi
    mov     [edi+ebx+20], esi
    add     edi, 8
    add     ebx, 16
    cmp     ebx, 192
    jl      loop_for_init

//end of IDCT init.

#ifdef PTEL_WORK_AROUND
    mov     [L_COEFFCOUNT], esi          // zero out coefficient counter
     mov    [L_COEFFVALUE], esi          // zero out coefficient value
#endif

	cmp     edx, 65
	  jg    intra_block

    mov     ebx, pInterBuf
      jmp   pre_acc_loop

intra_block:
    mov     ebx, pIntraBuf
	  sub   edx, 65

// register:
// ebp: loop counter
// ebx: inverse quant
// ecx: index [0,63]

pre_acc_loop:
	mov     esi, pIQ_INDEX
	  mov   [L_DESTBLOCK], ebx
    mov     [L_esi], esi

ALIGN 4
acc_loop:
    mov     ebx,[esi+edx*8-8]           //Invserse Quant
	  mov   ecx,[esi+edx*8-4]           //Coeff index
    mov     [L_NO_COEFF], edx
	  call  idct_acc
	mov     esi, [L_esi]
	  mov   edx, [L_NO_COEFF]
	dec     edx
      jnz   acc_loop

	mov     edx, [L_DESTBLOCK]
	  mov   ecx, [L_INPUT_INTER]
	cmp     edx, ecx
	  jnz   call_intra_bfly

	call    idct_bfly_inter

	add     esp, LOCALSIZE	            // free locals
	  add   eax, edi
	pop	    ebx
	  pop   edi
	pop	    esi
	  pop   ebp
	ret


call_intra_bfly:
    call    idct_bfly_intra

	add	    esp, LOCALSIZE	            // free locals
	  add   eax, edi
	pop	    ebx
	  pop   edi
	pop	    esi
	  pop   ebp
	ret

///////////////////////////////////////////////////////////////
// This "subroutine" idct_acc performs the accumulator phase of
// the fmidct.
//
// assume parameter passed in by registers
// ebx, inversed quantized value, input
// ecx, index [0,63]
//
//  C code:
//
//  for (i=0; i<NUM_ELEM; i++)   // Loop through each input
//  {
//    if (input[i])
//    {
//      pNKernel = &NKernel[i];    // initialize kernel pointer
//      totalU = pNKernel->totalUnique;
//      for (x=0; x<totalU; x++)  // compute positive and negative products
//      {
//        product[x] = input[i] * pNKernel->coeff[x];
//        product[x+totalU] = -product[x];
//      }
//      // Loop through each entry in the output matrix
//      acc[pNKernel->PClass] += product[ pNKernel->matrix[0] ];
//      acc[1+pNKernel->PClass] += product[ pNKernel->matrix[1] ];
//      acc[2+pNKernel->PClass] += product[ pNKernel->matrix[2] ];
//      acc[3+pNKernel->PClass] += product[ pNKernel->matrix[3] ];
//      acc[4+pNKernel->PClass] += product[ pNKernel->matrix[4] ];
//      acc[5+pNKernel->PClass] += product[ pNKernel->matrix[5] ];
//      acc[6+pNKernel->PClass] += product[ pNKernel->matrix[6] ];
//      acc[7+pNKernel->PClass] += product[ pNKernel->matrix[7] ];
//      acc[8+pNKernel->PClass] += product[ pNKernel->matrix[8] ];
//      acc[9+pNKernel->PClass] += product[ pNKernel->matrix[9] ];
//      acc[10+pNKernel->PClass] += product[ pNKernel->matrix[10] ];
//      acc[11+pNKernel->PClass] += product[ pNKernel->matrix[11] ];
//      acc[12+pNKernel->PClass] += product[ pNKernel->matrix[12] ];
//      acc[13+pNKernel->PClass] += product[ pNKernel->matrix[13] ];
//      acc[14+pNKernel->PClass] += product[ pNKernel->matrix[14] ];
//      acc[15+pNKernel->PClass] += product[ pNKernel->matrix[15] ];
//    }
//  }
///////////////////////////////////////////////////////////////
// assume parameter passed in by registers
// ebx, inverse quant
// ecx, index [0,63]
idct_acc:

;   For every non-zero coefficient:
;     LoopCounter, on local stack, has index
;     ecx = index (0-63)
;     ebx = non-zero input
;   Note i = index
;
#ifdef PTEL_WORK_AROUND
    mov     edx, [L_COEFFCOUNT+4]   ; get coefficient counter
      mov   [L_COEFFVALUE+4], ebx   ; store coefficient value
    inc     edx
      ;
    mov     [L_COEFFCOUNT+4], edx   ; store updated coefficient counter
      ;
#endif
    and     ecx, 03fh               ; Chad added to prevent GPF
      xor   edx, edx                ; zero out for byte read, use as dword
    mov     [L_LOOPCOUNTER+4], ecx  ; Store Loop counter
      mov   esi, ecx                ; move index to esi
    lea     eax, Unique             ; eax = Address of Unique[0]
      mov   ebp, ecx                ; move index to ebp
    shl     esi, 3                  ; index*8
      add   ecx, ecx                ; index*2
    add     esi, ecx                ; index*10
      lea   ecx, KernelCoeff        ; get KernelCoeff[0][0]
    lea     edi, [L_PRODUCT+4]      ; edi = address of product[0]
      mov   dl,  [eax+ebp]          ; get Unique[i]
    lea     esi, [ecx+4*esi]        ; address of KernelCoeff[i][0]
      mov   ebp, edx                ; ebp = Unique[i]
    lea     eax, [edi+edx*4]        ; eax = address of product[totalU]
      ;nop

;   ----------------------------------------------------------------------

;   Register usage
;     eax = addr of product[Unique[i]]
;     ebx = input[i]
;     ecx = 0, -product[x]
;     edx = KernelCoeff[i][x], product[x]= KernelCoeff[i][x] * input[i]
;     ebp = x
;     edi = addr of product[0]
;     esi = addr of KernelCoeff[i][x]

ALIGN 4
loop_for_x:
    xor     ecx, ecx
      mov   edx, [esi+ebp*4-4]      ; read KernelCoeff[i][x]
    imul    edx, ebx                ; KernelCoeff[i][x] * input[i]
    mov     [edi+ebp*4-4], edx      ; product[x] = result of imul
      sub   ecx, edx
    mov     [eax+ebp*4-4], ecx      ; product[totalU+x] = -product[x]
      dec   ebp                     ; decrement x
    jnz     loop_for_x

;   ----------------------------------------------------------------------

;   Register usage
;     eax = MapMatrix[i][0-15]
;     ebx = address of PClass[0], accum[PClass[i]]
;     ecx = LoopCounter, addr of MapMatrix[i][0]
;     edx = [0-15]+PClass[i], accum[[0-15]+PClass[i]]
;     ebp = product[MapMatrix[i][0-15]]
;     edi = addr of product[0]
;     esi = address of accum[0], address of accum[PClass[i]]

    mov     ecx, [L_LOOPCOUNTER+4]  ; get i
      and   ecx, 03fh               ; Chad added to prevent GPF
    lea     ebx, PClass             ; get addr of PClass[0]
      mov   esi, ecx                ; save i in esi
    shl     ecx, 4                  ; i*16
      lea   eax, MapMatrix          ; get addr of MapMatrix[0][0]
    xor     edx, edx
      nop
    mov     dl,  [ebx+esi]          ; get PClass[i]
      lea   ecx, [eax+ecx]          ; get addr of MapMatrix[i][0]
    shl     edx, 2                  ; PClass[i]*4
      lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
;   ----------------------------------------------------------------------
    xor     eax, eax
      add   esi, edx                ; esi = address of accum[PClass[i]]
    mov     al,  [ecx]              ; get MapMatrix[i][0]
      nop
      ;nop
    mov     ebx, [esi]              ; get accum[PClass[i]]
      nop
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][0]]
      mov   al,  [ecx+1]            ; get MapMatrix[i][1]
    add     ebx, ebp                ; accum[PClass[i]] += product[
                                    ;         MapMatrix[i][0]]
      mov   edx, [esi+4]            ; get accum[1+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][1]]
      mov   al,  [ecx+2]            ; get MapMatrix[i][2]
    add     edx, ebp                ; accum[1+PClass[i]] += product[
                                    ;       MapMatrix[i][1]]
      mov   [esi], ebx              ; store accum[PClass[i]] += product[
                                    ;       MapMatrix[i][0]]
    mov     [esi+4], edx            ; store accum[1+PClass[i]] +=
                                    ;      product[MapMatrix[i][1]]
      mov   ebx, [esi+8]            ; get accum[2+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][2]]
      mov   al,  [ecx+3]            ; get MapMatrix[i][3]
    add     ebx, ebp                ; accum[2+PClass[i]] += product[
                                    ;         MapMatrix[i][2]]
      mov   edx, [esi+12]           ; get accum[3+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][3]]
      mov   al,  [ecx+4]            ; get MapMatrix[i][4]
    add     edx, ebp                ; accum[3+PClass[i]] += product[
                                    ;       MapMatrix[i][3]]
      mov   [esi+8], ebx            ; store accum[2+PClass[i]] +=
                                    ;       product[MapMatrix[i][2]]
    mov     [esi+12], edx           ; store accum[3+PClass[i]] +=
                                    ;       product[MapMatrix[i][3]]

;   ----------------------------------------------------------------------
      mov   ebx, [esi+16]           ; get accum[4+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][4]]
      mov   al,  [ecx+5]            ; get MapMatrix[i][5]
    add     ebx, ebp                ; accum[4+PClass[i]] += product[
                                    ;         MapMatrix[i][4]]
      mov   edx, [esi+20]           ; get accum[5+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][5]]
      mov   al,  [ecx+6]            ; get MapMatrix[i][6]
    add     edx, ebp                ; accum[5+pNkernel->PClass] += product[
                                    ;       MapMatrix[i][5]]
      mov   [esi+16], ebx           ; store accum[4+PClass[i]] +=
                                    ;       product[MapMatrix[i][4]]
    mov     [esi+20], edx           ; store accum[5+PClass[i]] +=
                                    ;      product[MapMatrix[i][5]]
      mov   ebx, [esi+24]           ; get accum[6+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][6]]
      mov   al,  [ecx+7]            ; get MapMatrix[i][7]
    add     ebx, ebp
      mov   edx, [esi+28]           ; get accum[7+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][7]]
      mov   al,  [ecx+8]            ; get MapMatrix[i][8]
    add     edx, ebp                ; accum[7+PClass[i]] += product[
                                    ;       MapMatrix[i][7]]
      mov   [esi+24], ebx           ; store accum[6+PClass[i]] +=
                                    ;       product[MapMatrix[i][6]]
    mov     [esi+28], edx           ; store accum[7+PClass[i]] +=
                                    ;       product[MapMatrix[i][7]]

;   ----------------------------------------------------------------------
      mov   ebx, [esi+32]           ; get accum[8+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][8]]
      mov   al,  [ecx+9]            ; get MapMatrix[i][9]
    add     ebx, ebp                ; accum[8+PClass[i]] += product[
                                    ;         MapMatrix[i][8]]
      mov   edx, [esi+36]           ; get accum[9+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][9]]
      mov   al,  [ecx+10]           ; get MapMatrix[i][10]
    add     edx, ebp                ; accum[9+pNkernel->PClass] += product[
                                    ;       MapMatrix[i][9]]
      mov   [esi+32], ebx           ; store accum[8+PClass[i]] +=
                                    ;       product[MapMatrix[i][8]]
    mov     [esi+36], edx           ; store accum[9+PClass[i]] +=
                                    ;      product[MapMatrix[i][9]]
      mov   ebx, [esi+40]           ; get accum[10+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][10]]
      mov   al,  [ecx+11]           ; get MapMatrix[i][11]
    add     ebx, ebp
      mov   edx, [esi+44]           ; get accum[11+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][11]]
                                    ;       product[MapMatrix[i][11]]
      mov   al,  [ecx+12]           ; get MapMatrix[i][12]
    add     edx, ebp                ; accum[11+PClass[i]] += product[
                                    ;       MapMatrix[i][11]]
      mov   [esi+40], ebx           ; store accum[10+PClass[i]] +=
                                    ;       product[MapMatrix[i][10]]
    mov     [esi+44], edx           ; store accum[11+PClass[i]] +=
                                    ;       product[MapMatrix[i][11]]
;   ----------------------------------------------------------------------
      mov   ebx, [esi+48]           ; get accum[12+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][12]]
      mov   al,  [ecx+13]           ; get MapMatrix[i][13]
    add     ebx, ebp                ; accum[12+PClass[i]] += product[
                                    ;         MapMatrix[i][12]]
      mov   edx, [esi+52]           ; get accum[13+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][13]]
      mov   al,  [ecx+14]           ; get MapMatrix[i][14]
    add     edx, ebp                ; accum[13+pNkernel->PClass] += product[
                                    ;       MapMatrix[i][13]]
      mov   [esi+48], ebx           ; store accum[PClass[i]] += product[
                                    ;       MapMatrix[i][13]]
    mov     [esi+52], edx           ; store accum[13+PClass[i]] +=
                                    ;      product[MapMatrix[i][13]]
      mov   ebx, [esi+56]           ; get accum[14+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][14]]
      mov   al,  [ecx+15]           ; get MapMatrix[i][15]
    add     ebx, ebp
      mov   edx, [esi+60]           ; get accum[15+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][15]]
      mov   [esi+56], ebx           ; store accum[14+PClass[i]] +=
                                    ;       product[MapMatrix[i][14]]
    add     edx, ebp                ; accum[15+PClass[i]] += product[
                                    ;       MapMatrix[i][15]]
      mov   [esi+60], edx           ; store accum[15+PClass[i]] +=
                                    ;       product[MapMatrix[i][15]]
    ret

//////////////////////////////////////////////////////////////////////
// This "subroutine" idct_bfly_intra performs the butterfly phase of
// the fmidct for intra blocks.
//
// assume parameters passed in by registers
//
//  C code:
//
// Upper Left Quadrant
// Upper Right Quadrant
// Lower Left Quadrant
// Lower Right Quadrant
//
//		lOut[0][0] = CLIP_INTRA[acc[0]+acc[16] + acc[32]+acc[48]];
//		lOut[0][7] = CLIP_INTRA[acc[0]+acc[16] - (acc[32]+acc[48])];
//		lOut[7][0] = CLIP_INTRA[(acc[0]-acc[16]) + (acc[32]-acc[48])];
//		lOut[7][7] = CLIP_INTRA[(acc[0]-acc[16]) - (acc[32]-acc[48])];
//
//		lOut[0][1] = CLIP_INTRA[acc[1]+acc[17] + acc[33]+acc[49]];
//		lOut[0][6] = CLIP_INTRA[acc[1]+acc[17] - (acc[33]+acc[49])];
//		lOut[7][1] = CLIP_INTRA[(acc[1]-acc[17]) + (acc[33]-acc[49])];
//		lOut[7][6] = CLIP_INTRA[(acc[1]-acc[17]) - (acc[33]-acc[49])];
//
//		lOut[0][2] = CLIP_INTRA[acc[2]+acc[18] + acc[34]+acc[50]];
//		lOut[0][5] = CLIP_INTRA[acc[2]+acc[18] - (acc[34]+acc[50])];
//		lOut[7][2] = CLIP_INTRA[(acc[2]-acc[18]) + (acc[34]-acc[50])];
//		lOut[7][5] = CLIP_INTRA[(acc[2]-acc[18]) - (acc[34]-acc[50])];
//
//		lOut[0][3] = CLIP_INTRA[acc[3]+acc[19] + acc[35]+acc[51]];
//		lOut[0][4] = CLIP_INTRA[acc[3]+acc[19] - (acc[35]+acc[51])];
//		lOut[7][3] = CLIP_INTRA[(acc[3]-acc[19]) + (acc[35]-acc[51])];
//		lOut[7][4] = CLIP_INTRA[(acc[3]-acc[19]) - (acc[35]-acc[51])];
//
//
//		lOut[1][0] = CLIP_INTRA[acc[4]+acc[20] + acc[36]+acc[52]];
//		lOut[1][7] = CLIP_INTRA[acc[4]+acc[20] - (acc[36]+acc[52])];
//		lOut[6][0] = CLIP_INTRA[(acc[4]-acc[20]) + (acc[36]-acc[52])];
//		lOut[6][7] = CLIP_INTRA[(acc[4]-acc[20]) - (acc[36]-acc[52])];
//
//		lOut[1][1] = CLIP_INTRA[acc[5]+acc[21] + acc[37]+acc[53]];
//		lOut[1][6] = CLIP_INTRA[acc[5]+acc[21] - (acc[37]+acc[53])];
//		lOut[6][1] = CLIP_INTRA[(acc[5]-acc[21]) + (acc[37]-acc[53])];
//		lOut[6][6] = CLIP_INTRA[(acc[5]-acc[21]) - (acc[37]-acc[53])];
//
//		lOut[1][2] = CLIP_INTRA[acc[6]+acc[22] + acc[38]+acc[54]];
//		lOut[1][5] = CLIP_INTRA[acc[6]+acc[22] - (acc[38]+acc[54])];
//		lOut[6][2] = CLIP_INTRA[(acc[6]-acc[22]) + (acc[38]-acc[54])];
//		lOut[6][5] = CLIP_INTRA[(acc[6]-acc[22]) - (acc[38]-acc[54])];
//
//		lOut[1][3] = CLIP_INTRA[acc[7]+acc[23] + acc[39]+acc[55]];
//		lOut[1][4] = CLIP_INTRA[acc[7]+acc[23] - (acc[39]+acc[55])];
//		lOut[6][3] = CLIP_INTRA[(acc[7]-acc[23]) + (acc[39]-acc[55])];
//		lOut[6][4] = CLIP_INTRA[(acc[7]-acc[23]) - (acc[39]-acc[55])];
//
//
//		lOut[2][0] = CLIP_INTRA[acc[8]+acc[24] + acc[40]+acc[56]];
//		lOut[2][7] = CLIP_INTRA[acc[8]+acc[24] - (acc[40]+acc[56])];
//		lOut[5][0] = CLIP_INTRA[(acc[8]-acc[24]) + (acc[40]-acc[56])];
//		lOut[5][7] = CLIP_INTRA[(acc[8]-acc[24]) - (acc[40]-acc[56])];
//
//		lOut[2][1] = CLIP_INTRA[acc[9]+acc[25] + acc[41]+acc[57]];
//		lOut[2][6] = CLIP_INTRA[acc[9]+acc[25] - (acc[41]+acc[57])];
//		lOut[5][1] = CLIP_INTRA[(acc[9]-acc[25]) + (acc[41]-acc[57])];
//		lOut[5][6] = CLIP_INTRA[(acc[9]-acc[25]) - (acc[41]-acc[57])];
//
//		lOut[2][2] = CLIP_INTRA[acc[10]+acc[26] + acc[42]+acc[58]];
//		lOut[2][5] = CLIP_INTRA[acc[10]+acc[26] - (acc[42]+acc[58])];
//		lOut[5][2] = CLIP_INTRA[(acc[10]-acc[26]) + (acc[42]-acc[58])];
//		lOut[5][5] = CLIP_INTRA[(acc[10]-acc[26]) - (acc[42]-acc[58])];
//
//		lOut[2][3] = CLIP_INTRA[acc[11]+acc[27] + acc[43]+acc[59]];
//		lOut[2][4] = CLIP_INTRA[acc[11]+acc[27] - (acc[43]+acc[59])];
//		lOut[5][3] = CLIP_INTRA[(acc[11]-acc[27]) + (acc[43]-acc[59])];
//		lOut[5][4] = CLIP_INTRA[(acc[11]-acc[27]) - (acc[43]-acc[59])];
//
//
//		lOut[3][0] = CLIP_INTRA[acc[12]+acc[28] + acc[44]+acc[60]];
//		lOut[3][7] = CLIP_INTRA[acc[12]+acc[28] - (acc[44]+acc[60])];
//		lOut[4][0] = CLIP_INTRA[(acc[12]-acc[28]) + (acc[44]-acc[60])];
//		lOut[4][7] = CLIP_INTRA[(acc[12]-acc[28]) - (acc[44]-acc[60])];
//
//		lOut[3][1] = CLIP_INTRA[acc[13]+acc[29] + acc[45]+acc[61]];
//		lOut[3][6] = CLIP_INTRA[acc[13]+acc[29] - (acc[45]+acc[61])];
//		lOut[4][1] = CLIP_INTRA[(acc[13]-acc[29]) + (acc[45]-acc[61])];
//		lOut[4][6] = CLIP_INTRA[(acc[13]-acc[29]) - (acc[45]-acc[61])];
//
//		lOut[3][2] = CLIP_INTRA[acc[14]+acc[30] + acc[46]+acc[62]];
//		lOut[3][5] = CLIP_INTRA[acc[14]+acc[30] - (acc[46]+acc[62])];
//		lOut[4][2] = CLIP_INTRA[(acc[14]-acc[30]) + (acc[46]-acc[62])];
//		lOut[4][5] = CLIP_INTRA[(acc[14]-acc[30]) - (acc[46]-acc[62])];
//
//		lOut[3][3] = CLIP_INTRA[acc[15]+acc[31] + acc[47]+acc[63]];
//		lOut[3][4] = CLIP_INTRA[acc[15]+acc[31] - (acc[47]+acc[63])];
//		lOut[4][3] = CLIP_INTRA[(acc[15]-acc[31]) + (acc[47]-acc[63])];
//		lOut[4][4] = CLIP_INTRA[(acc[15]-acc[31]) - (acc[47]-acc[63])];
//
;   ----------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////
//assume parameters passed in by registers

idct_bfly_intra:

;   ----------------------------------------------------------------------
;   INTRA ONLY Butterfly and clamp
;   Uses all registers.
;   Uses all accumulators[64], accum
;   Uses ClipPixIntra[2048] of BYTES, ClipPixIntra
;   Writes to Output matrix of BYTES, OutputCoeff
;
;   Process 4 outputs per group, 0-7, 8-15
;   0

    mov     edi, [L_DESTBLOCK+4]    ; edi gets Base addr of OutputCoeff
     lea    esi, [L_ACCUM+128+4]    ; get addr of accum[32]
    mov     [L_DESTBLOCK_1+4], edi
      mov   edx, 2                  ; just loop 2 times
    mov     [L_DESTBLOCK_2+4], edi

ALIGN 4
loop_intra_bfly:
    mov     [L_LOOPCOUNTER+4], edx  ; Store local loop counter
      nop
    mov     eax, [esi-128]          ; get acc[0]
      mov   ebx, [esi-64]           ; get acc[16]
    mov     ebp, [esi]              ; get acc[32]
      mov   edx, [esi+64]           ; get acc[48]
    lea     ecx, [eax+ebx]          ; acc[0]+acc[16]
      sub   eax, ebx                ; acc[0]-acc[16]
    lea     ebx, [ebp+edx]          ; acc[32]+acc[48]
      sub   ebp, edx                ; acc[32]-acc[48]

    mov     edx, [edi]              ; pre-fetch output cache line 0
      mov   edi, [edi+7*PITCH]      ; pre-fetch output cache line 7
      ;mov   esi, [edi+7*PITCH]      ; pre-fetch output cache line 7

    lea     edx, [ecx+ebx]          ; tmp1 = acc[0]+acc[16] + acc[32]+acc[48]
      sub   ecx, ebx                ; tmp2 = acc[0]+acc[16] - (acc[32]+acc[48])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[0]-acc[16] + (acc[32]-acc[48])
      sub   eax, ebp                ; tmp4 = acc[0]-acc[16] - (acc[32]-acc[48])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi], dl      ; output[0][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+7], cl    ; output[0][7] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+7*PITCH], bl  ; output[7][0] = tmp3
      mov   ebx, [esi-60]               ; get acc[17]

;   -------------------------------------------------------------------------
;   1
    mov     BYTE PTR [edi+7*PITCH+7], al; output[7][7] = tmp4
      mov   eax, [esi-124]          ; get acc[1]
    mov     ebp, [esi+4]            ; get acc[33]
      mov   edx, [esi+68]           ; get acc[49]
    lea     ecx, [eax+ebx]          ; acc[1]+acc[17]
      sub   eax, ebx                ; acc[1]-acc[17]
    lea     ebx, [ebp+edx]          ; acc[33]+acc[49]
      sub   ebp, edx                ; acc[33]-acc[49]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[1]+acc[17] + acc[33]+acc[49]
      sub   ecx, ebx                ; tmp2 = acc[1]+acc[17] - (acc[33]+acc[49])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[1]-acc[17] + (acc[33]-acc[49])
      sub   eax, ebp                ; tmp4 = acc[1]-acc[17] - (acc[33]-acc[49])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+1], dl    ; output[0][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+6], cl    ; output[0][6] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+7*PITCH+1], bl  ; output[7][1] = tmp3
      mov   ebx, [esi-56]                 ; get acc[18]
;   -------------------------------------------------------------------------
;   2
    mov     BYTE PTR [edi+7*PITCH+6], al  ; output[7][6] = tmp4
      mov   eax, [esi-120]          ; get acc[2]
    mov     ebp, [esi+8]            ; get acc[34]
      mov   edx, [esi+72]           ; get acc[50]
    lea     ecx, [eax+ebx]          ; acc[2]+acc[18]
      sub   eax, ebx                ; acc[2]-acc[18]
    lea     ebx, [ebp+edx]          ; acc[34]+acc[50]
      sub   ebp, edx                ; acc[34]-acc[50]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[2]+acc[18] + acc[34]+acc[50]
      sub   ecx, ebx                ; tmp2 = acc[2]+acc[18] - (acc[34]+acc[50])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[2]-acc[18] + (acc[34]-acc[50])
      sub   eax, ebp                ; tmp4 = acc[2]-acc[18] - (acc[34]-acc[50])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2], dl    ; output[0][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+5], cl    ; output[0][5] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+7*PITCH+2], bl  ; output[7][2] = tmp3
      mov   ebx, [esi-52]                 ; get acc[19]
;   -------------------------------------------------------------------------
;   3
    mov     BYTE PTR [edi+7*PITCH+5], al  ; output[7][5] = tmp4
      mov   eax, [esi-116]          ; get acc[3]
    mov     ebp, [esi+12]           ; get acc[35]
      mov   edx, [esi+76]           ; get acc[51]
    lea     ecx, [eax+ebx]          ; acc[3]+acc[19]
      sub   eax, ebx                ; acc[3]-acc[19]
    lea     ebx, [ebp+edx]          ; acc[35]+acc[51]
      sub   ebp, edx                ; acc[35]-acc[51]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[3]+acc[19] + acc[35]+acc[51]
      sub   ecx, ebx                ; tmp2 = acc[3]+acc[19] - (acc[35]+acc[51])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[3]-acc[19] + (acc[35]-acc[51])
      sub   eax, ebp                ; tmp4 = acc[3]-acc[19] - (acc[35]-acc[51])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3], dl    ; output[0][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+4], cl    ; output[0][4] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+7*PITCH+3], bl  ; output[7][3] = tmp3
      mov   ebx, [esi-48]                 ; get acc[20]
;   -------------------------------------------------------------------------
;   4
    mov     BYTE PTR [edi+7*PITCH+4], al  ; output[7][4] = tmp4
      mov   eax, [esi-112]          ; get acc[4]
    mov     ebp, [esi+16]           ; get acc[36]
      mov   edx, [esi+80]           ; get acc[52]
    lea     ecx, [eax+ebx]          ; acc[4]+acc[20]
      sub   eax, ebx                ; acc[4]-acc[20]
    lea     ebx, [ebp+edx]          ; acc[36]+acc[52]
      sub   ebp, edx                ; acc[36]-acc[52]

    mov     edx, [edi+PITCH]        ; pre-fetch output cache line 1
      mov   edi, [edi+6*PITCH]      ; pre-fetch output cache line 6
      ;mov   esi, [edi+6*PITCH]      ; pre-fetch output cache line 6

    lea     edx, [ecx+ebx]          ; tmp1 = acc[4]+acc[20] + acc[36]+acc[52]
      sub   ecx, ebx                ; tmp2 = acc[4]+acc[20] - (acc[36]+acc[52])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[4]-acc[20] + (acc[36]-acc[52])
      sub   eax, ebp                ; tmp4 = acc[4]-acc[20] - (acc[36]-acc[52])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH], dl     ; output[1][0] = tmp1
      mov   bl,  [ebp+ebx]               ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+7], cl   ; output[1][7] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]               ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+6*PITCH], bl   ; output[6][0] = tmp3
      mov   ebx, [esi-44]                ; get acc[21]

;   -------------------------------------------------------------------------
;   5
    mov     BYTE PTR [edi+6*PITCH+7], al ; output[6][7] = tmp4
      mov   eax, [esi-108]          ; get acc[5]
    mov     ebp, [esi+20]           ; get acc[37]
      mov   edx, [esi+84]           ; get acc[53]
    lea     ecx, [eax+ebx]          ; acc[5]+acc[21]
      sub   eax, ebx                ; acc[5]-acc[21]
    lea     ebx, [ebp+edx]          ; acc[37]+acc[53]
      sub   ebp, edx                ; acc[37]-acc[53]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[5]+acc[21] + acc[37]+acc[53]
      sub   ecx, ebx                ; tmp2 = acc[5]+acc[21] - (acc[37]+acc[53])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[5]-acc[21] + (acc[37]-acc[53])
      sub   eax, ebp                ; tmp4 = acc[5]-acc[21] - (acc[37]-acc[53])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+1], dl    ; output[1][1] = tmp1
      mov   bl,  [ebp+ebx]                ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+6], cl    ; output[1][6] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]                ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+6*PITCH+1], bl  ; output[6][1] = tmp3
      mov   ebx, [esi-40]                 ; get acc[22]
;   -------------------------------------------------------------------------
;   6
    mov     BYTE PTR [edi+6*PITCH+6], al  ; output[6][6] = tmp4
      mov   eax, [esi-104]          ; get acc[6]
    mov     ebp, [esi+24]           ; get acc[38]
      mov   edx, [esi+88]           ; get acc[54]
    lea     ecx, [eax+ebx]          ; acc[6]+acc[22]
      sub   eax, ebx                ; acc[6]-acc[22]
    lea     ebx, [ebp+edx]          ; acc[38]+acc[54]
      sub   ebp, edx                ; acc[38]-acc[54]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[6]+acc[22] + acc[38]+acc[54]
      sub   ecx, ebx                ; tmp2 = acc[6]+acc[22] - (acc[38]+acc[54])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[6]-acc[22] + (acc[38]-acc[54])
      sub   eax, ebp                ; tmp4 = acc[6]-acc[22] - (acc[38]-acc[54])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+2], dl   ; output[1][2] = tmp1
      mov   bl,  [ebp+ebx]               ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+5], cl   ; output[1][5] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]               ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+6*PITCH+2], bl ; output[6][2] = tmp3
      mov   ebx, [esi-36]                ; get acc[23]
;   -------------------------------------------------------------------------
;   7
    mov     BYTE PTR [edi+6*PITCH+5], al ; output[6][5] = tmp4
      mov   eax, [esi-100]          ; get acc[7]
    mov     ebp, [esi+28]           ; get acc[39]
      mov   edx, [esi+92]           ; get acc[55]
    lea     ecx, [eax+ebx]          ; acc[7]+acc[23]
      sub   eax, ebx                ; acc[7]-acc[23]
    lea     ebx, [ebp+edx]          ; acc[39]+acc[55]
      sub   ebp, edx                ; acc[39]-acc[55]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[7]+acc[23] + acc[39]+acc[55]
      sub   ecx, ebx                ; tmp2 = acc[7]+acc[23] - (acc[39]+acc[55])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[7]-acc[23] + (acc[39]-acc[55])
      sub   eax, ebp                ; tmp4 = acc[7]-acc[23] - (acc[39]-acc[55])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+3], dl    ; output[1][3] = tmp1
      mov   bl,  [ebp+ebx]                ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+4], cl    ; output[1][4] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]                ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+6*PITCH+3], bl  ; output[6][3] = tmp3
      mov   edx, [L_LOOPCOUNTER+4]        ; fetch local loop counter
    mov     BYTE PTR [edi+6*PITCH+4], al  ; output[6][4] = tmp4
      add   edi, 2*PITCH
    add     esi, 32                       ; add 32 to esi for second pass
      mov   [L_DESTBLOCK_1+4], edi
    sub     edi, 4*PITCH
      dec   edx
    mov     [L_DESTBLOCK_2+4], edi
      jnz   loop_intra_bfly


    ret

//////////////////////////////////////////////////////////////////////
// This "subroutine" idct_bfly_inter performs the butterfly phase of
// the fmidct for inter blocks.
//
// assume parameters passed in by registers
//
//  C code:
//
// Upper Left Quadrant
// Upper Right Quadrant
// Lower Left Quadrant
// Lower Right Quadrant
//
//		lOut[0][0] = CLIP_INTER[acc[0]+acc[16] + acc[32]+acc[48]];
//		lOut[0][7] = CLIP_INTER[acc[0]+acc[16] - (acc[32]+acc[48])];
//		lOut[7][0] = CLIP_INTER[(acc[0]-acc[16]) + (acc[32]-acc[48])];
//		lOut[7][7] = CLIP_INTER[(acc[0]-acc[16]) - (acc[32]-acc[48])];
//
//		lOut[0][1] = CLIP_INTER[acc[1]+acc[17] + acc[33]+acc[49]];
//		lOut[0][6] = CLIP_INTER[acc[1]+acc[17] - (acc[33]+acc[49])];
//		lOut[7][1] = CLIP_INTER[(acc[1]-acc[17]) + (acc[33]-acc[49])];
//		lOut[7][6] = CLIP_INTER[(acc[1]-acc[17]) - (acc[33]-acc[49])];
//
//		lOut[0][2] = CLIP_INTER[acc[2]+acc[18] + acc[34]+acc[50]];
//		lOut[0][5] = CLIP_INTER[acc[2]+acc[18] - (acc[34]+acc[50])];
//		lOut[7][2] = CLIP_INTER[(acc[2]-acc[18]) + (acc[34]-acc[50])];
//		lOut[7][5] = CLIP_INTER[(acc[2]-acc[18]) - (acc[34]-acc[50])];
//
//		lOut[0][3] = CLIP_INTER[acc[3]+acc[19] + acc[35]+acc[51]];
//		lOut[0][4] = CLIP_INTER[acc[3]+acc[19] - (acc[35]+acc[51])];
//		lOut[7][3] = CLIP_INTER[(acc[3]-acc[19]) + (acc[35]-acc[51])];
//		lOut[7][4] = CLIP_INTER[(acc[3]-acc[19]) - (acc[35]-acc[51])];
//
//
//		lOut[1][0] = CLIP_INTER[acc[4]+acc[20] + acc[36]+acc[52]];
//		lOut[1][7] = CLIP_INTER[acc[4]+acc[20] - (acc[36]+acc[52])];
//		lOut[6][0] = CLIP_INTER[(acc[4]-acc[20]) + (acc[36]-acc[52])];
//		lOut[6][7] = CLIP_INTER[(acc[4]-acc[20]) - (acc[36]-acc[52])];
//
//		lOut[1][1] = CLIP_INTER[acc[5]+acc[21] + acc[37]+acc[53]];
//		lOut[1][6] = CLIP_INTER[acc[5]+acc[21] - (acc[37]+acc[53])];
//		lOut[6][1] = CLIP_INTER[(acc[5]-acc[21]) + (acc[37]-acc[53])];
//		lOut[6][6] = CLIP_INTER[(acc[5]-acc[21]) - (acc[37]-acc[53])];
//
//		lOut[1][2] = CLIP_INTER[acc[6]+acc[22] + acc[38]+acc[54]];
//		lOut[1][5] = CLIP_INTER[acc[6]+acc[22] - (acc[38]+acc[54])];
//		lOut[6][2] = CLIP_INTER[(acc[6]-acc[22]) + (acc[38]-acc[54])];
//		lOut[6][5] = CLIP_INTER[(acc[6]-acc[22]) - (acc[38]-acc[54])];
//
//		lOut[1][3] = CLIP_INTER[acc[7]+acc[23] + acc[39]+acc[55]];
//		lOut[1][4] = CLIP_INTER[acc[7]+acc[23] - (acc[39]+acc[55])];
//		lOut[6][3] = CLIP_INTER[(acc[7]-acc[23]) + (acc[39]-acc[55])];
//		lOut[6][4] = CLIP_INTER[(acc[7]-acc[23]) - (acc[39]-acc[55])];
//
//
//		lOut[2][0] = CLIP_INTER[acc[8]+acc[24] + acc[40]+acc[56]];
//		lOut[2][7] = CLIP_INTER[acc[8]+acc[24] - (acc[40]+acc[56])];
//		lOut[5][0] = CLIP_INTER[(acc[8]-acc[24]) + (acc[40]-acc[56])];
//		lOut[5][7] = CLIP_INTER[(acc[8]-acc[24]) - (acc[40]-acc[56])];
//
//		lOut[2][1] = CLIP_INTER[acc[9]+acc[25] + acc[41]+acc[57]];
//		lOut[2][6] = CLIP_INTER[acc[9]+acc[25] - (acc[41]+acc[57])];
//		lOut[5][1] = CLIP_INTER[(acc[9]-acc[25]) + (acc[41]-acc[57])];
//		lOut[5][6] = CLIP_INTER[(acc[9]-acc[25]) - (acc[41]-acc[57])];
//
//		lOut[2][2] = CLIP_INTER[acc[10]+acc[26] + acc[42]+acc[58]];
//		lOut[2][5] = CLIP_INTER[acc[10]+acc[26] - (acc[42]+acc[58])];
//		lOut[5][2] = CLIP_INTER[(acc[10]-acc[26]) + (acc[42]-acc[58])];
//		lOut[5][5] = CLIP_INTER[(acc[10]-acc[26]) - (acc[42]-acc[58])];
//
//		lOut[2][3] = CLIP_INTER[acc[11]+acc[27] + acc[43]+acc[59]];
//		lOut[2][4] = CLIP_INTER[acc[11]+acc[27] - (acc[43]+acc[59])];
//		lOut[5][3] = CLIP_INTER[(acc[11]-acc[27]) + (acc[43]-acc[59])];
//		lOut[5][4] = CLIP_INTER[(acc[11]-acc[27]) - (acc[43]-acc[59])];
//
//
//		lOut[3][0] = CLIP_INTER[acc[12]+acc[28] + acc[44]+acc[60]];
//		lOut[3][7] = CLIP_INTER[acc[12]+acc[28] - (acc[44]+acc[60])];
//		lOut[4][0] = CLIP_INTER[(acc[12]-acc[28]) + (acc[44]-acc[60])];
//		lOut[4][7] = CLIP_INTER[(acc[12]-acc[28]) - (acc[44]-acc[60])];
//
//		lOut[3][1] = CLIP_INTER[acc[13]+acc[29] + acc[45]+acc[61]];
//		lOut[3][6] = CLIP_INTER[acc[13]+acc[29] - (acc[45]+acc[61])];
//		lOut[4][1] = CLIP_INTER[(acc[13]-acc[29]) + (acc[45]-acc[61])];
//		lOut[4][6] = CLIP_INTER[(acc[13]-acc[29]) - (acc[45]-acc[61])];
//
//		lOut[3][2] = CLIP_INTER[acc[14]+acc[30] + acc[46]+acc[62]];
//		lOut[3][5] = CLIP_INTER[acc[14]+acc[30] - (acc[46]+acc[62])];
//		lOut[4][2] = CLIP_INTER[(acc[14]-acc[30]) + (acc[46]-acc[62])];
//		lOut[4][5] = CLIP_INTER[(acc[14]-acc[30]) - (acc[46]-acc[62])];
//
//		lOut[3][3] = CLIP_INTER[acc[15]+acc[31] + acc[47]+acc[63]];
//		lOut[3][4] = CLIP_INTER[acc[15]+acc[31] - (acc[47]+acc[63])];
//		lOut[4][3] = CLIP_INTER[(acc[15]-acc[31]) + (acc[47]-acc[63])];
//		lOut[4][4] = CLIP_INTER[(acc[15]-acc[31]) - (acc[47]-acc[63])];
//
////////////////////////////////////////////////////////////////////////////
//assume parameters passed in by registers

idct_bfly_inter:

;   ----------------------------------------------------------------------
;   INTER ONLY Butterfly and clamp
;   Uses all registers.
;   Uses all accumulators[64], accum
;   Uses ClipPixIntra[2048] of DWORDS, ClipPixIntra
;   Writes to Intermediate matrix [8][8] of DWORDS, Intermediate
;
;   Process 4 outputs per group, 0-15
;   0

#ifdef PTEL_WORK_AROUND
    mov     eax, [L_COEFFCOUNT+4]   ; get coefficient counter
      mov   ebx, [L_COEFFVALUE+4]   ; get coefficient value
    cmp     eax, 1                  ; compare counter with 1
      jg    Normal_Process          ;   if greater than 1 jump to normal process
    cmp     ebx, 3
      jz    Zero_Output             ; if value == 3 zero output
    cmp     ebx, -3
      jnz   Normal_Process          ; if value != -3 Process as usual

Zero_Output:
    ////////////////////////////////////////////////////////////////////////
    //  Zero out intermediate matrix [8][8] of DWORDS
    //
    //  C code:
    //
    //  for (x=0; x<8; x++)
    //    for (y=16; y<8; y++)
    //      Intermediate[x][y] = 0L;
    //

    mov     edi, [L_DESTBLOCK+4]    ; edi gets Base addr of Intermediate
      xor   eax, eax
    mov     ebx, 8
      ;

ALIGN 4
loop_for_reinit:
    mov     [edi], eax
      mov   [edi+4], eax
    mov     [edi+8], eax
      mov   [edi+12], eax
    mov     [edi+16], eax
      mov   [edi+20], eax
    mov     [edi+24], eax
      mov   [edi+28], eax
    add     edi, 32
      dec   ebx
    jnz     loop_for_reinit


    ret

Normal_Process:
#endif
    lea     esi, [L_ACCUM+128+4]    ; get addr of accum[32]
      mov   edi, [L_DESTBLOCK+4]    ; edi gets Base addr of Intermediate
    add     edi, 128
      nop
    mov     eax, [esi-128]          ; get acc[0]
      mov   ebx, [esi-64]           ; get acc[16]
    mov     ebp, [esi]              ; get acc[32]
      mov   edx, [esi+64]           ; get acc[48]
    lea     ecx, [eax+ebx]          ; acc[0]+acc[16]
      sub   eax, ebx                ; acc[0]-acc[16]
    lea     ebx, [ebp+edx]          ; acc[32]+acc[48]
      sub   ebp, edx                ; acc[32]-acc[48]

    mov     edx, [edi-128]          ; pre-fetch output cache line 0
      mov   esi, [edi+96]           ; pre-fetch output cache line 7

    lea     edx, [ecx+ebx]          ; tmp1 = acc[0]+acc[16] + acc[32]+acc[48]
      sub   ecx, ebx                ; tmp2 = acc[0]+acc[16] - (acc[32]+acc[48])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[0]-acc[16] + (acc[32]-acc[48])
      sub   eax, ebp                ; tmp4 = acc[0]-acc[16] - (acc[32]-acc[48])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-128], edx     ; Intermediate[0][0] = tmp1
      mov   ebx, [ebp+ebx*4]             ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-128+7*4], ecx ; Intermediate[0][7] = tmp2
      mov   eax, [ebp+eax*4]             ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+96], ebx      ; Intermediate[7][0] = tmp3
      mov   ebx, [esi-60]                ; get acc[17]

;   -------------------------------------------------------------------------
;   1
    mov     DWORD PTR [edi+96+7*4], eax  ; Intermediate[7][7] = tmp4
      mov   eax, [esi-124]          ; get acc[1]
    mov     ebp, [esi+4]            ; get acc[33]
      mov   edx, [esi+68]           ; get acc[49]
    lea     ecx, [eax+ebx]          ; acc[1]+acc[17]
      sub   eax, ebx                ; acc[1]-acc[17]
    lea     ebx, [ebp+edx]          ; acc[33]+acc[49]
      sub   ebp, edx                ; acc[33]-acc[49]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[1]+acc[17] + acc[33]+acc[49]
      sub   ecx, ebx                ; tmp2 = acc[1]+acc[17] - (acc[33]+acc[49])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[1]-acc[17] + (acc[33]-acc[49])
      sub   eax, ebp                ; tmp4 = acc[1]-acc[17] - (acc[33]-acc[49])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-128+1*4], edx ; Intermediate[0][1] = tmp1
      mov   ebx, [ebp+ebx*4]             ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-128+6*4], ecx ; Intermediate[0][6] = tmp2
      mov   eax, [ebp+eax*4]             ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+96+1*4], ebx  ; Intermediate[7][1] = tmp3
      mov   ebx, [esi-56]                ; get acc[18]
;   -------------------------------------------------------------------------
;   2
    mov     DWORD PTR [edi+96+6*4], eax  ; Intermediate[7][6] = tmp4
      mov   eax, [esi-120]          ; get acc[2]
    mov     ebp, [esi+8]            ; get acc[34]
      mov   edx, [esi+72]           ; get acc[50]
    lea     ecx, [eax+ebx]          ; acc[2]+acc[18]
      sub   eax, ebx                ; acc[2]-acc[18]
    lea     ebx, [ebp+edx]          ; acc[34]+acc[50]
      sub   ebp, edx                ; acc[34]-acc[50]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[2]+acc[18] + acc[34]+acc[50]
      sub   ecx, ebx                ; tmp2 = acc[2]+acc[18] - (acc[34]+acc[50])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[2]-acc[18] + (acc[34]-acc[50])
      sub   eax, ebp                ; tmp4 = acc[2]-acc[18] - (acc[34]-acc[50])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-128+2*4], edx ; Intermediate[0][2] = tmp1
      mov   ebx, [ebp+ebx*4]             ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-128+5*4], ecx ; Intermediate[0][5] = tmp2
      mov   eax, [ebp+eax*4]             ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+96+2*4], ebx  ; Intermediate[7][2] = tmp3
      mov   ebx, [esi-52]                ; get acc[19]
;   -------------------------------------------------------------------------
;   3
    mov     DWORD PTR [edi+96+5*4], eax  ; Intermediate[7][5] = tmp4
      mov   eax, [esi-116]          ; get acc[3]
    mov     ebp, [esi+12]           ; get acc[35]
      mov   edx, [esi+76]           ; get acc[51]
    lea     ecx, [eax+ebx]          ; acc[3]+acc[19]
      sub   eax, ebx                ; acc[3]-acc[19]
    lea     ebx, [ebp+edx]          ; acc[35]+acc[51]
      sub   ebp, edx                ; acc[35]-acc[51]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[3]+acc[19] + acc[35]+acc[51]
      sub   ecx, ebx                ; tmp2 = acc[3]+acc[19] - (acc[35]+acc[51])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[3]-acc[19] + (acc[35]-acc[51])
      sub   eax, ebp                ; tmp4 = acc[3]-acc[19] - (acc[35]-acc[51])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-128+3*4], edx ; Intermediate[0][3] = tmp1
      mov   ebx, [ebp+ebx*4]             ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-128+4*4], ecx ; Intermediate[0][4] = tmp2
      mov   eax, [ebp+eax*4]             ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+96+3*4], ebx  ; Intermediate[7][3] = tmp3
      mov   ebx, [esi-48]                ; get acc[20]
;   -------------------------------------------------------------------------
;   4
    mov     DWORD PTR [edi+96+4*4], eax  ; Intermediate[7][4] = tmp4
      mov   eax, [esi-112]          ; get acc[4]
    mov     ebp, [esi+16]           ; get acc[36]
      mov   edx, [esi+80]           ; get acc[52]
    lea     ecx, [eax+ebx]          ; acc[4]+acc[20]
      sub   eax, ebx                ; acc[4]-acc[20]
    lea     ebx, [ebp+edx]          ; acc[36]+acc[52]
      sub   ebp, edx                ; acc[36]-acc[52]

    mov     edx, [edi-96]           ; pre-fetch output cache line 1
      mov   esi, [edi+64]           ; pre-fetch output cache line 6

    lea     edx, [ecx+ebx]          ; tmp1 = acc[4]+acc[20] + acc[36]+acc[52]
      sub   ecx, ebx                ; tmp2 = acc[4]+acc[20] - (acc[36]+acc[52])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[4]-acc[20] + (acc[36]-acc[52])
      sub   eax, ebp                ; tmp4 = acc[4]-acc[20] - (acc[36]-acc[52])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-96], edx     ; Intermediate[1][0] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-96+7*4], ecx ; Intermediate[1][7] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+64], ebx     ; Intermediate[6][0] = tmp3
      mov   ebx, [esi-44]               ; get acc[21]

;   -------------------------------------------------------------------------
;   5
    mov     DWORD PTR [edi+64+7*4], eax ; Intermediate[6][7] = tmp4
      mov   eax, [esi-108]          ; get acc[5]
    mov     ebp, [esi+20]           ; get acc[37]
      mov   edx, [esi+84]           ; get acc[53]
    lea     ecx, [eax+ebx]          ; acc[5]+acc[21]
      sub   eax, ebx                ; acc[5]-acc[21]
    lea     ebx, [ebp+edx]          ; acc[37]+acc[53]
      sub   ebp, edx                ; acc[37]-acc[53]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[5]+acc[21] + acc[37]+acc[53]
      sub   ecx, ebx                ; tmp2 = acc[5]+acc[21] - (acc[37]+acc[53])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[5]-acc[21] + (acc[37]-acc[53])
      sub   eax, ebp                ; tmp4 = acc[5]-acc[21] - (acc[37]-acc[53])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-96+1*4], edx   ; Intermediate[1][1] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-96+6*4], ecx   ; Intermediate[1][6] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+64+1*4], ebx   ; Intermediate[6][1] = tmp3
      mov   ebx, [esi-40]                 ; get acc[22]
;   -------------------------------------------------------------------------
;   6
    mov     DWORD PTR [edi+64+6*4], eax   ; Intermediate[6][6] = tmp4
      mov   eax, [esi-104]          ; get acc[6]
    mov     ebp, [esi+24]           ; get acc[38]
      mov   edx, [esi+88]           ; get acc[54]
    lea     ecx, [eax+ebx]          ; acc[6]+acc[22]
      sub   eax, ebx                ; acc[6]-acc[22]
    lea     ebx, [ebp+edx]          ; acc[38]+acc[54]
      sub   ebp, edx                ; acc[38]-acc[54]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[6]+acc[22] + acc[38]+acc[54]
      sub   ecx, ebx                ; tmp2 = acc[6]+acc[22] - (acc[38]+acc[54])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[6]-acc[22] + (acc[38]-acc[54])
      sub   eax, ebp                ; tmp4 = acc[6]-acc[22] - (acc[38]-acc[54])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-96+2*4], edx   ; Intermediate[1][2] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-96+5*4], ecx   ; Intermediate[1][5] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+64+2*4], ebx   ; Intermediate[6][2] = tmp3
      mov   ebx, [esi-36]                 ; get acc[23]
;   -------------------------------------------------------------------------
;   7
    mov     DWORD PTR [edi+64+5*4], eax   ; Intermediate[6][5] = tmp4
      mov   eax, [esi-100]          ; get acc[7]
    mov     ebp, [esi+28]           ; get acc[39]
      mov   edx, [esi+92]           ; get acc[55]
    lea     ecx, [eax+ebx]          ; acc[7]+acc[23]
      sub   eax, ebx                ; acc[7]-acc[23]
    lea     ebx, [ebp+edx]          ; acc[39]+acc[55]
      sub   ebp, edx                ; acc[39]-acc[55]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[7]+acc[23] + acc[39]+acc[55]
      sub   ecx, ebx                ; tmp2 = acc[7]+acc[23] - (acc[39]+acc[55])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[7]-acc[23] + (acc[39]-acc[55])
      sub   eax, ebp                ; tmp4 = acc[7]-acc[23] - (acc[39]-acc[55])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-96+3*4], edx   ; Intermediate[1][3] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-96+4*4], ecx   ; Intermediate[1][4] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+64+3*4], ebx   ; Intermediate[6][3] = tmp3
      mov   ebx, [esi-32]                 ; get acc[24]
;   -------------------------------------------------------------------------
;   8
    mov     DWORD PTR [edi+64+4*4], eax   ; Intermediate[6][4] = tmp4
      mov   eax, [esi-96]           ; get acc[8]
    mov     ebp, [esi+32]           ; get acc[40]
      mov   edx, [esi+96]           ; get acc[56]
    lea     ecx, [eax+ebx]          ; acc[8]+acc[24]
      sub   eax, ebx                ; acc[8]-acc[24]
    lea     ebx, [ebp+edx]          ; acc[40]+acc[56]
      sub   ebp, edx                ; acc[40]-acc[56]

    mov     edx, [edi-64]           ; pre-fetch output cache line 2
      mov   esi, [edi+32]           ; pre-fetch output cache line 5

    lea     edx, [ecx+ebx]          ; tmp1 = acc[8]+acc[24] + acc[40]+acc[56]
      sub   ecx, ebx                ; tmp2 = acc[8]+acc[24] - (acc[40]+acc[56])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[8]-acc[24] + (acc[40]-acc[56])
      sub   eax, ebp                ; tmp4 = acc[8]-acc[24] - (acc[40]-acc[56])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      lea   esi, [L_ACCUM+128+4]        ; get addr of accum[32]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-64], edx       ; Intermediate[2][0] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-64+7*4], ecx   ; Intermediate[2][7] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+32], ebx       ; Intermediate[5][0] = tmp3
      mov   ebx, [esi-28]                 ; get acc[25]

;   -------------------------------------------------------------------------
;   9
    mov     DWORD PTR [edi+32+7*4], eax   ; Intermediate[5][7] = tmp4
      mov   eax, [esi-92]           ; get acc[9]
    mov     ebp, [esi+36]           ; get acc[41]
      mov   edx, [esi+100]          ; get acc[57]
    lea     ecx, [eax+ebx]          ; acc[9]+acc[25]
      sub   eax, ebx                ; acc[9]-acc[25]
    lea     ebx, [ebp+edx]          ; acc[41]+acc[57]
      sub   ebp, edx                ; acc[41]-acc[57]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[9]+acc[25] + acc[41]+acc[57]
      sub   ecx, ebx                ; tmp2 = acc[9]+acc[25] - (acc[41]+acc[57])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[9]-acc[25] + (acc[41]-acc[57])
      sub   eax, ebp                ; tmp4 = acc[9]-acc[25] - (acc[41]-acc[57])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-64+1*4], edx   ; Intermediate[2][1] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-64+6*4], ecx   ; Intermediate[2][6] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+32+1*4], ebx   ; Intermediate[5][1] = tmp3
      mov   ebx, [esi-24]                 ; get acc[26]
;   -------------------------------------------------------------------------
;   10
    mov     DWORD PTR [edi+32+6*4], eax   ; Intermediate[5][6] = tmp4
      mov   eax, [esi-88]           ; get acc[10]
    mov     ebp, [esi+40]           ; get acc[42]
      mov   edx, [esi+104]          ; get acc[58]
    lea     ecx, [eax+ebx]          ; acc[10]+acc[26]
      sub   eax, ebx                ; acc[10]-acc[26]
    lea     ebx, [ebp+edx]          ; acc[42]+acc[58]
      sub   ebp, edx                ; acc[42]-acc[58]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[10]+acc[26] + acc[42]+acc[58]
      sub   ecx, ebx                ; tmp2 = acc[10]+acc[26] - (acc[42]+acc[58])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[10]-acc[26] + (acc[42]-acc[58])
      sub   eax, ebp                ; tmp4 = acc[10]-acc[26] - (acc[42]-acc[58])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
       nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-64+2*4], edx   ; Intermediate[2][2] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-64+5*4], ecx   ; Intermediate[2][5] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+32+2*4], ebx   ; Intermediate[5][2] = tmp3
      mov   ebx, [esi-20]                 ; get acc[27]
;   -------------------------------------------------------------------------
;   11
    mov     DWORD PTR [edi+32+5*4], eax   ; Intermediate[5][5] = tmp4
      mov   eax, [esi-84]           ; get acc[11]
    mov     ebp, [esi+44]           ; get acc[43]
      mov   edx, [esi+108]          ; get acc[59]
    lea     ecx, [eax+ebx]          ; acc[11]+acc[27]
      sub   eax, ebx                ; acc[11]-acc[27]
    lea     ebx, [ebp+edx]          ; acc[43]+acc[59]
      sub   ebp, edx                ; acc[43]-acc[59]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[11]+acc[27] + acc[43]+acc[59]
      sub   ecx, ebx                ; tmp2 = acc[11]+acc[27] - (acc[43]+acc[59])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[11]-acc[27] + (acc[43]-acc[59])
      sub   eax, ebp                ; tmp4 = acc[11]-acc[27] - (acc[43]-acc[59])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-64+3*4], edx   ; Intermediate[2][3] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-64+4*4], ecx   ; Intermediate[2][4] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+32+3*4], ebx   ; Intermediate[5][3] = tmp3
      mov   ebx, [esi-16]                 ; get acc[28]
;   -------------------------------------------------------------------------
;   12
    mov     DWORD PTR [edi+32+4*4], eax   ; Intermediate[5][4] = tmp4
      mov   eax, [esi-80]           ; get acc[12]
    mov     ebp, [esi+48]           ; get acc[44]
      mov   edx, [esi+112]          ; get acc[60]
    lea     ecx, [eax+ebx]          ; acc[12]+acc[28]
      sub   eax, ebx                ; acc[12]-acc[28]
    lea     ebx, [ebp+edx]          ; acc[44]+acc[60]
      sub   ebp, edx                ; acc[44]-acc[60]

    mov     edx, [edi-32]           ; pre-fetch output cache line 3
      mov   esi, [edi]              ; pre-fetch output cache line 4

    lea     edx, [ecx+ebx]          ; tmp1 = acc[12]+acc[28] + acc[44]+acc[60]
      sub   ecx, ebx                ; tmp2 = acc[12]+acc[28] - (acc[44]+acc[60])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[12]-acc[28] + (acc[44]-acc[60])
      sub   eax, ebp                ; tmp4 = acc[12]-acc[28] - (acc[44]-acc[60])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-32], edx     ; Intermediate[3][0] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-32+7*4], ecx ; Intermediate[3][7] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi], ebx        ; Intermediate[4][0] = tmp3
      mov   ebx, [esi-12]               ; get acc[29]

;   -------------------------------------------------------------------------
;   13
    mov     DWORD PTR [edi+7*4], eax    ; Intermediate[4][7] = tmp4
      mov   eax, [esi-76]           ; get acc[13]
    mov     ebp, [esi+52]           ; get acc[45]
      mov   edx, [esi+116]          ; get acc[61]
    lea     ecx, [eax+ebx]          ; acc[13]+acc[29]
      sub   eax, ebx                ; acc[13]-acc[29]
    lea     ebx, [ebp+edx]          ; acc[45]+acc[61]
      sub   ebp, edx                ; acc[45]-acc[61]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[13]+acc[29] + acc[45]+acc[61]
      sub   ecx, ebx                ; tmp2 = acc[13]+acc[29] - (acc[45]+acc[61])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[13]-acc[29] + (acc[45]-acc[61])
      sub   eax, ebp                ; tmp4 = acc[13]-acc[29] - (acc[45]-acc[61])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-32+1*4], edx ; Intermediate[3][1] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-32+6*4], ecx ; Intermediate[3][6] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+1*4], ebx    ; Intermediate[4][1] = tmp3
      mov   ebx, [esi-8]                ; get acc[30]
;   -------------------------------------------------------------------------
;   14
    mov     DWORD PTR [edi+6*4], eax    ; Intermediate[4][6] = tmp4
      mov   eax, [esi-72]           ; get acc[14]
    mov     ebp, [esi+56]           ; get acc[46]
      mov   edx, [esi+120]          ; get acc[62]
    lea     ecx, [eax+ebx]          ; acc[14]+acc[30]
      sub   eax, ebx                ; acc[14]-acc[30]
    lea     ebx, [ebp+edx]          ; acc[46]+acc[62]
      sub   ebp, edx                ; acc[46]-acc[62]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[14]+acc[30] + acc[46]+acc[62]
      sub   ecx, ebx                ; tmp2 = acc[14]+acc[30] - (acc[46]+acc[62])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[14]-acc[30] + (acc[46]-acc[62])
      sub   eax, ebp                ; tmp4 = acc[14]-acc[30] - (acc[46]-acc[62])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-32+2*4], edx ; Intermediate[3][2] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-32+5*4], ecx ; Intermediate[3][5] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+2*4], ebx    ; Intermediate[4][2] = tmp3
      mov   ebx, [esi-4]                ; get acc[31]
;   -------------------------------------------------------------------------
;   15
    mov     DWORD PTR [edi+5*4], eax    ; Intermediate[4][5] = tmp4
      mov   eax, [esi-68]           ; get acc[15]
    mov     ebp, [esi+60]           ; get acc[47]
      mov   edx, [esi+124]          ; get acc[63]
    lea     ecx, [eax+ebx]          ; acc[15]+acc[31]
      sub   eax, ebx                ; acc[15]-acc[31]
    lea     ebx, [ebp+edx]          ; acc[47]+acc[63]
      sub   ebp, edx                ; acc[47]-acc[63]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[15]+acc[31] + acc[47]+acc[63]
      sub   ecx, ebx                ; tmp2 = acc[15]+acc[31] - (acc[47]+acc[63])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[15]-acc[31] + (acc[47]-acc[63])
      sub   eax, ebp                ; tmp4 = acc[15]-acc[31] - (acc[47]-acc[63])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-32+3*4], edx ; Intermediate[3][3] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-32+4*4], ecx ; Intermediate[3][4] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+3*4], ebx    ; Intermediate[4][3] = tmp3
      mov   DWORD PTR [edi+4*4], eax    ; Intermediate[4][4] = tmp4
    ret
	} //end of asm
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1mblk.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * d1mblk.cpp
 *
 * DESCRIPTION:
 *		Decoder macro block functions
 *
 * Routines:						Prototypes in:
 *  	H263DecodeMBHeader			d1dec.h
 *      H263DecodeMBData			d1dec.h	
 */

// $Header:   S:\h26x\src\dec\d1mblk.cpv   1.23   20 Dec 1996 16:58:06   RHAZRA  $
// $Log:   S:\h26x\src\dec\d1mblk.cpv  $
// 
//    Rev 1.23   20 Dec 1996 16:58:06   RHAZRA
// Fixed bitstream docoding for the case where MB stuffing is inserted
// between MBs. This was identified by a PTEL bitstream. This fix needs
// to be verified with our other tests.
// 
//    Rev 1.22   16 Dec 1996 14:41:46   RHAZRA
// 
// Changed a bitstream error ASSERT to a bonafide error
// 
//    Rev 1.21   18 Nov 1996 17:12:22   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.20   07 Nov 1996 15:44:08   SCDAY
// 
// Added MMX_ClipAndScale to replace Raj's glue code
// 
//    Rev 1.19   04 Nov 1996 10:28:10   RHAZRA
// Changed the IDCT scaling table to be a DWORD table (with rounding
// factored in) that is declared as a static.
// 
//    Rev 1.18   31 Oct 1996 08:58:28   SCDAY
// Raj added support for MMX decoder
// 
//    Rev 1.17   26 Sep 1996 12:35:06   RHAZRA
// Forced the decoder to use the IA version of VLD_RLD_IQ routine even
// when MMX is on (since we don't have a corresponding MMX routine ... yet)
// 
//    Rev 1.16   05 Aug 1996 11:00:26   MBODART
// 
// H.261 decoder rearchitecture:
// Files changed:  d1gob.cpp, d1mblk.{cpp,h}, d1dec.{cpp,h},
//                 filelist.261, h261_32.mak
// New files:      d1bvriq.cpp, d1idct.cpp
// Obsolete files: d1block.cpp
// Work still to be done:
//   Update h261_mf.mak
//   Optimize uv pairing in d1bvriq.cpp and d1idct.cpp
//   Fix checksum code (it doesn't work now)
//   Put back in decoder stats
// 
//    Rev 1.15   18 Mar 1996 17:02:12   AKASAI
// 
// Added pragma code_seg("IACODE2") and changed the timing statistics.
// At one point changed GET_VAR_BITS into subroutine to save code
// space but it didn't so left it as a macro.
// 
//    Rev 1.14   26 Dec 1995 17:42:14   DBRUCKS
// changed bTimerIsOn to bTimingThisFrame
// 
//    Rev 1.13   26 Dec 1995 12:50:00   DBRUCKS
// 
// fix copyright
// add timing code
// comment out define of DEBUG_MBLK
// 
//    Rev 1.12   05 Dec 1995 10:19:46   SCDAY
// 
// Added assembler version of Spatial Loop Filter
// 
//    Rev 1.11   03 Nov 1995 11:44:30   AKASAI
// 
// Changed the processing of MB checksum and MBA stuffing.  Changed 
// GET_VAR_BITS & GET_GT8_BITS for how to detect MBA stuffing code.
// 
//    Rev 1.10   01 Nov 1995 13:43:48   AKASAI
// 
// Added support for loop filter.  New routines call LpFilter,
// BlockAddSpecial and BlockCopySpecial.
// 
//    Rev 1.9   27 Oct 1995 18:17:20   AKASAI
// 
// Put in fix "hack" to keep the block action stream pointers
// in sync between d1dec and d1mblk.  With skip macro blocks some
// macroblocks were being processed multiple times.  Still a problem
// when gob ends with a skip macroblock.
// 
//    Rev 1.8   26 Oct 1995 15:36:28   SCDAY
// 
// Delta frames partially working -- changed main loops to accommodate
// skipped macroblocks by detecting next startcode
// 
//    Rev 1.7   17 Oct 1995 11:28:56   SCDAY
// Added error message if (MBA stuffing code found && Checksum not enabled)
// 
//    Rev 1.6   16 Oct 1995 16:28:02   AKASAI
// Fixed bug when CHECKSUM_MACRO_BLOCK_DETAIL & CHECKSUM_MACRO_BLOCK are
// both defined.
// 
//    Rev 1.5   16 Oct 1995 13:53:24   SCDAY
// 
// Added macroblock level checksum
// 
//    Rev 1.4   06 Oct 1995 15:32:54   SCDAY
// 
// Integrated with latest AKK d1block
// 
//    Rev 1.3   22 Sep 1995 14:48:46   SCDAY
// 
// added more mblock header and data decoding
// 
//    Rev 1.2   20 Sep 1995 09:52:22   SCDAY
// 
// eliminated a warning
// 
//    Rev 1.1   19 Sep 1995 15:24:10   SCDAY
// 
// added H261 MBA parsing
// 
//    Rev 1.0   11 Sep 1995 13:51:52   SCDAY
// Initial revision.
// 
//    Rev 1.11   25 Aug 1995 09:16:32   DBRUCKS
// add ifdef DEBUG_MBLK
// 
//    Rev 1.10   23 Aug 1995 19:12:02   AKASAI
// Fixed gNewTAB_CBPY table building.  Was using 8 as mask instead of 0xf.
// 
//    Rev 1.9   18 Aug 1995 15:03:22   CZHU
// 
// Output more error message when DecodeBlock returns error.
// 
//    Rev 1.8   16 Aug 1995 14:26:54   CZHU
// 
// Changed DWORD adjustment back to byte oriented reading.
// 
//    Rev 1.7   15 Aug 1995 09:54:18   DBRUCKS
// improve stuffing handling and add debug msg
// 
//    Rev 1.6   14 Aug 1995 18:00:40   DBRUCKS
// add chroma parsing
// 
//    Rev 1.5   11 Aug 1995 17:47:58   DBRUCKS
// cleanup
// 
//    Rev 1.4   11 Aug 1995 16:12:28   DBRUCKS
// add ptr check to MB data
// 
//    Rev 1.3   11 Aug 1995 15:10:58   DBRUCKS
// finish INTRA mb header parsing and callblock
// 
//    Rev 1.2   03 Aug 1995 14:30:26   CZHU
// Take block level operations out to d3block.cpp
// 
//    Rev 1.1   02 Aug 1995 10:21:12   CZHU
// Added asm codes for VLD of TCOEFF, inverse quantization, run-length decode.
// 
//    Rev 1.0   31 Jul 1995 13:00:08   DBRUCKS
// Initial revision.
// 
//    Rev 1.2   31 Jul 1995 11:45:42   CZHU
// changed the parameter list
// 
//    Rev 1.1   28 Jul 1995 16:25:52   CZHU
// 
// Added per block decoding framework.
// 
//    Rev 1.0   28 Jul 1995 15:20:16   CZHU
// Initial revision.

//Block level decoding for H.26x decoder

#include "precomp.h"            // rearch idct

/*****************************************************************************
 *
 *  GET_VAR_BITS
 *
 *  Read a variable number of bits using a lookup table.	
 *
 *  The input count should be the number of bits used to index the table.  
 *  The output count is the number of bits in that symbol.
 *
 *  The table should be initialized such that all don't care symbols match to 
 *  the same value.  Thus if the table is indexed by 6-bits a two bit symbol 
 *  01XX XX will be used to initialize all entries 0100 00 -> 0111 11.  These
 *  entries will include an 8-bit length in the least significant byte.
 *
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 *    uCode - OUT
 *    fpTable - IN
 */

#define GET_VAR_BITS(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpTable) {						\
	while (uBitsReady < uCount) {			\
		uWork <<= 8;				\
		uBitsReady += 8;			\
		uWork |= *fpu8++;			\
	}						\
	/* calculate how much to shift off */		\
	/* and get the code */				\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);			\
	/* read the data */				\
	uResult = fpTable[uCode];			\
	/* count of bits used */   			\
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */		\
/* H.261 tables are reverse order from H.263 */		\
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */		\
	uBitCount = uResult & 0xff00;			\
	uBitCount >>= 8;				\
	/* bits remaining */				\
	uBitsReady = uBitsReady - uBitCount;		\
	/* special case for stuffing processing */ 	\
	/* if (uBitsReady < 0)                  */	\
	/*    kluged to test for negative       */	\
	if (uBitsReady > 33) 				\
/*	if (bStuffing)	*/					\
	{						\
		uWork <<= 8;				\
		uBitsReady += 8;			\
		uWork |= *fpu8++;			\
	}						\
	/* end special case for stuffing        */ 	\
	uWork &= GetBitsMask[uBitsReady];		\
}

#define GET_GT8_BITS(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpTable) {						\
	while (uBitsReady < uCount) {			\
		uWork <<= 8;				\
		uBitsReady += 8;			\
		uWork |= *fpu8++;			\
	}						\
	/* calculate how much to shift off */		\
	/* and get the code */				\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);			\
	/* read the data */				\
	uResult = fpTable[uCode];			\
	/* count of bits used */   			\
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */		\
/* H.261 tables are reverse order from H.263 */		\
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */		\
	uBitCount = uResult & 0xff00;			\
	if ((uBitCount & 0x8000) == 0) /* if not negative */	\
	{						\
		uBitCount >>= 8;			\
		/* bits remaining */			\
		uBitsReady = uBitsReady - uBitCount;	\
		/* special case for stuffing processing */	\
		/* if (uBitsReady < 0)                  */	\
		/*    kluged to test for negative       */	\
		if (uBitsReady > 33) 				\
/*		if (bStuffing)	*/					\
		{						\
			uWork <<= 8;				\
			uBitsReady += 8;			\
			uWork |= *fpu8++;			\
		}						\
		/* end special case for stuffing        */ 	\
		uWork &= GetBitsMask[uBitsReady];		\
	}							\
	else							\
		uWork &= GetBitsMask[uBitsReady-8];		\
}

extern void BlockCopy(
            U32 uDstBlock, 
            U32 uSrcBlock);

extern void BlockCopySpecial(
            U32 uDstBlock, 
            U32 uSrcBlock);

extern void BlockAdd (
            U32 uResidual, 
            U32 uRefBlock,
            U32 uDstBlock);

extern void BlockAddSpecial (
            U32 uResidual, 
            U32 uRefBlock,
            U32 uDstBlock);

T_pFunc_VLD_RLD_IQ_Block pFunc_VLD_RLD_IQ_Block[2] = {VLD_RLD_IQ_Block,VLD_RLD_IQ_Block};  // New rearch
//T_pFunc_VLD_RLD_IQ_Block pFunc_VLD_RLD_IQ_Block[2] = {VLD_RLD_IQ_Block, MMX_VLD_RLD_IQ_Block};  // New rearch

/*****************************************************************************
 *
 *  H263DecodeMBHeader
 *
 *  Decode the MB header
 */
#pragma code_seg("IACODE1")
I32 H263DecodeMBHeader(
	T_H263DecoderCatalog FAR * DC, 
	BITSTREAM_STATE FAR * fpbsState, 
	U32 * uReadChecksum)
{
	I32 iReturn = ICERR_ERROR;
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	U32 uResult;
	U32 uCode;
	U32 uBitCount;
	int bStuffing;

#define START_CODE 0xff18
#define STUFFING_CODE 0x0b22
//#define DEBUG_MBLK  -- Turn this on with a define in the makefile.

#ifndef RING0
#ifdef DEBUG_MBLK
	char buf120[120];
	int iLength;
#endif
#endif

	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
/* MBA --------------- */
/* ********************************************* */
/* minor table decode (>8 bits) not fully tested */
/* to do note:                                   */
/* this is hacked                                */
/* change >8 bit processing to use major/minor   */
/*   tables and ONE GET_BITS routine             */
/* ********************************************* */
		
ReadMBA:	
	bStuffing = 0;
	GET_GT8_BITS(8, fpu8, uWork, uBitsReady, uResult, 
			uCode, uBitCount, gTAB_MBA_MAJOR);

		if (uResult == STUFFING_CODE)
		{ 	/* is stuffing code */
			bStuffing = 1;
/* do MB checksum stuff here */
#ifdef CHECKSUM_MACRO_BLOCK
GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
/* might want to move this to a separate function for readability */
GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
if (uResult == 1)
{
GET_FIXED_BITS(8, fpu8, uWork, uBitsReady, uResult);
if (uResult == 1)
{ /* indicates TCOEFF checksum processing */
	/* read off all but the real checksum data */
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);	
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);

	/* now get real checksum data */
	/* run */
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	*uReadChecksum = ((uResult & 0xff) << 24);
	/* level */
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	*uReadChecksum = (*uReadChecksum | ((uResult & 0xff) << 16)); 
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	*uReadChecksum = (*uReadChecksum | ((uResult & 0xff) << 8)); 
	/* sign */
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	*uReadChecksum = (*uReadChecksum | (uResult & 0xff));
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
}
 else
{
	DBOUT("ERROR :: H261MBChecksum :: Invalid Checksum Data :: ERROR");
	iReturn = ICERR_ERROR;
	goto done;
}
}
else
{
	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	goto ReadMBA;
}

#else	/* is MBA stuffing, but checksum not enabled */
GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)

// GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
/*if (uResult == 1) {
	DbgLog((LOG_ERROR, HDBG_ALWAYS, TEXT("ERROR :: Stuffing code found, Checksum not enabled :: ERROR")));
	iReturn = ICERR_ERROR;
	goto done;
} */
// if (uResult == 1)
// {
//    GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
    
// }
// else {
	//GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
// }
#endif
		} /* end if (uResult == STUFFING_CODE) */
		/* try this for now */
		else
		{
		if (uResult == START_CODE)
		{
			I8 temp;
			temp = (I8)(uResult & 0xff);
			GET_VAR_BITS(16, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, (gTAB_MBA_MINOR + temp));
			if (uResult != 0x1023)
			{
				DBOUT("ERROR :: Invalid startcode :: ERROR");
				iReturn = ICERR_ERROR;
			}
			else
				iReturn = START_CODE;
			
			GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
			goto done;
		} /* end if (uResult == START_CODE) */
		else /* is not stuffing */
		{ 	/* if uResult negative, get more bits */
			if (uResult & 0x8000)
			{
				I8 temp;
				temp = (I8)(uResult & 0xff);
				GET_VAR_BITS(11, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, (gTAB_MBA_MINOR + temp));
			}
			DC->uMBA = (uResult & 0xff);
		}/* end else is not stuffing */
		}
 			
/* When MBA==Stuffing, we jump back to the start to look for MBA */

	if (bStuffing)
		goto ReadMBA;


/* MTYPE ---------------------------------------- */
	GET_GT8_BITS(8, fpu8, uWork, uBitsReady, uResult, 
			uCode, uBitCount, gTAB_MTYPE_MAJOR);
		if (uResult & 0x8000)
		{
			I8 temp;
			temp = (I8)(uResult & 0xff);
			GET_VAR_BITS(10, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, (gTAB_MTYPE_MINOR + temp));
		}
		DC->uMBType = (uResult & 0xff);

/* MQUANT ---------------------------------------- */
	if (DC->uMBType == 1 || DC->uMBType == 3 || DC->uMBType == 6 || DC->uMBType == 9)
	{ /* get 5-bit MQuant */
		GET_FIXED_BITS(5, fpu8, uWork, uBitsReady, uResult);
		DC->uMQuant = (uResult & 0xff);
	}

/* MVD ------------------------------------------- */
/* reset previous motion vectors                   */
/*    if MB 0,11,22                                */
/*    if MBA != 1 or                               */
/*    if previous MB was not MC                    */

	if (DC->uMBType >3)
	{
		if ((DC->uMBA != 1) || (DC->i16LastMBA == 10) || (DC->i16LastMBA == 21))
			DC->i8MVDH = DC->i8MVDV = 0;
		/* get X motion vector */
		GET_GT8_BITS(8, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, gTAB_MVD_MAJOR);
		if (uResult & 0x8000)
		{
			I8 temp;
			temp = (I8)(uResult & 0xff);
			GET_VAR_BITS(11, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, (gTAB_MVD_MINOR + temp));
		}
		/* convert and make incremental */
		DC->i8MVDH = gTAB_MV_ADJUST[DC->i8MVDH + (I8)(uResult & 0xff) + 32];
		/* get Y motion vector */
		GET_GT8_BITS(8, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, gTAB_MVD_MAJOR);
		if (uResult & 0x8000)
		{
			I8 temp;
			temp = (I8)(uResult & 0xff);
			GET_VAR_BITS(11, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, (gTAB_MVD_MINOR + temp));
		}
		/* convert and make incremental */
		DC->i8MVDV = gTAB_MV_ADJUST[DC->i8MVDV + (I8)(uResult & 0xff) + 32];
	} /* end if (DC->MBType > 3) */
	else 
		DC->i8MVDH = DC->i8MVDV = 0;
	
/* CBP --------------------------------------------- */
	/* brute force method */
	DC->uCBP = 0;		/* for MType = 4 or 7 */
	if (DC->uMBType == 2 || DC->uMBType == 3 || DC->uMBType == 5 || DC->uMBType == 6 || DC->uMBType == 8 || DC->uMBType == 9)
	{ /* get CBP */
		GET_VAR_BITS(9, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, gTAB_CBP);
		DC->uCBP = (uResult & 0xff);
	} /* end get CBP */
	else
		if (DC->uMBType < 2)	/* is intra */
			DC->uCBP = 63;		/* force CBP to 63 */	
		
	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
	iReturn = ICERR_OK;

#ifndef RING0
#ifdef DEBUG_MBLK 
	iLength = wsprintf(buf120, "MBType=%ld MQuant=%ld MVDH=%ld MVDV=%ld CBP=%ld",
					   DC->uMBType,
					   DC->uMQuant,
					   DC->i8MVDH,
					   DC->i8MVDV,
					   DC->uCBP);
	DBOUT(buf120);
	ASSERT(iLength < 120);
#endif
#endif

done:
	return iReturn;
} /* end H263DecodeMBHeader() */

#pragma code_seg()
/*****************************************************************************
 *
 *  H263DecodeMBData
 *
 *  Decode each of the blocks in this macro block
 */
#pragma code_seg("IACODE1")
I32 H263DecodeMBData(
	T_H263DecoderCatalog FAR * DC,
	T_BlkAction FAR * fpBlockAction, 
	I32 iBlockNumber,
	BITSTREAM_STATE FAR * fpbsState,
	U8 FAR * fpu8MaxPtr, 
	U32 * uReadChecksum,
	U32 **pN,                         // New rearch
	T_IQ_INDEX ** pRUN_INVERSE_Q)     // New rearch
{

	I32 iResult = ICERR_ERROR;
	int iCBP = (int) DC->uCBP; 
 	int i;
	U32 uBitsReady;
	U32 uBitsReadIn;
	U32 uBitsReadOut;
	U8  u8Quant;		/* quantization level for this block */
 	U8  FAR * fpu8;
	U32 uByteCnt;
	I8 mvx, mvy, mvx2, mvy2;

    T_pFunc_VLD_RLD_IQ_Block pFunc_VLD =pFunc_VLD_RLD_IQ_Block[0];
	
	U32 uCheckSum;		/* checksum data returned from DecodeBlock */
#ifdef CHECKSUM_MACRO_BLOCK_DETAIL
char buf80[80];
int iMBDLength;
#endif

#ifdef CHECKSUM_MACRO_BLOCK
	char buff80[80];
	int iLength;
#endif

	#ifdef DECODE_STATS
	U32 uStartLow = DC->uStartLow;
	U32 uStartHigh = DC->uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uDecodeBlockSum = 0;
	U32 uLoopFilterSum = 0;
	U32 uBlockCopySum = 0;
	U32 uBlockCopySpSum = 0;
	U32 uBlockAddSum = 0;
	U32 uBlockAddSpSum = 0;
	int bTimingThisFrame = DC->bTimingThisFrame;
	DEC_TIMING_INFO * pDecTimingInfo = NULL;
	#endif

	/* On input the pointer points to the next byte.     */
	/* We need to change it to                           */
	/* point to the current word on a 32-bit boundary.   */  
 
	fpu8 = fpbsState->fpu8 - 1;	/* point to the current byte */
	uBitsReady = fpbsState->uBitsReady;
	while (uBitsReady >= 8) {
		fpu8--;
		uBitsReady -= 8;
	}
	uBitsReadIn = 8 - uBitsReady;
		
	u8Quant = (U8) (DC->uMQuant);

	if (DC->uMBType > 1)
	{
		/* calculate motion vectors */
		mvx = DC->i8MVDH;
		mvy = DC->i8MVDV;
		// calculate UV blocks MV
		mvx2 = mvx / 2;
		mvy2 = mvy / 2;
		
		fpBlockAction->i8MVX = mvx;
		fpBlockAction->i8MVY = mvy;
		// duplicate other 3 Y blocks
		fpBlockAction[1].i8MVX = mvx;
		fpBlockAction[1].i8MVY = mvy;
		fpBlockAction[2].i8MVX = mvx;
		fpBlockAction[2].i8MVY = mvy;
		fpBlockAction[3].i8MVX = mvx;
		fpBlockAction[3].i8MVY = mvy;
		// init UV blocks
		fpBlockAction[4].i8MVX = mvx2;
		fpBlockAction[4].i8MVY = mvy2;
		fpBlockAction[5].i8MVX = mvx2;
		fpBlockAction[5].i8MVY = mvy2;
	}	
	
	uCheckSum = 0;			/* Init MB Checksum */

	for (i = 0; i < 6; i++)
	{
		if (DC->uMBType <= 1)		/* is intra */
			fpBlockAction->u8BlkType = BT_INTRA;
		else
			if (iCBP & 0x20)		/* if coded */
				fpBlockAction->u8BlkType = BT_INTER;
			else
				fpBlockAction->u8BlkType = BT_EMPTY;

		if (fpBlockAction->u8BlkType != BT_EMPTY)
		{
			fpBlockAction->u8Quant = u8Quant;
			ASSERT(fpBlockAction->pCurBlock != NULL);
			ASSERT(fpBlockAction->uBlkNumber == (U32)iBlockNumber);

			/*----- DecodeBlock ----*/
			#ifdef DECODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif
			#ifdef CHECKSUM_MACRO_BLOCK
			//	uBitsReadOut = DecodeBlock(fpBlockAction, fpu8, uBitsReadIn, (U32)DC+DC->uMBBuffer+i*256, fpBlockAction->pCurBlock, &uCheckSum);
			#else
				// rearch
				uBitsReadOut = (*pFunc_VLD) ( fpBlockAction, 
                                              fpu8, 
                                              uBitsReadIn, 
                                              (U32 *) *pN,
                                              (U32 *) *pRUN_INVERSE_Q);
				// rearch
			#endif
			#ifdef DECODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uDecodeBlockSum)
			#endif

			if (uBitsReadOut == 0)
			{
				DBOUT("ERROR :: H263DecodeMBData :: Error decoding a Y block :: ERROR");
				DBOUT("ERROR :: DecodeBlock return 0 bits read....");
				goto done;
			}
			uByteCnt = uBitsReadOut >> 3; 		/* divide by 8 */
			uBitsReadIn = uBitsReadOut & 0x7; 	/* mod 8 */
			fpu8 += uByteCnt;
			
			/* New for rearch */
			ASSERT ( **pN < 65 );			
			////////////////////////////////////////////////
			// End hack                                   //
			////////////////////////////////////////////////

			*pRUN_INVERSE_Q += **pN;
			if ((0xf & fpBlockAction->u8BlkType) != BT_INTER)
				**pN += 65;
			(*pN)++;
			/* end of new rearch */

			/* allow the pointer to address up to four beyond */
			/* the end reading by DWORD using postincrement.  */
			/* changed for detection of stuffing code at      */
			/* end of frame                                   */
			// ASSERT(fpu8 <= (fpu8MaxPtr+14));

			if (fpu8 > (fpu8MaxPtr+14))
			{
				iResult = ICERR_ERROR; // probably not needed
				goto done;
			}

		} /* end if not empty */
		else /* is empty */
		{ /* zero out intermediate data structure and advance pointers */

			/* New for rearch */
			**pN = 0;
			(*pN)++;
			/* end of new rearch */
		}
		
		fpBlockAction++;
		iCBP <<= 1;
		iBlockNumber++;
	} /* end for each block in macroblock */

#ifdef CHECKSUM_MACRO_BLOCK
/* Compare checksum */
	if ((uCheckSum != *uReadChecksum) && (*uReadChecksum != 0))
	{
		iLength = wsprintf(buff80,"WARNING:MB CheckSum miss match, Enc Checksum=0x%x Dec Checksum=0x%x",
					 *uReadChecksum, uCheckSum); 	
		DBOUT(buff80);
		ASSERT(iLength < 80);
	}
#ifdef CHECKSUM_MACRO_BLOCK_DETAIL
	iMBDLength = wsprintf(buf80,"Block=%d CheckSum=0x%x", i, uCheckSum);
	DBOUT(buf80);
	ASSERT(iMBDLength < 80);
#endif
#endif

	/* restore the scanning pointers to point to the next byte */
	/* and set the uWork and uBitsReady values. */
	while (uBitsReadIn > 8)
	{
		fpu8++;
		uBitsReadIn -= 8;
	}
	fpbsState->uBitsReady = 8 - uBitsReadIn;
	fpbsState->uWork = *fpu8++;	   /* store the data and point to next byte */
	fpbsState->uWork &= GetBitsMask[fpbsState->uBitsReady];
	fpbsState->fpu8 = fpu8; 
	
	#ifdef DECODE_STATS
		if (bTimingThisFrame)
		{
			pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount; 
			pDecTimingInfo->uDecodeBlock += uDecodeBlockSum;
			pDecTimingInfo->uLoopFilter  += uLoopFilterSum;
			pDecTimingInfo->uBlockCopy   += uBlockCopySum;
			pDecTimingInfo->uBlockCopySp += uBlockCopySpSum;
			pDecTimingInfo->uBlockAdd    += uBlockAddSum;
			pDecTimingInfo->uBlockAddSp  += uBlockAddSpSum;
		}
	#endif

	iResult = ICERR_OK;
		
done:
	return iResult;
} /* H263DecodeMBData() */
#pragma code_seg()

/*****************************************************************************
 *
 *  H263IDCTandMC
 *
 *  Inverse Discrete Cosine Transform and
 *  Motion Compensation for each block
 *
 */

#pragma code_seg("IACODE2")
void H263IDCTandMC(
    T_H263DecoderCatalog FAR *DC,
    T_BlkAction FAR          *fpBlockAction, 
    int                       iBlock,
    int                       iMBNum,     // AP-NEW
    int                       iGOBNum, // AP-NEW
    U32                      *pN,                         
    T_IQ_INDEX               *pRUN_INVERSE_Q,
    T_MBInfo                 *fpMBInfo,      // AP-NEW
    int                       iEdgeFlag
)
{
    I32 pRef;
    I32 mvx, mvy;

    ASSERT(*pN != 65);
    
    if (*pN < 65) // Inter block
    {

      // first do motion compensation
      // result will be pointed to by pRef
    
      mvx = fpBlockAction[iBlock].i8MVX;
      mvy = fpBlockAction[iBlock].i8MVY;

      pRef = fpBlockAction[iBlock].pRefBlock + (I32) mvx + PITCH * (I32) mvy; 

                                                         
      // now do the inverse transform (where appropriate) & combine
      if (*pN > 0) // and, of course, < 65.
      {
        // Get residual block; output at DC+DC->uMBBuffer+BLOCK_BUFFER_OFFSET 
        // Finally add the residual to the reference block
        //  TODO

        DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q, 
            *pN,
            fpBlockAction[iBlock].pCurBlock,                // not used here
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);// inter  output

        if (fpMBInfo->i8MBType >=7)
        {
            // do spatial loop filter
            LoopFilter((U8 *)pRef, (U8*)DC+DC->uFilterBBuffer, PITCH);

            BlockAddSpecial((U32)DC+DC->uMBBuffer + BLOCK_BUFFER_OFFSET, 
                            (U32)DC+DC->uFilterBBuffer, 
                            fpBlockAction[iBlock].pCurBlock);
        }
        else
        {
            BlockAdd(
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET, // output
            pRef,                                           // prediction
            fpBlockAction[iBlock].pCurBlock);               // destination
        }

      }
      else  // *pN == 0, so no transform coefficients for this block
      {
        // Just copy motion compensated reference block

        if (fpMBInfo->i8MBType >=7)
        {
        // do spatial loop filter
           LoopFilter((U8 *)pRef, (U8*)DC+DC->uFilterBBuffer, PITCH);
           //MMX_LoopFilter((U8 *)pRef, (U8*)DC+DC->uFilterBBuffer, 8);

           BlockCopySpecial(fpBlockAction[iBlock].pCurBlock, 
                        (U32)DC+DC->uFilterBBuffer);
		}
		else
           
		   BlockCopy(
			  fpBlockAction[iBlock].pCurBlock,                    // destination
			  pRef);                                              // prediction
         
      }
                                                               
    }
    else  // *pN >= 65, hence intRA
    {
      //  TODO

		DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q, 
            *pN, 
            fpBlockAction[iBlock].pCurBlock,      // intRA transform output
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);
    }  // end if (*pN < 65) ... else ...
                         
}
//  End IDCTandMC
////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1gob.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/* 
 *  d3gob.cpp
 *
 *  Description:
 *		This modules contains the GOB header support routines
 *
 *	Routines:
 *		H263SetGOBHeaderInfo
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\dec\d1gob.cpv   1.15   10 Sep 1996 15:50:52   RHAZRA  $
 */

#include "precomp.h"

/* BIT field Constants
 */
const int BITS_GOB_STARTCODE = 16;
const int BITS_GROUP_NUMBER = 4;
const int BITS_GFID = 2;
const int BITS_GQUANT = 5;
const int MAX_GBSC_LOOKAHEAD_NUMBER = 7;
const int BITS_GSPARE = 8;	// not including the following GEI

/* GBSC_VALUE - 0000 0000 0000 0001 xxxx xxxx xxxx xxxx 
 */
const U32 GBSC_VALUE = (0x00010000 >> (32-BITS_GOB_STARTCODE));
  
/*****************************************************************************
 *
 * 	H263DecodeGOBHeader
 *
 *  Set the GOB header information in the decoder catalog.  GOB numbers 2 thru
 *  N may have a GOB header.  Look for one if it is there read it storing the
 *  information in the catalog.  If a GOB header is not there set the information
 *  to default values.
 *
 *  Returns an ICERR_STATUS
 */
#pragma code_seg("IACODE1")
extern I32 H263DecodeGOBHeader(
	T_H263DecoderCatalog FAR * DC,
	BITSTREAM_STATE FAR * fpbsState,
	U32 uAssumedGroupNumber)
{
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	I32 iReturn;
	U32 uResult;
	U16 bFoundStartCode = 0;
	int iSpareCount;
#ifndef RING0
	char buf120[120];
	int iLength;
#endif

	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
	/* GNum	 */
	GET_FIXED_BITS((U32) BITS_GROUP_NUMBER, fpu8, uWork, uBitsReady, uResult);
	DC->uGroupNumber = uResult;

//#ifndef LOSS_RECOVERY
#if 0
	if (DC->uGroupNumber <= 0)
	{
		DBOUT("Bad GOB number");
		iReturn = ICERR_ERROR;
		goto done;

		/* took out ASSERT so that can try and catch
		** invalid bit streams and return error
		*/
		//ASSERT(DC->uGroupNumber > 0);
	}
#else
	if (DC->uGroupNumber <= 0)
    {
	   DBOUT("Detected packet fault in GOB number");
       DBOUT("Returning PACKET_FAULT_AT_MB_OR_GOB");
	   iReturn = PACKET_FAULT_AT_MB_OR_GOB;
	   goto done;
	}
#endif

	/* GQUANT */
	GET_FIXED_BITS((U32) BITS_GQUANT, fpu8, uWork, uBitsReady, uResult);

//#ifndef LOSS_RECOVERY
#if 0
    if (uResult < 1)
    {
       iReturn = ICERR_ERROR;
       goto done;
    }
	DC->uGQuant = uResult;
	DC->uMQuant = uResult;
#else
    if (uResult < 1)
    {
       DBOUT("Detected packet fault in GOB quant");
       DBOUT("Returning PACKET_FAULT_AT_PSC");
       iReturn = PACKET_FAULT_AT_PSC;
       GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
       goto done;
    }
    
       DC->uGQuant = uResult;
       DC->uMQuant = uResult;
#endif


	/* skip spare bits */
	iSpareCount = 0;
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	while(uResult)
	{
		GET_FIXED_BITS((U32)BITS_GSPARE, fpu8, uWork, uBitsReady, uResult);
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		iSpareCount += BITS_GSPARE;
	}
		
		
	/* Save the modified bitstream state */
	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)

#ifndef RING0
	iLength = wsprintf(buf120,"GOB: HeaderPresent=%d GN=%ld GQ=%ld",
					   bFoundStartCode,
					   DC->uGroupNumber,
					   DC->uGQuant);
	DBOUT(buf120);
	ASSERT(iLength < 120);
#endif

	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodeGOBHeader() */
#pragma code_seg()

/* ******************************************** */
#pragma code_seg("IACODE1")
extern I32 H263DecodeGOBStartCode(
	T_H263DecoderCatalog FAR * DC,
	BITSTREAM_STATE FAR * fpbsState)
{
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	I32 iReturn;
	U32 uResult;

	/* Look for the GOB header Start Code */
	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
	GET_FIXED_BITS((U32) BITS_GOB_STARTCODE, fpu8, uWork, uBitsReady, uResult);
	if (uResult != 1)
	{
		iReturn = ICERR_ERROR;
		goto done;
	}
	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)

	iReturn = ICERR_OK;
done:	
	return iReturn;

} /* end H263DecodeGOBStartCode() */

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1picchk.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
//////////////////////////////////////////////////////////////////////////
// $Author:   MBODART  $
// $Date:   12 Sep 1996 14:23:16  $
// $Archive:   S:\h26x\src\dec\d1picchk.cpv  $
// $Header:   S:\h26x\src\dec\d1picchk.cpv   1.4   12 Sep 1996 14:23:16   MBODART  $
// $Log:   S:\h26x\src\dec\d1picchk.cpv  $
// 
//    Rev 1.4   12 Sep 1996 14:23:16   MBODART
// Replaced GlobalAlloc family with HeapAlloc in the H.261 decoder.
// 
//    Rev 1.3   21 Mar 1996 17:01:42   AKASAI
// Added #ifdef so code is not included in non-checksum build.
////////////////////////////////////////////////////////////////////////////// 

#ifdef CHECKSUM_PICTURE

#include "precomp.h"

//*********************************************************************
//H261PictureCheckSumEntry -- This function locks Decoder Instance
//                            data, calls routine to computes the 
//                            "Picture CheckSum" 3 - 32-bit values are 
//                            computed and returned in structure 
//                            YVUCheckSum and then Decoder Instance
//                            data is unlocked.
//*********************************************************************
I32 H261PictureCheckSumEntry(
	LPDECINST lpInst,
	YVUCheckSum * pYVUCheckSum) 
{
	LRESULT iReturn = ICERR_ERROR;
	U8 FAR * P32Inst;

	if (lpInst->pDecoderInst == NULL)
	{
		DBOUT("ERROR :: H261PictureCheckSumEntry :: ICERR_MEMORY");
		iReturn = ICERR_MEMORY;
		goto  done;
    }

	/* Build the decoder catalog pointer 
	 */
	P32Inst = (U8 FAR *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	/* Call routine to compute checksum
    */
    iReturn = H261ComputePictureCheckSum( P32Inst, pYVUCheckSum );
 
done:
	return iReturn;
}

//*********************************************************************
//H261ComputePictureCheckSum -- This function computes the "Picture CheckSum"
//                              3 - 32-bit values are computed and returned
//                              in structure YVUCheckSum
//*********************************************************************
I32 H261ComputePictureCheckSum(
	U8 FAR * P32Inst,
	YVUCheckSum * pYVUCheckSum) 
{ 
	I32 iReturn = ICERR_ERROR;
	T_H263DecoderCatalog * DC; 

    /* The following are used for Picture CheckSum */
    U32 uYCheckSum=0;
    U32 uVCheckSum=0;
    U32 uUCheckSum=0;
    I32 irow, icolumn;
	DWORD * hpdw;
	DWORD * hpdwU;

	DC = (T_H263DecoderCatalog FAR *) P32Inst;

	if (DC->uSrcFormat == SRC_FORMAT_QCIF)
	{
		hpdw = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_YPlane+Y_START);
		for (irow=0; irow < 144; irow++)
		{
			for (icolumn=0; icolumn < (176/16); icolumn++)
			{
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
			}
			hpdw += (PITCH/4) - (176/4);
		}
		pYVUCheckSum->uYCheckSum = uYCheckSum;

		hpdw  = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_VPlane+UV_START);
		hpdwU = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_UPlane+UV_START);
		for (irow=0; irow < (144/2); irow++)
		{
			for (icolumn=0; icolumn < (176/16); icolumn++)
			{
				uVCheckSum += *hpdw++;
				uVCheckSum += *hpdw++;
				uUCheckSum += *hpdwU++;
				uUCheckSum += *hpdwU++;
			}
			hpdw  += (PITCH/4) - (176/8);
			hpdwU += (PITCH/4) - (176/8);
		}
		pYVUCheckSum->uVCheckSum = uVCheckSum;
		pYVUCheckSum->uUCheckSum = uUCheckSum;

	}
	else if (DC->uSrcFormat == SRC_FORMAT_CIF)
	{
		hpdw = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_YPlane+Y_START);
		for (irow=0; irow < 288; irow++)
		{
			for (icolumn=0; icolumn < (352/32); icolumn++)
			{
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
			}
			hpdw += (PITCH/4) - (352/4);
		}
		pYVUCheckSum->uYCheckSum = uYCheckSum;

		hpdw  = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_VPlane+UV_START);
		hpdwU = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_UPlane+UV_START);
		for (irow=0; irow < (288/2); irow++)
		{
			for (icolumn=0; icolumn < (352/32); icolumn++)
			{
				uVCheckSum += *hpdw++;
				uVCheckSum += *hpdw++;
				uVCheckSum += *hpdw++;
				uVCheckSum += *hpdw++;
				uUCheckSum += *hpdwU++;
				uUCheckSum += *hpdwU++;
				uUCheckSum += *hpdwU++;
				uUCheckSum += *hpdwU++;
			}
			hpdw  += (PITCH/4) - (352/8);
			hpdwU += (PITCH/4) - (352/8);
		}
		pYVUCheckSum->uVCheckSum = uVCheckSum;
		pYVUCheckSum->uUCheckSum = uUCheckSum;

	}
	else {
		ASSERT(0);			// Should never happen
	}

	iReturn = ICERR_OK;

	return iReturn;
}

//*********************************************************************
//H261ComparePictureCheckSum -- This function compares the "Picture CheckSum"
//                              3 - 32-bit values.
//*********************************************************************
I32 H261ComparePictureCheckSum(
	YVUCheckSum * pYVUCheckSum1,
	YVUCheckSum * pYVUCheckSum2) 
{ 
	I32 iReturn = ICERR_ERROR;
	I16 iErrorFlag = 0;
	
	if (pYVUCheckSum1->uYCheckSum != pYVUCheckSum2->uYCheckSum)
	{
        DBOUT("Y CheckSum does not match");      
	iErrorFlag = 1;
//	goto done;
	}
	
	if (pYVUCheckSum1->uVCheckSum != pYVUCheckSum2->uVCheckSum)
	{
        DBOUT("V CheckSum does not match");      
	iErrorFlag = 1;
//	goto done;
	}

	if (pYVUCheckSum1->uUCheckSum != pYVUCheckSum2->uUCheckSum)
	{
        DBOUT("U CheckSum does not match");      
	iErrorFlag = 1;
//	goto done;
	}

	/* if any or all planes had checksum errors, return ICERR_ERROR */
	if (iErrorFlag)
		iReturn = ICERR_ERROR;
	else iReturn = ICERR_OK;

// done:
	return iReturn;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1mblk.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * 
 *  d1mblk.h
 *
 *  Description:
 *		Interface to macro block header processing.  
 */

/* $Header:   S:\h26x\src\dec\d1mblk.h_v   1.9   07 Nov 1996 15:43:12   SCDAY  $
 */

#ifndef __D1MB_H__
#define __D1MB_H__

extern I32 H263DecodeMBHeader(T_H263DecoderCatalog FAR * DC, 
		BITSTREAM_STATE FAR * fpbsState, 
		U32 * uReadChecksum);

extern I32 H263DecodeMBData(T_H263DecoderCatalog FAR * DC,
		T_BlkAction FAR * fpBlockAction, 
		I32 iBlockNumber,
		BITSTREAM_STATE FAR * fpbsState,
		U8 FAR * fpu8MaxPtr, 
		U32 * uReadChecksum,
                U32 **pN,                         // New rearch
                T_IQ_INDEX ** pRUN_INVERSE_Q);     // New rearch

extern void H263IDCTandMC(T_H263DecoderCatalog FAR *DC,	   // NEW function
				T_BlkAction FAR * fpBlockAction,
				int b,
				int m,
				int g,
				U32 *pN,
				T_IQ_INDEX *pRUN_INVERSE_Q,
				T_MBInfo *fpMBInfo,
				int iEdgeFlag);

extern "C" {
void FAR LoopFilter (
		U8 * uRefBlock,
		U8 * uDstBlock,
		I32 uDstPitch);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;// $Header:   S:\h26x\src\dec\d1rtp.h_v   1.1   04 Sep 1996 09:48:02   RHAZRA  $
;// $Log:   S:\h26x\src\dec\d1rtp.h_v  $
// 
//    Rev 1.1   04 Sep 1996 09:48:02   RHAZRA
// Added custom identifiers to differentiate packet loss types.
// 
//    Rev 1.0   21 Aug 1996 18:35:50   RHAZRA
// Initial revision.
;// 
;//    Rev 1.1   23 Jul 1996 11:22:42   CZHU
;// 
;// Added a MV recovery. Hursitic will be added in later.
;// 
;//    Rev 1.0   22 Apr 1996 16:44:06   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.7   10 Apr 1996 13:35:30   CZHU
;// 
;// Added subroutine to recover picture header information from extended bitstr
;// 
;//    Rev 1.6   29 Mar 1996 14:40:00   CZHU
;// 
;// cleaning 
;// 
;//    Rev 1.5   29 Mar 1996 13:39:00   CZHU
;// 
;// Moved bs verification to c3rtp.cpp
;// 
;//    Rev 1.4   28 Mar 1996 18:40:18   CZHU
;// Support packet loss recovery
;// 
;//    Rev 1.3   23 Feb 1996 16:21:26   CZHU
;// No change.
;// 
;//    Rev 1.2   15 Feb 1996 12:01:56   CZHU
;// 
;// More clean up
;// 
;//    Rev 1.1   14 Feb 1996 15:00:20   CZHU
;// Added support Mode A and Mode B
;// 
;//    Rev 1.0   12 Feb 1996 17:05:58   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   11 Dec 1995 14:54:26   CZHU
;// Initial revision.

#ifndef _H263_D3RTP_H_
#define _H263_D3RTP_H_

const long PACKET_FAULT_AT_PSC         = ICERR_CUSTOM -1;
const long PACKET_FAULT_AT_MB_OR_GOB   = ICERR_CUSTOM -2;
const long NEXT_MODE_STARTS_GOB        = ICERR_CUSTOM -3;
const long NEXT_MODE_STARTS_MB         = ICERR_CUSTOM -4;
const long NEXT_MODE_LAST              = ICERR_CUSTOM -5;
extern  I32 RtpH261FindNextPacket( 
          T_H263DecoderCatalog FAR * , 														  
	      BITSTREAM_STATE FAR * ,
	      U32 **, 
	      U32 *,
	      int *,
		  int *
	    );                      
extern I32 RtpGetPicHeaderFromBsExt(T_H263DecoderCatalog FAR * );
void MVAdjustment(T_BlkAction *,int ,int,  int ,int , int , const int );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1pict.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/* 
 *  d1pict.cpp
 *
 *  Description:
 *		This modules contains the picture header parsing routines
 *
 *	Routines:
 *		H263ReadPictureHeader
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\dec\d1pict.cpv   1.13   22 Jan 1997 13:36:12   RHAZRA  $
 */

#include "precomp.h"

/* BIT field Constants
 */
const int BITS_PICTURE_STARTCODE = 20;
const int BITS_TR = 5;
const int BITS_PSPARE = 8; //not including the following PEI

/* PSC_VALUE - 0000 0000 0000 0001 0000 xxxx xxxx xxxx 
 */
const U32 PSC_VALUE = (0x00010000 >> (32-BITS_PICTURE_STARTCODE));
/* We only want to search so far before it is considered an error 
 */
const int MAX_LOOKAHEAD_NUMBER = 256; /* number of bits */
  
/*****************************************************************************
 *
 * 	H263DecodePictureHeader
 *
 *  Read and parse the picture header - updating the fpbsState if the read
 *	succeeds.
 *
 *  Returns an ICERR_STATUS
 */
#ifdef CHECKSUM_PICTURE
extern I32 
H263DecodePictureHeader(
	T_H263DecoderCatalog FAR * DC,
	U8 FAR * fpu8,
	U32 uBitsReady, 
	U32 uWork,
	BITSTREAM_STATE FAR * fpbsState,
	YVUCheckSum * pReadYVUCksum,
	U32 * uCheckSumValid)
#else
extern I32 
H263DecodePictureHeader(
	T_H263DecoderCatalog FAR * DC,
	U8 FAR * fpu8,
	U32 uBitsReady, 
	U32 uWork,
	BITSTREAM_STATE FAR * fpbsState)
#endif
{
	I32 iReturn;
	int iLookAhead;
	U32 uResult;
	U32 uData;
	int iSpareCount;
#ifndef RING0
	char buf120[120];
	int iLength;
#endif

	/* PSC
	 */
	GET_FIXED_BITS((U32) BITS_PICTURE_STARTCODE, fpu8, uWork, uBitsReady, 
				   uResult);
	iLookAhead = 0;
	while (uResult != PSC_VALUE) {
		uResult = uResult << 1;
		uResult &= GetBitsMask[BITS_PICTURE_STARTCODE];
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uData);
		uResult |= uData;
		iLookAhead++;
		if (iLookAhead > MAX_LOOKAHEAD_NUMBER) {
			DBOUT("ERROR :: H263ReadPictureHeader :: missing PSC :: ERROR");
			iReturn = ICERR_ERROR;
			goto done;
		}
	}

	GET_FIXED_BITS((U32) BITS_TR, fpu8, uWork, uBitsReady, uResult);
	DC->uTempRef = uResult;

	/* PTYPE 
	 */

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bSplitScreen = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bCameraOn = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bFreezeRelease = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	if (uResult > SRC_FORMAT_CIF)
	{
		DBOUT("ERROR::H263ReadPictureHeader::src format not supported??::ERROR");
		iReturn=ICERR_ERROR;
		goto done;
	}
	DC->uPrevSrcFormat = DC->uSrcFormat;
	DC->uSrcFormat = (U16) uResult;
	if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat)
	{
		DBOUT("ERROR::H263ReadPictureHeader::src format change is not supported??::ERROR");
		iReturn=ICERR_ERROR;
		goto done;
	}
	
	DC->bReadSrcFormat = 1;
		
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bHiResStill = (U16) !uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bUnused = (U16) uResult;
	
/* process Picture layer checksum data */
/* OR */
/* skip spare bits */
#ifdef CHECKSUM_PICTURE
	/* get checksum data one bit */
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	if (uResult == 1)
	{
		/* first check for key field */
		GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
		if (uResult == 1)
			*uCheckSumValid = 1;
		else	*uCheckSumValid = 0;

		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
		/* get Y checksum */
		pReadYVUCksum->uYCheckSum = ((uResult & 0xff) << 24);
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uYCheckSum = (pReadYVUCksum->uYCheckSum | ((uResult & 0xff) << 16));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uYCheckSum = (pReadYVUCksum->uYCheckSum | ((uResult & 0xff) << 8));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uYCheckSum = (pReadYVUCksum->uYCheckSum | (uResult & 0xff));
		/* get V checksum */
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uVCheckSum = ((uResult & 0xff) << 24);
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uVCheckSum = (pReadYVUCksum->uVCheckSum | ((uResult & 0xff) << 16));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uVCheckSum = (pReadYVUCksum->uVCheckSum | ((uResult & 0xff) << 8));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uVCheckSum = (pReadYVUCksum->uVCheckSum | (uResult & 0xff));
		/* get U checksum */
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uUCheckSum = ((uResult & 0xff) << 24);
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uUCheckSum = (pReadYVUCksum->uUCheckSum | ((uResult & 0xff) << 16));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uUCheckSum = (pReadYVUCksum->uUCheckSum | ((uResult & 0xff) << 8));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uUCheckSum = (pReadYVUCksum->uUCheckSum | (uResult & 0xff));
		
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		while (uResult) {
			GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
			GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		}
	}
	else 
	{
		DBOUT("ERROR :: H261PictureChecksum :: Invalid Checksum data :: ERROR");
		iReturn = ICERR_ERROR;
		goto done;
	}

#else	/* checksum is not enabled */
	/* skip spare bits */
	iSpareCount = 0;
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	while (uResult) {
		GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		iSpareCount += BITS_PSPARE;
	}
#endif

#ifndef RING0
	iLength = wsprintf(buf120,
					 "TR=%ld SS=%d CAM=%d FRZ=%d SRC=%d Spare=%d",
					 DC->uTempRef,
					 DC->bSplitScreen,
					 DC->bCameraOn,
					 DC->bFreezeRelease,
					 DC->uSrcFormat,
					 iSpareCount);
	DBOUT(buf120);
	ASSERT(iLength < 120);
#endif

	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState);
	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodePictureHeader() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1pict.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * 
 *  d1pict.h
 *
 *  Description:
 *		Interface to the picture header reader
 */

/* $Header:   S:\h26x\src\dec\d1pict.h_v   1.5   09 Jan 1996 09:41:38   AKASAI  $
 */

#ifndef __D1PICT_H__
#define __D1PICT_H__

extern I32 H263DecodePictureHeader(T_H263DecoderCatalog FAR * DC, 
				   U8 FAR * fpu8, 
				   U32 uBitsReady,
				   U32 uWork, 
				   BITSTREAM_STATE FAR * fpbsState);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1tables.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
//////////////////////////////////////////////////////////////////////////
;// $Author:   AKASAI  $
;// $Date:   09 Jan 1996 09:41:26  $
;// $Archive:   S:\h26x\src\dec\d1tables.h_v  $
;// $Header:   S:\h26x\src\dec\d1tables.h_v   1.7   09 Jan 1996 09:41:26   AKASAI  $
;// $Log:   S:\h26x\src\dec\d1tables.h_v  $
;// 
;//    Rev 1.7   09 Jan 1996 09:41:26   AKASAI
;// Updated copyright notice.
;// 
;//    Rev 1.6   20 Oct 1995 13:16:14   SCDAY
;// Changed the type for motion vector data
;// 
;//    Rev 1.5   18 Oct 1995 11:00:18   SCDAY
;// Added motion vector table
;// 
;//    Rev 1.4   16 Oct 1995 13:52:16   SCDAY
;// 
;// Merged in d1akktbl.h
;// 
;//    Rev 1.3   22 Sep 1995 14:50:38   SCDAY
;// 
;// added akk temporary tables
;// 
;//    Rev 1.2   20 Sep 1995 15:33:18   SCDAY
;// 
;// added Mtype, MVD, CBP tables
;// 
;//    Rev 1.1   19 Sep 1995 15:22:26   SCDAY
;// added MBA tables
;// 
;//    Rev 1.0   11 Sep 1995 13:51:14   SCDAY
;// Initial revision.
;// 
;//    Rev 1.3   16 Aug 1995 14:25:44   CZHU
;// 
;// Changed inverse quantization table to I16
;// 
;//    Rev 1.2   11 Aug 1995 15:50:26   CZHU
;// Moved the tables to d3tables.cpp, leave only extern defs.
;// 
;//    Rev 1.1   02 Aug 1995 11:47:04   CZHU
;// 
;// Added table for inverse quantization and RLD-ZZ
;// 
;//    Rev 1.0   31 Jul 1995 15:46:20   CZHU
;// Initial revision.

//Initialize global tables shared by all decoder instances:
//Huffman tables, etc
//declare the global static tables here
#ifndef _GLOBAL_TABLES_
#define _GLOBAL_TABLES_

/* H261 */

/* AKK tables */
extern U8 gTAB_TCOEFF_tc1[512];
extern U8 gTAB_TCOEFF_tc1a[512];
extern U8 gTAB_TCOEFF_tc2[192];

extern U16 gTAB_MBA_MAJOR[256];		// total 512 Bytes

extern U16 gTAB_MBA_MINOR[32];		// total 64 Bytes

extern U16 gTAB_MTYPE_MAJOR[256];	// total 512 Bytes

extern U16 gTAB_MTYPE_MINOR[4];		// total 8 Bytes

extern U16 gTAB_MVD_MAJOR[256];		// total 512 Bytes

extern U16 gTAB_MVD_MINOR[24];		// total 48 Bytes

extern U16 gTAB_CBP[512];		// total 1024 Bytes

extern I8  gTAB_MV_ADJUST[65];

extern I16 gTAB_INVERSE_Q[1024] ;

extern U32 gTAB_ZZ_RUN[64]; //input is the cumulative run value
                     //returns the offset to the starting address of the block
					 //total at 256
  					   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1tables.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 14:41:08  $
;// $Archive:   S:\h26x\src\dec\d1tables.cpv  $
;// $Header:   S:\h26x\src\dec\d1tables.cpv   1.11   22 Dec 1995 14:41:08   KMILLS  $
;// $Log:   S:\h26x\src\dec\d1tables.cpv  $
// 
//    Rev 1.11   22 Dec 1995 14:41:08   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.10   26 Oct 1995 15:31:18   SCDAY
// Changed MV tables
// 
//    Rev 1.9   23 Oct 1995 16:14:20   SCDAY
// changed minor tables for >8 bit processing
// 
//    Rev 1.8   20 Oct 1995 13:16:52   SCDAY
// 
// Changed motion vector tables and the type for gTAB_MV_ADJUST
// 
//    Rev 1.7   18 Oct 1995 14:50:26   AKASAI
// Fixed bug in tcoeff tables.  tc1a table was missing a set of 8 entries.
// Had only 504 entries instead of 512.
// 
//    Rev 1.6   18 Oct 1995 11:01:26   SCDAY
// 
// Added motion vector table
// 
//    Rev 1.5   16 Oct 1995 13:51:02   SCDAY
// Merged in d1akktbl.cpp
// 
//    Rev 1.4   09 Oct 1995 08:21:30   SCDAY
// fixed gTAB_ZZ_RUN
// 
//    Rev 1.3   21 Sep 1995 18:05:00   AKASAI
// Updated Inverse quantization table, should now match version in d3tables.cp
// 
//    Rev 1.2   20 Sep 1995 15:34:14   SCDAY
// 
// added Mtype, MVD, CBP tables
// 
//    Rev 1.1   19 Sep 1995 15:22:14   SCDAY
// added MBA tables
// 
//    Rev 1.0   11 Sep 1995 13:51:54   SCDAY
// Initial revision.
// 
//    Rev 1.5   31 Aug 1995 16:42:48   CZHU
// Changed the format of MVD variable length decoder tables: major and minor
// 
//    Rev 1.4   24 Aug 1995 15:34:28   CZHU
// Fixed bugs in the inverse quant table, and TCOEFF minor tables 
// 
//    Rev 1.3   22 Aug 1995 17:39:00   CZHU
// 
// Modified the TCOEFF_MAJOR and MINOR tables for embedded run values.
// 
//    Rev 1.2   18 Aug 1995 15:01:00   CZHU
// Added run length tables ready for joint opt IDCT and RLD+ZZ
// 
//    Rev 1.1   16 Aug 1995 14:25:10   CZHU
// 
// Rebuild the tables for IQ, RLD for Transform coefficients
// 
//    Rev 1.0   11 Aug 1995 15:50:56   CZHU
// Initial revision.
;// 
;//    Rev 1.1   02 Aug 1995 11:47:04   CZHU
;// 
;// Added table for inverse quantization and RLD-ZZ
;// 
;//    Rev 1.0   31 Jul 1995 15:46:20   CZHU
;// Initial revision.

//Initialize global tables shared by all decoder instances:
//Huffman tables, etc
//declare the global static tables here

#include "precomp.h"

/* H261 tables */

U16 gTAB_MBA_MAJOR[256]= {
	
0xff18,				/* 0x00 */
0x0b22,
0xff00,
0xff10,
0xff08,
0xff00,
0x080f,
0x080e,

0x080d,
0x080c,
0x080b,
0x080a,
0x0709,
0x0709,
0x0708,
0x0708,

0x0507,				/* 0x10 */
0x0507,
0x0507,
0x0507,
0x0507,
0x0507,
0x0507,
0x0507,

0x0506,
0x0506,
0x0506,
0x0506,
0x0506,
0x0506,
0x0506,
0x0506,

0x0405,				/* 0x20 */
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,

0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,

0x0404,				/* 0x30 */
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,

0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,

0x0303,				/* 0x40 */
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,

0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,

0x0303,				/* 0x50 */
0x0303,	
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,

0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,

0x0302,				/* 0x60 */
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,

0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,

0x0302,				/* 0x70 */
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,

0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,

0x0101,				/* 0x80 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0x90 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xa0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xb0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xc0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xd0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xe0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xf0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101
};

U16 gTAB_MBA_MINOR[32]= {
0x0a13,			/* 16 - 19 */
0x0a13,
0x0a12,
0x0a12,
0x0a11,
0x0a11,
0x0a10,
0x0a10,

0x0b19,			/* 20 - 25 */
0x0b18,
0x0b17,
0x0b16,
0x0a15,
0x0a15,
0x0a14,
0x0a14,

0x0b21,			/* 26 - 33 */
0x0b20,
0x0b1f,
0x0b1e,
0x0b1d,
0x0b1c,
0x0b1b,
0x0b1a,

0x1023,			/* code 35  */
0x1023,
0x1023,
0x1023,
0x1023,
0x1023,
0x1023,
0x1023
};

U16 gTAB_MTYPE_MAJOR[]={
0xff00,				/* 0x00 */
0x0805,
0x0701,
0x0701,
0x0609,
0x0609,
0x0609,
0x0609,

0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,

0x0400,				/* 0x10 */
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,

0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,

0x0307,				/* 0x20 */
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,

0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,

0x0307,				/* 0x30 */
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,

0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,

0x0208,				/* 0x40 */
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,				/* 0x50 */
0x0208,	
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,				/* 0x60 */
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,				/* 0x70 */
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0102,				/* 0x80 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0x90 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xa0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xb0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xc0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xd0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xe0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xf0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102
};

U16 gTAB_MTYPE_MINOR[]={
0x0800,
0x0a06,
0x0904,
0x0904
};

U16 gTAB_MVD_MAJOR[]={
0xffff,				/* 0x00 */
0xffff,
0xffff,
0xff00,
0xff08,
0xff10,
0x0807,
0x08f9,

0x0806,
0x08fa,
0x0805,
0x08fb,
0x0704,
0x0704,
0x07fc,
0x07fc,

0x0503,				/* 0x10 */
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,

0x05fd,
0x05fd,
0x05fd,
0x05fd,
0x05fd,
0x05fd,
0x05fd,
0x05fd,

0x0402,				/* 0x20 */
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,

0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,

0x04fe,				/* 0x30 */
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,

0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,

0x0301,				/* 0x40 */
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,

0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,

0x0301,				/* 0x50 */
0x0301,	
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,

0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,

0x03ff,				/* 0x60 */
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,

0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,

0x03ff,				/* 0x70 */
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,

0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,

0x0100,				/* 0x80 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0x90 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xa0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xb0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xc0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xd0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xe0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xf0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100
};

U16 gTAB_MVD_MINOR[]={
0x0bff,			/* 0000 0011 */
0x0bf0,
0x0b0f,
0x0bf1,
0x0b0e,
0x0bf2,
0x0b0d,
0x0bf3,

0x0b0c,			/* 0000 0100 */
0x0bf4,
0x0b0b,
0x0bf5,
0x0a0a,
0x0a0a,
0x0af6,
0x0af6,

0x0a09,			/* 0000 0101 */
0x0a09,
0x0af7,
0x0af7,
0x0a08,
0x0a08,
0x0af8,
0x0af8
};

U16 gTAB_CBP[]={
0x00ff,			/* 0000 0000 x */
0x00ff,
0x0927,			/* 0000 0001 0 */
0x091b,			/* 0000 0001 1 */
0x093b,			/* 0000 0010 0 */
0x0937,			/* 0000 0010 1 */
0x092f,			/* 0000 0011 0 */
0x091f,			/* 0000 0011 1 */
0x083a,			/* 0000 0100 x */
0x083a,
0x0836,			/* 0000 0101 x */
0x0836,
0x082e,			/* 0000 0110 x */
0x082e,
0x081e,			/* 0000 0111 x */
0x081e,

0x0839,			/* 0000 1000 x */
0x0839,
0x0835,			/* 0000 1001 x */
0x0835,
0x082d,			/* 0000 1010 x */
0x082d,
0x081d,			/* 0000 1011 x */
0x081d,
0x0826,			/* 0000 1100 x */
0x0826,
0x081a,			/* 0000 1101 x */
0x081a,
0x0825,			/* 0000 1110 x */
0x0825,
0x0819,			/* 0000 1111 x */
0x0819,

0x082b,			/* 0001 0000 x */
0x082b,
0x0817,			/* 0001 0001 x */
0x0817,
0x0833,			/* 0001 0010 x */
0x0833,
0x080f,			/* 0001 0011 x */
0x080f,
0x082a,			/* 0001 0100 x */
0x082a,
0x0816,			/* 0001 0101 x */
0x0816,
0x0832,			/* 0001 0110 x */
0x0832,
0x080e,			/* 0001 0111 x */
0x080e,

0x0829,			/* 0001 1000 x */
0x0829,
0x0815,			/* 0001 1001 x */
0x0815,
0x0831,			/* 0001 1010 x */
0x0831,
0x080d,			/* 0001 1011 x */
0x080d,
0x0823,			/* 0001 1100 x */
0x0823,
0x0813,			/* 0001 1101 x */
0x0813,
0x080b,			/* 0001 1110 x */
0x080b,
0x0807,			/* 0001 1111 x */
0x0807,

0x0722,			/* 0010 000x x */
0x0722,
0x0722,
0x0722,
0x0712,			/* 0010 001x x */
0x0712,
0x0712,
0x0712,
0x070a,			/* 0010 010x x */
0x070a,
0x070a,
0x070a,
0x0706,			/* 0010 011x x */
0x0706,
0x0706,
0x0706,

0x0721,			/* 0010 100x x */
0x0721,
0x0721,
0x0721,
0x0711,			/* 0010 101x x */
0x0711,
0x0711,
0x0711,
0x0709,			/* 0010 110x x */
0x0709,
0x0709,
0x0709,
0x0705,			/* 0010 111x x */
0x0705,
0x0705,
0x0705,

0x063f,			/* 0011 00xx x */
0x063f,
0x063f,
0x063f,
0x063f,
0x063f,
0x063f,
0x063f,
0x0603,			/* 0011 01xx x */
0x0603,
0x0603,
0x0603,
0x0603,
0x0603,
0x0603,
0x0603,

0x0624,			/* 0011 10xx x */
0x0624,
0x0624,
0x0624,
0x0624,
0x0624,
0x0624,
0x0624,
0x0618,			/* 0011 11xx x */
0x0618,
0x0618,
0x0618,
0x0618,
0x0618,
0x0618,
0x0618,

0x053e,			/* 0100 0xxx x */
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,

0x0502,			/* 0100 1xxx x */
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,

0x053d,			/* 0101 0xxx x */
0x053d,
0x053d,	
0x053d,	
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,

0x0501,			/* 0101 1xxx x */
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,

0x0538,			/* 0110 0xxx x */
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,

0x0534,			/* 0110 1xxx x */
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,

0x052c,			/* 0111 0xxx x */
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,

0x051c,			/* 0111 1xxx x */
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,

0x0528,			/* 1000 0xxx x */
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,

0x0514,			/* 1000 1xxx x */
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,

0x0530,			/* 1001 0xxx x */
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,

0x050c,			/* 1001 1xxx x */
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,

0x0420,			/* 1010 xxxx x */
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,

0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,

0x0410,			/* 1011 xxxx x */
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,

0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,

0x0408,			/* 1100 xxxx x */
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,

0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,

0x0404,			/* 1101 xxxx x */
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,

0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,

0x033c,			/* 111x xxxx x */
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,

0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,

0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,

0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c
};

U8 gTAB_TCOEFF_tc1[512]={
0xa0, 0x00,               // prefix 0000 0000  
0xb0, 0x40,               // prefix 0000 0001  
0xd0, 0x00,               // prefix 0000 0010  
0xd0, 0x08,               // prefix 0000 0011  
0x5f, 0x02,               // escape  
0x5f, 0x02, 
0x5f, 0x02, 
0x5f, 0x02, 

0x72, 0x02,               // 0000 100s  
0x72, 0xfe, 
0x79, 0x01,               // 0000 101s  
0x79, 0xff, 
0x70, 0x04,               // 0000 110s  
0x70, 0xfc, 
0x78, 0x01,               // 0000 111s  
0x78, 0xff, 

0x67, 0x01,               // 0001 00s  
0x67, 0x01, 
0x67, 0xff, 
0x67, 0xff, 
0x66, 0x01,               // 0001 01s  
0x66, 0x01, 
0x66, 0xff, 
0x66, 0xff, 

0x61, 0x02,               // 0001 10s  
0x61, 0x02, 
0x61, 0xfe, 
0x61, 0xfe, 
0x65, 0x01,               // 0001 11s  
0x65, 0x01, 
0x65, 0xff, 
0x65, 0xff, 

0xf0, 0x10,               // prefix 0010 0000  
0xf0, 0x12,               // prefix 0010 0001  
0xf0, 0x14,               // prefix 0010 0010  
0xf0, 0x16,               // prefix 0010 0011  
0xf0, 0x18,               // prefix 0010 0100  
0xf0, 0x1a,               // prefix 0010 0101  
0xf0, 0x1c,               // prefix 0010 0110  
0xf0, 0x1e,               // prefix 0010 0111  

0x50, 0x03,               // 0010 1s  
0x50, 0x03, 
0x50, 0x03, 
0x50, 0x03, 
0x50, 0xfd, 
0x50, 0xfd, 
0x50, 0xfd, 
0x50, 0xfd, 

0x54, 0x01,               // 0011 0s  
0x54, 0x01, 
0x54, 0x01, 
0x54, 0x01, 
0x54, 0xff, 
0x54, 0xff, 
0x54, 0xff, 
0x54, 0xff, 

0x53, 0x01,               // 0011 1s  
0x53, 0x01, 
0x53, 0x01, 
0x53, 0x01, 
0x53, 0xff, 
0x53, 0xff, 
0x53, 0xff, 
0x53, 0xff, 

0x40, 0x02,               // 0100 s  
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 

0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 

0x42, 0x01,               // 0101 s  
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 

0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 

0x31, 0x01,               // 011s  
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 

0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 

0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 

0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 

0x10, 0x00,               // EOB dw 080  
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00,               // dw 090  
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00,               // dw 0a0  
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00,               // dw 0b0  
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x20, 0x01,               // 11s  
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 

0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 

0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 

0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 

0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 

0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 

0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 

0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff 
};  //512 elements


U8 gTAB_TCOEFF_tc1a[512]={
0xa0, 0x00,               // prefix 0000 0000  
0xb0, 0x40,               // prefix 0000 0001  
0xd0, 0x00,               // prefix 0000 0010  
0xd0, 0x08,               // prefix 0000 0011  
0x5f, 0x02,               // escape  
0x5f, 0x02, 
0x5f, 0x02, 
0x5f, 0x02, 

0x72, 0x02,               // 0000 100s  
0x72, 0xfe, 
0x79, 0x01,               // 0000 101s  
0x79, 0xff, 
0x70, 0x04,               // 0000 110s  
0x70, 0xfc, 
0x78, 0x01,               // 0000 111s  
0x78, 0xff, 

0x67, 0x01,               // 0001 00s  
0x67, 0x01, 
0x67, 0xff, 
0x67, 0xff, 
0x66, 0x01,               // 0001 01s  
0x66, 0x01, 
0x66, 0xff, 
0x66, 0xff, 

0x61, 0x02,               // 0001 10s  
0x61, 0x02, 
0x61, 0xfe, 
0x61, 0xfe, 
0x65, 0x01,               // 0001 11s  
0x65, 0x01, 
0x65, 0xff, 
0x65, 0xff, 

0xf0, 0x10,               // prefix 0010 0000  
0xf0, 0x12,               // prefix 0010 0001  
0xf0, 0x14,               // prefix 0010 0010  
0xf0, 0x16,               // prefix 0010 0011  
0xf0, 0x18,               // prefix 0010 0100  
0xf0, 0x1a,               // prefix 0010 0101  
0xf0, 0x1c,               // prefix 0010 0110  
0xf0, 0x1e,               // prefix 0010 0111  

0x50, 0x03,               // 0010 1s  
0x50, 0x03, 
0x50, 0x03, 
0x50, 0x03, 
0x50, 0xfd, 
0x50, 0xfd, 
0x50, 0xfd, 
0x50, 0xfd, 

0x54, 0x01,               // 0011 0s  
0x54, 0x01, 
0x54, 0x01, 
0x54, 0x01, 
0x54, 0xff, 
0x54, 0xff, 
0x54, 0xff, 
0x54, 0xff, 

0x53, 0x01,               // 0011 1s  
0x53, 0x01, 
0x53, 0x01, 
0x53, 0x01, 
0x53, 0xff, 
0x53, 0xff, 
0x53, 0xff, 
0x53, 0xff, 

0x40, 0x02,               // 0100 s  
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 

0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 

0x42, 0x01,               // 0101 s  
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 

0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 

0x31, 0x01,               // 011s  
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 

0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 

0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 

0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 

0x10, 0x01,               // 1s  
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01,               // dw 090  
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01,               // dw 0a0  
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01,               // dw 0b0  
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff
};  // 512 elements 

U8 gTAB_TCOEFF_tc2[192]={
                    // for prefix 0000 0010  
0x10, 0x01,              // 00 s  
0x10, 0xff, 
0x05, 0x02,               // 01 s  
0x05, 0xfe, 
0x00, 0x07,               // 10 s  
0x00, 0xf9, 
0x02, 0x03,               // 11 s  
0x02, 0xfd, 

                    // for prefix 0000 0011  
0x01, 0x04,               // 00 s  
0x01, 0xfc, 
0x0f, 0x01,               // 01 s  
0x0f, 0xff, 
0x0e, 0x01,               // 10 s  
0x0e, 0xff, 
0x04, 0x02,               // 11 s  
0x04, 0xfe, 

0x0d, 0x01,               // for prefix 0010 0000  
0x0d, 0xff, 
0x00, 0x06,               // for prefix 0010 0001  
0x00, 0xfa, 
0x0c, 0x01,               // for prefix 0010 0010  
0x0c, 0xff, 
0x0b, 0x01,               // for prefix 0010 0011  
0x0b, 0xff, 

0x03, 0x02,               // for prefix 0010 0100  
0x03, 0xfe, 
0x01, 0x03,               // for prefix 0010 0101  
0x01, 0xfd, 
0x00, 0x05,               // for prefix 0010 0110  
0x00, 0xfb, 
0x0a, 0x01,               // for prefix 0010 0111  
0x0a, 0xff, 


// table for 0000 0000 prefix  

0x0a, 0x02,               // 1000 0s  
0x0a, 0xfe, 
0x09, 0x02,               // 1000 1s  
0x09, 0xfe, 
0x05, 0x03,               // 1001 0s  
0x05, 0xfd, 
0x03, 0x04,               // 1001 1s  
0x03, 0xfc, 

0x02, 0x05,               // 1010 0s  
0x02, 0xfb, 
0x01, 0x07,               // 1010 1s  
0x01, 0xf9, 
0x01, 0x06,               // 1011 0s  
0x01, 0xfa, 
0x00, 0x0f,               // 1011 1s  
0x00, 0xf1, 

0x00, 0x0e,               // 1100 0s  
0x00, 0xf2, 
0x00, 0x0d,               // 1100 1s  
0x00, 0xf3, 
0x00, 0x0c,               // 1101 0s  
0x00, 0xf4, 
0x1a, 0x01,               // 1101 1s  
0x1a, 0xff, 

0x19, 0x01,               // 1110 0s  
0x19, 0xff, 
0x18, 0x01,               // 1110 1s  
0x18, 0xff, 
0x17, 0x01,               // 1111 0s  
0x17, 0xff, 
0x16, 0x01,               // 1111 1s  
0x16, 0xff, 

// table for 0000 0001 prefix  

0x00, 0x0b,               // 0000 s  
0x00, 0xf5, 
0x08, 0x02,               // 0001 s  
0x08, 0xfe, 
0x04, 0x03,               // 0010 s  
0x04, 0xfd, 
0x00, 0x0a,               // 0011 s  
0x00, 0xf6, 

0x02, 0x04,               // 0100 s  
0x02, 0xfc, 
0x07, 0x02,               // 0101 s  
0x07, 0xfe, 
0x15, 0x01,               // 0110 s  
0x15, 0xff, 
0x14, 0x01,               // 0111 s  
0x14, 0xff, 

0x00, 0x09,               // 1000 s  
0x00, 0xf7, 
0x13, 0x01,               // 1001 s  
0x13, 0xff, 
0x12, 0x01,               // 1010 s  
0x12, 0xff, 
0x01, 0x05,               // 1011 s  
0x01, 0xfb, 

0x03, 0x03,               // 1100 s  
0x03, 0xfd, 
0x00, 0x08,               // 1101 s  
0x00, 0xf8, 
0x06, 0x02,               // 1110 s  
0x06, 0xfe, 
0x11, 0x01,               // 1111 s        ; error in doc?  
0x11, 0xff 
};  // 192 elements

I8 gTAB_MV_ADJUST[65] = {
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
	-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
	-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,
	0};
	
I16 gTAB_INVERSE_Q[1024] = { 
  0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    3,   -3,    5,   -5,    7,   -7,    9, 
  -9,   11,  -11,   13,  -13,   15,  -15,   17, 
 -17,   19,  -19,   21,  -21,   23,  -23,   25, 
 -25,   27,  -27,   29,  -29,   31,  -31,    0, 
   0,    5,   -5,    9,   -9,   13,  -13,   17, 
 -17,   21,  -21,   25,  -25,   29,  -29,   33, 
 -33,   37,  -37,   41,  -41,   45,  -45,   49, 
 -49,   53,  -53,   57,  -57,   61,  -61,    0, 
   0,    9,   -9,   15,  -15,   21,  -21,   27, 
 -27,   33,  -33,   39,  -39,   45,  -45,   51, 
 -51,   57,  -57,   63,  -63,   69,  -69,   75, 
 -75,   81,  -81,   87,  -87,   93,  -93,    0, 
   0,   11,  -11,   19,  -19,   27,  -27,   35, 
 -35,   43,  -43,   51,  -51,   59,  -59,   67, 
 -67,   75,  -75,   83,  -83,   91,  -91,   99, 
 -99,  107, -107,  115, -115,  123, -123,    0, 
   0,   15,  -15,   25,  -25,   35,  -35,   45, 
 -45,   55,  -55,   65,  -65,   75,  -75,   85, 
 -85,   95,  -95,  105, -105,  115, -115,  125, 
-125,  135, -135,  145, -145,  155, -155,    0, 
   0,   17,  -17,   29,  -29,   41,  -41,   53, 
 -53,   65,  -65,   77,  -77,   89,  -89,  101, 
-101,  113, -113,  125, -125,  137, -137,  149, 
-149,  161, -161,  173, -173,  185, -185,    0, 
   0,   21,  -21,   35,  -35,   49,  -49,   63, 
 -63,   77,  -77,   91,  -91,  105, -105,  119, 
-119,  133, -133,  147, -147,  161, -161,  175, 
-175,  189, -189,  203, -203,  217, -217,    0, 
   0,   23,  -23,   39,  -39,   55,  -55,   71, 
 -71,   87,  -87,  103, -103,  119, -119,  135, 
-135,  151, -151,  167, -167,  183, -183,  199, 
-199,  215, -215,  231, -231,  247, -247,    0, 
   0,   27,  -27,   45,  -45,   63,  -63,   81, 
 -81,   99,  -99,  117, -117,  135, -135,  153, 
-153,  171, -171,  189, -189,  207, -207,  225, 
-225,  243, -243,  261, -261,  279, -279,    0, 
   0,   29,  -29,   49,  -49,   69,  -69,   89, 
 -89,  109, -109,  129, -129,  149, -149,  169, 
-169,  189, -189,  209, -209,  229, -229,  249, 
-249,  269, -269,  289, -289,  309, -309,    0, 
   0,   33,  -33,   55,  -55,   77,  -77,   99, 
 -99,  121, -121,  143, -143,  165, -165,  187, 
-187,  209, -209,  231, -231,  253, -253,  275, 
-275,  297, -297,  319, -319,  341, -341,    0, 
   0,   35,  -35,   59,  -59,   83,  -83,  107, 
-107,  131, -131,  155, -155,  179, -179,  203, 
-203,  227, -227,  251, -251,  275, -275,  299, 
-299,  323, -323,  347, -347,  371, -371,    0, 
   0,   39,  -39,   65,  -65,   91,  -91,  117, 
-117,  143, -143,  169, -169,  195, -195,  221, 
-221,  247, -247,  273, -273,  299, -299,  325, 
-325,  351, -351,  377, -377,  403, -403,    0, 
   0,   41,  -41,   69,  -69,   97,  -97,  125, 
-125,  153, -153,  181, -181,  209, -209,  237, 
-237,  265, -265,  293, -293,  321, -321,  349, 
-349,  377, -377,  405, -405,  433, -433,    0, 
   0,   45,  -45,   75,  -75,  105, -105,  135, 
-135,  165, -165,  195, -195,  225, -225,  255, 
-255,  285, -285,  315, -315,  345, -345,  375, 
-375,  405, -405,  435, -435,  465, -465,    0, 
   0,   47, -47,   79,  -79,  111, -111,  143, 
-143,  175, -175,  207, -207,  239, -239,  271, 
-271,  303, -303,  335, -335,  367, -367,  399, 
-399,  431, -431,  463, -463,  495, -495,    0, 
   0,   51,  -51,   85,  -85,  119, -119,  153, 
-153,  187, -187,  221, -221,  255, -255,  289, 
-289,  323, -323,  357, -357,  391, -391,  425, 
-425,  459, -459,  493, -493,  527, -527,    0, 
   0,   53,  -53,   89,  -89,  125, -125,  161, 
-161,  197, -197,  233, -233,  269, -269,  305, 
-305,  341, -341,  377, -377,  413, -413,  449, 
-449,  485, -485,  521, -521,  557, -557,    0, 
   0,   57,  -57,   95,  -95,  133, -133,  171, 
-171,  209, -209,  247, -247,  285, -285,  323, 
-323,  361, -361,  399, -399,  437, -437,  475, 
-475,  513, -513,  551, -551,  589, -589,    0, 
   0,   59,  -59,   99,  -99,  139, -139,  179, 
-179,  219, -219,  259, -259,  299, -299,  339, 
-339,  379, -379,  419, -419,  459, -459,  499, 
-499,  539, -539,  579, -579,  619, -619,    0, 
   0,   63,  -63,  105, -105,  147, -147,  189, 
-189,  231, -231,  273, -273,  315, -315,  357, 
-357,  399, -399,  441, -441,  483, -483,  525, 
-525,  567, -567,  609, -609,  651, -651,    0, 
   0,   65,  -65,  109, -109,  153, -153,  197, 
-197,  241, -241,  285, -285,  329, -329,  373, 
-373,  417, -417,  461, -461,  505, -505,  549, 
-549,  593, -593,  637, -637,  681, -681,    0, 
   0,   69,  -69,  115, -115,  161, -161,  207, 
-207,  253, -253,  299, -299,  345, -345,  391, 
-391,  437, -437,  483, -483,  529, -529,  575, 
-575,  621, -621,  667, -667,  713, -713,    0, 
   0,   71,  -71,  119, -119,  167, -167,  215, 
-215,  263, -263,  311, -311,  359, -359,  407, 
-407,  455, -455,  503, -503,  551, -551,  599, 
-599,  647, -647,  695, -695,  743, -743,    0, 
   0,   75,  -75,  125, -125,  175, -175,  225, 
-225,  275, -275,  325, -325,  375, -375,  425, 
-425,  475, -475,  525, -525,  575, -575,  625, 
-625,  675, -675,  725, -725,  775, -775,    0, 
   0,   77,  -77,  129, -129,  181, -181,  233, 
-233,  285, -285,  337, -337,  389, -389,  441, 
-441,  493, -493,  545, -545,  597, -597,  649, 
-649,  701, -701,  753, -753,  805, -805,    0, 
   0,   81,  -81,  135, -135,  189, -189,  243, 
-243,  297, -297,  351, -351,  405, -405,  459, 
-459,  513, -513,  567, -567,  621, -621,  675, 
-675,  729, -729,  783, -783,  837, -837,    0, 
   0,   83,  -83,  139, -139,  195, -195,  251, 
-251,  307, -307,  363, -363,  419, -419,  475, 
-475,  531, -531,  587, -587,  643, -643,  699, 
-699,  755, -755,  811, -811,  867, -867,    0, 
   0,   87,  -87,  145, -145,  203, -203,  261, 
-261,  319, -319,  377, -377,  435, -435,  493, 
-493,  551, -551,  609, -609,  667, -667,  725, 
-725,  783, -783,  841, -841,  899, -899,    0, 
   0,   89,  -89,  149, -149,  209, -209,  269, 
-269,  329, -329,  389, -389,  449, -449,  509, 
-509,  569, -569,  629, -629,  689, -689,  749, 
-749,  809, -809,  869, -869,  929, -929,    0, 
   0,   93,  -93,  155, -155,  217, -217,  279, 
-279,  341, -341,  403, -403,  465, -465,  527, 
-527,  589, -589,  651, -651,  713, -713,  775, 
-775,  837, -837,  899, -899,  961, -961
};


U32 gTAB_ZZ_RUN[64]= { 0,  1,  8,  16, 9,  2,  3,  10,
                       17, 24, 32, 25, 18, 11, 4,  5,
					   12, 19, 26, 33, 40, 48, 41, 34, 
					   27, 20, 13, 6,  7,  14, 21, 28, 
					   35, 42, 49, 56, 57, 50, 43, 36, 
					   29, 22, 15, 23, 30, 37, 44, 51, 
					   58, 59, 52, 45, 38, 31, 39, 46,
					   53, 60, 61, 54, 47, 55, 62, 63
}
; //input is the cumulative run value
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d3bvriq.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

///////////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   22 Mar 1996 17:22:36  $
// $Archive:   S:\h26x\src\dec\d3bvriq.h_v  $
// $Header:   S:\h26x\src\dec\d3bvriq.h_v   1.5   22 Mar 1996 17:22:36   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3bvriq.h_v  $
;// 
;//    Rev 1.5   22 Mar 1996 17:22:36   AGUPTA2
;// Minor interface change to accomodate MMX rtns.  Now the interface is the
;// same for MMX and IA.
;// 
;//    Rev 1.4   14 Mar 1996 14:58:26   AGUPTA2
;// Added decls for MMX rtn.
;// 
;//    Rev 1.3   27 Dec 1995 14:36:10   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   09 Dec 1995 17:34:48   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB frames)
// 
//    Rev 1.1   27 Nov 1995 14:39:28   CZHU
// 
//    Rev 1.0   27 Nov 1995 14:37:10   CZHU
// Initial revision.


#ifndef __VLD_RLD_IQ_Block__
#define __VLD_RLD_IQ_Block__

extern "C" U32 VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX);

typedef U32 (*T_pFunc_VLD_RLD_IQ_Block)
    (T_BlkAction *,
	 U8 *,
     U32,
	 U32 *,
     U32 *);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d1rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Header:   S:\h26x\src\dec\d1rtp.cpv   1.3   24 Jan 1997 17:10:04   RHAZRA  $
// $Log:   S:\h26x\src\dec\d1rtp.cpv  $
// 
//    Rev 1.3   24 Jan 1997 17:10:04   RHAZRA
// Since the PPM now fills in 0 for QCIF, 1 for CIF and 2 for unknown
// in the trailer's source format field, we now check for the unknown
// format and bug out.
// 
//    Rev 1.2   10 Sep 1996 15:53:52   RHAZRA
// Added code to return motion vector predictor in RtpFindNextPacket().
// 
//    Rev 1.1   04 Sep 1996 09:47:24   RHAZRA
// No change.
// 
//    Rev 1.0   21 Aug 1996 18:35:34   RHAZRA
// Initial revision.
// 
//    Rev 1.4   23 Jul 1996 11:22:16   CZHU
// 
// Added a MV recovery. Hursitic will be added in later.
// 
//    Rev 1.3   15 Jul 1996 16:22:42   CZHU
// Added checking bitstream extension when PSC is lost.
// 
//    Rev 1.2   03 May 1996 13:04:22   CZHU
// Change logic such that bitstream verification is invoked only when bit erro
// is encountered.
// 
//    Rev 1.1   28 Apr 1996 21:18:58   BECHOLS
// Removed ifdef RTP_HEADER.
// 
//    Rev 1.0   22 Apr 1996 17:47:08   BECHOLS
// Initial revision.
// 
//    Rev 1.7   10 Apr 1996 13:35:58   CZHU
// 
// Added subroutine to recover picture header information from extended bitstr
// 
//    Rev 1.6   29 Mar 1996 14:39:56   CZHU
// 
// cleaning 
// 
//    Rev 1.5   29 Mar 1996 13:39:16   CZHU
// 
// Moved bs verification to c3rtp.cpp
// 
//    Rev 1.4   28 Mar 1996 18:40:28   CZHU
// Support packet loss recovery
// 
//    Rev 1.3   23 Feb 1996 16:21:22   CZHU
// No change.
// 
//    Rev 1.2   15 Feb 1996 12:01:50   CZHU
// 
// More clean up
// 
//    Rev 1.1   14 Feb 1996 15:00:10   CZHU
// Added support Mode A and Mode B
// 
//    Rev 1.0   12 Feb 1996 17:05:56   CZHU
// Initial revision.
// 
//    Rev 1.2   25 Jan 1996 16:13:54   CZHU
// changed name to the spec
// 
//    Rev 1.1   15 Dec 1995 13:07:30   CZHU
// 
//  
// 
//    Rev 1.0   11 Dec 1995 14:54:22   CZHU
// Initial revision.
*/

#include "precomp.h"

/*
 * RtpH263FindNextPacket() look through the extended bitstream and
 * find the next BITSTREAM_INFO structure that point to a valid packet
 * return indicates what mode the next packet is in mode A, or mode B,
 * mode C is not supported at this point.Chad, 3/28/96
 *
 */

I32 RtpH261FindNextPacket( //DC, fpbsState, &pN, fpMBInfo, &uNewMB, &uNewGOB)
	T_H263DecoderCatalog FAR * DC, 														  
	BITSTREAM_STATE FAR * fpbsState,
	U32 **pN,
	U32 *pQuant,
	int *pMB,
	int *pGOB
	)                      

{  I32 iret=ICERR_OK; 
//#ifdef LOSS_RECOVERY
   U32 u; 
   U32 uBitOffset;
   U32 uBitstream = (U32)((U32)DC + DC->X32_BitStream);
   T_RTP_H261_BSINFO *pBsInfo;
   U32 mask[]={0xff,0x7f, 0x3f, 0x1f,0x0f, 0x07, 0x03,0x01};
     //verify bitstream extension first

   if (!DC->iVerifiedBsExt)
   	 H26XRTP_VerifyBsInfoStream(DC,(U8 *)((U8 *)DC + DC->X32_BitStream),DC->Sz_BitStream);

   if (!DC->iValidBsExt) {
    iret=ICERR_UNSUPPORTED;
	goto done;
   }

   uBitOffset =  ((U32)fpbsState->fpu8 - uBitstream)*8 - 8 + fpbsState->uBitsReady;
   //travser through the BITSTREAM_INFO to find the next PACKET.
   //update pNewMB and pNewGOB if succeed, return Ok otherwise return error
   pBsInfo=(T_RTP_H261_BSINFO*)DC->pBsInfo;
   for ( u=0; u<DC->uNumOfPackets;u++)
   {
	 if (!(pBsInfo->uFlags & RTP_H26X_PACKET_LOST))
	 {
	   if (uBitOffset < pBsInfo->uBitOffset) break;
	 }
	 pBsInfo++;
   }
   //find it?
   if (u<DC->uNumOfPackets) //find next packet
   {
    if (pBsInfo->u8Quant == 0) 
    {	//adjust bit stream pointer according to received packet
		fpbsState->fpu8 = (U8 *)(uBitstream + pBsInfo->uBitOffset /8 );
		fpbsState->uBitsReady =	8 - pBsInfo->uBitOffset % 8;
		if (fpbsState->uBitsReady) 
		{
		fpbsState->uWork =(U32)*fpbsState->fpu8++;
		fpbsState->uWork &= mask[8- fpbsState->uBitsReady];
		}
		else
		 fpbsState->uWork =0;
			   //update m, g, MV in fpBlockAction, fpMBInfo for block type
	   *pGOB    = pBsInfo->u8GOBN;
	   *pMB     = pBsInfo->u8MBA;
	   *pQuant  = pBsInfo->u8Quant;

        DC->i8MVDH = pBsInfo->i8HMV;
        DC->i8MVDV = pBsInfo->i8VMV;

		iret = NEXT_MODE_STARTS_GOB;

    }
	else //read Quant, GOB, MBA, MVs, from Payload Header
	{  
	   //update m, g, MV in fpBlockAction, fpMBInfo for block type
	   *pGOB    = pBsInfo->u8GOBN;
	   *pMB     = pBsInfo->u8MBA;
	   *pQuant  = pBsInfo->u8Quant;

       DC->i8MVDH = pBsInfo->i8HMV;
       DC->i8MVDV = pBsInfo->i8VMV; 
	   
       //update the bit pointer and offset 
	   	fpbsState->fpu8 = (U8 *)(uBitstream + pBsInfo->uBitOffset / 8 );
		fpbsState->uBitsReady =	8 - pBsInfo->uBitOffset % 8;
		if (fpbsState->uBitsReady) 
		{
		fpbsState->uWork =(U32)*fpbsState->fpu8++;
		fpbsState->uWork &= mask[8- fpbsState->uBitsReady];
		}
		else
		 fpbsState->uWork =0;

	   iret = NEXT_MODE_STARTS_MB;
	   //file MV indexed by fpBlockAction,
	}

   }
   else // no more valid packet in this frame
   {	// need to set all the rest of MB to be not coded
	   iret = NEXT_MODE_LAST;
   }
done:
//#endif
   return iret;
}

/*
 * Use the extended bitstream to get the information lost
 * in the picture header
 */

I32 RtpGetPicHeaderFromBsExt(T_H263DecoderCatalog FAR * DC)
{I32 iret = ICERR_OK;
//#ifdef LOSS_RECOVERY
 T_H26X_RTP_BSINFO_TRAILER *pTrailer;

 if (!DC->iVerifiedBsExt)
 {
  H26XRTP_VerifyBsInfoStream(DC,(U8 *)((U8 *)DC + DC->X32_BitStream),DC->Sz_BitStream);
 }

 if (!DC->iValidBsExt) {
    iret=ICERR_UNSUPPORTED;
	goto done;
 }
 pTrailer = ( T_H26X_RTP_BSINFO_TRAILER *)DC->pBsTrailer;
 //update DC info for Pict header.Src, INTRA, TR, etc.
 DC->uTempRef   = pTrailer->u8TR;

 // PPM writes 0 for QCIF and 1 for CIF 
 ASSERT ( (pTrailer->u8Src != 2) )
 ASSERT ( (pTrailer->u8Src >= 0) && (pTrailer->u8Src < 2) )

 if (pTrailer->u8Src == 2) {  // PPM indicates a bad format using 2
	 iret = ICERR_UNSUPPORTED;
	 goto done;
 }
 DC->uSrcFormat = pTrailer->u8Src;
 DC->bFreezeRelease = 0;
 DC->bCameraOn = 0;
 DC->bSplitScreen = 0;
 DC->bKeyFrame = (U16) (pTrailer->uFlags & RTP_H26X_INTRA_CODED) ;//(U16) !uResult;
done:
//#endif
return iret;
}

/*
 * MVAdjustment(pBlackAction, iBlock, old_g, old_m, new_g, new_m)
 * reuse the motion vector from the GOB above, when current is lost
 * EXPERIMENTAL
 */
/* void MVAdjustment(
T_BlkAction  *fpBlockAction,
int iBlockNum, //block number
int iOld_gob,
int iOld_mb,
int iNew_gob,
int iNew_mb,
const int iNumberOfMBs
)
{ int i,j;
  T_BlkAction *pBA=fpBlockAction;
  int iAbove = -6 * iNumberOfMBs;

  for (i=iOld_gob*iNumberOfMBs+iOld_mb;i<iNew_gob*iNumberOfMBs+iNew_mb; i++,pBA += 6)
  {
   if ((i+iAbove) >= 0) 
	 for (j=0;j<6;j++)
     {   pBA[i+j].i8MVx2 = pBA[iAbove+i+j].i8MVx2;
	     pBA[i+j].i8MVy2 = pBA[iAbove+i+j].i8MVy2;
     }
  }
  return;
}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\d3idct.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   14 Mar 1996 14:56:42  $
// $Archive:   S:\h26x\src\dec\d3idct.h_v  $
// $Header:   S:\h26x\src\dec\d3idct.h_v   1.5   14 Mar 1996 14:56:42   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3idct.h_v  $
;// 
;//    Rev 1.5   14 Mar 1996 14:56:42   AGUPTA2
;// 
;//    Rev 1.4   27 Dec 1995 14:36:14   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.3   09 Dec 1995 17:34:26   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB Frames)
// 
//    Rev 1.1   27 Nov 1995 13:13:32   CZHU
// 
// 
//    Rev 1.0   27 Nov 1995 13:08:34   CZHU
// Initial revision.

////////////////////////////////////////////////////////////////////////////////
// Input: 
//       pIQ_INDEX,   pointer to pointer for Inverse quantization and index 
//                    for the current block.
//       No_Coeff,    A 32 bit number indicate block types, etc.
//                    0--63,   inter block, number of coeff
//                    64--127  64+ intra block, number of coeff
//       pIntraBuf,   Buffer pointer for intra blocks.
//
//       pInterBuf,   Buffer pointer for inter blocks.
//
//
// return:
//       
//////////////////////////////////////////////////////////////////////////////////
#ifndef _DECODE_BLOCK_IDCT_INC

#define _DECODE_BLOCK_IDCT_INC

extern U32 DecodeBlock_IDCT ( U32 pIQ_INDEX, 
                                 U32 No_Coeff, 
                                 U32 pIntraBuf, 
                                 U32 pInterBuf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\dxcolori.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MBODART  $
// $Date:   17 Dec 1996 10:36:46  $
// $Archive:   S:\h26x\src\dec\dxcolori.h_v  $
// $Header:   S:\h26x\src\dec\dxcolori.h_v   1.21   17 Dec 1996 10:36:46   MBODART  $
// $Log:   S:\h26x\src\dec\dxcolori.h_v  $
;// 
;//    Rev 1.21   17 Dec 1996 10:36:46   MBODART
;// Exlude function prototypes that either aren't used, or do not match,
;// those for H.261.
;// 
;//    Rev 1.20   16 Dec 1996 13:53:48   MDUDA
;// Adjusted output color convertor table to account for H263' problem
;// with MMX output color convertors (MMX width must be multiple of 8).
;// 
;//    Rev 1.19   09 Dec 1996 09:35:54   MDUDA
;// 
;// Some re-arrangement for H263P.
;// 
;//    Rev 1.18   29 Oct 1996 13:45:34   MDUDA
;// Added prototype for MMX_YUV12ToYUY2.
;// 
;//    Rev 1.17   06 Sep 1996 16:10:18   BNICKERS
;// 
;// Added Pentium Pro color convertor function prototypes.
;// 
;//    Rev 1.16   18 Jul 1996 09:24:56   KLILLEVO
;// implemented YUV12 color convertor (pitch changer) in assembly
;// and added it as a normal color convertor function, via the
;// ColorConvertorCatalog() call.
;// 
;//    Rev 1.15   19 Jun 1996 14:27:54   RHAZRA
;// 
;// added #define YUY2DDRAW 33, added YUY2 Init color convertor function
;// and the YUY2 color convertor to the list of color convertors.
;// 
;//    Rev 1.14   14 Jun 1996 17:27:48   AGUPTA2
;// Updated the color convertor table.
;// 
;//    Rev 1.13   30 May 1996 15:16:44   KLILLEVO
;// added YUV12 output
;// 
;//    Rev 1.12   30 May 1996 11:26:44   AGUPTA2
;// Added support for MMX color convertors.
;// 
;//    Rev 1.11   01 Apr 1996 10:26:36   BNICKERS
;// Add YUV12 to RGB32 color convertors.  Disable IF09.
;// 
;//    Rev 1.10   18 Mar 1996 09:58:52   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.9   05 Feb 1996 13:35:50   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.8   27 Dec 1995 14:36:18   RMCKENZX
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////

#define YUV12ForEnc           0   // Keep these assignments consistent with
#define CLUT8                 1   // assembly .inc file
#define CLUT8DCI              2
#define CLUT8ZoomBy2          3
#define CLUT8ZoomBy2DCI       4
#define RGB24                 5
#define RGB24DCI              6
#define RGB24ZoomBy2          7
#define RGB24ZoomBy2DCI       8
#define RGB16555              9
#define RGB16555DCI          10
#define RGB16555ZoomBy2      11
#define RGB16555ZoomBy2DCI   12  
#define IF09                 13
#define RGB16664             14
#define RGB16664DCI          15
#define RGB16664ZoomBy2      16
#define RGB16664ZoomBy2DCI   17 
#define RGB16565             18
#define RGB16565DCI          19
#define RGB16565ZoomBy2      20
#define RGB16565ZoomBy2DCI   21 
#define RGB16655             22
#define RGB16655DCI          23
#define RGB16655ZoomBy2      24
#define RGB16655ZoomBy2DCI   25 
#define CLUT8APDCI           26
#define CLUT8APZoomBy2DCI    27
#define RGB32                28
#define RGB32DCI             29
#define RGB32ZoomBy2         30
#define RGB32ZoomBy2DCI      31
#define YUV12NOPITCH         32
#define YUY2DDRAW            33

#define H26X_DEFAULT_BRIGHTNESS  128
#define H26X_DEFAULT_CONTRAST    128
#define H26X_DEFAULT_SATURATION  128

#if !defined(H263P)
enum {PENTIUM_CC = 0, PENTIUMPRO_CC, MMX_CC};
#endif

typedef struct {
  LRESULT (* Initializer) (      /* Ptr to color conv initializer function.   */
                           T_H263DecoderCatalog FAR *, UN);
#if defined(H263P)
  void (FAR ASM_CALLTYPE * ColorConvertor[2][3]) (  /* Ptr to color conv func.   */
        LPSTR YPlane,
        LPSTR VPlane,
        LPSTR UPlane,
        UN  FrameWidth,
        UN  FrameHeight,
        UN  YPitch,
        UN  VPitch,
        UN  AspectAdjustmentCount,
        LPSTR ColorConvertedFrame,
        U32 DCIOffset,
        U32 CCOffsetToLine0,
        int CCOPitch,
        int CCType);
#else
  void (FAR ASM_CALLTYPE * ColorConvertor[3]) (  /* Ptr to color conv func.   */
        LPSTR YPlane,
        LPSTR VPlane,
        LPSTR UPlane,
        UN  FrameWidth,
        UN  FrameHeight,
        UN  YPitch,
        UN  VPitch,
        UN  AspectAdjustmentCount,
        LPSTR ColorConvertedFrame,
        U32 DCIOffset,
        U32 CCOffsetToLine0,
        int CCOPitch,
        int CCType);
#endif
} T_H263ColorConvertorCatalog;

extern T_H263ColorConvertorCatalog ColorConvertorCatalog[];

LRESULT H26X_YVU12ForEnc_Init (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_CLUT8_Init       (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_YUY2_Init        (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_YUV_Init         (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_RGB16_Init       (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_RGB24_Init       (T_H263DecoderCatalog FAR *, UN); 
LRESULT H26X_RGB32_Init       (T_H263DecoderCatalog FAR *, UN); 
LRESULT H26X_CLUT8AP_Init     (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_CLUT8AP_InitReal (LPDECINST,T_H263DecoderCatalog FAR * , UN, BOOL);

extern "C" {
#if !defined(H261)
	long Convert_Y_8to7_Bit(HPBYTE, DWORD, DWORD, DWORD, HPBYTE, DWORD);
	long AspectCorrect(HPBYTE,HPBYTE,HPBYTE,DWORD,DWORD,WORD FAR *,
			           DWORD,HPBYTE,HPBYTE,DWORD,DWORD);
#endif
	void FAR ASM_CALLTYPE AdjustPels (
              U8 FAR * P16InstPostProcess, /* Base of PostFrm.                */
              X32 X32_Plane,               /* Offset to plane to adjust.      */
              DWORD Width,                 /* Width of plane.                 */
              DWORD Pitch,                 /* Pitch of plane.                 */
              DWORD Height,                /* Height of plane.                */
              X32 X16_AdjustmentTable);    /* Lookup table to do adjustment.  */
}

											 
extern "C" {
void FAR ASM_CALLTYPE
H26x_YUV12ForEnc       (U8 FAR*,X32,X32,X32,UN,UN,UN,U8 FAR *,X32,X32,X32);
void FAR ASM_CALLTYPE
YUV12ToCLUT8           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8ZoomBy2    (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB32           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB32ZoomBy2    (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB24           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB24ZoomBy2    (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB16           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB16ZoomBy2    (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToIF09            (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8AP         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8APZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToYUY2            (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToYUV             (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
}

// For now the YUY2 color convertor is in C

// extern void FAR ASM_CALLTYPE YUV12ToYUY2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\dxgetbit.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  dxgetbit.h
 *
 *  Description:
 *	  bit reading interface
 */

/*
 * $Header:   S:\h26x\src\dec\dxgetbit.h_v   1.5   27 Dec 1995 14:36:20   RMCKENZX  $
 * $Log:   S:\h26x\src\dec\dxgetbit.h_v  $
;// 
;//    Rev 1.5   27 Dec 1995 14:36:20   RMCKENZX
;// Added copyright notice
 */

#ifndef __DXGETBIT_H__
#define __DXGETBIT_H__

/*****************************************************************************
 *
 *  DESCRIPTION:
 *    The bit reading functions support reading from 1 to 24 bits from a 
 *    stream of bytes.  The most significant bit is read first.
 *
 *  VARIABLES:
 *    U8 FAR * fpu8 - pointer to a stream of bytes
 *	  U32 uWork - working storage
 *    U32 uBitsReady - the number of bits that have been read into the 
 *					   working storage
 * 	  U32 uCount - the number of bits
 *    U32 uResult - the output value
 *    BITSTREAM_STATE FAR * fpbsState - the bitstream state.
 *    U32 uCode - the code used to look up the uResult
 *    U32 uBitCount - number of bits in the code
 */

/*****************************************************************************
 * 
 *  The GetBitsMask is an array of masks indexed by the number of valid bits
 */
extern const U32 GetBitsMask[33]; 

/*****************************************************************************
 *
 *  The state of a stream can be represented using the following structure.
 *  This state structure can be passed between functions and used to initialize
 *  or reinitialize the bitstream.
 */
typedef struct {
	U8 FAR * fpu8;
	U32 uWork;
	U32 uBitsReady;
} BITSTREAM_STATE;

/*****************************************************************************
 *
 *  GET_BITS_INIT
 *
 *  Initialize the bit reading functions.
 *
 *  Parameters:
 *	  uBitsReady - OUT parameter
 *    uWork - OUT parameter
 */
#define GET_BITS_INIT(uWork, uBitsReady) {	\
	uBitsReady = 0;		 					\
	uWork = 0;								\
}

/*****************************************************************************
 *
 *  GET_BITS_SAVE_STATE
 *  
 *  Save the state
 *
 *  Parameters
 *    fpu8 - IN
 *    uBitsReady - IN
 *    uWork - IN
 *    fpbsState - OUT
 */
#define GET_BITS_SAVE_STATE(fp, uW, uBR, fpbs) { \
	fpbs->fpu8 = fp;				\
	fpbs->uBitsReady = uBR;			\
	fpbs->uWork = uW;				\
}

/*****************************************************************************
 *
 *  GET_BITS_RESTORE_STATE
 *
 *  Restore the state
 *
 *  Parameters
 */
#define GET_BITS_RESTORE_STATE(fp, uW, uBR, fpbs) { \
	 fp = fpbs->fpu8;				\
	 uBR = fpbs->uBitsReady;		\
	 uW = fpbs->uWork;				\
}

/*****************************************************************************
 *
 *  GET_FIXED_BITS
 *
 *  Read from 1 to 24 bits from the pointer.
 * 
 *  Parameters:
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 */
#define GET_FIXED_BITS(uCount, fpu8, uWork, uBitsReady, uResult) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* setup uBitsReady for next time */	\
	uBitsReady = uBitsReady - uCount;		\
	uResult = (uWork >> uBitsReady);		\
	uWork &= GetBitsMask[uBitsReady];		\
}

/*****************************************************************************
 *
 *  GET_ONE_BIT
 *
 *  Read 1 bit from the pointer. This is a special case of GET_FIXED_BITS 
 *  provided because of the possible assembly optimization advantages.
 * 
 *  Parameters:
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 */
#define GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult) {		\
	GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult)		\
}


/*****************************************************************************
 *
 *  GET_VARIABLE_BITS
 *
 *  Read a variable number of bits using a lookup table.	
 *
 *  The input count should be the number of bits used to index the table.  
 *  The output count is the number of bits in that symbol.
 *
 *  The table should be initialized such that all don't care symbols match to 
 *  the same value.  Thus if the table is indexed by 6-bits a two bit symbol 
 *  01XX XX will be used to initialize all entries 0100 00 -> 0111 11.  These
 *  entries will include an 8-bit length in the least significant byte.
 *
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 *    uCode - OUT
 *    fpTable - IN
 */
#define GET_VARIABLE_BITS(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpTable) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* calculate how much to shift off */	\
	/* and get the code */					\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);				\
	/* read the data */						\
	uResult = fpTable[uCode];				\
	/* count of bits used */   				\
	uBitCount = uResult & 0xFF;				\
	/* bits remaining */					\
	uBitsReady = uBitsReady - uBitCount;	\
	uWork &= GetBitsMask[uBitsReady];		\
}

#endif /* __DXGETBIT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\dxctrls.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;//
;// Description:    This module implements the following functions.
;//                     CustomChangeBrightness();
;//                     CustomChangeContrast();
;//                     CustomChangeSaturation();
;//                     CustomResetBrightness();
;//                     CustomResetContrast();
;//                     CustomResetSaturation();
;//                     CustomGetBrightness();
;//                     CustomGetContrast();
;//                     CustomGetSaturation();
;//
;// $Author:   BECHOLS  $
;// $Date:   09 Dec 1996 08:51:44  $
;// $Archive:   S:\h26x\src\dec\dxctrls.cpv  $
;// $Header:   S:\h26x\src\dec\dxctrls.cpv   1.14   09 Dec 1996 08:51:44   BECHOLS  $
;//	$Log:   S:\h26x\src\dec\dxctrls.cpv  $
// 
//    Rev 1.14   09 Dec 1996 08:51:44   BECHOLS
// Fixed reset saturation, so that it modified chroma table, not luma.
// 
//    Rev 1.13   20 Oct 1996 13:33:32   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.12   10 Sep 1996 10:31:38   KLILLEVO
// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
// 
//    Rev 1.11   11 Jul 1996 14:09:18   SCDAY
// Added comments re: CustomGetB/C/S functions
// 
//    Rev 1.10   10 Jul 1996 08:21:26   SCDAY
// Added functions for CustomGetBrightness/Contrast/Saturation (DBrucks)
// 
//    Rev 1.9   04 Jun 1996 09:04:00   AKASAI
// Fixed bug in CustomResetSaturation where it was reseting the LumaTable
// instead of the ChromaTable.  This was discovered in Quartz testing.
// 
//    Rev 1.8   01 Feb 1996 10:16:24   BNICKERS
// Fix the "knobs".
// 
//    Rev 1.7   22 Dec 1995 13:53:06   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.6   17 Nov 1995 15:22:12   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.5   01 Nov 1995 16:52:24   TRGARDOS
// Fixed unmatched GlobalUnlocks.
// 
//    Rev 1.4   25 Oct 1995 18:14:02   BNICKERS
// 
// Clean up archive stuff.
// 
//    Rev 1.3   20 Sep 1995 09:23:52   SCDAY
// 
// added #ifdef for #include d?dec.h
// 
//    Rev 1.2   01 Sep 1995 09:49:36   DBRUCKS
// checkin partial ajdust pels changes
// 
//    Rev 1.1   23 Aug 1995 12:24:04   DBRUCKS
// change to H26X_DEFAULT_* from H263_ as these are shared values.
// 
//    Rev 1.0   31 Jul 1995 13:00:14   DBRUCKS
// Initial revision.
// 
//    Rev 1.1   24 Jul 1995 15:00:40   CZHU
// 
// Adjust the changes to the decoder catalog structure
// 
//    Rev 1.0   17 Jul 1995 14:46:18   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:22   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#define SCALE               128
#define ACTIVE_RANGE        256
#define OFFSET_TABLE_COPY   256 + 16

typedef BOOL FAR *LPBOOL;
typedef struct {
    LPBYTE  LumaTable;
    LPBOOL  LumaFlag;
    LPBYTE  ChromaTable;
    LPBOOL  ChromaFlag;
    LPBYTE  Brightness;
    LPBYTE  Contrast;
    LPBYTE  Saturation;
    } PIXDAT, FAR *LPPIXDAT;

/**********************************************************************
 * static WORD LockLCTables(LPDECINST, LPPIXDAT);
 * Description:    This function locks the memory and fills the Pixel Data
 *                 Structure with valid pointers to the tables that I need
 *                 to adjust.
 * History:        06/29/94 -BEN-
 **********************************************************************/
static LRESULT LockLCTables(LPDECINST lpInst, LPPIXDAT lpPixData)
{
	T_H263DecoderCatalog *DC;

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO))) 
    {
		DBOUT("ERROR :: LockLCTables :: ICERR_BADPARAM");
		return(ICERR_BADPARAM);
	}
	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	lpPixData->LumaTable = (LPBYTE)(DC->p16InstPostProcess +
								    DC->X16_LumaAdjustment);
	lpPixData->ChromaTable = (LPBYTE)(DC->p16InstPostProcess +
									  DC->X16_ChromaAdjustment);
	lpPixData->LumaFlag = (LPBOOL)&(DC->bAdjustLuma);
	lpPixData->ChromaFlag = (LPBOOL)&(DC->bAdjustChroma);
	lpPixData->Brightness = (LPBYTE)&(DC->BrightnessSetting);
	lpPixData->Contrast = (LPBYTE)&(DC->ContrastSetting);
	lpPixData->Saturation = (LPBYTE)&(DC->SaturationSetting);

	return(ICERR_OK);
}

/*********************************************************************
 * static LRESULT UnlockLCTables(LPDECINST, LPPIXDAT);
 * Description:    This funtion unlocks
 * History:        06/30/94 -BEN-
 **********************************************************************/
static LRESULT UnlockLCTables(LPDECINST lpInst, LPPIXDAT lpPixData)
{
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	lpPixData->LumaTable = (LPBYTE)NULL;
	lpPixData->ChromaTable = (LPBYTE)NULL;
	lpPixData->LumaFlag = (LPBOOL)NULL;
	lpPixData->ChromaFlag = (LPBOOL)NULL;

	return(ICERR_OK);
}

/**********************************************************************
 * static VOID MassageContrast(BYTE, PBYTE);
 * Description:    input is 0 to 255, 1/SCALE to 256/SCALE inclusive
 *                 0 = 1/SCALE
 *                 1 = 2/SCALE
 *                 n = (n + 1) / SCALE
 *                 SCALE - 1 = 1        yields no change
 *                 255 = 256/SCALE
 *                 if the response is too coarse, SCALE can be increased
 *                 if the response is too fine, SCALE can be decreased
 *
 * History:        02/22/94 -BEN-  Added header.
 **********************************************************************/
static VOID MassageContrast(BYTE offsetfactor, LPBYTE table)
    {
    int i;
    long temp, contrastfactor;

    contrastfactor = ((long)((DWORD)offsetfactor)) + 1; // 1 - 256
    contrastfactor = (contrastfactor * ACTIVE_RANGE) / 256L;
    for(i = 0; i < 256; i++)
        {
        temp = (long)((DWORD)table[i]);
        temp -= (ACTIVE_RANGE / 2L);                    // add centering
        temp *= contrastfactor;
        temp /= SCALE;
        temp += (ACTIVE_RANGE / 2L);                    // remove centering
        if(temp < 0)                                    // and clamp
            table[i] = 0;
        else if(temp <= 255)
            table[i] = (unsigned char) temp;
        else
            table[i] = 255;
        table[i+OFFSET_TABLE_COPY] = table[i];
        }
    return;
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeBrightness(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeBrightness(LPDECINST lpInst, BYTE offsetdelta)
    {
    LRESULT lRes;
    int     delta, temp, i;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetBrightness(lpInst);
        if(offsetdelta != H26X_DEFAULT_BRIGHTNESS)
            {
            delta = ((offsetdelta - 128) * ACTIVE_RANGE) / 256; // -128 to 127
            for(i = 0; i < 256; i++)
                {
                temp = (int)PixData.LumaTable[i] + delta;
                if(temp < 0) PixData.LumaTable[i] = 0;
                else if(temp <= 255) PixData.LumaTable[i] = (BYTE)temp;
                else PixData.LumaTable[i] = 255;
                PixData.LumaTable[i+OFFSET_TABLE_COPY] = PixData.LumaTable[i];
                }
            *(PixData.Brightness) = offsetdelta;
            *(PixData.LumaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeContrast(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeContrast(LPDECINST lpInst, BYTE offsetfactor)
    {
    LRESULT lRes;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetContrast(lpInst);
        if(offsetfactor != H26X_DEFAULT_CONTRAST)
            {
            MassageContrast(offsetfactor, PixData.LumaTable);
            *(PixData.Contrast) = offsetfactor;
            *(PixData.LumaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeSaturation(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeSaturation(LPDECINST lpInst, BYTE offsetfactor)
    {
    LRESULT lRes;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetSaturation(lpInst);
        if(offsetfactor != H26X_DEFAULT_SATURATION)
            {
            MassageContrast(offsetfactor, PixData.ChromaTable);
            *(PixData.Saturation) = offsetfactor;
            *(PixData.ChromaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }
#ifdef QUARTZ

/************************************************************************
 *  CustomGetBrightness
 *
 *  Gets the current brightness value
 ***********************************************************************/
LRESULT CustomGetBrightness(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->BrightnessSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetBrightness() */

/************************************************************************
 *  CustomGetContrast
 *
 *  Gets the current contrast value
 ***********************************************************************/
LRESULT CustomGetContrast(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->ContrastSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetContrast() */

/************************************************************************
 *
 *  CustomGetSaturation
 *
 *  Gets the current saturation value
 ***********************************************************************/
LRESULT CustomGetSaturation(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->SaturationSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetSaturation() */

#endif /* QUARTZ */


;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetBrightness(LPDECINST lpInst);
;//
;// Description:    Sets the luminance table to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetBrightness(LPDECINST lpInst)
{
    LRESULT lRes;
    int i;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
    {
        for(i = 0; i < 256; i++) 
        {
            PixData.LumaTable[i] = i;
            PixData.LumaTable[i+OFFSET_TABLE_COPY] = i;
        }
        *(PixData.LumaFlag) = FALSE;
        *(PixData.Brightness) = H26X_DEFAULT_BRIGHTNESS;
        if(*(PixData.Contrast) != H26X_DEFAULT_CONTRAST)
            CustomChangeContrast(lpInst, *(PixData.Contrast));
        lRes = UnlockLCTables(lpInst, &PixData);
    }

    return(lRes);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetContrast(LPDECINST lpInst);
;//
;// Description:    Sets the luminance table to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetContrast(LPDECINST lpInst)
{
    LRESULT lRes;
    int i;
    PIXDAT  PixData;
    
    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
    {
        for(i = 0; i < 256; i++) 
        {
            PixData.LumaTable[i] = i;
            PixData.LumaTable[i+OFFSET_TABLE_COPY] = i;
        }
        *(PixData.LumaFlag) = FALSE;
        *(PixData.Contrast) = H26X_DEFAULT_CONTRAST;
        if(*(PixData.Brightness) != H26X_DEFAULT_BRIGHTNESS)
            CustomChangeBrightness(lpInst, *(PixData.Brightness));
        lRes = UnlockLCTables(lpInst, &PixData);
    }
    
    return(lRes);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetSaturation(LPDECINST);
;//
;// Description:    Sets chroma tables to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetSaturation(LPDECINST lpInst)
{
    LRESULT lRes;
    int i;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
    {
        for(i = 0; i < 256; i++) 
        {
            PixData.ChromaTable[i] = i;
            PixData.ChromaTable[i+OFFSET_TABLE_COPY] = i;
        }
        *(PixData.ChromaFlag) = FALSE;
        *(PixData.Saturation) = H26X_DEFAULT_SATURATION;
        lRes = UnlockLCTables(lpInst, &PixData);
    }

    return(lRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\e1enc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * e1enc.cpp
 *
 * DESCRIPTION:
 *		Specific encoder compression functions.
 *
 * Routines:					Prototypes in:
 *  H263InitEncoderInstance			
 * 	H263Compress
 *  H263TermEncoderInstance
 */

// $Header:   S:\h26x\src\enc\e1enc.cpv   1.78   15 Apr 1997 10:24:48   AGUPTA2  $
// $Log:   S:\h26x\src\enc\e1enc.cpv  $
// 
//    Rev 1.78   15 Apr 1997 10:24:48   AGUPTA2
// Added checks to ensure 1) bit-stream is less than (8,32)K  and 2)
// extended bitstream is less than allocated buffer size.
// 
//    Rev 1.77   24 Jan 1997 17:12:06   RHAZRA
// We were computing the size of the bitstream to be one more than
// the real size. Now fixed.
// 
//    Rev 1.76   17 Dec 1996 09:07:16   SCDAY
// changed an ASSERT to handle Memory Layout changes
// 
//    Rev 1.75   16 Dec 1996 17:36:04   MBODART
// Applied Raj's changes for tweaking ME parameters under RTP.
// Also restructured some code for cleanliness.
// 
//    Rev 1.74   13 Dec 1996 17:19:02   MBODART
// Bumped the ME SLF parameters for MMX.
// 
//    Rev 1.73   13 Dec 1996 15:17:02   MBODART
// Adjusted the motion estimation IA spatial loop filter parameters.
// Still need to tune the MMX parameters.
// 
//    Rev 1.72   05 Dec 1996 10:56:14   MBODART
// Added h261test.ini options for playing with motion estimation parameters.
// 
//    Rev 1.71   04 Dec 1996 13:23:34   MBODART
// Tweaked some DbgLog messages to aid bit rate tuning.
// Removed some unused code.
// 
//    Rev 1.70   21 Nov 1996 10:50:32   RHAZRA
// Changed recompression strategy to be more pessimistic with key
// frames since a buffer overflow on a keyframe can cause a host
// of secondary effects.
// 
//    Rev 1.69   18 Nov 1996 17:11:38   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.68   18 Nov 1996 09:02:34   RHAZRA
// Now no DWORD 0 at the end of the bitstream for both the MMX and IA
// codecs.
// 
//    Rev 1.67   15 Nov 1996 09:47:22   RHAZRA
// #ifdef ed out the addition of a DWORD of zeros at the end of the bitstream.
// 
//    Rev 1.66   13 Nov 1996 11:37:20   RHAZRA
// Added MMX autosensing
// 
//    Rev 1.65   21 Oct 1996 10:45:50   RHAZRA
// Changed interface to EDTQ function to keep in sync with exmme.asm which
// now has EMV
// 
//    Rev 1.64   21 Oct 1996 09:00:18   RHAZRA
// MMX integration
// 
//    Rev 1.62   16 Sep 1996 13:17:44   RHAZRA
// Added support for SLF to be adaptively turned on and off via
// coding thresholds and differentials.
// 
//    Rev 1.61   06 Sep 1996 15:04:52   MBODART
// Added performance counters for NT's perfmon.
// New files:  cxprf.cpp, cxprf.h, cxprfmac.h.
// New directory:  src\perf
// Updated files:  e1enc.{h,cpp}, d1dec.{h,cpp}, cdrvdefs.h, h261* makefiles.
// 
//    Rev 1.60   26 Aug 1996 10:09:02   RHAZRA
// Added checking to ensure that RTP BS Info stream is rewound on
// GOB recompression only if RTP is signalled. This fixes the reported
// failure of build 29 on q1502stl.avi @ 100Kbps.
// 
//    Rev 1.59   21 Aug 1996 19:01:18   RHAZRA
// Added RTP extended bitstream generation
// 
//    Rev 1.58   21 Jun 1996 10:06:06   AKASAI
// Changes to e1enc.cpp, e1mbenc.cpp, ex5me.asm to support "improved
// bit rate control", changing MacroBlock Quantization within a
// row of MB's in addition to changing the Quantization change
// between rows of macro blocks.
// 
// ex5me.asm had a problem with SLF SWD.  Brian updated asm code.
// 
// 
//    Rev 1.57   05 Jun 1996 13:56:52   AKASAI
// Changes to e1enc.cpp:  Added new parameter to MOTIONESTIMATION which
// allows for 15 pel radius search otherwise (? maybe 7 pels).
// 
// Changes to e1enc.h:  New parameter to MOTIONESTIMATION and change to
// offsets in MBAcationStream to match changes in e3mbad.inc, ex5me.asm
// and ex5fdct.asm.
// 
//    Rev 1.56   29 May 1996 13:53:00   AKASAI
// Tuned the Motion Estimation parameters.  Video quality
// seems to remain about the same, bit rate increased a little (200 bits
// per frame), CPU usage decreased a little.
// 
//    Rev 1.55   14 May 1996 12:33:10   AKASAI
// Got an undefined on wsprintf so moved it to a #ifdef DEBUG_RECOMPRESS
// area.
// 
//    Rev 1.54   14 May 1996 10:33:46   AKASAI
// Two files changed to hopefully eliminate Quantization clamping 
// artifacts and to reduce the max buffer overflow case: e1enc.cpp
// and e1mbenc.cpp.
// 
// In e1mbenc.cpp when the MQuant level is < 6 I test to see if
// the 0th coefficient is larger than the values representable
// at that Quant level if it is I increase the Quant level until
// the clamping artifact will not occur.  Note: I am test only 
// the Oth coefficient, there is the possibility that some other
// coefficient is larger but the performance trade off seems to
// indicate this is good for now and if we still see clamping
// artifacts we can add more testing later.
// 
// In e1enc.cpp I modified when the Overflow types of warnings are
// turn on as well as changing the rate the Quantization level
// changes at.
// 
//    Rev 1.53   24 Apr 1996 12:13:50   AKASAI
// Added re-compression strategy to encoder.  Had to change e1enc.cpp,
// e1enc.h and e1mbenc.cpp.  
// Basic strategy is if spending too many bits in a GOB quantize the
// next GOB at a higher rate.  If after compressing the frame too
// many bits have been used, re-compress the last GOB at a higher
// QUANT level if that still doesn't work send a "Skip" GOB.
// Needed to add extra parameter to GOB+Q_RLE_VLC_WriteBS because
// CalcMBQuant kept decreasing the QUANT when we were in trouble with
// possibly overflowing the buffer.
// 
//    Rev 1.52   22 Apr 1996 10:54:24   AKASAI
// Two files changed e1enc.cpp and e1mbenc.cpp to try and support
// allowing the Quantization values to go down to 2 instead of
// CLAMP to 6.
// This is part 1 of implementing the re-compression (what to do
// if exceed max compressed buffer size 8KBytes QCIF, 32KBytes FCIF).
// Also changed in e1enc was to limit request uFrameSize to 8KB or
// 32KB.  Problem was if user specified too large of a datarate
// request frame size would be larger than the allowed buffer size.
// If you try to compress qnoise10.avi or fnoise5.avi you get an
// ASSERT error until rest of re-compression is implemented.
// 
//    Rev 1.51   19 Apr 1996 14:26:26   SCDAY
// Added adaptive bit usage profile (Karl's BRC changes)
// 
//    Rev 1.50   15 Apr 1996 14:10:30   AKASAI
// Updated range to allow for +/- 15 pel search.  There was and assert
// if MV outside +/- 15 (in half pel numbers) now assert if [-32,31].
// 
//    Rev 1.49   11 Apr 1996 16:00:02   AKASAI
// Updated H261 encoder to new interface and macroblock action stream
// data structure in e3mbad.inc for FORWARDDCT.  Files updated together
// e1enc.cpp, e1enc.h, ex5fdct.asm, e3mbad.inc.
// 
// Added IFNDEF H261 in ex5fdct so that code used only in H263 is
// not assembled for H261.
// 
//    Rev 1.48   11 Apr 1996 13:02:04   SCDAY
// Fixed zero dirty buffer problem
// 
//    Rev 1.45   10 Apr 1996 13:06:40   SCDAY
// Changed clearing of bitstream buffer to zero only the "dirty"
// part of the buffer rather than the entire buffer
// 
//    Rev 1.44   05 Apr 1996 14:36:28   SCDAY
// 
// Added ASM version of UV SLF
// 
//    Rev 1.43   04 Apr 1996 13:45:32   AKASAI
// Added 2 Bytes, 16-bits of zeros at end of bitstream to help 16-bit
// decoder find end of frame.  Under testing we saw green blocks at
// end of frame.
// 
//    Rev 1.42   27 Mar 1996 15:09:52   SCDAY
// Moved declarations/definition of H26X_YUV12toEncYUV12 to excolcnv.cpp
// to incorporate latest H263 changes and SCD 'C' code optimization
// 
//    Rev 1.41   20 Mar 1996 14:21:04   Sylvia_C_Day
// Added lower level timing stats for SLF_UV
// 
//    Rev 1.40   26 Feb 1996 10:09:34   AKASAI
// Corrected PicFreeze bit last fix set it to always ON instead of the
// correct usage.  ON for Keys OFF for deltas.  
// Also fixed 2 other bits that were set incorrectly.  HI_RES and SPARE.
// SPARE should always be 1, HI_RES should be OFF (which is 1 for this
// bit).
// 
//    Rev 1.39   14 Feb 1996 14:53:56   AKASAI
// Added work around for Blazer team to set PicFreeze to ON when 
// encoding a KEY FRAME.
// 
//    Rev 1.38   06 Feb 1996 09:46:00   AKASAI
// Updated Copyright to include 1996.
// 
//    Rev 1.37   05 Feb 1996 15:24:04   AKASAI
// Changes to support new BRC interface.  Tested with RING3 codec.
// 
//    Rev 1.36   09 Jan 1996 08:52:34   AKASAI
// 
// Added U&V plane loop filter.  To enable make sure SLF_WORK_AROUND
// is defined in makefile.
// 
//    Rev 1.35   08 Jan 1996 10:11:58   DBRUCKS
// Disable half pel interpolation of U & V motion vectors in fdct
// Change to use divide and not shift when calculating U & V motion vectors
// in order that we truncate towards zero as the spec requires.
// 
//    Rev 1.34   29 Dec 1995 18:12:54   DBRUCKS
// 
// add clamp_n_to(qp,6,31) to avoid clipping artifacts.
// add code to assign Y2,3,4-PrevPtr based on Y1-PrevPtr for SLF blocks
// 
//    Rev 1.33   27 Dec 1995 16:51:54   DBRUCKS
// move the increment of InterCodeCnt to e1mbenc.cpp
// cleanup based on H263 v11
// remove unused definitions
// 
//    Rev 1.32   26 Dec 1995 17:44:52   DBRUCKS
// moved statistics to e1stat
// 
//    Rev 1.31   20 Dec 1995 16:46:02   DBRUCKS
// get Spox to compile with the timing code
// 
//    Rev 1.30   20 Dec 1995 15:35:08   DBRUCKS
// get to build without ENC_STATS define
// 
//    Rev 1.29   20 Dec 1995 14:56:50   DBRUCKS
// add timing stats
// 
//    Rev 1.28   18 Dec 1995 15:38:02   DBRUCKS
// improve stats
// 
//    Rev 1.27   13 Dec 1995 13:58:18   DBRUCKS
// 
// moved trace and cnvt_fdct_output to exutil.cpp
// removed BitRev as it was not used
// changed to call terminate if init was called with Initialized == True
// implemented TR
// 
//    Rev 1.26   07 Dec 1995 12:53:38   DBRUCKS
// 
// add an ifdef so the ring0 release build succeeds
// change the quality to quant from conversion to use 3 to 31
// fix mb first state initialization for CIF
// 
//    Rev 1.25   06 Dec 1995 09:43:38   DBRUCKS
// 
// initialize blazer COMPINSTINFO variables
// integrate blazer bit rate control into Compress
// remove LINK_ME
// 
//    Rev 1.24   04 Dec 1995 10:26:28   DBRUCKS
// cleanup the ini file reading function
// 
//    Rev 1.23   01 Dec 1995 15:37:56   DBRUCKS
// 
// Added the bit rate controller
// set the default options (if no INI file) to:
// RING0: MotionEstimation SpatialLoopFilter FixedQuantization of 8
// RING3: MotionEstimation SpatialLoopFilter VfW driven Bit Rate Control
// 
//    Rev 1.20   28 Nov 1995 13:21:30   DBRUCKS
// add BRC options
// change to read options from an ini file - h261.ini
// 
//    Rev 1.19   27 Nov 1995 17:53:42   DBRUCKS
// add spatial loop filtering
// 
//    Rev 1.18   27 Nov 1995 16:41:44   DBRUCKS
// replace B and Future planes with SLF
// remove the scratch space
// 
//    Rev 1.17   22 Nov 1995 18:21:42   DBRUCKS
// Add an #ifdef around the MOTIONESTIMATION call in order that the IASpox
// environment not be required to call MOTIONESTIMATION when advancing the
// tip.  Unless LINK_ME is defined MOTIONESTIMATION will not be called.
// 
//    Rev 1.16   22 Nov 1995 17:37:36   DBRUCKS
// cleanup me changes
// 
//    Rev 1.15   22 Nov 1995 15:34:30   DBRUCKS
// 
// Motion Estimation works - but needs to be cleaned up
// 
//    Rev 1.14   20 Nov 1995 12:13:14   DBRUCKS
// Cleanup the encoder terminate function
// Integrate in the picture checksum code (CHECKSUM_PICTURE)
// 
//    Rev 1.13   17 Nov 1995 14:25:24   BECHOLS
// Made modifications so that this file can be made for ring 0.
// 
//    Rev 1.12   15 Nov 1995 19:05:22   AKASAI
// Cleaned up some warning messages.
// 
//    Rev 1.11   15 Nov 1995 14:38:16   AKASAI
// 
// Current and Previous frame pointers changed from Addresses to Offsets.
// Change of parameters to call to FOWARDDCT.  Some Union thing.
// (Integration point)
// 
//    Rev 1.10   01 Nov 1995 09:01:12   DBRUCKS
// 
// cleanup variable names
// add ZERO_INPUT test option
// make sure all frames end on a byte boundary.
// 
//    Rev 1.9   27 Oct 1995 17:19:52   DBRUCKS
// initializing PastRef ptrs
// 
//    Rev 1.8   27 Oct 1995 15:06:26   DBRUCKS
// update cnvt_fdct_output
// 
//    Rev 1.7   27 Oct 1995 14:31:10   DBRUCKS
// integrate 0-MV delta support based on 263 baseline
// 
//    Rev 1.6   28 Sep 1995 17:02:34   DBRUCKS
// fix colorIn to not swap left to right
// 
//    Rev 1.5   28 Sep 1995 15:58:20   DBRUCKS
// remove pragmas
// 
//    Rev 1.4   28 Sep 1995 14:21:30   DBRUCKS
// fix to match INTRA and INTER enum changes
// 
//    Rev 1.3   25 Sep 1995 10:22:48   DBRUCKS
// activate call to InitVLC
// 
//    Rev 1.2   20 Sep 1995 12:38:48   DBRUCKS
// cleanup
// 
//    Rev 1.0   18 Sep 1995 10:09:30   DBRUCKS
// Initial revision after the archive got corrupted.
// 
//    Rev 1.4   15 Sep 1995 12:27:32   DBRUCKS
// intra mb header
// 
//    Rev 1.3   14 Sep 1995 17:16:08   DBRUCKS
// turn on FDCT and some cleanup
// 
//    Rev 1.2   14 Sep 1995 14:18:52   DBRUCKS
// init mb action stream
// 
//    Rev 1.1   13 Sep 1995 13:41:50   DBRUCKS
// move the picture header writing into a separate routine.
// implement the gob header writing.
// 
//    Rev 1.0   12 Sep 1995 15:53:40   DBRUCKS
// initial
//

#define DUMPFILE 0

/* Pick a resiliency strategy.
 */
#define REQUESTED_KEY_FRAME 0
#define PERIODIC_KEY_FRAME  1
#define FAST_RECOVERY       2
#define SLOW_RECOVERY       3

#define MAX_STUFFING_BYTES  10

#define RESILIENCY_STRATEGY PERIODIC_KEY_FRAME

#define PERIODIC_KEY_FRAME_PERIODICITY 15     /* Select periodicity (max 32767) */

#define UNRESTRICTED_MOTION_FRAMES 16 /* Number of frames that don't have an Intra slice.  0 for FAST_RECOVERY.
                                       * Modest amount for SLOW_RECOVERY. Unimportant for other strategies. */

#include "precomp.h"

#ifdef ENCODE_STATS
#define ENCODE_STATS_FILENAME "encstats.txt"
#endif

#define PITCHL 384L
#define DEFAULT_DCSTEP 8
#define DEFAULT_QUANTSTEP 36
#define DEFAULT_QUANTSTART 30

#define LEFT        0
#define INNERCOL    1
#define NEARRIGHT   2
#define RIGHT       3

#define TOP         0
#define INNERROW    4
#define NEARBOTTOM  8
#define BOTTOM     12

#define FCIF_NUM_OF_GOBS 12
#define QCIF_NUM_OF_GOBS 3

#if defined(_DEBUG) || defined(DEBUG_RECOMPRESS) || defined(DEBUG_ENC) || defined(DEBUG_BRC)
char string[128];
#endif

/* Look up table for quarter pel to half pel conversion of chroma MV's. */
const char QtrPelToHalfPel[64] =
 { -16, -15, -15, -15, -14,	-13, -13, -13, -12,	-11, -11, -11, -10, -9, -9, -9, -8,
         -7,  -7,  -7,  -6,  -5,  -5,  -5,  -4,  -3,  -3,  -3,  -2, -1, -1, -1,  0,
	      1,   1,   1,   2,   3,   3,   3,   4,   5,   5,   5,   6,  7,  7,  7,  8,
	      9,   9,   9,  10,  11,  11,  11,  12,  13,  13,  13,  14, 15, 15, 15 };

/* The GOB number arrays contain the GOB numbers for QCIF and CIF.  The lists are zero terminated.
 */
static U32 uCIFGOBNumbers[] = {1,2,3,4,5,6,7,8,9,10,11,12,0};
static U32 uQCIFGOBNumbers[] = {1,3,5,0};

/* The starting INTER Motion Estimation states are different for QCIF and CIF.  
 */
#define MAX_ME_STATE_ROW_NUMBER 8
#define BAD_ME_ROW (MAX_ME_STATE_ROW_NUMBER + 1)
static U8 u8FirstInterMEStateRows[MAX_ME_STATE_ROW_NUMBER+1][11] =
{  /* 1            2            3            4			  5			   6		    7		     8			  9		      10		   11 */
 {UpperLeft,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperRight},
 {LeftEdge,    CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,RightEdge},
 {LowerLeft,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerRight},
 
 {UpperLeft,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge},
 {UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperRight},

 {LeftEdge,    CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock},
 {CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,RightEdge},

 {LowerLeft,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge},
 {LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerRight},
};

//RTP: resiliency tables.

static U8 u8FirstInterMENoVerMVStateRows[MAX_ME_STATE_ROW_NUMBER+1][11] =
{  /* 1                     2                 3                 4			        5			       6		          7		             8			        9		           10		          11 */
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},
 {NoVertLeftEdge,    NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertRightEdge},
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},
 
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock},
 {NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},

 {NoVertLeftEdge,    NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock},
 {NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertRightEdge},

 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock},
 {NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},
};

static U8 u8FirstInterMENoPosVerMVStateRows[MAX_ME_STATE_ROW_NUMBER+1][11] =
{  /* 1            2            3            4			  5			   6		    7		     8			  9		      10		   11 */
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},
 {LowerLeft,    LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerRight},
 {LowerLeft,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerRight},
 
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock},
 {NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},

 {LowerLeft,    LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge},
 {LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerRight},

 {LowerLeft,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge},
 {LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerRight},
};
                                                       
static U8 u8MEPad[1];
static U8 u8QCIFFirstInterMEStateRowNumbers[12] = 
			{0,1,1, 1,1,1, 1,1,2, BAD_ME_ROW,BAD_ME_ROW,BAD_ME_ROW};
static U8 u8CIFFirstInterMEStateRowNumbers[40] = 
			{3,5,5, 4,6,6, 5,5,5, 6,6,6, 5,5,5, 6,6,6, 5,5,5, 6,6,6, 5,5,5, 6,6,6, 5,5,7, 6,6,8, BAD_ME_ROW,BAD_ME_ROW,BAD_ME_ROW,BAD_ME_ROW}; 

/* The starting offsets for each of the GOBs
 * - odd GOBs:  NumberOfGOBsAbove * PITCH * 3MacroBlocksToAGOB * NumberOfLinesToAMacroBlock
 * - even GOBs:	oddGobValue + 11MacroBlocksToAGOB * NumberOfColumnsToAMacroBlock
 */
static U32 uStartingYOffsets[16] =
{ 
	0, /* not used */
	0*PITCH*3*16, 0*PITCH*3*16+11*16,		// 1 and 2
	1*PITCH*3*16, 1*PITCH*3*16+11*16,		// 3 and 4
	2*PITCH*3*16, 2*PITCH*3*16+11*16,		// 5 and 6
	3*PITCH*3*16, 3*PITCH*3*16+11*16,		// 7 and 8
	4*PITCH*3*16, 4*PITCH*3*16+11*16,		// 9 and 10
	5*PITCH*3*16, 5*PITCH*3*16+11*16,		// 11 and 12
	0, 0, 0 /* not used */
};
static U32 uStartingUOffsets[16] =
{
	0, /* not used */
	0*PITCH*3*8, 0*PITCH*3*8+11*8,		// 1 and 2
	1*PITCH*3*8, 1*PITCH*3*8+11*8,		// 3 and 4
	2*PITCH*3*8, 2*PITCH*3*8+11*8,		// 5 and 6
	3*PITCH*3*8, 3*PITCH*3*8+11*8,		// 7 and 8
	4*PITCH*3*8, 4*PITCH*3*8+11*8,		// 9 and 10
	5*PITCH*3*8, 5*PITCH*3*8+11*8,		// 11 and 12
	0, 0, 0
};

/* Table to limit Quant changes between Rows of Marco Blocks */
U8 MaxChangeRowMBTbl[32] = 
	{ 0,		/* Not Used */
	  1,		/* Not Used when clamp to (2,31) */
	  1,		/* 2 */
	  2,		/* 3 */
	  2,		/* 4 */
	  3,		/* 5 */
	  3,		/* 6 */
	  3,		/* 7 */
	  3,		/* 8 */
	  3,		/* 9 */
	  3,		/* 10 */
	  3,		/* 11 */
	  3,		/* 12 */
	  3,		/* 13 */
	  3,		/* 14 */
	  3,		/* 15 */
	  3,		/* 16 */
	  3,		/* 17 */
	  3,		/* 18 */
	  3,		/* 19 */
	  3,		/* 20 */
	  3,		/* 21 */
	  3,		/* 22 */
	  3,		/* 23 */
	  4,		/* 24 */
	  4,		/* 25 */
	  4,		/* 26 */
	  4,		/* 27 */
	  4,		/* 28 */
	  4,		/* 29 */
	  4,		/* 30 */
	  4			/* 31 */
	};

U8 INTERCODECNT_ADJUST[11]=

//                         Packet loss (in %)        
//  0-9  10-19  20-29  30-39  40-49  50-59  60-69  70-79  80-89  90-99  100 
//                          Refresh limit 
{   132,  100,   80,    75,    60,    45,    20,    10,    5,     3,    1  };

U32 EMPTYTHRESHOLD_ADJUST[5]=

//      Packet loss (in %)        
//  0-24  25-49  50-74  75-99  100
//         Multiplier
{    1,     2,    3,     4,     10};

/* Static Function declarations
 */
static void WriteBeginPictureHeaderToStream(T_H263EncoderCatalog *, U8 ** ,U8 *);

#ifdef CHECKSUM_PICTURE
static void WritePictureChecksum(YVUCheckSum *, U8 ** ,U8 *, U8);
#endif

static void WriteEndPictureHeaderToStream(T_H263EncoderCatalog *, U8 ** ,U8 *);

static void WriteGOBHeaderToStream(U32,unsigned int, U8 ** ,U8 *);

static void CalcGOBChromaVecs(T_H263EncoderCatalog *, UN, T_CONFIGURATION *);

static void GetEncoderOptions(T_H263EncoderCatalog *);

static void StartupBRC(T_H263EncoderCatalog *, U32, U32, float);

static void CalculateQP_mean(T_H263EncoderCatalog * EC);

/* Global Data definition
 */
#pragma data_seg ("H263EncoderTbl")	/* Put in the data segment named "H263EncoderTbl" */

#pragma data_seg ()


/*****************************************************************************
 * EXTERNAL FUNCTIONS
 ****************************************************************************/

/*****************************************************************************
 * 
 *  H263InitEncoderGlobal 
 *
 *  This function initializes the global tables used by the H261 encoder.  Note 
 *  that in 16-bit Windows, these tables are copied to the per-instance data 
 *  segment, so that they can be used without segment override prefixes.
 *  In 32-bit Windows, the tables are left in their staticly allocated locations.
 *
 *  Returns an ICERR value
 */
LRESULT H263InitEncoderGlobal(void)
{
	/*
	 * Initialize fixed length tables for INTRADC
	 */
	InitVLC();

	return ICERR_OK;
} /* end H263InitEncoderGlobal() */


/*****************************************************************************
 *
 *  H263InitEncoderInstance 
 *
 *  This function allocates and initializes the per-instance tables used by 
 *  the H261 encoder.  Note that in 16-bit Windows, the non-instance-specific
 *  global tables are copied to the per-instance data segment, so that they 
 *  can be used without segment override prefixes.
 * 
 *  Returns an ICERR value;
 */
LRESULT H263InitEncoderInstance(LPCODINST lpCompInst)
{

	LRESULT lResult = ICERR_ERROR;
	U32 uGOBNumber;
	U32 uSize;
	UN unIndex;
	UN unStartingMB;

	T_H263EncoderInstanceMemory * P32Inst;
	T_H263EncoderCatalog * EC;
	U32 * puGOBNumbers;
	int iMBNumber;
	UN bEncoderInstLocked = 0;
	int	iNumMBs;

    // RTP: declarations

    T_CONFIGURATION *pConfiguration;
    UN uIntraQP;
    UN uInterQP;

	/* If we were already initialized then we need to terminate the instance.
	 * This happens when two BEGIN's are called without an END.  
	 *
	 * Note: We can't just clear the memory because that will throw out the 
	 * decoder memory. because it will clear the decoder instance which 
	 * contains the decoder catalog pointer.
	 */
	if(lpCompInst->Initialized)
	{
		lResult = H263TermEncoderInstance(lpCompInst);
		if (lResult != ICERR_OK)
		{
			DBOUT("Warning an error occurred terminating the encoder before reinitializing");
		}
	}

	/* Calculate size of encoder instance memory needed. */
	//uSize = sizeof(T_H263EncoderInstanceMemory) + 32;
    uSize = sizeof(T_H263EncoderInstanceMemory) + sizeof(T_MBlockActionStream);


	/*
	 * Allocate the memory.
	 */
	lpCompInst->hEncoderInst = GlobalAlloc(GHND, uSize);

	lpCompInst->EncoderInst = (LPVOID) GlobalLock(lpCompInst->hEncoderInst);
	if (lpCompInst->hEncoderInst == NULL || lpCompInst->EncoderInst == NULL)
	{
		lResult = ICERR_MEMORY;
		goto  done;
	}
	bEncoderInstLocked = 1;

	/* Calculate the 32 bit instance pointer starting at the next
	 * 32 byte boundary.
	 */
     P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) lpCompInst->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));

	/* The encoder catalog is at the start of the per-instance data.
	 */
	EC = &(P32Inst->EC);

    // RTP: initialization

    /* Initialize the Configuration information 
	 */
	pConfiguration = &(lpCompInst->Configuration);
#if 0
	if (LoadConfiguration(pConfiguration) == FALSE)
	{
		GetConfigurationDefaults(pConfiguration);
	}
#endif
	pConfiguration->bInitialized = TRUE;
	pConfiguration->bCompressBegin = TRUE;

	#ifdef _DEBUG
	DBOUT("Encoder Configuration Options:");
	wsprintf(string,"bRTPHeader=%d", (int)pConfiguration->bRTPHeader);
	DBOUT(string);
	wsprintf(string,"unPacketSize=%d", (int)pConfiguration->unPacketSize);
	DBOUT(string);
	wsprintf(string,"bEncoderResiliency=%d", (int)pConfiguration->bEncoderResiliency);
	DBOUT(string);
	wsprintf(string,"bDisallowPosVerMVs=%d", (int)pConfiguration->bDisallowPosVerMVs);
	DBOUT(string);
	wsprintf(string,"bDisallowAllVerMVs=%d", (int)pConfiguration->bDisallowAllVerMVs);
	DBOUT(string);
	wsprintf(string,"unPercentForcedUpdate=%d", (int)pConfiguration->unPercentForcedUpdate);
	DBOUT(string);
	wsprintf(string,"unDefaultIntraQuant=%d", (int)pConfiguration->unDefaultIntraQuant);
	DBOUT(string);
	wsprintf(string,"unDefaultInterQuant=%d", (int)pConfiguration->unDefaultInterQuant);
	DBOUT(string);
	#endif


	/* Initialize encoder catalog.
	 */
	EC->FrameHeight = lpCompInst->yres;
	EC->FrameWidth  = lpCompInst->xres;
	EC->FrameSz	= lpCompInst->FrameSz;
	EC->NumMBRows   = EC->FrameHeight >> 4;
	EC->NumMBPerRow	= EC->FrameWidth  >> 4;
	EC->NumMBs      = EC->NumMBRows * EC->NumMBPerRow;

	/* Get the Options
	 */
	GetEncoderOptions(EC);

    // RTP: resiliency initialization

    if(pConfiguration->bEncoderResiliency &&
	   pConfiguration->unPercentForcedUpdate &&
	   pConfiguration->unPacketLoss) 

	{
		EC->uNumberForcedIntraMBs = ((EC->NumMBs * pConfiguration->unPercentForcedUpdate) + 50) / 100;
		EC->uNextIntraMB = 0;
	}


	/* Store pointers to current frame in the catalog.
	 */
	EC->pU8_CurrFrm        = P32Inst->u8CurrentPlane;
	EC->pU8_CurrFrm_YPlane = EC->pU8_CurrFrm + 16;
	EC->pU8_CurrFrm_UPlane = EC->pU8_CurrFrm_YPlane + YU_OFFSET;
	EC->pU8_CurrFrm_VPlane = EC->pU8_CurrFrm_UPlane + UV_OFFSET;

	/* Store pointers to the previous frame in the catalog.
	 */
	EC->pU8_PrevFrm        = P32Inst->u8PreviousPlane;
	EC->pU8_PrevFrm_YPlane = EC->pU8_PrevFrm + 16*PITCH + 16;
	EC->pU8_PrevFrm_UPlane = EC->pU8_PrevFrm_YPlane + YU_OFFSET;
	EC->pU8_PrevFrm_VPlane = EC->pU8_PrevFrm_UPlane + UV_OFFSET;

	/* Store pointers to the Spatial Loop Filter frame in the catalog.  
	 */
	EC->pU8_SLFFrm     = 	P32Inst->u8SLFPlane;
	EC->pU8_SLFFrm_YPlane = EC->pU8_SLFFrm + 16;
	EC->pU8_SLFFrm_UPlane = EC->pU8_SLFFrm_YPlane + YU_OFFSET;
	EC->pU8_SLFFrm_VPlane = EC->pU8_SLFFrm_UPlane + UV_OFFSET;

    /* Store pointers to the Signature frame in the catalog
	 */
    EC->pU8_Signature        = P32Inst->u8Signature;
  	EC->pU8_Signature_YPlane = EC->pU8_Signature + 16*PITCH + 16;

	// Store pointer to the RunValSign triplets for Luma and Chroma
	EC->pI8_MBRVS_Luma   = P32Inst->i8MBRVS_Luma;
	EC->pI8_MBRVS_Chroma = P32Inst->i8MBRVS_Chroma;

	/* Store pointer to the macroblock action stream in the catalog.
	 */
	EC->pU8_MBlockActionStream = P32Inst->MBActionStream;

	/* Store pointer to the GOB DCT coefficient buffer in the catalog.
	 */
	EC->pU8_DCTCoefBuf = P32Inst->piGOB_DCTCoefs;

	/* Store pointer to the bit stream buffer in the catalog.
	 */
	EC->pU8_BitStream = P32Inst->u8BitStream;

	/* Store pointer to private copy of decoder instance info.
	 */
	EC->pDecInstanceInfo = &(P32Inst->DecInstanceInfo);

	/* Fill the picture header structure.
	 */
	EC->PictureHeader.Split = OFF;
	EC->PictureHeader.DocCamera = OFF;
	EC->PictureHeader.PicFreeze = OFF;
	EC->PictureHeader.StillImage = (EnumOnOff) 1;	// For this bit ON=0, OFF=1
	EC->PictureHeader.TR = 31;
	if (EC->FrameWidth == 352) 
	{
		ASSERT(EC->FrameHeight == 288);
		EC->PictureHeader.SourceFormat = SF_CIF;
		EC->u8DefINTRA_QP = 20;
		EC->u8DefINTER_QP = 13;
	}
	else
	{
		ASSERT(EC->FrameWidth == 176 && EC->FrameHeight == 144);
		EC->PictureHeader.SourceFormat = SF_QCIF;
		EC->u8DefINTRA_QP = 15;
		EC->u8DefINTER_QP = 10;
	}
	EC->PictureHeader.Spare = 1;			// Spare bits set to 1
	EC->PictureHeader.PEI = 0;
	EC->PictureHeader.PQUANT = 8;		   // for now
	EC->PictureHeader.PicCodType = INTRAPIC;  // for now

	#ifndef RING0
	/* Save the timing info pointer - only if do this if not Ring0 because 
	 * structure in P32Inst is only declared if not Ring0.
	 */
	EC->pEncTimingInfo = P32Inst->EncTimingInfo;
	#endif

	/* Force the first frame to a key frame
	 */
	EC->bMakeNextFrameKey = TRUE;

	/* Initialize table with Bit Usage Profile */
//	for (iNumMBs = 0; iNumMBs <= 33 ; iNumMBs++)
	for (iNumMBs = 0; iNumMBs <= (int)EC->NumMBs ; iNumMBs++)
	{
		EC->uBitUsageProfile[iNumMBs] = iNumMBs;   // assume linear distribution at first
	}

	/* Check assumptions about structure sizes and boundary
 	 * alignment.
	 */
	ASSERT( sizeof(T_Blk) == sizeof_T_Blk )
	ASSERT( sizeof(T_MBlockActionStream) == sizeof_T_MBlockActionStream )

	/* Encoder instance memory should start on a 32 byte boundary.
	 */
	ASSERT( ( (unsigned int)P32Inst & 0x1f) == 0)

	/* MB Action Stream should be on a 16 byte boundary.
	 */
	ASSERT( ( (unsigned int)EC->pU8_MBlockActionStream & 0xf) == 0 )

	/* Block structure array should be on a 16 byte boundary.
	 */
	ASSERT( ( (unsigned int) &(EC->pU8_MBlockActionStream->BlkY1) & 0xf) == 0)

	/* Current Frame Buffers should be on a 32 byte boundaries.
	 */
	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_YPlane & 0x1f) == 0)
	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_UPlane & 0x1f) == 0)
	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_VPlane & 0x1f) == 0)

	/* Previous Frame Buffers should be on 16 byte boundaries.
	 */
	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_YPlane & 0x1f) == 0x10)
	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_UPlane & 0x1f) == 0x10)
	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_VPlane & 0x1f) == 0x10)

	/* Spatial Loop Filter Frame Buffers should be on a 32 byte boundary.
	 */
	ASSERT( ( (unsigned int)EC->pU8_SLFFrm_YPlane & 0x1f) == 0)
	ASSERT( ( (unsigned int)EC->pU8_SLFFrm_UPlane & 0x1f) == 0)
	ASSERT( ( (unsigned int)EC->pU8_SLFFrm_VPlane & 0x1f) == 0)

	/* Motion Estimation includes a memory layout.  Assert that we satisfy it.
	 */
	ASSERT( ( (EC->pU8_PrevFrm_YPlane - EC->pU8_CurrFrm_YPlane) % 128) == 80)
	ASSERT( ( (EC->pU8_SLFFrm_YPlane - EC->pU8_PrevFrm_YPlane) % 4096) == 944)

	/* The bitstream should be on a 32 byte boundary
	 */
	ASSERT( ( (unsigned int)EC->pU8_BitStream & 0x1f) == 0)

	/* DCT coefficient array should be on a 32 byte boundary.
	 */
	ASSERT( ( (unsigned int)EC->pU8_DCTCoefBuf & 0x1f) == 0)

	/* Decoder instance structure should be on a DWORD boundary.
	 */
	ASSERT( ( (unsigned int)EC->pDecInstanceInfo & 0x3 ) == 0 )

	/* Initialize MBActionStream
	 */
    int YBlockOffset, UBlockOffset;

	puGOBNumbers = ( EC->PictureHeader.SourceFormat == SF_CIF ) ? uCIFGOBNumbers : uQCIFGOBNumbers;

	for (uGOBNumber = *puGOBNumbers++, unStartingMB = 0; 
	     uGOBNumber != 0; 
	     uGOBNumber = *puGOBNumbers++, unStartingMB += 33) 
	{
		YBlockOffset = uStartingYOffsets[uGOBNumber];
		UBlockOffset = EC->pU8_CurrFrm_UPlane - EC->pU8_CurrFrm_YPlane + uStartingUOffsets[uGOBNumber];

		for (unIndex = 0; unIndex < 33; )
		{
			iMBNumber = unStartingMB + unIndex;

			/* Clear the counter of the number of consecutive times a macroblock has been inter coded.
			 */
			(EC->pU8_MBlockActionStream[iMBNumber]).InterCodeCnt = 0;

			(EC->pU8_MBlockActionStream[iMBNumber]).BlkY1.BlkOffset = YBlockOffset;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkY2.BlkOffset = YBlockOffset+8;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkY3.BlkOffset = YBlockOffset+PITCH*8;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkY4.BlkOffset = YBlockOffset+PITCH*8+8;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkU.BlkOffset = UBlockOffset;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkV.BlkOffset = UBlockOffset+UV_OFFSET;

			if (! EC->bUseMotionEstimation)
			{
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY1.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY1.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY2.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY2.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY3.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY3.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY4.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY4.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkU.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkU.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkV.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkV.PVMV = 0;
			}

			YBlockOffset += 16;
			UBlockOffset += 8;

			unIndex++;

			if (11 == unIndex || 22 == unIndex)
			{
				/* skip to the next row of macro blocks 
				 * - skip forward number of lines in a MB and back 11 macroblocks
				 */
				YBlockOffset += PITCH*16 - 11*16;
				UBlockOffset += PITCH*8  - 11*8;
			}
			else if (33 == unIndex)
			{
				/* Mark the last MB in this GOB.
				 */
				(EC->pU8_MBlockActionStream[iMBNumber]).CodedBlocks  |= 0x40;
			}
		} /* end for unIndex */
	} /* end for uGOBNumber */

	ASSERT(unStartingMB == EC->NumMBs);

	if (! EC->bUseMotionEstimation)
	{
		/* Initialize previous frame pointers.
		 */
		puGOBNumbers = ( EC->PictureHeader.SourceFormat == SF_CIF ) ? uCIFGOBNumbers : uQCIFGOBNumbers;

		for (uGOBNumber = *puGOBNumbers++, unStartingMB = 0; 
		     uGOBNumber != 0; 
		     uGOBNumber = *puGOBNumbers++, unStartingMB += 33) 
		{
			YBlockOffset = uStartingYOffsets[uGOBNumber];
			UBlockOffset = EC->pU8_PrevFrm_UPlane - EC->pU8_PrevFrm_YPlane + uStartingUOffsets[uGOBNumber];

			for (unIndex = 0; unIndex < 33; )
			{
				iMBNumber = unStartingMB + unIndex;

				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY1.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + YBlockOffset;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY2.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + YBlockOffset+8;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY3.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + YBlockOffset+PITCH*8;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY4.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + YBlockOffset+PITCH*8+8;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkU.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + UBlockOffset;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkV.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + UBlockOffset+UV_OFFSET;

				YBlockOffset += 16;
				UBlockOffset += 8;

				unIndex++;

				if (11 == unIndex || 22 == unIndex)
				{
					/* skip to the next row of macro blocks 
					 * - skip forward number of lines in a MB and back 11 macroblocks
					 */
					YBlockOffset += PITCH*16 - 11*16;
					UBlockOffset += PITCH*8  - 11*8;
				}
			} /* end for unIndex */
		} /* end for uGOBNumber */
	} /* end ! bUseMotionEstimation */

	/* Initialize bit rate controller
	 */

    // RTP: BRC initialization. Changed call to InitBRC to accomodate
    // uIntraQP and uInterQP

    if(pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
	{
		uIntraQP = pConfiguration->unDefaultIntraQuant;
		uInterQP = pConfiguration->unDefaultInterQuant;
	}
	else
	{
		uIntraQP = EC->u8DefINTRA_QP; //def263INTRA_QP;
		uInterQP = EC->u8DefINTER_QP; //def263INTER_QP;
	}


	InitBRC(&(EC->BRCState), 	/* Address of the state structure */
		    uIntraQP, //EC->u8DefINTRA_QP, 	/* default INTRA Quantization value */
		    uInterQP, //EC->u8DefINTER_QP, 	/* default INTER Quantization value */
		    EC->NumMBs);		/* number of Macroblocks */

    // RTP: initialize BSInfoStream for RTP header generation

    if (pConfiguration->bRTPHeader)
    {
        H261RTP_InitBsInfoStream(EC, pConfiguration->unPacketSize);
    }
	
    /* Finished initializing the encoder
	 */
	lpCompInst->Initialized = TRUE;
	
	/*
	 * Create a decoder instance and init it.  DecoderInstInfo must be in first 64K.
	 */
	EC->pDecInstanceInfo->xres = lpCompInst->xres;
	EC->pDecInstanceInfo->yres = lpCompInst->yres;

	lResult = H263InitDecoderInstance(EC->pDecInstanceInfo, H263_CODEC);
	if (lResult != ICERR_OK) 
	{
		DBOUT("Encoder's call to init the decoder failed.");
		goto done;
	}
	lResult = H263InitColorConvertor(EC->pDecInstanceInfo, YUV12ForEnc);
	if (lResult != ICERR_OK) 
	{
		DBOUT("Encoder's call to init the color converter failed.");
		goto done;
	}

	lResult = ICERR_OK;

done:
	if (bEncoderInstLocked)
	{
	    GlobalUnlock(lpCompInst->hEncoderInst);
	}	
  
	return lResult;

} /* end H263InitEncoderInstance() */

// Define a variety of parameters to be used with motion estimation.

T_MotionEstimationControls MECatalog[] = {

#define ME_DEFAULT_CTRLS  0
  { 300, 128, 20, 150, 100, 100, 50 },

#define ME_MMX_CTRLS      1
  // These parameters are used when MMX is enabled.
  // NOTE:  Of these, only the SLF parameters are currently used.
  // For MMX, the other parameters are hard coded in exmme.asm.
  { 300, 128, 20, 150, 100, 200, 100 },

#define ME_CUSTOM_CTRLS   2
  // These parameters are used when EC->bUseCustomMotionEstimation is enabled.
  // EC-bUseCustomMotionEstimation, and the individual values here, can be
  // set via the "ini" file.
  { 300, 128, 20, 150, 100, 100, 50 }
};

const U32 MAXCIFSIZE  = 32768;
const U32 MAXQCIFSIZE = 8192;

/*****************************************************************************
 *
 *  H263Compress
 *
 *  This function drives the compression of one frame
 *
 */
LRESULT H263Compress(
	LPCODINST lpCompInst,		/* ptr to compressor instance info. */
	ICCOMPRESS *lpicComp)	    /* ptr to ICCOMPRESS structure. */
{
	FX_ENTRY("H261Compress");

	LRESULT	lResult = ICERR_ERROR;
	U32 uGOBNumber;
	U32 uMB;
	U8 * pu8CurBitStream;		/* pointer to the current location in the bitstream. */
    U32 * puGOBNumbers;
	UN unGQuant;
	UN unLastEncodedGQuant;
	UN unSizeBitStream;
    U32 uMaxSizeBitStream;
//	UN unSize;
	UN unStartingMB;
	U8 u8BitOffset;				/* bit offset in the current byte of the bitstream. */

	/* Variables used in recompression */
	BOOL bOverFlowWarning = FALSE;
	BOOL bOverFlowSevereWarning = FALSE;
	BOOL bOverFlowSevereDanger = FALSE;
	BOOL bOverFlowed = FALSE;
	U32  u32AverageSize;	
	U32  u32sizeBitBuffer;
	U32  u32TooBigSize;
	UN   unGQuantTmp;
	U8   u8GOBcount;

	U32 iSWD;
	U32 uMAXGOBNumber, uGOBsLeft;

	/* save state for if need to recompress last GOB */
	U8 * pu8CurBitStreamSave;	/* ptr to the curr location in the bitstream. */
	U8 u8BitOffsetSave;		/* bit offset in the curr byte of the bitstream. */
	UN unStartingMBSave;
	UN unGQuantSave;
	U8 u8CodedBlockSave[33];
	U8 u8blocknum;

	U8 * pu8FirstInterMEStateRowNumbers;	
	int inRowNumber;
	int inMEStateIndex;

    U32	uCumFrmSize = 0;

	U32 uFrameCount;

	U8 *pU8_temp;			/* dummy pointer needed for FDCT */
	U8 u8_temp;			/* dummy variable needed for FDCT */

	#ifdef ENCODE_STATS
	U32 uStartLow;
	U32 uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uEncodeFrameSum	= 0;
	U32 uInputCCSum = 0;
	U32 uMotionEstimationSum = 0;
	U32 uFDCTSum = 0;
	U32 uQRLESum = 0;
	U32 uDecodeFrameSum = 0;
	U32 uZeroingBufferSum = 0;
//	U32 uSLF_UVSum = 0;
	int bTimingThisFrame = 0;
	ENC_TIMING_INFO * pEncTimingInfo = NULL;
	#endif

    U32 uIntraSWDTotal;
    U32 uIntraSWDBlocks;
    U32 uInterSWDTotal;
    U32 uInterSWDBlocks;
    int MEC_index;
    T_MotionEstimationControls MEC;

	float fFrameRate;
	U32 uFrameSize;
	U32 uQuality;
	  
	T_H263EncoderInstanceMemory * P32Inst;
	T_H263EncoderCatalog * EC;
	LPVOID pEncoderInst = NULL;

	ENC_BITSTREAM_INFO * pBSInfo;

    ICDECOMPRESSEX ICDecExSt;
static ICDECOMPRESSEX DefaultICDecExSt = {
		0,
		NULL, NULL,
		NULL, NULL,
		0, 0, 0, 0,
		0, 0, 0, 0
	};

	int uPQUANTMin;

    // RTP: declaration

    T_CONFIGURATION *pConfiguration = &(lpCompInst->Configuration);

	#ifdef CHECKSUM_PICTURE
	YVUCheckSum YVUCheckSumStruct;
	U8 * pu8SaveCurBitStream;
	U8 u8SaveBitOffset;
	#endif

	// check instance pointer
	if (!lpCompInst)
		return ICERR_ERROR;

	/********************************************************************
	 * Lock the instance data private to the encoder.
	 ********************************************************************/
	pEncoderInst = (LPVOID)GlobalLock(lpCompInst->hEncoderInst);
	if (pEncoderInst == NULL)
	{
		DBOUT("ERROR :: H263Compress :: ICERR_MEMORY");
		lResult = ICERR_MEMORY;
		goto  done;
	}

	/* Generate pointer to the encoder instance memory.
	 */
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) lpCompInst->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
	/* Get pointer to encoder catalog.
	 */
	EC = &(P32Inst->EC);

	// Check pointer to encoder catalog
	if (!EC)
		return ICERR_ERROR;

	pBSInfo = &EC->BSInfo;

	/********************************************************************
	 *  Dummy operations.
	 ********************************************************************/
	pU8_temp = &u8_temp;

	/********************************************************************
	 *  Do per-frame initialization.
	 ********************************************************************/

	/* Get the frame number
	 */
	uFrameCount = pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount;
	
	#ifdef ENCODE_STATS
		if (uFrameCount < DEC_TIMING_INFO_FRAME_COUNT)
		{
			ASSERT(EC->pEncTimingInfo);
			TIMER_START(bTimingThisFrame,uStartLow,uStartHigh);
			ASSERT(bTimingThisFrame);
			EC->uStartLow = uStartLow;
			EC->uStartHigh = uStartHigh;
			EC->uStatFrameCount = uFrameCount;
		}
		else
		{	
			ASSERT(!bTimingThisFrame);
		}
		EC->bTimingThisFrame = bTimingThisFrame;
	#endif

	if((lpicComp->dwFlags & ICCOMPRESS_KEYFRAME) ||
	   (EC->bMakeNextFrameKey == TRUE))
	{
		EC->PictureHeader.PicCodType = INTRAPIC;
		EC->bMakeNextFrameKey = FALSE;
		EC->PictureHeader.PicFreeze = ON;
	}
	else
	{
		EC->PictureHeader.PicCodType = INTERPIC;
		EC->PictureHeader.PicFreeze = OFF;
		DBOUT("INTERPIC...")
	}

	if (EC->PictureHeader.PicCodType == INTRAPIC)
	{ 
		/* Initialize macroblocks action stream for INTRA
		 */
		for (uMB = 0; uMB < EC->NumMBs; uMB++)
		{
			(EC->pU8_MBlockActionStream[uMB]).CodedBlocks  |= 0x3F;      /* Set to all nonempty blocks. */
			(EC->pU8_MBlockActionStream[uMB]).CodedBlocksB = 0;
			(EC->pU8_MBlockActionStream[uMB]).InterCodeCnt = ((U8)uMB)&0xF; /* Seed update pattern */
			(EC->pU8_MBlockActionStream[uMB]).FirstMEState = ForceIntra;
			if (! EC->bUseMotionEstimation)
			{
				(EC->pU8_MBlockActionStream[uMB]).BlockType = INTRABLOCK;
			}
		}
		*(lpicComp->lpdwFlags) |=  AVIIF_KEYFRAME;
          lpicComp->dwFlags |= ICCOMPRESS_KEYFRAME;
	}
	else // not a key frame, motion vectors present
	{
		/* Setup to initialize the FirstMEState field.  The initial data for
		 * the FirstMEState is stored compressed in rows of 11 bytes.  Different
		 * rows are chosen for CIF and QCIF initialization.
		 */
		if ( EC->PictureHeader.SourceFormat == SF_CIF )
		{
			pu8FirstInterMEStateRowNumbers = u8CIFFirstInterMEStateRowNumbers;
		}
		else
		{
			pu8FirstInterMEStateRowNumbers = u8QCIFFirstInterMEStateRowNumbers;
		}
		inRowNumber = *pu8FirstInterMEStateRowNumbers++;
		ASSERT(inRowNumber <= MAX_ME_STATE_ROW_NUMBER);

		/* Initialize macroblocks action stream for INTER
		 */
		for (inMEStateIndex = 0, uMB = 0; uMB < EC->NumMBs; uMB++, inMEStateIndex++)
		{
			/* There are only 11 bytes in a row of data.  So reset the Index and go to
			 * the next row number.
			 */
			if (inMEStateIndex == 11)
			{
				inMEStateIndex = 0;
				inRowNumber = *pu8FirstInterMEStateRowNumbers++;
				ASSERT(inRowNumber <= MAX_ME_STATE_ROW_NUMBER);
			}

			(EC->pU8_MBlockActionStream[uMB]).CodedBlocks  |= 0x3F; /* Initialize to all nonempty blocks. */
			(EC->pU8_MBlockActionStream[uMB]).CodedBlocksB = 0;
			if (EC->pU8_MBlockActionStream[uMB].InterCodeCnt >= 
					(pConfiguration->bRTPHeader
						? INTERCODECNT_ADJUST[pConfiguration->unPacketLoss/10]
						: 132))
			{
				(EC->pU8_MBlockActionStream[uMB]).FirstMEState = ForceIntra;	/* Force intra blocks. */
				(EC->pU8_MBlockActionStream[uMB]).BlockType = INTRABLOCK;
			}
			else
                {  // RTP: resiliency stuff
               if (pConfiguration->bDisallowAllVerMVs)
                  (EC->pU8_MBlockActionStream[uMB]).FirstMEState =
                   u8FirstInterMENoVerMVStateRows[inRowNumber][inMEStateIndex];
               else
               {
                   if (pConfiguration->bDisallowPosVerMVs)
                   (EC->pU8_MBlockActionStream[uMB]).FirstMEState =
                    u8FirstInterMENoPosVerMVStateRows[inRowNumber][inMEStateIndex];
                   else
				      (EC->pU8_MBlockActionStream[uMB]).FirstMEState = 
                        u8FirstInterMEStateRows[inRowNumber][inMEStateIndex];
               }
				if (! EC->bUseMotionEstimation)
				{
					(EC->pU8_MBlockActionStream[uMB]).BlockType = INTERBLOCK;
				}
			}
		}
		*(lpicComp->lpdwFlags)  &= ~AVIIF_KEYFRAME;
	      lpicComp->dwFlags &= ~ICCOMPRESS_KEYFRAME;
	}
    // RTP: resiliency stuff

    if (pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
    {
      UN i;
      if (EC->uNumberForcedIntraMBs > 0)
      {
        for (i=0; i < EC->uNumberForcedIntraMBs; i++)
        {
            if (EC->uNextIntraMB == EC->NumMBs)
                EC->uNextIntraMB=0;
            (EC->pU8_MBlockActionStream[EC->uNextIntraMB]).FirstMEState = 
                 ForceIntra;
            if (! EC->bUseMotionEstimation)
			{
				(EC->pU8_MBlockActionStream[uMB]).BlockType = INTRABLOCK;
			}
        }
      }
    }

	/* Initialize bit stream pointers */
	pu8CurBitStream = EC->pU8_BitStream;
	u8BitOffset = 0;	    

    /******************************************************************
     * RGB to YVU 12 Conversion
     ******************************************************************/
	#ifdef ENCODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif

    colorCnvtFrame(EC, lpCompInst, lpicComp, 
                       EC->pU8_CurrFrm_YPlane,
                       EC->pU8_CurrFrm_UPlane,
                       EC->pU8_CurrFrm_VPlane);

	#ifdef ENCODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uInputCCSum)
	#endif
  
	/********************************************************************
	 * Setup the bit rate controller
	 ********************************************************************/
     // RTP: Configuration setting

    // If the Encoder Bit Rate section of the configuration has been
	// set ON then, we override quality only or any frame size normally
	// sent in and use frame rate and data rate to determine frame
	// size.
    if (EC->PictureHeader.PicCodType == INTERPIC &&
        lpCompInst->Configuration.bBitRateState == TRUE &&
        lpCompInst->FrameRate != 0.0f &&
		lpicComp->dwFrameSize == 0UL)
	{
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Changing dwFrameSize from %ld to %ld bits\r\n", _fx_, lpicComp->dwFrameSize << 3, (DWORD)((float)lpCompInst->DataRate / lpCompInst->FrameRate) << 3));
		
        lpicComp->dwFrameSize = (U32)((float)lpCompInst->DataRate / lpCompInst->FrameRate);
	}
 
        uFrameSize = lpicComp->dwFrameSize;
		#ifdef DEBUG_RECOMPRESS
  		wsprintf(string, "uFrameSize %d", (int) uFrameSize);
		DBOUT(string);
		#endif

	/* check uFrameSize.  Max compressed frame size for QCIF is 8KBytes
	 * and 32 KBytes for FCIF.
	 */
	if ( EC->PictureHeader.SourceFormat == SF_CIF )
	{
        uMaxSizeBitStream = MAXCIFSIZE;
		if (uFrameSize > MAXCIFSIZE)
			uFrameSize = MAXCIFSIZE;
	}
	else
	{
        uMaxSizeBitStream = MAXQCIFSIZE;
		if (uFrameSize > MAXQCIFSIZE)
			uFrameSize = MAXQCIFSIZE;
	}
		#ifdef DEBUG_RECOMPRESS
  		wsprintf(string, "uFrameSize %d", (int) uFrameSize);
		DBOUT(string);
		#endif

        uQuality = lpicComp->dwQuality;
        fFrameRate = lpCompInst->FrameRate;
	
	StartupBRC(EC, uFrameSize, uQuality, fFrameRate);

	/* QRLE does not do clamping - it passes 8-bits to VLC.  Because of 
	 * that we need to be sure that all values can be represented by 255.
	 *	  QP-4 represents +-2040 leaving out 2041..2048.
	 *	  QP-5 represents +-2550 which has no clamping problems.
	 * Because QRLE does not do clamping we should limit our QP to 5.
	 * But I still see some clamping artifacts at 5.  See the "Tom" video
	 * encoded with a fixed quantizer at frame 100.  For that reason I
	 * am limiting my QP to 6 (which is the same value as the 750 encoder).
	 *
	 * If you had unlimited time you could look at the first four coefficients
	 * and pretty safely decide if you can use lower quantizers.  Since we
	 * are supposed to run on a P5/90 we don't have that time.
	 */
	//CLAMP_N_TO(EC->PictureHeader.PQUANT,6,31);

	/* Change Clamp range to allow quant to get to 2 unless fixed quant
	 * or quality setting used instead of data rate.  This does probably
	 * cause quantization errors at high data rates the question is does
	 * it cause noticable errors at ISDN data rates when the clips are
	 * playing at speed?  This will be evaluated witn Beta 02 candidate.
	 * Changes made in e1enc and e1mbenc.
	 */
	if (EC->BRCState.uTargetFrmSize == 0)
	{
		CLAMP_N_TO(EC->PictureHeader.PQUANT,6,31);
	}
	else
	{
		uPQUANTMin = clampQP((10000L - (int)lpicComp->dwQuality) * 15L / 10000L);
		
		CLAMP_N_TO(EC->PictureHeader.PQUANT, uPQUANTMin, 31);
		
	}

	// also set previous GQuant 
	unLastEncodedGQuant = EC->PictureHeader.PQUANT;

    if (EC->bBitRateControl)
    {
	    /* Initialize Cumulative Quantization values
		 */
	    EC->uQP_cumulative = 0;
		EC->uQP_count = 0;
	}

	/* Increment temporal reference.
	 */
	#ifdef RING0
	Increment_TR_UsingFrameRate(&(EC->PictureHeader.TR), 
								&(EC->fTR_Error), 
								fFrameRate, 
								(pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) == 0, 
								0x1F);
	#else
	Increment_TR_UsingTemporalValue(&(EC->PictureHeader.TR), 
									&(EC->u8LastTR), 
									lpicComp->lFrameNum, 
								    (pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) == 0, 
								    0x1F);
	#endif

    // RTP: packet initialization for first GOB
    if (pConfiguration->bRTPHeader)
    {
        H261RTP_GOBUpdateBsInfo(EC, 1, pu8CurBitStream, 0);
    }

	/********************************************************************
	 * Write the Picture Header
	 *******************************************************************/
	WriteBeginPictureHeaderToStream(EC, &pu8CurBitStream, &u8BitOffset);

#ifdef CHECKSUM_PICTURE
	/* Initialize the checksum record to all zeros.
	 */
	YVUCheckSumStruct.uYCheckSum = 0;
	YVUCheckSumStruct.uVCheckSum = 0;
	YVUCheckSumStruct.uUCheckSum = 0;
		
	/* save the pointers
	 */
	pu8SaveCurBitStream = pu8CurBitStream;
	u8SaveBitOffset = u8BitOffset;

	/* write the zero checksum
	 */
	WritePictureChecksum(&YVUCheckSumStruct, &pu8CurBitStream, &u8BitOffset, 0);

#endif

	WriteEndPictureHeaderToStream(EC, &pu8CurBitStream, &u8BitOffset);


	/********************************************************************
	 * Inner Loop: Loop through GOBs and macroblocks.
	 ********************************************************************/
	puGOBNumbers = ( EC->PictureHeader.SourceFormat == SF_CIF ) ? uCIFGOBNumbers : uQCIFGOBNumbers;
	uMAXGOBNumber = ( EC->PictureHeader.SourceFormat == SF_CIF ) ? 12 : 3;

	u32sizeBitBuffer = CompressGetSize(lpCompInst, lpicComp->lpbiInput,
										lpicComp->lpbiOutput);

	/* Check to see if we told VfW to create a buffer smaller than the maximum allowable.
	 */
	ASSERT( u32sizeBitBuffer <= sizeof_bitstreambuf );

	if (EC->PictureHeader.PicCodType == INTRAPIC)
	{
        u32AverageSize = 
                (EC->PictureHeader.SourceFormat == SF_CIF ) ? 
			    (7 * u32sizeBitBuffer/FCIF_NUM_OF_GOBS) >> 3:
                (7 * u32sizeBitBuffer/QCIF_NUM_OF_GOBS) >> 3;
	}
	else
	{
        u32AverageSize = 
                (EC->PictureHeader.SourceFormat == SF_CIF ) ? 
			    (8 * u32sizeBitBuffer/FCIF_NUM_OF_GOBS) >> 4:
                (8 * u32sizeBitBuffer/QCIF_NUM_OF_GOBS) >> 4;
	}

	// Select motion estimation parameters.

	if (EC->bUseCustomMotionEstimation)
		MEC_index = ME_CUSTOM_CTRLS;
	else
		MEC_index = ME_DEFAULT_CTRLS;
	// Make a local copy of the controls, so that we can alter the
	// controls dynamically, without destroying the original values.
	MEC = MECatalog[MEC_index];

	if (pConfiguration->bRTPHeader) {
		MEC.empty_threshold /= EMPTYTHRESHOLD_ADJUST[pConfiguration->unPacketLoss/25];
		if (pConfiguration->unPacketLoss > 25) {
			MEC.zero_vector_threshold = 99999;
			MEC.nonzero_MV_differential = 99999;
			if ((MEC.slf_differential <<= 2) > 99999)
				MEC.slf_differential = 99999;
			if (pConfiguration->unPacketLoss > 50) {
				MEC.slf_threshold = 99999;
			}
		}
	}

	for (uGOBNumber = *puGOBNumbers++, unStartingMB = 0, u8GOBcount = 1; 
	     uGOBNumber != 0; 
	     uGOBNumber = *puGOBNumbers++, unStartingMB += 33, u8GOBcount++) 
	{
		#ifdef DEBUG_ENC
		wsprintf(string, "GOB #%d", (int) uGOBNumber);
		DBOUT(string);
		trace(string);
		#endif

		uGOBsLeft = uMAXGOBNumber - u8GOBcount;

		if (EC->bUseMotionEstimation) 
		{
			#ifdef ENCODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif
	        MOTIONESTIMATION(
			    &(EC->pU8_MBlockActionStream[unStartingMB]),
	            EC->pU8_CurrFrm_YPlane,
	            EC->pU8_PrevFrm_YPlane,
	            EC->pU8_SLFFrm_YPlane,
				1,          // Do Radius 15 search.
			    0,			// No Half Pel motion estimation
	            0,			// No Block MVs
			    (int)EC->bUseSpatialLoopFilter,
			    MEC.zero_vector_threshold, // Zero Vector Threshold.  If the
			    			// SWD for the zero vector is less than this
			    			// threshold, then don't search for NZ MV's.
			    			// Set to 99999 to not search.
			    MEC.nonzero_MV_differential, // NonZeroMVDifferential.
	                        // Once the best NZ MV is found, it must be better
	                        // than the 0 MV SWD by at least this amount.
	                        // Set to 99999 to never choose NZ MV.
			    128,		// BlockMVDifferential. The sum of the four block
			    			// SWD must be better than the MB SWD by at least
			    			// this amount to choose block MV's.
							// H.261 don't care
			    MEC.empty_threshold, // Empty Threshold.  Set to 0 to not force
			    			// empty blocks.
			    MEC.intercoding_threshold, // Inter Coding Threshold. If the
			    			// inter SWD is less than this amount then don't
			    			// bother calc. the intra SWD.
			    MEC.intercoding_differential, // Intra Coding Differential.
			    			// Bias against choosing INTRA blocks.
			    MEC.slf_threshold, // If the SWD of the chosen MV is less than
			    			// this threshold, then don't bother investigating
			    			// the spatial loop filtered case.
			    MEC.slf_differential,  // If you do look at the SLF case, its
			    			// SWD must be better than the non-SLF SWD by at
			    			// least this much in order to select the SLF type.

			    &uIntraSWDTotal,
			    &uIntraSWDBlocks,
			    &uInterSWDTotal,
			    &uInterSWDBlocks
	         );
			#ifdef ENCODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMotionEstimationSum)
			#endif

	        /* If it's an inter frame then, calculate chroma vectors and update the InterCodeCnt.
			 */
	        if (EC->PictureHeader.PicCodType == INTERPIC)
	        {

            // RTP: added pConfiguration to CalcGOBChromaVecs()

			CalcGOBChromaVecs(EC, unStartingMB, pConfiguration);

		} /* end INTERPIC */
		} /* end if UseMotionEstimation */

		/* Calculate unGQuant based on bits used in previous GOBs, and bits used 
		 * for current GOB of previous frame.
		 */
        if (EC->bBitRateControl)
        {
			unGQuantTmp = unGQuant;
            unGQuant = CalcMBQUANT(&(EC->BRCState), EC->uBitUsageProfile[unStartingMB],EC->uBitUsageProfile[EC->NumMBs], uCumFrmSize, EC->PictureHeader.PicCodType);
		    EC->uBitUsageProfile[unStartingMB] = uCumFrmSize;

			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Bitrate controller enabled for GOB #%ld (uCumFrmSize = %ld bits and unGQuantTmp = %ld), setting unGQuant = %ld (min and max will truncate from %ld to 31)\r\n", _fx_, uGOBNumber, uCumFrmSize << 3, unGQuantTmp, unGQuant, uPQUANTMin));

			/* if bOverFlowSevereDanger True Increase Quant */
			if ( bOverFlowSevereDanger )
			{
				DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Danger of overflow for GOB #%ld, changing unGQuant from %ld to %ld\r\n", _fx_, uGOBNumber, unGQuant, (unGQuant < unGQuantTmp) ? (unGQuantTmp + ((EC->PictureHeader.PicCodType == INTRAPIC) ? 12 : 6)) : (unGQuant + ((EC->PictureHeader.PicCodType == INTRAPIC) ? 12 : 6))));

				if (unGQuant < unGQuantTmp)
					unGQuant = unGQuantTmp;

		        if (EC->PictureHeader.PicCodType == INTRAPIC)
			        unGQuant += 12;
				else
					unGQuant += 6;

				DBOUT("Increasing GQuant increase by +6");
			}
			else if ( bOverFlowSevereWarning )
			{
				DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Danger of overflow for GOB #%ld, changing unGQuant from %ld to %ld\r\n", _fx_, uGOBNumber, unGQuant, (unGQuant < unGQuantTmp) ? (unGQuantTmp + ((EC->PictureHeader.PicCodType == INTRAPIC) ? 8 : 4)) : (unGQuant + ((EC->PictureHeader.PicCodType == INTRAPIC) ? 8 : 4))));

				/* if bOverFlowSevereWarning True Increase Quant */
				if (unGQuant < unGQuantTmp)
					unGQuant = unGQuantTmp;
				if (EC->PictureHeader.PicCodType == INTRAPIC)
			       unGQuant += 8;
				else
				   unGQuant += 4;

				DBOUT("Increasing GQuant increase by +4");
			}
			else if ( !bOverFlowWarning )
			{
				DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Warning of overflow for GOB #%ld, changing unGQuant from %ld to %ld\r\n", _fx_, uGOBNumber, unGQuant, ((int)unGQuant > ((int)unLastEncodedGQuant + MaxChangeRowMBTbl[unGQuant])) ? (unLastEncodedGQuant + MaxChangeRowMBTbl[unGQuant]) : (((int)unGQuant < ((int)unLastEncodedGQuant - 2)) ? (unLastEncodedGQuant - 2) : unGQuant)));

				/* if bOverFlowWarning False limit Quant changes */

		    	/* Limit the quant changes */
		    	if ((int)unGQuant > ((int)unLastEncodedGQuant + MaxChangeRowMBTbl[unGQuant]))
		    	{
				    unGQuant = unLastEncodedGQuant + MaxChangeRowMBTbl[unGQuant];
				    DBOUT("Slowing GQuant increase to +[1-4]");
		    	}
		    	else if ((int)unGQuant < ((int)unLastEncodedGQuant - 2))
		    	{
				    unGQuant = unLastEncodedGQuant - 2;
				    DBOUT("Slowing GQuant decrease to -2");
		    	}
			}
			else
			{
				DBOUT("bOverFlowWarning don't limit Quant change");
			}

			if (EC->BRCState.uTargetFrmSize == 0)
			{
				CLAMP_N_TO(unGQuant,6,31);
			}
			else
			{
				CLAMP_N_TO(unGQuant, uPQUANTMin , 31);
			}

		    unLastEncodedGQuant = unGQuant;
	    

		    #ifdef DEBUG_BRC
		    wsprintf(string,"At MB %d GQuant=%d", unStartingMB, unGQuant);
		    DBOUT(string);
		    #endif
        }
        else
        {
            unGQuant = EC->PictureHeader.PQUANT;
        }

		if ( bOverFlowWarning )
		{
			/* save state may need to recompress */
			pu8CurBitStreamSave = pu8CurBitStream;
			u8BitOffsetSave     = u8BitOffset;
			unStartingMBSave    = unStartingMB;
			unGQuantSave		= unGQuant;

			for (u8blocknum = 0; u8blocknum < 33; u8blocknum++)
			{
				/* go through last GOBs macroblock action stream
				 * saving coded block type because quantization
				 * resets the pattern in some blocks quantize to 0.
				 */
				u8CodedBlockSave[u8blocknum] = 
                    (EC->pU8_MBlockActionStream[unStartingMB+u8blocknum]).CodedBlocks;
			}
		}

        // RTP: GOB update

        if ( (uGOBNumber != 1) && (pConfiguration->bRTPHeader) )
        {
           H261RTP_GOBUpdateBsInfo(EC, uGOBNumber, pu8CurBitStream, (U32)
                                   u8BitOffset);
        }

		WriteGOBHeaderToStream(uGOBNumber, unGQuant, &pu8CurBitStream, &u8BitOffset);
        
        
		/* Input is the macroblock action stream with pointers to
		 * current and previous blocks. Output is a set of 32 DWORDs
		 * containing pairs of coefficients for each block. There are
		 * from 0 to 12 blocks depending on if PB frames are used and
		 * what the CBP field states.
		 */
		#ifdef ENCODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif

        FORWARDDCT( &(EC->pU8_MBlockActionStream[unStartingMB]),
            EC->pU8_CurrFrm_YPlane,
            EC->pU8_PrevFrm_YPlane,
            0,
            EC->pU8_DCTCoefBuf,
            0,                    //  0 = not a B-frame
	    0,                    //  0 = AP not on
	    0,			  //  0 = PB?
	    pU8_temp,		  //  Scratch
	    EC->NumMBPerRow
        );

		#ifdef ENCODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFDCTSum)
		#endif
        
		/* Input is the string of coefficient pairs output from the
		 * DCT routine.
		 */
		#ifdef ENCODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
		
            GOB_Q_RLE_VLC_WriteBS(
			EC,
			EC->pU8_DCTCoefBuf,
			&pu8CurBitStream,
			&u8BitOffset,
			unStartingMB,
			unGQuant,
			bOverFlowSevereWarning,
            (BOOL) pConfiguration->bRTPHeader,  // RTP: MBUpdate flag
			uGOBNumber,
			uPQUANTMin);

		#ifdef ENCODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uQRLESum)
		#endif

        /* Calculate number of bytes used in frame so far.
		 */
        uCumFrmSize = pu8CurBitStream - EC->pU8_BitStream;

		/* Try to make sure we won't overrun the bit stream buffer. Take the stuffing bytes
		 * at the end into account when you do this. Also make sure that if this GOB is not
		 * recompressed then there is enough space left to send SKIP GOBs for the remaining
		 * GOBs. I am using sizeof (SKIP GOB) = 2 bytes.
		 */

		if (  (unsigned)uCumFrmSize >= 
			            (u32sizeBitBuffer - (uGOBsLeft*2) - 10) )
		{
			/* Already about to exceed need to recompress */
			DBOUT("Need to RECOMPRESS");

			if ( bOverFlowWarning )
			{
				#ifdef DEBUG_RECOMPRESS
					wsprintf(string,"Bits Used before recompress= %d ", uCumFrmSize*8);
					DBOUT(string);
					//trace(string);
				#endif

				u32TooBigSize = uCumFrmSize;
				bOverFlowSevereDanger = TRUE;

				/* zero out last GOBs worth of bitstream */
				U8 u8temp;

				u8temp = *pu8CurBitStreamSave;
				u8temp = (u8temp>>(8-u8BitOffsetSave))<<(8-u8BitOffsetSave);
				*pu8CurBitStreamSave = u8temp;

				memset(pu8CurBitStreamSave+1, 0, pu8CurBitStream - pu8CurBitStreamSave);

				/* restore state */
				pu8CurBitStream = pu8CurBitStreamSave;
				u8BitOffset     = u8BitOffsetSave;
				unStartingMB    = unStartingMBSave;

				if (EC->PictureHeader.PicCodType == INTRAPIC)
					unGQuant = unGQuantSave + 16;
				else 
				    unGQuant		= unGQuantSave + 8;
			
				CLAMP_N_TO(unGQuant,6,31);

                // RTP: rewind operation
                if (pConfiguration->bRTPHeader)
                    H261RTP_RewindBsInfoStream(EC, (U32) uGOBNumber);

				for (u8blocknum = 0; u8blocknum < 33; u8blocknum++)
				{
					/* go through GOBs macroblock action stream
					 * restoring coded block type because quantization
					 * resets the patter in some blocks quantize to 0.
					 */
					(EC->pU8_MBlockActionStream[unStartingMB+u8blocknum]).CodedBlocks = u8CodedBlockSave[u8blocknum];
				}
				
				/* rewrite GOB header */
				WriteGOBHeaderToStream(uGOBNumber, unGQuant, &pu8CurBitStream, &u8BitOffset);
			
				GOB_Q_RLE_VLC_WriteBS(
					EC,
					EC->pU8_DCTCoefBuf,
					&pu8CurBitStream,
					&u8BitOffset,
					unStartingMB,
					unGQuant,
					bOverFlowSevereDanger,
                    pConfiguration->bRTPHeader, // RTP: switch
                    uGOBNumber,                 // RTP: info
					uPQUANTMin);

				/* test if still too big if so just send skip GOB */
				/* For intended KEY frames, this is a problem     */

        		uCumFrmSize = pu8CurBitStream - EC->pU8_BitStream;

				if (  (unsigned) uCumFrmSize >= 
					  (u32sizeBitBuffer - (uGOBsLeft*2) - 10) )
				{
					bOverFlowed = TRUE;

					/* zero out last GOBs worth of bitstream */
					u8temp = *pu8CurBitStreamSave;
					u8temp = (u8temp>>(8-u8BitOffsetSave))<<(8-u8BitOffsetSave);
					*pu8CurBitStreamSave = u8temp;

					memset(pu8CurBitStreamSave+1, 0, pu8CurBitStream - pu8CurBitStreamSave);

					/* restore state */
					pu8CurBitStream = pu8CurBitStreamSave;
					u8BitOffset     = u8BitOffsetSave;
					unStartingMB    = unStartingMBSave;
					// unGQuant		= unGQuantSave + 8;

                    // RTP: rewind operation

                    if (pConfiguration->bRTPHeader)
                       H261RTP_RewindBsInfoStream(EC, (U32) uGOBNumber);

					WriteGOBHeaderToStream(uGOBNumber, unGQuant, &pu8CurBitStream, &u8BitOffset);
                    
                    /* write out a stuffing code */
					PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, &pu8CurBitStream, &u8BitOffset);

					DBOUT("Just Sent SKIP GOB");
					#ifdef DEBUG_RECOMPRESS
					wsprintf(string,"Just Sent SKIP GOB");
					//trace(string);
					#endif
				}
			}
			else
			{
				DBOUT("Did not save state to recompress");
			}
		}

       	/* Calculate number of bytes used in frame so far.
		 */
        uCumFrmSize = pu8CurBitStream - EC->pU8_BitStream;
		#ifdef DEBUG_RECOMPRESS
			wsprintf(string,"Bits Used = %d ", uCumFrmSize*8);
			DBOUT(string);
			//trace(string);
		#endif

		/* Check to make sure we haven't overrun the bit stream buffer.
		 */
		ASSERT( (unsigned) uCumFrmSize < u32sizeBitBuffer );

		/* Setup method to determine if might have a problem with buffer size */
		bOverFlowWarning =
			bOverFlowSevereWarning =
				bOverFlowSevereDanger = FALSE;
		if (uCumFrmSize > u8GOBcount*u32AverageSize)
		{
			/* allow for more Quant level changes */
			bOverFlowWarning = TRUE;

			if (uCumFrmSize > u8GOBcount*u32AverageSize + (u32AverageSize>>1))
			{
				/* force Quant level increase */
				bOverFlowSevereWarning = TRUE;
				DBOUT("bOverFlowSevereWarning");

				if (uCumFrmSize > u8GOBcount*u32AverageSize+u32AverageSize)
				{
					/* force Quant level increase by even more */
					bOverFlowSevereDanger = TRUE;
					DBOUT("bOverFlowSevereDanger");
				}
			}
		}
	} /* for uGOBNumber */

	/* if recompress failed shove big number in here */
	if (bOverFlowed)
	{
		/* used max size so quant will go up for next frame */
		EC->uBitUsageProfile[unStartingMB] = u32TooBigSize;

	}
	else
		EC->uBitUsageProfile[unStartingMB] = uCumFrmSize;


	/* Make sure we end this frame on a byte boundary - some decoders require this.
	 */
	while (u8BitOffset != 0) 
	{
	 	PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, &pu8CurBitStream, &u8BitOffset);
	}

	/* Add extra DWORD of zero's to try and get rid of green blocks akk */
	/* 16 bits of zeros seems to work */
	/* 8 bits of zeros does not seems to work */
#ifdef DWORD_HACK
	PutBits(0x0000, 16, &pu8CurBitStream, &u8BitOffset);
#endif

    if (EC->bBitRateControl)
    {
		CalculateQP_mean(EC);
	}

	/********************************************************************
	 * Calculate the size of the compressed image.
	 ********************************************************************/

	unSizeBitStream = pu8CurBitStream - EC->pU8_BitStream;
	lpCompInst->CompressedSize = unSizeBitStream;

	// IP + UDP + RTP + payload mode C header - worst case
	#define TRANSPORT_HEADER_SIZE (20 + 8 + 12 + 12)
	DWORD dwTransportOverhead;

	// Estimate the transport overhead
	if (pConfiguration->bRTPHeader)
		dwTransportOverhead = (lpCompInst->CompressedSize / pConfiguration->unPacketSize + 1) * TRANSPORT_HEADER_SIZE;
	else
		dwTransportOverhead = 0UL;

	if (EC->PictureHeader.PicCodType == INTRAPIC)
	{
#ifdef _DEBUG
		wsprintf(string, "Intra Frame %d size: %d", pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount, unSizeBitStream);
#endif

		pBSInfo->uKeyFrameCount ++;
		pBSInfo->uTotalKeyBytes += unSizeBitStream;

        if (EC->bBitRateControl)
        {
			EC->BRCState.uLastINTRAFrmSz = dwTransportOverhead + unSizeBitStream;
		}
	}
	else
	{
#ifdef _DEBUG
		wsprintf(string, "Inter Frame %d size: %d", pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount, unSizeBitStream);
#endif
        
		pBSInfo->uDeltaFrameCount ++;
		pBSInfo->uTotalDeltaBytes += unSizeBitStream;

        if (EC->bBitRateControl)
        {
			EC->BRCState.uLastINTERFrmSz = dwTransportOverhead + unSizeBitStream;
		}
	}
#ifdef _DEBUG
	DBOUT(string)
#endif

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Total cumulated frame size = %ld bits (data: %ld, transport overhead: %ld)\r\n", _fx_, (unSizeBitStream + dwTransportOverhead) << 3, unSizeBitStream << 3, dwTransportOverhead << 3));

	/********************************************************************
	 *  Run the decoder on this frame, to get next basis for prediction.
	 ********************************************************************/

	ICDecExSt = DefaultICDecExSt;
	ICDecExSt.lpSrc = EC->pU8_BitStream;
	ICDecExSt.lpbiSrc = lpicComp->lpbiOutput;
	ICDecExSt.lpbiSrc->biSizeImage = unSizeBitStream;
	ICDecExSt.lpDst = P32Inst->u8PreviousPlane;
	ICDecExSt.lpbiDst = NULL;

	if (EC->PictureHeader.PicCodType == INTERPIC)
	{
		ICDecExSt.dwFlags = ICDECOMPRESS_NOTKEYFRAME;
	}

	#ifdef ENCODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
	lResult = H263Decompress (EC->pDecInstanceInfo, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
	if (lResult != ICERR_OK) 
	{
		DBOUT("Encoder's call to decompress failed.");
        EC->bMakeNextFrameKey = TRUE;
		goto done;
	}
	#ifdef ENCODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uDecodeFrameSum)
	#endif

	#ifdef CHECKSUM_PICTURE
		lResult = H261PictureCheckSumEntry(EC->pDecInstanceInfo, &YVUCheckSumStruct);
		if (lResult != ICERR_OK) 
		{
			DBOUT("Encoder's call to compute the picture checksum failed.");
			goto done;
		}
	
		/* restore the pointers
		 */
		pu8CurBitStream = pu8SaveCurBitStream;
		u8BitOffset = u8SaveBitOffset;

		/* update the checksum
		 */
		WritePictureChecksum(&YVUCheckSumStruct, &pu8CurBitStream, &u8BitOffset, 1);
	#endif

    if (unSizeBitStream > uMaxSizeBitStream)
    {
        //  Exceeded allowed - 8K for QCIF and 32K for CIF  - size
        DBOUT("BS exceeds allowed size");
        EC->bMakeNextFrameKey = TRUE;
        goto done;
    }

    // RTP: bstream extension attachment
    if (pConfiguration->bRTPHeader)
    {
        //  Changed this if statement to check for overflow of bitstream buffer
        //  4/14/97 AG.
        U32 uEBSSize = H261RTP_GetMaxBsInfoStreamSize(EC);

        if (uEBSSize + unSizeBitStream <= u32sizeBitBuffer)
        {
            unSizeBitStream +=
              (WORD) H261RTP_AttachBsInfoStream(EC, (U8 *)EC->pU8_BitStream,
                                                unSizeBitStream);
            lpCompInst->CompressedSize = unSizeBitStream;
        }
        else
        {
            DBOUT("BS+EBS exceeds allocated buffer size");
            EC->bMakeNextFrameKey = TRUE;
            goto done;
        }
    }

	#ifndef RING0
	#ifdef DEBUG
	{
		char buf[60];

		wsprintf(buf, "Compressed frame is %d bytes\n", unSizeBitStream);
		DBOUT(buf);
	}
	#endif
	#endif

	/********************************************************************
	 * Copy the compressed image to the output area.   This is done after
	 * possibly updating the picture checksum.
	 ********************************************************************/
	memcpy( lpicComp->lpOutput, EC->pU8_BitStream, unSizeBitStream);

	/* zero only the dirty part of the bitstream buffer */ 
	#ifdef ENCODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
//	unSize = CompressGetSize(lpCompInst, lpicComp->lpbiInput, lpicComp->lpbiOutput);
	memset(EC->pU8_BitStream, 0, unSizeBitStream);
	#ifdef ENCODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uZeroingBufferSum)
	#endif

	#ifdef ENCODE_STATS
		TIMER_STOP(bTimingThisFrame,uStartLow,uStartHigh,uEncodeFrameSum);
		if (bTimingThisFrame)
		{
			pEncTimingInfo = EC->pEncTimingInfo + uFrameCount;
			pEncTimingInfo->uEncodeFrame      = uEncodeFrameSum;
			pEncTimingInfo->uInputCC          = uInputCCSum;
			pEncTimingInfo->uMotionEstimation = uMotionEstimationSum;
			pEncTimingInfo->uFDCT             = uFDCTSum;
			pEncTimingInfo->uQRLE             = uQRLESum;
			pEncTimingInfo->uDecodeFrame      = uDecodeFrameSum;
			pEncTimingInfo->uZeroingBuffer    = uZeroingBufferSum;
//			pEncTimingInfo->uSLF_UV           = uSLF_UVSum;
			/* Verify that we have time for all the required steps 
			 */
			ASSERT(pEncTimingInfo->uEncodeFrame);
			ASSERT(pEncTimingInfo->uInputCC);
			ASSERT(pEncTimingInfo->uMotionEstimation);
			ASSERT(pEncTimingInfo->uFDCT);
			ASSERT(pEncTimingInfo->uQRLE);
			ASSERT(pEncTimingInfo->uDecodeFrame);
			ASSERT(pEncTimingInfo->uZeroingBuffer);
//			ASSERT(pEncTimingInfo->uSLF_UV);
		}
	#endif

	lResult = ICERR_OK;

done:
	if (pEncoderInst) 
	{
		GlobalUnlock(lpCompInst->hEncoderInst);
	}

	return lResult;
} /* end H263Compress() */


/*****************************************************************************
 *
 *  H263TermEncoderInstance
 *
 *  This function frees the space allocated for an instance of the H263 encoder.
 */
LRESULT H263TermEncoderInstance(LPCODINST lpCompInst)
{
	LRESULT lResult;
	LRESULT lLockingResult;
	LRESULT lDecoderResult;
	LRESULT lColorOutResult;
	U8 BIGG * P32Inst;
	T_H263EncoderCatalog FAR * EC;

	// Check instance pointer
	if (!lpCompInst)
		return ICERR_ERROR;

	if(lpCompInst->Initialized == FALSE)
	{
		DBOUT("Warning: H263TermEncoderInstance(): Uninitialized instance")
		lResult = ICERR_OK;
		goto done;
	}
	lpCompInst->Initialized = FALSE;

	lpCompInst->EncoderInst = (LPVOID)GlobalLock(lpCompInst->hEncoderInst);
	if (lpCompInst->EncoderInst == NULL)
	{
		DBOUT("ERROR :: H263TermEncoderInstance :: ICERR_MEMORY");
		lLockingResult = ICERR_MEMORY;
		lColorOutResult = ICERR_OK;
		lDecoderResult = ICERR_OK;
	}
	else
	{
		lLockingResult = ICERR_OK;
        P32Inst = (U8 *)
  			  ((((U32) lpCompInst->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
		// P32Inst = (U8 *) ((((U32) lpCompInst->EncoderInst) + 31) & ~0x1F);
		EC = ((T_H263EncoderCatalog  *) P32Inst);

		// Check encoder catalog pointer
		if (!EC)
			return ICERR_ERROR;

		#ifdef ENCODE_STATS
//			OutputEncodeBitStreamStatistics(ENCODE_STATS_FILENAME, &EC->BSInfo, EC->PictureHeader.SourceFormat == SF_CIF);
			OutputEncodeTimingStatistics(ENCODE_STATS_FILENAME, EC->pEncTimingInfo);
		#endif

		/* Terminate the color converter
		 */
		lColorOutResult = H263TermColorConvertor(EC->pDecInstanceInfo);
		if (lColorOutResult != ICERR_OK) 
		{
			DBOUT("Terminating the color converter failed.");
		}

		/* Terminate the decoder
		 */
		lDecoderResult = H263TermDecoderInstance(EC->pDecInstanceInfo);
		if (lDecoderResult != ICERR_OK) 
		{
			DBOUT("Terminating the decoder failed.");
		}

    	GlobalUnlock(lpCompInst->hEncoderInst);
		GlobalFree(lpCompInst->hEncoderInst);
	}

	/* set the result
	 */
	if (lLockingResult != ICERR_OK)
	{
		lResult = lLockingResult;
	}
	else if (lColorOutResult != ICERR_OK)
	{
		lResult = lColorOutResult;
	}
	else if (lDecoderResult != ICERR_OK)
	{
		lResult = lDecoderResult;
	}
	else
	{
		lResult = ICERR_OK;
	}

done:

	return lResult;
}

/*****************************************************************************
 *
 *  WriteBeginPictureHeaderToStream
 *
 *  Write the beginning of the picture header to the stream updating the 
 *  stream pointer and the bit offset.	The beginning of the picture header
 *  is everything but the zero PEI bit
 */
static void WriteBeginPictureHeaderToStream(
	T_H263EncoderCatalog *EC,
	U8 ** ppu8CurBitStream,
	U8 * pu8BitOffset)
{
	/* Picture Start Code */
	PutBits(FIELDVAL_PSC, FIELDLEN_PSC, ppu8CurBitStream, pu8BitOffset);

	/* Temporal Reference */
	PutBits( EC->PictureHeader.TR, FIELDLEN_TR, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Split screen indicator */
	PutBits( EC->PictureHeader.Split, FIELDLEN_PTYPE_SPLIT, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Document camera indicator. */
	PutBits( EC->PictureHeader.DocCamera, FIELDLEN_PTYPE_DOC, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Freeze picture release. */
	PutBits( EC->PictureHeader.PicFreeze, FIELDLEN_PTYPE_RELEASE, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Source image format. */
	PutBits( EC->PictureHeader.SourceFormat, FIELDLEN_PTYPE_SRCFORMAT, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Still image indicator. */
	PutBits( EC->PictureHeader.StillImage, FIELDLEN_PTYPE_STILL, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Still image indicator. */
	PutBits( EC->PictureHeader.Spare, FIELDLEN_PTYPE_SPARE, ppu8CurBitStream, pu8BitOffset);

} /* end WriteBeginPictureHeaderToStream() */


/*****************************************************************************
 *
 *  WriteEndPictureHeaderToStream
 *
 *  Write the end of the picture header to the stream updating the 
 *  stream pointer and the bit offset.  The end of the picture header is the
 *  zero PEI bit.
 */
static void WriteEndPictureHeaderToStream(
	T_H263EncoderCatalog *EC,
	U8 ** ppu8CurBitStream,
	U8 * pu8BitOffset)
{
	/* PEI - Extra insertion information */
	PutBits( EC->PictureHeader.PEI, FIELDLEN_PEI, ppu8CurBitStream, pu8BitOffset);

} /* end WriteEndPictureHeaderToStream() */


#ifdef CHECKSUM_PICTURE
/*****************************************************************************
 *
 *  WritePictureChecksum
 *
 *  Write the picture checksum to the file.  
 *
 *  This function should be able to be called twice.  The first time it should 
 *  be called with 0 values after saving the values of the bitstream poointer 
 *  and bitoffset.  After completing the picture call it with the actual 
 *  checksum values to update.
 */
static void WritePictureChecksum(
	YVUCheckSum * pYVUCheckSum,
	U8 ** ppu8CurBitStream,
	U8 * pu8BitOffset,
	U8 u8ValidData)
{
	U32 uBytes;
	UN unData;

	/* Tag data
	 */
	unData = (UN) u8ValidData;
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	/* Y date - high to low bytes.
	 */
	uBytes = pYVUCheckSum->uYCheckSum;

	unData = (UN) ((uBytes >> 24) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 16) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 8) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) (uBytes & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	/* V date - high to low bytes.
	 */
	uBytes = pYVUCheckSum->uVCheckSum;

	unData = (UN) ((uBytes >> 24) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 16) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 8) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) (uBytes & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	/* U date - high to low bytes.
	 */
	uBytes = pYVUCheckSum->uUCheckSum;

	unData = (UN) ((uBytes >> 24) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 16) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 8) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) (uBytes & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	
} /* WritePictureChecksum() */
#endif


/*****************************************************************************
 *
 *  WriteGOBHeaderToStream
 *
 *  Write the GOB header to the stream updating the stream pointer and the
 *  bit offset.
 */
static void WriteGOBHeaderToStream(
	U32 uGOBNumber,
	UN unGQuant,
	U8 ** ppu8CurBitStream,
	U8 * pu8BitOffset)
{
	/* GOB Start Code */
	PutBits(FIELDVAL_GBSC, FIELDLEN_GBSC, ppu8CurBitStream, pu8BitOffset);

	/* GOB Number */
	PutBits((int)uGOBNumber, FIELDLEN_GN, ppu8CurBitStream, pu8BitOffset);

	/* GOB Quant */
	PutBits((int)unGQuant, FIELDLEN_GQUANT, ppu8CurBitStream, pu8BitOffset);

	/* GEI */
	PutBits(0, FIELDLEN_GEI, ppu8CurBitStream, pu8BitOffset);

} /* end WriteGOBHeaderToStream() */


/************************************************************************
 * 
 * CalcGOBChromaVecs
 */
static void CalcGOBChromaVecs(
	T_H263EncoderCatalog * EC, 
	UN unStartingMB,
    T_CONFIGURATION *pConfiguration)
{
	#ifdef ENCODE_STATS
//	#include "ctiming.h"
	U32 uStartLow = EC->uStartLow;
	U32 uStartHigh = EC->uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uSLF_UVSum = 0;
	int bTimingThisFrame = EC->bTimingThisFrame;
	ENC_TIMING_INFO * pEncTimingInfo = NULL;
	#endif

	register T_MBlockActionStream *pCurrMB;
	T_MBlockActionStream *pLastMBPlus1;
	char HMV;
	char VMV;
	int c;

	pCurrMB = &(EC->pU8_MBlockActionStream[unStartingMB]);
	pLastMBPlus1 = &(EC->pU8_MBlockActionStream[unStartingMB + 33]);
	for( c = unStartingMB; pCurrMB <  pLastMBPlus1 ; pCurrMB++, c++)
	{
	    if (IsIntraBlock(pCurrMB->BlockType))
			continue;

		/* Now that are using +/- 15 pel motion search, need to change
		   valid range of returned MVs.  Remember these are in 1/2 pel
		   increments.  Valid range is [-32,31] now.
		*/
		/*
	    ASSERT( (pCurrMB->BlkY1.PHMV >= -15) &&
	            (pCurrMB->BlkY1.PHMV <= 15) )
	    ASSERT( (pCurrMB->BlkY1.PVMV >= -15) &&
	            (pCurrMB->BlkY1.PVMV <= 15) )
		*/

	    ASSERT( (pCurrMB->BlkY1.PHMV >= -32) &&
	            (pCurrMB->BlkY1.PHMV <= 31) )
	    ASSERT( (pCurrMB->BlkY1.PVMV >= -32) &&
	            (pCurrMB->BlkY1.PVMV <= 31) )

        // RTP: resiliency considerations check

        if (pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
        {
           if (pConfiguration->bDisallowAllVerMVs)
           {
              ASSERT(pCurrMB->BlkY1.PVMV == 0);
           }
           else if (pConfiguration->bDisallowPosVerMVs)
                {
                   ASSERT(pCurrMB->BlkY1.PVMV <= 0);
                }
        }
	    HMV = QtrPelToHalfPel[pCurrMB->BlkY1.PHMV+32];
	    VMV = QtrPelToHalfPel[pCurrMB->BlkY1.PVMV+32];

		/* Make sure we don't do half pel interpolation in the fdct 
		 */
		HMV = (HMV / 2) * 2;
		VMV = (VMV / 2) * 2;
	    
	    /* Assign the motion vectors for use in the dct
		 */
	    pCurrMB->BlkU.PHMV = HMV;
	    pCurrMB->BlkU.PVMV = VMV;
	    pCurrMB->BlkV.PHMV = HMV;
	    pCurrMB->BlkV.PVMV = VMV;

		// TBD: get Brian to put this in ex5me.asm
		if (IsSLFBlock(pCurrMB->BlockType))
		{  
			/*
			if (pCurrMB->CodedBlocks & 0x2)
				ASSERT(pCurrMB->BlkY2.B4_7.PastRef == pCurrMB->BlkY1.B4_7.PastRef + 8);
			if (pCurrMB->CodedBlocks & 0x4)
				ASSERT(pCurrMB->BlkY3.B4_7.PastRef == pCurrMB->BlkY1.B4_7.PastRef + 8*PITCH);
			if (pCurrMB->CodedBlocks & 0x8)
				ASSERT(pCurrMB->BlkY4.B4_7.PastRef == pCurrMB->BlkY1.B4_7.PastRef + 8*PITCH+8);
			*/
			if (pCurrMB->CodedBlocks & 0x2)
				pCurrMB->BlkY2.B4_7.PastRef = pCurrMB->BlkY1.B4_7.PastRef + 8;
			if (pCurrMB->CodedBlocks & 0x4)
				pCurrMB->BlkY3.B4_7.PastRef = pCurrMB->BlkY1.B4_7.PastRef + 8*PITCH;
			if (pCurrMB->CodedBlocks & 0x8)
				pCurrMB->BlkY4.B4_7.PastRef = pCurrMB->BlkY1.B4_7.PastRef + 8*PITCH+8;
		}

		/* Motion vectors are in half pels.  So we need to divide by 2 to get
		 * to integer pels.
		 */
		ASSERT((VMV / 2) == (VMV >> 1)); /* since we divided by 2 and mult above */
		ASSERT((HMV / 2) == (HMV >> 1));
 		VMV >>= 1;
		HMV >>= 1;

#ifdef SLF_WORK_AROUND

 	 	pCurrMB->BlkU.B4_7.PastRef =
	        EC->pU8_PrevFrm_YPlane 
	        + pCurrMB->BlkU.BlkOffset 
	        + VMV*PITCH + HMV;
    
	    pCurrMB->BlkV.B4_7.PastRef =
	        EC->pU8_PrevFrm_YPlane 
	        + pCurrMB->BlkV.BlkOffset 
	        + VMV*PITCH + HMV;

		/* Currently U & V are not SLF. 
           TBD:  assemble version of SLF for U & V, ask Brian
		 */
		if (IsSLFBlock(pCurrMB->BlockType))
		{  
			if (pCurrMB->CodedBlocks & 0x10) 
			{
			#ifdef ENCODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif

				EncUVLoopFilter((U8*)pCurrMB->BlkU.B4_7.PastRef, 
					(U8*)EC->pU8_SLFFrm_YPlane+pCurrMB->BlkU.BlkOffset,PITCH);
				pCurrMB->BlkU.B4_7.PastRef = 
					EC->pU8_SLFFrm_YPlane+pCurrMB->BlkU.BlkOffset;
			}

			if (pCurrMB->CodedBlocks & 0x20)
			{
				EncUVLoopFilter((U8*)pCurrMB->BlkV.B4_7.PastRef, 
					(U8*)EC->pU8_SLFFrm_YPlane+pCurrMB->BlkV.BlkOffset,PITCH);
				pCurrMB->BlkV.B4_7.PastRef = 
					EC->pU8_SLFFrm_YPlane+pCurrMB->BlkV.BlkOffset;
			#ifdef ENCODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uSLF_UVSum)
			#endif
			}
		}		
 
#else
 	 	pCurrMB->BlkU.B4_7.PastRef =
	        EC->pU8_PrevFrm_YPlane 
	        + pCurrMB->BlkU.BlkOffset 
	        + VMV*PITCH + HMV;
    
	    pCurrMB->BlkV.B4_7.PastRef =
	        EC->pU8_PrevFrm_YPlane 
	        + pCurrMB->BlkV.BlkOffset 
	        + VMV*PITCH + HMV;
#endif

	}  /* for(pCurrMB ... */
	#ifdef ENCODE_STATS
		if (bTimingThisFrame)
		{
			pEncTimingInfo = EC->pEncTimingInfo + EC->uStatFrameCount;
			pEncTimingInfo->uSLF_UV += uSLF_UVSum;
		}
	#endif

} /* end CalcGOBChromaVecs() */


/************************************************************************
 *
 *  GetEncoderOptions
 *
 *  Get the options, saving them in the catalog
 */
static void GetEncoderOptions(
	T_H263EncoderCatalog * EC)
{
	int bSetOptions = 1;
	
	/* Default Options
	 */
	const int bDefaultUseMotionEstimation = 1;
	const int bDefaultUseSpatialLoopFilter = 1;
	const char * szDefaultBRCType = "Normal";
	const U32 uDefaultForcedQuant = 8;
	const U32 uDefaultForcedDataRate = 1024;
	const float fDefaultForcedFrameRate = (float) 8.0; /* should be the same as szDefaultForcedFrameRate */
	
	#ifndef RING0
	const char * szDefaultForcedFrameRate = "8.0";	   /* should be the same as fDefaultForcedFrameRate */
	#endif

	/* INI file variables
	 */
	#ifndef RING0
	UN unResult;
	DWORD dwResult;
	char buf120[120];
	float fResult;
	#define SECTION_NAME	"Encode"
	#define INI_FILE_NAME	"h261test.ini"
	#endif

	/* Read the options from the INI file
	 */
	#ifndef RING0
	{
		DBOUT("Getting options from the ini file h261test.ini");
	
		/* Motion Estimation 
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "MotionEstimation", bDefaultUseMotionEstimation, INI_FILE_NAME);
		if (unResult != 0  && unResult != 1)
		{
			#ifdef _DEBUG
			wsprintf(string,"MotionEstimation ini value error (should be 0 or 1) - using default=%d", 
				     (int) bDefaultUseMotionEstimation);
			DBOUT(string);
			#endif
			
			unResult = bDefaultUseMotionEstimation;
		}
		EC->bUseMotionEstimation = unResult;

		/* Set the custom parameters for motion estimation.
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEzerothresh", MECatalog[ME_CUSTOM_CTRLS].zero_vector_threshold, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].zero_vector_threshold = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEnonzerodiff", MECatalog[ME_CUSTOM_CTRLS].nonzero_MV_differential, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].nonzero_MV_differential = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEemptythresh", MECatalog[ME_CUSTOM_CTRLS].empty_threshold, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].empty_threshold = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEinterthresh", MECatalog[ME_CUSTOM_CTRLS].intercoding_threshold, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].intercoding_threshold = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEinterdiff", MECatalog[ME_CUSTOM_CTRLS].intercoding_differential, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].intercoding_differential = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEslfthresh", MECatalog[ME_CUSTOM_CTRLS].slf_threshold, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].slf_threshold = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEslfdiff", MECatalog[ME_CUSTOM_CTRLS].slf_differential, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].slf_differential = unResult;

		/* Enable or disable the custom parameters for motion estimation.
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "CustomME", 0, INI_FILE_NAME);
		EC->bUseCustomMotionEstimation = unResult ? 1 : 0;

		/* Spatial Loop Filter
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "SpatialLoopFilter", bDefaultUseSpatialLoopFilter, INI_FILE_NAME);
		if (unResult != 0  && unResult != 1)
		{
			#ifdef _DEBUG
			wsprintf(string,"SpatialLoopFilter ini value error (should be 0 or 1) - using default=%d",
				  (int) bDefaultUseSpatialLoopFilter);
			DBOUT(string);
			#endif
			
			unResult = bDefaultUseSpatialLoopFilter;
		}
		EC->bUseSpatialLoopFilter = unResult;

		/* Bit Rate Controller Type
		 */
		strcpy(buf120,"Error");
		dwResult = GetPrivateProfileString(SECTION_NAME, "BRCType", szDefaultBRCType, buf120, 120, INI_FILE_NAME);
		if ((dwResult == 0) ||
		    ((strcmp(buf120,"Normal") != 0)         &&
		     (strcmp(buf120,"ForcedQuant") != 0)	&&
			 (strcmp(buf120,"ForcedDataRate") != 0)))
		{
			#ifdef _DEBUG
			wsprintf(string,"BRCType ini value error (should be Normal, ForcedQuant, or ForcedDataRate) - using default=%s",
			         szDefaultBRCType);
			DBOUT(string);
			#endif
			
			strcpy(buf120,szDefaultBRCType);
		}
		if (strcmp(buf120,"Normal") == 0)
		{
			EC->u8BRCType = BRC_Normal;
		}
		else if (strcmp(buf120,"ForcedQuant") == 0)
		{
			EC->u8BRCType = BRC_ForcedQuant;
		}
		else if (strcmp(buf120,"ForcedDataRate") == 0)
		{
			EC->u8BRCType = BRC_ForcedDataRate;
		}
		else
		{
			ASSERT(0);
		}

		/* ForcedQuant
		 */
		if (EC->u8BRCType == BRC_ForcedQuant)
		{
			unResult = GetPrivateProfileInt(SECTION_NAME, "ForcedQuant", uDefaultForcedQuant, INI_FILE_NAME);
			if (unResult < 6  || unResult > 31)
			{
				#ifdef _DEBUG
				wsprintf(string, "ForcedQuant ini value error (should be 6 to 31) - using default=%d",
				         uDefaultForcedQuant);
				DBOUT(string);
				#endif

				unResult = uDefaultForcedQuant;
			}
			EC->uForcedQuant = unResult;
		}

		/* ForcedDataRate
		 */
		if (EC->u8BRCType == BRC_ForcedDataRate)
		{
			unResult = GetPrivateProfileInt(SECTION_NAME, "ForcedDataRate", uDefaultForcedDataRate, INI_FILE_NAME);
			if (unResult < 1)
			{
				#ifdef _DEBUG
				wsprintf(string,"ForcedDataRate ini value error (should be > 0) - using default=%d",
						 uDefaultForcedDataRate);
				DBOUT(string);
				#endif
				unResult = uDefaultForcedDataRate;
			}
			EC->uForcedDataRate = unResult;

			strcpy(buf120,"0.0");
			dwResult = GetPrivateProfileString(SECTION_NAME, "ForcedFrameRate", szDefaultForcedFrameRate, buf120, 120, INI_FILE_NAME);
			if (dwResult > 0)
			{
				fResult = (float) atof(buf120);
			}
			else
			{
				fResult = (float) 0.0;
			}
			if ( fResult <= 0.0 || fResult > 30.0)
			{
				#ifdef _DEBUG
				wsprintf(string, "ForcedFrameRate ini value error (should be > 0.0 and <= 30.0) - using default=%s",
					     szDefaultForcedFrameRate);
				DBOUT(string);
				#endif
				fResult = fDefaultForcedFrameRate;
			}
			EC->fForcedFrameRate = fResult;
		}

		bSetOptions = 0;
	}
	#endif
	
	if (bSetOptions)
	{
		EC->bUseMotionEstimation = bDefaultUseMotionEstimation;
		EC->bUseSpatialLoopFilter = bDefaultUseSpatialLoopFilter;
		EC->u8BRCType = BRC_Normal;
		EC->uForcedQuant = uDefaultForcedQuant;			  /* Used with BRC_ForcedQuant */
		EC->uForcedDataRate = uDefaultForcedDataRate;	  /* Used with BRC_ForcedDataRate */
		EC->fForcedFrameRate = fDefaultForcedFrameRate;	  /* Used with BRC_ForcedDataRate */
	} 

	/* Can only use the SLF if ME is on
	 */
	if (EC->bUseSpatialLoopFilter && !EC->bUseMotionEstimation)
	{
		DBOUT("The Spatial Loop Filter can not be on if Motion Estimation is OFF");
		EC->bUseSpatialLoopFilter = 0;
	}

	/* Display the options
	 */
	if (EC->bUseMotionEstimation)
	{
		DBOUT("Encoder option (Motion Estimation) is ON");
	}
	else
	{
		DBOUT("Encoder option (Motion Estimation) is OFF");
	}
	if (EC->bUseSpatialLoopFilter)
	{
		DBOUT("Encoder option (Spatial Loop Filter) is ON");
	}
	else
	{
		DBOUT("Encoder option (Spatial Loop Filter) is OFF");
	}

	#ifdef _DEBUG
	if (EC->bUseCustomMotionEstimation)
	{
		wsprintf(string, "Encoder option (Custom Motion Estimation) %5d %5d %5d %5d %5d %5d %5d",
				MECatalog[ME_CUSTOM_CTRLS].zero_vector_threshold,
				MECatalog[ME_CUSTOM_CTRLS].nonzero_MV_differential,
				MECatalog[ME_CUSTOM_CTRLS].empty_threshold,
				MECatalog[ME_CUSTOM_CTRLS].intercoding_threshold,
				MECatalog[ME_CUSTOM_CTRLS].intercoding_differential,
				MECatalog[ME_CUSTOM_CTRLS].slf_threshold,
				MECatalog[ME_CUSTOM_CTRLS].slf_differential
		  );
		DBOUT(string);
	}
	#endif

	#ifdef _DEBUG
	switch (EC->u8BRCType)
	{
		case BRC_Normal: 
			DBOUT("Encoder option (BRC Type) is Normal");
			break;
		case BRC_ForcedQuant:
			wsprintf(string, "Encoder option (BRC Type) is ForcedQuant with value=%d", EC->uForcedQuant);
			DBOUT(string);
			break;
		case BRC_ForcedDataRate:
			wsprintf(string, "Encoder option (BRC Type) is ForcedDataRate with value=%d", EC->uForcedDataRate);
			DBOUT(string);
			break; 
		default:
			ASSERT(0); /* shouldn't happen */
			break;
	}
	#endif
	DBOUT("Encoder option (UsePerfmonNFMO) is OFF");
	DBOUT("Encoder option (MMX) is OFF");
} /* end GetEncoderOptions() */


/************************************************************************
 *
 *  StartupBRC
 *
 *	Start up the Bit Rate Controller for this frame
 *	- set EC->bBitRateControl 
 *  - set BRCState.TargetFrameRate
 *  - set BRCState.uTargetFrmSize
 *  - set EC->PictureHeader.PQuant
 */
static void StartupBRC(
	T_H263EncoderCatalog * EC,
	U32 uVfWDataRate,					   	/* VfW data rate - byte per frame */
	U32 uVfWQuality,					   	/* VfW Quality 1..10000 */
	float fVfWFrameRate)				   	/* VfW frame rate */
{
	FX_ENTRY("StartupBRC");
	/* Values used to constrain Quant based on Quality.  
	 *
	 * When you change these remember to change GetOptions. 
	 */
	const int iLowFixedQuant = 6;    // the lowest value without clipping artifacts
	const int iHighFixedQuant = 31;	 // the highest value
	I32 iRange;
	I32 iValue;
	float fValue;

	switch (EC->u8BRCType) {
	case BRC_Normal:
	    if (uVfWDataRate == 0)
	    {
	        EC->bBitRateControl = 0;
			EC->BRCState.TargetFrameRate = (float) 0.0; /* turn it off */
			EC->BRCState.uTargetFrmSize = 0;	/* should not be used */
			/* Compute the fixed quant from the quality
			 */
			iRange = iHighFixedQuant - iLowFixedQuant;
			ASSERT((iRange >= 0) && (iRange <= 30));
			iValue = (10000 - (int)uVfWQuality);
			ASSERT((iValue >= 0) && (iValue <= 10000));
			fValue = (float)iValue * (float)iRange / (float)10000.0;
			iValue = (int) (fValue + (float) 0.5);
			iValue += iLowFixedQuant;
			ASSERT((iValue >= iLowFixedQuant) && (iValue <= iHighFixedQuant));
	        EC->PictureHeader.PQUANT = (U8) iValue;

			DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller disabled, setting EC->PictureHeader.PQUANT = %ld\r\n", _fx_, EC->PictureHeader.PQUANT));
	    }
	    else
	    {
	        EC->bBitRateControl = 1;
			EC->BRCState.TargetFrameRate = fVfWFrameRate;
	        EC->BRCState.uTargetFrmSize = uVfWDataRate;

			DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller enabled with\r\n", _fx_));
			DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Target frame rate = %ld.%ld fps\r\n  Target quality = %ld\r\n  Target frame size = %ld bits\r\n  Target bitrate = %ld bps\r\n", (DWORD)EC->BRCState.TargetFrameRate, (DWORD)(EC->BRCState.TargetFrameRate - (float)(DWORD)EC->BRCState.TargetFrameRate) * 10UL, uVfWQuality, (DWORD)EC->BRCState.uTargetFrmSize << 3, (DWORD)(EC->BRCState.TargetFrameRate * EC->BRCState.uTargetFrmSize) * 8UL));
			DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Minimum quantizer = %ld\r\n  Maximum quantizer = 31\r\n", clampQP((10000 - uVfWQuality)*15/10000)));

	        EC->PictureHeader.PQUANT = CalcPQUANT( &(EC->BRCState), EC->PictureHeader.PicCodType);
	    }
		break;
	case BRC_ForcedQuant:
		EC->bBitRateControl = 0;
		EC->BRCState.TargetFrameRate = (float) 0.0; /* turn it off */
		EC->BRCState.uTargetFrmSize = 0;	/* should not be used */
		EC->PictureHeader.PQUANT = (U8) EC->uForcedQuant;
		break;
	case BRC_ForcedDataRate:
		EC->bBitRateControl = 1;
		EC->BRCState.TargetFrameRate = EC->fForcedFrameRate;
		EC->BRCState.uTargetFrmSize = EC->uForcedDataRate;

		DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller enabled with\r\n", _fx_));
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Target frame rate = %ld.%ld fps\r\n  Target quality = %ld\r\n  Target frame size = %ld bits\r\n  Target bitrate = %ld bps\r\n", (DWORD)EC->BRCState.TargetFrameRate, (DWORD)(EC->BRCState.TargetFrameRate - (float)(DWORD)EC->BRCState.TargetFrameRate) * 10UL, uVfWQuality, (DWORD)EC->BRCState.uTargetFrmSize << 3, (DWORD)(EC->BRCState.TargetFrameRate * EC->BRCState.uTargetFrmSize) * 8UL));
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Minimum quantizer = %ld\r\n  Maximum quantizer = 31\r\n", clampQP((10000 - uVfWQuality)*15/10000)));

		EC->PictureHeader.PQUANT = CalcPQUANT( &(EC->BRCState), EC->PictureHeader.PicCodType);
		break;
	default:
		ASSERT(0); /* should never happen */
		break;
	}

    #ifdef DEBUG_BRC
	wsprintf(string,"PQuant=%d", EC->PictureHeader.PQUANT);
	DBOUT(string);
	#endif
} /* end StartupBRC() */


/************************************************************************
 *
 * CalculateQP_mean
 * 
 * Calculate the new QP_mean value.
 *
 * TBD: Consider making this more sophisticated - ie: look at more than
 * the last frame or look at the second order affect.
 */
static void CalculateQP_mean(
	T_H263EncoderCatalog * EC)
{
    /* Calculate average quantizer to be used for next frame.
	 * The current approach changes QP at the beginning of each row.
	 */

/* uQP_count no longer on a row of macroblocks bases, Arlene 6/20/96
	if ( EC->PictureHeader.SourceFormat == SF_CIF ) 
	{
		ASSERT(EC->uQP_count == 2*EC->NumMBRows);	
	} 
	else
	{
		ASSERT(EC->uQP_count == EC->NumMBRows);	
	}
*/
    
    /* If this is an an INTRA picture use the inter default as QP_mean
	 * Otherwise compute QP_mean.
	 */
	if (EC->PictureHeader.PicCodType == INTRAPIC)
	{
		EC->BRCState.QP_mean = EC->u8DefINTER_QP;
	}
	else
	{
    	EC->BRCState.QP_mean = 	EC->uQP_cumulative / EC->uQP_count;

/* New method, Arlene 6/20/96
    	EC->BRCState.QP_mean = 
    		(EC->uQP_cumulative + (EC->uQP_count >> 1)) / EC->uQP_count;
*/
	}
} /* end CalculateQP_mean() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\e1enc.h ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;//      Copyright (c) 1995-1996 Intel Corporation.
;//      All Rights Reserved.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Author:   RHAZRA  $
;// $Date:   21 Oct 1996 10:46:40  $
;// $Archive:   S:\h26x\src\enc\e1enc.h_v  $
;// $Header:   S:\h26x\src\enc\e1enc.h_v   1.35   21 Oct 1996 10:46:40   RHAZRA  $
;//
;////////////////////////////////////////////////////////////////////////////
#ifndef __E1ENC_H__
#define __E1ENC_H__

/* This file declares structs which catalog the locations of various
 * tables, structures, and arrays needed by the H261 encoder.
 */

enum SourceFormat {SF_QCIF=0, SF_CIF=1};

/* If the size of T_H261FrameHeaderStruct is changed, then
 * that change must be updated in T_H261EncoderCatalog below
 */
typedef struct {
    // fields in the header
 	EnumOnOff	Split;			// split screen indicator
    EnumOnOff	DocCamera;		// document camera indicator
    EnumOnOff	PicFreeze;		// freeze picture release
	EnumOnOff   StillImage;     // still image mode
	EnumPicCodType	PicCodType;	// picture code type
    U8 	TR;						// temporal reference
    U8	SourceFormat;			// source format
	U8  Spare;					// spare bit
	U8	PEI;					// pei indicator
	
	// Not in the header but needed by the algorithm
	U8	PQUANT;					// picture level quantization
	U8  Pad[3];					// Pad to a mulitple of 4
} T_H261FrameHeaderStruct;
const int sizeof_T_H261FrameHeaderStruct = 28;

/*
  This file declares structs which catalog the locations of various
  tables, structures, and arrays needed by the H263 encoder.
*/

/*
 * Block description structure. Must be 16-byte aligned.
 */
typedef struct {
    U32     BlkOffset;	// [0-3]  Offset to 8*8 target block from start of Y plane.
    union {
        U8 	*PastRef;	// [4-7]  Address of 8*8 reference block.
        struct {
            U8 HMVf;
            U8 VMVf;
            U8 HMVb;
            U8 VMVb;
        }	BestMV;
    } B4_7;
    struct {
        U8 HMVf;
        U8 VMVf;
        U8 HMVb;
        U8 VMVb;
    } CandidateMV;
	char PHMV;		// [12]   Horizontal motion vector for P block..
	char PVMV;		// [13]   Vertical motion vector for P block..
	char BHMV;		// [14]   Horizontal motion vector for B block..
	char BVMV;		// [15]   Vertical motion vector for B block..
} T_Blk;
const int sizeof_T_Blk = 16;

/*
 * T_MBlockActionStream - Structure to keep side information for a MB
 * used by encoder. This structure must be 16-byte aligned when allocated.
 * CodedBlocks must be DWORD aligned.
 * The entire structure must be a multiple of 16 bytes, and must
 * match the size of the structure in e3mbad.inc.
 * 
 */
typedef struct {
	U8	BlockType;		// 0   -- See block types below.
	U8  MBEdgeType;     // 1   -- 1 off if left edge| 2 right| 4 top | 8 bottom.
	U8	Unassigned1;   	// 2   --
	U8	FirstMEState;	// 3   -- First State Num for Motion Estimation engine.
	U8	CodedBlocks;	// 4   -- [6] End-of-Stream indicator
						//        [0] indicates Y1 non-empty
						//        [1...5] indicates Y2, Y3, Y4, U, V nonempty.
						//        Other bits zero.
	U8	CodedBlocksB;	// 5   -- [0...5] like CodedBlocks, but for B frame.
						//        Set to 0 for non bi-di prediction.
	U8	Unassigned2[2]; // 6...7
	U32	SWD;			// 8...11  Sum of weighted diffs, from motion estimation.
	U32	SWDB;			// 12...15 Sum of weighted diffs, from B frame motion estimation.
	T_Blk	BlkY1;		// 16...31
	T_Blk	BlkY2;		// 32...47
	T_Blk	BlkY3;		// 48...63
	T_Blk	BlkY4;		// 64...79
	T_Blk	BlkU;		// 80...95
	T_Blk	BlkV;		// 96...111

	U8	COD;			// 112 -- Coded macroblock indication. When set to "0"
	  					//        indicates that macroblock is coded. If set to
						//        "1", it indicates that the macroblock is not coded
						//         and the rest of the macroblock layer is empty.
	U8	MBType;			// 113 -- Macro block type, {INTER, INTER+Q, INTER4V, INTRA, INTRA+Q}
	U8	CBPC;			// 114 -- Coded block pattern for chrominance.
	U8	MODB;			// 115 -- Macroblock mode for B-blocks.
	U8	CBPB;			// 116 -- Coded block pattern for B blocks.
	U8	CBPY;			// 117 -- Coded block pattern for luminance.
	U8	DQUANT;			// 118 -- Quantizer information. A two bit pattern to define
	   					//        change in QUANT.
	U8	InterCodeCnt;	// 119 -- Count number of times current MB has been intercoded.
	U8	Unassigned4[8]; // 120...127 -- Pad out to a power of two.
} T_MBlockActionStream;
const int sizeof_T_MBlockActionStream = 128;

/*
 * Block Types
 */
const U8 INTERBLOCK = 0;
const U8 INTRABLOCK = 1;
const U8 INTERSLF	= 2;

#define IsInterBlock(t)	(t != INTRABLOCK)
#define IsIntraBlock(t)	(t == INTRABLOCK)
#define IsSLFBlock(t)	(t == INTERSLF)
 
/* MB Types
 */
const U8 INTER	= 0;
const U8 INTERQ	= 1;
const U8 INTER4V= 2;
const U8 INTRA	= 3;
const U8 INTRAQ	= 4;

/* First ME state for ME engine
 */
const U8 ForceIntra	= 0;
const U8 UpperLeft	= 1;
const U8 UpperEdge	= 2;
const U8 UpperRight	= 3;
const U8 LeftEdge	= 4;
const U8 CentralBlock = 5;
const U8 RightEdge	= 6;
const U8 LowerLeft	= 7;
const U8 LowerEdge	= 8;
const U8 LowerRight	= 9;
const U8 NoVertLeftEdge	= 10;
const U8 NoVertCentralBlock = 11;
const U8 NoVertRightEdge = 12;

/* Coded block bit masks.
 */
const U8 Y1BLOCK = 0x01;
const U8 Y2BLOCK = 0x02;
const U8 Y3BLOCK = 0x04;
const U8 Y4BLOCK = 0x08;
const U8 UBLOCK  = 0x10;
const U8 VBLOCK  = 0x20;

/* Bit Rate Control Type
 */
const U8 BRC_Undefined      = 0;
const U8 BRC_ForcedQuant    = 1;
const U8 BRC_ForcedDataRate = 2;
const U8 BRC_Normal         = 3;

typedef struct {
   U8 StateNumInc_SelectCentralPt;
   U8 MVIncIdx_SelectCentralPt;
   U8 StateNumInc_SelectRef1;
   U8 MVIncIdx_SelectRef1;
   U8 StateNumInc_SelectRef2;
   U8 MVIncIdx_SelectRef2;
   U16 pad;
} T_SADState;

/* For optimal performance, the parameters to be used when invoking motion
   estimation should depend on our runtime state.  Here we define a struct
   to hold motion estimation parameters.  A particular instance of this
   struct is selected at runtime.
   See the motion estimation routines for a description of each parameter.
 */
typedef struct {
  I32   zero_vector_threshold;
  I32   nonzero_MV_differential;
  I32   empty_threshold;
  I32   intercoding_threshold;
  I32   intercoding_differential;
  I32   slf_threshold;
  I32   slf_differential;
} T_MotionEstimationControls;

/* T_H263EncoderCatalog - Catalog of information needed for an instance.
 * This structure must be multiple of 16.
 */
typedef struct {
    U8        *pU8_CurrFrm;         // 0 Pointers to current frame buffers
    U8        *pU8_CurrFrm_YPlane;	// 4
    U8        *pU8_CurrFrm_VPlane;	// 8
    U8        *pU8_CurrFrm_UPlane;	// 12

    U8        *pU8_PrevFrm;         // 16 Pointers to previous frame buffers
    U8        *pU8_PrevFrm_YPlane;	// 20
    U8        *pU8_PrevFrm_VPlane;	// 24
    U8        *pU8_PrevFrm_UPlane;	// 28

    U8        *pU8_SLFFrm;		    // 32 Pointers to spatial loop filter frame
    U8        *pU8_SLFFrm_YPlane;	// 36
    U8        *pU8_SLFFrm_UPlane;	// 40
    U8        *pU8_SLFFrm_VPlane;	// 44

    T_MBlockActionStream *pU8_MBlockActionStream; // 48 Pointer to macro block action stream.
    I32       *pU8_DCTCoefBuf;		// 52 Pointer to GOB DCT coefficient buffer.
    U8        *pU8_BitStream;		// 56 Pointer to bitstream buffer.
    U32       uBase;                // 60 RTP: takes place of Unassigned0[1]
    T_H261FrameHeaderStruct PictureHeader;  // 64..91 (28 bytes) Picture layer header structure.

    UN        FrameHeight;		// 92
    UN        FrameWidth;		// 96
    FrameSize FrameSz;			// 100 Define frame size: SQCIF, QCIF, CIF
    UN        NumMBRows;        // 104 Number of rows of MB's
    UN        NumMBPerRow;      // 108 Number of MB's in a row.
    UN        NumMBs;		    // 112 Total number of MBs.

    LPDECINST pDecInstanceInfo; // 116 Private decoder instance info.

	/* Temporal Reference
	 */
	float	fTR_Error;		// 120
	U8	u8LastTR;		    // 124
	U8	u8Pad0[3];		    // 125

 
	/* Bit Rate Controller 
	 */
	BRCStateStruct BRCState;	// 128...159 (32 bytes) Bit Rate Controller state	
	U32 	  uQP_cumulative;	// 160 Cumulative QP value
	U32	      uQP_count;		// 164 Number of accumulated QP values
	U8        u8DefINTRA_QP;	// 168 Default Intra QP value
	U8        u8DefINTER_QP;	// 169 Default Inter QP value
                                        
    /* Flags
	 */
	U8	bMakeNextFrameKey;	// 170
	U8	bBitRateControl;	// 171
    
    /* Options
	 */
	U8        bUseMotionEstimation;	// 172 either 1 or 0 - if 0 ME will not be called
	U8        bUseSpatialLoopFilter;// 173 either 1 or 0 - if 0 Spatial Loop Filter will not be used
	U8        u8BRCType;		// 174 Bit Rate Controller Type
	U8        u8Pad1[1];		// 175 align to four bytes

	U32	      uForcedQuant;		// 176 if u8BRCType == BRC_ForcedQuant
	U32       uForcedDataRate;	// 180 if u8BRCType == BRC_ForcedDataRate
	float     fForcedFrameRate;	// 184 if u8BRCType == BRC_ForcedDataRate
	
	/* Statistics	 */
	ENC_BITSTREAM_INFO BSInfo;	         // 188..539 (352 bytes)
	ENC_TIMING_INFO *pEncTimingInfo;	 // 540
	U32 uStatFrameCount;		         // 544
	/* The following are needed in lower level routines */
	int bTimingThisFrame;		         // 548
	U32 uStartLow;			             // 552
	U32 uStartHigh;			             // 556
	U32 uBitUsageProfile[397];	         // 560..2147  Table for storing bit usage profile
                                         // 397 is large enough for FCIF+1 worth of MacroBlocks
                                         // element 0...NumMBs-1 stores cumulative bit usage
                                         // element NumMBs stores the final frame size
	                    			     // Note: NumMBs is 0...395
	HANDLE hBsInfoStream;                // 2148
    void *pBsInfoStream;                 // 2152
    U32  uPacketSizeThreshold;           // 2156
    void *pBaseBsInfoStream;             // 2160
    U32  uNumOfPackets;                  // 2164
    U32  uNextIntraMB;                   // 2168
    U32  uNumberForcedIntraMBs;          // 2172

    U8        *pU8_Signature;            // 2176
    U8        *pU8_Signature_YPlane;     // 2180

	I8        *pI8_MBRVS_Luma;           // 2184
    I8        *pI8_MBRVS_Chroma;         // 2188

    /* bUseCustomMotionEstimation is used for tuning motion estimation
       parameters.  It is enabled via the h261 "ini" file, and causes
       custom values to be used when invoking motion estimation.  See the
       GetEncoderOptions routine for a description of the custom values.
     */
    U8        bUseCustomMotionEstimation;
    U8	U8pad[15];
} T_H263EncoderCatalog;

/*
 * T_H263EncoderInstanceMemory
 *     Memory layout for encoder instance. The memory is allocated 
 * dynamically and the beginning of this structure is aligned to a 
 * 32 byte boundary.
 * All arrays should be start on a DWORD boundary.
 * MBActionStream should start on a 16 byte boundary.
 */

// Define bit stream buffer size.
const unsigned int sizeof_bitstreambuf = 352*288*3/4;

// This structure is allocated on a 32 byte boundary.
typedef struct {
	T_H263EncoderCatalog EC;					        	 
	U8  UnAssigned0[2304 - sizeof(T_H263EncoderCatalog)]; // Align to 32 byte boundary (2176+32).
	T_MBlockActionStream MBActionStream[33*12];			    
	// 57,536 / 32 = 1798 chunks of 32 bytes

	U8	UnAssigned1[16];     							 // Align to 16 and not 32
	U8	u8CurrentPlane [ (288+16+8+144)*384 + 8 ];
	U8	u8Pad1[ 80 - 8 ];                                // (Prev - Current) % 128 == 80
	U8	u8PreviousPlane[ (16+288+16+8+144+8)*384 + 64];  // Reconstructed past
	/* The difference between the SLF and Previous pointers MOD 4096 should equal 944
	 * Since the previous memory contains 16 buffered lines with a 16 byte offset
	 * while the SLF memory only has the 16-byte offset we ignore the 16*PITCH in
	 * calculating the difference.
	 *		((288+16+8+144+8)*384 + 64) % 4096 = 2112
	 * Since 2112 is > 944 we need to pad almost 4096 bytes.
	 */
	U8  u8Pad2[ 4096 - (2112 - 944) ];	// (SLF - Prev) % 4096 == 944
	U8  u8SLFPlane[ (288+16+8+144)*384 + 8];	// Spatial Loop Filter working area
	U8  u8Pad3[ 8 ];

	U8	u8BitStream [ sizeof_bitstreambuf ];

	/*
	 * Allocate space for DCT coefficients for an entire GOB.
	 * Each block of coefficients is stored in 32 DWORDS (2 coefs/DWORD)
	 * and there are 6 blocks in a macroblock, and 33 MBs in a GOB.
	 */
	I32 piGOB_DCTCoefs[32*6*33];						// Align to 32 byte boundary

	U8  u8Signature[(16+288+16)*384 + 24];	// Should be placed correctly for optimal
	U8  u8Pad4[ 8 ];			// Align to 32 byte boundary

	I8 i8MBRVS_Luma[65 * 3 * 33 * 4];
	I8 i8MBRVS_Chroma[65 * 3 * 33 * 2];

	DECINSTINFO	DecInstanceInfo;	// Private decoder instance.

	#ifndef RING0
	ENC_TIMING_INFO	EncTimingInfo[ENC_TIMING_INFO_FRAME_COUNT];
	#endif
  }	T_H263EncoderInstanceMemory;

  // Define offsets from Y to U planes, and U to V planes.
  const int YU_OFFSET = (288+16+8)*384;
  const int UV_OFFSET = 192;
  const int CurPrev_OFFSET = 181328;	// Offset from current to previous frame buffer.
    
/****************************************************************
 * Function prototypes
 ****************************************************************/
void colorCnvtFrame(
    T_H263EncoderCatalog * EC,
    LPCODINST              lpCompInst,
    ICCOMPRESS           * lpicComp,
    U8                   * YPlane,
    U8                   * UPlane,
    U8                   * VPlane
);


void PutBits(
	unsigned int fieldval, // Value of field to write to stream.
	unsigned int fieldlen, // Length of field to be written
	unsigned char **pbs, 				// Pointer to current byte in bitstream
	unsigned char *bitoffset	// bit offset in current byte of bitstream.
	);

extern "C" void FORWARDDCT (T_MBlockActionStream * MBlockActionStream,
    U8 *  TargetFrameBaseAddr,
    U8 *  PreviousFrameBaseAddr,
    U8 *  FutureFrameBaseAddr,
    I32 * CoeffStream,
    int   IsBFrame,
    int   IsAdvancedPrediction,
    int   ISPofPBPair,
    U8 *  ScratchBlocks,
    int   NumberofMBlksInGOB
);

extern "C" void MOTIONESTIMATION (
    T_MBlockActionStream * MBlockActionStream,
    U8  * TargetFrameBaseAddr,
    U8  * PreviousFrameBaseAddr,
    U8  * FilteredFrameBaseAddr,
    int   DoRadius15Search,
    int   DoHalfPelEstimation,
    int   DoBlockLevelVectors,
    int   DoSpatialFiltering,
    int   ZeroVectorThreshold,
    int   NonZeroMVDifferential,
    int   BlockMVDifferential,
    int   EmptyThreshold,
    int   InterCodingThreshold,
    int   IntraCodingDifferential,
    int   SLFThreshold,
    int   SLFDifferential,
    U32 * IntraSWDTotal,
    U32 * IntraSWDBlocks,
    U32 * InterSWDTotal,
    U32 * InterSWDBlocks
);

extern "C" I8 * QUANTRLE(
    I32  *CoeffStr, 
    I8   *CodeStr, 
    I32   QP, 
    I32   BlockType
);

extern "C" void MBEncodeVLC(
    I8 **,
    I8 **,
    U32 , 
    U8 **, 
    U8 *, 
    I32,
    I32
);


#ifdef SLF_WORK_AROUND
extern "C" {
void FAR EncUVLoopFilter (
		U8 * uRefBlock,
		U8 * uDstBlock,
		I32 uDstPitch);
};
#endif

/*
 * Routine to quantize, rle, vlc and write to bitstream
 * for an entire GOB.
 */
void GOB_Q_RLE_VLC_WriteBS(
	T_H263EncoderCatalog * EC,
	I32 *DCTCoefs,
	U8 **pBitStream,
	U8 *pBitOffset,
	UN  unStartingMB,
	UN  gquant,
	BOOL bOverFlowWarningFlag,
    BOOL bRTPHeader,  // RTP: definition
    U32  uGOBNUmber,  // RTP: definition
	U8 u8QPMin
    );

void GOB_VLC_WriteBS(
	T_H263EncoderCatalog * EC,
    I8 *pMBRVS_Luma,
	I8 *pMBRVS_Chroma,	
	U8 **pBitStream,
	U8 *pBitOffset,
	UN unGQuant,
	UN  unStartingMB,
    BOOL bRTPHeader,  // RTP: definition
    U32  uGOBNUmber  // RTP: definition
    );


void InitVLC(void);

struct T_MAXLEVEL_PTABLE {
	int	maxlevel;
	int * ptable;
	};

//extern "C" { UN FAR ASM_CALLTYPE H263EOffset_DecoderInstInfo(); }

#endif		// #ifndef _E1ENC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\dxgetbit.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 13:54:10  $
;// $Archive:   S:\h26x\src\dec\dxgetbit.cpv  $
;// $Header:   S:\h26x\src\dec\dxgetbit.cpv   1.2   22 Dec 1995 13:54:10   KMILLS  $
;// $Log:   S:\h26x\src\dec\dxgetbit.cpv  $
// 
//    Rev 1.2   22 Dec 1995 13:54:10   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.1   01 Aug 1995 12:28:10   DBRUCKS
// change to read most sig bit first and to not read too many bytes
// 
//    Rev 1.0   31 Jul 1995 13:00:16   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   28 Jul 1995 09:46:26   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////// 

#include "precomp.h"

const U32 GetBitsMask[33] = {
	0x00000000, 0x00000001, 0x00000003, 0x00000007,
	0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
	0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
	0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
	0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
	0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
	0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
	0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
	0xffffffff
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h261\dxbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
//
// $Author:   mbodart  $
// $Date:   24 Mar 1997 15:00:34  $
// $Archive:   S:\h26x\src\dec\dxbase.cpv  $
// $Header:   S:\h26x\src\dec\dxbase.cpv   1.46   24 Mar 1997 15:00:34   mbodart  $
//	$Log:   S:\h26x\src\dec\dxbase.cpv  $
// 
//    Rev 1.46   24 Mar 1997 15:00:34   mbodart
// Fix PVCS tracker bug 150 in the H.263 bug base:  allow a change of
// dimensions in "redundant" DecompressBegin's.
// 
//    Rev 1.45   18 Mar 1997 16:21:10   MDUDA
// Commented out call to H263TermColorConvertor in DecompressEnd.
// This fixes a Graphedt problem where starts and stops cause a hang.
// 
//    Rev 1.44   18 Mar 1997 10:43:28   mbodart
// Quick one-line fix to previous change.  Note that there are still problems
// in graphedt, when trying a bunch of play-pause-stop-play... combinations.
// We need to re-evaluate how DecompressBegin/DecompressEnd deal with
// memory allocation and initialization.
// 
// Also rearranged some DbgLog messages in DecompressQuery to give more
// condensed information.
// 
//    Rev 1.43   14 Mar 1997 19:01:36   JMCVEIGH
// Removed H263TermDecoderInstance from DecompressEnd. Some apps.
// send a DecompressEnd, but then restart decompressing at the
// middle of the sequence (i.e., not a the previous keyframe). We
// therefore need to retain the reference frame. The instance is
// free in DrvClose.
// 
//    Rev 1.42   07 Mar 1997 09:07:42   mbodart
// Added a missing '#ifndef H261' in DecompressQuery.
// Added a call to _clearfp() in the Decompress exception handler, so that
// the exception will not reoccur in the caller's code.
// 
//    Rev 1.41   14 Jan 1997 11:16:22   JMCVEIGH
// Put flag for old still-frame mode backward compatibility under
// #ifdef H263P
// 
//    Rev 1.40   13 Jan 1997 10:51:14   JMCVEIGH
// Added NULL pointer checks in all functions that interface with
// application.
// 
//    Rev 1.39   10 Jan 1997 18:30:24   BECHOLS
// Changed decompress query so that it will accept negative heights.
// 
//    Rev 1.38   06 Jan 1997 17:40:24   JMCVEIGH
// Added support to ensure backward compatibility with old
// still-frame mode (crop CIF image to 320x240). Since 320x240 size
// is valid with arbitrary frame size support in H.263+, we check
// for this case by either comparing the source/destination header
// sizes or the source header size and the size contained in the
// picture header of the bitstream.
// 
//    Rev 1.37   03 Jan 1997 15:05:16   JMCVEIGH
// Re-inserted check in DecompressQuery that allows a H263 bitstream
// with frame dimensions 320x240 in non-prime decoder to be
// supported. This undos the elimination of this check in rev. 1.33.
// 
//    Rev 1.36   11 Dec 1996 16:02:34   MBODART
// 
// In Decompress, catch any exceptions and return an error code.  This gives
// upstream active movie filters a chance to recover gracefully.
// 
//    Rev 1.35   09 Dec 1996 18:02:10   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.34   27 Nov 1996 13:55:18   MBODART
// Added a comment to DecompressQuery that explicitly enumerates the
// formats and transformations that H.261 supports.
// 
//    Rev 1.33   21 Nov 1996 17:27:18   MDUDA
// Disables YUV12 output zoom by 2 and removed 160x120, 240x180,
// and 320x240 acceptance of H263 input.
// 
//    Rev 1.32   15 Nov 1996 08:39:56   MDUDA
// Added 640x480 frame size for H263 and FOURCC_YUV12.
// 
//    Rev 1.31   14 Nov 1996 09:22:34   MBODART
// Disable the ability to select a DCI color convertor, they don't exist!
// However, DCI col. conv. initialization does exist, and differs from
// non-DCI initialization.
// 
//    Rev 1.30   13 Nov 1996 10:58:32   RHAZRA
// H.261 YUV12 decoder now accepts CIF, QCIF, 160x120, 320x240 and 640x480
// 
//    Rev 1.29   12 Nov 1996 08:47:12   JMCVEIGH
// Removed initial arbitrary frame size support, i.e., reverted back
// to rev 1.27. Will hold off on custom picture format support until
// branch for release candidate for PS 3.0.
// 
//    Rev 1.28   11 Nov 1996 11:51:14   JMCVEIGH
// Added initial support for arbitrary frame sizes (H.263+ draft,
// document LBC-96-263). Define H263P to allow frame sizes from
// 4 <= width <= 352 and 4 <= height <= 288, where both width and
// height are multiples of 4.
// 
//    Rev 1.27   20 Oct 1996 13:31:46   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.26   26 Sep 1996 09:46:00   BECHOLS
// 
// Turned on Snapshot for H263.  This code merely sets up for the Snapshot
// copy, and waits on an event for the decoder to do the copy.  When the
// event is signaled, the Snapshot trigger wakes up and returns the status
// of the copy to the caller.
// 
//    Rev 1.25   25 Sep 1996 17:30:32   BECHOLS
// changed the snapshot code to wait on an event while the decoder
// does the snapshot copy.
// 
//    Rev 1.24   24 Sep 1996 13:51:42   BECHOLS
// 
// Added Snapshot() implementation.
// 
//    Rev 1.23   03 Sep 1996 16:29:22   CZHU
// enable DDRAW, removed define
// 
//    Rev 1.22   18 Jul 1996 09:24:36   KLILLEVO
// implemented YUV12 color convertor (pitch changer) in assembly
// and added it as a normal color convertor function, via the
// ColorConvertorCatalog() call.
// 
//    Rev 1.21   01 Jul 1996 10:05:10   RHAZRA
// 
// Turn off aspect ratio correction for YUY2 color conversion.
// 
//    Rev 1.20   19 Jun 1996 16:38:54   RHAZRA
// 
// Added a #ifdef to coditionally disable DDRAW (YUY2) support
// 
//    Rev 1.19   19 Jun 1996 14:26:28   RHAZRA
// Added code to (i) accept YUY2 as a valid output format (ii) select
// YUY2 color convertor in SelectColorConvertor()
// 
//    Rev 1.18   30 May 1996 17:08:52   RHAZRA
// Added SQCIF support for H263.
// 
//    Rev 1.17   30 May 1996 15:16:38   KLILLEVO
// added YUV12 output
// 
//    Rev 1.16   30 May 1996 10:13:00   KLILLEVO
// 
// removed one cluttering debug statement
// 
//    Rev 1.15   01 Apr 1996 10:26:34   BNICKERS
// Add YUV12 to RGB32 color convertors.  Disable IF09.
// 
//    Rev 1.14   09 Feb 1996 10:09:22   AKASAI
// Added ifndef RING0 around code in DecompressGetPalette to eliminate
// warning in building RING0 release version of codec.
// 
//    Rev 1.13   11 Jan 1996 16:59:14   DBRUCKS
// 
// cleaned up DecompressQuery
// added setting of bProposedCorrectAspectRatio (in Query) and
// bCorrectAspectRatio (in Begin) if the source dimensions are SQCIF,
// QCIF, or CIF and the destination dimensions are the aspect ratio
// sizes with a possible zoom by two.
// 
//    Rev 1.12   18 Dec 1995 12:51:38   RMCKENZX
// added copyright notice
// 
//    Rev 1.11   13 Dec 1995 13:22:54   DBRUCKS
// 
// Add assertions to verify that the source size is not changing on
// a begin.
// 
//    Rev 1.10   07 Dec 1995 13:02:52   DBRUCKS
// fix spx release build
// 
//    Rev 1.9   17 Nov 1995 15:22:30   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.8   15 Nov 1995 15:57:24   AKASAI
// Remove YVU9 from decompress and decompress_query.
// (Integration point)
// 
//    Rev 1.7   25 Oct 1995 18:12:36   BNICKERS
// Add YUV12 color convertors.  Eliminate YUV9 looking glass support.
// 
//    Rev 1.6   17 Oct 1995 17:31:24   CZHU
// 
// Fixed a bug in DecompressQuery related to YUV12
// 
//    Rev 1.5   18 Sep 1995 08:40:50   CZHU
// 
// Added support for YUV12
// 
//    Rev 1.4   08 Sep 1995 12:11:12   CZHU
// Output compressed size for debugging
// 
//    Rev 1.3   25 Aug 1995 13:58:06   DBRUCKS
// integrate MRV R9 changes
// 
//    Rev 1.2   23 Aug 1995 12:25:12   DBRUCKS
// Turn on the color converters
// 
//    Rev 1.1   01 Aug 1995 12:27:38   DBRUCKS
// add PSC parsing
// 
//    Rev 1.0   31 Jul 1995 13:00:12   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:14   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:26   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

extern BYTE PalTable[236*4];

#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)

/***************************************************************************
 *
 * Build16bitModeID().
 *
 * given red, green and blue values showing their maximum value,
 * count the bits standing and then form a decimal digit which lists
 * the number of red bits in the hundreds position, green in the tens
 * position and blue in the ones position.
 *
 * This code is used when the RGB16 table is built so the correct
 * field size will be used.
 *
 * returns the 16 bit mode ID
 *
 * Prototype in rgb16cct.h
 *
 ***************************************************************************/
int Build16bitModeID(I32 red, I32 green, I32 blue)
{
    int rval;
    int Rbits, Gbits, Bbits;
    U32 i;

	for (Rbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Rbits += (red & i) ? 1 : 0;
	for (Gbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Gbits += (green & i) ? 1 : 0;
	for (Bbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Bbits += (blue & i) ? 1 : 0;
	rval = Rbits * 100 + Gbits * 10 + Bbits;

    return(rval);
}


/***********************************************************************
 * SelectConvertor(LPDECINST, BOOL);
 * History:        03/18/94 -BEN-
 ***********************************************************************/
static UINT SelectConvertor(
    LPDECINST lpInst,
    LPBITMAPINFOHEADER lpbiDst, 
    BOOL bIsDCI)
{
    UINT    uiCnvtr = 0xFFFF;
    DWORD FAR * pDW = (DWORD FAR *)((LPBYTE)lpbiDst+sizeof(BITMAPINFOHEADER));
    int RequestedMode;
    
	/* Force off the DCI color converters because we can not be sure that the
	 * archive data has not changed.
	 * Also, we have no DCI color convertors, so don't select one!
	 */
	
	bIsDCI = 0;		 

    switch(lpInst->outputDepth)
	{
    case    12:
		if ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV))
        {
            DBOUT("SelectConvertor:YUV12 selected \n");
            uiCnvtr = YUV12NOPITCH;  // YUV12 output
		}
        break;

    case    8:  
        if (lpInst->UseActivePalette==0)
        {
            switch(lpInst->XScale)
            {
            case 1:
                if(bIsDCI == TRUE)
                {
                    uiCnvtr = CLUT8DCI;
                    DBOUT("SelectConvertor:CLUT8DCI selected \n");
                }
                else
                {
                    DBOUT("SelectConvertor:CLUT8 selected \n");
                    uiCnvtr = CLUT8; 
                }
                break;

            case 2:
                if(bIsDCI == TRUE)
                {
                    DBOUT("SelectConvertor:CLUT8DCIx2 selected \n");
                    uiCnvtr = CLUT8ZoomBy2DCI;
                }
                else 
                {
                    uiCnvtr = CLUT8ZoomBy2; 
                    DBOUT("SelectConvertor:CLUT8x2 selected \n");
                }
                break;
            } 
        }
        else 
        {
            switch(lpInst->XScale)
            {
            case 1:
                if(bIsDCI == TRUE) 
                {
                    DBOUT("SelectConvertor:CLUT8APDCI selected \n");
                    uiCnvtr = CLUT8APDCI;                                       
                }
                else 
                {
                    DBOUT("SelectConvertor:CLUT8AP selected \n");
                    uiCnvtr = CLUT8APDCI;
                }
                break;
                   

            case 2: 
                if(bIsDCI == TRUE) 
                {
                    DBOUT("SelectConvertor:CLUT8APDCIx2 selected \n");
                    uiCnvtr = CLUT8APZoomBy2DCI; 
                }
                else 
                {
                    DBOUT("SelectConvertor:CLUT8APDCIx2 selected \n");
                    uiCnvtr = CLUT8APZoomBy2DCI;
                }
                break;
            }   
        }
        break;
 
	case 16:
        // check which mode is

        if (lpbiDst->biCompression == FOURCC_YUY2)
		{
            DBOUT("SelectConvertor:YUY2 selected \n");
            uiCnvtr = YUY2DDRAW;
            break;
        }
        else
		{
            if (lpbiDst->biCompression == BI_RGB)
                RequestedMode = 555; /* default rgb16 mode */
            else //if (lpbiDst->biCompression == BI_BITFIELDS)
                RequestedMode = Build16bitModeID(pDW[0], pDW[1], pDW[2]);

            switch (RequestedMode)
			{
            case 555:  
                switch(lpInst->XScale)
                {
                case 1:
                    DBOUT("SelectConvertor:RGB16,555 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16555DCI;
                    else
                        uiCnvtr = RGB16555;
                    break;

                case 2:
                    DBOUT("SelectConvertor:RGB16x2,555 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16555ZoomBy2DCI;
                    else
                        uiCnvtr = RGB16555ZoomBy2;
                    break;
                }   //end of 555
                break; 
			     
            case 664:   
                switch(lpInst->XScale)
                {
                case 1:
                    DBOUT("SelectConvertor:RGB16,664 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16664DCI;
                    else
                        uiCnvtr = RGB16664;
                    break;

                case 2:
                    DBOUT("SelectConvertor:RGB16x2,664 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16664ZoomBy2DCI;
                    else
                        uiCnvtr = RGB16664ZoomBy2;
                    break;
                }   //end of 664
                break; 
			   
            case 565:  
                switch(lpInst->XScale)
                {
                case 1:
                    DBOUT("SelectConvertor:RGB16,565 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16565DCI;
                    else
                        uiCnvtr = RGB16565;
                    break;
                    
                case 2:
                    DBOUT("SelectConvertor:RGB16x2,565 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16565ZoomBy2DCI;
                    else
                        uiCnvtr = RGB16565ZoomBy2;
                    break;
                }   //end of 565
                break; 
			   
            case 655:   
                switch(lpInst->XScale)
                {
                case 1:
                    DBOUT("SelectConvertor:RGB16,655 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16655DCI;
                    else
                        uiCnvtr = RGB16655;
                    break;
                    
                case 2:
                    DBOUT("SelectConvertor:RGB16x2,655 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16655ZoomBy2DCI;
                    else
                        uiCnvtr = RGB16655ZoomBy2;
                    break;
                }   //end of 655
                break; 
			     
            default:
                break;
			
            } // switch

        } // else
	        		           
        break;
	   
	case    24:   
	    switch(lpInst->XScale)
		{
		case 1:
            DBOUT("SelectConvertor:RGB24 selected \n");
		    if(bIsDCI == TRUE)
                uiCnvtr = RGB24DCI;
		    else
                uiCnvtr = RGB24;
		    break;
            
		case 2:
            DBOUT("SelectConvertor:RGB24x2 selected \n");
		    if(bIsDCI == TRUE)
                uiCnvtr = RGB24ZoomBy2DCI;
		    else
                uiCnvtr = RGB24ZoomBy2;
		    break;
		}
	    break;

	case    32:   
	    switch(lpInst->XScale)
		{
		case 1:
            DBOUT("SelectConvertor:RGB32 selected \n");
		    if(bIsDCI == TRUE)
                uiCnvtr = RGB32DCI;
		    else
                uiCnvtr = RGB32;
		    break;

		case 2:
            DBOUT("SelectConvertor:RGB32x2 selected \n");
		    if(bIsDCI == TRUE)
                uiCnvtr = RGB32ZoomBy2DCI;
		    else
                uiCnvtr = RGB32ZoomBy2;
		    break;
		}
	    break;
	}

    return(uiCnvtr);
}

/***********************************************************************
 *   DWORD PASCAL DecompressQuery(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);
 * History:        02/18/94 -BEN-
 *
 * The following table summarizes the transformations that the H.261 decoder
 * and I420 color convertor support.
 *
 * H.261 Decoder Inputs and Outputs
 *
+--------------------------+-------------------------------------------------+
| Input Format             | Supported Output Formats for this Input Format  |
+--------------------------+-------------------------------------------------+
| H.261 FCIF (352 x 288)   | 352 x 288 RGBnn, YUV12 or YUY2                  |
|          or              | 352 x 264 RGBnn (aspect ratio correction)       |
| YUV12 FCIF (352 x 288)   | 704 x 576 RGBnn (zoom by 2)                     |
|                          | 704 x 528 RGBnn (zoom by 2, aspect ratio corr.) |
+--------------------------+-------------------------------------------------+
| H.261 QCIF (176 x 144)   | 176 x 144 RGBnn, YUV12 or YUY2                  |
|          or              | 176 x 132 RGBnn (aspect ratio correction)       |
| YUV12 QCIF (176 x 144)   | 352 x 288 RGBnn (zoom by 2)                     |
|                          | 352 x 264 RGBnn (zoom by 2, aspect ratio corr.) |
+--------------------------+-------------------------------------------------+
| YUV12  640 x 480         |  640 x 480 RGBnn, YUV12 or YUY2                 |
|                          | 1280 x 960 RGBnn (zoom by 2)                    |
+--------------------------+-------------------------------------------------+
| YUV12  320 x 240         | 320 x 240 RGBnn, YUV12 or YUY2                  |
|                          | 640 x 480 RGBnn (zoom by 2)                     |
+--------------------------+-------------------------------------------------+
| YUV12  160 x 120         | 160 x 120 RGBnn, YUV12 or YUY2                  |
|                          | 320 x 240 RGBnn (zoom by 2)                     |
+--------------------------+-------------------------------------------------+
 *
 *  Notes:
 *    o RGBnn represents RGB8, RGB16, RGB24 and RGB32.
 *    o Zoom by 2 and aspect ratio correction are not supported with YUY2 and
 *      YUV12 *output*.
 *    o Aspect ratio correction on output is only supported
 *      when the *input* resolution is exactly QCIF or FCIF.
 *
 ***********************************************************************/
DWORD PASCAL DecompressQuery(
	LPDECINST            lpInst, 
	ICDECOMPRESSEX FAR * lpicDecEx, 
	BOOL                 bIsDCI)
{
    LPBITMAPINFOHEADER lpbiSrc;
	LPBITMAPINFOHEADER lpbiDst;
	int iSrcWidth;
	int iSrcHeight;
	int iDstWidth;
	int iDstHeight;
	BOOL bSupportedSrcDimensions;

    if ((lpicDecEx == NULL) || (lpicDecEx->lpbiSrc == NULL))
		return (DWORD)ICERR_ERROR;

	// Set source and destination bitmap info headers
	lpbiSrc = lpicDecEx->lpbiSrc;
    lpbiDst = lpicDecEx->lpbiDst;

	// Check the source dimensions
	iSrcWidth = lpbiSrc->biWidth;
	iSrcHeight = lpbiSrc->biHeight;
	bSupportedSrcDimensions = FALSE;
	if (lpbiSrc->biCompression == FOURCC_H263)
	{
		/* H261 supports CIF and QCIF 
		 * H263 supports CIF, SQCIF, and QCIF.
		 * H263 also may need 160x120, 240x180, and 320x240 as Tom put special
		 * code into exbase to accept these.
		 */
#ifdef H263P
		/* H.263+ supports custom picture format with width [4,...,352],
		 * height [4,...,288], and both a multiple of 4.
		 */
		if ((iSrcWidth <= 352 && iSrcHeight <= 288) &&
			(iSrcWidth >= 4   && iSrcHeight >= 4)   &&
			(iSrcWidth & ~3) == iSrcWidth           &&
			(iSrcHeight & ~3) == iSrcHeight)

			bSupportedSrcDimensions = TRUE;
#else
		if ((iSrcWidth == 352 && iSrcHeight == 288) ||
			#ifndef H261
			(iSrcWidth == 128 && iSrcHeight == 96)  ||
			(iSrcWidth == 160 && iSrcHeight == 120) ||
			(iSrcWidth == 240 && iSrcHeight == 180) ||
			(iSrcWidth == 320 && iSrcHeight == 240) ||
			#endif
			(iSrcWidth == 176 && iSrcHeight == 144))

			bSupportedSrcDimensions = TRUE;
#endif // H263P
	}
	else if ((lpbiSrc->biCompression == FOURCC_YUV12) || (lpbiSrc->biCompression == FOURCC_IYUV))
	{
	
#ifndef H261
		if (((iSrcWidth <= 352 && iSrcHeight <= 288) &&
		     (iSrcWidth >= 4 && iSrcHeight >= 4) &&
			 ((iSrcWidth & ~3) == iSrcWidth) &&
			 ((iSrcHeight & ~3) == iSrcHeight)) ||
			(iSrcWidth == 640 && iSrcHeight == 480))
#else
		if ((iSrcWidth == 352 && iSrcHeight == 288) ||
            (iSrcWidth == 176 && iSrcHeight == 144) ||
			(iSrcWidth == 160 && iSrcHeight == 120) ||
			(iSrcWidth == 320 && iSrcHeight == 240) ||
			(iSrcWidth == 640 && iSrcHeight == 480))
#endif
			bSupportedSrcDimensions = TRUE;
	}
	
	if (! bSupportedSrcDimensions ) 
    {
        DBOUT("DecompressQuery:Unsupported src dimen \n");
		return (DWORD)ICERR_UNSUPPORTED;
	}
	
	/* Stop if just querying input
	 */
    if (lpbiDst == NULL)
		return ICERR_OK;                               

	/* Check the bit depth
	 */
	switch (lpbiDst->biBitCount) 
    {
	case 8:  
	    DBOUT("Checking 8 bits \n");
		if (lpbiDst->biCompression != BI_RGB)
			return((DWORD)ICERR_BADFORMAT); 
		break;

	case 12: 
		DBOUT("Checking 12 bits \n");
		if ((lpbiDst->biCompression != FOURCC_YUV12) && (lpbiDst->biCompression != FOURCC_IYUV))
	    	return((DWORD)ICERR_BADFORMAT); 
		break;
 

	case 16:  
	    DBOUT("Checking 16 bits  ");
		switch (lpicDecEx->lpbiDst->biCompression)
		{
		case BI_RGB: 
            DBOUT("DecompressQuery:BI_RGB \n");
            break;
		case BI_BITFIELDS: 
            DBOUT("DecompressQuery:BI_BITFIELDS \n");
			break;
		/*
		 * This definition of BI_BITMAP is here because MS has not provided
		 * a "standard" definition. When MS does provide it, it will likely be
		 * in compddk.h. At that time this definition should be removed.
		 */
		#define BI_BITMAP mmioFOURCC('B', 'I', 'T', 'M')
		case BI_BITMAP:  
		    DBOUT("Checking BI_BITMAP \n");
			if (lpicDecEx->lpbiDst->biYPelsPerMeter != 0)
            {   
                // output shouldn't cross a segment boundary in a scan line.
	    		return((DWORD)ICERR_BADFORMAT); 
			}
	    break;

		case FOURCC_YUY2:
            DBOUT("DecompressQuery:YUY2 \n");
            break;
		default:
			return((DWORD)ICERR_BADFORMAT); 
		} // switch biCompression
  		break;

	case 24:
	    DBOUT("Checking 24 bits \n");
		if (lpbiDst->biCompression != BI_RGB) 
        {
			return((DWORD)ICERR_BADFORMAT); 
		}
		break;

	case 32:
	    DBOUT("Checking 32 bits \n");
		if (lpbiDst->biCompression != BI_RGB) 
        {
			return((DWORD)ICERR_BADFORMAT); 
		}
		break;

	default:
	    return((DWORD)ICERR_BADFORMAT); 
		break;
	}

    /*
      if(lpbiDst->biCompression != BI_RGB && lpbiDst->biCompression != FOURCC_IF09)    // check color space
	{
    #define BI_BITMAP mmioFOURCC('B', 'I', 'T', 'M')
	if(lpbiDst->biCompression != BI_BITMAP)
	    return (DWORD)ICERR_UNSUPPORTED;
	if(lpbiDst->biYPelsPerMeter != 0)
	    {   
		
	    return (DWORD)ICERR_UNSUPPORTED;
	    }
	}
    */

   	//  Find the destination dimensions
	if (bIsDCI == TRUE)
	{
		iDstWidth = lpicDecEx->dxDst;
		iDstHeight = lpicDecEx->dyDst;
	}
	else
	{
		iDstWidth = lpbiDst->biWidth;
		iDstHeight = lpbiDst->biHeight;
	}
#ifdef _DEBUG
	{
		char buf80[80];
		wsprintf(buf80,"Query destination %d,%d", iDstWidth, iDstHeight);
		DBOUT(buf80);
	}
#endif

	// For the sake of the checks below, we need to take the absolute value
	// of the destination height.
	if(iDstHeight < 0)
	{
		iDstHeight = -iDstHeight;
	}

	// Check out the instance pointer
	if (!lpInst)
		return ICERR_ERROR;

#ifdef H263P
	// Initialize flag that is used for backward compatibility with old still
	// frame mode
	lpInst->bCIFto320x240 = FALSE;
#endif

	// Check the destination dimensions
	if ((iSrcWidth == iDstWidth) && (iSrcHeight == iDstHeight))
	{
		lpInst->pXScale = lpInst->pYScale = 1;
		lpInst->bProposedCorrectAspectRatio = FALSE;
	}
	else if ( ((iSrcWidth<<1) == iDstWidth) && ((iSrcHeight<<1) == iDstHeight) )
	{
		lpInst->pXScale = lpInst->pYScale = 2;
		lpInst->bProposedCorrectAspectRatio = FALSE;
	}
	else if (
	#ifndef H261
	         ((iSrcWidth == 128) && (iSrcHeight ==  96)) ||
	#endif
	         ((iSrcWidth == 176) && (iSrcHeight == 144)) ||
			     ((iSrcWidth == 352) && (iSrcHeight == 288))
			 )
	{
		/* Support aspect ratio correction for SQCIF, QCIF, and CIF
		 */
		if ( (iSrcWidth == iDstWidth) && ((iSrcHeight*11/12) == iDstHeight) )
		{
			lpInst->pXScale = lpInst->pYScale = 1;
			lpInst->bProposedCorrectAspectRatio = TRUE;
		}
		else if ( ((iSrcWidth<<1) == iDstWidth) && 
		          (((iSrcHeight<<1)*11/12) == iDstHeight) )
		{
			lpInst->pXScale = lpInst->pYScale = 2;
			lpInst->bProposedCorrectAspectRatio = TRUE;
		}
		else
		{
			return(DWORD)ICERR_UNSUPPORTED;
		}
	}
	else
	{
	    return(DWORD)ICERR_UNSUPPORTED;
	}

    /* check color depth 
     */
    if(lpbiDst->biBitCount !=  8 &&
       lpbiDst->biBitCount != 16 &&
       lpbiDst->biBitCount != 12  &&   // raw YUV12 output
       lpbiDst->biBitCount != 24 &&
       lpbiDst->biBitCount != 32)
	{
		return(DWORD)ICERR_UNSUPPORTED;
	}

	// Set the parameters
	lpInst->xres = (WORD)lpbiSrc->biWidth;
	lpInst->yres = (WORD)lpbiSrc->biHeight;

#if 0
	/* aspect ratio correction with YUY2 is not available */
// It's supported now, for direct draw support under Active Movie.

	if (lpInst && lpInst->bProposedCorrectAspectRatio && 
	    (lpbiDst->biCompression == FOURCC_YUY2))
	{
		return (DWORD)ICERR_UNSUPPORTED;
	}
#endif
	

	/* aspect ratio correction with YUV12 is not supported 
	 */
	if (lpInst && lpInst->bProposedCorrectAspectRatio && 
	    ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV)))
	{
		return (DWORD)ICERR_UNSUPPORTED;
	}

	/* No driver zooming in DirectDraw */

	if ( lpInst && ((lpInst->pXScale == 2) && (lpInst->pYScale == 2)) &&
	     (lpbiDst->biCompression == FOURCC_YUY2) )
	{
		 return (DWORD)ICERR_UNSUPPORTED;
	}

	/* No driver zooming for YUV12 */

	if ( lpInst && ((lpInst->pXScale == 2) && (lpInst->pYScale == 2)) &&
	     ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV)) )
	{
		 return (DWORD)ICERR_UNSUPPORTED;
	}
    return (DWORD)ICERR_OK;
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL DecompressGetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL DecompressGetPalette(
    LPDECINST lpInst, 
    LPBITMAPINFOHEADER lpbiSrc, 
    LPBITMAPINFOHEADER lpbiDst)
{
    DWORD dw;
    LPBYTE lpPalArea, PalStart;  
#ifndef RING0
    HDC hDC;
#endif
    BYTE tmp;
    int i;
//    int iUseActivePalette;
    ICDECOMPRESSEX icDecEx;

    icDecEx.lpbiSrc = lpbiSrc;
    icDecEx.lpbiDst = lpbiDst;
    if(dw = DecompressQuery(lpInst, &icDecEx, FALSE))
        return dw;

	if (lpbiDst == NULL) 
        return (DWORD)ICERR_ERROR;

    if(lpbiDst->biBitCount != 8)
    {
        DBOUT("DecompressGetPalette:ICERR_ERROR \n");
        return (DWORD)ICERR_ERROR;
    }
    lpbiDst->biClrUsed = 256;        /* specify all used */
    lpbiDst->biClrImportant = 0;

#ifndef RING0
    /* copy system palette entries (valid entries are 0-9 and 246-255) */
	hDC = GetDC(NULL);
	lpPalArea = (unsigned char FAR *)lpbiDst + (int)lpbiDst->biSize;
	GetSystemPaletteEntries(hDC, 0, 256, (PALETTEENTRY FAR *)lpPalArea);
	ReleaseDC(NULL, hDC);  
#endif
/*
#ifdef DEBUG
	iUseActivePalette = GetPrivateProfileInt("indeo", "UseActivePalette", 0, "system.ini");
	if (iUseActivePalette) {
		for (i = 0; i < 256; i++) {
			tmp = *lpPalArea;
			*lpPalArea = *(lpPalArea+2);
			*(lpPalArea+2) = tmp;
			lpPalArea += 4;
		}
		lpPalArea = (unsigned char FAR *)lpbiDst + (int)lpbiDst->biSize;
		_fmemcpy(lpInst->ActivePalette, lpPalArea, sizeof(lpInst->ActivePalette));
		lpInst->UseActivePalette = 1;
	}
#endif
*/

	if (!lpInst)
		return ICERR_ERROR;

#ifndef RING0
    if (lpInst->UseActivePalette == 1) 
    {
#ifdef WIN32
        memcpy(lpPalArea,lpInst->ActivePalette, sizeof(lpInst->ActivePalette));
#else
        _fmemcpy(lpPalArea,lpInst->ActivePalette, sizeof(lpInst->ActivePalette));
#endif
    }  
    else
    {  
#endif
        DBOUT("DecompressGetPalette \n");
        PalStart = (LPBYTE)lpbiDst + (int)lpbiDst->biSize;
        lpPalArea = PalStart + 40;        // fill in starting from the 10th
        for(i = 0; i < (236 << 2); i++)
            *lpPalArea++ = PalTable[i]; 
        
        lpPalArea = PalStart;   // reverse r&b: dealing with DIBs
        for(i = 0; i < 256; i++)// for all the entries,from PALENTRY to RGBQUAD
                                // fixed by CZHU, 1/23/95
        {
            tmp = *lpPalArea;
            *lpPalArea = *(lpPalArea+2);
            *(lpPalArea+2) = tmp;
            lpPalArea+=4;
        } 
#ifndef RING0
    }
#endif

    return (DWORD)ICERR_OK;
}


/***********************************************************************
 * DWORD PASCAL DecompressGetFormat(LPDECINST, LPBITMAPINFOHEADER,
 *                                  LPBITMAPINFOHEADER);
 * Description:    This allows us to suggest a good format to decompress to.
 *
 * History:        02/18/94 -BEN-
 ***********************************************************************/
DWORD PASCAL DecompressGetFormat(
    LPDECINST          lpInst, 
    LPBITMAPINFOHEADER lpbiSrc, 
    LPBITMAPINFOHEADER lpbiDst)
{
    DWORD dw;
    ICDECOMPRESSEX icDecEx;
	LPBYTE lpPalArea;
	int i;
	BYTE tmp;
	HDC hDC;
	BOOL f8Bit;

 