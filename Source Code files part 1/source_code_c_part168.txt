Hive.Signature != HHIVE_SIGNATURE ) {
        dprintf("Invalid Hive signature:  %lx\n",Hive.Signature);
        return;
    }

    dprintf("HSECTOR_SIZE = %lx\n",HSECTOR_SIZE);
    dprintf("HBLOCK_SIZE  = %lx\n",HBLOCK_SIZE);
    dprintf("PAGE_SIZE    = %lx\n",PAGE_SIZE);
    dprintf("\n");

    BitsPerULONG = 8*sizeof(ULONG);
    BitsPerBlock = 0x10000 / HBLOCK_SIZE; // 64k blocks
    BitsPerLine  = 0x40000 / HBLOCK_SIZE; // 256k lines (vicinity reasons)

    SizeOfBitmap = Hive.Storage[StorageCount].Length / HBLOCK_SIZE;
    
    DirtyBufferAddr = (ULONG_PTR)Hive.Storage[StorageCount].FreeDisplay[DisplayCount].Buffer;

    dprintf("Storage = %s , FreeDisplay[%lu]: \n",StorageCount?"Volatile":"Stable",DisplayCount);
    
    dprintf("\n%8s    %16s %16s %16s %16s","Address","64K (0x10000)","64K (0x10000)","64K (0x10000)","64K (0x10000)");

    for(i=0;i<SizeOfBitmap;i++) {
        ExitIfCtrlC();
        if( !(i%BitsPerLine) ){
            dprintf("\n 0x%8lx  ",i*HBLOCK_SIZE);
        }

        if( !(i%BitsPerBlock) ) {
            dprintf(" ");
        }
        if( !(i%BitsPerULONG) ) {
            //
            // fetch in a new DWORD
            //
            if( !ReadMemory(DirtyBufferAddr,
                        &DirtyBuffer,
                        sizeof(DirtyBuffer),
                        &BytesRead) ) {
                dprintf("\tRead %lx bytes from %lx\n",BytesRead,DirtyBufferAddr);
                return;
            }
            DirtyBufferAddr += sizeof(ULONG);
        }

        Mask = ((DirtyBuffer >> (i%BitsPerULONG)) & 0x1);
        //Mask <<= (BitsPerULONG - (i%BitsPerULONG) - 1);
        //Mask &= DirtyBuffer;
        dprintf("%s",Mask?"1":"0");
    }

    dprintf("\n\n");
}

DECLARE_API( help )
/*++

Routine Description:

    Called as:

        !help

Arguments:

    
Return Value:

    .

--*/

{
    dprintf("\nkcb\t\t<kcb_address>\n"); //OK, moved to kdexts
    dprintf("knode\t\t<knode_address>\n");//OK, moved to kdexts
    dprintf("kbody\t\t<kbody_address>\n");//OK, moved to kdexts
    dprintf("kvalue\t\t<kvalue_address>\n");//OK, moved to kdexts
    dprintf("cellindex\t<HiveAddr> <HCELL_INDEX>\n"); //OK, moved to kdexts
    dprintf("childlist\t<address>\n");// not worth moving, never used it
    dprintf("hashindex\t<ConvKey>\n");//OK, moved to kdexts
    dprintf("openkeys\t<HiveAddr|0>\n");//OK, moved to kdexts
    dprintf("baseblock\t<BaseBlockAddr>\n");//OK, moved to kdexts
    dprintf("findkcb\t\t<FullKeyPath>\n");//OK, moved to kdexts
    dprintf("seccache\t<HiveAddr>\n");//OK, moved to kdexts
    dprintf("viewlist\t<HiveAddr>\n");//OK, moved to kdexts
    dprintf("hivelist\n");//OK, moved to kdexts
    dprintf("freebins\t<HiveAddr>\n");//OK, moved to kdexts
    dprintf("dirtyvector\t<HiveAddr>\n");//OK, moved to kdexts
    dprintf("freecells\t<BinAddr>\n");//OK, moved to kdexts
    dprintf("freehints\t<HiveAddr> <Storage> <Display>\n");//OK, moved to kdexts
    dprintf("help\t\tThis screen\n\n");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\chkreg\regmain.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    regmain.c

Abstract:

    Main module. Data definitions.

Author:

    Dragos C. Sambotin (dragoss) 30-Dec-1998

Revision History:

--*/

#include "chkreg.h"

// check the hive structure.
BOOLEAN CheckHive = TRUE;

// compact the hive.
BOOLEAN CompactHive = FALSE;

// check for lost space (marked as used but not reffered).
BOOLEAN LostSpace = FALSE;

// repair damaged hives.
BOOLEAN FixHive = FALSE;

// repair damaged hives.
BOOLEAN SpaceUsage = FALSE;

// Verbose control.
BOOLEAN VerboseMode = FALSE;

// maximum level to dump 
ULONG   MaxLevel = 0;

// bin to examine space display
LONG    BinIndex = -1;

// the hive file name
TCHAR *Hive = NULL;

// the root of the hive
HCELL_INDEX RootCell;

// size of the file
DWORD FileSize;

// Usage string
char *Usage="\
Checks a hive file and perform repairs, compacts or displays a status report.\n\n\
CHKREG /F <filename[.<LOG>]> [/H] [/D [<level>] [/S [<bin>]] [/C] [/L] [/R] [/V]\n\n\
    <filename>      FileName of hive to be analyzed\n\
    /H              This manual\n\
    /D [<level>]    Dump subkeys up to level <level>. If level is not\n\
                    specified, dumps the entire hive. No checks are done\n\
                    when dumping.\n\
    /S [<bin>]      Displays space usage for the bin <bin>. When bin is\n\
                    not specified, displays usage for the entire hive.\n\
    /C              Compacts the hive. Bad hives cannot be compacted.\n\
                    The compacted hive will be written to <filename>.BAK\n\
    /L              Lost space detection.\n\
    /R              Repair the hive.\n\
    /V              Verbose Mode.\n\
    ";

// Lost Space Warning
char *LostSpaceWarning="\n\
WARNING :  Lost space detection may take a while. Are you sure you want this (y/n)?";

// Starting address of the in-memory maped hive image
PUCHAR Base;

// LostCells list used for lost space detection
UNKNOWN_LIST LostCells[FRAGMENTATION];

// OutputFile : future changes may use it to write the results to a file rather than to stdout
FILE *OutputFile;

#define NAME_BUFFERSIZE 2000

UNICODE_STRING  KeyName;
WCHAR NameBuffer[NAME_BUFFERSIZE];

// Miscelaneous variables used fo data statistics
ULONG   TotalKeyNode=0;
ULONG   TotalKeyValue=0;
ULONG   TotalKeyIndex=0;
ULONG   TotalKeySecurity=0;
ULONG   TotalValueIndex=0;
ULONG   TotalUnknown=0;

ULONG   CountKeyNode=0;
ULONG   CountKeyValue=0;
ULONG   CountKeyIndex=0;
ULONG   CountKeySecurity=0;
ULONG   CountValueIndex=0;
ULONG   CountUnknown=0;

ULONG   CountKeyNodeCompacted=0;

ULONG   TotalFree=0; 
ULONG   FreeCount=0; 
ULONG   TotalUsed=0;

PHBIN   FirstBin;
PHBIN   MaxBin;
ULONG   HiveLength;

#define OPTION_MODE 0
#define FILE_MODE   1
#define LEVEL_MODE  2
#define BIN_MODE    3

VOID
ChkDumpLogFile( PHBASE_BLOCK BaseBlock,ULONG Length );

VOID
ParseArgs (
    int argc,
    char *argv[]
    )
{

    char *p;
    int i;
    
    // specified what should we expect from the command line
    int iMode = OPTION_MODE;
    
    for(i=0;i<argc;i++) {
        p  = argv[i];
        if ( *p == '/' ) {
            // option mode
            p++;
            iMode = OPTION_MODE;
            while ((*p != '\0') && (*p != ' ')) {
                switch (*p) {
                case 'h':
                case 'H':
                case '?':
                    fprintf(stderr, "%s\n", Usage);
                    ExitProcess(1);
                    break;
                case 'f':
                case 'F':
                    iMode = FILE_MODE;
                    break;
                case 'd':
                case 'D':
                    iMode = LEVEL_MODE;
                    // when not specified, dump at least 100 levels
                    MaxLevel = 100;
                    CheckHive = FALSE;
                    break;
                case 's':
                case 'S':
                    SpaceUsage = TRUE;
                    iMode = BIN_MODE;
                    break;
                case 'c':
                case 'C':
                    p++;
                    CompactHive = TRUE;
                    break;
                case 'l':
                case 'L':
                    p++;
                    LostSpace = TRUE;
                    break;
                case 'r':
                case 'R':
                    p++;
                    FixHive = TRUE;
                    break;
                case 'V':
                case 'v':
                    p++;
                    VerboseMode = TRUE;
                    break;
                default:
                    p++;
                    break;
                }
                if( iMode != OPTION_MODE ) {
                    // break the loop; ignore the rest of the current argv
                    break;
                }
            } // while
        } else {
            switch(iMode) {
            case FILE_MODE:
                Hive = argv[i]; 
                break;
            case LEVEL_MODE:
                if( atol(argv[i]) >= 0 ) {
					MaxLevel = (ULONG)atol(argv[i]);
				}
                break;
            case BIN_MODE:
                BinIndex = (LONG) atol(argv[i]);
				if( BinIndex < -1 ) {
					BinIndex = 1;
				}
                break;
            default:
                break;
            }
        }
    }
    
}

__cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG   FileIndex;
    HANDLE myFileHandle, myMMFHandle;
    LPBYTE myMMFViewHandle;
    BYTE lowChar, hiChar, modVal;
    ULONG   Index,Index2;

    PHBASE_BLOCK PHBaseBlock;
    PHBIN        NewBins;
    ULONG        Offset;
    ULONG        CellCount;
    ULONG        SizeCount;

    REG_USAGE    TotalUsage;
    DWORD dwHiveFileAccess = GENERIC_READ;
    DWORD flHiveViewProtect = PAGE_READONLY;
    DWORD dwHiveViewAccess = FILE_MAP_READ;
    ParseArgs( argc, argv );

    if (!Hive) {
        fprintf(stderr, "\nMust provide a hive name !!!\n\n");
        fprintf(stderr, "%s\n", Usage);
        ExitProcess(-1);
    }

    if(LostSpace) {
    // are you sure you want lost cells detection? It may take a while!
        int chLost;
        fprintf(stdout, "%s",LostSpaceWarning);
        fflush(stdin);
        chLost = getchar();
        if( (chLost != 'y') && (chLost != 'Y') ) {
        // he changed his mind
            LostSpace = FALSE;
        }
        fprintf(stderr, "\n");
    }

    if( FixHive ) {
        dwHiveFileAccess |= GENERIC_WRITE;
        flHiveViewProtect = PAGE_READWRITE;
        dwHiveViewAccess = FILE_MAP_WRITE;
    }
    /* Create temporary file for mapping. */
    if ((myFileHandle = CreateFile (Hive, dwHiveFileAccess,
                                   0 , NULL, OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL))
         == (HANDLE) INVALID_HANDLE_VALUE) /* Bad handle */ {
        fprintf(stderr,"Could not create file %s\n", Hive);
        exit(-1);
    }

    // Get the size of the file.  I am assuming here that the
    // file is smaller than 4 GB.
    FileSize = GetFileSize(myFileHandle, NULL);

    /* If we get here, we managed to name and create a temp file. Now we need
       to create a mapping */

    myMMFHandle = CreateFileMapping (myFileHandle, NULL, flHiveViewProtect,
                                     0, FileSize, NULL);
    if (myMMFHandle == (HANDLE) INVALID_HANDLE_VALUE) {
        fprintf(stderr,"Could not map file %s\n", Hive);
        exit(-1);
    }

    /* So we've mapped the file. Now try to map a view */

    myMMFViewHandle = (LPBYTE) MapViewOfFile (myMMFHandle, dwHiveViewAccess, 0, 0, FileSize);
    if (!myMMFViewHandle) {
        fprintf(stderr,"Could not map view of file %s   error = %lx\n", Hive,(ULONG)GetLastError());
        exit(-1);
    }

    /* Now we have a view. Read through it */

    PHBaseBlock = (PHBASE_BLOCK) myMMFViewHandle;

    if( strstr(Hive,".LOG") != NULL ) {
        // dumping log file 
        ChkDumpLogFile(PHBaseBlock,MaxLevel);
    } else {
/*
        if (PHBaseBlock->Minor < 4) {
            fprintf(stderr,"Hive version %d is too old, must be 3 or later\n", PHBaseBlock->Minor);
            ExitProcess(-1);
        }
*/
        // Initialization stuff
        for(Index =0;Index<FRAGMENTATION;Index++) {
            LostCells[Index].Count = 0;
            for(Index2 = 0;Index2<SUBLISTS;Index2++) {
                LostCells[Index].List[Index2] = NULL;
            }
        }
    
        RootCell = PHBaseBlock->RootCell;
    
        OutputFile = stdout;
        Base = (PUCHAR)(PHBaseBlock) + HBLOCK_SIZE;

        Offset=HBLOCK_SIZE;
        HiveLength = PHBaseBlock->Length;

        if( HiveLength > (FileSize - HBLOCK_SIZE) ) {
            HiveLength = (FileSize - HBLOCK_SIZE);
        }
        MaxBin= (PHBIN) (Base + HiveLength);
        FirstBin = (PHBIN) (Base);

        KeyName.Buffer = NameBuffer;
        KeyName.MaximumLength = NAME_BUFFERSIZE;

        ChkBaseBlock(PHBaseBlock,FileSize);
    
        ChkSecurityDescriptors();

        ChkPhysicalHive();

        if (MaxLevel) {
            fprintf(stdout,"%6s,%6s,%7s,%10s, %s\n", 
                    "Keys",
                    "Values",
                    "Cells",
                    "Size",
                    "SubKeys");
        }

        DumpChkRegistry(0, 0, PHBaseBlock->RootCell,HCELL_NIL,&TotalUsage);

        if(LostSpace) {
            // clear the dirt on the screen
            fprintf(OutputFile,"\r                          \n");
        }

        DumpUnknownList();
        FreeUnknownList();

        fprintf(OutputFile,"\nSUMMARY: \n");
        fprintf(OutputFile,"%15s,%15s,     %s\n", 
                    "Cells",
                    "Size",
                    "Category");

        fprintf(OutputFile,"%15lu,%15lu,     Keys\n", 
                CountKeyNode,
                TotalKeyNode
                );
        fprintf(OutputFile,"%15lu,%15lu,     Values\n", 
                CountKeyValue,
                TotalKeyValue
                );
        fprintf(OutputFile,"%15lu,%15lu,     Key Index\n", 
                CountKeyIndex,
                TotalKeyIndex
                );
        fprintf(OutputFile,"%15lu,%15lu,     Value Index\n", 
                CountValueIndex,
                TotalValueIndex
                );
        fprintf(OutputFile,"%15lu,%15lu,     Security\n", 
                CountKeySecurity,
                TotalKeySecurity
                );
        fprintf(OutputFile,"%15lu,%15lu,     Data\n", 
                CountUnknown - CountValueIndex,
                TotalUnknown - TotalValueIndex
                );

        fprintf(OutputFile,"%15lu,%15lu,     Free\n", 
                FreeCount,
                TotalFree
                );

        CellCount = CountKeyNode + 
                    CountKeyValue + 
                    CountKeyIndex + 
                    CountKeySecurity + 
                    CountUnknown +
                    FreeCount;

        SizeCount = TotalKeyNode +
                    TotalKeyValue +
                    TotalKeyIndex +
                    TotalKeySecurity +
                    TotalUnknown +
                    TotalFree;

        fprintf(OutputFile,"%15lu,%15lu,     %s\n", 
                CellCount,
                SizeCount,
                "Total Hive");

        {
            double RateTotal = CountKeyNodeCompacted;
            RateTotal *= 100.00;
            RateTotal /= (double)CountKeyNode;
            fprintf(OutputFile,"\n%15lu (%.2f%%) compacted  keys (all related cells in the same view)\n",CountKeyNodeCompacted,(float)RateTotal);
        }
            
    }
        
    UnmapViewOfFile(myMMFViewHandle);
    CloseHandle(myMMFHandle);
    CloseHandle(myFileHandle);

    if(CompactHive) {
        DoCompactHive();
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\cmkd\parseini.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    parseini.c
Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\cmkd\init386.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    initi386.c

Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\cmkd\initdat.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\cmkd\rules.c ===
/*++

Copyright (c) 2000  Microsoft Corporation


Module Name:

    rules.c
Abstract:

    The sole purpose of this empty file is to fool build and allow cmkd 
    debugger extension to exist at the cm level
    
Author:

    Dragos Sambotin (dragoss) 06-March-2000

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\i386\geninst.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.


Module Name:

    geninst.c

Abstract:

    This modules contains routines to implement GenInstall of an inf section.
    This is based on the code from the setupapi. Currently, it only supports
    a subset of GenInstall functionality i.e AddReg and DelReg and BitReg.

Author:

    Santosh Jodh (santoshj) 08-Aug-1998


Environment:

    Kernel mode.

Revision History:

--*/


#include "cmp.h"
#include "stdlib.h"
#include "parseini.h"
#include "geninst.h"

typedef
BOOLEAN
(* PFN_INFRULE)(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN PVOID RefData
    );

typedef
BOOLEAN
(* PFN_REGLINE)(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    );

BOOLEAN
CmpProcessReg(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN PVOID RefData
    );

NTSTATUS
CmpProcessAddRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    );

NTSTATUS
CmpProcessDelRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    );

NTSTATUS
CmpProcessBitRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    );

NTSTATUS
CmpGetAddRegInfData(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN ULONG ValueType,
    OUT PVOID *Data,
    OUT PULONG DataSize
    );

NTSTATUS
CmpOpenRegKey(
    IN OUT PHANDLE Key,
    IN OUT PULONG Disposition,
    IN PCHAR Root,
    IN PCHAR SubKey,
    IN ULONG DesiredAccess,
    IN BOOLEAN Create
    );

NTSTATUS
CmpAppendStringToMultiSz(
    IN HANDLE Key,
    IN PCHAR ValueName,
    IN OUT PVOID *Data,
    IN OUT PULONG DataSize
    );

//
// Copied from setupapi.h
//
// Flags for AddReg section lines in INF.  The corresponding value
// is <ValueType> in the AddReg line format given below:
//
// <RegRootString>,<SubKey>,<ValueName>,<ValueType>,<Value>...
//
// The low word contains basic flags concerning the general data type
// and AddReg action. The high word contains values that more specifically
// identify the data type of the registry value.  The high word is ignored
// by the 16-bit Windows 95 SETUPX APIs.
//

#define FLG_ADDREG_BINVALUETYPE     ( 0x00000001 )
#define FLG_ADDREG_NOCLOBBER        ( 0x00000002 )
#define FLG_ADDREG_DELVAL           ( 0x00000004 )
#define FLG_ADDREG_APPEND           ( 0x00000008 ) // Currently supported only
                                                   // for REG_MULTI_SZ values.
#define FLG_ADDREG_KEYONLY          ( 0x00000010 ) // Just create the key, ignore value
#define FLG_ADDREG_OVERWRITEONLY    ( 0x00000020 ) // Set only if value already exists

#define FLG_ADDREG_TYPE_MASK        ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_SZ          ( 0x00000000                           )
#define FLG_ADDREG_TYPE_MULTI_SZ    ( 0x00010000                           )
#define FLG_ADDREG_TYPE_EXPAND_SZ   ( 0x00020000                           )
#define FLG_ADDREG_TYPE_BINARY      ( 0x00000000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_DWORD       ( 0x00010000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_NONE        ( 0x00020000 | FLG_ADDREG_BINVALUETYPE )

#define FLG_BITREG_CLEAR            ( 0x00000000 )
#define FLG_BITREG_SET              ( 0x00000001 )
#define FLG_BITREG_TYPE_BINARY      ( 0x00000000 )
#define FLG_BITREG_TYPE_DWORD       ( 0x00000002 )

//
// We currently only support AddReg and DelReg sections.
//

#define NUM_OF_INF_RULES    3

//
// GenInstall methods we support.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
struct {
    PCHAR       Name;
    PFN_INFRULE Action;
    PVOID       RefData;
} const gInfRuleTable[NUM_OF_INF_RULES] =
{
    {"AddReg", CmpProcessReg, (PVOID)(ULONG_PTR) CmpProcessAddRegLine},
    {"DelReg", CmpProcessReg, (PVOID)(ULONG_PTR) CmpProcessDelRegLine},
    {"BitReg", CmpProcessReg, (PVOID)(ULONG_PTR) CmpProcessBitRegLine}
};
static const UNICODE_STRING NullString = {0, 1, L""};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpAppendStringToMultiSz)
#pragma alloc_text(INIT,CmpOpenRegKey)
#pragma alloc_text(INIT,CmpGetAddRegInfData)
#pragma alloc_text(INIT,CmpProcessReg)
#pragma alloc_text(INIT,CmpProcessAddRegLine)
#pragma alloc_text(INIT,CmpProcessDelRegLine)
#pragma alloc_text(INIT,CmpProcessBitRegLine)
#pragma alloc_text(INIT,CmpGenInstall)
#endif

BOOLEAN
CmpGenInstall(
    IN PVOID InfHandle,
    IN PCHAR Section
    )

/*++

    Routine Description:

        This routine does a GenInstall of the section in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

    Return Value:

        TRUE iff the entire section was processed successfully.

--*/

{
    ULONG   ruleNumber;
    ULONG   i;
    PCHAR   ruleName;
    PCHAR   regSection;
    BOOLEAN result = FALSE;

    if (CmpSearchInfSection(InfHandle, Section))
    {
        //
        // Go through all the rules in the section and try to process
        // each of them.
        //

        for (   ruleNumber = 0;
                ruleName = CmpGetKeyName(InfHandle, Section, ruleNumber);
                ruleNumber++)
        {

            //
            // Search for the proceesing function in our table.
            //

            for (   i = 0;
                    i < NUM_OF_INF_RULES &&
                        _stricmp(ruleName, gInfRuleTable[i].Name);
                    i++);

            if (    i >= NUM_OF_INF_RULES ||
                    (regSection = CmpGetSectionLineIndex(   InfHandle,
                                                            Section,
                                                            ruleNumber,
                                                            0)) == NULL ||
                    !CmpSearchInfSection(InfHandle, Section))
            {
                result = FALSE;
                break;
            }

            if (!(*gInfRuleTable[i].Action)(InfHandle, regSection, gInfRuleTable[i].RefData))
            {
                result = FALSE;
            }
        }

        //
        // All inf rules processed.
        //

        if (ruleNumber)
        {
            result = TRUE;
        }
    }

    return (result);
}

BOOLEAN
CmpProcessReg(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN PVOID RefData
    )

/*++

    Routine Description:

        This routine processes a AddReg section in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

    Return Value:

        TRUE iff the entire section was processed successfully.

--*/

{
    ULONG       lineIndex;
    NTSTATUS    status = STATUS_SUCCESS;
    NTSTATUS    temp;

    //
    // Process all the lines in the xxxReg Section.
    //

    for (   lineIndex = 0;
            CmpSearchInfLine(InfHandle, Section, lineIndex);
            lineIndex++)
    {
        temp = (*(PFN_REGLINE)(ULONG_PTR)RefData)(InfHandle, Section, lineIndex);
        if (!NT_SUCCESS(temp))
        {
            status = temp;
        }
    }

    if (NT_SUCCESS(status))
    {
        return (TRUE);
    }

    return (FALSE);
}

NTSTATUS
CmpProcessAddRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine processes a AddReg line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PCHAR               rootKeyName;
    PCHAR               subKeyName;
    PCHAR               valueName;
    ULONG               flags;
    ULONG               valueType;
    HANDLE              key;
    ULONG               disposition;
    BOOLEAN             dontSet;
    PVOID               data = 0;
    ULONG               dataSize = 0;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;

    //
    // Get the root-key name.
    //

    rootKeyName = CmpGetSectionLineIndex(   InfHandle,
                                            Section,
                                            LineIndex,
                                            0);
    if (rootKeyName)
    {
        //
        // Get the optional sub-key name.
        //

        subKeyName = CmpGetSectionLineIndex(    InfHandle,
                                                Section,
                                                LineIndex,
                                                1);

        //
        // Value name is optional. Can be NULL or "".
        //

        valueName = CmpGetSectionLineIndex( InfHandle,
                                            Section,
                                            LineIndex,
                                            2);
        //
        // If we don't have a value name, the type is REG_SZ to force
        // the right behavior in RegSetValueEx. Otherwise get the data type.
        //

        valueType = REG_SZ;

        //
        // Read in the flags.
        //

        if (!CmpGetIntField(    InfHandle,
                                Section,
                                LineIndex,
                                3,
                                &flags))
        {
            flags = 0;
        }

        //
        // Convert the flags to the registry type.
        //

        switch(flags & FLG_ADDREG_TYPE_MASK)
        {

            case FLG_ADDREG_TYPE_SZ:

                valueType = REG_SZ;
                break;

            case FLG_ADDREG_TYPE_MULTI_SZ:

                valueType = REG_MULTI_SZ;
                break;

            case FLG_ADDREG_TYPE_EXPAND_SZ:

                valueType = REG_EXPAND_SZ;
                break;

            case FLG_ADDREG_TYPE_BINARY:

                valueType = REG_BINARY;
                break;

            case FLG_ADDREG_TYPE_DWORD:

                valueType = REG_DWORD;
                break;

            case FLG_ADDREG_TYPE_NONE:

                valueType = REG_NONE;
                break;

            default :

                //
                // If the FLG_ADDREG_BINVALUETYPE is set, then the highword
                // can contain just about any random reg data type ordinal value.
                //

                if(flags & FLG_ADDREG_BINVALUETYPE)
                {
                    //
                    // Disallow the following reg data types:
                    //
                    //    REG_NONE, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ
                    //

                    valueType = HIGHWORD(flags);

                    if(valueType < REG_BINARY || valueType == REG_MULTI_SZ)
                    {
                        return (STATUS_INVALID_PARAMETER);
                    }

                }
                else
                {
                    return (STATUS_INVALID_PARAMETER);
                }
                break;
        }

        //
        // Presently, the append behavior flag is only supported for
        // REG_MULTI_SZ values.
        //

        if((flags & FLG_ADDREG_APPEND) && valueType != REG_MULTI_SZ)
        {
            return (STATUS_INVALID_PARAMETER);
        }

        //
        // W9x compatibility.
        //

        if( (!valueName || *valueName == '\0') && valueType == REG_EXPAND_SZ)
        {
            valueType = REG_SZ;
        }

        //
        // Open the specified key if possible.
        //

        status = CmpOpenRegKey( &key,
                                &disposition,
                                rootKeyName,
                                subKeyName,
                                KEY_ALL_ACCESS,
                                (BOOLEAN)!(flags & FLG_ADDREG_OVERWRITEONLY));

        if (NT_SUCCESS(status))
        {
            //
            // Respect the key only flag.
            //
            if (!(flags & FLG_ADDREG_KEYONLY)) 
            {
                status = CmpGetAddRegInfData(   InfHandle,
                                                Section,
                                                LineIndex,
                                                4,
                                                valueType,
                                                &data,
                                                &dataSize);
                if (NT_SUCCESS(status))
                {
                    //
                    // This variable gets set to TRUE if we dont actually want to set
                    // the value.
                    //

                    dontSet = FALSE;
                    if (flags & FLG_ADDREG_APPEND)
                    {
                        status = CmpAppendStringToMultiSz(  key,
                                                            valueName,
                                                            &data,
                                                            &dataSize);
                    }
                    if (NT_SUCCESS(status))
                    {
                        //
                        // W9x compatibility.
                        //

                        if (disposition == REG_OPENED_EXISTING_KEY)
                        {
                            if (    (flags & FLG_ADDREG_NOCLOBBER) &&
                                    (valueName == NULL || *valueName == '\0'))
                            {
                                status = NtQueryValueKey(   key,
                                                            (PUNICODE_STRING)&NullString,
                                                            KeyValueBasicInformation,
                                                            NULL,
                                                            0,
                                                            &disposition);
                                if (NT_SUCCESS(status) || status == STATUS_BUFFER_TOO_SMALL)
                                {
                                    flags &= ~FLG_ADDREG_NOCLOBBER;
                                }
                                status = STATUS_SUCCESS;
                            }

                            if (flags & FLG_ADDREG_DELVAL)
                            {
                                //
                                // setupx compatibility.
                                //

                                dontSet = TRUE;
                                if (valueName)
                                {
                                    //
                                    // Delete the specified value.
                                    //

                                    RtlInitAnsiString(&ansiString, valueName);
                                    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
                                    if (NT_SUCCESS(status))
                                    {
                                        status = NtDeleteValueKey(key, &unicodeString);
                                        RtlFreeUnicodeString(&unicodeString);
                                    }
                                }
                            }
                        }
                        else
                        {
                            flags &= ~FLG_ADDREG_NOCLOBBER;
                        }

                        if (!dontSet)
                        {
                            //
                            // If no clobber flag is set, make sure that the value does not
                            // already exist.
                            //

                            RtlInitAnsiString(&ansiString, valueName);
                            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
                            if (NT_SUCCESS(status))
                            {
                                NTSTATUS    existStatus;

                                if (flags & FLG_ADDREG_NOCLOBBER)
                                {
                                    existStatus = NtQueryValueKey(  key,
                                                                    &unicodeString,
                                                                    KeyValueBasicInformation,
                                                                    NULL,
                                                                    0,
                                                                    &disposition);
                                    if (NT_SUCCESS(existStatus) || existStatus == STATUS_BUFFER_TOO_SMALL) {
                                        dontSet = TRUE;
                                    }
                                }
                                else
                                {
                                    if (flags & FLG_ADDREG_OVERWRITEONLY)
                                    {
                                        existStatus = NtQueryValueKey(  key,
                                                                        &unicodeString,
                                                                        KeyValueBasicInformation,
                                                                        NULL,
                                                                        0,
                                                                        &disposition);
                                        if (!NT_SUCCESS(existStatus) && existStatus != STATUS_BUFFER_TOO_SMALL) {
                                            dontSet = TRUE;
                                        }
                                    }
                                }

                                if (!dontSet)
                                {
                                    status = NtSetValueKey( key,
                                                            &unicodeString,
                                                            0,
                                                            valueType,
                                                            data,
                                                            dataSize);
                                }

                                RtlFreeUnicodeString(&unicodeString);
                            }
                        }
                    }
                }
            }
            NtClose(key);
        }
        else if (flags & FLG_ADDREG_OVERWRITEONLY)
        {
            status = STATUS_SUCCESS;
        }
    }

    return (status);
}

NTSTATUS
CmpProcessDelRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine processes a DelReg line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PCHAR               rootKeyName;
    PCHAR               subKeyName;
    PCHAR               valueName;
    HANDLE              key;
    ULONG               disposition;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;

    //
    // Read the required fields.
    //

    rootKeyName = CmpGetSectionLineIndex(   InfHandle,
                                            Section,
                                            LineIndex,
                                            0);

    subKeyName = CmpGetSectionLineIndex(    InfHandle,
                                            Section,
                                            LineIndex,
                                            1);

    if (rootKeyName && subKeyName)
    {
        //
        // Read the optional field.
        //

        valueName = CmpGetSectionLineIndex( InfHandle,
                                            Section,
                                            LineIndex,
                                            2);

        //
        // Open the specified registry key.
        //

        status = CmpOpenRegKey( &key,
                                &disposition,
                                rootKeyName,
                                subKeyName,
                                KEY_ALL_ACCESS,
                                FALSE);

        //
        // Proceed if we successfully opened the registry key.
        //

        if (NT_SUCCESS(status))
        {

            //
            // If the key was successfully opened, do the DelReg.
            //

            if (valueName)
            {
                //
                // Delete the specified value.
                //

                RtlInitAnsiString(&ansiString, valueName);
                status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
                if (NT_SUCCESS(status))
                {
                    status = NtDeleteValueKey(key, &unicodeString);
                    RtlFreeUnicodeString(&unicodeString);
                }
            }
            else
            {
                //
                // No value specified. The subkey needs to be deleted.
                //

                status = NtDeleteKey(key);
            }

            //
            // Close the key handle.
            //

            NtClose(key);
        }
    }

    return (status);
}

NTSTATUS
CmpProcessBitRegLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine processes a BitReg line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS                    status = STATUS_UNSUCCESSFUL;
    PCHAR                       rootKeyName;
    PCHAR                       subKeyName;
    PCHAR                       valueName;
    ULONG                       flags;
    ULONG                       mask;
    ULONG                       field = 0;
    HANDLE                      key;
    ULONG                       disposition;
    ANSI_STRING                 ansiString;
    UNICODE_STRING              unicodeString;
    PCHAR                       buffer;
    ULONG                       size;
    PKEY_VALUE_FULL_INFORMATION valueInfo;

    //
    // Get the root-key name.
    //

    rootKeyName = CmpGetSectionLineIndex(   InfHandle,
                                            Section,
                                            LineIndex,
                                            0);
    if (rootKeyName)
    {
        //
        // Get the optional sub-key name.
        //

        subKeyName = CmpGetSectionLineIndex(    InfHandle,
                                                Section,
                                                LineIndex,
                                                1);

        //
        // Value name is optional. Can be NULL or "".
        //

        valueName = CmpGetSectionLineIndex( InfHandle,
                                            Section,
                                            LineIndex,
                                            2);
        if (valueName && *valueName)
        {
            //
            // Read in the flags.
            //

            if (!CmpGetIntField(    InfHandle,
                                    Section,
                                    LineIndex,
                                    3,
                                    &flags))
            {
                flags = 0;
            }

            if (!CmpGetIntField(    InfHandle,
                                    Section,
                                    LineIndex,
                                    4,
                                    &mask))
            {
                mask = 0;
            }

            if (!(flags & FLG_BITREG_TYPE_DWORD))
            {
                if (!CmpGetIntField(    InfHandle,
                                        Section,
                                        LineIndex,
                                        5,
                                        &field))
                {
                    return (status);
                }
            }

            //
            // Open the specified registry key.
            //

            status = CmpOpenRegKey( &key,
                                    &disposition,
                                    rootKeyName,
                                    subKeyName,
                                    KEY_QUERY_VALUE | KEY_SET_VALUE,
                                    FALSE);
            if (NT_SUCCESS(status))
            {
                //
                // Read the existing data.
                //

                RtlInitAnsiString(&ansiString, valueName);
                status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
                if (NT_SUCCESS(status))
                {
                    size = 0;
                    status = NtQueryValueKey(   key,
                                                &unicodeString,
                                                KeyValueFullInformation,
                                                NULL,
                                                0,
                                                &size);
                    if (size)
                    {
                        status = STATUS_NO_MEMORY;
                        buffer = ExAllocatePoolWithTag(PagedPool, size, CM_GENINST_TAG);
                        if (buffer)
                        {
                            status = NtQueryValueKey(   key,
                                                        &unicodeString,
                                                        KeyValueFullInformation,
                                                        buffer,
                                                        size,
                                                        &size);
                            if (NT_SUCCESS(status))
                            {
                                valueInfo = (PKEY_VALUE_FULL_INFORMATION)buffer;
                                if (flags & FLG_BITREG_TYPE_DWORD)
                                {
                                    if (valueInfo->Type == REG_DWORD && valueInfo->DataLength == sizeof(ULONG))
                                    {
                                        if (flags & FLG_BITREG_SET)
                                        {
                                            *(PULONG)(buffer + valueInfo->DataOffset) |= mask;
                                        }
                                        else
                                        {
                                            *(PULONG)(buffer + valueInfo->DataOffset) &= ~mask;
                                        }
                                    }
                                }
                                else
                                {
                                    if (valueInfo->Type == REG_BINARY && field < valueInfo->DataLength)
                                    {
                                        if (flags & FLG_BITREG_SET)
                                        {
                                            *(PUCHAR)(buffer + valueInfo->DataOffset + field) |= mask;
                                        }
                                        else
                                        {
                                            *(PUCHAR)(buffer + valueInfo->DataOffset + field) &= ~mask;
                                        }
                                    }
                                }
                                status = NtSetValueKey( key,
                                                        &unicodeString,
                                                        0,
                                                        valueInfo->Type,
                                                        buffer + valueInfo->DataOffset,
                                                        valueInfo->DataLength);
                            }
                            else
                            {
#ifndef _CM_LDR_
                                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Value cannot be read for BitReg in %s line %d\n", Section, LineIndex);
#endif //_CM_LDR_
                                ASSERT(NT_SUCCESS(status));
                            }
                            ExFreePool(buffer);
                        }
                        else
                        {
                            ASSERT(buffer);
                            status = STATUS_NO_MEMORY;
                        }
                    }

                    RtlFreeUnicodeString(&unicodeString);
                }
                //
                // Close the key handle.
                //

                NtClose(key);
            }
        }
    }

    return (status);
}

NTSTATUS
CmpGetAddRegInfData(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN ULONG ValueType,
    OUT PVOID *Data,
    OUT PULONG DataSize
    )

/*++

    Routine Description:

        This routine reads AddReg data from the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

        ValueIndex - Index of the value to be read.

        ValueType - Data type to be read.

        Data - Receives pointer to the buffer in which data has been read.

        DataSize - Receives the size of the data buffer.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PCHAR           str;
    ULONG           count;
    ULONG           i;
    ANSI_STRING     ansiString;
    UNICODE_STRING  unicodeString;

    //
    // Validate the required fields.
    //

    ASSERT(Data);
    ASSERT(DataSize);

    switch (ValueType)
    {
        case REG_DWORD:

            *DataSize = sizeof(ULONG);
            *Data = ExAllocatePoolWithTag(PagedPool, *DataSize, CM_GENINST_TAG);
            if (*Data)
            {
                //
                // DWORD data is specified as four bytes in W9x.
                //

                if (CmpGetSectionLineIndexValueCount(   InfHandle,
                                                        Section,
                                                        LineIndex) == 8)
                {
                    if (!CmpGetBinaryField( InfHandle,
                                            Section,
                                            LineIndex,
                                            ValueIndex,
                                            *Data,
                                            *DataSize,
                                            NULL))
                    {
                        *((PULONG)*Data) = 0;
                    }

                    status = STATUS_SUCCESS;
                }
                else
                {
                    //
                    // Get the DWORD value.
                    //

                    if (!CmpGetIntField(    InfHandle,
                                            Section,
                                            LineIndex,
                                            4,
                                            *Data))
                    {
                        *((PULONG)*Data) = 0;
                    }

                    status = STATUS_SUCCESS;
                }
            }
            else
            {
                ASSERT(*Data);
                status = STATUS_NO_MEMORY;
            }

            break;

        case REG_SZ:
        case REG_EXPAND_SZ:

            //
            // Null terminated string. Gets converted to unicode before being
            // added into the registry.
            //

            str = CmpGetSectionLineIndex(   InfHandle,
                                            Section,
                                            LineIndex,
                                            ValueIndex);
            if (str)
            {
                RtlInitAnsiString(&ansiString, str);
                *DataSize = (ansiString.Length << 1) + sizeof(UNICODE_NULL);
                unicodeString.MaximumLength = (USHORT)*DataSize;
                unicodeString.Buffer = ExAllocatePoolWithTag(PagedPool, *DataSize, CM_GENINST_TAG);
                *Data = NULL;
                if (unicodeString.Buffer)
                {
                    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
                    if (NT_SUCCESS(status))
                    {
                        *Data = unicodeString.Buffer;
                        status = STATUS_SUCCESS;
                    }
                }
                else
                {
                    ASSERT(unicodeString.Buffer);
                    status = STATUS_NO_MEMORY;
                }
            }
            else
            {
                ASSERT(str);
                status = STATUS_NO_MEMORY;
            }

            break;

        case REG_MULTI_SZ:

            *DataSize = 0;
            *Data = NULL;

            //
            // Loop to determine the total memory that needs to be allocated.
            //

            count = CmpGetSectionLineIndexValueCount(   InfHandle,
                                                        Section,
                                                        LineIndex);
            if (count > ValueIndex)
            {
                count -= ValueIndex;
                for (i = 0; i < count; i++)
                {
                    str = CmpGetSectionLineIndex(   InfHandle,
                                                    Section,
                                                    LineIndex,
                                                    ValueIndex + i);
                    if (str == NULL)
                    {
                        break;
                    }

                    *DataSize += (ULONG)((strlen(str) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));
                }

                if (i == count)
                {
                    //
                    // Account for the terminating NULL.
                    //

                    *DataSize += sizeof(UNICODE_NULL);
                    *Data = ExAllocatePoolWithTag(PagedPool, *DataSize, CM_GENINST_TAG);
                    if (*Data)
                    {
                        for (   i = 0, unicodeString.Buffer = *Data;
                                i < count;
                                i++, unicodeString.Buffer = (PWCHAR)((PCHAR)unicodeString.Buffer + unicodeString.MaximumLength))
                        {
                            str = CmpGetSectionLineIndex(   InfHandle,
                                                            Section,
                                                            LineIndex,
                                                            ValueIndex + i);
                            if (str == NULL)
                            {
                                break;
                            }
                            RtlInitAnsiString(&ansiString, str);
                            unicodeString.MaximumLength = (ansiString.Length * sizeof(WCHAR)) + sizeof(UNICODE_NULL);
                            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);
                            if (!NT_SUCCESS(status))
                            {
                                break;
                            }
                        }

                        //
                        // Terminate the multi-sz string.
                        //

                        if (i == count)
                        {
                            unicodeString.Buffer[0] = UNICODE_NULL;
                            status = STATUS_SUCCESS;
                        }
                    }
                    else
                    {
                        ASSERT(*Data);
                        status = STATUS_NO_MEMORY;
                    }
                }
            }

            break;

        case REG_BINARY:
        default:

            //
            // Free form binary data.
            //

            if (CmpGetBinaryField(  InfHandle,
                                    Section,
                                    LineIndex,
                                    ValueIndex,
                                    NULL,
                                    0,
                                    DataSize) && *DataSize)
            {
                *Data = ExAllocatePoolWithTag(PagedPool, *DataSize, CM_GENINST_TAG);
                if (*Data)
                {
                    if (CmpGetBinaryField( InfHandle,
                                            Section,
                                            LineIndex,
                                            4,
                                            *Data,
                                            *DataSize,
                                            NULL))
                    {
                        status = STATUS_SUCCESS;
                    }
                }
                else
                {
                    ASSERT(*Data);
                    status = STATUS_NO_MEMORY;
                }
            }
            else
            {
                status = STATUS_UNSUCCESSFUL;
            }

            break;
    }

    return (status);
}

NTSTATUS
CmpOpenRegKey(
    IN OUT PHANDLE Key,
    IN OUT PULONG Disposition,
    IN PCHAR Root,
    IN PCHAR SubKey,
    IN ULONG DesiredAccess,
    IN BOOLEAN Create
    )

/*++

    Routine Description:

        This routine opens\creates a handle to the registry key.

    Input Parameters:

        Key - Receives the handle to the key.

        Disposition - Receives the disposition of the key.

        Root - Abbreviated name of the root key.

        SubKey - Name of the subkey under the root.

        DesiredAccess - Desired access flags for the key.

        Create - TRUE if the key needs to be created instead of opened.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS            status = STATUS_OBJECT_NAME_INVALID;
    SIZE_T              size;
    PCHAR               str;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   objectAttributes;

    str = NULL;
    size = strlen(SubKey) + 1;

    //
    // Check if we understand the specified root name.
    //

    if (_stricmp(Root, "HKLM") == 0)
    {
        size += (sizeof("\\Registry\\Machine\\") - 1); // Already added one above for NULL
        str = ExAllocatePoolWithTag(PagedPool, size, CM_GENINST_TAG);
        if (str)
        {
            _snprintf(str, size, "\\Registry\\Machine\\%s", SubKey);
            str[size - 1] = 0;
        }
        else
        {
            ASSERT(str);
            status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        ASSERT(_stricmp(Root, "HKLM") == 0);
    }

    //
    // Proceed if we have a valid key name.
    //

    if (str)
    {
        RtlInitAnsiString(&ansiString, str);
        status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
        if (NT_SUCCESS(status))
        {
            InitializeObjectAttributes( &objectAttributes,
                                        &unicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL);
            if (Create)
            {
                //
                // Create a new key or open an existing one.
                //

                status = NtCreateKey(   Key,
                                        DesiredAccess,
                                        &objectAttributes,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        Disposition ? Disposition : (PULONG)&size);
            }
            else
            {
                //
                // Open existing key.
                //

                if (Disposition)
                {
                    *Disposition = REG_OPENED_EXISTING_KEY;
                }
                status = NtOpenKey( Key,
                                    DesiredAccess,
                                    &objectAttributes);
            }

            RtlFreeUnicodeString(&unicodeString);
        }
        else
        {
            ASSERT(NT_SUCCESS(status));
        }

        ExFreePool(str);
    }

    return (status);
}

NTSTATUS
CmpAppendStringToMultiSz(
    IN HANDLE Key,
    IN PCHAR ValueName,
    IN OUT PVOID *Data,
    IN OUT PULONG DataSize
    )

/*++

    Routine Description:

        This routine opens\creates a handle to the registry key.

    Input Parameters:

        Key - Receives the handle to the key.

        ValueName - Name of the value to be appended to.

        Data - Buffer containing the multi-sz to be appended.

        DataSize - Size of the data.

    Return Value:

        Standard NT status value.

--*/

{
    NTSTATUS                    status;
    ULONG                       size;
    ANSI_STRING                 ansiString;
    UNICODE_STRING              unicodeString;
    PKEY_VALUE_FULL_INFORMATION valueInfo;
    PVOID                       buffer;
    PVOID                       str;

    ASSERT(DataSize && *DataSize);
    ASSERT(*Data);

    RtlInitAnsiString(&ansiString, ValueName);
    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
    if (NT_SUCCESS(status))
    {
        size = 0;
        status = NtQueryValueKey(   Key,
                                    &unicodeString,
                                    KeyValueFullInformation,
                                    NULL,
                                    0,
                                    &size);
        if (size)
        {
            buffer = ExAllocatePoolWithTag(PagedPool, size, CM_GENINST_TAG);
            if (buffer)
            {
                status = NtQueryValueKey(   Key,
                                            &unicodeString,
                                            KeyValueFullInformation,
                                            buffer,
                                            size,
                                            &size);
                if (NT_SUCCESS(status))
                {
                    valueInfo = (PKEY_VALUE_FULL_INFORMATION)buffer;
                    str = ExAllocatePoolWithTag(    PagedPool,
                                                    valueInfo->DataLength +
                                                        *DataSize - sizeof(UNICODE_NULL),
                                                    CM_GENINST_TAG);
                    if (str)
                    {
                        memcpy( str,
                                (PCHAR)buffer + valueInfo->DataOffset,
                                valueInfo->DataLength);
                        memcpy( (PCHAR)str + valueInfo->DataLength - sizeof(UNICODE_NULL),
                                *Data,
                                *DataSize);
                        ExFreePool(*Data);
                        *Data = str;
                        *DataSize += valueInfo->DataLength - sizeof(UNICODE_NULL);
                    }
                    else
                    {
#ifndef _CM_LDR_
                        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpAppendStringToMultiSz: Failed to allocate memory!\n");
#endif //_CM_LDR_
                        ASSERT(str);
                        status = STATUS_NO_MEMORY;
                    }
                }
                ExFreePool(buffer);
            }
            else
            {
#ifndef _CM_LDR_
                DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpAppendStringToMultiSz: Failed to allocate memory!\n");
#endif //_CM_LDR_
                ASSERT(buffer);
                status = STATUS_NO_MEMORY;
            }
        }
        RtlFreeUnicodeString(&unicodeString);
    }

    return (status);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\i386\rules.h ===
/*++                    

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    rules.h

Abstract:

    This module contains support routines for implementing BIOS 
    identification rules.
    
Environment:

    Kernel mode

--*/

//
// Maximum data that can be specified (either as string or binary) in the 
// machine identification rules.
//

#define MAX_DESCRIPTION_LEN 256

BOOLEAN
CmpMatchInfList(
    IN PVOID InfImage,
    IN ULONG ImageSize,
    IN PCHAR Section
    );

PDESCRIPTION_HEADER
CmpFindACPITable(
    IN ULONG        Signature,
    IN OUT PULONG   Length
    );

NTSTATUS
CmpGetRegistryValue(
    IN  HANDLE                          KeyName,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION  *Information
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\i386\init386.c ===
//depot/Lab01_N/base/ntos/config/i386/init386.c#4 - edit change 6794 (text)
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    init386.c

Abstract:

    This module is responsible to build any x86 specific entries in
    the hardware tree of registry.

Author:

    Ken Reneris (kenr) 04-Aug-1992


Environment:

    Kernel mode.

Revision History:

    shielint - add BIOS date and version detection.

--*/

#include "cmp.h"
#include "stdio.h"
#include "acpitabl.h"
#include "ntacpi.h"
#include "rules.h"

#ifdef _WANT_MACHINE_IDENTIFICATION
#include "string.h"
#include "stdlib.h"
#include "ntverp.h"
#endif


typedef struct _ACPI_BIOS_INFORMATION {
    ULONG BootArchitecture;
    ULONG PreferredProfile;
    ULONG Capabilities;
} ACPI_BIOS_INFORMATION, *PACPI_BIOS_INFORMATION;
//
// Title Index is set to 0.
// (from ..\cmconfig.c)
//

#define TITLE_INDEX_VALUE 0

extern const PCHAR SearchStrings[];
extern PCHAR BiosBegin;
extern PCHAR Start;
extern PCHAR End;
#if defined(_X86_)
extern const UCHAR CmpID1[];
#endif
extern const UCHAR CmpID2[];
extern const WCHAR CmpVendorID[];
extern const WCHAR CmpProcessorNameString[];
extern const WCHAR CmpFeatureBits[];
extern const WCHAR CmpMHz[];
extern const WCHAR CmpUpdateSignature[];
extern const WCHAR CmPhysicalAddressExtension[];

#if !defined(_AMD64_)
extern const UCHAR CmpCyrixID[];
#endif

extern const UCHAR CmpIntelID[];
extern const UCHAR CmpAmdID[];

//
// Bios date and version definitions
//

#define BIOS_DATE_LENGTH 11
#define MAXIMUM_BIOS_VERSION_LENGTH 128
#define SYSTEM_BIOS_START 0xF0000
#define SYSTEM_BIOS_LENGTH 0x10000
#define INT10_VECTOR 0x10
#define VIDEO_BIOS_START 0xC0000
#define VIDEO_BIOS_LENGTH 0x8000
#define VERSION_DATA_LENGTH PAGE_SIZE

//
// Extended CPUID function definitions
//

#define CPUID_PROCESSOR_NAME_STRING_SZ  49
#define CPUID_EXTFN_BASE                0x80000000
#define CPUID_EXTFN_PROCESSOR_NAME      0x80000002

//
// CPU Stepping mismatch.
//

UCHAR CmProcessorMismatch;

#define CM_PROCESSOR_MISMATCH_VENDOR    0x01
#define CM_PROCESSOR_MISMATCH_STEPPING  0x02
#define CM_PROCESSOR_MISMATCH_L2        0x04


extern ULONG CmpConfigurationAreaSize;
extern PCM_FULL_RESOURCE_DESCRIPTOR CmpConfigurationData;


BOOLEAN
CmpGetBiosVersion (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR VersionString
    );

BOOLEAN
CmpGetAcpiBiosVersion(
    PCHAR VersionString
    );

BOOLEAN
CmpGetBiosDate (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR DateString,
    BOOLEAN SystemBiosDate
    );

BOOLEAN
CmpGetAcpiBiosInformation(
    PACPI_BIOS_INFORMATION AcpiBiosInformation
    );

ULONG
Ke386CyrixId (
    VOID
    );

#ifdef _WANT_MACHINE_IDENTIFICATION

VOID
CmpPerformMachineIdentification(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpGetBiosDate)
#pragma alloc_text(INIT,CmpGetBiosVersion)
#pragma alloc_text(INIT,CmpGetAcpiBiosVersion)
#pragma alloc_text(INIT,CmpGetAcpiBiosInformation)
#pragma alloc_text(INIT,CmpInitializeMachineDependentConfiguration)

#ifdef _WANT_MACHINE_IDENTIFICATION
#pragma alloc_text(INIT,CmpPerformMachineIdentification)
#endif

#endif

#if defined(_AMD64_)

#define KeI386NpxPresent TRUE

VOID
__inline
CPUID (
    ULONG InEax,
    PULONG OutEax,
    PULONG OutEbx,
    PULONG OutEcx,
    PULONG OutEdx
    )
{
    CPU_INFO cpuInfo;

    KiCpuId (InEax, &cpuInfo);

    *OutEax = cpuInfo.Eax;
    *OutEbx = cpuInfo.Ebx;
    *OutEcx = cpuInfo.Ecx;
    *OutEdx = cpuInfo.Edx;
}

#endif


BOOLEAN
CmpGetBiosDate (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR DateString,
    BOOLEAN SystemBiosDate
    )

/*++

Routine Description:

    This routine finds the most recent date in the computer/video
    card's ROM.  When GetRomDate encounters a datae, it checks the
    previously found date to see if the new date is more recent.

Arguments:

    SearchArea - the area to search for a date.

    SearchLength - Length of search.

    DateString - Supplies a pointer to a fixed length memory to receive
                 the date string.

Return Value:

    NT_SUCCESS if a date is found.

--*/

{
    CHAR    prevDate[BIOS_DATE_LENGTH]; // Newest date found so far (CCYY/MM/DD)
    CHAR    currDate[BIOS_DATE_LENGTH]; // Date currently being examined (CCYY/MM/DD)
    PCHAR   start;                      // Start of the current search area.
    PCHAR   end;                        // End of the search area.
    ULONG   year;                       // YY
    ULONG   month;                      // MM
    ULONG   day;                        // DD
    ULONG   count;

#define IS_DIGIT(c) ((c) >= '0' && (c) <= '9')

    //
    // Initialize previous date
    //

    RtlZeroMemory(prevDate, BIOS_DATE_LENGTH);

    //
    // We need to look ahead 5 characters to determine the
    // validity of the date pattern.
    //

    start = SearchArea + 2;
    end = SearchArea + SearchLength - 5;

    //
    // Process the entire search area.
    //

    while (start < end) {

        //
        // We consider the following byte pattern as a potential date.
        // We are assuming the following date pattern Month/Day/Year.
        // "n/nn/nn" where n is any digit. We allow month to be single
        // digit only.
        //

        if (    start[0] == '/' && start[3] == '/' &&
                IS_DIGIT(*(start - 1)) &&
                IS_DIGIT(start[1]) && IS_DIGIT(start[2]) &&
                IS_DIGIT(start[4]) && IS_DIGIT(start[5])) {

            //
            // Copy MM/DD part into the currDate.
            //

            RtlMoveMemory(&currDate[5], start - 2, 5);

            //
            // Handle single digit month correctly.
            //

            if (!IS_DIGIT(currDate[5])) {
                currDate[5] = '0';
            }

            //
            // Copy the year YY into currDate
            //

            currDate[2] = start[4];
            currDate[3] = start[5];
            currDate[4] = currDate[7] = currDate[10] = '\0';

            //
            // Do basic validation for the date.
            // Only one field (YY) can be 0.
            // Only one field (YY) can be greater than 31.
            // We assume the ROM date to be in the format MM/DD/YY.
            //

            year = strtoul(&currDate[2], NULL, 16);
            month = strtoul(&currDate[5], NULL, 16);
            day = strtoul(&currDate[8], NULL, 16);

            //
            // Count the number of fields that are 0.
            //

            count = ((day == 0)? 1 : 0) + ((month == 0)? 1 : 0) + ((year == 0)? 1 : 0);
            if (count <= 1) {

                //
                // Count number of field that are greater than 31.
                //

                count = ((day > 0x31)? 1 : 0) + ((month > 0x31)? 1 : 0) + ((year > 0x31)? 1 : 0);
                if (count <= 1) {

                    //
                    // See if the ROM already has a 4 digit date. We do this only for System ROM
                    // since they have a consistent date format.
                    //

                    if (SystemBiosDate && IS_DIGIT(start[6]) && IS_DIGIT(start[7]) &&
                        (memcmp(&start[4], "19", 2) == 0 || memcmp(&start[4], "20", 2) == 0)) {

                        currDate[0] = start[4];
                        currDate[1] = start[5];
                        currDate[2] = start[6];
                        currDate[3] = start[7];

                    } else {

                        //
                        // Internally, we treat year as a 4 digit quantity
                        // for comparison to determine the newest date.
                        // We treat year YY < 80 as 20YY, otherwise 19YY.
                        //

                        if (year < 0x80) {
                            currDate[0] = '2';
                            currDate[1] = '0';
                        } else {
                            currDate[0] = '1';
                            currDate[1] = '9';
                        }
                    }

                    //
                    // Add the '/' delimiters into the date.
                    //

                    currDate[4] = currDate[7] = '/';

                    //
                    // Compare the dates, and save the newer one.
                    //

                    if (memcmp (prevDate, currDate, BIOS_DATE_LENGTH - 1) < 0) {
                        RtlMoveMemory(prevDate, currDate, BIOS_DATE_LENGTH - 1);
                    }

                    //
                    // Next search should start at the second '/'.
                    //

                    start += 2;
                }
            }
        }
        start++;
    }

    if (prevDate[0] != '\0') {

        //
        // Convert from the internal CCYY/MM/DD format to
        // return MM/DD//YY format.
        //

        RtlMoveMemory(DateString, &prevDate[5], 5);
        DateString[5] = '/';
        DateString[6] = prevDate[2];
        DateString[7] = prevDate[3];
        DateString[8] = '\0';

        return (TRUE);
    }

    //
    // If we did not find a date, return an empty string.
    //

    DateString[0] = '\0';
    return (FALSE);
}

BOOLEAN
CmpGetBiosVersion (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR VersionString
    )

/*++

Routine Description:

    This routine finds the version number stored in ROM, if any.

Arguments:

    SearchArea - the area to search for the version.

    SearchLength - Length of search

    VersionString - Supplies a pointer to a fixed length memory to receive
                 the version string.

Return Value:

    TRUE if a version number is found.  Else a value of FALSE is returned.

--*/
{
    PCHAR String;
    USHORT Length;
    USHORT i;
    CHAR Buffer[MAXIMUM_BIOS_VERSION_LENGTH];
    PCHAR BufferPointer;

        if (SearchArea != NULL) {

        //
        // If caller does not specify the search area, we will search
        // the area left from previous search.
        //

        BiosBegin = SearchArea;
        Start = SearchArea + 1;
        End = SearchArea + SearchLength - 2;
    }

    while (1) {

         //
         // Search for a period with a digit on either side
         //

         String = NULL;
         while (Start <= End) {
             if (*Start == '.' && *(Start+1) >= '0' && *(Start+1) <= '9' &&
                 *(Start-1) >= '0' && *(Start-1) <= '9') {
                 String = Start;
                 break;
             } else {
                 Start++;
             }
         }

         if (Start > End) {
             return(FALSE);
         } else {
             Start += 2;
         }

         Length = 0;
         Buffer[MAXIMUM_BIOS_VERSION_LENGTH - 1] = '\0';
         BufferPointer = &Buffer[MAXIMUM_BIOS_VERSION_LENGTH - 1];

         //
         // Search for the beginning of the string
         //

         String--;
         while (Length < MAXIMUM_BIOS_VERSION_LENGTH - 8 &&
                String >= BiosBegin &&
                *String >= ' ' && *String <= 127 &&
                *String != '$') {
             --BufferPointer;
             *BufferPointer = *String;
             --String, ++Length;
         }
         ++String;

         //
         // Can one of the search strings be found
         //

         for (i = 0; SearchStrings[i]; i++) {
             if (strstr(BufferPointer, SearchStrings[i])) {
                 goto Found;
             }
         }
    }

Found:

    //
    // Skip leading white space
    //

    for (; *String == ' '; ++String)
      ;

    //
    // Copy the string to user supplied buffer
    //

    for (i = 0; i < MAXIMUM_BIOS_VERSION_LENGTH - 1 &&
         String <= (End + 1) &&
         *String >= ' ' && *String <= 127 && *String != '$';
         ++i, ++String) {
         VersionString[i] = *String;
    }
    VersionString[i] = '\0';
    return (TRUE);
}

BOOLEAN
CmpGetAcpiBiosVersion(
    PCHAR VersionString
    )
{
    ULONG               length;
    PDESCRIPTION_HEADER header;
    ULONG               i;

    header = CmpFindACPITable(RSDT_SIGNATURE, &length);
    if (header) {

        for (i = 0; i < 6 && header->OEMID[i]; i++) {

            *VersionString++ = header->OEMID[i];
        }
        sprintf(VersionString, " - %x", header->OEMRevision);

        //
        // Unmap the table
        //
        MmUnmapIoSpace(header, length );

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
CmpGetAcpiBiosInformation(
    PACPI_BIOS_INFORMATION AcpiBiosInformation
    )
{
    ULONG               length;
    PFADT               fadt;
    BOOLEAN             result;

    AcpiBiosInformation->BootArchitecture = 0;
    AcpiBiosInformation->Capabilities = 0;
    AcpiBiosInformation->PreferredProfile = 0;
    fadt = (PFADT)CmpFindACPITable(FADT_SIGNATURE, &length);
    if (fadt) {

        //
        // Information is valid only for ACPI version > 1.0
        //

        if (fadt->Header.Revision > 1) {

            AcpiBiosInformation->BootArchitecture = fadt->boot_arch;
            AcpiBiosInformation->Capabilities = fadt->flags;
            AcpiBiosInformation->PreferredProfile = fadt->pm_profile;
        }

        result = (fadt->Header.Revision > 1)? TRUE : FALSE;

        //
        // Unmap the table
        //

        MmUnmapIoSpace(fadt, length);

        return result;
    }

    return FALSE;
}

NTSTATUS
CmpInitializeMachineDependentConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine creates x86 specific entries in the registry.

Arguments:

    LoaderBlock - supplies a pointer to the LoaderBlock passed in from the
                  OS Loader.

Returns:

    NTSTATUS code for sucess or reason of failure.

--*/
{
    NTSTATUS Status;
    ULONG VideoBiosStart;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING ValueData;
    ANSI_STRING AnsiString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;
    HANDLE ParentHandle;
    HANDLE BaseHandle, NpxHandle;
    CONFIGURATION_COMPONENT_DATA CurrentEntry;
    const char *VendorID;
    CHAR  Buffer[MAXIMUM_BIOS_VERSION_LENGTH];
    PKPRCB Prcb;
    ULONG  i, Junk;
    ULONG VersionsLength = 0, Length;
    PCHAR VersionStrings, VersionPointer;
    UNICODE_STRING SectionName;
    SIZE_T ViewSize;
    LARGE_INTEGER ViewBase;
    PVOID BaseAddress;
    HANDLE SectionHandle;
    USHORT DeviceIndexTable[NUMBER_TYPES];
    ULONG CpuIdFunction;
    ULONG MaxExtFn;
    PULONG NameString = NULL;
    ULONG   P0L2Size = 0;
    ULONG   ThisProcessorL2Size;
    struct {
        union {
            UCHAR   Bytes[CPUID_PROCESSOR_NAME_STRING_SZ];
            ULONG   DWords[1];
        } u;
    } ProcessorNameString;
    ULONG VersionPass;
    ACPI_BIOS_INFORMATION AcpiBiosInformation;
    UNICODE_STRING registryDate;
    HANDLE  BiosInfo;
    PKEY_VALUE_PARTIAL_INFORMATION information;


    for (i = 0; i < NUMBER_TYPES; i++) {
        DeviceIndexTable[i] = 0;
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                &CmRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagement,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                               );

    Status = NtOpenKey( &BaseHandle,
                        KEY_READ | KEY_WRITE,
                        &ObjectAttributes
                      );

    if (NT_SUCCESS(Status)) {

        ULONG paeEnabled;

        if (SharedUserData->ProcessorFeatures[PF_PAE_ENABLED] == FALSE) {
            paeEnabled = 0;
        } else {
            paeEnabled = 1;
        }

        RtlInitUnicodeString( &ValueName,
                              CmPhysicalAddressExtension );


        NtSetValueKey( BaseHandle,
                       &ValueName,
                       TITLE_INDEX_VALUE,
                       REG_DWORD,
                       &paeEnabled,
                       sizeof(paeEnabled) );

        NtClose( BaseHandle );
   }





    InitializeObjectAttributes( &ObjectAttributes,
                                &CmRegistryMachineHardwareDescriptionSystemName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtCreateKey( &ParentHandle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          NULL,
                          0,
                          NULL);

    if (!NT_SUCCESS(Status)) {
        // Something is really wrong...
        return Status;
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                &CmRegistryMachineSystemCurrentControlSetControlBiosInfo,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtCreateKey(   &BiosInfo,
                            KEY_ALL_ACCESS,
                            &ObjectAttributes,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            &Disposition
                        );

    if (!NT_SUCCESS(Status)) {
        // Something is really wrong...
        return Status;
    }

    //
    // On an ARC machine the processor(s) are included in the hardware
    // configuration passed in from bootup.  Since there's no standard
    // way to get all the ARC information for each processor in an MP
    // machine via pc-ROMs the information will be added here (if it's
    // not already present).
    //

    RtlInitUnicodeString( &KeyName,
                          L"CentralProcessor"
                        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        ParentHandle,
        NULL
        );

    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtCreateKey(
                &BaseHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                0,
                NULL,
                0,
                &Disposition
                );

    NtClose (BaseHandle);

    if (Disposition == REG_CREATED_NEW_KEY) {

        //
        // The ARC rom didn't add the processor(s) into the registry.
        // Do it now.
        //

        CmpConfigurationData = (PCM_FULL_RESOURCE_DESCRIPTOR)ExAllocatePool(
                                            PagedPool,
                                            CmpConfigurationAreaSize
                                            );

        //
        // if (CmpConfigurationData == 0) {
        //     <do something useful>
        //     Note: we don't actually use it so it doesn't matter for now
        //     since it isn't used until the free.  go figure.
        // }
        //

        for (i=0; i < (ULONG)KeNumberProcessors; i++) {
            Prcb = KiProcessorBlock[i];

            RtlZeroMemory (&CurrentEntry, sizeof CurrentEntry);
            CurrentEntry.ComponentEntry.Class = ProcessorClass;
            CurrentEntry.ComponentEntry.Type = CentralProcessor;
            CurrentEntry.ComponentEntry.Key = i;
            CurrentEntry.ComponentEntry.AffinityMask = (ULONG)AFFINITY_MASK(i);

            CurrentEntry.ComponentEntry.Identifier = Buffer;

#if defined(_X86_)

            if (Prcb->CpuID == 0) {

                //
                // Old style stepping format
                //

                sprintf (Buffer, (PCHAR)CmpID1,
                    Prcb->CpuType,
                    (Prcb->CpuStep >> 8) + 'A',
                    Prcb->CpuStep & 0xff
                    );

            } else
#endif

            {

                //
                // New style stepping format
                //

                sprintf (Buffer, (PCHAR)CmpID2,
                    Prcb->CpuType,
                    (Prcb->CpuStep >> 8),
                    Prcb->CpuStep & 0xff
                    );
            }

            CurrentEntry.ComponentEntry.IdentifierLength =
                (ULONG)(strlen (Buffer) + 1);

            Status = CmpInitializeRegistryNode(
                &CurrentEntry,
                ParentHandle,
                &BaseHandle,
                -1,
                (ULONG)-1,
                DeviceIndexTable
                );

            if (!NT_SUCCESS(Status)) {
                return(Status);
            }


            if (KeI386NpxPresent) {
                RtlZeroMemory (&CurrentEntry, sizeof CurrentEntry);
                CurrentEntry.ComponentEntry.Class = ProcessorClass;
                CurrentEntry.ComponentEntry.Type = FloatingPointProcessor;
                CurrentEntry.ComponentEntry.Key = i;
                CurrentEntry.ComponentEntry.AffinityMask = (ULONG)AFFINITY_MASK(i);

                CurrentEntry.ComponentEntry.Identifier = Buffer;

                if (Prcb->CpuType == 3) {

                    //
                    // 386 processors have 387's installed, else
                    // use processor identifier as the NPX identifier
                    //

                    strcpy (Buffer, "80387");
                }

                CurrentEntry.ComponentEntry.IdentifierLength =
                    (ULONG)(strlen (Buffer) + 1);

                Status = CmpInitializeRegistryNode(
                    &CurrentEntry,
                    ParentHandle,
                    &NpxHandle,
                    -1,
                    (ULONG)-1,
                    DeviceIndexTable
                    );

                if (!NT_SUCCESS(Status)) {
                    NtClose(BaseHandle);
                    return(Status);
                }

                NtClose(NpxHandle);
            }

            //
            // If processor supports Cpu Indentification then
            // go obtain that information for the registry
            //

            VendorID = Prcb->CpuID ? (const char *)Prcb->VendorString : NULL;

            //
            // Move to target processor and get other related
            // processor information for the registery
            //

            KeSetSystemAffinityThread(Prcb->SetMember);

#if !defined(_AMD64_)
            if (!Prcb->CpuID) {

                //
                // Test for Cyrix processor
                //

                if (Ke386CyrixId ()) {
                    VendorID = (const char *)CmpCyrixID;
                }
            } else
#endif
            {

                //
                // If this processor has extended CPUID functions, get
                // the ProcessorNameString.  Although the Intel books
                // say that for CpuID functions > than the valued
                // returned for function 0 will return undefined results,
                // we have a guarantee from Intel that that result will
                // never have the highest order bit set.  This enables
                // us to determine if the extended functions are supported
                // by issuing CpuID function 0x80000000.
                //
                // Note:  It is not known that this is true for all x86
                // clones.  If/when we find exceptions we will support
                // them.  In the mean time we are asking the clone makers
                // to guarantee this behavior.
                //

                CPUID(CPUID_EXTFN_BASE, &MaxExtFn, &Junk, &Junk, &Junk);

                if (MaxExtFn >= (CPUID_EXTFN_PROCESSOR_NAME + 2)) {

                    //
                    // This processor supports extended CPUID functions
                    // up to and (at least) including processor name string.
                    //
                    // Each CPUID call for the processor name string will
                    // return 16 bytes, 48 bytes in all, zero terminated.
                    //

                    NameString = &ProcessorNameString.u.DWords[0];

                    for (CpuIdFunction = CPUID_EXTFN_PROCESSOR_NAME;
                         CpuIdFunction <= (CPUID_EXTFN_PROCESSOR_NAME+2);
                         CpuIdFunction++) {

                        CPUID(CpuIdFunction,
                              NameString,
                              NameString + 1,
                              NameString + 2,
                              NameString + 3);
                        NameString += 4;
                    }

                    //
                    // Enforce 0 byte terminator.
                    //

                    ProcessorNameString.u.Bytes[CPUID_PROCESSOR_NAME_STRING_SZ-1] = 0;
                }
            }

            ThisProcessorL2Size = KeGetPcr()->SecondLevelCacheSize;

            //
            // Restore thread's affinity to all processors
            //

            KeRevertToUserAffinityThread();

            if (NameString) {

                //
                // Add Processor Name String to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpProcessorNameString
                    );

                RtlInitAnsiString(
                    &AnsiString,
                    (PCSZ)ProcessorNameString.u.Bytes
                    );

                Status = RtlAnsiStringToUnicodeString(
                            &ValueData,
                            &AnsiString,
                            TRUE
                            );
                if( NT_SUCCESS(Status) ) {
                    Status = NtSetValueKey(
                                BaseHandle,
                                &ValueName,
                                TITLE_INDEX_VALUE,
                                REG_SZ,
                                ValueData.Buffer,
                                ValueData.Length + sizeof( UNICODE_NULL )
                                );

                    RtlFreeUnicodeString(&ValueData);
                }
            }

            if (VendorID) {

                //
                // Add Vendor Indentifier to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpVendorID
                    );

                RtlInitAnsiString(
                    &AnsiString,
                    VendorID
                    );

                Status = RtlAnsiStringToUnicodeString(
                            &ValueData,
                            &AnsiString,
                            TRUE
                            );

                if( NT_SUCCESS(Status) ) {
                    Status = NtSetValueKey(
                                BaseHandle,
                                &ValueName,
                                TITLE_INDEX_VALUE,
                                REG_SZ,
                                ValueData.Buffer,
                                ValueData.Length + sizeof( UNICODE_NULL )
                                );

                    RtlFreeUnicodeString(&ValueData);
                }
            }

            if (Prcb->FeatureBits) {
                //
                // Add processor feature bits to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpFeatureBits
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_DWORD,
                            &Prcb->FeatureBits,
                            sizeof (Prcb->FeatureBits)
                            );
            }

            if (Prcb->MHz) {
                //
                // Add processor MHz to the registery
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpMHz
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_DWORD,
                            &Prcb->MHz,
                            sizeof (Prcb->MHz)
                            );
            }

            if (Prcb->UpdateSignature.QuadPart) {
                //
                // Add current microcode update signature (if any) to
                // the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpUpdateSignature
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_BINARY,
                            &Prcb->UpdateSignature,
                            sizeof (Prcb->UpdateSignature)
                            );
            }

            NtClose(BaseHandle);

            //
            // Check processor steppings.
            //

            if (i == 0) {

                P0L2Size = ThisProcessorL2Size;

            } else {

                //
                // Check all processors against processor 0. Compare
                //     CPUID supported,
                //     Vendor ID String
                //     Family and Stepping
                //     L2 cache size.
                //

                if (Prcb->CpuID) {
                    if (strcmp((PCHAR)Prcb->VendorString,
                               (PCHAR)KiProcessorBlock[0]->VendorString)) {
                        CmProcessorMismatch |= CM_PROCESSOR_MISMATCH_VENDOR;
                    }
                    if (ThisProcessorL2Size != P0L2Size) {
                        CmProcessorMismatch |= CM_PROCESSOR_MISMATCH_L2;
                    }
                    if ((Prcb->CpuType != KiProcessorBlock[0]->CpuType) ||
                        (Prcb->CpuStep != KiProcessorBlock[0]->CpuStep)) {
                        CmProcessorMismatch |= CM_PROCESSOR_MISMATCH_STEPPING;
                    }
                } else {

                    //
                    // If this processor doesn't support CPUID, P0
                    // shouldn't support it either.
                    //

                    if (KiProcessorBlock[0]->CpuID) {
                        CmProcessorMismatch |= CM_PROCESSOR_MISMATCH_STEPPING;
                    }
                }
            }
        }

        if (0 != CmpConfigurationData) {
            ExFreePool((PVOID)CmpConfigurationData);
        }
    }

    //
    // Next we try to collect System BIOS date and version strings.
    //

    //
    // Open a physical memory section to map in physical memory.
    //

    RtlInitUnicodeString(
        &SectionName,
        L"\\Device\\PhysicalMemory"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SectionName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    Status = ZwOpenSection(
        &SectionHandle,
        SECTION_ALL_ACCESS,
        &ObjectAttributes
        );

    if (!NT_SUCCESS(Status)) {

        //
        // If fail, forget the bios data and version
        //

        goto AllDone;
    }

    //
    // Examine the first page of physical memory for int 10 segment
    // address.
    //

    BaseAddress = 0;
    ViewSize = 0x1000;
    ViewBase.LowPart = 0;
    ViewBase.HighPart = 0;

    Status =ZwMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &ViewBase,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(Status)) {
        VideoBiosStart = VIDEO_BIOS_START;
    } else {
        VideoBiosStart = (*((PULONG)BaseAddress + INT10_VECTOR) & 0xFFFF0000) >> 12;
        VideoBiosStart += (*((PULONG)BaseAddress + INT10_VECTOR) & 0x0000FFFF);
        VideoBiosStart &= 0xffff8000;
        if (VideoBiosStart < VIDEO_BIOS_START) {
            VideoBiosStart = VIDEO_BIOS_START;
        }
        Status = ZwUnmapViewOfSection(
            NtCurrentProcess(),
            BaseAddress
            );
    }

    VersionStrings = ExAllocatePool(PagedPool, VERSION_DATA_LENGTH);
    BaseAddress = 0;
    ViewSize = SYSTEM_BIOS_LENGTH;
    ViewBase.LowPart = SYSTEM_BIOS_START;
    ViewBase.HighPart = 0;

    Status =ZwMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &ViewBase,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_READWRITE
        );

    if (NT_SUCCESS(Status)) {

        if (CmpGetBiosDate(BaseAddress, SYSTEM_BIOS_LENGTH, Buffer, TRUE)) {

            //
            // Convert ascii date string to unicode string and
            // store it in registry.
            //

            RtlInitUnicodeString(
                &ValueName,
                L"SystemBiosDate"
                );

            RtlInitAnsiString(
                &AnsiString,
                Buffer
                );

            Status = RtlAnsiStringToUnicodeString(
                        &ValueData,
                        &AnsiString,
                        TRUE
                        );

            if( NT_SUCCESS(Status) ) {

                Status = NtSetValueKey(
                            ParentHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            ValueData.Buffer,
                            ValueData.Length + sizeof( UNICODE_NULL )
                            );

                RtlFreeUnicodeString(&ValueData);
            }
        }

        //
        // Check if the BIOS date has changed.
        //
        if (CmpGetBiosDate((PCHAR)BaseAddress + 0xFFF5, 8, Buffer, TRUE)) {

            RtlInitAnsiString(
                &AnsiString,
                Buffer
                );

            Status = RtlAnsiStringToUnicodeString(
                        &ValueData,
                        &AnsiString,
                        TRUE
                        );
            if (NT_SUCCESS(Status)) {

                //
                // Get the current date in the registry.
                //
                RtlInitUnicodeString(
                    &ValueName,
                    L"SystemBiosDate"
                    );
                Status = CmpGetRegistryValue(
                            BiosInfo,
                            ValueName.Buffer,
                            &information
                            );
                if (NT_SUCCESS(Status) && information) {

                    registryDate.Buffer = (PWCHAR)&information->Data[0];
                    registryDate.MaximumLength = (USHORT)information->DataLength;
                    registryDate.Length = registryDate.MaximumLength - sizeof(UNICODE_NULL);
                    if (RtlCompareUnicodeString(&ValueData, &registryDate, TRUE)) {

                        RtlInitUnicodeString(
                            &ValueName,
                            L"OldSystemBiosDate"
                            );
                        Status = NtSetValueKey(
                                    ParentHandle,
                                    &ValueName,
                                    TITLE_INDEX_VALUE,
                                    REG_SZ,
                                    registryDate.Buffer,
                                    registryDate.Length + sizeof(UNICODE_NULL)
                                    );
                    }
                    ExFreePool(information);
                }

                //
                // Set the current date in the registry.
                //
                RtlInitUnicodeString(
                    &ValueName,
                    L"SystemBiosDate"
                    );

                Status = NtSetValueKey(
                            BiosInfo,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            ValueData.Buffer,
                            ValueData.Length + sizeof(UNICODE_NULL)
                            );

                RtlFreeUnicodeString(&ValueData);
            }
        }

        if ((VersionPointer = VersionStrings) != NULL) {

            //
            // Try to detect ALL the possible BIOS version strings.
            //

            for (VersionPass = 0; ; VersionPass++) {

                if (VersionPass == 0) {

                    //
                    // First try to get the version from ACPI tables.
                    //

                    if (!CmpGetAcpiBiosVersion(Buffer)) {

                        //
                        // This is a non-ACPI system.
                        //
                        continue;
                    }
                } else {

                    if (!CmpGetBiosVersion((VersionPass == 1)?  BaseAddress : NULL, (VersionPass == 1)? SYSTEM_BIOS_LENGTH : 0, Buffer)) {

                        break;
                    }
                }

                //
                // Convert to unicode strings and copy them to our
                // VersionStrings buffer.
                //

                RtlInitAnsiString(
                    &AnsiString,
                    Buffer
                    );

                if( NT_SUCCESS(RtlAnsiStringToUnicodeString(
                                    &ValueData,
                                    &AnsiString,
                                    TRUE
                                    )) ) {

                    Length = ValueData.Length + sizeof(UNICODE_NULL);
                    RtlCopyMemory(VersionPointer,
                                  ValueData.Buffer,
                                  Length
                                  );
                    VersionsLength += Length;
                    RtlFreeUnicodeString(&ValueData);
                    if (VersionsLength + (MAXIMUM_BIOS_VERSION_LENGTH +
                        sizeof(UNICODE_NULL)) * 2 > PAGE_SIZE) {
                        break;
                    }
                    VersionPointer += Length;
                }
            }

            //
            // If we found any version string, write it to the registry.
            //

            if (VersionsLength != 0) {

                //
                // Append a UNICODE_NULL to the end of VersionStrings
                //

                *(PWSTR)VersionPointer = UNICODE_NULL;
                VersionsLength += sizeof(UNICODE_NULL);

                //
                // If any version string is found, we set up a ValueName and
                // initialize its value to the string(s) we found.
                //

                RtlInitUnicodeString(
                    &ValueName,
                    L"SystemBiosVersion"
                    );

                Status = NtSetValueKey(
                            ParentHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_MULTI_SZ,
                            VersionStrings,
                            VersionsLength
                            );
            }
        }
        ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
    }

    //
    // Get system information like SealedCaseSystem, LegacyFreeSystem etc from
    // the BIOS.
    //
    if (CmpGetAcpiBiosInformation(&AcpiBiosInformation)) {

        RtlInitUnicodeString(
            &ValueName,
            L"BootArchitecture"
            );

        NtSetValueKey(
            ParentHandle,
            &ValueName,
            TITLE_INDEX_VALUE,
            REG_DWORD,
            &AcpiBiosInformation.BootArchitecture,
            sizeof(ULONG)
            );

        RtlInitUnicodeString(
            &ValueName,
            L"PreferredProfile"
            );

        NtSetValueKey(
            ParentHandle,
            &ValueName,
            TITLE_INDEX_VALUE,
            REG_DWORD,
            &AcpiBiosInformation.PreferredProfile,
            sizeof(ULONG)
            );

        RtlInitUnicodeString(
            &ValueName,
            L"Capabilities"
            );

        NtSetValueKey(
            ParentHandle,
            &ValueName,
            TITLE_INDEX_VALUE,
            REG_DWORD,
            &AcpiBiosInformation.Capabilities,
            sizeof(ULONG)
            );
    }

    //
    // Next we try to collect Video BIOS date and version strings.
    //

    BaseAddress = 0;
    ViewSize = VIDEO_BIOS_LENGTH;
    ViewBase.LowPart = VideoBiosStart;
    ViewBase.HighPart = 0;

    Status =ZwMapViewOfSection(
        SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &ViewBase,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_READWRITE
        );

    if (NT_SUCCESS(Status)) {
        if (CmpGetBiosDate(BaseAddress, VIDEO_BIOS_LENGTH, Buffer, FALSE)) {

            RtlInitUnicodeString(
                &ValueName,
                L"VideoBiosDate"
                );

            RtlInitAnsiString(
                &AnsiString,
                Buffer
                );

            Status = RtlAnsiStringToUnicodeString(
                        &ValueData,
                        &AnsiString,
                        TRUE
                        );

            if( NT_SUCCESS(Status) ) {
                Status = NtSetValueKey(
                            ParentHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            ValueData.Buffer,
                            ValueData.Length + sizeof( UNICODE_NULL )
                            );

                RtlFreeUnicodeString(&ValueData);
            }
        }

        if (VersionStrings && CmpGetBiosVersion(BaseAddress, VIDEO_BIOS_LENGTH, Buffer)) {
            VersionPointer = VersionStrings;
            do {

                //
                // Try to detect ALL the possible BIOS version strings.
                // Convert them to unicode strings and copy them to our
                // VersionStrings buffer.
                //

                RtlInitAnsiString(
                    &AnsiString,
                    Buffer
                    );

                if( NT_SUCCESS(RtlAnsiStringToUnicodeString(
                                &ValueData,
                                &AnsiString,
                                TRUE
                                )) ) {

                    Length = ValueData.Length + sizeof(UNICODE_NULL);
                    RtlCopyMemory(VersionPointer,
                                  ValueData.Buffer,
                                  Length
                                  );
                    VersionsLength += Length;
                    RtlFreeUnicodeString(&ValueData);
                    if (VersionsLength + (MAXIMUM_BIOS_VERSION_LENGTH +
                        sizeof(UNICODE_NULL)) * 2 > PAGE_SIZE) {
                        break;
                    }
                    VersionPointer += Length;
                }
            } while (CmpGetBiosVersion(NULL, 0, Buffer));

            if (VersionsLength != 0) {

                //
                // Append a UNICODE_NULL to the end of VersionStrings
                //

                *(PWSTR)VersionPointer = UNICODE_NULL;
                VersionsLength += sizeof(UNICODE_NULL);

                RtlInitUnicodeString(
                    &ValueName,
                    L"VideoBiosVersion"
                    );

                Status = NtSetValueKey(
                            ParentHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_MULTI_SZ,
                            VersionStrings,
                            VersionsLength
                            );
            }
        }
        ZwUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
    }
    ZwClose(SectionHandle);
    if (VersionStrings) {
        ExFreePool((PVOID)VersionStrings);
    }

AllDone:

    NtClose (BiosInfo);
    NtClose (ParentHandle);

    //
    // Add any other x86 specific code here...
    //

#ifdef _WANT_MACHINE_IDENTIFICATION

    //
    // Do machine identification.
    //

    CmpPerformMachineIdentification(LoaderBlock);

#endif

    return STATUS_SUCCESS;
}

#ifdef _WANT_MACHINE_IDENTIFICATION

VOID
CmpPerformMachineIdentification(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    ULONG   majorVersion;
    ULONG   minorVersion;
    CHAR    versionBuffer[64];
    PCHAR   major;
    PCHAR   minor;
    ULONG   minSize;

    major = strcpy(versionBuffer, VER_PRODUCTVERSION_STR);
    minor = strchr(major, '.');
    majorVersion = atoi(major);
    if( minor != NULL ) {
        *minor++ = '\0';
        minorVersion = atoi(minor);
    } else {
        minorVersion = 0;
    }
    if (    LoaderBlock->Extension->MajorVersion > majorVersion ||
            (LoaderBlock->Extension->MajorVersion == majorVersion &&
                LoaderBlock->Extension->MinorVersion >= minorVersion)) {

        minSize = FIELD_OFFSET(LOADER_PARAMETER_EXTENSION, InfFileSize) + sizeof(ULONG);
        if (LoaderBlock->Extension && LoaderBlock->Extension->Size >= minSize) {

            if (LoaderBlock->Extension->InfFileImage && LoaderBlock->Extension->InfFileSize) {

                CmpMatchInfList(
                    LoaderBlock->Extension->InfFileImage,
                    LoaderBlock->Extension->InfFileSize,
                    "MachineDescription"
                    );
            }
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\i386\geninst.h ===
/*++                    

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    geninst.h

Abstract:

    This module contains support routines for implementing 
    running of Install sections containing AddReg, DelReg, 
    BitReg etc.
    
Environment:

    Kernel mode

--*/

BOOLEAN
CmpGenInstall(
    IN PVOID InfHandle,
    IN PCHAR Section
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\i386\rules.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.


Module Name:

    rules.c

Abstract:

    This module contains routines to implement rules used to describe a machine.
    This is based on the detection code from W9x.

Author:

    Santosh Jodh (santoshj) 08-Aug-1998

Environment:

    Kernel mode.

Revision History:

--*/

#include "cmp.h"
#include "stdlib.h"
#include "parseini.h"
#include "geninst.h"
#include "acpitabl.h"
#include "ntacpi.h"
#include "rules.h"

#define TABLE_ENTRIES_FROM_RSDT_POINTER(p)  (((p)->Header.Length-min((p)->Header.Length, sizeof(DESCRIPTION_HEADER))) / 4)


//
// Size of the ROM BIOS segment.
//

#define SYSTEM_BIOS_LENGTH 0x10000

//
// PnP BIOS structure signature.
//

#define PNPBIOS_SIGNATURE   'PnP$'

typedef
LOGICAL
(* PFN_RULE)(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

typedef struct _PNP_BIOS_TABLE PNP_BIOS_TABLE, *PPNP_BIOS_TABLE;

#pragma pack(push, 1)

struct _PNP_BIOS_TABLE
{
    ULONG   Signature;
    UCHAR   Version;
    UCHAR   Length;
    USHORT  ControlField;
    UCHAR   CheckSum;
    ULONG   EventNotification;
    USHORT  RMOffset;
    USHORT  RMSegment;
    USHORT  PMOffset;
    ULONG   PMSegment;
    ULONG   Oem;
    USHORT  RMData;
    ULONG   PMData;
};

#pragma pack(pop)

ULONG
CmpComputeChecksum(
    IN PCHAR    Address,
    IN ULONG    Size
    );

NTSTATUS
CmpFindRSDTTable(
    OUT PACPI_BIOS_MULTI_NODE   *Rsdt
    );

LOGICAL
CmpCheckOperator(
    IN PCHAR Operator,
    IN ULONG Lhs,
    IN ULONG Rhs
    );

PVOID
CmpMapPhysicalAddress(
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR Address,
    IN ULONG Size
    );

BOOLEAN
CmpGetInfData(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG KeyIndex,
    IN ULONG LineIndex,
    IN OUT PCHAR Buffer,
    IN OUT PULONG BufferSize
    );

PVOID
CmpFindPattern(
    IN PCHAR Buffer,
    IN ULONG BufSize,
    IN PCHAR Pattern,
    IN ULONG PatSize,
    IN BOOLEAN IgnoreCase,
    IN ULONG Step
    );

 ULONG
 CmpGetPnPBIOSTableAddress(
    VOID
    );

BOOLEAN
CmpMatchDescription(
    IN PVOID InfHandle,
    IN PCHAR Description
    );

LOGICAL
CmpMatchDateRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchMemoryRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchSearchRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchNextMatchRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchPointerRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchOemIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchPModeRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchRmPmSameRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchInstallRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchAcpiOemIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchAcpiOemTableIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchAcpiOemRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchAcpiRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

LOGICAL
CmpMatchAcpiCreatorRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    );

//
// Number of rules currently implemented.
//

#define NUM_OF_RULES    14

//
// Rule table.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#pragma const_seg("INITCONST")
#endif
struct {
    PCHAR       Name;
    PFN_RULE    Action;
} const gRuleTable[NUM_OF_RULES] =
{
    {"Date", CmpMatchDateRule},
    {"Memory", CmpMatchMemoryRule},
    {"Search", CmpMatchSearchRule},
    {"NextMatch", CmpMatchNextMatchRule},
    {"Pointer", CmpMatchPointerRule},
    {"OemId", CmpMatchOemIdRule},
    {"PMode", CmpMatchPModeRule},
    {"RmPmSame", CmpMatchRmPmSameRule},
    {"Install", CmpMatchInstallRule},
    {"ACPIOemId", CmpMatchAcpiOemIdRule},
    {"ACPIOemTableId", CmpMatchAcpiOemTableIdRule},
    {"ACPIOemRevision", CmpMatchAcpiOemRevisionRule},
    {"ACPIRevision", CmpMatchAcpiRevisionRule},
    {"ACPICreatorRevision", CmpMatchAcpiCreatorRevisionRule}
};

PVOID   gSearchAddress = NULL;

static const WCHAR rgzMultiFunctionAdapter[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
static const WCHAR rgzAcpiConfigurationData[] = L"Configuration Data";
static const WCHAR rgzAcpiIdentifier[] = L"Identifier";
static const WCHAR rgzBIOSIdentifier[] = L"ACPI BIOS";

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpGetRegistryValue)
#pragma alloc_text(INIT,CmpFindACPITable)
#pragma alloc_text(INIT,CmpFindRSDTTable)
#pragma alloc_text(INIT,CmpComputeChecksum)
#pragma alloc_text(INIT,CmpCheckOperator)
#pragma alloc_text(INIT,CmpMapPhysicalAddress)
#pragma alloc_text(INIT,CmpGetInfData)
#pragma alloc_text(INIT,CmpFindPattern)
#pragma alloc_text(INIT,CmpGetPnPBIOSTableAddress)
#pragma alloc_text(INIT,CmpMatchInfList)
#pragma alloc_text(INIT,CmpMatchDescription)
#pragma alloc_text(INIT,CmpMatchDateRule)
#pragma alloc_text(INIT,CmpMatchMemoryRule)
#pragma alloc_text(INIT,CmpMatchSearchRule)
#pragma alloc_text(INIT,CmpMatchNextMatchRule)
#pragma alloc_text(INIT,CmpMatchPointerRule)
#pragma alloc_text(INIT,CmpMatchOemIdRule)
#pragma alloc_text(INIT,CmpMatchPModeRule)
#pragma alloc_text(INIT,CmpMatchRmPmSameRule)
#pragma alloc_text(INIT,CmpMatchInstallRule)
#pragma alloc_text(INIT,CmpMatchAcpiOemIdRule)
#pragma alloc_text(INIT,CmpMatchAcpiOemTableIdRule)
#pragma alloc_text(INIT,CmpMatchAcpiOemRevisionRule)
#pragma alloc_text(INIT,CmpMatchAcpiRevisionRule)
#pragma alloc_text(INIT,CmpMatchAcpiCreatorRevisionRule)
#endif


BOOLEAN
CmpMatchInfList(
    IN PVOID InfImage,
    IN ULONG ImageSize,
    IN PCHAR Section
    )

/*++

    Routine Description:

    Input Parameters:

        InfImage - Pointer to the inf image in memory.

        ImageSize - Size of the inf image.

        Section - Section name containing the descriptions.

        Description -

    Return Value:

        TRUE if the machine matches any one of the descriptions in the inf.

--*/

{
    PCHAR   computerName;
    ULONG   i = 0;
    PVOID   infHandle;
    BOOLEAN result = FALSE;

    infHandle = CmpOpenInfFile(InfImage, ImageSize);

    if (infHandle)
    {
        //
        // Do any clean-up specified in the inf.
        //

        CmpGenInstall(infHandle, "Cleanup");

        //
        // Go through each description in this section and try to match
        // this machine to it.
        //

        while ((computerName = CmpGetSectionLineIndex(infHandle, Section, i++, 0)))
        {
            //
            // Reset search result from previous description.
            //

            gSearchAddress = NULL;

            //
            // We will process ALL sections even if one or more match.
            //

            if (CmpMatchDescription(infHandle, computerName))
            {
                CmKdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_WARNING_LEVEL, "CmpMatchInfList: Machine matches %s description!\n", computerName));
                result = TRUE;
            }
        }

        CmpCloseInfFile(infHandle);
    }

    //
    // None of the descriptions match.
    //

    return (result);
}

BOOLEAN
CmpMatchDescription(
    IN PVOID InfHandle,
    IN PCHAR Description
    )

/*++

    Routine Description:

        This routine processes all the rules in the specified description.

    Input Parameters:

        InfHandle - Handle to the inf containing the description.

        Description - Section name containing the rules.

    Return Value:

        TRUE iff all the rules in the description succeed.

--*/

{
    ULONG   ruleNumber;
    ULONG   i;
    PCHAR   ruleName;

    //
    // Proceed only if the section does exist.
    //

    if (CmpSearchInfSection(InfHandle, Description))
    {
        //
        // Go through all the rules in the description and try to match
        // each of them.
        //

        ruleNumber = 0;
        while ((ruleName = CmpGetKeyName(InfHandle, Description, ruleNumber)))
        {
            //
            // Search for the rule in our table.
            //

            for (   i = 0;
                    i < NUM_OF_RULES &&
                        _stricmp(ruleName, gRuleTable[i].Name);
                    i++);

            //
            // If we did not find the rule or the rule failed,
            // return failure.
            //

            if (    i >= NUM_OF_RULES ||
                    !(*gRuleTable[i].Action)(InfHandle, Description, ruleNumber++))
            {
                return (FALSE);
            }
        }

        //
        // Description matches if we found at least one rule and all rules
        // succeeded.
        //

        if (ruleNumber)
        {
            return (TRUE);
        }
    }

    //
    // Description did not match.
    //

    return (FALSE);
}

LOGICAL
CmpMatchDateRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )

/*++

    Routine Description:

        This routine checks if the machine satisfies the DATE rule. The BIOS date
        is stored in a standard location in the BIOS ROM at FFFF:5.

        Syntax -

        DATE=operator,month,day,year
            where operator [=, ==, !=, <>, <, <=, =<, >, >=, =>]

        Examples -

        date="<=",2,1,95
            is TRUE if the BIOS date on this machine is less than or equal to
            02/01/95.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Description - Name of the section containing the rule info.

        RuleIndex - Line number for the rule in the description section.

    Return Value:

        TRUE if the BIOS on this machine has the specified relation with the
        date specified in the rule.

--*/

{
    PCHAR   op;
    PCHAR   month;
    PCHAR   day;
    PCHAR   year;
    ULONG   infDate;
    ULONG   yr;
    ULONG   biosDate;
    CHAR    temp[3];
    PVOID   baseAddress;
    PCHAR   address;

    op = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    month = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);
    day = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 2);
    year = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 3);

    if (op && month && day && year)
    {
        yr = strtoul(year, NULL, 16);
        infDate = ((yr < 0x80) ? 0x20000000 : 0x19000000) +
                    (yr << 16) +
                    (strtoul(month, NULL, 16) << 8) +
                    (strtoul(day, NULL, 16));

        address = CmpMapPhysicalAddress(&baseAddress, 0xFFFF5, 8);
        if (address)
        {
            temp[2] = '\0';

            RtlCopyBytes(temp, address + 6, 2);
            yr = strtoul(temp, NULL, 16);
            biosDate = ((yr < 0x80) ? 0x20000000 : 0x19000000) +
                        (yr << 16);

            RtlCopyBytes(temp, address, 2);
            biosDate |= (strtoul(temp, NULL, 16) << 8);

            RtlCopyBytes(temp, address + 3, 2);
            biosDate |= strtoul(temp, NULL, 16);

            ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);

            if (CmpCheckOperator(op, biosDate, infDate))
            {
                return (TRUE);
            }
        }
    }

    return (FALSE);
}

LOGICAL
CmpMatchMemoryRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )

/*++

    Routine Description:

        This routine checks if the machine satisfies the MEMORY rule.

        Syntax -

        MEMORY=segment,offset,type,data
            where type ["S", "B"]

        Examples -

        memory=f000,e000,S,"TOSHIBA"
            is TRUE if the memory in this machine at physical address f000:e000
            has the string "TOSHIBA".

        memory=ffff,5,B,01,02
            is TRUE if the memory in this machine at physical memory ffff:5
            has the bytes 0x01 and 0x02.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Description - Name of the section containing the rule info.

        RuleIndex - Line number for the rule in the description section.

    Return Value:

        TRUE iff the MEMORY in this machine at the specified address
        contains the specified data.

--*/

{
    LOGICAL             match = FALSE;
    PCHAR               segment;
    PCHAR               offset;
    CHAR                data[MAX_DESCRIPTION_LEN + 1];
    ULONG               cbData;
    PVOID               baseAddress;
    PCHAR               address;
    ULONG               memory;

    //
    // Read in the segment and offset of the address specified.
    //

    segment = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    offset = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);

    if (segment && offset)
    {
        //
        // Get the data specified in the inf.
        //

        cbData = sizeof(data);
        if (CmpGetInfData(InfHandle, Description, RuleIndex, 2, data, &cbData))
        {
            memory = (strtoul(segment, NULL, 16) << 4) + strtoul(offset, NULL, 16);

            //
            // Map in the physical address.
            //

            address = CmpMapPhysicalAddress(&baseAddress, memory, cbData);
            if (address)
            {

                //
                // Check if the inf data matches data in memory.
                //

                match = (RtlCompareMemory(address, data, cbData) == cbData);

                //
                // Unmap the physical address.
                //

                ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
            }
        }
    }

    return (match);
}

LOGICAL
CmpMatchSearchRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )

/*++

    Routine Description:

        This routine checks to see if the machine matches the SEARCH rule.

        Syntax -

        SEARCH=segment,offset,length,type,data
            where type ["S", "B"]

        Examples -

        search=f000,e000,7f,S,"SurePath"
            is TRUE if the string "SurePath" is somewhere in memory range
            F000:E000 to F000:E07F (inclusive).

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Description - Name of the section containing the rule info.

        RuleIndex - Line number for the rule in the description section.

    Return Value:

        TRUE iff the specified pattern is found within the specified address
        range.

--*/

{
    LOGICAL match = FALSE;
    PCHAR   segment;
    PCHAR   offset;
    PCHAR   size;
    CHAR    data[MAX_DESCRIPTION_LEN + 1];
    ULONG   cbData;
    ULONG   memory;
    ULONG   length;
    PVOID   baseAddress;
    PCHAR   address;

    segment = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    offset = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);
    size = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 2);

    if (segment && offset && size)
    {
        //
        // Get the data specified in the inf.
        //

        cbData = sizeof(data);
        if (CmpGetInfData(InfHandle, Description, RuleIndex, 3, data, &cbData))
        {
            memory = (strtoul(segment, NULL, 16) << 4) + strtoul(offset, NULL, 16);

            //
            // Map in the physical address.
            //

            length = strtoul(size, NULL, 16);
            address = CmpMapPhysicalAddress(&baseAddress, memory, length);
            if (address)
            {
                gSearchAddress = CmpFindPattern(address, length, data, cbData, FALSE, 0);
                if (gSearchAddress)
                {
                    //
                    // If we found the pattern, compute the actual address for it.
                    //

                    gSearchAddress = (PVOID)((PCHAR)gSearchAddress - address);
                    gSearchAddress = (PVOID)((PCHAR)gSearchAddress + memory);
                    match = TRUE;
                }

                //
                // Unmap the physical address.
                //

                ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
            }
        }
    }

    return (match);
}

LOGICAL
CmpMatchNextMatchRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )

/*++

    Routine Description:

        This routine checks to see if the machine matches the NEXTMATCH rule.

        Syntax -

        NEXTMATCH=offset,type,data
            where type ["S", "B"]

        Examples -

        nextmatch=f0,S,"Atlanta"
            is TRUE if the string "Atlanta" is at offset 0xF0 from the previous
            successful SEARCH or NEXTMATCH rule.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Description - Name of the section containing the rule info.

        RuleIndex - Line number for the rule in the description section.

    Return Value:

        TRUE iff the specified pattern is found at the specified offset
        from the previous successful SEARCH or NEXTMATCH.

--*/

{
    LOGICAL match = FALSE;
    PCHAR   offset;
    CHAR    data[MAX_DESCRIPTION_LEN + 1];
    ULONG   cbData;
    PVOID   baseAddress;
    PCHAR   address;

    if (gSearchAddress)
    {
        offset = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
        if (offset)
        {
            //
            // Get the data specified in the inf.
            //

            cbData = sizeof(data);

            if (CmpGetInfData(InfHandle, Description, RuleIndex, 1, data, &cbData))
            {
                gSearchAddress = (PVOID)((PCHAR)gSearchAddress + strtoul(offset, NULL, 16));

                //
                // Map in the physical address.
                //

                address = CmpMapPhysicalAddress(&baseAddress, (ULONG_PTR)gSearchAddress, cbData);
                if (address)
                {

                    //
                    // Check if the inf data matches data in memory.
                    //

                    match = (RtlCompareMemory(address, data, cbData) == cbData);

                    //
                    // Unmap the physical address.
                    //

                    ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                }
            }
        }
    }

    return (match);
}

LOGICAL
CmpMatchPointerRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    LOGICAL match = FALSE;
    PCHAR   segment1;
    PCHAR   offset1;
    PCHAR   segment2;
    PCHAR   offset2;
    PCHAR   index;
    PCHAR   op;
    CHAR    data[MAX_DESCRIPTION_LEN + 1];
    ULONG   cbData;
    ULONG   memory;
    ULONG   pointer;
    PVOID   baseAddress;
    PCHAR   address;

    segment1 = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    offset1 = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);
    segment2 = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 2);
    offset2 = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 3);
    index = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 4);
    op = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 5);

    if (    segment1 && offset1 &&
            segment2 && offset2 &&
            index && op)
    {
        //
        // Get the data specified in the inf.
        //

        cbData = sizeof(data);

        if (CmpGetInfData(InfHandle, Description, RuleIndex, 6, data, &cbData))
        {
            if (strlen(offset2) == 0)
            {
                memory = strtoul(segment2, NULL, 16) << 4;
            }
            else
            {
                memory = (strtoul(segment2, NULL, 16) << 4) + strtoul(offset2, NULL, 16);
            }

            address = CmpMapPhysicalAddress(&baseAddress, memory, 4);
            if (address)
            {
                pointer = *((PUSHORT)address);

                //
                // Unmap the physical address.
                //

                ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);

                if (strlen(offset1) == 0)
                {
                    memory = (strtoul(segment1, NULL, 16) << 4) + pointer;
                }
                else
                {
                    memory = (strtoul(segment1, NULL, 16) << 4) + strtoul(offset1, NULL, 16);
                    address = CmpMapPhysicalAddress(&baseAddress, memory, 2);
                    if (address)
                    {
                        memory = ((*(PUSHORT)address) << 4) + pointer;

                        //
                        // Unmap the physical address.
                        //

                        ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                    }
                }

                memory += strtoul(index, NULL, 16);

                //
                // Map in the physical address.
                //

                address = CmpMapPhysicalAddress(&baseAddress, memory, cbData);
                if (address)
                {
                    match = CmpCheckOperator(op, (ULONG)RtlCompareMemory(address, data, cbData), cbData);

                    //
                    // Unmap the physical address.
                    //

                    ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                }
            }
        }
    }

    return (match);
}

LOGICAL
CmpMatchOemIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    LOGICAL         match = FALSE;
    ULONG           address;
    PCHAR           op;
    PCHAR           oemIdStr;
    ULONG           oemId;
    PCHAR           baseAddress;
    PPNP_BIOS_TABLE biosTable;

    //
    // Search for the PnPBIOS structure in the BIOS ROM.
    //

    address = CmpGetPnPBIOSTableAddress();

    //
    // Proceed if we found the PnP BIOS structure.
    //

    if (address)
    {
        op = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
        oemIdStr = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 1);
        if (op && oemIdStr)
        {

            if (    strlen(oemIdStr) == 7 &&
                    isalpha(oemIdStr[0]) &&
                    isalpha(oemIdStr[1]) &&
                    isalpha(oemIdStr[2]) &&
                    isxdigit(oemIdStr[3]) &&
                    isxdigit(oemIdStr[4]) &&
                    isxdigit(oemIdStr[5]) &&
                    isxdigit(oemIdStr[6]))
            {

                biosTable = (PPNP_BIOS_TABLE)CmpMapPhysicalAddress(&baseAddress, address, sizeof(PNP_BIOS_TABLE));
                if (biosTable)
                {
                    oemId = ((ULONG)(oemIdStr[0] & 0x1F) << 26) +
                            ((ULONG)(oemIdStr[1] & 0x1F) << 21) +
                            ((ULONG)(oemIdStr[2] & 0x1F) << 16) +
                            strtoul(&oemIdStr[3], NULL, 16);

                    //
                    // We only support EQUAL and NOT EQUAL operators.
                    //

                    if (strcmp(op, "=") == 0 || strcmp(op, "==") == 0)
                    {
                        match = (oemId == biosTable->Oem);
                    }
                    else if(    strcmp(op, "<>") == 0 ||
                                strcmp(op, "!=") == 0 ||
                                strcmp(op, "=!") == 0)
                    {
                        match = (oemId != biosTable->Oem);
                    }

                    //
                    // Unmap the physical address.
                    //

                    ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                }
            }
        }
    }

    return (match);
}

LOGICAL
CmpMatchPModeRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    LOGICAL         match = FALSE;
    ULONG           address;
    CHAR            data[MAX_DESCRIPTION_LEN + 1];
    ULONG           cbData;
    PVOID           baseAddress;
    PPNP_BIOS_TABLE biosTable;
    ULONG           pmAddress;
    PCHAR           pmodeEntry;

    //
    // Search for the PnPBIOS structure in the BIOS ROM.
    //

    address = CmpGetPnPBIOSTableAddress();

    //
    // Proceed if we found the PnP BIOS structure.
    //

    if (address)
    {
        //
        // Get the data specified in the inf.
        //

        cbData = sizeof(data);
        if (CmpGetInfData(InfHandle, Description, RuleIndex, 0, data, &cbData))
        {
            biosTable = (PPNP_BIOS_TABLE)CmpMapPhysicalAddress(&baseAddress, address, sizeof(PNP_BIOS_TABLE));
            if (biosTable)
            {
                pmAddress = (biosTable->PMSegment << 4) + biosTable->PMOffset;

                //
                // Unmap the physical address.
                //

                ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);

                pmodeEntry = CmpMapPhysicalAddress(&baseAddress, pmAddress, SYSTEM_BIOS_LENGTH);
                if (pmodeEntry)
                {
                    if (*pmodeEntry == 0xE9)
                    {
                        pmodeEntry += (3 + (*((PUSHORT)&pmodeEntry[1])));
                    }

                    match = (RtlCompareMemory(pmodeEntry, data, cbData) == cbData);

                    //
                    // Unmap the physical address.
                    //

                    ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
                }
            }
        }
    }

    return (match);
}

LOGICAL
CmpMatchRmPmSameRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    LOGICAL match = FALSE;
    ULONG           address;
    PCHAR           baseAddress;
    PPNP_BIOS_TABLE biosTable;

    UNREFERENCED_PARAMETER (InfHandle);
    UNREFERENCED_PARAMETER (Description);
    UNREFERENCED_PARAMETER (RuleIndex);

    //
    // Search for the PnPBIOS structure in the BIOS ROM.
    //

    address = CmpGetPnPBIOSTableAddress();

    //
    // Proceed if we found the PnP BIOS structure.
    //

    if (address)
    {
        biosTable = CmpMapPhysicalAddress(&baseAddress, address, sizeof(PNP_BIOS_TABLE));
        if (biosTable)
        {
            match = (   biosTable->RMSegment == biosTable->PMSegment &&
                        biosTable->RMOffset == biosTable->PMOffset);

            //
            // Unmap the physical address.
            //

            ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
        }
    }

    return (match);
}

LOGICAL
CmpMatchInstallRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
{
    BOOLEAN match = FALSE;
    PCHAR   install;

    install = CmpGetSectionLineIndex(InfHandle, Description, RuleIndex, 0);
    if (install)
    {
        if (CmpGenInstall(InfHandle, install))
        {
            //
            // Successfully installed the specified section.
            //

            match = TRUE;
        }
    }

    return (match);
}

LOGICAL
CmpMatchAcpiOemIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI OEM ID rule from an INF file

    Examples:

        AcpiOemId="RSDT", "123456"

    is true if the RSDT has the OEM ID of 123456.

        AcpiOemId="DSDT", "768000"

    is true if the DSDT has the OEM ID of 768000.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    BOOLEAN             anyCase = FALSE;
    BOOLEAN             match = FALSE;
    PCHAR               tableName;
    PCHAR               oemId;
    PCHAR               optionalArgs;
    ULONG               length;
    PDESCRIPTION_HEADER header;
    CHAR                tableOemId[7];
    STRING              acpiString;
    STRING              tableString;

    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    oemId = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    if (tableName && oemId) {

        //
        // See if we have to do a case insensitive match
        //
        optionalArgs = CmpGetSectionLineIndex(
            InfHandle,
            Description,
            RuleIndex,
            2
            );
        if (optionalArgs) {

            if (_stricmp(optionalArgs,"any") == 0) {

                anyCase = TRUE;

            }

        }

        //
        // Find the specified table in the BIOS ROM.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            //
            // Build the OEM id from the table
            //
            RtlZeroMemory(tableOemId, sizeof(tableOemId));
            RtlCopyMemory(tableOemId, header->OEMID, sizeof(header->OEMID));
            RtlInitString( &tableString, tableOemId );

            //
            // And one from the string in the file
            //
            RtlInitString( &acpiString, oemId );

            //
            // Now see if they are equal
            //
            match = RtlEqualString( &acpiString, &tableString, anyCase );

            //
            // Unmap the table
            //
            MmUnmapIoSpace(header, length );

        }

    }
    return (match);
}

LOGICAL
CmpMatchAcpiOemTableIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI OEM Table ID rule from an INF file.

    Examples:

    AcpiOemTableId="RSDT", "12345678"

        is true if the RSDT has the Oem Table ID of 12345678.

    AcpiOemTableId="DSDT", "87654321"

        is true if the DSDT has the Oem Table ID of 87654321.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM Table ID.

    FALSE - the computer does not have the specified ACPI OEM Table ID.

--*/

{
    LOGICAL             match = FALSE;
    PCHAR               tableName;
    PCHAR               oemTableId;
    ULONG               length;
    PDESCRIPTION_HEADER header;
    SIZE_T              idLength;
    CHAR                acpiOemTableId[8];

    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    oemTableId = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    if (tableName && oemTableId) {

        //
        // Find the specified table in the BIOS ROM.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            RtlZeroMemory(acpiOemTableId, sizeof(acpiOemTableId));
            idLength = strlen(oemTableId);
            if (idLength > sizeof(acpiOemTableId)) {

                idLength = sizeof(acpiOemTableId);

            }
            RtlCopyMemory(acpiOemTableId, oemTableId, idLength);
            match = RtlEqualMemory(acpiOemTableId, header->OEMTableID, sizeof(header->OEMTableID));
            MmUnmapIoSpace( header, length );

        }

    }
    return (match);
}

LOGICAL
CmpMatchAcpiOemRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI Oem Revision rule from an INF file.

    Examples:

    AcpiOemRevision="=","RSDT", 1234

        is true if the RSDT has the Oem Revision EQUAL to 1234.

    AcpiOemRevision=">","DSDT", 4321

        is true if the DSDT has the Oem Revision GREATER than 4321.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI Oem Revision.

    FALSE - the computer does not have the specified ACPI Oem Revision.

--*/

{
    LOGICAL             match = FALSE;
    PCHAR               op;
    PCHAR               tableName;
    PCHAR               oemRevisionStr;
    ULONG               oemRevision;
    ULONG               length;
    PDESCRIPTION_HEADER header;

    op = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    oemRevisionStr = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        2
        );
    if (op && tableName && oemRevisionStr) {

        //
        // Find the specified table.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            RtlCharToInteger(oemRevisionStr, 16, &oemRevision);
            match = CmpCheckOperator(op, header->OEMRevision, oemRevision);
            MmUnmapIoSpace(header, length);

        }

    }
    return(match);

}

LOGICAL
CmpMatchAcpiRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI Revision rule from an INF file.

    Examples:

        AcpiRevision="=", "RSDT", 1234

    is true if the RSDT ACPI Revision is EQUAL to 1234.

        AcpiRevision=">", "DSDT", 4321

    is true if the DSDT ACPI Revision is GREATER than 4321.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI Revision.

    FALSE - the computer does not have the specified ACPI Revision.

--*/

{
    LOGICAL             match = FALSE;
    PCHAR               op;
    PCHAR               tableName;
    PCHAR               revisionStr;
    ULONG               revision;
    ULONG               length;
    PDESCRIPTION_HEADER header;

    op = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    revisionStr = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        2
        );
    if (op && tableName && revisionStr){

        //
        // Find the specified table.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            RtlCharToInteger(revisionStr, 16, &revision);
            match = CmpCheckOperator(op, header->Revision, revision);
            MmUnmapIoSpace(header, length);

        }

    }
    return(match);

}

LOGICAL
CmpMatchAcpiCreatorRevisionRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI Creator Revision rule from an INF file.

    Examples:

        AcpiCreatorRevision="=", "RSDT", 1234

    is true if the RSDT ACPI Creator Revision is EQUAL to 1234.

        AcpiCreatorRevision=">", "DSDT", 4321

    is true if the DSDT ACPI Creator Revision is GREATER than 4321.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI Creator Revision.

    FALSE - the computer does not have the specified ACPI Creator Revision.

--*/

{
    LOGICAL             match = FALSE;
    PCHAR               op;
    PCHAR               tableName;
    PCHAR               creatorRevisionStr;
    ULONG               creatorRevision;
    ULONG               length;
    PDESCRIPTION_HEADER header;

    op = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    creatorRevisionStr = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        2
        );
    if (op && tableName && creatorRevisionStr) {

        //
        // Find the specified table.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header){

            RtlCharToInteger(creatorRevisionStr, 16, &creatorRevision);
            match = CmpCheckOperator(op, header->CreatorRev, creatorRevision);
            MmUnmapIoSpace( header, length );

        }

    }
    return(match);
}

LOGICAL
CmpMatchAcpiCreatorIdRule(
    IN PVOID InfHandle,
    IN PCHAR Description,
    IN ULONG RuleIndex
    )
/*++

Routine Description:

    This function processes a ACPI Creator ID rule from an INF file.

    Examples:

        AcpiCreatorId="RSDT", "MSFT"

    is true if the RSDT has the Creator ID of MSFT.

Arguments:

    InfHandle - Handle of the inf containing the rule.

    Description - Specifies the section name the rule is in

    RuleIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI Creator ID.

    FALSE - the computer does not have the specified ACPI Creator ID.

--*/

{
    LOGICAL             match = FALSE;
    PCHAR               tableName;
    PCHAR               creatorId;
    ULONG               length;
    PDESCRIPTION_HEADER header;
    SIZE_T              idLength;
    CHAR                acpiCreatorId[6];

    tableName = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        0
        );
    creatorId = CmpGetSectionLineIndex(
        InfHandle,
        Description,
        RuleIndex,
        1
        );
    if (tableName && creatorId) {

        //
        // Find the specified table.
        //
        header = CmpFindACPITable(*(PULONG)tableName, &length);
        if (header) {

            RtlZeroMemory(acpiCreatorId, sizeof(acpiCreatorId));
            idLength = strlen(creatorId);
            if (idLength > sizeof(acpiCreatorId)) {

                idLength = sizeof(acpiCreatorId);

            }
            RtlCopyMemory(acpiCreatorId, creatorId, idLength);
            match = RtlEqualMemory(acpiCreatorId, header->CreatorID, sizeof(header->CreatorID));
            MmUnmapIoSpace( header, length );

        }

    }
    return(match);
}

BOOLEAN
CmpGetInfData(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PCHAR Buffer,
    IN OUT PULONG BufferSize
    )

/*++

    Routine Description:

        This routine reads and parses data from the inf. It understands
        two kinds of data 1. String 2. Binary.

        Examples-

        B,02 - byte 0x02
        B,72,0D,FF,0F - sequence of bytes 0x72 0x0D 0xFF 0x0F or the DWORD 0x0FFF0D72
        S,COMPAQ - ASCII string "COMPAQ"

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Section name to be read.

        LineIndex - Index of the line in the Section to be read.

        ValueIndex - First value to be read on the LineIndex.

        Buffer - Parsed data gets returned in this buffer.

        BufferSize - On entry, contains the size of Buffer.
        The number of bytes parsed in gets returned in this
        variable.

    Return Value:

        TRUE iff data was parsed in successfully. Else FALSE.

--*/

{
    BOOLEAN result = FALSE;
    ULONG   cbData;
    PCHAR   data;
    ULONG   remainingBytes;

    //
    // Validate input parameters.
    //

    if (Buffer && BufferSize && *BufferSize)
    {
        //
        // Read in the data type "S" or "B".
        //

        PCHAR type = CmpGetSectionLineIndex(InfHandle, Section, LineIndex, ValueIndex++);
        if (type)
        {
            //
            // Initialize local data.
            //

            remainingBytes = *BufferSize;

            //
            // Process Binary data.
            //

            if (_stricmp(type, "B") == 0)
            {

                //
                // Parse data as long as there is more data and the buffer is not full.
                //

                for (result = TRUE; result == TRUE && remainingBytes; remainingBytes--)
                {
                    CHAR    value;

                    //
                    // Read in the data.
                    //

                    data = CmpGetSectionLineIndex(InfHandle, Section, LineIndex, ValueIndex++);
                    if (data)
                    {
                        //
                        // Convert the data read in and validate that is indeed a HEX value.
                        //

                        value = (CHAR)strtoul(data, NULL, 16);
                        if (value == 0 && strcmp(data, "00") && strcmp(data, "0"))
                        {
                            result = FALSE;
                        }
                        else
                        {
                            *Buffer++ = value;
                        }
                    }
                    else
                    {
                        break;
                    }
                }

                //
                // Return the number of bytes parsed in.
                //

                *BufferSize -= remainingBytes;
            }

            //
            // Process String data.
            //

            else if(_stricmp(type, "S") == 0)
            {
                //
                // Read in the string.
                //

                data = CmpGetSectionLineIndex(InfHandle, Section, LineIndex, ValueIndex);

                //
                // Only copy as much data as the buffer can hold.
                //
                cbData = (ULONG)strlen(data);
                cbData = (ULONG) min(remainingBytes, cbData);
                RtlCopyBytes(Buffer, data, cbData);

                //
                // Return the number of bytes actually copied.
                //

                *BufferSize = cbData;
                result = TRUE;
            }
        }
    }

    return (result);
}

PVOID
CmpMapPhysicalAddress(
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR Address,
    IN ULONG Size
    )

/*++

    Routine Description:

        This routine maps the specified physical segment into the process
        virtual memory.

    Input Parameters:

        Segment - Segment to be mapped.

        Size - Segment size to be mapped.

    Return Value:

        Virtual address for the mapped segment.

--*/

{
    UNICODE_STRING      sectionName;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              sectionHandle;
    NTSTATUS            status;
    PVOID               baseAddress;
    SIZE_T              viewSize;
    LARGE_INTEGER       viewBase;
    PVOID               ptr = NULL;

    *BaseAddress = NULL;

    RtlInitUnicodeString(&sectionName, L"\\Device\\PhysicalMemory");
    InitializeObjectAttributes( &objectAttributes,
                                &sectionName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                (PSECURITY_DESCRIPTOR)NULL);
    status = ZwOpenSection( &sectionHandle,
                            SECTION_MAP_READ,
                            &objectAttributes);
    if (NT_SUCCESS(status))
    {
        baseAddress = NULL;
        viewSize = Size;
        viewBase.QuadPart = Address & ~(0xFFF);
        status = ZwMapViewOfSection(    sectionHandle,
                                        NtCurrentProcess(),
                                        &baseAddress,
                                        0,
                                        viewSize,
                                        &viewBase,
                                        &viewSize,
                                        ViewUnmap,
                                        MEM_DOS_LIM,
                                        PAGE_READWRITE);
        if (NT_SUCCESS(status))
        {
            ptr = (PVOID)((PCHAR)baseAddress + (Address & 0xFFF));
            *BaseAddress = baseAddress;
        }
    }

    return (ptr);
}

LOGICAL
CmpCheckOperator(
    IN PCHAR Operator,
    IN ULONG Lhs,
    IN ULONG Rhs
    )

/*++

    Routine Description:

        This routine tests condition specified by the operator by
        applying it to the specified LHS and RHS arguments.

    Input Parameters:

        Operator - Is the operator to be tested.

        Lhs - Left Hand Side argument for the Operator.

        Rhs - Right Hand Side argument for the Operator.

    Return Value:

        True iff the condition Lhs Operator Rhs is satisfied.

--*/

{
    LOGICAL result = FALSE;

    //
    // We are pretty lenient about which operators we support.
    //

    //
    // "=" or "==" for EQUAL.
    //

    if (strcmp(Operator, "=") == 0 || strcmp(Operator, "==") == 0)
    {
        result = (Lhs == Rhs);
    }

    //
    // "!=" or "=!" or "<>" for NOT EQUAL.
    //

    else if(    strcmp(Operator, "!=") == 0 ||
                strcmp(Operator, "<>") == 0 ||
                strcmp(Operator, "=!") == 0)
    {
        result = (Lhs != Rhs);
    }

    //
    // "<" for LESS THAN.
    //

    else if(strcmp(Operator, "<") == 0)
    {
        result = (Lhs < Rhs);
    }

    //
    // "<=" or "=<" for LESS THAN or EQUAL.
    //

    else if(strcmp(Operator, "<=") == 0 || strcmp(Operator, "=<") == 0)
    {
        result = (Lhs <= Rhs);
    }

    //
    // ">" for GREATER THAN.
    //

    else if(strcmp(Operator, ">") == 0)
    {
        result = (Lhs > Rhs);
    }

    //
    // ">=" or "=>" for GREATER THAN or EQUAL.
    //

    else if(strcmp(Operator, ">=") == 0 || strcmp(Operator, "=>") == 0)
    {
        result = (Lhs >= Rhs);
    }
    else
    {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Invalid operator %s used!\n", Operator);
#endif //_CM_LDR_
    }

    return (result);
}

PVOID
CmpFindPattern(
    IN PCHAR Buffer,
    IN ULONG BufSize,
    IN PCHAR Pattern,
    IN ULONG PatSize,
    IN BOOLEAN IgnoreCase,
    IN ULONG Step
    )

/*++

    Routine Description:

        This routine searches the buffer for the specified pattern of data.

    Input Parameters:

        Buffer - Buffer to be searched.

        BufSize - Size of this buffer.

        Pattern - Pattern to be searched.

        PatSize - Size of the pattern.

        IgnoreCase - TRUE if the search is to be case insensitive.

    Return Value:

        Returns the pointer into the buffer where the pattern is first found.

--*/

{
    PCHAR   bufEnd;

    if (PatSize > BufSize)
    {
        return (NULL);
    }

    if (PatSize == 0)
    {
        PatSize = (ULONG) strlen(Pattern);
    }

    if (Step == 0)
    {
        Step = 1;
    }

    for (   bufEnd = Buffer + BufSize;
            Buffer + PatSize < bufEnd;
            Buffer += Step)
    {
        if (IgnoreCase)
        {
            if (_strnicmp(Buffer, Pattern, PatSize) == 0)
            {
                return (Buffer);
            }
        }
        else
        {
            if (strncmp(Buffer, Pattern, PatSize) == 0)
            {
                return (Buffer);
            }
        }
    }

    return (NULL);
 }

 ULONG
 CmpGetPnPBIOSTableAddress(
    VOID
    )

/*++

    Routine Description:

        This routine searches the BIOS ROM for the PnP BIOS installation
        structure.

    Input Parameters:

        None.

    Return Value:

        Returns the physical address in the ROM BIOS where the PnP
        BIOS structure is located.

--*/

{
    static ULONG    tableAddress = (ULONG)-1;
    PVOID           baseAddress;
    PPNP_BIOS_TABLE address;
    PPNP_BIOS_TABLE lastAddress;
    ULONG           i;
    ULONG           checksum;

    if (tableAddress == (ULONG)-1)
    {
        //
        // Search for the PnPBIOS structure in the BIOS ROM.
        //

        address = (PPNP_BIOS_TABLE)CmpMapPhysicalAddress(&baseAddress, 0xF0000, SYSTEM_BIOS_LENGTH);
        if (address)
        {
            for (   lastAddress = (PPNP_BIOS_TABLE)((PCHAR)address + SYSTEM_BIOS_LENGTH - 0x10);
                    address < lastAddress;
                    address = (PPNP_BIOS_TABLE)((PCHAR)address + 0x10))
            {
                if (address->Signature == PNPBIOS_SIGNATURE)
                {
                    for (   i = 0, checksum = 0;
                            i < address->Length;
                            i++)
                    {
                        checksum += ((PUCHAR)address)[i];
                    }

                    if (    (checksum & 0xFF) == 0 &&
                            address->Length >= 0x21)
                    {
                        tableAddress = 0xF0000 + (SYSTEM_BIOS_LENGTH - 10) - (ULONG)((PCHAR)lastAddress - (PCHAR)address);
                        break;
                    }
                }
            }

            //
            // Unmap the physical address.
            //

            ZwUnmapViewOfSection(NtCurrentProcess(), baseAddress);
        }
    }

    return (tableAddress);
}

PDESCRIPTION_HEADER
CmpFindACPITable(
    IN ULONG        Signature,
    IN OUT PULONG   Length
    )
{
    static PHYSICAL_ADDRESS rsdtAddress = { (ULONG)-1, (ULONG)-1 };
    PDESCRIPTION_HEADER     header;
    PDESCRIPTION_HEADER     rsdtHeader;
    ULONG                   length;
    NTSTATUS                status;
    PACPI_BIOS_MULTI_NODE   rsdpMulti;
    PFADT                   fadt;
    PHYSICAL_ADDRESS        dsdtAddress;
    PHYSICAL_ADDRESS        tableAddress;
    PRSDT                   rsdt;
    ULONG                   rsdtLength;
    ULONG                   i;
    ULONG                   num;

    length = 0;
    header = NULL;
    rsdtHeader = NULL;

    //
    // Use the cached location of RSDT address if available.
    //
    if (rsdtAddress.QuadPart == -1) {

        rsdtAddress.QuadPart = 0;
        //
        // Get the multinode
        //
        status = CmpFindRSDTTable(&rsdpMulti);
        if (!NT_SUCCESS(status)) {

            goto exit;
        }

        //
        // Map the address
        //
        rsdtAddress.LowPart = rsdpMulti->RsdtAddress.LowPart;
        rsdtAddress.HighPart = rsdpMulti->RsdtAddress.HighPart;

        //
        // Done with the multinode
        //
        ExFreePool(rsdpMulti);
    }

    //
    // If we dont have an address, system probably does not have an ACPI BIOS.
    //
    if (rsdtAddress.QuadPart == 0) {

        goto exit;
    }

    //
    // Map in the the rsdt table
    //
    rsdtHeader = MmMapIoSpace(
                    rsdtAddress,
                    sizeof(DESCRIPTION_HEADER),
                    MmNonCached
                    );
    if (rsdtHeader == NULL) {

#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFindACPITable: Cannot map RSDT at %I64x\n", rsdtAddress.QuadPart);
#endif //_CM_LDR_

        goto exit;
    }

    //
    // If what we are looking for is the RSDT, then we are done
    //
    if (Signature == RSDT_SIGNATURE) {

        header = rsdtHeader;
        length = sizeof(DESCRIPTION_HEADER);
        //
        // We want to leave this mapped, caller wil unmap.
        //
        rsdtHeader = NULL;
        goto exit;
    } 

    if (Signature == DSDT_SIGNATURE) {

        fadt = (PFADT)CmpFindACPITable(FADT_SIGNATURE, &length);
        if (!fadt) {

#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"CmpFindACPITable: Cannot find FADT\n");
#endif //_CM_LDR_

            goto exit;
        }

        dsdtAddress.HighPart = 0;
        dsdtAddress.LowPart = fadt->dsdt;

        //
        // Done with the FADT
        //
        MmUnmapIoSpace(fadt, length);

        //
        // Map in the dsdt table
        //
        header = MmMapIoSpace(
                    dsdtAddress,
                    sizeof(DESCRIPTION_HEADER),
                    MmNonCached
                    );
        if (header) {

            length = sizeof(DESCRIPTION_HEADER);
        } else {

#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,
                "CmpFindACPITable: Cannot map DSDT at %I64x\n",
                dsdtAddress.QuadPart
                );
#endif //_CM_LDR_
        }

        goto exit;
    }

    //
    // Map in the entire RSDT
    //
    rsdtLength = rsdtHeader->Length;
    rsdt = (PRSDT)MmMapIoSpace(rsdtAddress, rsdtLength, MmNonCached);
    if (rsdt == NULL) {

#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,
            "CmpFindACPITable: Cannot map RSDT at %I64x\n",
            rsdtAddress.QuadPart
            );
#endif //_CM_LDR_

        goto exit;
    }

    //
    // Look at all the table entries for the header that we care about
    //
    num = TABLE_ENTRIES_FROM_RSDT_POINTER(rsdt);
    for (i = 0; i < num ; i ++) {

        //
        // Get the address of the table
        //
        tableAddress.HighPart = 0;
        tableAddress.LowPart = rsdt->Tables[i];

        //
        // Map in the header
        //
        header = MmMapIoSpace(
                    tableAddress,
                    sizeof(DESCRIPTION_HEADER),
                    MmNonCached
                    );
        if (!header) {

#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,
                "CmpFindACPITable: Cannot map header at %I64x\n",
                tableAddress.QuadPart
                );
#endif //_CM_LDR_

            break;
        }

        //
        // Signature check
        //
        if (header->Signature == Signature) {

            //
            // Are we looking at the FADT?
            //
            if (Signature == FADT_SIGNATURE) {

                length = header->Length;
                //
                // Unmap the old table
                //
                MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));

                //
                // Map the entire table for this one
                //
                header = MmMapIoSpace(tableAddress, length, MmNonCached);


                //
                // Did we successfully map the header?
                //
                if (header == NULL ) {

    #ifndef _CM_LDR_
                    DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,
                        "CmpFindACPITable: Cannot map FADT at %I64x\n",
                        tableAddress.QuadPart
                        );
    #endif //_CM_LDR_    
                }

            } else {

                //
                // Remember where the table and length are stored
                //
                length = sizeof(DESCRIPTION_HEADER);
            }

            break;
        }

        MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
        header = NULL;

    } // for

    //
    // Done with the rsdt.
    //
    MmUnmapIoSpace(rsdt, rsdtLength);

exit:

    //
    // Cleanup.
    //

    if (rsdtHeader) {

        MmUnmapIoSpace(rsdtHeader, sizeof(DESCRIPTION_HEADER));
    }

    //
    // If we found the table, return its length.
    //
    if (Length) {

        if (header) {

            *Length = length;

        } else {

            *Length = 0;

        }
    }

    return header;
}

NTSTATUS
CmpFindRSDTTable(
    OUT PACPI_BIOS_MULTI_NODE   *Rsdt
    )
/*++

Routine Description:

    This function looks into the registry to find the ACPI RSDT,
    which was stored there by ntdetect.com

Arguments:

    RsdtPtr - Pointer to a buffer that contains the ACPI
              Root System Description Pointer Structure.
              The caller is responsible for freeing this
              buffer.  Note:  This is returned in non-paged
              pool.

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    BOOLEAN                         same;
    HANDLE                          hMFunc;
    HANDLE                          hBus;
    NTSTATUS                        status;
    OBJECT_ATTRIBUTES               objectAttributes;
    PACPI_BIOS_MULTI_NODE           multiNode;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PCM_PARTIAL_RESOURCE_LIST       prl;
    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo;
    PWSTR                           p;
    ULONG                           i;
    ULONG                           length;
    ULONG                           multiNodeSize;
    UNICODE_STRING                  unicodeString;
    UNICODE_STRING                  unicodeValueName;
    UNICODE_STRING                  biosId;
    WCHAR                           wbuffer[10];

    PAGED_CODE();

    //
    // Look in the registry for the "ACPI BIOS bus" data
    //
    RtlInitUnicodeString( &unicodeString, rgzMultiFunctionAdapter );
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );
    status = ZwOpenKey( &hMFunc, KEY_READ, &objectAttributes );
    if (!NT_SUCCESS(status)) {

#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_WARNING_LEVEL,"CmpFindRSDTTable: Cannot open MultifunctionAdapter registry key.\n");
#endif //_CM_LDR_
        return status;

    }

    //
    // We will need to make a unicode string that we can use to enumerate
    // the subkeys of the MFA key
    //
    unicodeString.Buffer = wbuffer;
    unicodeString.MaximumLength = sizeof(wbuffer);
    RtlInitUnicodeString( &biosId, rgzBIOSIdentifier );

    //
    // Loop over all subkeys
    //
    for (i = 0; TRUE; i++) {

        //
        // Turn the number into a key name
        //
        RtlIntegerToUnicodeString( i, 10, &unicodeString);
        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL
            );

        //
        // Open the named subkey
        //
        status = ZwOpenKey( &hBus, KEY_READ, &objectAttributes );
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //
#ifndef _CM_LDR_
            DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_WARNING_LEVEL,"CmpFindRSDTTable: ACPI BIOS MultifunctionAdapter registry key not found.\n");
#endif //_CM_LDR_
            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;

        }

        //
        // Check the Indentifier to see if this is an ACPI BIOS entry
        //
        status = CmpGetRegistryValue( hBus, (PWCHAR)rgzAcpiIdentifier, &valueInfo );
        if (!NT_SUCCESS (status)) {

            ZwClose( hBus );
            continue;

        }

        p = (PWSTR) ((PUCHAR) valueInfo->Data);
        unicodeValueName.Buffer = p;
        unicodeValueName.MaximumLength = (USHORT)valueInfo->DataLength;
        length = valueInfo->DataLength;

        //
        // Determine the real length of the ID string
        //
        while (length) {

            if (p[length / sizeof(WCHAR) - 1] == UNICODE_NULL) {

                length -= 2;

            } else {

                break;
            }

        }

        //
        // Do we have a match the "ACPI BIOS" identifier?
        //
        unicodeValueName.Length = (USHORT)length;
        same = RtlEqualUnicodeString( &biosId, &unicodeValueName, TRUE );
        ExFreePool( valueInfo );
        if (!same) {

            ZwClose( hBus );
            continue;

        }

        //
        // We do, so get the configuration data
        //
        status = CmpGetRegistryValue(
            hBus,
            (PWCHAR)rgzAcpiConfigurationData,
            &valueInfo
            );
        ZwClose( hBus );
        if (!NT_SUCCESS(status)) {

            continue ;

        }

        //
        // The data that we want is at the end of the PARTIAL_RESOURCE_LIST
        // descriptor
        //
        prl = (PCM_PARTIAL_RESOURCE_LIST)(valueInfo->Data);
        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)
            ( (PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST) );
        break;

    }

    //
    // Calculate the size of the data so that we can make a copy
    //
    multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
        ( (ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY) );
    *Rsdt = (PACPI_BIOS_MULTI_NODE) ExAllocatePoolWithTag(
        NonPagedPool,
        multiNodeSize,
        'IPCA'
        );
    if (*Rsdt == NULL) {

        ExFreePool( valueInfo );
        return STATUS_INSUFFICIENT_RESOURCES;

    }
    RtlCopyMemory(*Rsdt, multiNode, multiNodeSize);

    //
    // Done with the key memory
    //
    ExFreePool(valueInfo);

    //
    // Done
    //
    return STATUS_SUCCESS;
}

NTSTATUS
CmpGetRegistryValue(
    IN  HANDLE                          KeyHandle,
    IN  PWSTR                           ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION  *Information
    )
/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    NTSTATUS                        status;
    PKEY_VALUE_PARTIAL_INFORMATION  infoBuffer;
    ULONG                           keyValueLength;
    UNICODE_STRING                  unicodeString;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //
    status = ZwQueryValueKey(
        KeyHandle,
        &unicodeString,
        KeyValuePartialInformation,
        (PVOID) NULL,
        0,
        &keyValueLength
        );
    if( !NT_SUCCESS(status) &&
        (status != STATUS_BUFFER_OVERFLOW) &&
        (status != STATUS_BUFFER_TOO_SMALL)) {

        return status;

    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //
    infoBuffer = ExAllocatePoolWithTag(
        NonPagedPool,
        keyValueLength,
        'IPCA'
        );
    if (!infoBuffer) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Query the data for the key value.
    //
    status = ZwQueryValueKey(
        KeyHandle,
        &unicodeString,
        KeyValuePartialInformation,
        infoBuffer,
        keyValueLength,
        &keyValueLength
        );
    if (!NT_SUCCESS( status )) {

        ExFreePool( infoBuffer );

        return status;

    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //
    *Information = infoBuffer;
    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\i386\parseini.h ===
/*++                    

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    parseini.h

Abstract:

    This module contains support routines for parsing INFs in kernel-mode.
    
Environment:

    Kernel mode

--*/

PVOID
CmpOpenInfFile(
    IN  PVOID   InfImage,
    IN  ULONG   ImageSize
   );
   
VOID
CmpCloseInfFile(
    PVOID   InfHandle
    );   

PCHAR
CmpGetKeyName(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );
    
LOGICAL
CmpSearchInfSection(
    IN PVOID InfHandle,
    IN PCHAR SectionName
    );
    
LOGICAL
CmpSearchInfLine(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );
    
PCHAR
CmpGetSectionLineIndex (
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex,
    IN ULONG ValueIndex
    );

ULONG
CmpGetSectionLineIndexValueCount(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );

BOOLEAN
CmpGetIntField(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PULONG Data
    );

BOOLEAN
CmpGetBinaryField(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN OUT PULONG ActualSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\i386\parseini.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.


Module Name:

    parseini.c

Abstract:

    This modules contains routines to parse an inf file. This is based on
    the code from the osloader. All indices are zero based.

Author:

    Santosh Jodh (santoshj) 08-Aug-1998


Environment:

    Kernel mode.

Revision History:

--*/

#include "cmp.h"
#include "string.h"
#include "ctype.h"
#include "stdlib.h"
#include "parseini.h"

typedef struct _value   VALUE,      *PVALUE;
typedef struct _line    LINE,       *PLINE;
typedef struct _section SECTION,    *PSECTION;
typedef struct _inf     INF,        *PINF;
typedef struct _cm_token   CM_TOKEN,*PCM_TOKEN;
typedef enum _tokentype TOKENTYPE,  *PTOKENTTYPE;
typedef enum _stringsSectionType    STRINGSSECTIONTYPE;;

struct _value
{
    PVALUE  pNext;
    PCHAR   pName;
    BOOLEAN Allocated;
};

struct _line
{
    PLINE   pNext;
    PCHAR   pName;
    PVALUE  pValue;
    BOOLEAN Allocated;
};

struct _section
{
    PSECTION    pNext;
    PCHAR       pName;
    PLINE       pLine;
    BOOLEAN     Allocated;
};

struct _inf
{
    PSECTION            pSection;
    PSECTION            pSectionRecord;
    PLINE               pLineRecord;
    PVALUE              pValueRecord;
    STRINGSSECTIONTYPE  StringsSectionType;
    PSECTION            StringsSection;
};

//
// [Strings] section types.
//
enum _stringsSectionType
{
    StringsSectionNone,
    StringsSectionPlain,
    StringsSectionLoosePrimaryMatch,
    StringsSectionExactPrimaryMatch,
    StringsSectionExactMatch
};

enum _tokentype
{
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
};

struct _cm_token
{
    TOKENTYPE   Type;
    PCHAR       pValue;
    BOOLEAN     Allocated;
};

VOID
CmpFreeValueList(
    IN PVALUE pValue
    );

VOID
CmpFreeLineList(
    IN PLINE pLine
    );

VOID
CmpFreeSectionList(
    IN PSECTION pSection
    );

PCHAR
CmpProcessForSimpleStringSub(
    IN PINF pInf,
    IN PCHAR String
    );

BOOLEAN
CmpAppendSection(
    IN PINF  pInf,
    IN PCHAR pSectionName,
    IN BOOLEAN Allocated
    );

BOOLEAN
CmpAppendLine(
    IN PINF pInf,
    IN PCHAR pLineKey,
    IN BOOLEAN Allocated
    );

BOOLEAN
CmpAppendValue(
    IN PINF pInf,
    IN PCHAR pValueString,
    IN BOOLEAN Allocated
    );

VOID
CmpGetToken(
    IN OUT PCHAR *Stream,
    IN PCHAR MaxStream,
    IN OUT PCM_TOKEN Token
    );

PINF
CmpParseInfBuffer(
    IN PCHAR Buffer,
    IN ULONG Size,
    IN OUT PULONG ErrorLine
    );

PVALUE
CmpSearchValueInLine(
    IN PLINE pLine,
    IN ULONG ValueIndex
    );

PLINE
CmpSearchLineInSectionByIndex(
    IN PSECTION pSection,
    IN ULONG    LineIndex
    );

PSECTION
CmpSearchSectionByName(
    IN PINF  pInf,
    IN PCHAR SectionName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpFreeValueList)
#pragma alloc_text(INIT,CmpFreeLineList)
#pragma alloc_text(INIT,CmpFreeSectionList)
#pragma alloc_text(INIT,CmpProcessForSimpleStringSub)
#pragma alloc_text(INIT,CmpAppendSection)
#pragma alloc_text(INIT,CmpAppendLine)
#pragma alloc_text(INIT,CmpAppendValue)
#pragma alloc_text(INIT,CmpGetToken)
#pragma alloc_text(INIT,CmpParseInfBuffer)
#pragma alloc_text(INIT,CmpSearchValueInLine)
#pragma alloc_text(INIT,CmpSearchLineInSectionByIndex)
#pragma alloc_text(INIT,CmpSearchSectionByName)
#pragma alloc_text(INIT,CmpSearchInfLine)
#pragma alloc_text(INIT,CmpOpenInfFile)
#pragma alloc_text(INIT,CmpCloseInfFile)
#pragma alloc_text(INIT,CmpGetKeyName)
#pragma alloc_text(INIT,CmpSearchInfSection)
#pragma alloc_text(INIT,CmpGetSectionLineIndex)
#pragma alloc_text(INIT,CmpGetSectionLineIndexValueCount)
#pragma alloc_text(INIT,CmpGetIntField)
#pragma alloc_text(INIT,CmpGetBinaryField)
#endif


//
// Globals used by the token parser.
// String terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const CHAR  StringTerminators[] = "[]=,\t \"\n\f\v\r";
CHAR const* const QStringTerminators = StringTerminators + 6;
const CHAR EmptyValue[] = "";

BOOLEAN
CmpAppendSection(
    IN PINF  pInf,
    IN PCHAR pSectionName,
    IN BOOLEAN Allocated
    )

/*++

    Routine Description:

        This routine creates a new section or merges with an existing section in the inf.

    Input Parameters:

        pInf - Pointer to the inf to be processed.

        pSectionName - Name of the section.

        Allocated - TRUE if memory was allocated for the section name.

    Return Value:

        TRUE iff successful.

--*/

{
    PSECTION            pNewSection;
    PLINE               pLineRecord;
    STRINGSSECTIONTYPE  type;
    USHORT              id;
    USHORT              threadLang;
    PCHAR               p;

    //
    // Check to see if INF initialised and the parameters passed in is valid
    //

    if (    pInf == (PINF)NULL ||
            pSectionName == (PCHAR)NULL)
    {
        return (FALSE);
    }

    //
    // See if we already have a section by this name. If so we want
    // to merge sections.
    //

    for(    pNewSection = pInf->pSection;
            pNewSection;
            pNewSection = pNewSection->pNext)
    {
        if(pNewSection->pName && _stricmp(pNewSection->pName,pSectionName) == 0)
        {
            break;
        }
    }

    if(pNewSection)
    {
        //
        // Set pLineRecord to point to the last line currently in the section.
        //

        for(    pLineRecord = pNewSection->pLine;
                pLineRecord && pLineRecord->pNext;
                pLineRecord = pLineRecord->pNext);

        pInf->pLineRecord = pLineRecord;
    }
    else
    {
        //
        // Allocate memory for the new section
        //

        pNewSection = (PSECTION)ExAllocatePoolWithTag(PagedPool, sizeof(SECTION), CM_PARSEINI_TAG);

        if (pNewSection == (PSECTION)NULL)
        {
            ASSERT(pNewSection);
            return (FALSE);
        }

        //
        // Initialize the new section.
        //

        pNewSection->pNext = NULL;
        pNewSection->pLine = NULL;
        pNewSection->pName = pSectionName;
        pNewSection->Allocated = Allocated;

        //
        // Link it in.
        //

        pNewSection->pNext = pInf->pSection;
        pInf->pSection = pNewSection;

        if(_strnicmp(pSectionName, "Strings", 7) == 0)
        {
            type = StringsSectionNone;

            if(pSectionName[7] == '.')
            {
                //
                // The langid part must be in the form of 4 hex digits.
                //

                id = (USHORT)strtoul(pSectionName + 8, &p, 16);
                if(p == (pSectionName + 8 + 5) && *p == '\0')
                {
                    threadLang = LANGIDFROMLCID(NtCurrentTeb()->CurrentLocale);

                    if(threadLang == id)
                    {
                        type = StringsSectionExactMatch;
                    }
                    else
                    {
                        if(id == PRIMARYLANGID(threadLang))
                        {
                            type = StringsSectionExactPrimaryMatch;
                        }
                        else
                        {
                            if(PRIMARYLANGID(id) == PRIMARYLANGID(threadLang))
                            {
                                type = StringsSectionLoosePrimaryMatch;
                            }
                        }
                    }
                }
            }
            else
            {
                if(!pSectionName[7])
                {
                    type = StringsSectionPlain;
                }
            }

            if(type > pInf->StringsSectionType)
            {
                pInf->StringsSection = pNewSection;
            }
        }

        //
        // Reset the current line record.
        //

        pInf->pLineRecord = NULL;
    }

    pInf->pSectionRecord = pNewSection;
    pInf->pValueRecord = NULL;

    return (TRUE);
}

BOOLEAN
CmpAppendLine(
    IN PINF pInf,
    IN PCHAR pLineKey,
    IN BOOLEAN Allocated
    )

/*++

    Routine Description:

        This routine creates a new line and appends it to the end of the line list.

    Input Parameters:

        pInf - Pointer to the inf to be processed.

        pLineKey - Name of the line.

        Allocated - TRUE if memory was allocated for the line name.

    Return Value:

        TRUE iff successful.

--*/

{
    PLINE pNewLine;

    //
    // Check to see if current section initialized.
    //

    if (pInf->pSectionRecord == (PSECTION)NULL)
    {
        return (FALSE);
    }

    //
    // Allocate memory for the new Line.
    //

    pNewLine = (PLINE)ExAllocatePoolWithTag(PagedPool, sizeof(LINE), CM_PARSEINI_TAG);
    if (pNewLine == (PLINE)NULL)
    {
        ASSERT(pNewLine);
        return (FALSE);
    }

    //
    // Link it in.
    //

    pNewLine->pNext  = (PLINE)NULL;
    pNewLine->pValue = (PVALUE)NULL;
    pNewLine->pName  = pLineKey;
    pNewLine->Allocated = Allocated;

    if (pInf->pLineRecord == (PLINE)NULL)
    {
        pInf->pSectionRecord->pLine = pNewLine;
    }
    else
    {
        pInf->pLineRecord->pNext = pNewLine;
    }

    pInf->pLineRecord  = pNewLine;

    //
    // Reset the current value record
    //

    pInf->pValueRecord = (PVALUE)NULL;

    return (TRUE);
}

BOOLEAN
CmpAppendValue(
    IN PINF pInf,
    IN PCHAR pValueString,
    IN BOOLEAN Allocated
    )

/*++

    Routine Description:

        This routine creates a new value and appends it to the end of the value list.

    Input Parameters:

        pInf - Pointer to the inf to be processed.

        pValueString - Name of the value.

        Allocated - TRUE if memory was allocated for the value name.

    Return Value:

        TRUE iff successful.

--*/

{
    PVALUE pNewValue;

    //
    // Check to see if current line record has been initialised and
    // the parameter passed in is valid.
    //

    if (    pInf->pLineRecord == (PLINE)NULL ||
            pValueString == (PCHAR)NULL)
    {
        return (FALSE);
    }

    //
    // Allocate memory for the new value record.
    //

    pNewValue = (PVALUE)ExAllocatePoolWithTag(PagedPool, sizeof(VALUE), CM_PARSEINI_TAG);

    if (pNewValue == (PVALUE)NULL)
    {
        ASSERT(pNewValue);
        return (FALSE);
    }

    //
    // Link it in.
    //

    pNewValue->pNext  = (PVALUE)NULL;
    pNewValue->pName  = pValueString;
    pNewValue->Allocated = Allocated;

    if (pInf->pValueRecord == (PVALUE)NULL)
    {
        pInf->pLineRecord->pValue = pNewValue;
    }
    else
    {
        pInf->pValueRecord->pNext = pNewValue;
    }

    pInf->pValueRecord = pNewValue;

    return (TRUE);
}

VOID
CmpGetToken(
    IN OUT PCHAR *Stream,
    IN PCHAR MaxStream,
    IN OUT PCM_TOKEN Token
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    MaxStream - Supplies the address of the last character in the stream.


Return Value:

    None.

--*/

{

    PCHAR   pch;
    PCHAR   pchStart;
    PCHAR   pchNew;
    ULONG   length;
    BOOLEAN done;

    Token->Allocated = FALSE;
    Token->pValue = NULL;

    do
    {
        done = TRUE;

        //
        //  Skip whitespace (except for EOL).
        //

        for (   pch = *Stream;
                pch < MaxStream && *pch != '\n' && isspace(*pch);
                pch++);

        //
        // Check for comments and remove them.
        //

        if (    pch < MaxStream &&
                (*pch == '#' || *pch == ';'))
        {
            while (pch < MaxStream && *pch != '\n')
            {
                pch++;
            }
        }

        //
        // Check to see if EOF has been reached, set the token to the right
        // value.
        //

        if (pch >= MaxStream || *pch == 26)
        {
            *Stream = pch;
            Token->Type  = TOK_EOF;
            Token->pValue = NULL;

            return;
        }

        switch (*pch)
        {
            case '[':

                pch++;
                Token->Type  = TOK_LBRACE;
                break;

            case ']':

                pch++;
                Token->Type  = TOK_RBRACE;
                break;

            case '=':

                pch++;
                Token->Type  = TOK_EQUAL;
                break;

            case ',':

                pch++;
                Token->Type  = TOK_COMMA;
                break;

            case '\n':

                pch++;
                Token->Type  = TOK_EOL;
                break;

            case '\"':

                pch++;

                //
                // Determine quoted string.
                //

                for (   pchStart = pch;
                        pch < MaxStream && (strchr(QStringTerminators, *pch) == NULL);
                        pch++);

                if (pch >= MaxStream || *pch != '\"')
                {
                    Token->Type   = TOK_ERRPARSE;
                }
                else
                {

                    //
                    // We require a quoted string to end with a double-quote.
                    // (If the string ended with anything else, the if() above
                    // would not have let us into the else clause.) The quote
                    // character is irrelevent, however, and can be overwritten.
                    // So we'll save some heap and use the string in-place.
                    // No need to make a copy.
                    //
                    // Note that this alters the image of txtsetup.sif we pass
                    // to setupdd.sys. Thus the inf parser in setupdd.sys must
                    // be able to treat a nul character as if it were a terminating
                    // double quote.
                    //

                    *pch++ = '\0';
                    Token->Type = TOK_STRING;
                    Token->pValue = pchStart;
                }
                break;

            case '\\':

                for (   pchNew = ++pch;
                        pchNew < MaxStream &&
                            *pchNew != '\n' && isspace(*pchNew);
                        pchNew++);

                if (pch >= MaxStream)
                {
                    Token->Type   = TOK_ERRPARSE;
                    break;
                } 
                else if (*pchNew == '\n')
                {
                    pch = pchNew + 1;
                    done = FALSE;
                    break;
                }

            default:

                //
                // Determine regular string.
                //

                for (   pchStart = pch;
                        pch < MaxStream && (strchr(StringTerminators, *pch) == NULL);
                        pch++);

                if (pch == pchStart)
                {
                    pch++;
                    Token->Type  = TOK_ERRPARSE;
                }
                else
                {
                    length = (ULONG)(pch - pchStart);
                    pchNew = ExAllocatePoolWithTag(PagedPool, length + 1, CM_PARSEINI_TAG);
                    if (pchNew == NULL)
                    {
                        ASSERT(pchNew);
                        Token->Type = TOK_ERRNOMEM;
                    }
                    else
                    {
                        strncpy(pchNew, pchStart, length);
                        pchNew[length] = 0;
                        Token->Type = TOK_STRING;
                        Token->pValue = pchNew;
                        Token->Allocated = TRUE;
                    }
                }
                break;
        }

        *Stream = pch;
    }
    while (!done);

    return;
}

PINF
CmpParseInfBuffer(
    IN PCHAR Buffer,
    IN ULONG Size,
    IN OUT PULONG ErrorLine
    )

/*++

Routine Description:

   Given a character buffer containing the INF file, this routine parses
   the INF into an internal form with Section records, Line records and
   Value records.

Arguments:

   Buffer - contains to ptr to a buffer containing the INF file

   Size - contains the size of the buffer.

   ErrorLine - if a parse error occurs, this variable receives the line
        number of the line containing the error.


Return Value:

   PVOID - INF handle ptr to be used in subsequent INF calls.

--*/

{
    PINF        pInf;
    ULONG       state;
    PCHAR       stream;
    PCHAR       maxStream;
    PCHAR       pchSectionName;
    PCHAR       pchValue;
    CM_TOKEN    token;
    BOOLEAN     done;
    BOOLEAN     error;
    ULONG       infLine;
    BOOLEAN     allocated = FALSE;

    //
    // Allocate memory for the INF record.
    //

    pInf = (PINF)ExAllocatePoolWithTag(PagedPool, sizeof(INF), CM_PARSEINI_TAG);

    if (pInf == NULL)
    {
        return NULL;
    }

    pInf->pSection = NULL;
    pInf->pSectionRecord = NULL;
    pInf->pLineRecord = NULL;
    pInf->pValueRecord = NULL;
    pInf->StringsSectionType = StringsSectionNone;
    pInf->StringsSection = NULL;

    //
    // Set initial state.
    //

    state     = 1;
    stream    = Buffer;
    maxStream = Buffer + Size;
    pchSectionName = NULL;
    pchValue = NULL;
    done      = FALSE;
    error     = FALSE;
    infLine = 1;

    //
    // Enter token processing loop.
    //

    while (!done)
    {

       CmpGetToken(&stream, maxStream, &token);

        switch (state)
        {
            //
            // STATE1: Start of file, this state remains till first
            //         section is found
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
            //

            case 1:

                switch (token.Type)
                {
                    case TOK_EOL:

                        break;

                    case TOK_EOF:

                        done = TRUE;

                        break;

                    case TOK_LBRACE:

                        state = 2;

                        break;

                    case TOK_STRING:

                        ASSERT(token.Type != TOK_STRING);
                        error = done = TRUE;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 2: Section LBRACE has been received, expecting STRING
            //
            // Valid Tokens: TOK_STRING, TOK_RBRACE
            //

            case 2:

                switch (token.Type)
                {
                    case TOK_STRING:

                        state = 3;
                        pchSectionName = token.pValue;
                        allocated = token.Allocated;

                        break;

                    case TOK_RBRACE:

                        token.pValue = (PCHAR)EmptyValue;
                        token.Allocated = FALSE;
                        allocated = FALSE;
                        state = 4;

                        break;

                    default:

                        error = done = TRUE;

                        break;

                }

                break;

            //
            // STATE 3: Section Name received, expecting RBRACE
            //
            // Valid Tokens: TOK_RBRACE
            //

            case 3:

                switch (token.Type)
                {
                    case TOK_RBRACE:

                        state = 4;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 4: Section Definition Complete, expecting EOL
            //
            // Valid Tokens: TOK_EOL, TOK_EOF
            //

            case 4:

                switch (token.Type)
                {

                    case TOK_EOL:

                        if (!CmpAppendSection(pInf, pchSectionName, allocated))
                        {

                            error = done = TRUE;
                        }
                        else
                        {
                            pchSectionName = NULL;
                            state = 5;
                        }

                        break;

                    case TOK_EOF:

                        if (!CmpAppendSection(pInf, pchSectionName, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchSectionName = NULL;
                            done = TRUE;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 5: Expecting Section Lines
            //
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
            //

            case 5:

                switch (token.Type)
                {
                    case TOK_EOL:

                        break;

                    case TOK_EOF:

                        done = TRUE;

                        break;

                    case TOK_STRING:

                        pchValue = token.pValue;
                        allocated = token.Allocated;
                        state = 6;

                        break;

                    case TOK_LBRACE:

                        state = 2;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 6: String returned, not sure whether it is key or value
            //
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
            //

            case 6:

                switch (token.Type)
                {

                    case TOK_EOL:

                        if (    !CmpAppendLine(pInf, NULL, FALSE) ||
                                !CmpAppendValue(pInf, pchValue, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchValue = NULL;
                            state = 5;
                        }

                        break;

                    case TOK_EOF:

                        if (    !CmpAppendLine(pInf, NULL, FALSE) ||
                                !CmpAppendValue(pInf, pchValue, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchValue = NULL;
                            done = TRUE;
                        }

                        break;

                    case TOK_COMMA:

                        if (    !CmpAppendLine(pInf, NULL, FALSE) ||
                                !CmpAppendValue(pInf, pchValue, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchValue = NULL;
                            state = 7;
                        }

                        break;

                    case TOK_EQUAL:

                        if (!CmpAppendLine(pInf, pchValue, allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            pchValue = NULL;
                            state = 8;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 7: Comma received, Expecting another string
            //
            // Valid Tokens: TOK_STRING TOK_COMMA
            //   A comma means we have an empty value.
            //

            case 7:

                switch (token.Type)
                {

                    case TOK_COMMA:

                        token.pValue = (PCHAR)EmptyValue;
                        token.Allocated = FALSE;
                        allocated = FALSE;
                        if (!CmpAppendValue(pInf, token.pValue, FALSE))
                        {
                            error = done = TRUE;
                        }

                        //
                        // State stays at 7 because we are expecting a string
                        //

                        break;

                    case TOK_STRING:

                        if (!CmpAppendValue(pInf, token.pValue, token.Allocated))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            state = 9;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 8: Equal received, Expecting another string
            //          If none, assume there is a single empty string on the RHS
            //
            // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF
            //

            case 8:

                switch (token.Type)
                {
                    case TOK_EOF:

                        token.pValue = (PCHAR)EmptyValue;
                        token.Allocated = FALSE;
                        allocated = FALSE;
                        if(!CmpAppendValue(pInf, token.pValue, FALSE))
                        {
                            error = TRUE;
                        }

                        done = TRUE;

                        break;

                    case TOK_EOL:

                        token.pValue = (PCHAR)EmptyValue;
                        token.Allocated = FALSE;
                        allocated = FALSE;
                        if(!CmpAppendValue(pInf, token.pValue, FALSE))
                        {
                            error = TRUE;
                            done = TRUE;
                        }
                        else
                        {
                            state = 5;
                        }

                        break;

                    case TOK_STRING:

                        if (!CmpAppendValue(pInf, token.pValue, FALSE))
                        {
                            error = done = TRUE;
                        }
                        else
                        {
                            state = 9;
                        }

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 9: String received after equal, value string
            //
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
            //

            case 9:

                switch (token.Type)
                {
                    case TOK_EOL:

                        state = 5;

                        break;

                    case TOK_EOF:

                        done = TRUE;

                        break;

                    case TOK_COMMA:

                        state = 7;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            //
            // STATE 10: Value string definitely received
            //
            // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
            //

            case 10:

                switch (token.Type)
                {
                    case TOK_EOL:

                        state =5;

                        break;

                    case TOK_EOF:

                        done = TRUE;

                        break;

                    case TOK_COMMA:

                        state = 7;

                        break;

                    default:

                        error = done = TRUE;

                        break;
                }

                break;

            default:

                error = done = TRUE;

                break;

        } // END switch(state)


        if (error)
        {
            *ErrorLine = infLine;
            if (pchSectionName != (PCHAR)NULL && allocated)
            {
                ExFreePool(pchSectionName);
            }

            if (pchValue != (PCHAR)NULL && allocated)
            {
                ExFreePool(pchValue);
            }

            ExFreePool(pInf);

            pInf = (PINF)NULL;
        }
        else
        {
            //
            // Keep track of line numbers for error reporting.
            //

            if (token.Type == TOK_EOL)
            {
                infLine++;
            }
        }

    } // END while

    if (pInf)
    {
        pInf->pSectionRecord = NULL;
    }

    return(pInf);
}

PCHAR
CmpProcessForSimpleStringSub(
    IN PINF pInf,
    IN PCHAR String
    )

/*++

    Routine Description:

        This routine substitutes reference to string in the STRINGS section of the inf.

    Input Parameters:

        pInf - Pointer to the inf to be processed.

        String - String to be substituted.

    Return Value:

        None.

--*/

{
    SIZE_T      len;
    PCHAR       returnString;
    PSECTION    pSection;
    PLINE       pLine;

    //
    // Assume no substitution necessary.
    //

    returnString = String;
    len = strlen(String);
    pSection = pInf->StringsSection;

    //
    // If it starts and end with % then look it up in the
    // strings section. Note the initial check before doing a
    // wcslen, to preserve performance in the 99% case where
    // there is no substitution.
    //

    if( String[0] == '%' &&
        len > 2 &&
        String[len - 1] == '%' &&
        pSection)
    {

        for(pLine = pSection->pLine; pLine; pLine = pLine->pNext)
        {
            if( pLine->pName &&
                _strnicmp(pLine->pName, String + 1, len - 2) == 0 &&
                pLine->pName[len - 2] == '\0')
            {
                break;
            }
        }

        if(pLine && pLine->pValue && pLine->pValue->pName)
        {
            returnString = pLine->pValue->pName;
        }
    }

    return(returnString);
}

VOID
CmpFreeValueList(
    IN PVALUE pValue
    )

/*++

    Routine Description:

        This routine releases memory for the list of values.

    Input Parameters:

        pValue - Pointer to the value list to be freed.

    Return Value:

        None.

--*/

{
    PVALUE pNext;

    while (pValue)
    {
        //
        // Save the next pointer so we dont access memory after it has
        // been freed.
        //

        pNext = pValue->pNext;

        //
        // Free any data inside this value.
        //

        if (pValue->Allocated && pValue->pName)
        {
            ExFreePool((PVOID)pValue->pName);
        }

        //
        // Free memory for this value.
        //

        ExFreePool(pValue);

        //
        // Go to the next value.
        //

        pValue = pNext;
    }
}

VOID
CmpFreeLineList(
    IN PLINE pLine
    )

/*++

    Routine Description:

        This routine releases memory for the list of lines and
        values under it.

    Input Parameters:

        pLine - Pointer to the line list to be freed.

    Return Value:

        None.

--*/

{
    PLINE pNext;

    while (pLine)
    {
        //
        // Save the next pointer so we dont access memory after it has
        // been freed.
        //

        pNext = pLine->pNext;

        //
        // Free any data inside this Line.
        //

        if (pLine->Allocated && pLine->pName)
        {
            ExFreePool((PVOID)pLine->pName);
        }

        //
        // Free the list of values inside this Line.
        //

        CmpFreeValueList(pLine->pValue);

        //
        // Free memory for this line itself.
        //

        ExFreePool((PVOID)pLine);

        //
        // Go to the next line.
        //

        pLine = pNext;
    }
}

VOID
CmpFreeSectionList(
    IN PSECTION pSection
    )

/*++

    Routine Description:

        This routine releases memory for the list of sections and
        lines under it.

    Input Parameters:

        pSection - Pointer to the section list to be freed.

    Return Value:

        None.

--*/

{
    PSECTION pNext;

    while (pSection)
    {
        //
        // Save the next pointer so we dont access memory after it has
        // been freed.
        //

        pNext = pSection->pNext;

        //
        // Free any data inside this Line.
        //

        if (pSection->Allocated && pSection->pName)
        {
            ExFreePool((PVOID)pSection->pName);
        }

        //
        // Free the list of values inside this Line.
        //

        CmpFreeLineList(pSection->pLine);

        //
        // Free memory for this line itself.
        //

        ExFreePool((PVOID)pSection);

        //
        // Go to the next line.
        //

        pSection = pNext;
    }

}

PVALUE
CmpSearchValueInLine(
    IN PLINE pLine,
    IN ULONG ValueIndex
    )

/*++

    Routine Description:

        This routine searches for the specified value in the inf.

    Input Parameters:

        pLine - Pointer to the line to be searched.

        ValueIndex - Index of the value to be searched.

    Return Value:

        Pointer to the value iff found. Else NULL.

--*/

{
    ULONG   i;
    PVALUE  pValue = NULL;

    if (pLine)
    {
        for (   i = 0, pValue = pLine->pValue;
                i < ValueIndex && pValue;
                i++, pValue = pValue->pNext);
    }

    return (pValue);
}


PSECTION
CmpSearchSectionByName(
    IN PINF  pInf,
    IN PCHAR SectionName
    )

/*++

    Routine Description:

        This routine searches for the specified section in the inf.

    Input Parameters:

        pInf - Pointer to the inf to be searched.

        SectionName - Name of the section to be searched.

    Return Value:

        Pointer to the section iff found. Else NULL.

--*/

{
    PSECTION    pSection = NULL;
    PSECTION    pFirstSearchedSection;

    //
    // Validate the parameters passed in.
    //

    if (pInf && SectionName)
    {
        //
        // Traverse down the section list searching each section for the
        // section name mentioned.
        //

        for (   pSection = pFirstSearchedSection = pInf->pSectionRecord;
                pSection && _stricmp(pSection->pName, SectionName);
                pSection = pSection->pNext);

        //
        // If we did not find the section, search from the beginning.
        //

        if (pSection == NULL)
        {
            for (   pSection = pInf->pSection;
                    pSection && pSection != pFirstSearchedSection;
                    pSection = pSection->pNext)
            {
                if (pSection->pName && _stricmp(pSection->pName, SectionName) == 0)
                {
                    break;
                }
            }

            if (pSection == pFirstSearchedSection)
            {
                pSection = NULL;
            }
        }

        if (pSection)
        {
            pInf->pSectionRecord = pSection;
        }
    }

    //
    // Return the section at which we stopped.
    //

    return (pSection);
}

PLINE
CmpSearchLineInSectionByIndex(
    IN PSECTION pSection,
    IN ULONG    LineIndex
    )

/*++

    Routine Description:

        This routine searches for the specified line in the inf.

    Input Parameters:

        pSection - Pointer to the section to be searched.

        LineIndex - Index of the line to be searched.

    Return Value:

        Pointer to the line iff found. Else NULL.

--*/

{
    PLINE   pLine = NULL;
    ULONG   i;

    //
    // Validate the parameters passed in.
    //

    if (pSection)
    {

        //
        // Traverse down the current line list to the LineIndex line.
        //

        for(    i = 0, pLine = pSection->pLine;
                i < LineIndex && pLine;
                i++, pLine = pLine->pNext);
    }

    //
    // Return the Line found
    //

    return (pLine);
}

PVOID
CmpOpenInfFile(
    IN  PVOID   InfImage,
    IN  ULONG   ImageSize
   )

/*++

    Routine Description:

        This routine opens an handle to the inf.

    Input Parameters:

        InfImage - Pointer to the inf image read into memory.

        ImageSize - Image size.

    Return Value:

        Returns handle to the inf iff successful. Else NULL.

--*/

{
    PINF    infHandle;
    ULONG   errorLine = 0;

    //
    // Parse the inf buffer.
    //

    infHandle = CmpParseInfBuffer(InfImage, ImageSize, &errorLine);

    if (infHandle == NULL)
    {
#ifndef _CM_LDR_
        DbgPrintEx(DPFLTR_CONFIG_ID,DPFLTR_ERROR_LEVEL,"Error on line %d in CmpOpenInfFile!\n", errorLine);
#endif //_CM_LDR_
    }

    return (infHandle);
}

VOID
CmpCloseInfFile(
    PVOID   InfHandle
    )

/*++

    Routine Description:

        This routine closes the inf handle by releasing any
        memory allocated for it during parsing.

    Input Parameters:

        InfHandle - Handle to the inf to be closed.

    Return Value:

        None.

--*/

{
    if (InfHandle)
    {
        CmpFreeSectionList(((PINF)InfHandle)->pSection);
        ExFreePool(InfHandle);
    }
}

LOGICAL
CmpSearchInfSection(
    IN PINF  pInf,
    IN PCHAR Section
    )

/*++

    Routine Description:

        This routine searches for the specified section in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

    Return Value:

        TRUE iff section is found in the inf.

--*/

{
    return (CmpSearchSectionByName(pInf, Section) != NULL);
}

PCHAR
CmpGetKeyName(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine returns the name of the specified line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Pointer to the name of line in the inf iff successful. Else NULL.

--*/

{
    PSECTION    pSection;
    PLINE       pLine;

    //
    // First search the section.
    //

    pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
    if(pSection)
    {
        //
        // Get the line in the section.
        //

        pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
        if(pLine)
        {
            return(pLine->pName);
        }
    }

    return (NULL);
}

LOGICAL
CmpSearchInfLine(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine searches for the specified line in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        TRUE iff line is found in the section in the inf.

--*/

{
    PSECTION    pSection;
    PLINE       pLine = NULL;

    //
    // First search the section.
    //

    pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
    if(pSection)
    {
        //
        // Search the line in the section.
        //

        pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
    }

    return (pLine != NULL);
}


PCHAR
CmpGetSectionLineIndex (
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex
    )

/*++

    Routine Description:

        This routine returns the value at the specified location in the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

        ValueIndex - Index of the value to be read.

    Return Value:

        Pointer to the value iff successful. Else NULL.

--*/

{
    PSECTION pSection;
    PLINE    pLine;
    PVALUE   pValue;

    //
    // Search the section in the inf.
    //

    pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
    if(pSection)
    {
        //
        // Search the line in the section.
        //

        pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
        if(pLine)
        {
            //
            // Search the value in the line.
            //

            pValue = CmpSearchValueInLine(pLine, ValueIndex);
            if(pValue)
            {
                //
                // The value may need to be replaced by one of the strings
                // from the string section.
                //

                return(CmpProcessForSimpleStringSub(InfHandle, pValue->pName));
            }
        }
    }

    return(NULL);
}

ULONG
CmpGetSectionLineIndexValueCount(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex
    )

/*++

    Routine Description:

        This routine returns the number of values in the inf line.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

    Return Value:

        Number of values in the inf line.

--*/

{
    PSECTION    pSection;
    PLINE       pLine;
    PVALUE      pValue;
    ULONG       count = 0;

    //
    // Search the section in the inf.
    //

    pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
    if(pSection)
    {
        //
        // Search the line in the section.
        //

        pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
        if (pLine)
        {
            //
            // Count the number of values in this line.
            //

            for(    pValue = pLine->pValue;
                    pValue;
                    pValue = pValue->pNext, count++);
        }
    }

    return (count);
}

BOOLEAN
CmpGetIntField(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PULONG Data
    )

/*++

    Routine Description:

        This routine reads integer data from the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

        ValueIndex - Index of the value to be read.

        Data - Receives the integer data.

    Return Value:

        TRUE iff successful.

--*/

{
    PCHAR   valueStr;

    //
    // Get the specified value.
    //

    valueStr = CmpGetSectionLineIndex(  InfHandle,
                                        Section,
                                        LineIndex,
                                        ValueIndex);
    //
    // If valid value is found, convert it to an integer.
    //

    if (valueStr && *valueStr)
    {
        *Data = strtoul(valueStr, NULL, 16);
        return (TRUE);
    }

    return (FALSE);
}

BOOLEAN
CmpGetBinaryField(
    IN PVOID InfHandle,
    IN PCHAR Section,
    IN ULONG LineIndex,
    IN ULONG ValueIndex,
    IN OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN OUT PULONG ActualSize
    )

/*++

    Routine Description:

        This routine reads binary data from the inf.

    Input Parameters:

        InfHandle - Handle to the inf to be read.

        Section - Name of the section to be read.

        LineIndex - Index of the line to be read.

        ValueIndex - Index of the value to be read.

        Buffer - Receives the binary data read.

        BufferSize - Size of the buffer.

        ActualSize - Receives the size of the data buffer required.

    Return Value:

        TRUE iff successful.

--*/

{
    BOOLEAN     result = FALSE;
    ULONG       requiredSize;
    PSECTION    pSection;
    PLINE       pLine;
    PVALUE      pValue;
    ULONG       count;
    PCHAR       valueStr = NULL;
    PUCHAR      charBuf;

    //
    // Compute the size of buffer required to read in the binary data.
    //

    requiredSize = (CmpGetSectionLineIndexValueCount(   InfHandle,
                                                        Section,
                                                        LineIndex) - ValueIndex) * sizeof(UCHAR);
    //
    // Validate input parameters.
    //

    if (Buffer && BufferSize >= requiredSize)
    {
        //
        // Search the section in the inf.
        //

        pSection = CmpSearchSectionByName((PINF)InfHandle, Section);
        if(pSection)
        {
            //
            // Search the line in this section.
            //

            pLine = CmpSearchLineInSectionByIndex(pSection, LineIndex);
            if (pLine)
            {
                //
                // Go to the specified value.
                //

                for(    pValue = pLine->pValue, count = 0;
                        pValue && count < ValueIndex;
                        pValue = pValue->pNext, count++);

                //
                // Read in and convert the binary data.
                //

                charBuf = (PUCHAR) Buffer;

                for (   ;
                        pValue;
                        pValue = pValue->pNext)
                {
                    valueStr = CmpGetSectionLineIndex(  InfHandle,
                                                        Section,
                                                        LineIndex,
                                                        ValueIndex++);
                    if (valueStr == NULL)
                    {
                        break;
                    }
                    *charBuf++ = (UCHAR)strtoul(valueStr, NULL, 16);
                }
                if (valueStr)
                {
                    result = TRUE;
                }
            }
        }
    }

    //
    // The caller wants to know the buffer size required.
    //

    if (ActualSize)
    {
        *ActualSize = requiredSize;
        result = TRUE;
    }

    return (result);
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\ia64\initdat.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

Author:

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"

//
// ***** INIT *****
//

//
// Data for CmGetSystemControlValues
//
//
// ----- CmControlVector -----
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

PCHAR  SearchStrings[] = {
      "Ver", "Rev", "Rel", "v0", "v1", "v2", "v3", "v4", "v5",
      "v6", "v7", "v8", "v9", "v 0", "v 1", "v 2", "v 3", "v 4",
      "v 5", "v 6", "v 7", "v 8", "v 9", NULL };

PCHAR BiosBegin = { 0 };
PCHAR Start = { 0 };
PCHAR End = { 0 };

CHAR CmpID[] = "ia64 Family %u Model %u Stepping %u";
WCHAR CmpVendorID[] = L"VendorIdentifier";
WCHAR CmpProcessorNameString[] = L"ProcessorNameString";
WCHAR CmpFeatureBits[] = L"FeatureSet";
WCHAR CmpMHz[] = L"~MHz";
WCHAR CmpUpdateSignature[] = L"Update Signature";

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGE")
#endif

CHAR CmpIntelID[] = "GenuineIntel";

CHAR CmpItanium [] = "Itanium";
CHAR CmpItanium2[] = "Itanium 2";

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\i386\initdat.c ===
//depot/Lab01_N/Base/ntos/config/i386/initdat.c#3 - edit change 11365 (text)
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

Author:

Environment:

    Kernel mode.

Revision History:

--*/
#include "cmp.h"

//
// ***** INIT *****
//

//
// Data for CmGetSystemControlValues
//
//
// ----- CmControlVector -----
//
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#pragma const_seg("INITCONST")
#endif

const PCHAR  SearchStrings[] = {
      "Ver", "Rev", "Rel", "v0", "v1", "v2", "v3", "v4", "v5",
      "v6", "v7", "v8", "v9", "v 0", "v 1", "v 2", "v 3", "v 4",
      "v 5", "v 6", "v 7", "v 8", "v 9", NULL };

PCHAR BiosBegin = { 0 };
PCHAR Start = { 0 };
PCHAR End = { 0 };

#if defined(_X86_)
const UCHAR CmpID1[] = "80%u86-%c%x";
const UCHAR CmpID2[] = "x86 Family %u Model %u Stepping %u";
#else
const UCHAR CmpID2[] = "x86-64 Family %u Model %u Stepping %u";
#endif

const WCHAR CmpVendorID[] = L"VendorIdentifier";
const WCHAR CmpProcessorNameString[] = L"ProcessorNameString";
const WCHAR CmpFeatureBits[] = L"FeatureSet";
const WCHAR CmpMHz[] = L"~MHz";
const WCHAR CmpUpdateSignature[] = L"Update Signature";
const WCHAR CmDisabledFloatingPointProcessor[] = L"DisabledFloatingPointProcessor";
const WCHAR CmPhysicalAddressExtension[] = L"PhysicalAddressExtension";

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGE")
#pragma  const_seg("PAGECONST")
#endif

const CHAR CmpCyrixID[]     = "CyrixInstead";
const CHAR CmpIntelID[]     = "GenuineIntel";
const CHAR CmpAmdID[]       = "AuthenticAMD";
const CHAR CmpTransmetaID[] = "GenuineTMx86";
const CHAR CmpCentaurID[]   = "CentaurHauls";

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#pragma  const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\chkreg.c ===
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include "windows.h"

#define MSG_ERROR_VALUE_INCORRECT_SIZE        "\tERROR: Value entry data has incorrect size \n\t\tValueName = %ls \n\t\tNameSize  = %d \n\t\tValueType = %s \n\t\tValueSize = %d\n"
#define MSG_ERROR_VALUE_NOT_NUL_TERMINATED    "\tERROR: Value entry data is not NUL terminated \n\t\tValueName = %ls \n\t\tNameSize  = %d \n\t\tValueType = %s\n"
#define MSG_ERROR_VALUE_UNKNOWN_DATA          "\tERROR: Value entry contains unknown data \n\t\tValueName = %ls \n\t\tNameSize  = %d \n\t\tValueType = %#x \n\t\tValueSize = %d\n"
#define MSG_ERROR_REG_ENUM_VALUE              "\tERROR: RegEnumValue() failed, iValue = %d, Status = %d \n"
#define MSG_ERROR_REG_OPEN_KEY_EX             "\tERROR: RegOpenKeyEx() failed, Status = %d \n"
#define MSG_ERROR_REG_QUERY_INFO_KEY          "\tERROR: RegQueryInfoKey() failed, Status = %d \n"
#define MSG_ERROR_REG_ENUM_KEY_EX             "ERROR: RegEnumKeyEx() failed, \n\t Status = %d \n\t, SubKey = %d"
#define MSG_ERROR_REG_CONNECT_REGISTRY        "ERROR: Unable to connect to %s, Status = %d \n"
#define MSG_COMPLETE_KEY_NAME                 "%ls\\%ls \n"

VOID
ExamineValueEntries( IN HKEY    Key,
                     IN LPCWSTR CompleteKeyName,
                     IN DWORD   cchMaxValueName,
                     IN DWORD   cbMaxValueData,
                     IN DWORD   cValues,
                     IN LPCWSTR PredefinedKeyName )


{
    LONG    Status;
    DWORD   iValue;
    LPWSTR  lpszValue;
    DWORD   cchValue;
    DWORD   dwType;
    PBYTE   lpbData;
    DWORD   cbData;
    BOOLEAN KeyNameAlreadyPrinted;

    //
    //  Allocate the buffers for the value name and value data
    //

    lpszValue = ( LPWSTR )malloc( (cchMaxValueName + 1)*sizeof( WCHAR ) );
    lpbData = ( LPBYTE )malloc( cbMaxValueData );
    if( ( lpszValue == NULL ) ||
        ( lpbData == NULL ) ) {
        printf( "ERROR: Unable to allocate memory, cchMaxValueName = %d, cbMaxValuedata = %d \n",
                 cchMaxValueName, cbMaxValueData );
        if( lpszValue != NULL ) {
            free( lpszValue );
        }
        if( lpbData != NULL ) {
            free( lpbData );
        }
        return;
    }

    //
    //  Examine all value entries
    //

    KeyNameAlreadyPrinted = FALSE;
    for( iValue = 0; iValue < cValues; iValue++ ) {
        cchValue = cchMaxValueName + 1;
        cbData = cbMaxValueData;
        Status = RegEnumValueW( Key,
                                iValue,
                                lpszValue,
                                &cchValue,
                                0,
                                &dwType,
                                lpbData,
                                &cbData );

        if( Status != ERROR_SUCCESS ) {
            if( !KeyNameAlreadyPrinted ) {
                KeyNameAlreadyPrinted = TRUE;
                printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
            }
            printf( MSG_ERROR_REG_ENUM_VALUE, iValue, Status );
            continue;
        }

//
//      For debugging only
//
//        printf( "\tValueName = %ls \n", lpszValue );
//

        switch( dwType ) {

            case REG_BINARY:

                if( cbData == 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_BINARY", cbData );
                }
                break;

            case REG_DWORD:

                if( cbData != sizeof( DWORD ) ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_DWORD", cbData );
                }
                break;

            case REG_DWORD_BIG_ENDIAN:

                if( cbData != sizeof( DWORD ) ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_DWORD_BIG_ENDIAN", cbData );
                }
                break;

            case REG_EXPAND_SZ:

                if( ( cbData != 0 )  && ( ( cbData % sizeof( WCHAR ) ) == 0 )) {
                    if( *( ( PWCHAR )( lpbData + cbData - sizeof( WCHAR ) ) ) != ( WCHAR )'\0' ) {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_NOT_NUL_TERMINATED,
                                lpszValue, cchValue, "REG_EXPAND_SZ" );
                    }
                } else {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                                lpszValue, cchValue, "REG_EXPAND_SZ", cbData );
                }
                break;

            case REG_LINK:

                if( cbData == 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_LINK", cbData );
                }
                break;

            case REG_MULTI_SZ:

                if( ( cbData != 0 )  && ( ( cbData % sizeof( WCHAR ) ) == 0 )) {
                    if( *( ( PWCHAR )( lpbData + cbData - sizeof( WCHAR ) ) ) != ( WCHAR )'\0' ) {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_NOT_NUL_TERMINATED,
                                lpszValue, cchValue, "REG_MULTI_SZ" );
                    }
                } else {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                                lpszValue, cchValue, "REG_MULTI_SZ", cbData );
                }
                break;

            case REG_NONE:

                if( cbData != 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_NONE", cbData );
                }
                break;

            case REG_RESOURCE_LIST:

                if( cbData == 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_RESOURCE_LIST", cbData );
                }
                break;


            case REG_SZ:

                if( ( cbData != 0 ) && ( ( cbData % sizeof( WCHAR ) ) == 0 ) ) {
                    if( *( ( PWCHAR )( lpbData + cbData - sizeof( WCHAR ) ) ) != ( WCHAR )'\0' ) {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_NOT_NUL_TERMINATED,
                                lpszValue, cchValue, "REG_SZ" );
                    }
                } else {
                        if( !KeyNameAlreadyPrinted ) {
                            KeyNameAlreadyPrinted = TRUE;
                            printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                        }
                        printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                                lpszValue, cchValue, "REG_SZ", cbData );
                }
                break;

            case REG_FULL_RESOURCE_DESCRIPTOR:

                if( cbData == 0 ) {
                    if( !KeyNameAlreadyPrinted ) {
                        KeyNameAlreadyPrinted = TRUE;
                        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                    }
                    printf( MSG_ERROR_VALUE_INCORRECT_SIZE,
                            lpszValue, cchValue, "REG_FULL_RESOURCE_DESCRIPTOR", cbData );
                }
                break;

            default:

                if( !KeyNameAlreadyPrinted ) {
                    KeyNameAlreadyPrinted = TRUE;
                    printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                }
                printf( MSG_ERROR_VALUE_UNKNOWN_DATA,
                        lpszValue, cchValue, dwType, cbData );
                break;

        }
    }

    //
    //  Free buffers for value name and value data
    //
    free( lpszValue );
    free( lpbData );
}





VOID
ExamineKey(
    IN  HKEY    PredefinedKey,
    IN  LPCWSTR ParentName,
    IN  LPCWSTR KeyName,
    IN  LPCWSTR PredefinedKeyName
    )

{
    LPWSTR      CompleteKeyName;

    HKEY        Key;

    LONG        Status;

    WCHAR       szClass[ MAX_PATH + 1 ];
    DWORD       cchClass;
    DWORD       cSubKeys;
    DWORD       cchMaxSubKey;
    DWORD       cchMaxClass;
    DWORD       cValues;
    DWORD       cchMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;

    WCHAR       szSubKeyName[ MAX_PATH + 1 ];
    DWORD       cchSubKeyNameLength;

    DWORD       iSubKey;
    BOOLEAN     KeyNameAlreadyPrinted;


    //
    //  Build the complete key name
    //

    if( wcslen( ParentName ) == 0 ) {
        CompleteKeyName = wcsdup( KeyName );
        if( CompleteKeyName == NULL ) {
            printf( "ERROR: wcsdup( KeyName ) failed \n" );
            return;
        }
    } else {
        CompleteKeyName = wcsdup( ParentName );
        if( CompleteKeyName == NULL ) {
            printf( "ERROR: wcsdup( ParentName ) failed \n" );
            return;
        }
        if( wcslen( KeyName ) != 0 ) {
            CompleteKeyName = realloc( CompleteKeyName,
                                       ( wcslen( CompleteKeyName ) +
                                         wcslen( L"\\" ) +
                                         wcslen( KeyName ) + 1 )*sizeof( WCHAR ) );
            wcscat( CompleteKeyName, L"\\" );
            wcscat( CompleteKeyName, KeyName );
        }
    }

//
//  For debugging only
//
//    printf( "%ls\\%ls \n", PredefinedKeyName, CompleteKeyName );
//

    //
    //  Open the key
    //

    Status = RegOpenKeyExW( PredefinedKey,
                           CompleteKeyName,
                           0,
                           MAXIMUM_ALLOWED,
                           &Key );


    if( Status != ERROR_SUCCESS ) {
        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
        printf( MSG_ERROR_REG_OPEN_KEY_EX, Status );
        free( CompleteKeyName );
        return;
    }

    //
    //  Determine the number of value entries, the maximum length of a value
    //  entry name, the maximum data size, and the number of subkeys
    //

    cchClass = sizeof( szClass ) / sizeof( WCHAR );
    Status = RegQueryInfoKeyW( Key,
                               szClass,
                               &cchClass,
                               0,
                               &cSubKeys,
                               &cchMaxSubKey,
                               &cchMaxClass,
                               &cValues,
                               &cchMaxValueName,
                               &cbMaxValueData,
                               &cbSecurityDescriptor,
                               &ftLastWriteTime );

    if( Status != ERROR_SUCCESS ) {
        printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
        printf( MSG_ERROR_REG_QUERY_INFO_KEY, Status );
        free( CompleteKeyName );
        RegCloseKey( Key );
        return;
    }


    if( cValues != 0 ) {

        //
        // Examine the value entries
        //

        ExamineValueEntries( Key,
                            CompleteKeyName,
                            cchMaxValueName,
                            cbMaxValueData,
                            cValues,
                            PredefinedKeyName );

    }

    //
    //  Traverse each subkey
    //
    if( cSubKeys != 0 ) {
        KeyNameAlreadyPrinted = FALSE;
        for( iSubKey = 0; iSubKey < cSubKeys; iSubKey++ ) {
            cchSubKeyNameLength = sizeof( szSubKeyName )/sizeof( WCHAR );
            cchClass = sizeof( szClass ) / sizeof( WCHAR );
            Status = RegEnumKeyExW( Key,
                                    iSubKey,
                                    szSubKeyName,
                                    &cchSubKeyNameLength,
                                    0,
                                    NULL,
                                    NULL,
                                    &ftLastWriteTime );

            if( Status != ERROR_SUCCESS ) {
                if( !KeyNameAlreadyPrinted ) {
                    KeyNameAlreadyPrinted = TRUE;
                    printf( MSG_COMPLETE_KEY_NAME, PredefinedKeyName, CompleteKeyName );
                }
                printf( MSG_ERROR_REG_ENUM_KEY_EX, Status, iSubKey );
                continue;
            }
            ExamineKey( PredefinedKey,
                        CompleteKeyName,
                        szSubKeyName,
                        PredefinedKeyName );
        }
    }
    RegCloseKey( Key );

    free( CompleteKeyName );
}




main( int argc, char* argv[] )
{
    DWORD   i;
    HKEY    RemoteUsers;
    HKEY    RemoteLocalMachine;
    LONG    Status;

    if( argc <= 1 ) {
        printf( "\n******* Examining HKEY_LOCAL_MACHINE on local machine\n\n" );
        ExamineKey( HKEY_LOCAL_MACHINE,
                    L"",
                    L"",
                    L"HKEY_LOCAL_MACHINE" );

        printf( "\n******* Examining HKEY_USERS on local machine\n\n" );
        ExamineKey( HKEY_USERS,
                    L"",
                    L"",
                    L"HKEY_USERS" );

        printf( "\n******* Examining HKEY_CLASSES_ROOT on local machine\n\n" );
        ExamineKey( HKEY_CLASSES_ROOT,
                    L"",
                    L"",
                    L"HKEY_CLASSES_ROOT" );

        printf( "\n******* Examining HKEY_CURRENT_USER on local machine\n\n" );
        ExamineKey( HKEY_CURRENT_USER,
                    L"",
                    L"",
                    L"HKEY_CURRENT_USER" );
    } else {
        for( i = 1; i < argc; i++ ) {
            //
            // printf( "Machine name = %s \n", argv[ i ] );
            //

            Status = RegConnectRegistry( argv[ i ],
                                         HKEY_LOCAL_MACHINE,
                                         &RemoteLocalMachine );

            if( Status != ERROR_SUCCESS ) {
                printf( MSG_ERROR_REG_CONNECT_REGISTRY, argv[i], Status );
                continue;
            }

            Status = RegConnectRegistry( argv[ i ],
                                         HKEY_USERS,
                                         &RemoteUsers );

            if( Status != ERROR_SUCCESS ) {
                RegCloseKey( RemoteLocalMachine );
                printf( MSG_ERROR_REG_CONNECT_REGISTRY, argv[i], Status );
                continue;
            }

            printf( "\n******* Examining HKEY_LOCAL_MACHINE on %s \n\n", argv[i] );
            ExamineKey( RemoteLocalMachine,
                        L"",
                        L"",
                        L"HKEY_LOCAL_MACHINE" );

            printf( "\n******* Examining HKEY_USERS on %s \n\n", argv[i] );
            ExamineKey( RemoteUsers,
                        L"",
                        L"",
                        L"HKEY_USERS" );

            RegCloseKey( RemoteLocalMachine );
            RegCloseKey( RemoteUsers );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\editreg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    editreg.c

Abstract:

    This program acts as an interactive shell allowing a user to view
    and manipulate the configuration registry.  Also, it has some specific
    commands for support of the NTFT component of the registry.

Author:

    Mike Glass
    Bob Rinne

Environment:

    User process.

Notes:

    The commands "disk", "fix", "restore" are commands that know where
    the configuration information is for the NTFT component of the NT
    system.

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "ntdskreg.h"
#include "ntddft.h"

//
// Tempory stuff to get types and values to print in help.
//

PUCHAR TypeNames[] =
{
    "REG_NONE",
    "REG_SZ",
    "REG_BINARY",
    "REG_DWORD",
    "REG_DWORD_LITTLE_ENDIAN",
    "REG_DWORD_BIG_ENDIAN",
    "REG_LINK",
    "REG_MULTI_SZ",
    "REG_RESOURCE_LIST",
    NULL
};

ULONG TypeNumbers[] =
{
    REG_NONE,
    REG_SZ,
    REG_BINARY,
    REG_DWORD,
    REG_DWORD_LITTLE_ENDIAN,
    REG_DWORD_BIG_ENDIAN,
    REG_LINK,
    REG_MULTI_SZ,
    REG_RESOURCE_LIST
};

//
// Special support for the driver load lists in the registry.
//

PUCHAR StartDescription[] =
{
    "Boot loader",
    "System",
    "2",
    "3",
    
    //
    // Anything above 3 is not loaded.
    //

    NULL
};

PUCHAR TypeDescription[] =
{
    "System driver",
    "File system",
    "Service",
    NULL
};


//
// Constants and defines.
//

#define WORK_BUFFER_SIZE 4096

//
// Amount to fudge when mallocing for strings.
//

#define FUDGE 8

//
// Registry base.
//

#define REGISTRY_BASE "\\REGISTRY\\MACHINE"

//
// Default type value when key value set.
//

#define DEFAULT_TYPE REG_SZ

//
// Base location for component descriptions of FT elements.
//

#define FT_REGISTRY_ROOT "\\REGISTRY\\MACHINE\\SYSTEM\\NTFT"

//
// Subkey name located in the FT_REGISTRY_ROOT for stripes.
//

#define FT_STRIPE_BASE   "Stripe%d"

//
// Subkey name located in the FT_REGISTRY_ROOT for mirrors.
//

#define FT_MIRROR_BASE   "Mirror%d"

//
// Subkey name located in the FT_REGISTRY_ROOT for volume sets.
//

#define FT_VOLSET_BASE   "VolSet%d"


//
// Constants for the command values.
//

#define INVALID   -1
#define DIR       0
#define CREATE    1
#define LIST      2
#define CHDIR     3
#define HELP      4
#define QUIT      5
#define DDEBUG    6
#define SETVALUE  7
#define DELKEY    8
#define DELVALUE  9
#define DIRLONG  10
#define INLONG   11
#define INSHORT  12
#define INBYTE   13
#define DUMP     14
#define DISKREG  15
#define FIXDISK  16
#define RESTORE  17
#define DRIVERS  18
#define ORPHAN   19
#define REGEN    20
#define INIT     21
#define MAKEFT   22

#define CTRL_C 0x03

//
// Table of recognized commands.
//

PUCHAR Commands[] = {
    "dir",
    "keys",
    "lc",
    "ls",
    "create",
    "set",
    "unset",
    "erase",
    "delete",
    "rm",
    "list",
    "values",
    "display",
    "cd",
    "chdir",
    "help",
    "?",
    "quit",
    "exit",
    "debug",
    "longs",
    "shorts",
    "bytes",
    "dump",
    "disks",
    "fix",
    "restore",
    "drivers",
    "orphan",
    "regenerate",
    "initialize",
    "makeft",
    NULL
};

//
// Using the index from the match on the commands in Commands[], this
// table gives the proper command value to be executed.  This allows
// for multiple entries in Commands[] for the same command code.
//

int CommandMap[] = {

    DIRLONG,
    DIR,
    DIR,
    DIR,
    CREATE,
    SETVALUE,
    DELVALUE,
    DELVALUE,
    DELKEY,
    DELKEY,
    LIST,
    LIST,
    LIST,
    CHDIR,
    CHDIR,
    HELP,
    HELP,
    QUIT,
    QUIT,
    DDEBUG,
    INLONG,
    INSHORT,
    INBYTE,
    DUMP,
    DISKREG,
    FIXDISK,
    RESTORE,
    DRIVERS,
    ORPHAN,
    REGEN,
    INIT,
    MAKEFT
};

//
// CommandHelp is an array of help strings for each of the commands.
// The array is indexed by the result of CommandMap[i] for the Commands[]
// array.  This way the same help message will print for each of the
// commands aliases.
//

PUCHAR   CommandHelp[] = {

    "Displays keys.",
    "Create a new key.",
    "Displays values withing a key.",
    "Change current location in registry.",
    "This help information.",
    "Exit the program.",
    "Set internal debug on for this program.",
    "Set a new value within a key.",
    "Delete a key.",
    "Unset (erase) a key value.",
    "Unset (erase) a key value.",
    "Change dump format to Longs (default).",
    "Change dump format to Shorts.",
    "Change dump format to Bytes.",
    "Toggle dump mode (force hex dump for all value types).",
    "Display the disk registry.",
    "Set disk signatures in registry.",
    "Restore an FT orphan to working state.",
    "List the information on the drivers from the registry.",
    "Orphan a member of an FT set.",
    "Mark a FT set member for regeneration on next boot.",
    "Mark a stripe with parity for initialization on next boot.",
    "Construct an FT set from existing partitions",
    NULL

};

//
// Space for working location string in registry.
//

UCHAR WorkingDirectory[512];

//
// Space for current location string in registry.
//

UCHAR CurrentDirectory[512];

//
// Space for command input.
//

UCHAR CommandLine[512];

//
// Prompt strings for getting definition for an FT_COPY request.
//

PUCHAR SetPrompts[] = {

    "Name => ",
    "Value => ",
    "Index => ",
    NULL
};

//
// Version indicator.  Should be changed every time a major edit occurs.
//

PUCHAR Version = "Version 1.30";

//
// Debug print level.
//

ULONG Debug = 0;

//
// Dump control values.
//

typedef enum _DUMP_CONTROL {

    InBytes,
    InShorts,
    InLongs

} DUMP_CONTROL, *PDUMP_CONTROL;

ULONG ForceDump = 0;

DUMP_CONTROL DumpControl = InLongs;

NTSTATUS
FtOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS          status;
    STRING            keyString;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    unicodeKeyName;

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       (BOOLEAN) TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenKey(HandlePtr,
                       MAXIMUM_ALLOWED,
                       &objectAttributes);

    RtlFreeUnicodeString(&unicodeKeyName);

    if (Debug == 1) {
        if (!NT_SUCCESS(status)) {
            printf("Failed NtOpenKey for %s => %x\n",
                   KeyName,
                   status);
        }
    }

    return status;
}


NTSTATUS
FtDeleteKey(
    PUCHAR KeyName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS status;
    HANDLE   keyToDelete;

    status = FtOpenKey(&keyToDelete,
                       KeyName);

    if (!NT_SUCCESS(status)) {
        printf("Key %s not found (0x%x).\n", KeyName, status);
        return status;
    }

    status = NtDeleteKey(keyToDelete);

    if (Debug == 1) {
        if (!NT_SUCCESS(status)) {
            printf("Could not delete key %s => %x\n",
                   KeyName,
                   status);
        }
    }

    NtClose(keyToDelete);
    return status;
}


NTSTATUS
FtCreateKey(
    PUCHAR KeyName,
    PUCHAR KeyClass,
    ULONG  Index
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS          status;
    STRING            keyString;
    UNICODE_STRING    unicodeKeyName;
    STRING            classString;
    UNICODE_STRING    unicodeClassName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG             disposition;
    HANDLE            tempHandle;

#if DBG
    if ((KeyName == NULL) ||
        (KeyClass == NULL)) {
        printf("FtCreateKey: Invalid parameter 0x%x, 0x%x\n",
               KeyName,
               KeyClass);
        ASSERT(0);
    }
#endif

    //
    // Initialize the object for the key.
    //

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       (BOOLEAN) TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Setup the unicode class value.
    //

    RtlInitString(&classString,
                  KeyClass);
    (VOID)RtlAnsiStringToUnicodeString(&unicodeClassName,
                                       &classString,
                                       (BOOLEAN) TRUE);

    //
    // Create the key.
    //

    status = NtCreateKey(&tempHandle,
                         MAXIMUM_ALLOWED,
                         &objectAttributes,
                         Index,
                         &unicodeClassName,
                         REG_OPTION_NON_VOLATILE,
                         &disposition);

    if (NT_SUCCESS(status)) {
        switch (disposition)
        {
        case REG_CREATED_NEW_KEY:
            break;

        case REG_OPENED_EXISTING_KEY:
            printf("Warning: Creation was for an existing key!\n");
            break;

        default:
            printf("New disposition returned == 0x%x\n", disposition);
            break;
        }
    }

    //
    // Free all allocated space.
    //

    RtlFreeUnicodeString(&unicodeKeyName);
    RtlFreeUnicodeString(&unicodeClassName);
    NtClose(tempHandle);
    return status;
}


NTSTATUS
FtDeleteValue(
    HANDLE KeyHandle,
    PUCHAR ValueName
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS       status;
    STRING         valueString;
    UNICODE_STRING unicodeValueName;

    RtlInitString(&valueString,
                  ValueName);
    status = RtlAnsiStringToUnicodeString(&unicodeValueName,
                                          &valueString,
                                          (BOOLEAN) TRUE);
    if (!NT_SUCCESS(status)) {
        printf("FtDeleteValue: internal conversion error 0x%x\n", status);
        return status;
    }

    status = NtDeleteValueKey(KeyHandle,
                              &unicodeValueName);
    if (Debug == 1) {
        if (!NT_SUCCESS(status)) {
            printf("Could not delete value %s => %x\n",
                   ValueName,
                   status);
        }
    }

    RtlFreeUnicodeString(&unicodeValueName);
    return status;
}

NTSTATUS
FtSetValue(
    HANDLE KeyHandle,
    PUCHAR ValueName,
    PVOID  DataBuffer,
    ULONG  DataLength,
    ULONG  Type
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS          status;
    STRING            valueString;
    UNICODE_STRING    unicodeValueName;

    RtlInitString(&valueString,
                  ValueName);
    RtlAnsiStringToUnicodeString(&unicodeValueName,
                                 &valueString,
                                 (BOOLEAN) TRUE);
    status = NtSetValueKey(KeyHandle,
                           &unicodeValueName,
                           0,
                           Type,
                           DataBuffer,
                           DataLength);
    if (Debug == 1) {
        if (!NT_SUCCESS(status)) {
            printf("Could not set value %s => %x\n",
                   ValueName,
                   status);
        }
    }

    RtlFreeUnicodeString(&unicodeValueName);
    return status;
}


PUCHAR
FindTypeString(
    ULONG Type
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    int i;

    for (i = 0; TypeNames[i] != NULL; i++) {

        if (TypeNumbers[i] == Type) {
            return TypeNames[i];
        }
    }
    return "(Unknown)";
}


BOOLEAN
ProcessHex(
    PUCHAR String,
    PULONG Value
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG  workValue;
    int    i;
    PUCHAR cp;

    if (String == NULL) {
        return FALSE;
    }

    cp = String;

    //
    // 'i' is an index value.  It contains the maximum index into the String.
    // Therefore it is initialized to -1.
    //

    i = -1;
    while ((*cp) && (*cp != '\n')) {
        i++;
        cp++;
    }

    if (i >= 8) {

        //
        // String to long for a long.
        //

        return FALSE;
    }

    workValue = 0;
    cp = String;
    while (*cp) {
        *cp = (UCHAR) tolower(*cp);

        switch (*cp) {

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            workValue |= (((*cp) - '0') << (i * 4));
            break;

        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
            workValue |= ((((*cp) - 'a') + 10) << (i * 4));
            break;

        default:

            //
            // Illegal value, just punt.
            //

            return FALSE;
            break;
        }
        cp++;
        i--;
    }

    *Value = workValue;
    return TRUE;
}


VOID
Dump(
    PVOID Buffer,
    ULONG Length
    )

/*++

Routine Description:

    Dump the value data from a buffer in the format specified.

Arguments:

    Buffer - pointer to the data.
    Length - length of the data.

Return Value:

    None.

--*/
{
    PUCHAR location;
    PUCHAR internalBuffer;
    int    i;
    int    j;
    int    numberLines;
    UCHAR  outHexLine[128];
    UCHAR  outPrintable[64];

    numberLines = (Length + 15) / 16;

    //
    // Since the amount of data displayed has been rounded up, this
    // routine mallocs enough space and copies the data in.  This way
    // it won't fault if the data is at the end of memory.
    //

    internalBuffer = (PUCHAR) malloc(numberLines * 16);
    RtlMoveMemory(internalBuffer, Buffer, Length);
    location = (PUCHAR) internalBuffer;

    for (i = 0; i < numberLines; i++) {

        sprintf(outHexLine, "%8x: ", (i * 16));
        sprintf(outPrintable, "*");
        switch (DumpControl) {

        case InBytes:

            for (j = 0; j < 16; j++) {
                sprintf(outHexLine, "%s%2X ", outHexLine, *location);
                sprintf(outPrintable, "%s%c", outPrintable,
                        (isprint(location[0])) ? location[0] : '.');
                location++;
            }
            break;

        case InShorts:

            for (j = 0; j < 8; j++) {
                sprintf(outHexLine, "%s%4X ", outHexLine,
                        *((PUSHORT)location));
                sprintf(outPrintable, "%s%c%c", outPrintable,
                        (isprint(location[0])) ? location[0] : '.',
                        (isprint(location[1])) ? location[1] : '.');
                location += 2;
            }
            break;

        default:
        case InLongs:

            for (j = 0; j < 4; j++) {
                sprintf(outHexLine, "%s%8X ", outHexLine,
                        *((PULONG)location));
                sprintf(outPrintable, "%s%c%c%c%c", outPrintable,
                        (isprint(location[0])) ? location[0] : '.',
                        (isprint(location[1])) ? location[1] : '.',
                        (isprint(location[2])) ? location[2] : '.',
                        (isprint(location[3])) ? location[3] : '.');
                location += 4;
            }
            break;
        }

        printf("%s   %s*\n", outHexLine, outPrintable);
    }
    printf("\n");
    free(internalBuffer);
}


void
UnicodePrint(
    PUNICODE_STRING  UnicodeString
    )

/*++

Routine Description:

    Print a unicode string.

Arguments:

    UnicodeString - pointer to the string.

Return Value:

    None.

--*/
{
    ANSI_STRING ansiString;
    PUCHAR      tempbuffer = (PUCHAR) malloc(WORK_BUFFER_SIZE);

    ansiString.MaximumLength = WORK_BUFFER_SIZE;
    ansiString.Length = 0L;
    ansiString.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&ansiString,
                                 UnicodeString,
                                 (BOOLEAN) FALSE);
    printf("%s", ansiString.Buffer);
    free(tempbuffer);
    return;
}


NTSTATUS
Directory(
    HANDLE  KeyHandle,
    BOOLEAN LongListing
    )

/*++


Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS        status;
    ULONG           index;
    ULONG           resultLength;
    UNICODE_STRING  unicodeValueName;
    PKEY_BASIC_INFORMATION keyInformation;

    keyInformation = (PKEY_BASIC_INFORMATION) malloc(WORK_BUFFER_SIZE);

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(keyInformation, WORK_BUFFER_SIZE);

        status = NtEnumerateKey(KeyHandle,
                                index,
                                KeyBasicInformation,
                                keyInformation,
                                WORK_BUFFER_SIZE,
                                &resultLength);

        if (status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(status)) {

            printf("readreg: Error on Enumerate status = %x\n", status);
            break;

        }

        unicodeValueName.Length = (USHORT)keyInformation->NameLength;
        unicodeValueName.MaximumLength = (USHORT)keyInformation->NameLength;
        unicodeValueName.Buffer = (PWSTR)&keyInformation->Name[0];
        UnicodePrint(&unicodeValueName);
        printf("\n");

        if (LongListing) {
        }
    }

    free(keyInformation);
    return status;
}


NTSTATUS
List(
    HANDLE KeyHandle,
    PUCHAR ItemName
    )

/*++


Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS       status;
    ULONG          index;
    ULONG          resultLength;
    ULONG          type;
    PUCHAR         typeString;
    UNICODE_STRING unicodeValueName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    UNREFERENCED_PARAMETER(ItemName);

    resultLength = WORK_BUFFER_SIZE;
    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)malloc(WORK_BUFFER_SIZE);

    for (index = 0; TRUE; index++) {

        while (1) {

            RtlZeroMemory(keyValueInformation, resultLength);
            status = NtEnumerateValueKey(KeyHandle,
                                         index,
                                         KeyValueFullInformation,
                                         keyValueInformation,
                                         resultLength,
                                         &resultLength);

            if (status == STATUS_BUFFER_OVERFLOW) {
                free(keyValueInformation);
                keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                           malloc(resultLength + 10);
            } else {
                break;
            }
        }

        if (status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(status)) {

            printf("readreg: Cannot list (%x)\n", status);
            break;

        }

        type = keyValueInformation->Type;
        typeString = FindTypeString(type);
        unicodeValueName.Length = (USHORT)keyValueInformation->NameLength;
        unicodeValueName.MaximumLength =(USHORT)keyValueInformation->NameLength;
        unicodeValueName.Buffer = (PWSTR)&keyValueInformation->Name[0];
        printf("Name-> """);
        UnicodePrint(&unicodeValueName);
        printf("""\n");
        printf("\ttype = %s (%d)\ttitle index = %d\tdata length = %d\n",
               typeString,
               type,
               keyValueInformation->TitleIndex,
               keyValueInformation->DataLength);
        printf("\tData:\n");

        if (ForceDump) {
            type = REG_BINARY;
        }

        switch (type) {

        case REG_DWORD:
        // case REG_DWORD_LITTLE_ENDIAN:
            printf("\tDWORD value == %d, (0x%x)\n",
               *((PULONG)((PUCHAR)keyValueInformation +
                                  keyValueInformation->DataOffset)),
               *((PULONG)((PUCHAR)keyValueInformation +
                                  keyValueInformation->DataOffset)));
            break;

        case REG_SZ:

            unicodeValueName.Length = (USHORT)keyValueInformation->DataLength;
            unicodeValueName.MaximumLength = (USHORT)
                                                keyValueInformation->DataLength;
            unicodeValueName.Buffer = (PWSTR) ((PUCHAR) keyValueInformation +
                                               keyValueInformation->DataOffset);
            UnicodePrint(&unicodeValueName);
            break;

        case REG_BINARY:
        default:
            Dump(((PUCHAR)keyValueInformation +keyValueInformation->DataOffset),
                 keyValueInformation->DataLength);
        }
        printf("\n");
    }

    free(keyValueInformation);
    return status;
}


UCHAR
GetCharacter(
    BOOLEAN Batch
    )

/*++

Routine Description:

    This routine returns a single character from the input stream.
    It discards leading blanks if the input is not from the console.

Arguments:

    Batch - a boolean indicating if the input it coming from the console.

Return Value:

    A character

--*/

{
    UCHAR c;

    if (Batch) {

        while ((c = (UCHAR) getchar()) == ' ')
            ;

    } else {

        c = (UCHAR) getchar();
    }

    return c;
} // GetCharacter


PUCHAR
GetArgumentString(
    BOOLEAN Batch,
    PUCHAR  Prompt,
    BOOLEAN ConvertToLower
    )

/*++

Routine Description:

    This routine prints the prompt if the input is coming from the console,
    then proceeds to collect the user input until a carraige return is typed.

Arguments:

    Batch  - a boolean indicating if the input is coming from the console.
    Prompt - String to prompt with.

Return Value:

    A pointer to the input string.
    NULL if the user escaped.

--*/

{
    //
    // The command line data area is used to store the argument string.
    //

    PUCHAR argument = CommandLine;
    int    i;
    UCHAR  c;

    if (!Batch) {

        printf("%s", Prompt);
    }

    while ((c = GetCharacter(Batch)) == ' ') {

        //
        // Ignore leading spaces.
        //
    }

    i = 0;
    while (c) {

        putchar(c);

        if (c == CTRL_C) {

            return NULL;
        }

        if ((c == '\n') || (c == '\r')) {

            putchar('\n');

            if (i == 0) {
                return NULL;
            } else {
                break;
            }
        }

        if (c == '\b') {

            if (i > 0) {

                //
                // blank over last char
                //

                putchar(' ');
                putchar('\b');
                i--;

            } else {

                //
                // space forward to keep prompt in the same place.
                //

                putchar(' ');
            }

        } else {

            //
            // Collect the argument.
            //

            if (ConvertToLower == TRUE) {
                argument[i] = (UCHAR) tolower(c);
            } else {
                argument[i] = (UCHAR) c;
            }
            i++;

        }

        c = GetCharacter(Batch);
    }

    argument[i] = '\0';
    return CommandLine;

} // GetArgumentString


ULONG
ParseArgumentNumeric(
    PUCHAR  *ArgumentPtr
    )

/*++

Routine Description:

    This routine prints the prompt if the input is coming from the console.

Arguments:

    Batch - a boolean indicating if the input is coming from the console.

Return Value:

    None

--*/

{
    UCHAR   c;
    ULONG   number;
    int     i;
    BOOLEAN complete = FALSE;
    PUCHAR  argument = *ArgumentPtr;

    while (*argument == ' ') {

        //
        // skip spaces.
        //

        argument++;
    }

    //
    // Assume there is only one option to parse until proven
    // otherwise.
    //

    *ArgumentPtr = NULL;

    i = 0;

    while (complete == FALSE) {

        c = argument[i];

        switch (c) {

        case '\n':
        case '\r':
        case '\t':
        case ' ':

            //
            // Update the caller argument pointer to the remaining string.
            //

            *ArgumentPtr = &argument[i + 1];

            //
            // fall through.
            //

        case '\0':

            argument[i] = '\0';
            complete = TRUE;
            break;

        default:

            i++;
            break;
        }

    }

    if (i > 0) {
        number = (ULONG) atoi(argument);
    } else {
        number = (ULONG) -1;
    }

    return number;

} // ParseArgumentNumeric


VOID
PromptUser(
    BOOLEAN Batch
    )

/*++

Routine Description:

    This routine prints the prompt if the input is coming from the console.

Arguments:

    Batch - a boolean indicating if the input is coming from the console.

Return Value:

    None

--*/

{
    if (!Batch) {

        printf("\n%s> ", CurrentDirectory);
    }

} // PromptUser


int
GetCommand(
    BOOLEAN Batch,
    PUCHAR *ArgumentPtr
    )
/*++

Routine Description:

    This routine processes the user input and returns the code for the
    command entered.  If the command has an argument, either the default
    value for the argument (if none is given) or the value provided by the
    user is returned.

Arguments:

    Batch - a boolean indicating if the input it coming from the console.

Return Value:

    A command code

--*/

{
    int    i;
    int    commandIndex;
    int    commandCode;
    UCHAR  c;
    PUCHAR commandPtr;
    PUCHAR command = CommandLine;
    int    argumentIndex = -1;
    PUCHAR argument = NULL;

    PromptUser(Batch);

    while ((c = GetCharacter(Batch)) == ' ') {

        //
        // Ignore leading spaces.
        //
    }

    i = 0;
    while (c) {

        putchar(c);

        if ((c == '\n') || (c == '\r')) {
            putchar('\n');
            if (i == 0) {
                PromptUser(Batch);
                c = GetCharacter(Batch);
                continue;
            }
            break;
        }

        if (c == '\b') {

            if (i > 0) {

                //
                // blank over last char
                //

                putchar(' ');
                putchar('\b');
                i--;

                if (argumentIndex == i) {
                    argumentIndex = -1;
                    argument = NULL;
                }
            } else {

                //
                // space forward to keep prompt in the same place.
                //

                putchar(' ');
            }
        } else {

            //
            // Collect the command.
            //

            command[i] = (UCHAR)tolower(c);
            i++;
        }

        if ((c == ' ') && (argument == NULL)) {

            argument = &command[i];
            argumentIndex = i;
            command[i - 1] = '\0';
        }

        c = GetCharacter(Batch);
    }

    //
    // add end of string.
    //

    command[i] = '\0';

    if (Debug) {
        printf("command => %s$\n", command);
    }

    //
    // Identify the command and return its code.
    //

    commandIndex = 0;

    for (commandPtr = Commands[commandIndex];
         commandPtr != NULL;
         commandPtr = Commands[commandIndex]) {

        if (Debug) {
            printf("Testing => %s$ ... ", commandPtr);
        }

        i = 0;
        while (commandPtr[i] == command[i]) {
            if (command[i] == '\0') {
                break;
            }
            i++;
        }

        if (Debug) {
            printf(" i == %d, command[i] == 0x%x\n", i, command[i]);
        }

        if (command[i]) {

            //
            // Not complete there was a mismatch on the command.
            //

            commandIndex++;
            continue;
        }

        //
        // Have a match on the command.
        //

        if (Debug) {
            printf("Command match %d, argument %s\n",
                   commandIndex,
                   (argument == NULL) ? "(none)" : argument);
        }

        commandCode = CommandMap[commandIndex];
        *ArgumentPtr = argument;
        return commandCode;
    }

    printf("Command was invalid\n");
    return INVALID;
} // GetCommand


VOID
NotImplemented()

/*++

--*/

{
    printf("Sorry, function not implemented yet.\n");
}

NTSTATUS
FtReturnValue(
    IN HANDLE Handle,
    IN PUCHAR ValueName,
    IN PUCHAR Buffer,
    IN ULONG  BufferLength
    )

/*++

Routine Description:

    Formatted display of the disk registry information.

Arguments:

    None.

Return Values:

    None.

--*/

{
    NTSTATUS       status;
    ULONG          resultLength;
    ULONG          length;
    STRING         valueString;
    UNICODE_STRING unicodeValueName;
    PUCHAR         internalBuffer;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)malloc(WORK_BUFFER_SIZE);
    if (keyValueInformation == NULL) {
        printf("FtReturnValue: cannot allocate memory.\n");
        return STATUS_NO_MEMORY;
    }

    RtlInitString(&valueString,
                  ValueName);
    RtlAnsiStringToUnicodeString(&unicodeValueName,
                                 &valueString,
                                 (BOOLEAN) TRUE);
    status = NtQueryValueKey(Handle,
                             &unicodeValueName,
                             KeyValueFullInformation,
                             keyValueInformation,
                             WORK_BUFFER_SIZE,
                             &resultLength);
    RtlFreeUnicodeString(&unicodeValueName);

    if (NT_SUCCESS(status)) {
        length = (resultLength > BufferLength) ? BufferLength : resultLength;
        internalBuffer =
           ((PUCHAR)keyValueInformation + keyValueInformation->DataOffset);

        RtlMoveMemory(Buffer, internalBuffer, length);
    }
    free(keyValueInformation);
    return status;
}

VOID
DiskDump()

/*++

Routine Description:

    Formatted display of the disk registry information.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ULONG               outerLoop;
    ULONG               innerLoop;
    HANDLE              handle;
    NTSTATUS            status;
    PDISK_CONFIG_HEADER configHeader;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    PDISK_PARTITION     diskPartition;
    PFT_REGISTRY        ftRegistry;
    PFT_DESCRIPTION     ftDescription;
    PFT_MEMBER_DESCRIPTION ftMember;

    status = FtOpenKey(&handle,
                       DISK_REGISTRY_KEY);

    if (!NT_SUCCESS(status)) {
        printf("Currently there is no key in the registry"
               " for the disk information.\n");
        return;
    }

    configHeader = (PDISK_CONFIG_HEADER) malloc(WORK_BUFFER_SIZE);
    if (configHeader == NULL) {
        printf("Unable to allocate memory for the disk registy information.\n");
        return;
    }

    RtlZeroMemory(configHeader, WORK_BUFFER_SIZE);

    status = FtReturnValue(handle,
                           (PUCHAR) DISK_REGISTRY_VALUE,
                           (PUCHAR) configHeader,
                           WORK_BUFFER_SIZE);
    NtClose(handle);

    if (!NT_SUCCESS(status)) {
        printf("There is no disk registry information (%x)\n", status);
        free(configHeader);
        return;
    }

    //
    // Print the header.
    //

    printf("Registry header information:\n");
    printf("\tVersion = 0x%x, Checksum = 0x%x\n",
           configHeader->Version,
           configHeader->CheckSum);
    printf("\tDisk info Offset = 0x%x, Size = 0x%x\n",
           configHeader->DiskInformationOffset,
           configHeader->DiskInformationSize);
    printf("\tFT info Offset = 0x%x, Size = 0x%x\n",
           configHeader->FtInformationOffset,
           configHeader->FtInformationSize);

    //
    // Print the information on disks.
    //

    diskRegistry = (PDISK_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->DiskInformationOffset);
    printf("\nDisk information for %d disks:\n",
           diskRegistry->NumberOfDisks);

    diskDescription = &diskRegistry->Disks[0];
    for (outerLoop = 0;
         outerLoop < diskRegistry->NumberOfDisks;
         outerLoop++) {

        printf("\nDisk %d signature 0x%08x has %d partitions:\n",
               outerLoop,
               diskDescription->Signature,
               diskDescription->NumberOfPartitions);

        printf("       Ln Type  Start              Length             FtGrp  Member\n");
        for (innerLoop = 0;
             innerLoop < diskDescription->NumberOfPartitions;
             innerLoop++) {
            diskPartition = &diskDescription->Partitions[innerLoop];
            printf("  %c: %c %1d   %3d  %08x:%08x  %08x:%08x  %5d  %4d  %s\n",
                   (diskPartition->DriveLetter != '\0') ?
                                               diskPartition->DriveLetter : ' ',
                   (diskPartition->AssignDriveLetter) ? 'A' : ' ',
                   diskPartition->LogicalNumber,
                   diskPartition->FtType,
                   diskPartition->StartingOffset.HighPart,
                   diskPartition->StartingOffset.LowPart,
                   diskPartition->Length.HighPart,
                   diskPartition->Length.LowPart,
                   diskPartition->FtGroup,
                   diskPartition->FtMember,
                   (diskPartition->FtState == Orphaned) ? "Orphan" :
                     (diskPartition->FtState == Regenerating) ? "Regen" :
                     (diskPartition->FtState == Initializing) ? "Init" : "");

        }

        diskDescription = (PDISK_DESCRIPTION)
          &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    //
    // Print the information for FT.
    //

    if (configHeader->FtInformationSize == 0) {
        printf("There is no FT configuration.\n");
        free(configHeader);
        return;
    }

    ftRegistry = (PFT_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->FtInformationOffset);

    printf("\nNumber of FT components = %d\n",
           ftRegistry->NumberOfComponents);

    ftDescription = &ftRegistry->FtDescription[0];
    for (outerLoop = 0;
         outerLoop < ftRegistry->NumberOfComponents;
         outerLoop++) {

        printf("Component %d has %d members and is type %d\n",
               outerLoop,
               ftDescription->NumberOfMembers,
               ftDescription->Type);

        printf("      State Signature Start              Length            #\n");
        for (innerLoop = 0;
             innerLoop < ftDescription->NumberOfMembers;
             innerLoop++) {
            ftMember = &ftDescription->FtMemberDescription[innerLoop];

            diskPartition = (PDISK_PARTITION)
                 ((PUCHAR) configHeader + ftMember->OffsetToPartitionInfo);
            
            printf("%5x    %2x %08x  %08x:%08x  %08x:%08x %d\n",
                   ftMember->OffsetToPartitionInfo,
                   ftMember->State,
                   ftMember->Signature,
                   diskPartition->StartingOffset.HighPart,
                   diskPartition->StartingOffset.LowPart,
                   diskPartition->Length.HighPart,
                   diskPartition->Length.LowPart,
                   ftMember->LogicalNumber);
        }

        ftDescription = (PFT_DESCRIPTION)
         &ftDescription->FtMemberDescription[ftDescription->NumberOfMembers];
    }
}


VOID
ChangeMemberState(
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member,
    IN FT_PARTITION_STATE NewState
    )

/*++

Routine Description:

    Set the FT state for a partition.

Arguments:

    Type   - the FT type.
    Group  - the FT Group number for that type.
    Member - the member number within the group.

Return Values:

    None.

--*/

{
    BOOLEAN             writeBackRegistry = FALSE;
    HANDLE              handle;
    ULONG               outerLoop;
    ULONG               innerLoop;
    NTSTATUS            status;
    PDISK_CONFIG_HEADER configHeader;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    PDISK_PARTITION     partitionDescription;

    status = FtOpenKey(&handle,
                       DISK_REGISTRY_KEY);

    if (!NT_SUCCESS(status)) {
        printf("Currently there is no key in the registry"
               " for the disk information.\n");
        return;
    }

    configHeader = (PDISK_CONFIG_HEADER) malloc(WORK_BUFFER_SIZE);
    if (configHeader == NULL) {
        printf("Unable to allocate memory for the disk registy information.\n");
        NtClose(handle);
        return;
    }

    RtlZeroMemory(configHeader, WORK_BUFFER_SIZE);

    status = FtReturnValue(handle,
                           (PUCHAR) DISK_REGISTRY_VALUE,
                           (PUCHAR) configHeader,
                           WORK_BUFFER_SIZE);

    if (!NT_SUCCESS(status)) {
        printf("There is no disk registry information (%x)\n", status);
        free(configHeader);
        NtClose(handle);
        return;
    }

    diskRegistry = (PDISK_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->DiskInformationOffset);

    diskDescription = &diskRegistry->Disks[0];
    for (outerLoop = 0;
         outerLoop < diskRegistry->NumberOfDisks;
         outerLoop++) {

        for (innerLoop = 0;
             innerLoop < diskDescription->NumberOfPartitions;
             innerLoop++) {

            partitionDescription = &diskDescription->Partitions[innerLoop];

            if ((partitionDescription->FtType == (FT_TYPE) Type) &&
                (partitionDescription->FtGroup == (USHORT) Group) &&
                (partitionDescription->FtMember == (USHORT) Member)) {

                partitionDescription->FtState = NewState;
                writeBackRegistry = TRUE;
                break;
            }
        }

        if (writeBackRegistry == TRUE) {
            ULONG size;

            if (configHeader->FtInformationSize == 0) {
                printf("Seems a little odd to be setting FT state " // no comma
                       "with no FT information...\n");
                size = configHeader->DiskInformationOffset +
                       configHeader->DiskInformationSize;
            } else {
                size = configHeader->FtInformationOffset +
                       configHeader->FtInformationSize;
            }

            (VOID) FtSetValue(handle,
                              (PUCHAR) DISK_REGISTRY_VALUE,
                              (PUCHAR) configHeader,
                              size,
                              REG_BINARY);
            break;
        }
        diskDescription = (PDISK_DESCRIPTION)
              &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    NtClose(handle);
    free(configHeader);
}


VOID
RestoreOrphan(
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member
    )

/*++

Routine Description:

    Set the FT state for a partition back to Healthy.

Arguments:

    Type   - the FT type.
    Group  - the FT Group number for that type.
    Member - the member number within the group.

Return Values:

    None.

--*/

{
    ChangeMemberState(Type,
                      Group,
                      Member,
                      Healthy);
}


VOID
OrphanMember(
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member
    )

/*++

Routine Description:

    Set the FT state for a partition to Orphaned.

Arguments:

    Type   - the FT type.
    Group  - the FT Group number for that type.
    Member - the member number within the group.

Return Values:

    None.

--*/

{
    ChangeMemberState(Type,
                      Group,
                      Member,
                      Orphaned);
}


VOID
RegenerateMember(
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member
    )

/*++

Routine Description:

    Set the FT state for a partition to regenerate.

Arguments:

    Type   - the FT type.
    Group  - the FT Group number for that type.
    Member - the member number within the group.

Return Values:

    None.

--*/

{
    ChangeMemberState(Type,
                      Group,
                      Member,
                      Regenerating);
}


VOID
FixDisk()

/*++

Routine Description:

    Fix the disk signatures in the registry.

Arguments:

    None.

Return Values:

    None.

--*/

{
    ULONG               outerLoop;
    ULONG               innerLoop;
    ULONG               length;
    HANDLE              handle;
    NTSTATUS            status;
    PDISK_CONFIG_HEADER configHeader;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    PFT_REGISTRY        ftRegistry;
    PFT_DESCRIPTION     ftDescription;
    PFT_MEMBER_DESCRIPTION ftMember;
    UCHAR               prompt[128];
    PUCHAR              hexString;
    BOOLEAN             changed = FALSE;

    status = FtOpenKey(&handle,
                       DISK_REGISTRY_KEY);

    if (!NT_SUCCESS(status)) {
        printf("Currently there is no key in the registry"
               " for the disk information.\n");
        return;
    }

    configHeader = (PDISK_CONFIG_HEADER) malloc(WORK_BUFFER_SIZE);
    if (configHeader == NULL) {
        printf("Unable to allocate memory for the disk registy information.\n");
        NtClose(handle);
        return;
    }

    RtlZeroMemory(configHeader, WORK_BUFFER_SIZE);

    status = FtReturnValue(handle,
                           (PUCHAR) DISK_REGISTRY_VALUE,
                           (PUCHAR) configHeader,
                           WORK_BUFFER_SIZE);

    if (!NT_SUCCESS(status)) {
        printf("There is no disk registry information (%x)\n", status);
        free(configHeader);
        NtClose(handle);
        return;
    }

    diskRegistry = (PDISK_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->DiskInformationOffset);
    printf("\nDisk information for %d disks:\n",
           diskRegistry->NumberOfDisks);

    diskDescription = &diskRegistry->Disks[0];
    for (outerLoop = 0;
         outerLoop < diskRegistry->NumberOfDisks;
         outerLoop++) {

        sprintf(prompt,
               "\nDisk %d signature 0x%08x = ",
               outerLoop,
               diskDescription->Signature);

        hexString = GetArgumentString((BOOLEAN) FALSE,
                                      prompt,
                                      (BOOLEAN) TRUE);

        if (hexString != NULL) {

            changed = ProcessHex(hexString, &diskDescription->Signature);
        }

        diskDescription = (PDISK_DESCRIPTION)
          &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    //
    // Print the information for FT.
    //

    if (configHeader->FtInformationSize == 0) {
        printf("There is no FT configuration.\n");
        free(configHeader);
        NtClose(handle);
        return;
    }

    ftRegistry = (PFT_REGISTRY)
                 ((PUCHAR) configHeader + configHeader->FtInformationOffset);

    printf("\nNumber of FT components = %d\n",
           ftRegistry->NumberOfComponents);

    ftDescription = &ftRegistry->FtDescription[0];
    for (outerLoop = 0;
         outerLoop < ftRegistry->NumberOfComponents;
         outerLoop++) {

        printf("Component %d has %d members and is type %d\n",
               outerLoop,
               ftDescription->NumberOfMembers,
               ftDescription->Type);

        for (innerLoop = 0;
             innerLoop < ftDescription->NumberOfMembers;
             innerLoop++) {
            ftMember = &ftDescription->FtMemberDescription[innerLoop];

            sprintf(prompt,
                    "FT Member Signature 0x%x = ",
                    ftMember->Signature);

            hexString = GetArgumentString((BOOLEAN) FALSE,
                                          prompt,
                                          (BOOLEAN) TRUE);

            if (hexString != NULL) {

                changed = ProcessHex(hexString, &ftMember->Signature);
            }
        }

        ftDescription = (PFT_DESCRIPTION)
         &ftDescription->FtMemberDescription[ftDescription->NumberOfMembers];
    }

    if (changed == TRUE) {

        printf("Attempting to update registry information.\n");

        //
        // Delete the current registry value and write the new one.
        //

        status = FtDeleteValue(handle,
                               DISK_REGISTRY_VALUE);

        if (!NT_SUCCESS(status)) {
            printf("Could not delete value (0x%x).\n", status);
        } else {

            length = (ULONG) ((PCHAR)ftDescription - (PUCHAR)configHeader);
            status = FtSetValue(handle,
                                DISK_REGISTRY_VALUE,
                                configHeader,
                                length,
                                REG_BINARY);
            if (!NT_SUCCESS(status)) {
                printf("Could not write value (0x%x)\n.", status);
            }
        }
    }

    NtClose(handle);
}

PDISK_CONFIG_HEADER
GetDiskInfo()

/*++

--*/

{
    HANDLE              handle;
    ULONG               length;
    NTSTATUS            status;
    PDISK_CONFIG_HEADER configHeader;

    status = FtOpenKey(&handle,
                       DISK_REGISTRY_KEY);

    if (!NT_SUCCESS(status)) {
        printf("Currently there is no key in the registry"
               " for the disk information.\n");
        return NULL;
    }

    configHeader = (PDISK_CONFIG_HEADER) malloc(WORK_BUFFER_SIZE);
    if (configHeader == NULL) {
        printf("Unable to allocate memory for the disk registy information.\n");
        NtClose(handle);
        return NULL;
    }

    RtlZeroMemory(configHeader, WORK_BUFFER_SIZE);

    status = FtReturnValue(handle,
                           (PUCHAR) DISK_REGISTRY_VALUE,
                           (PUCHAR) configHeader,
                           WORK_BUFFER_SIZE);
    NtClose(handle);

    if (!NT_SUCCESS(status)) {
        printf("There is no disk registry information (%x)\n", status);
        free(configHeader);
        return NULL;
    }

    return configHeader;
}


BOOLEAN
CreateFtMember(
    IN PDISK_CONFIG_HEADER ConfigHeader,
    IN ULONG Disk,
    IN ULONG Partition,
    IN ULONG Type,
    IN ULONG Group,
    IN ULONG Member
    )

/*++

--*/

{
    ULONG               innerLoop;
    ULONG               outerLoop;
    ULONG               length;
    NTSTATUS            status;
    PDISK_REGISTRY      diskRegistry;
    PDISK_DESCRIPTION   diskDescription;
    PDISK_PARTITION     diskPartition;

    diskRegistry = (PDISK_REGISTRY)
                 ((PUCHAR) ConfigHeader + ConfigHeader->DiskInformationOffset);
    diskDescription = &diskRegistry->Disks[0];

    //
    // Have to walk the disk information by hand to find a match on
    // disk number and partition
    //

    for (outerLoop = 0;
         outerLoop < diskRegistry->NumberOfDisks;
         outerLoop++) {

        if (outerLoop == Disk) {
            for (innerLoop = 0;
                 innerLoop < diskDescription->NumberOfPartitions;
                 innerLoop++) {
                diskPartition = &diskDescription->Partitions[innerLoop];
    
                if (diskPartition->LogicalNumber == Partition) {
    
                    //
                    // Found a match.
                    //

                    diskPartition->FtType = Type;
                    diskPartition->FtMember = Member;
                    diskPartition->FtGroup = Group;
                    diskPartition->FtState = Healthy;
                    diskPartition->AssignDriveLetter = FALSE;
                    return TRUE;
                }
            }
        }

        diskDescription = (PDISK_DESCRIPTION)
          &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    //
    // Didn't find it.
    //

    return FALSE;
}


#define DRIVER_KEY "\\REGISTRY\\MACHINE\\System\\CurrentControlSet\\Services"

#define TYPE_KEY     "Type"
#define START_KEY    "Start"
#define GROUP_KEY    "Group"
#define DEPENDENCIES "DependOnGroup"

#if 0
VOID
DisplayLoadInformation(
    IN PUNICODE_STRING DriverKey
    )

/*++

Routine Description:


Arguments:

    DriverKey - a Unicode string pointer for the driver key name.

Return Value:

    None.

--*/

{
    HANDLE         keyHandle;
    UNICODE_STRING unicodeKeyName;
    UNICODE_STRING unicodeValueName;
    ULONG          resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    resultLength = WORK_BUFFER_SIZE;
    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)malloc(WORK_BUFFER_SIZE);

    //
    // Type
    //

    //
    // Start
    //

    //
    // Group
    //

    //
    // DependOnGroup
    //

    while (1) {

        RtlZeroMemory(keyValueInformation, resultLength);
        status = NtEnumerateValueKey(KeyHandle,
                                     0,
                                     KeyValueFullInformation,
                                     keyValueInformation,
                                     resultLength,
                                     &resultLength);

        if (status == STATUS_BUFFER_OVERFLOW) {
            free(keyValueInformation);
            keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                       malloc(resultLength + 10);
        } else {
            break;
        }
    }

    free(keyValueInformation);
    NtClose(keyHandle);
}
#else
VOID
DisplayLoadInformation(
    IN PUCHAR DriverKey
    )
{
    UNREFERENCED_PARAMETER(DriverKey);
}
#endif



#define TEMP_BUFFER_SIZE 256
VOID
ListDrivers()

/*++

Routine Description:

    Got to the load list for the drivers, interpret and display what is there.

Arguments:

    None.

Return Value:

    NONE

--*/

{
    int            index;
    NTSTATUS       status;
    HANDLE         keyHandle;
    ULONG          resultLength;
    UCHAR          tempBuffer[TEMP_BUFFER_SIZE];
    ANSI_STRING    ansiString;
    UNICODE_STRING unicodeValueName;
    PKEY_BASIC_INFORMATION keyInformation;

    keyInformation = (PKEY_BASIC_INFORMATION)malloc(WORK_BUFFER_SIZE);

    status = FtOpenKey(&keyHandle, DRIVER_KEY);

    if (!NT_SUCCESS(status)) {

        printf("Could not open Services key (0x%x).\n", status);
        return;
    }

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(keyInformation, WORK_BUFFER_SIZE);

        status = NtEnumerateKey(keyHandle,
                                index,
                                KeyBasicInformation,
                                keyInformation,
                                WORK_BUFFER_SIZE,
                                &resultLength);

        if (status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(status)) {

            printf("readreg: Error on Enumerate status = %x\n", status);
            break;

        }

        unicodeValueName.Length = (USHORT)keyInformation->NameLength;
        unicodeValueName.MaximumLength = (USHORT)keyInformation->NameLength;
        unicodeValueName.Buffer = (PWSTR)&keyInformation->Name[0];

        ansiString.MaximumLength = TEMP_BUFFER_SIZE;
        ansiString.Length = 0L;
        ansiString.Buffer = &tempBuffer[0];

        RtlUnicodeStringToAnsiString(&ansiString,
                                     &unicodeValueName,
                                     (BOOLEAN) FALSE);

        //
        // Now have the key name for the driver - concatenate it and
        // call the routine to display what is in the key.
        //

        sprintf(WorkingDirectory,
                "%s\\%s",
                DRIVER_KEY,
                tempBuffer);

        DisplayLoadInformation(WorkingDirectory);
    }

    free(keyInformation);
    NtClose(keyHandle);
}


VOID
main()

/*++

Routine Description:

    The main entry point for the user process.
    This process will prompt the user for the action desired.  This
    includes starting performance, stopping performance, and retreiving
    performance data collected by the FT driver.

Arguments:

    Command line:
        No options.

Return Value:

    NONE

--*/

{
    NTSTATUS status;
    BOOLEAN  batch;
    PUCHAR   argumentString;
    int      commandCode;
    HANDLE   keyHandle;


    status = FtOpenKey(&keyHandle, REGISTRY_BASE);

    if (!NT_SUCCESS(status)) {

        printf("readreg: Unable to open registry base (0x%x)\n", status);
        exit(1);
    }

    sprintf(CurrentDirectory,
            REGISTRY_BASE);

    //
    // See if we are connected to CON
    //

    batch = FALSE;
//  batch = (BOOLEAN)(!isatty(0));

    if (!batch) {
        printf("FT registry edit utility.  %s:\n", Version);
    }

    while(1) {
        while ((commandCode = GetCommand(batch,
                                         &argumentString)) == INVALID) {

            //
            // Continue until we get a valid command.
            //

        }

        if (Debug) {
            printf("Command code == %d, argumentString = %s\n",
                   commandCode,
                   (argumentString == NULL) ? "(none)" : argumentString);
        }

        switch (commandCode) {

        case DIRLONG:

            Directory(keyHandle, (BOOLEAN) TRUE);
            break;

        case DIR:

            Directory(keyHandle, (BOOLEAN) FALSE);
            break;

        case CREATE:
        {
            ULONG   index;
            PUCHAR  keyClass;
            BOOLEAN classAllocated = FALSE;

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "Key Name = ", 
                                                   (BOOLEAN) FALSE);
            }

            if (argumentString == NULL) {
                break;
            }

            sprintf(WorkingDirectory,
                    "%s\\%s",
                    CurrentDirectory,
                    argumentString);

            argumentString = GetArgumentString(batch,
                                               "Key Class = ",
                                               (BOOLEAN) FALSE);

            if (argumentString == NULL) {
                keyClass = "Default Class";
            } else {
                keyClass = (PUCHAR) malloc(strlen(argumentString) + FUDGE);
                classAllocated = TRUE;

                sprintf(keyClass,
                        "%s",
                        argumentString);
            }

            argumentString = GetArgumentString(batch,
                                               "Index = ",
                                               (BOOLEAN) TRUE);

            if (argumentString == NULL) {
                index = 1;
            } else {
                index = ParseArgumentNumeric(&argumentString);
            }

            if (Debug) {
                printf("Creating key %s, index %d with class %s\n",
                       WorkingDirectory,
                       index,
                       keyClass);
            }

            status = FtCreateKey(WorkingDirectory,
                                 keyClass,
                                 index);

            if (!NT_SUCCESS(status)) {

                printf("Could not create key %s (0x%x).\n",
                       WorkingDirectory,
                       status);
            }

            if (classAllocated == TRUE) {
                free(keyClass);
            }

            break;
        }

        case LIST:

            List(keyHandle,
                 argumentString);
            break;

        case CHDIR:

            NtClose(keyHandle);

            if (argumentString == NULL) {

                argumentString = GetArgumentString(batch,
                                                   "New location = ",
                                                   (BOOLEAN) TRUE);
            }

            if (argumentString != NULL) {

                if (*argumentString == '\\') {

                    //
                    // Root relative string.
                    // Use text provided (i.e. %s is to avoid user crashing
                    // by putting %s in the string).
                    //

                    sprintf(WorkingDirectory,
                            "%s",
                            argumentString);

                } else {

                    while ((*argumentString == '.') &&
                           (*(argumentString + 1) == '.')) {

                        if ((*(argumentString + 2) == '\\') ||
                            (*(argumentString + 2) == '\0')) {

                            PUCHAR cptr = CurrentDirectory;

                            //
                            // move argumentString past ".."
                            //

                            argumentString += 2;

                            //
                            // Find end of current directory.
                            //

                            while (*cptr != '\0') {
                                cptr++;
                            }

                            //
                            // Backup to last component.
                            //

                            while (*cptr != '\\') {
                                cptr--;
                            }

                            if (cptr == CurrentDirectory) {

                                //
                                // Cannot backup anymore.  Continue parsing
                                // argument.
                                //

                                continue;
                            }

                            //
                            // Remove component from path.
                            //

                            *cptr = '\0';

                            if (*argumentString == '\0') {

                                //
                                // All done with argument.
                                //

                                break;
                            }

                            //
                            // Step around backslash.
                            //

                            argumentString++;

                        } else {

                            //
                            // Assume it is a real name.
                            //

                            break;
                        }
                    }

                    if (*argumentString != '\0') {
                        sprintf(WorkingDirectory,
                                "%s\\%s",
                                CurrentDirectory,
                                argumentString);
                    } else {
                        sprintf(WorkingDirectory,
                                "%s",
                                CurrentDirectory);
                    }
                }

                status = FtOpenKey(&keyHandle,
                                   WorkingDirectory);

                if (NT_SUCCESS(status)) {

                    sprintf(CurrentDirectory,
                            "%s",
                            WorkingDirectory);
                } else {

                    (VOID) FtOpenKey(&keyHandle,
                                     CurrentDirectory);

                    //
                    // No error checks because this was opened once before.
                    //
                }

            }

            break;

        case HELP:
        {
            int i;

            printf("Valid commands are:\n");

            for (i = 0; Commands[i] != NULL; i++) {
                printf("  %10s  - %s\n",
                       Commands[i],
                       CommandHelp[CommandMap[i]]);
            }
            break;
        }

        case QUIT:

            exit(0);
            break;

        case DDEBUG:

            if (argumentString == NULL) {

                if (Debug) {

                    printf("Debug turned off.\n");
                    Debug = 0;
                } else {

                    Debug = 1;
                }
            } else {

                Debug = atoi(argumentString);
                printf("Debug set to %d\n", Debug);
            }
            break;

        case SETVALUE:
        {
            int    i;
            BOOLEAN convertToUnicode = FALSE;
            PUCHAR valueName;
            PUCHAR valueData;
            ULONG  valueLength;
            ULONG  valueWord;
            PVOID  valuePtr;
            ULONG  type = DEFAULT_TYPE;
            STRING         valueString;
            UNICODE_STRING unicodeValue;
            BOOLEAN dataAllocated = FALSE;
            BOOLEAN unicodeAllocated = FALSE;

            if (argumentString == NULL) {

                argumentString = GetArgumentString(batch,
                                                   "Value Name = ",
                                                   (BOOLEAN) FALSE);
            }

            if (argumentString == NULL) {

                break;
            }

            valueName = (PUCHAR) malloc(strlen(argumentString) + FUDGE);

            sprintf(valueName,
                    "%s",
                    argumentString);

            //
            // print a help banner on type and get the type.
            //

            for (i = 0; TypeNames[i] != NULL; i++) {

                printf("%d - %s\n", TypeNumbers[i], TypeNames[i]);
            }
            printf("# - Other numbers are user defined\n");
            argumentString = GetArgumentString(batch,
                                               "Numeric value for type = ",
                                               (BOOLEAN) TRUE);

            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            }

            switch(type)
            {
            default:
            case REG_SZ:
                if (type == REG_SZ) {
                    convertToUnicode = TRUE;
                    printf("Typed in string will be converted to unicode...\n");
                    argumentString = GetArgumentString(batch,
                                                       "Value Data = ",
                                                       (BOOLEAN) FALSE);
                } else {
                    printf("For now the data must be typed in...\n");
                    argumentString = GetArgumentString(batch,
                                                       "Value Data = ",
                                                       (BOOLEAN) FALSE);
                }

                if (argumentString == NULL) {
                    valueData = "Default Data";
                    valueLength = strlen(valueData);
                } else {
                    valueData = (PUCHAR) malloc(strlen(argumentString) + FUDGE);
                    dataAllocated = TRUE;
                    sprintf(valueData,
                            "%s",
                            argumentString);
                    if (convertToUnicode == TRUE) {
                        RtlInitString(&valueString,
                                      valueData);
                        RtlAnsiStringToUnicodeString(&unicodeValue,
                                                     &valueString,
                                                     (BOOLEAN) TRUE);
                        unicodeAllocated = TRUE;
                        valueLength = unicodeValue.Length + 2;
                    } else {
                        valueLength = strlen(valueData);
                    }
                }

                break;

            case REG_DWORD:
                argumentString = GetArgumentString(batch,
                                                   "Value Data Word = ",
                                                   (BOOLEAN) TRUE);
                if (argumentString == NULL) {
                    valueWord = 0;
                } else {
                    valueWord = ParseArgumentNumeric(&argumentString);
                }

                valueLength = sizeof(ULONG);
                break;
            }

            switch (type) {

            case REG_DWORD:
                valuePtr = (PVOID) &valueWord;
                break;

            case REG_SZ:
                valuePtr = (PVOID) unicodeValue.Buffer;
                break;

            default:
                valuePtr = (PVOID) valueData;
                break;
            }
            status = FtSetValue(keyHandle,
                                valueName,
                                valuePtr,
                                valueLength,
                                type);

            if (!NT_SUCCESS(status)) {
                printf("Could not set value %s (0x%x).\n", valueName, status);
            }

            free(valueName);
            if (dataAllocated == TRUE) {
                free(valueData);
            }
            if (unicodeAllocated == TRUE) {
                RtlFreeUnicodeString(&unicodeValue);
            }
            break;
        }

        case DELKEY:
        {
            if (argumentString == NULL) {

                argumentString = GetArgumentString(batch,
                                                   "Key Name = ",
                                                   (BOOLEAN) TRUE);
            }

            if (argumentString == NULL) {

                break;
            }

            sprintf(WorkingDirectory,
                    "%s\\%s",
                    CurrentDirectory,
                    argumentString);

            status = FtDeleteKey(WorkingDirectory);

            if (!NT_SUCCESS(status)) {
                printf("Unable to delete key %s (0x%x)\n",
                       WorkingDirectory,
                       status);
            }

            break;
        }

        case DELVALUE:
        {
            if (argumentString == NULL) {

                argumentString = GetArgumentString(batch,
                                                   "Key Name = ",
                                                   (BOOLEAN) TRUE);
            }

            if (argumentString == NULL) {

                break;
            }

            status = FtDeleteValue(keyHandle,
                                   argumentString);

            if (!NT_SUCCESS(status)) {

                printf("Unable to delete value %s (0x%x)\n",
                       argumentString,
                       status);
            }
            break;
        }

        case INLONG:
            DumpControl = InLongs;
            break;

        case INSHORT:
            DumpControl = InShorts;
            break;

        case INBYTE:
            DumpControl = InBytes;
            break;

        case DUMP:

            if (ForceDump) {
                ForceDump = 0;
            } else {
                ForceDump++;
            }
            break;

        case DISKREG:
            DiskDump();
            break;

        case FIXDISK:
            FixDisk();
            break;

        case RESTORE:
        {
            ULONG type;
            ULONG group;
            ULONG member;

            printf("FT types that can be restored are:\n");
            printf("\t%d - for Mirrors\n", Mirror);
            printf("\t%d - for Stripes with parity\n", StripeWithParity);

            //
            // Get the type
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT volume type = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the group
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT group number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the member
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT member number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                member = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            RestoreOrphan(type, group, member);
            break;
        }

        case DRIVERS:
            NotImplemented();
            // ListDrivers();
            break;

        case ORPHAN:
        {
            ULONG type;
            ULONG group;
            ULONG member;

            printf("FT types that can be orphaned are:\n");
            printf("\t%d - for Mirrors\n", Mirror);
            printf("\t%d - for Stripes with parity\n", StripeWithParity);

            //
            // Get the type
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT volume type = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the group
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT group number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the member
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT member number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                member = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            OrphanMember(type, group, member);
            break;
        }

        case REGEN:
        {
            ULONG type;
            ULONG group;
            ULONG member;

            printf("FT types that can be regenerated are:\n");
            printf("\t%d - for Mirrors\n", Mirror);
            printf("\t%d - for Stripes with parity\n", StripeWithParity);

            //
            // Get the type
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT volume type = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the group
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT group number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            //
            // Get the member
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "FT member number = ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                member = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            RegenerateMember(type, group, member);
            break;
        }

        case INIT:
        {
            ULONG type;
            ULONG group;
            ULONG member;

            printf("Only stripes with parity are initialized.\n");

            //
            // Get the group
            //

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                               "Parity stripe group number = ",
                                               (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            ChangeMemberState(StripeWithParity,
                              group,
                              0,
                              Initializing);
            break;
        }

        case MAKEFT:
        {
            ULONG type;
            ULONG group;
            ULONG member;
            ULONG disk;
            ULONG partition;
            PDISK_CONFIG_HEADER configHeader;
            BOOLEAN doUpdate = TRUE;

            configHeader = GetDiskInfo();
            if (configHeader == NULL) {
                break;
            }
            printf("\t%d for Mirrors\n", Mirror);
            printf("\t%d for Stripe Set\n", Stripe);
            printf("\t%d for Stripe with parity\n", StripeWithParity);
            printf("\t%d for Volume Set\n", VolumeSet);

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "Which FT set to create? ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                type = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            if (argumentString == NULL) {
                argumentString = GetArgumentString(batch,
                                                   "Please give an FT group # - ",
                                                   (BOOLEAN) TRUE);
            }
            if (argumentString != NULL) {
                group = ParseArgumentNumeric(&argumentString);
            } else {
                break;
            }

            for (member = 0; TRUE; member++) {
                printf("Information for member %d\n", member);

                if (argumentString == NULL) {
                    argumentString = GetArgumentString(batch,
                                                       "Disk Number = ",
                                                       (BOOLEAN) TRUE);
                }

                if (argumentString != NULL) {
                    disk = ParseArgumentNumeric(&argumentString);
                } else {
                    break;
                }

                if (argumentString == NULL) {
                    argumentString = GetArgumentString(batch,
                                                       "Partition Number = ",
                                                       (BOOLEAN) TRUE);
                }

                if (argumentString != NULL) {
                    partition = ParseArgumentNumeric(&argumentString);
                } else {
                    break;
                }

                if (CreateFtMember(configHeader, disk, partition, type, group, member) == FALSE) {
                    printf("Failed to change member state\n");
                    printf("No update will be made\n");
                    doUpdate = FALSE;
                    break;
                }
            }
            if (doUpdate == TRUE) {
                PDISK_REGISTRY diskRegistry;
                diskRegistry = (PDISK_REGISTRY)
                             ((PUCHAR) configHeader + configHeader->DiskInformationOffset);
                DiskRegistrySet(diskRegistry);
            }
            free(configHeader);
            break;
        }

        default:

            printf("WDF homer?!?\n");
            break;
        }
    }
} // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\ia64\initia64.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    initia64.c

Abstract:

    This module is responsible for building any IA64 specific entries in
    the hardware tree of the registry.

Author:

    Ken Reneris (kenr) 04-Aug-1992


Environment:

    Kernel mode.

Revision History:

    shielint - add BIOS date and version detection.

--*/

#include "cmp.h"
#include "stdio.h"
#include "smbios.h"


//
// Title Index is set to 0.
// (from ..\cmconfig.c)
//

#define TITLE_INDEX_VALUE 0

extern PCHAR SearchStrings[];
extern PCHAR BiosBegin;
extern PCHAR Start;
extern PCHAR End;
extern CHAR CmpID[];
extern WCHAR CmpVendorID[];
extern WCHAR CmpProcessorNameString[];
extern WCHAR CmpFeatureBits[];
extern WCHAR CmpMHz[];
extern WCHAR CmpUpdateSignature[];
extern CHAR CmpIntelID[];
extern CHAR CmpItanium[];
extern CHAR CmpItanium2[];

//
// Bios date and version definitions
//

#define BIOS_DATE_LENGTH 64
#define MAXIMUM_BIOS_VERSION_LENGTH 128

WCHAR   SystemBIOSDateString[BIOS_DATE_LENGTH];
WCHAR   SystemBIOSVersionString[MAXIMUM_BIOS_VERSION_LENGTH];
WCHAR   VideoBIOSDateString[BIOS_DATE_LENGTH];
WCHAR   VideoBIOSVersionString[MAXIMUM_BIOS_VERSION_LENGTH];

//
// Extended CPUID function definitions
//

#define CPUID_PROCESSOR_NAME_STRING_SZ  65
#define CPUID_EXTFN_BASE                0x80000000
#define CPUID_EXTFN_PROCESSOR_NAME      0x80000002


extern ULONG CmpConfigurationAreaSize;
extern PCM_FULL_RESOURCE_DESCRIPTOR CmpConfigurationData;


BOOLEAN
CmpGetBiosVersion (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR VersionString
    );

BOOLEAN
CmpGetBiosDate (
    PCHAR SearchArea,
    ULONG SearchLength,
    PCHAR DateString
    );

ULONG
Ke386CyrixId (
    VOID
    );

VOID
InitializeProcessorInformationFromSMBIOS(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,CmpInitializeMachineDependentConfiguration)
#pragma alloc_text(INIT,InitializeProcessorInformationFromSMBIOS)
#endif


NTSTATUS
CmpInitializeMachineDependentConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine creates IA64 specific entries in the registry.

Arguments:

    LoaderBlock - supplies a pointer to the LoaderBlock passed in from the
                  OS Loader.

Returns:

    NTSTATUS code for sucess or reason of failure.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UNICODE_STRING ValueData;
    ANSI_STRING AnsiString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;
    HANDLE ParentHandle;
    HANDLE BaseHandle, NpxHandle;
    CONFIGURATION_COMPONENT_DATA CurrentEntry;
    PCHAR VendorID;
    CHAR  Buffer[MAXIMUM_BIOS_VERSION_LENGTH];
    PKPRCB Prcb;
    ULONG  i;
    USHORT DeviceIndexTable[NUMBER_TYPES];

    for (i = 0; i < NUMBER_TYPES; i++) {
        DeviceIndexTable[i] = 0;
    }


    //
    // Go get a bunch of information out of SMBIOS
    //
    InitializeProcessorInformationFromSMBIOS(LoaderBlock);



    InitializeObjectAttributes( &ObjectAttributes,
                                &CmRegistryMachineHardwareDescriptionSystemName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtOpenKey( &ParentHandle,
                        KEY_READ,
                        &ObjectAttributes
                      );

    if (!NT_SUCCESS(Status)) {
        // Something is really wrong...
        return Status;
    }


    //
    // On an ARC machine the processor(s) are included in the hardware
    // configuration passed in from bootup.  Since there's no standard
    // way to get all the ARC information for each processor in an MP
    // machine via pc-ROMs the information will be added here (if it's
    // not already present).
    //

    RtlInitUnicodeString( &KeyName,
                          L"CentralProcessor"
                        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        ParentHandle,
        NULL
        );

    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtCreateKey(
                &BaseHandle,
                KEY_READ | KEY_WRITE,
                &ObjectAttributes,
                TITLE_INDEX_VALUE,
                &CmClassName[ProcessorClass],
                0,
                &Disposition
                );

    NtClose (BaseHandle);

    if (Disposition == REG_CREATED_NEW_KEY) {

        //
        // The ARC rom didn't add the processor(s) into the registry.
        // Do it now.
        //

        CmpConfigurationData = (PCM_FULL_RESOURCE_DESCRIPTOR)ExAllocatePool(
                                            PagedPool,
                                            CmpConfigurationAreaSize
                                            );

        if (CmpConfigurationData == NULL) {
            // bail out
            NtClose (ParentHandle);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        for (i=0; i < (ULONG)KeNumberProcessors; i++) {
            Prcb = KiProcessorBlock[i];

            RtlZeroMemory (&CurrentEntry, sizeof CurrentEntry);
            CurrentEntry.ComponentEntry.Class = ProcessorClass;
            CurrentEntry.ComponentEntry.Type = CentralProcessor;
            CurrentEntry.ComponentEntry.Key = i;
            CurrentEntry.ComponentEntry.AffinityMask = (ULONG)AFFINITY_MASK(i);

            CurrentEntry.ComponentEntry.Identifier = Buffer;

            sprintf( Buffer, CmpID,
                     Prcb->ProcessorFamily,
                     Prcb->ProcessorModel,
                     Prcb->ProcessorRevision
                   );

            CurrentEntry.ComponentEntry.IdentifierLength =
                (ULONG)(strlen (Buffer) + 1);

            Status = CmpInitializeRegistryNode(
                &CurrentEntry,
                ParentHandle,
                &BaseHandle,
                -1,
                (ULONG)-1,
                DeviceIndexTable
                );

            if (!NT_SUCCESS(Status)) {
                return(Status);
            }

            VendorID = (PCHAR) Prcb->ProcessorVendorString;
            if ( *VendorID == '\0' ) {
               VendorID = NULL;
            }

            if (VendorID) {

                //
                // Add Vendor Indentifier to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpVendorID
                    );

                RtlInitAnsiString(
                    &AnsiString,
                    VendorID
                    );

                Status = RtlAnsiStringToUnicodeString(
                            &ValueData,
                            &AnsiString,
                            TRUE
                            );
                
                if( NT_SUCCESS(Status) ) {
                    Status = NtSetValueKey(
                                BaseHandle,
                                &ValueName,
                                TITLE_INDEX_VALUE,
                                REG_SZ,
                                ValueData.Buffer,
                                ValueData.Length + sizeof( UNICODE_NULL )
                                );

                    RtlFreeUnicodeString(&ValueData);
                }
            }

            if ( VendorID && !strcmp( VendorID, CmpIntelID ) )   {

                PCHAR processorNameString;

                //
                // Add Processor Name String to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpProcessorNameString
                    );

                switch( Prcb->ProcessorFamily )  {
                   case 0x07:
                       processorNameString = CmpItanium;
                       break;
   
                   case 0x1F:
                   default:
                       //
                       // Default to the most recent known family
                       //
                       
                       processorNameString = CmpItanium2;
                       break;
                }

                RtlInitAnsiString(
                    &AnsiString,
                    processorNameString
                    );

                Status = RtlAnsiStringToUnicodeString(
                            &ValueData,
                            &AnsiString,
                            TRUE
                            );

                if( NT_SUCCESS(Status) ) {
                    Status = NtSetValueKey(
                                BaseHandle,
                                &ValueName,
                                TITLE_INDEX_VALUE,
                                REG_SZ,
                                ValueData.Buffer,
                                ValueData.Length + sizeof( UNICODE_NULL )
                                );

                    RtlFreeUnicodeString(&ValueData);
                }

            }


//
// If more processor IDs have to be restored or initialized,
// check non-IA64 implementations of this function.
//


            if ( Prcb->ProcessorFeatureBits ) {

                //
                // Add processor feature bits to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpFeatureBits
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_QWORD,
                            &Prcb->ProcessorFeatureBits,
                            sizeof( Prcb->ProcessorFeatureBits )
                            );
            }


            if (Prcb->MHz) {
                //
                // Add processor MHz to the registry
                //

                RtlInitUnicodeString(
                    &ValueName,
                    CmpMHz
                    );

                Status = NtSetValueKey(
                            BaseHandle,
                            &ValueName,
                            TITLE_INDEX_VALUE,
                            REG_DWORD,
                            &Prcb->MHz,
                            sizeof (Prcb->MHz)
                            );
            }


            //
            // Add ia32 floating point enties for iVE.
            //
            RtlZeroMemory (&CurrentEntry, sizeof CurrentEntry);
            CurrentEntry.ComponentEntry.Class = ProcessorClass;
            CurrentEntry.ComponentEntry.Type = FloatingPointProcessor;
            CurrentEntry.ComponentEntry.Key = i;
            CurrentEntry.ComponentEntry.AffinityMask = (ULONG)AFFINITY_MASK(i);

            CurrentEntry.ComponentEntry.Identifier = Buffer;

            //
            // The iVE is defined to look like the Pentium III FP
            // This is the value returned by the ia32 CPUID instruction
            // on Merced (Itanium)
            //
            strcpy (Buffer, "x86 Family 7 Model 0 Stepping 0");

            CurrentEntry.ComponentEntry.IdentifierLength =
                (ULONG)(strlen (Buffer) + 1);

            Status = CmpInitializeRegistryNode(
                &CurrentEntry,
                ParentHandle,
                &NpxHandle,
                -1,
                (ULONG)-1,
                DeviceIndexTable
                );


            //
            // How odd. Some calls check the status return value
            // and others don't. Is this based on required vs. optional
            // keys? For the moment, since it was checked on the i386
            // then do the check here too...
            //
            if (!NT_SUCCESS(Status)) {
                NtClose(BaseHandle);
                return(Status);
            }

            //
            // Only need to close the handle if we succeeded
            //
            NtClose(NpxHandle);

            NtClose(BaseHandle);
        }

        ExFreePool((PVOID)CmpConfigurationData);
    }


    //
    // Next we try to collect System BIOS date and version strings.
    //
    if( SystemBIOSDateString[0] != 0 ) {

        RtlInitUnicodeString(
            &ValueName,
            L"SystemBiosDate"
            );

        Status = NtSetValueKey(
                    ParentHandle,
                    &ValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    SystemBIOSDateString,
                    (ULONG)((wcslen(SystemBIOSDateString)+1) * sizeof( WCHAR ))
                    );

    }

    if( SystemBIOSVersionString[0] != 0 ) {

        RtlInitUnicodeString(
            &ValueName,
            L"SystemBiosVersion"
            );

        Status = NtSetValueKey(
                    ParentHandle,
                    &ValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    SystemBIOSVersionString,
                    (ULONG)((wcslen(SystemBIOSVersionString)+1) * sizeof( WCHAR ))
                    );

    }


    //
    // Next we try to collect Video BIOS date and version strings.
    //
    if( VideoBIOSDateString[0] != 0 ) {

        RtlInitUnicodeString(
            &ValueName,
            L"VideoBiosDate"
            );

        Status = NtSetValueKey(
                    ParentHandle,
                    &ValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    VideoBIOSDateString,
                    (ULONG)((wcslen(VideoBIOSDateString)+1) * sizeof( WCHAR ))
                    );

    }

    if( VideoBIOSVersionString[0] != 0 ) {

        RtlInitUnicodeString(
            &ValueName,
            L"VideoBiosVersion"
            );

        Status = NtSetValueKey(
                    ParentHandle,
                    &ValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    VideoBIOSVersionString,
                    (ULONG)((wcslen(VideoBIOSVersionString)+1) * sizeof( WCHAR ))
                    );

    }


    NtClose (ParentHandle);

    //
    // Add any other x86 specific code here...
    //

    return STATUS_SUCCESS;
}



VOID
InitializeProcessorInformationFromSMBIOS(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function attempts to load processor-specific information
    out of the SMBIOS table.  If present, that information will be
    used to initialize specific global variables.

Arguments:

    LoaderBlock : Pointer to the loaderblock as sent in from the loader.

Return Value:

    NONE.

--*/
{
    PLOADER_PARAMETER_EXTENSION     LoaderExtension;
    PSMBIOS_EPS_HEADER              SMBiosEPSHeader;
    PDMIBIOS_EPS_HEADER             DMIBiosEPSHeader;
    BOOLEAN                         Found = FALSE;
    PHYSICAL_ADDRESS                SMBiosTablePhysicalAddress = {0};
    PUCHAR                          StartPtr = NULL;
    PUCHAR                          EndPtr = NULL;
    PUCHAR                          SMBiosDataVirtualAddress = NULL;
    PSMBIOS_STRUCT_HEADER           Header = NULL;
    ULONG                           i = 0;
    UCHAR                           Checksum;


    PAGED_CODE();


    LoaderExtension = LoaderBlock->Extension;

    if (LoaderExtension->Size >= sizeof(LOADER_PARAMETER_EXTENSION)) {


        if (LoaderExtension->SMBiosEPSHeader != NULL) {

            //
            // Load the SMBIOS table address and checksum it just to make sure.
            //
            SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)LoaderExtension->SMBiosEPSHeader;
            DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader->Signature2[0];

            SMBiosTablePhysicalAddress.HighPart = 0;
            SMBiosTablePhysicalAddress.LowPart = DMIBiosEPSHeader->StructureTableAddress;

            StartPtr = (PUCHAR)SMBiosEPSHeader;
            Checksum = 0;
            for( i = 0; i < SMBiosEPSHeader->Length; i++ ) {
                Checksum = (UCHAR)(Checksum + StartPtr[i]);
            }
            if( Checksum != 0 ) {
                CmKdPrintEx((DPFLTR_CONFIG_ID,DPFLTR_TRACE_LEVEL,"InitializeProcessorInformationFromSMBIOS: _SM_ table has an incorrect checksum.\n"));
                return;
            }



            //
            // Map the table into a virtual address and search it.
            //
            SMBiosDataVirtualAddress = MmMapIoSpace( SMBiosTablePhysicalAddress,
                                                     DMIBiosEPSHeader->StructureTableLength,
                                                     MmCached );

            if( SMBiosDataVirtualAddress != NULL ) {

                //
                // Search...
                //
                StartPtr = SMBiosDataVirtualAddress;
                EndPtr = StartPtr + DMIBiosEPSHeader->StructureTableLength;
                Found = FALSE;
                while( (StartPtr < EndPtr) ) {

                    if (StartPtr + sizeof(SMBIOS_STRUCT_HEADER) > EndPtr) {
                        break;
                    }

                    Header = (PSMBIOS_STRUCT_HEADER)StartPtr;


                    if( Header->Type == SMBIOS_BIOS_INFORMATION_TYPE ) {

                        PSMBIOS_BIOS_INFORMATION_STRUCT InfoHeader = (PSMBIOS_BIOS_INFORMATION_STRUCT)StartPtr;
                        PUCHAR      StringPtr = NULL;
                        PUCHAR      StringEndPtr = NULL;

                        if (StartPtr + sizeof(SMBIOS_BIOS_INFORMATION_STRUCT) > EndPtr) {
                            break;
                        }

                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: SMBIOS_BIOS_INFORMATION\n"));

                        //
                        // Load the System BIOS Version information.
                        //


                        // Now jump to the BiosInfoHeader->BIOSVersion-th string which
                        // is appended onto the end of the formatted section of the table.

                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the version string is at offset: %d\n", (ULONG)InfoHeader->Version));
                        if( (ULONG)InfoHeader->Version > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->Version-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }

                            //
                            // Make sure the end string is null terminated in the buffer.
                            //

                            StringEndPtr = StringPtr;
                            while (StringEndPtr < EndPtr && *(StringEndPtr) != 0) {
                                StringEndPtr++;
                            }
                            
                            // StringPtr should be sitting at the BIOSVersion string.  Convert him to
                            // Unicode and save it off.
                            if( StringEndPtr < EndPtr ) {
                                UNICODE_STRING  UnicodeString;
                                ANSI_STRING    AnsiString;

                                KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I'm about to load the Version string %s\n", StringPtr));
                                UnicodeString.Buffer = SystemBIOSVersionString;
                                UnicodeString.MaximumLength = MAXIMUM_BIOS_VERSION_LENGTH;
                                RtlInitAnsiString(
                                    &AnsiString,
                                    (PCSZ) StringPtr
                                    );

                                RtlAnsiStringToUnicodeString(
                                    &UnicodeString,
                                    &AnsiString,
                                    FALSE
                                    );

                            }
                        }



                        //
                        // Load the System BIOS Date information
                        //

                        // Now jump to the BiosInfoHeader->BIOSDate-th string which
                        // is appended onto the end of the formatted section of the table.
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I think the ReleaseDate string is at offset: %d\n", (ULONG)InfoHeader->ReleaseDate));
                        if( (ULONG)InfoHeader->ReleaseDate > 0 ) {

                            // Jump to the end of the formatted portion of the SMBIOS table.
                            StringPtr = StartPtr + Header->Length;

                            // Jump over some number of strings to get to our string.
                            for( i = 0; i < ((ULONG)InfoHeader->ReleaseDate-1); i++ ) {
                                while( (*StringPtr != 0) && (StringPtr < EndPtr) ) {
                                    StringPtr++;
                                }
                                StringPtr++;
                            }

                            //
                            // Make sure the end string is null terminated in the buffer.
                            //

                            StringEndPtr = StringPtr;
                            while (StringEndPtr < EndPtr && *(StringEndPtr) != 0) {
                                StringEndPtr++;
                            }
                            
                            // StringPtr should be sitting at the BIOSDate string.  Convert him to
                            // Unicode and save it off.
                            if( StringEndPtr < EndPtr ) {
                                UNICODE_STRING  UnicodeString;
                                ANSI_STRING    AnsiString;


                                KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"    I'm about to load the Date string %s\n", StringPtr));
                                UnicodeString.Buffer = SystemBIOSDateString;
                                UnicodeString.MaximumLength = BIOS_DATE_LENGTH;
                                RtlInitAnsiString(
                                    &AnsiString,
                                    (PCSZ) StringPtr
                                    );

                                RtlAnsiStringToUnicodeString(
                                    &UnicodeString,
                                    &AnsiString,
                                    FALSE
                                    );

                            }
                        }


                    } else if( Header->Type == SMBIOS_BASE_BOARD_INFORMATION_TYPE ) {
                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: SMBIOS_BASE_BOARD_INFORMATION\n"));

                    } else if( Header->Type == SMBIOS_SYSTEM_CHASIS_INFORMATION_TYPE ) {

                        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: SMBIOS_SYSTEM_CHASIS_INFORMATION\n"));

                    }


                    //
                    // Go to the next table.
                    //
                    KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: Haven't found the ProcessorInformation block yet.  Just looked at a block of type: %d.\n", Header->Type));

                    StartPtr +=  Header->Length;

                    // jump over any trailing string-list too.
                    while ( (*((USHORT UNALIGNED *)StartPtr) != 0)  &&
                            (StartPtr < EndPtr) )
                    {
                        StartPtr++;
                    }
                    StartPtr += 2;

                }


                MmUnmapIoSpace(SMBiosDataVirtualAddress, DMIBiosEPSHeader->StructureTableLength);

            } else {
                KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: Failed to map the SMBIOS physical address.\n"));
            }

        } else {
            KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: The SMBiosEPSHeader is NULL in the extension block.\n"));
        }

    } else {
        KdPrintEx((DPFLTR_SYSTEM_ID, DPFLTR_INFO_LEVEL,"InitializeProcessorInformationFromSMBIOS: LoaderBlock extension is out of sync with the kernel.\n"));

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\init386.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    init386.c

Abstract:

    This module is here to fool build

Author:

    John Vert (jvert) 29-Aug-1994

Environment:

    Kernel mode.

Revision History:

--*/


void dummy(void) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\initdat.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    initdat.c

Abstract:

    This module is here to fool build

Author:

    John Vert (jvert) 29-Aug-1994

Environment:

    Kernel mode.

Revision History:

--*/


void dummy2(void) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\perform.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <wchar.h>
#include "windows.h"
#include "winreg.h"

#define TEST_STRING     "Test String"
#define TEST_STRING_W   L"Test String"



BOOLEAN
AdjustPrivilege(
    PSTR    SecurityNameString
    )
{
    HANDLE              TokenHandle;
    LUID_AND_ATTRIBUTES LuidAndAttributes;
//    PSTR                SecurityNameString;

    TOKEN_PRIVILEGES    TokenPrivileges;
    TOKEN_PRIVILEGES    PreviousTokenPrivileges;
    DWORD               ReturnLength;

    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &TokenHandle ) ) {
        printf( "OpenProcessToken failed \n" );
        return( FALSE );
    }

//    SecurityNameString = SE_RESTORE_NAME; // SE_SECURITY_NAME;

    if( !LookupPrivilegeValue( NULL,
                               SecurityNameString,
                               &( LuidAndAttributes.Luid ) ) ) {
        printf( "LookupPrivilegeValue failed, Error = %#x \n", GetLastError() );
        return( FALSE );
    }

    LuidAndAttributes.Attributes = SE_PRIVILEGE_ENABLED;
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0] = LuidAndAttributes;

    if( !AdjustTokenPrivileges( TokenHandle,
                                FALSE,
                                &TokenPrivileges,
                                0,
                                NULL,
                                NULL ) ) {
        printf( "AdjustTokenPrivileges failed, Error = %#x \n", GetLastError() );
        return( FALSE );
    }


    if( GetLastError() != NO_ERROR ) {
        return( FALSE );
    }

    return( TRUE );
}



#define ENVIRONMENT_NAME    L"Environment"
#define TESTKEY_NAME        L"TestKey"
#define TESTKEY_FULL_NAME   L"Environment\\TestKey"
#define KEY1_NAME           L"Key1"
#define KEY1_FULL_NAME      L"Environment\\TestKey\\Key1"
#define KEY2_NAME           L"Key2"
#define KEY2_FULL_NAME      L"Environment\\TestKey\\Key2"
#define VALUE_NAME          L"123"
#define VALUE_DATA          L"This is a string"



INT __cdecl
main()
{
    DWORD       Status;

    HKEY        TestKeyHandle;
    HKEY        Key1Handle;
    HKEY        Key2Handle;
    HKEY        EnvironmentHandle;

    WCHAR       ValueData[] = VALUE_DATA;

    WCHAR       BufferForKeyName[100];
    WCHAR       BufferForKeyClass[100];
    WCHAR       BufferForValueEntryName[100];
    BYTE        BufferForValueEntryData[100];


    DWORD       DataType;
    DWORD       DataSize;
    DWORD       NameSize;
    DWORD       ClassSize;


    DWORD       cSubKeys;
    DWORD       cbMaxSubkey;
    DWORD       cbMaxClass;
    DWORD       cValues;
    DWORD       vbMaxValueName;
    DWORD       cbMaxValueData;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;


    BYTE        BufferForSecurityDescriptor[2048];

    HANDLE      NotificationEvent;

    PWSTR       File1 = L"d:\\File1";
    PWSTR       File2 = L"d:\\File2";
    DWORD       Disposition;



/*
    Key = NULL;
    Status = RegOpenKeyExW( HKEY_CURRENT_USER,
                            L"",
                            0,
                            MAXIMUM_ALLOWED,
                            &Key );
*/








//    AdjustPrivilege( SE_BACKUP_NAME );
//    AdjustPrivilege( SE_RESTORE_NAME );


    NotificationEvent = CreateEvent( NULL,
                                     FALSE,
                                     FALSE,
                                     NULL );

    if( NotificationEvent == NULL ) {
        printf( "CreateEvent failed, ErrorCode = %d \n", GetLastError() );
    }



    Status = RegOpenKeyExW( HKEY_CURRENT_USER,
                            TESTKEY_FULL_NAME,
                            0,
                            MAXIMUM_ALLOWED,
                            &TestKeyHandle );

    if( Status != 0 ) {
        printf( "RegOpenKeyExW failed, Status = %d \n", Status );
    } else {
        printf( "RegOpenKeyExW succeeded \n" );
    }


    Status = RegOpenKeyW( HKEY_CURRENT_USER,
                          ENVIRONMENT_NAME,
                          &EnvironmentHandle );

    if( Status != 0 ) {
        printf( "RegOpenKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegOpenKeyW succeeded \n" );
    }






    Status = RegCreateKeyExW( TestKeyHandle,
                              KEY1_NAME,
                              NULL,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              MAXIMUM_ALLOWED,
                              NULL,
                              &Key1Handle,
                              &Disposition );

    if( Status != 0 ) {
        printf( "RegCreateKeyExW failed, Status = %d \n", Status );
    } else {
        printf( "RegCreateKeyExW succeeded \n" );
    }



    Status = RegCreateKeyW( TestKeyHandle,
                            KEY2_NAME,
                            &Key2Handle );


    if( Status != 0 ) {
        printf( "RegCreateKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegCreateKeyW succeeded \n" );
    }


    Status = RegSetValueExW( Key1Handle,
                             VALUE_NAME,
                             NULL,
                             REG_SZ,
                             ValueData,
                             sizeof( ValueData ) );

    if( Status != 0 ) {
        printf( "RegSetValueExW failed, Status = %d \n", Status );
    } else {
        printf( "RegSetValueExW succeeded \n" );
    }


    Status = RegSetValueW( Key1Handle,
                             NULL,
                             REG_SZ,
                             ValueData,
                             sizeof( ValueData ) );

    if( Status != 0 ) {
        printf( "RegSetValueW failed, Status = %d \n", Status );
    } else {
        printf( "RegSetValueW succeeded \n" );
    }



    Status = RegFlushKey( Key1Handle );
    if( Status != 0 ) {
        printf( "RegFlushKey failed, Status = %d \n", Status );
    } else {
        printf( "RegFlushKey succeeded \n" );
    }




    DataSize = sizeof( BufferForValueEntryData );
    memset( BufferForValueEntryData, '\0', DataSize );
    Status = RegQueryValueExW( Key1Handle,
                               VALUE_NAME,
                               NULL,
                               &DataType,
                               BufferForValueEntryData,
                               &DataSize );

    if( Status != 0 ) {
        printf( "RegQueryValueExW failed, Status = %d \n", Status );
    } else {
        printf( "RegQueryValueExW succeeded \n" );
    }



    DataSize = sizeof( BufferForValueEntryData );
    memset( BufferForValueEntryData, '\0', DataSize );
    Status = RegQueryValueW( Key1Handle,
                             NULL,
                             BufferForValueEntryData,
                             &DataSize );


    if( Status != 0 ) {
        printf( "RegQueryValueW failed, Status = %d \n", Status );
    } else {
        printf( "RegQueryValueW succeeded \n" );
    }


    DataSize = sizeof( BufferForValueEntryData );
    memset( BufferForValueEntryData, 'X', DataSize );
    NameSize = sizeof( BufferForValueEntryName );
    memset( BufferForValueEntryName, 'X', NameSize );

    Status = RegEnumValueW( Key1Handle,
                            0,
                            BufferForValueEntryName,
                            &NameSize,
                            NULL,
                            &DataType,
                            BufferForValueEntryData,
                            &DataSize );


    if( Status != 0 ) {
        printf( "RegEnumValueW failed, Status = %d \n", Status );
    } else {
        printf( "RegEnumValueW succeeded \n" );
    }


    NameSize = sizeof( BufferForKeyName );
    ClassSize = sizeof( BufferForKeyClass );
    Status = RegEnumKeyExW( TestKeyHandle,
                            0,
                            BufferForKeyName,
                            &NameSize,
                            NULL,
                            BufferForKeyClass,
                            &ClassSize,
                            &ftLastWriteTime );

    if( Status != 0 ) {
        printf( "RegEnumKeyExW failed, Status = %d \n", Status );
    } else {
        printf( "RegEnumKeyExW succeeded \n" );
    }


    NameSize = sizeof( BufferForKeyName );
    Status = RegEnumKeyW( TestKeyHandle,
                          0,
                          BufferForKeyName,
                          &NameSize );

    if( Status != 0 ) {
	printf( "RegEnumKeyW failed, Status = %d \n", Status );
    } else {
	printf( "RegEnumKeyW succeeded \n" );
    }


    ClassSize = sizeof( BufferForKeyClass );
    Status = RegQueryInfoKeyW( Key1Handle,
                               BufferForKeyClass,
                               &ClassSize,
                               NULL,
                               &cSubKeys,
                               &cbMaxSubkey,
                               &cbMaxClass,
                               &cValues,
                               &vbMaxValueName,
                               &cbMaxValueData,
                               &cbSecurityDescriptor,
                               &ftLastWriteTime );



    if( Status != 0 ) {
        printf( "RegQueryInfoKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegQueryInfoKeyW succeeded \n" );
    }


    Status = RegGetKeySecurity( Key1Handle,
                                DACL_SECURITY_INFORMATION,
                                ( PSECURITY_DESCRIPTOR )BufferForSecurityDescriptor,
                                &cbSecurityDescriptor );

    if( Status != 0 ) {
        printf( "RegGetKeySecurity failed, Status = %d \n", Status );
    } else {
        printf( "RegGetKeySecurity succeeded \n" );
    }



    Status = RegSetKeySecurity( Key1Handle,
                                DACL_SECURITY_INFORMATION,
                                ( PSECURITY_DESCRIPTOR )BufferForSecurityDescriptor );

    if( Status != 0 ) {
        printf( "RegSetKeySecurity failed, Status = %d \n", Status );
    } else {
        printf( "RegSetKeySecurity succeeded \n" );
    }

/*
    Status = RegSaveKeyW( Key1Handle,
                          File1,
                          NULL );


    if( Status != 0 ) {
        printf( "RegSaveKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegSaveKeyW succeeded \n" );
    }



    Status = RegRestoreKeyW( Key2Handle,
                             File1,
                             0 );


    if( Status != 0 ) {
        printf( "RegRestoreKeyW failed, Status = %d \n", Status );
    } else {
        printf( "RegRestoreKeyW succeeded \n" );
    }
*/

    Status = RegDeleteValueW( Key1Handle,
                              VALUE_NAME );


    if( Status != 0 ) {
        printf( "RegDeleteValueW failed, Status = %d \n", Status );
    } else {
        printf( "RegDeleteValueW succeeded \n" );
    }


    Status = RegCloseKey( Key1Handle );

    if( Status != 0 ) {
        printf( "RegCloseKey failed, Status = %d \n", Status );
    } else {
        printf( "RegCloseKey succeeded \n" );
    }

    Status = RegDeleteKeyW( TestKeyHandle,
                            KEY1_NAME );

    if( Status != 0 ) {
        printf( "RegCloseKey failed, Status = %d \n", Status );
    } else {
        printf( "RegCloseKey succeeded \n" );
    }


    Status = RegNotifyChangeKeyValue( HKEY_CURRENT_USER,
                                      TRUE,
                                      REG_NOTIFY_CHANGE_NAME |
                                      REG_NOTIFY_CHANGE_ATTRIBUTES |
                                      REG_NOTIFY_CHANGE_LAST_SET |
                                      REG_NOTIFY_CHANGE_SECURITY,
                                      NotificationEvent,
                                      TRUE );

    if( Status != 0 ) {
        printf( "RegNotifyChangeKeyValue failed, Status = %d \n", Status );
    } else {
        printf( "RegNotifyChangeKeyValue succeeded \n" );
    }


    //
    //  Cleanup
    //

    CloseHandle( NotificationEvent );
//    DeleteFileW( File1 );
    RegCloseKey( Key2Handle );
    RegDeleteKeyW( TestKeyHandle,
                   KEY2_NAME );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\regext.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regext.c

Abstract:

    Kernel debugger extensions useful for the registry

Author:

    John Vert (jvert) 7-Sep-1993

Environment:

    Loaded as a kernel debugger extension

Revision History:

    John Vert (jvert) 7-Sep-1993
        created

--*/
#include "cmp.h"
#include <windef.h>
#include <ntkdexts.h>
#include <stdlib.h>
#include <stdio.h>

HIVE_LIST_ENTRY HiveList[8];

ULONG TotalPages;
ULONG TotalPresentPages;

ULONG TotalKcbs;
ULONG TotalKcbName;

BOOLEAN SavePages;
BOOLEAN RestorePages;
FILE *TempFile;

PNTKD_OUTPUT_ROUTINE lpPrint;
PNTKD_GET_EXPRESSION lpGetExpressionRoutine;
PNTKD_GET_SYMBOL lpGetSymbolRoutine;
PNTKD_CHECK_CONTROL_C lpCheckControlCRoutine;
PNTKD_READ_VIRTUAL_MEMORY lpReadMem;

void
poolDumpHive(
    IN PCMHIVE Hive
    );

VOID
poolDumpMap(
    IN ULONG Length,
    IN PHMAP_DIRECTORY Map
    );

void
dumpHiveFromFile(
    IN FILE *File
    );

VOID
kcbWorker(
    IN PCM_KEY_CONTROL_BLOCK pKcb
    );

VOID
pool(
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )

/*++

Routine Description:

    Goes through all the paged pool allocated to registry space and
    determines which pages are present and which are not.

    Called as:

        !regext.pool [s|r]

        s Save list of registry pages to temporary file
        r Restore list of registry pages from temp. file

Arguments:

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.

Return Value:

    None.

--*/

{
    PLIST_ENTRY pCmpHiveListHead;
    PLIST_ENTRY pNextHiveList;
    HIVE_LIST_ENTRY *pHiveListEntry;
    ULONG BytesRead;
    PCMHIVE CmHive;

    lpPrint = lpExtensionApis->lpOutputRoutine;
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine;
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;
    lpReadMem = lpExtensionApis->lpReadVirtualMemRoutine;

    if (toupper(lpArgumentString[0])=='S') {
        SavePages = TRUE;
    } else {
        SavePages = FALSE;
    }
    if (toupper(lpArgumentString[0])=='R') {
        RestorePages = TRUE;
    } else {
        RestorePages = FALSE;
    }

    //
    // Go get the hivelist.
    //
    memset(HiveList,0,sizeof(HiveList));
    pHiveListEntry = (PHIVE_LIST_ENTRY)(lpGetExpressionRoutine)("CmpMachineHiveList");
    if (pHiveListEntry != NULL) {
        (lpReadMem)(pHiveListEntry,
                    HiveList,
                    sizeof(HiveList),
                    &BytesRead);
    }

    //
    // First go and get the hivelisthead
    //
    pCmpHiveListHead = (PLIST_ENTRY)(lpGetExpressionRoutine)("CmpHiveListHead");
    if (pCmpHiveListHead==NULL) {
        (lpPrint)("CmpHiveListHead couldn't be read\n");
        return;
    }

    (lpReadMem)(&pCmpHiveListHead->Flink,
                &pNextHiveList,
                sizeof(pNextHiveList),
                &BytesRead);
    if (BytesRead != sizeof(pNextHiveList)) {
        (lpPrint)("Couldn't read first Flink (%lx) of CmpHiveList\n",
                  &pCmpHiveListHead->Flink);
        return;
    }

    TotalPages = TotalPresentPages = 0;

    if (SavePages) {
        TempFile = fopen("regext.dat","w+");
        if (TempFile==NULL) {
            (lpPrint)("Couldn't create regext.dat for write\n");
            return;
        }
    } else if (RestorePages) {
        TempFile = fopen("regext.dat","r");
        if (TempFile==NULL) {
            (lpPrint)("Couldn't open regext.dat for read\n");
            return;
        }
    }

    if (RestorePages) {
        dumpHiveFromFile(TempFile);
    } else {
        while (pNextHiveList != pCmpHiveListHead) {
            CmHive = CONTAINING_RECORD(pNextHiveList, CMHIVE, HiveList);
            poolDumpHive(CmHive);

            (lpReadMem)(&pNextHiveList->Flink,
                        &pNextHiveList,
                        sizeof(pNextHiveList),
                        &BytesRead);
            if (BytesRead != sizeof(pNextHiveList)) {
                (lpPrint)("Couldn't read Flink (%lx) of %lx\n",
                          &pCmpHiveListHead->Flink,pNextHiveList);
                break;
            }

        }
    }

    (lpPrint)("Total pages present = %d / %d\n",
              TotalPresentPages,
              TotalPages);

    if (SavePages || RestorePages) {
        fclose(TempFile);
    }
}

void
poolDumpHive(
    IN PCMHIVE pHive
    )
{
    CMHIVE CmHive;
    ULONG BytesRead;
    WCHAR FileName[HBASE_NAME_ALLOC/2 + 1];
    ULONG i;

    (lpPrint)("\ndumping hive at %lx ",pHive);
    (lpReadMem)(pHive,
                &CmHive,
                sizeof(CmHive),
                &BytesRead);

    if (BytesRead < sizeof(CmHive)) {
        (lpPrint)("\tRead %lx bytes from %lx\n",BytesRead,pHive);
        return;
    }

    (lpReadMem)(&CmHive.Hive.BaseBlock->FileName,
                FileName,
                sizeof(FileName),
                &BytesRead);

    if (BytesRead < sizeof(FileName)) {
        wcscpy(FileName, L"UNKNOWN");
    } else {
        if (FileName[0]==L'\0') {
            wcscpy(FileName, L"NONAME");
        } else {
            FileName[HBASE_NAME_ALLOC/2]=L'\0';
        }
    }

    (lpPrint)("(%ws)\n",FileName);

    (lpPrint)("  %d KCBs open\n",CmHive.KcbCount);
    (lpPrint)("  Stable Length = %lx\n",CmHive.Hive.Storage[Stable].Length);
    if (SavePages) {
        fprintf(TempFile,
                "%ws %d %d\n",
                FileName,
                CmHive.Hive.Storage[Stable].Length,
                CmHive.Hive.Storage[Volatile].Length);
    }
    poolDumpMap(CmHive.Hive.Storage[Stable].Length,
                CmHive.Hive.Storage[Stable].Map);

    (lpPrint)("  Volatile Length = %lx\n",CmHive.Hive.Storage[Volatile].Length);
    poolDumpMap(CmHive.Hive.Storage[Volatile].Length,
                CmHive.Hive.Storage[Volatile].Map);

}

VOID
poolDumpMap(
    IN ULONG Length,
    IN PHMAP_DIRECTORY Map
    )
{
    ULONG Tables;
    ULONG MapSlots;
    ULONG i;
    ULONG BytesRead;
    HMAP_DIRECTORY MapDirectory;
    PHMAP_TABLE MapTable;
    HMAP_ENTRY MapEntry;
    ULONG Garbage;
    ULONG Present=0;

    if (Length==0) {
        return;
    }

    MapSlots = Length / HBLOCK_SIZE;
    Tables = 1+ ((MapSlots-1) / HTABLE_SLOTS);

    //
    // read in map directory
    //
    (lpReadMem)(Map,
             &MapDirectory,
             Tables * sizeof(PHMAP_TABLE),
             &BytesRead);
    if (BytesRead < (Tables * sizeof(PHMAP_TABLE))) {
        (lpPrint)("Only read %lx/%lx bytes from %lx\n",
                  BytesRead,
                  Tables * sizeof(PHMAP_TABLE),
                  Map);
        return;

    }

    //
    // check out each map entry
    //
    for (i=0; i<MapSlots; i++) {

        MapTable = MapDirectory.Directory[i/HTABLE_SLOTS];

        (lpReadMem)(&(MapTable->Table[i%HTABLE_SLOTS]),
                    &MapEntry,
                    sizeof(HMAP_ENTRY),
                    &BytesRead);
        if (BytesRead < sizeof(HMAP_ENTRY)) {
            (lpPrint)("  can't read HMAP_ENTRY at %lx\n",
                      &(MapTable->Table[i%HTABLE_SLOTS]));
        }

        if (SavePages) {
            fprintf(TempFile, "%lx\n",MapEntry.BlockAddress);

        }

        //
        // probe the HBLOCK
        //
        (lpReadMem)(MapEntry.BlockAddress,
                    &Garbage,
                    sizeof(ULONG),
                    &BytesRead);
        if (BytesRead > 0) {
            ++Present;
        }
    }
    (lpPrint)("  %d/%d pages present\n",
              Present,
              MapSlots);

    TotalPages += MapSlots;
    TotalPresentPages += Present;

}

void
dumpHiveFromFile(
    IN FILE *File
    )

/*++

Routine Description:

    Takes a list of the registry hives and pages from a file and
    checks to see how many of the pages are in memory.

    The format of the file is as follows
       hivename stablelength volatilelength
       stable page address
       stable page address
            .
            .
            .
       volatile page address
       volatile page address
            .
            .
            .
       hivename stablelength volatilelength
            .
            .
            .


Arguments:

    File - Supplies a file.

Return Value:

    None.

--*/

{
    CHAR Hivename[33];
    ULONG StableLength;
    ULONG VolatileLength;
    ULONG Page;
    ULONG i;
    ULONG NumFields;
    ULONG Garbage;
    ULONG Present;
    ULONG Total;
    ULONG BytesRead;

    while (!feof(File)) {
        NumFields = fscanf(File,"%s %d %d\n",
                            Hivename,
                            &StableLength,
                            &VolatileLength);
        if (NumFields != 3) {
            (lpPrint)("fscanf returned %d\n",NumFields);
            return;
        }

        (lpPrint)("\ndumping hive %s\n",Hivename);
        (lpPrint)("  Stable Length = %lx\n",StableLength);
        Present = 0;
        Total = 0;
        while (StableLength > 0) {
            fscanf(File, "%lx\n",&Page);
            (lpReadMem)(Page,
                        &Garbage,
                        sizeof(ULONG),
                        &BytesRead);
            if (BytesRead > 0) {
                ++Present;
            }
            ++Total;
            StableLength -= HBLOCK_SIZE;
        }
        if (Total > 0) {
            (lpPrint)("  %d/%d stable pages present\n",
                      Present,Total);
        }
        TotalPages += Total;
        TotalPresentPages += Present;

        (lpPrint)("  Volatile Length = %lx\n",VolatileLength);
        Present = 0;
        Total = 0;
        while (VolatileLength > 0) {
            fscanf(File, "%lx\n",&Page);
            (lpReadMem)(Page,
                        &Garbage,
                        sizeof(ULONG),
                        &BytesRead);
            if (BytesRead > 0) {
                ++Present;
            }
            ++Total;
            VolatileLength -= HBLOCK_SIZE;
        }
        if (Total > 0) {
            (lpPrint)("  %d/%d volatile pages present\n",
                      Present,Total);
        }

        TotalPages += Total;
        TotalPresentPages += Present;
    }

}

void
kcb(
    DWORD dwCurrentPc,
    PNTKD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )

/*++

Routine Description:

    Walks the kcb tree and prints the names of keys which have
    outstanding kcbs

    Called as:

        !regext.kcb

Arguments:

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the pattern and expression for this
        command.

Return Value:

    None.

--*/

{
    PCM_KEY_CONTROL_BLOCK pKCB;
    PCM_KEY_CONTROL_BLOCK Root;
    ULONG BytesRead;

    lpPrint = lpExtensionApis->lpOutputRoutine;
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine;
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine;
    lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;
    lpReadMem = lpExtensionApis->lpReadVirtualMemRoutine;

    Root = (PCM_KEY_CONTROL_BLOCK)(lpGetExpressionRoutine)("CmpKeyControlBlockRoot");
    if (Root == NULL) {
        (lpPrint)("Couldn't find address of CmpKeyControlBlockRoot\n");
        return;
    }
    (lpReadMem)(Root,
                &pKCB,
                sizeof(pKCB),
                &BytesRead);

    if (BytesRead < sizeof(pKCB)) {
        (lpPrint)("Couldn't get pKCB from CmpKeyControlBlockRoot\n");
    }

    TotalKcbs = 0;
    TotalKcbName = 0;
    kcbWorker(pKCB);

    (lpPrint)("%d KCBs\n",TotalKcbs);
    (lpPrint)("%d total bytes of FullNames\n",TotalKcbName);

}

VOID
kcbWorker(
    IN PCM_KEY_CONTROL_BLOCK pKcb
    )

/*++

Routine Description:

    recursive worker for walking the kcb tree.

Arguments:

    pKcb - Supplies pointer to kcb.

Return Value:

    None.

--*/

{
    CM_KEY_CONTROL_BLOCK kcb;
    ULONG BytesRead;
    WCHAR *Buffer;

    ++TotalKcbs;
    (lpReadMem)(pKcb,
                &kcb,
                sizeof(kcb),
                &BytesRead);
    if (BytesRead < sizeof(kcb)) {
        (lpPrint)("Can't read kcb at %lx\n",pKcb);
        return;
    }
    TotalKcbName += kcb.FullName.Length;

    if (kcb.Left != NULL) {
        kcbWorker(kcb.Left);
    }

    (lpPrint)("%d - ",kcb.RefCount);

    Buffer = malloc(kcb.FullName.Length);
    if (Buffer != NULL) {
        (lpReadMem)(kcb.FullName.Buffer,
                    Buffer,
                    kcb.FullName.Length,
                    &BytesRead);

        kcb.FullName.Length = BytesRead;
        kcb.FullName.Buffer = Buffer;

        (lpPrint)(" %wZ\n",&kcb.FullName);
        free(Buffer);

    } else {
        (lpPrint)(" ??? \n");
    }

    if (kcb.Right != NULL) {
        kcbWorker(kcb.Right);
    }


}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtbatcr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtbatcr.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Do a batch create.

    rtbatcr    <KeyPath> <KeyName> <basename> <#children> <#values>

    Will attempt to create key <KeyName> as child of <KeyPath>  If
    <#children> and <#values> are 0, this is all it does.  If <KeyName>
    already exists, it will simply be used.

    Will create <#children> child cells, with names of the form
    <base>0  <base>1, etc.  Will create <#values> value entries,
    with similar names, for each created child key.  Data of
    values will be a constant string including their name.

    Example:

        rtbatcr    \REGISTRY\MACHINE\TEST bigkey runa_ 100 100
        rtbatcr    \REGISTRY\MACHINE\TEST\bigkey runa_1 runb_ 100 100

        Will create bigkey, give it 100 values calls runa_1 through
        runa_100, create 100 subkeys called runa_1 through runa_100
        for each of those children.

        It will then open bigkey\runa_1, and create 100 subkeys and
        100 values each for that.

Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

ULONG           failure = 0;

UNICODE_STRING  KeyPath;
UNICODE_STRING  KeyName;
ULONG           NumberChildren;
ULONG           NumberValues;
UCHAR           BaseName[WORK_SIZE];
UCHAR           formatbuffer[WORK_SIZE];
STRING          format;
BOOLEAN         CreateVolatile = FALSE;

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    HANDLE          WorkHandle;
    ULONG           Disposition;
    UNICODE_STRING  ClassName;
    ULONG           i;
    ULONG           j;
    PUCHAR  p;
    ULONG           CreateOption;

    //
    // Process args
    //

    processargs(argc, argv);


    //
    // Set up and create/open KeyPath|KeyName
    //

    printf("rtbatcr: starting\n");

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    RtlCopyString((PSTRING)&WorkName, (PSTRING)&KeyPath);

    p = WorkName.Buffer;
    p += WorkName.Length;
    *p = '\\';
    p++;
    *p = '\0';
    WorkName.Length += 2;

    RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&KeyName);

    RtlInitUnicodeString(
        &ClassName,
        L"Test Class Name"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    if (CreateVolatile) {
        CreateOption = REG_OPTION_VOLATILE;
    } else {
        CreateOption = 0;
    }

    status = NtCreateKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                0,
                &ClassName,
                CreateOption,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtbatcr: t0: %08lx\n", status);
        failure++;
        goto punt;
    }


    //
    // Create NumberChildren subkeys
    //

    for (i = 0; i < NumberChildren; i++) {

        sprintf(formatbuffer, "%s%d", BaseName, i);
        RtlInitString(&format, formatbuffer);
        RtlAnsiStringToUnicodeString(&WorkName, &format, FALSE);


        InitializeObjectAttributes(
            &ObjectAttributes,
            &WorkName,
            0,
            BaseHandle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtCreateKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes,
                    0,
                    &ClassName,
                    CreateOption,
                    &Disposition
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtbatcr: t1: status = %08lx i = %d\n", status, i);
            failure++;
        }

        //
        // Create NumberValues value entries for each (current) key
        //

        for (j = 0; j < NumberValues; j++) {

            sprintf(formatbuffer, "%s%d", BaseName, j);
            RtlInitString(&format, formatbuffer);
            RtlAnsiStringToUnicodeString(&WorkName, &format, FALSE);

            sprintf(
                formatbuffer, "This is a rtbatcr value for %s%d", BaseName, j
                );

            status = NtSetValueKey(
                        WorkHandle,
                        &WorkName,
                        j,
                        j,
                        formatbuffer,
                        strlen(formatbuffer)+1
                        );
            if (!NT_SUCCESS(status)) {
                printf("rtbatcr: t2: status = %08lx j = %d\n", status, j);
                failure++;
            }
        }
        NtClose(WorkHandle);
    }

punt:
    printf("rtbatcr: %d failures\n", failure);
    exit(failure);
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc < 3) || (argc > 7) )
    {
        printf("Usage: %s [volatile] <KeyPath> <KeyName> [<basename> <#children> <#values>]\n",
                argv[0]);
        exit(1);
    }

    if (_stricmp(argv[1],"volatile")==0) {
        CreateVolatile = TRUE;
        ++argv;
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &KeyName,
        &temp,
        TRUE
        );

    if (argc < 6) {

        NumberChildren = 0;
        NumberValues = 0;

    } else {

        strcpy(BaseName, argv[3]);
        NumberChildren = atoi(argv[4]);
        NumberValues = atoi(argv[5]);

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtdeltre.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdeltre.c

Abstract:

    NT level registry api test program #4, basic non-error paths.

    Sub-tree delete for the registry.

    rtdeltre <KeyPath>

    Will ennumerate and delete the subkeys and values of KeyPath,
    and each of their subkeys, and so on.

    Example:

        rtdeltre \REGISTRY\MACHINE\TEST\bigkey

Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int argc, char *);
void processargs();

void print(PUNICODE_STRING);

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("regtest3: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                DELETE | KEY_ENUMERATE_SUB_KEYS,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("regtest3: t0: %08lx\n", status);
        exit(1);
    }

    Delete(BaseHandle);
}


void
Delete(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  WorkHandle;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    NamePos = WorkName.Length;

    //
    // Enumerate node's children and apply ourselves to each one
    //

    index = 0;
    do {

        RtlZeroMemory(KeyInformation, WORK_SIZE);
        status = NtEnumerateKey(
                    Handle,
                    index,
                    KeyBasicInformation,
                    KeyInformation,
                    WORK_SIZE,
                    &ResultLength
                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            WorkName.Length = NamePos;
            break;

        } else if (!NT_SUCCESS(status)) {

            printf("regtest3: dump1: status = %08lx\n", status);
            exit(1);

        }

        enumname.Buffer = &(KeyInformation->Name[0]);
        enumname.Length = KeyInformation->NameLength;
        enumname.MaximumLength = KeyInformation->NameLength;

        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&enumname);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &enumname,
            OBJ_CASE_INSENSITIVE,
            Handle,
            NULL
            );

        status = NtOpenKey(
                    &WorkHandle,
                    DELETE | KEY_ENUMERATE_SUB_KEYS,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(status)) {
            printf("regtest3: couldn't delete %wZ: %08lx\n", &enumname,status);
            index++;
        } else {
            Delete(WorkHandle);
            NtClose(WorkHandle);
        }

        WorkName.Length = NamePos;

    } while (TRUE);

    //
    // If we're here, then we have delt with all children, so deal with
    // the node we were applied to
    //

    NtDeleteKey(Handle);
    NtClose(Handle);        // Force it to actually go away
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtdelval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdelval.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Delete a key's value entry (field)

    rtdelval <KeyPath> <value entry name>

    Example:

        rtdelval \REGISTRY\MACHINE\TEST\bigkey first_value_field

Author:

    Bryan Willman (bryanwi)  10-Jan-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

UNICODE_STRING  ValueName;
WCHAR           valuebuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);


    ValueName.MaximumLength = WORK_SIZE;
    ValueName.Length = 0L;
    ValueName.Buffer = &(valuebuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdelval: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_SET_VALUE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdelval: t0: %08lx\n", status);
        exit(1);
    }

    status = NtDeleteValueKey(BaseHandle, &ValueName);
    if (!NT_SUCCESS(status)) {
        printf("rtdelval: t1: %08lx\n", status);
        exit(1);
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 3) )
    {
        printf("Usage: %s <KeyPath> <value entry name>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &ValueName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtdelkey.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdelkey.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Delete a key.

    rtdelkey <KeyPath>

    Example:

        rtdelkey \REGISTRY\MACHINE\TEST\bigkey

Author:

    Bryan Willman (bryanwi)  10-Jan-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int,char *);
void processargs();

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdelkey: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                DELETE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdelkey: t0: %08lx\n", status);
        exit(1);
    }

    status = NtDeleteKey(BaseHandle);
    if (!NT_SUCCESS(status)) {
        printf("rtdelkey: t1: %08lx\n", status);
        exit(1);
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtdmpsec.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdmpsec.c

Abstract:

    NT level registry security test program #1, basic non-error paths.

    Dump out the security descriptors of a sub-tree of the registry.

    rtdmpsec <KeyPath>

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    It assumes data values are null terminated strings.

    Example:

        rtdmpsec \REGISTRY\MACHINE\TEST\bigkey

Author:

    John Vert (jvert) 24-Jan-92

        based on rtdmp.c by

    Bryan Willman (bryanwi)  10-Dec-91

        and getdacl.c by RobertRe

Revision History:

    Richard Ward (richardw)  14 April 1992   Changed ACE_HEADER

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

//
//  Get a pointer to the first ace in an acl
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Get a pointer to the following ace
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

//
// Generic ACE structure, to be used for casting ACE's of known types
//

typedef struct _KNOWN_ACE {
   ACE_HEADER Header;
   ACCESS_MASK Mask;
   ULONG SidStart;
   } KNOWN_ACE, *PKNOWN_ACE;



VOID
InitVars();

VOID
PrintAcl (
    IN PACL Acl
    );

VOID
PrintAccessMask(
    IN ACCESS_MASK AccessMask
    );

void __cdecl main(int, char *);
void processargs();

void print(PUNICODE_STRING);

void
DumpSecurity(
    HANDLE  Handle
    );

void
Dump(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

//
// Universal well known SIDs
//

PSID  NullSid;
PSID  WorldSid;
PSID  LocalSid;
PSID  CreatorOwnerSid;

//
// Sids defined by NT
//

PSID NtAuthoritySid;

PSID DialupSid;
PSID NetworkSid;
PSID BatchSid;
PSID InteractiveSid;
PSID LocalSystemSid;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    InitVars();

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdmpsec: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdmpsec: t0: %08lx\n", status);
        exit(1);
    }

    Dump(BaseHandle);
}


void
Dump(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  WorkHandle;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];
    PUCHAR  p;

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    NamePos = WorkName.Length;

    //
    // Print name of node we are about to dump out
    //
    printf("\n");
    print(&WorkName);
    printf("::\n");

    //
    // Print out node's values
    //
    DumpSecurity(Handle);

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyInformation, WORK_SIZE);
        status = NtEnumerateKey(
                    Handle,
                    index,
                    KeyBasicInformation,
                    KeyInformation,
                    WORK_SIZE,
                    &ResultLength
                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            WorkName.Length = NamePos;
            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmpsec: dump1: status = %08lx\n", status);
            exit(1);

        }

        enumname.Buffer = &(KeyInformation->Name[0]);
        enumname.Length = KeyInformation->NameLength;
        enumname.MaximumLength = KeyInformation->NameLength;

        p = WorkName.Buffer;
        p += WorkName.Length;
        *p = '\\';
        p++;
        *p = '\0';
        WorkName.Length += 2;

        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&enumname);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &enumname,
            0,
            Handle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtOpenKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(status)) {
            if (status == STATUS_ACCESS_DENIED) {
                printf("\n");
                print(&WorkName);
                printf("::\n\tAccess denied!\n");
            } else {
                printf("rtdmpsec: dump2: %08lx\n", status);
                exit(1);
            }
        } else {
            Dump(WorkHandle);
            NtClose(WorkHandle);
        }

        WorkName.Length = NamePos;
    }
}


void
DumpSecurity(
    HANDLE  Handle
    )
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    NTSTATUS Status;
    ULONG Length;
    PACL Dacl;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    Status = NtQuerySecurityObject( Handle,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &Length );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        printf("DumpSecurity t0: NtQuerySecurityObject failed %lx\n",Status);
        exit(1);
    }

    SecurityDescriptor = malloc(Length);
    if (SecurityDescriptor == NULL) {
        printf("DumpSecurity: couldn't malloc buffer\n");
        exit(1);
    }

    Status = NtQuerySecurityObject( Handle,
                                    DACL_SECURITY_INFORMATION,
                                    SecurityDescriptor,
                                    Length,
                                    &Length );

    if (!NT_SUCCESS(Status)) {
        printf("DumpSecurity t1: NtQuerySecurityObject failed %lx\n",Status);
        exit(1);
    }

    Dacl = NULL;

    Status = RtlGetDaclSecurityDescriptor( SecurityDescriptor,
                                           &DaclPresent,
                                           &Dacl,
                                           &DaclDefaulted );
    if (!NT_SUCCESS(Status)) {
        printf("DumpSecurity t2: RtlGetDaclSecurityDescriptor failed %lx\n",Status);
    }

    if (DaclPresent) {
        PrintAcl(Dacl);
    } else {
        printf("\tAcl not present\n");
    }

}


void
print(
    PUNICODE_STRING  String
    )
{
    static  ANSI_STRING temp;
    static  char        tempbuffer[WORK_SIZE];

    temp.MaximumLength = WORK_SIZE;
    temp.Length = 0L;
    temp.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&temp, String, FALSE);
    printf("%s", temp.Buffer);
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        FALSE
        );

    return;
}


BOOLEAN
SidTranslation(
    PSID Sid,
    PSTRING AccountName
    )
// AccountName is expected to have a large maximum length

{
    if (RtlEqualSid(Sid, WorldSid)) {
        RtlInitString( AccountName, "WORLD");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, LocalSid)) {
        RtlInitString( AccountName, "LOCAL");

        return(TRUE);
    }

    if (RtlEqualSid(Sid, NetworkSid)) {
        RtlInitString( AccountName, "NETWORK");

        return(TRUE);
    }

    if (RtlEqualSid(Sid, BatchSid)) {
        RtlInitString( AccountName, "BATCH");

        return(TRUE);
    }

    if (RtlEqualSid(Sid, InteractiveSid)) {
        RtlInitString( AccountName, "INTERACTIVE");
        return(TRUE);
    }

    if (RtlEqualSid(Sid, LocalSystemSid)) {
        RtlInitString( AccountName, "SYSTEM");
        return(TRUE);
    }

//
//    if (RtlEqualSid(Sid, LocalManagerSid)) {
//      RtlInitString( AccountName, "LOCAL MANAGER");
//      return(TRUE);
//  }

//  if (RtlEqualSid(Sid, LocalAdminSid)) {
//      RtlInitString( AccountName, "LOCAL ADMIN");
//      return(TRUE);
//  }

    return(FALSE);

}


VOID
DisplayAccountSid(
    PSID Sid
    )
{
    UCHAR Buffer[128];
    STRING AccountName;
    UCHAR i;
    ULONG Tmp;
    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    UCHAR SubAuthorityCount;

    Buffer[0] = 0;

    AccountName.MaximumLength = 127;
    AccountName.Length = 0;
    AccountName.Buffer = (PVOID)&Buffer[0];



    if (SidTranslation( (PSID)Sid, &AccountName) ) {

        printf("%s\n", AccountName.Buffer );

    } else {
        IdentifierAuthority = RtlIdentifierAuthoritySid(Sid);

        //
        // HACK! HACK!
        // The next line prints the revision of the SID.  Since there is no
        // rtl routine which gives us the SID revision, we must make due.
        // luckily, the revision field is the first field in the SID, so we
        // can just cast the pointer.
        //

        printf("S-%u-", (USHORT) *((PUCHAR) Sid) );

        if (  (IdentifierAuthority->Value[0] != 0)  ||
              (IdentifierAuthority->Value[1] != 0)     ){
            printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                        IdentifierAuthority->Value[0],
                        IdentifierAuthority->Value[1],
                        IdentifierAuthority->Value[2],
                        IdentifierAuthority->Value[3],
                        IdentifierAuthority->Value[4],
                        IdentifierAuthority->Value[5] );
        } else {
            Tmp = IdentifierAuthority->Value[5]          +
                  (IdentifierAuthority->Value[4] <<  8)  +
                  (IdentifierAuthority->Value[3] << 16)  +
                  (IdentifierAuthority->Value[2] << 24);
            printf("%lu", Tmp);
        }

        SubAuthorityCount = *RtlSubAuthorityCountSid(Sid);
        for (i=0;i<SubAuthorityCount ;i++ ) {
            printf("-%lu", (*RtlSubAuthoritySid(Sid, i)));
        }
        printf("\n");

    }

}

VOID
InitVars()
{
    ULONG SidWithZeroSubAuthorities;
    ULONG SidWithOneSubAuthority;
    ULONG SidWithThreeSubAuthorities;
    ULONG SidWithFourSubAuthorities;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;


    //
    //  The following SID sizes need to be allocated
    //

    SidWithZeroSubAuthorities  = RtlLengthRequiredSid( 0 );
    SidWithOneSubAuthority     = RtlLengthRequiredSid( 1 );
    SidWithThreeSubAuthorities = RtlLengthRequiredSid( 3 );
    SidWithFourSubAuthorities  = RtlLengthRequiredSid( 4 );

    //
    //  Allocate and initialize the universal SIDs
    //

    NullSid         = (PSID)malloc(SidWithOneSubAuthority);
    WorldSid        = (PSID)malloc(SidWithOneSubAuthority);
    LocalSid        = (PSID)malloc(SidWithOneSubAuthority);
    CreatorOwnerSid = (PSID)malloc(SidWithOneSubAuthority);

    RtlInitializeSid( NullSid,    &NullSidAuthority, 1 );
    RtlInitializeSid( WorldSid,   &WorldSidAuthority, 1 );
    RtlInitializeSid( LocalSid,   &LocalSidAuthority, 1 );
    RtlInitializeSid( CreatorOwnerSid, &CreatorSidAuthority, 1 );

    *(RtlSubAuthoritySid( NullSid, 0 ))         = SECURITY_NULL_RID;
    *(RtlSubAuthoritySid( WorldSid, 0 ))        = SECURITY_WORLD_RID;
    *(RtlSubAuthoritySid( LocalSid, 0 ))        = SECURITY_LOCAL_RID;
    *(RtlSubAuthoritySid( CreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //

    NtAuthoritySid  = (PSID)malloc(SidWithZeroSubAuthorities);
    DialupSid       = (PSID)malloc(SidWithOneSubAuthority);
    NetworkSid      = (PSID)malloc(SidWithOneSubAuthority);
    BatchSid        = (PSID)malloc(SidWithOneSubAuthority);
    InteractiveSid  = (PSID)malloc(SidWithOneSubAuthority);
    LocalSystemSid  = (PSID)malloc(SidWithOneSubAuthority);

    RtlInitializeSid( NtAuthoritySid,   &NtAuthority, 0 );
    RtlInitializeSid( DialupSid,        &NtAuthority, 1 );
    RtlInitializeSid( NetworkSid,       &NtAuthority, 1 );
    RtlInitializeSid( BatchSid,         &NtAuthority, 1 );
    RtlInitializeSid( InteractiveSid,   &NtAuthority, 1 );
    RtlInitializeSid( LocalSystemSid,   &NtAuthority, 1 );

    *(RtlSubAuthoritySid( DialupSid,       0 )) = SECURITY_DIALUP_RID;
    *(RtlSubAuthoritySid( NetworkSid,      0 )) = SECURITY_NETWORK_RID;
    *(RtlSubAuthoritySid( BatchSid,        0 )) = SECURITY_BATCH_RID;
    *(RtlSubAuthoritySid( InteractiveSid,  0 )) = SECURITY_INTERACTIVE_RID;
    *(RtlSubAuthoritySid( LocalSystemSid,  0 )) = SECURITY_LOCAL_SYSTEM_RID;

    return;

}



VOID
PrintAcl (
    IN PACL Acl
    )

/*++

Routine Description:

    This routine dumps an Acl for debug purposes (via printf).  It is
    specialized to dump standard aces.

Arguments:

    Acl - Supplies the Acl to dump

Return Value:

    None

--*/


{
    ULONG i;
    PKNOWN_ACE Ace;
    BOOLEAN KnownType;
    PCHAR AceTypes[] = { "Access Allowed",
                         "Access Denied ",
                         "System Audit  ",
                         "System Alarm  "
                       };

    if (Acl == NULL) {

        printf("\tAcl == ALL ACCESS GRANTED!\n");
        return;

    }

    //
    //  Dump the Acl header
    //

    printf("\tRevision: %02x", Acl->AclRevision);
    printf(" Size: %04x", Acl->AclSize);
    printf(" AceCount: %04x\n", Acl->AceCount);

    //
    //  Now for each Ace we want do dump it
    //

    for (i = 0, Ace = FirstAce(Acl);
         i < Acl->AceCount;
         i++, Ace = NextAce(Ace) ) {

        //
        //  print out the ace header
        //

        printf("\n\tAceHeader: %08lx ", *(PULONG)Ace);

        //
        //  special case on the standard ace types
        //

        if ((Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
            (Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) ||
            (Ace->Header.AceType == SYSTEM_AUDIT_ACE_TYPE) ||
            (Ace->Header.AceType == SYSTEM_ALARM_ACE_TYPE)) {

            //
            //  The following array is indexed by ace types and must
            //  follow the allowed, denied, audit, alarm seqeuence
            //

            PCHAR AceTypes[] = { "Access Allowed",
                                 "Access Denied ",
                                 "System Audit  ",
                                 "System Alarm  "
                               };

            printf(AceTypes[Ace->Header.AceType]);
            PrintAccessMask(Ace->Mask);
            KnownType = TRUE;

        } else {

            KnownType = FALSE;
            printf(" Unknown Ace Type\n");

        }

        printf("\n");

        printf("\tAceSize = %d\n",Ace->Header.AceSize);

        printf("\tAce Flags = ");
        if (Ace->Header.AceFlags & OBJECT_INHERIT_ACE) {
            printf("OBJECT_INHERIT_ACE\n");
            printf("                   ");
        }

        if (Ace->Header.AceFlags & CONTAINER_INHERIT_ACE) {
            printf("CONTAINER_INHERIT_ACE\n");
            printf("                   ");
        }

        if (Ace->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE) {
            printf("NO_PROPAGATE_INHERIT_ACE\n");
            printf("                   ");
        }

        if (Ace->Header.AceFlags & INHERIT_ONLY_ACE) {
            printf("INHERIT_ONLY_ACE\n");
            printf("                   ");
        }

        if (Ace->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
            printf("SUCCESSFUL_ACCESS_ACE_FLAG\n");
            printf("            ");
        }

        if (Ace->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) {
            printf("FAILED_ACCESS_ACE_FLAG\n");
            printf("            ");
        }

        printf("\n");

        printf("\tSid = ");
        DisplayAccountSid(&Ace->SidStart);
    }

}


VOID
PrintAccessMask(
    IN ACCESS_MASK AccessMask
    )
{
    printf("\n\tAccess Mask: ");

    if (AccessMask == KEY_ALL_ACCESS) {
        printf("KEY_ALL_ACCESS\n\t             ");
        return;
    }
    if (AccessMask == KEY_READ) {
        printf("KEY_READ\n\t             ");
        return;
    }
    if (AccessMask == KEY_WRITE) {
        printf("KEY_WRITE\n\t             ");
        return;
    }

    if (AccessMask & KEY_QUERY_VALUE) {
        printf("KEY_QUERY_VALUE\n\t             ");
    }
    if (AccessMask & KEY_SET_VALUE) {
        printf("KEY_SET_VALUE\n\t             ");
    }
    if (AccessMask & KEY_CREATE_SUB_KEY) {
        printf("KEY_CREATE_SUB_KEY\n\t             ");
    }
    if (AccessMask & KEY_ENUMERATE_SUB_KEYS) {
        printf("KEY_ENUMERATE_SUB_KEYS\n\t             ");
    }
    if (AccessMask & KEY_NOTIFY) {
        printf("KEY_NOTIFY\n\t             ");
    }
    if (AccessMask & KEY_CREATE_LINK) {
        printf("KEY_CREATE_LINK\n\t             ");
    }
    if (AccessMask & GENERIC_ALL) {
        printf("GENERIC_ALL\n\t             ");
    }
    if (AccessMask & GENERIC_EXECUTE) {
        printf("GENERIC_EXECUTE\n\t             ");
    }
    if (AccessMask & GENERIC_WRITE) {
        printf("GENERIC_WRITE\n\t             ");
    }
    if (AccessMask & GENERIC_READ) {
        printf("GENERIC_READ\n\t             ");
    }
    if (AccessMask & GENERIC_READ) {
        printf("GENERIC_READ\n\t             ");
    }
    if (AccessMask & MAXIMUM_ALLOWED) {
        printf("MAXIMUM_ALLOWED\n\t             ");
    }
    if (AccessMask & ACCESS_SYSTEM_SECURITY) {
        printf("ACCESS_SYSTEM_SECURITY\n\t             ");
    }
    if (AccessMask & WRITE_OWNER) {
        printf("WRITE_OWNER\n\t             ");
    }
    if (AccessMask & WRITE_DAC) {
        printf("WRITE_DAC\n\t             ");
    }
    if (AccessMask & READ_CONTROL) {
        printf("READ_CONTROL\n\t             ");
    }
    if (AccessMask & DELETE) {
        printf("DELETE\n\t             ");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtdmp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdmp.c

Abstract:

    NT level registry api test program #3, basic non-error paths.

    Dump out a sub-tree of the registry.

    rtdmp <KeyPath>

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    It assumes data values are null terminated strings.

    Example:

        rtdmp \REGISTRY\MACHINE\TEST\bigkey


        \REGISTRY\MACHINE\TEST\bigkey::

            ValueTest1_01 type=0 ti=1
            "This is a test string"

            ValueTest1_01 type=0 ti=2
            "This is a test string"

        \REGISTRY\MACHCINE\TEST\bigkey\child_key_1::

            ValueTest1_01 type=0 ti=1
            "This is a test string"

            ValueTest1_01 type=0 ti=2
            "This is a test string"
Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE 16384

void __cdecl main(int, char *);
void processargs();

void print(PUNICODE_STRING);

void
DumpValues(
    HANDLE  Handle
    );

void
Dump(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdmp: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdmp: t0: %08lx\n", status);
        exit(1);
    }

    Dump(BaseHandle);
}


void
Dump(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  WorkHandle;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];
    PUCHAR  p;

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    NamePos = WorkName.Length;

    //
    // Print name of node we are about to dump out
    //
    print(&WorkName);
    printf("::\n\n");

    //
    // Print out node's values
    //
    DumpValues(Handle);

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyInformation, WORK_SIZE);
        status = NtEnumerateKey(
                    Handle,
                    index,
                    KeyBasicInformation,
                    KeyInformation,
                    WORK_SIZE,
                    &ResultLength
                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            WorkName.Length = NamePos;
            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmp: dump1: status = %08lx\n", status);
            exit(1);

        }

        enumname.Buffer = &(KeyInformation->Name[0]);
        enumname.Length = KeyInformation->NameLength;
        enumname.MaximumLength = KeyInformation->NameLength;

        p = WorkName.Buffer;
        p += WorkName.Length;
        *p = '\\';
        p++;
        *p = '\0';
        WorkName.Length += 2;

        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&enumname);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &enumname,
            0,
            Handle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtOpenKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtdmp: dump2: %08lx\n", status);
            exit(1);
        }

        Dump(WorkHandle);
        NtClose(WorkHandle);
        WorkName.Length = NamePos;
    }
}


void
DumpValues(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    static  char        tempbuffer[WORK_SIZE];
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG   index;
    ULONG   ResultLength;
    PULONG  p;
    ULONG i;
    UNICODE_STRING valname;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)tempbuffer;

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyValueInformation, WORK_SIZE);
        status = NtEnumerateValueKey(
                    Handle,
                    index,
                    KeyValueFullInformation,
                    KeyValueInformation,
                    WORK_SIZE,
                    &ResultLength
                    );
        if (status == STATUS_NO_MORE_ENTRIES) {

            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmp: dumpvalues: status = %08lx\n", status);
            exit(1);

        }

        printf("\t");
        valname.Length = KeyValueInformation->NameLength;
        valname.MaximumLength = KeyValueInformation->NameLength;
        valname.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
        printf("'");
        print(&valname);
        printf("'\n");
        printf(
            "\ttitle index = %d\ttype = ",
            KeyValueInformation->TitleIndex
            );
        switch( KeyValueInformation->Type ) {
        case REG_NONE:
            printf("NONE\n\tValue = 0x%x",
                   *((PULONG)KeyValueInformation + KeyValueInformation->DataOffset));
            break;

        case REG_SZ:
            printf("REG_SZ\n\tValue = '%ws'",
                   ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset));
            break;

        case REG_BINARY:
            printf("REG_BINARY\n\tValue = (%lx)\n", KeyValueInformation->DataLength);
            p = (PULONG)KeyValueInformation + KeyValueInformation->DataOffset;
            i = 1;
            while (i <= KeyValueInformation->DataLength) {
                printf( "  %08lx", *p++ );
                if ((i % 8) == 0) {
                    printf( "\n" );
                }
                i += sizeof( ULONG );
            }
            break;

//      case REG_DWORD:
        case REG_DWORD_LITTLE_ENDIAN:
            printf("REG_DWORD\n\tValue = 0x%lx",
                   *((PULONG)KeyValueInformation + KeyValueInformation->DataOffset));
            break;

        case REG_DWORD_BIG_ENDIAN:
            printf("REG_DWORD_BIG_ENDIAN\n\tValue = 0x%lx",
                   *((PULONG)KeyValueInformation + KeyValueInformation->DataOffset));
            break;

        }
        printf("\n\n");
    }
}


void
print(
    PUNICODE_STRING  String
    )
{
    static  ANSI_STRING temp;
    static  char        tempbuffer[WORK_SIZE];

    temp.MaximumLength = WORK_SIZE;
    temp.Length = 0L;
    temp.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&temp, String, FALSE);
    printf("%s", temp.Buffer);
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        FALSE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtdmpb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdmp.c

Abstract:

    NT level registry api test program #3, basic non-error paths.

    Dump out a sub-tree of the registry.

    rtdmp <KeyPath>

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    It assumes data values are null terminated strings.

    Example:

        rtdmp \REGISTRY\MACHINE\TEST\bigkey


        \REGISTRY\MACHINE\TEST\bigkey::

            ValueTest1_01 type=0 ti=1
            "This is a test string"

            ValueTest1_01 type=0 ti=2
            "This is a test string"

        \REGISTRY\MACHCINE\TEST\bigkey\child_key_1::

            ValueTest1_01 type=0 ti=1
            "This is a test string"

            ValueTest1_01 type=0 ti=2
            "This is a test string"
Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE 16384

void __cdecl main(int, char *);
void processargs();

void print(PUNICODE_STRING);

void
DumpValues(
    HANDLE  Handle
    );

void
Dump(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdmp: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdmp: t0: %08lx\n", status);
        exit(1);
    }

    Dump(BaseHandle);
}


void
Dump(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  WorkHandle;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];
    PUCHAR  p;

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    NamePos = WorkName.Length;

    //
    // Print name of node we are about to dump out
    //
    print(&WorkName);
    printf("::\n\n");

    //
    // Print out node's values
    //
    DumpValues(Handle);

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyInformation, WORK_SIZE);
        status = NtEnumerateKey(
                    Handle,
                    index,
                    KeyBasicInformation,
                    KeyInformation,
                    WORK_SIZE,
                    &ResultLength
                    );

        if (status == STATUS_NO_MORE_ENTRIES) {

            WorkName.Length = NamePos;
            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmp: dump1: status = %08lx\n", status);
            exit(1);

        }

        enumname.Buffer = &(KeyInformation->Name[0]);
        enumname.Length = KeyInformation->NameLength;
        enumname.MaximumLength = KeyInformation->NameLength;

        p = WorkName.Buffer;
        p += WorkName.Length;
        *p = '\\';
        p++;
        *p = '\0';
        WorkName.Length += 2;

        RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&enumname);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &enumname,
            0,
            Handle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtOpenKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtdmp: dump2: %08lx\n", status);
            exit(1);
        }

        Dump(WorkHandle);
        NtClose(WorkHandle);
        WorkName.Length = NamePos;
    }
}


void
DumpValues(
    HANDLE  Handle
    )
{
    NTSTATUS    status;
    static  char        tempbuffer[WORK_SIZE];
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG   index;
    ULONG   ResultLength;
    PULONG  p;
    ULONG i;
    UNICODE_STRING valname;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)tempbuffer;

    for (index = 0; TRUE; index++) {

        RtlZeroMemory(KeyValueInformation, WORK_SIZE);
        status = NtEnumerateValueKey(
                    Handle,
                    index,
                    KeyValueFullInformation,
                    KeyValueInformation,
                    WORK_SIZE,
                    &ResultLength
                    );
        if (status == STATUS_NO_MORE_ENTRIES) {

            return;

        } else if (!NT_SUCCESS(status)) {

            printf("rtdmp: dumpvalues: status = %08lx\n", status);
            exit(1);

        }

        printf("\t");
        valname.Length = KeyValueInformation->NameLength;
        valname.MaximumLength = KeyValueInformation->NameLength;
        valname.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
        printf("'");
        print(&valname);
        printf("'\n");
        printf(
            "\ttitle index = %d\ttype = ",
            KeyValueInformation->TitleIndex
            );
        printf("REG_BINARY\n\tValue = (%lx)\n", KeyValueInformation->DataLength);
        p = (PULONG)KeyValueInformation + KeyValueInformation->DataOffset;
        i = 1;
        while (i <= KeyValueInformation->DataLength) {
            printf( "  %08lx", *p++ );
            if ((i % 8) == 0) {
                printf( "\n" );
            }
            i += sizeof( ULONG );
        }
        printf("\n\n");
    }
}


void
print(
    PUNICODE_STRING  String
    )
{
    static  ANSI_STRING temp;
    static  char        tempbuffer[WORK_SIZE];

    temp.MaximumLength = WORK_SIZE;
    temp.Length = 0L;
    temp.Buffer = tempbuffer;

    RtlUnicodeStringToAnsiString(&temp, String, FALSE);
    printf("%s", temp.Buffer);
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        FALSE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtdmpval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtdmpval.c

Abstract:

    NT level registry api test program, basic non-error paths.

    dump a key's value entry (field)

    rtdmpval <KeyPath> <value entry name>

    Example:

        rtdmpval \REGISTRY\MACHINE\TEST\bigkey first_value_field

Author:

    John Vert (jvert) 25-Mar-1993 (written expressly for reading JimK's
        supersecret file)

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

UNICODE_STRING  ValueName;
WCHAR           valuebuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    KEY_VALUE_PARTIAL_INFORMATION PartialInfo;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;
    ULONG i;
    ULONG Count;


    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);


    ValueName.MaximumLength = WORK_SIZE;
    ValueName.Length = 0L;
    ValueName.Buffer = &(valuebuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtdmpval: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_READ,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtdmpval: t0: %08lx\n", status);
        exit(1);
    }

    status = NtQueryValueKey(BaseHandle,
                             &ValueName,
                             KeyValuePartialInformation,
                             &PartialInfo,
                             sizeof(PartialInfo),
                             &Count);

    pInfo=malloc(PartialInfo.DataLength+sizeof(PartialInfo));
    status = NtQueryValueKey(BaseHandle,
                             &ValueName,
                             KeyValuePartialInformation,
                             pInfo,
                             PartialInfo.DataLength+sizeof(PartialInfo),
                             &Count);
    if (!NT_SUCCESS(status)) {
        printf("rtdmpval: t2: %08lx\n", status);
        exit(1);
    }

    for (i=0; i<PartialInfo.DataLength; i++) {
        printf("%c",pInfo->Data[i]);
    }

    free(pInfo);
    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 3) )
    {
        printf("Usage: %s <KeyPath> <value entry name>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &ValueName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtmisc1.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtmisc1.c

Abstract:

    NT level registry api test program #1, basic non-error paths.

    Test open, create, setvalue, queryvalue, enumeratekey, enumeratevalue,
    querykey.

Author:

    Bryan Willman (bryanwi)  19-Nov-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//
//  NOTE:   This version of the test operations on \REGISTRY\MACHINE\TEST\*,
//          which is the TEST hive.  This hive will not exist in production
//          systems, so the test will have to change.
//


void __cdecl main(int, char *);

VOID
NameClassAndTitle(
    KEY_NODE_INFORMATION    *NodeInformation,
    UNICODE_STRING          ClassName,
    ULONG                   TitleIndex,
    UNICODE_STRING          KeyName,
    LARGE_INTEGER           CompTime,
    BOOLEAN                 Strong,         // time must be >= CompTime
    PUCHAR                  TestName
    );

VOID
expectstring(
    PWSTR   expected,
    ULONG   expectedlength,
    PWSTR   actual,
    ULONG   actuallength
    );

VOID
expecttime(
    LARGE_INTEGER   ExpectTime,
    LARGE_INTEGER   ActualTime
    );


#define TITLE_INDEX_1   122259
#define TITLE_INDEX_2   120858
#define TITLE_INDEX_3   120159
#define TYPE_1          666
#define TYPE_2          1066


ULONG           failure = 0;


void
__cdecl main(int, char *)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  KeyName;
    UNICODE_STRING  KeyName2;
    UNICODE_STRING  ClassName;
    UNICODE_STRING  ClassName2;
    UNICODE_STRING  ValueName;
    UNICODE_STRING  ValueName2;
    HANDLE          BaseHandle;
    HANDLE          Testhand1;
    ULONG           Disposition;
    LARGE_INTEGER   CompTime;
    ULONG           buffer[100];
    ULONG           bufsize = sizeof(ULONG) * 100;
    PKEY_NODE_INFORMATION NodeInformation;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    PKEY_VALUE_BASIC_INFORMATION KeyValueBasic;
    ULONG           ResultLength;
    PUCHAR          datastring = "Some simple ascii data for use as a value";
    PUCHAR          datastring2 = "Some more not so simple data $#";
    ULONG           expected;
    PVOID           tp;


    printf("rtmisc1: starting\n");

    NodeInformation = (PKEY_NODE_INFORMATION)&(buffer[0]);
    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)&(buffer[0]);
    KeyValueBasic = (PKEY_VALUE_BASIC_INFORMATION)&(buffer[0]);

    //
    // t0: Perform all operations against a base node, open it here.
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\REGISTRY\\MACHINE\\TEST"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t0: %08lx\n", status);
        goto punt;
    }


    //
    // t1: Create a key with class and title index
    //

    RtlInitUnicodeString(
        &ClassName,
        L"t1 Class Name"
        );

    RtlInitUnicodeString(
        &KeyName,
        L"first_test_node"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        BaseHandle,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    NtQuerySystemTime(&CompTime);

//  printf("ClassName@%08lx  KeyName@%08lx\n",
//          ClassName.Buffer, KeyName.Buffer);

    status = NtCreateKey(
                &Testhand1,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                TITLE_INDEX_1,
                &ClassName,
                0,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t1: %08lx\n", status);
        goto punt;
    }

    if (Disposition != REG_CREATED_NEW_KEY) {
        printf("rtmisc1: t1a: got old key, expected to create new one\n");
        failure++;
    }

    //
    // t2: See if we can get data back, and if it makes sense
    //

    RtlZeroMemory(NodeInformation, bufsize);
    status = NtQueryKey(
                Testhand1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t2a: %08lx\n", status);
        goto punt;
    }
    if (ResultLength != 80) {
        printf("rtmisc1: t2i: expect 80, ResultLength = %d\n", ResultLength);
        failure++;
    }


    NameClassAndTitle(
        NodeInformation,
        ClassName,
        TITLE_INDEX_1,
        KeyName,
        CompTime,
        FALSE,          // time must be >= CompTime
        "rtmisc1: t2b: "
        );
    CompTime = NodeInformation->LastWriteTime;

    status = NtClose(Testhand1);
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t2c: %08lx\n");
        goto punt;
    }


    //
    // t3: Reopen the key with create, see if data still there.
    //

    status = NtCreateKey(
                &Testhand1,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                TITLE_INDEX_1,
                &ClassName,
                0,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t3: %08lx\n", status);
        goto punt;
    }

    if (Disposition != REG_OPENED_EXISTING_KEY) {
        printf("rtmisc1: t3a failure\n");
        failure++;
    }

    RtlZeroMemory(NodeInformation, bufsize);
    status = NtQueryKey(
                Testhand1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t3b: %08lx\n", status);
        goto punt;
    }

    NameClassAndTitle(
        NodeInformation,
        ClassName,
        TITLE_INDEX_1,
        KeyName,
        CompTime,
        FALSE,          // time must be >= CompTime
        "rtmisc1: t3c: "
        );

    status = NtClose(Testhand1);
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t3d: %08lx\n");
        goto punt;
    }


    //
    // t4: Reopen the key with open, see if data still there.
    //

    status = NtOpenKey(
                &Testhand1,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t4: %08lx\n", status);
        goto punt;
    }

    RtlZeroMemory(NodeInformation, bufsize);
    status = NtQueryKey(
                Testhand1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t4a: %08lx\n", status);
        goto punt;
    }

    NameClassAndTitle(
        NodeInformation,
        ClassName,
        TITLE_INDEX_1,
        KeyName,
        CompTime,
        FALSE,          // time must be >= CompTime
        "rtmisc1: t4b: "
        );

//  status = NtClose(Testhand1);
//  if (!NT_SUCCESS(status)) {
//      printf("rtmisc1: t4c: %08lx\n");
//      exit(1);
//  }


    //
    // t5: Create a value
    //

    RtlInitUnicodeString(
        &ValueName,
        L"the very first value stored in the registry"
        );


    status = NtSetValueKey(
                Testhand1,
                &ValueName,
                TITLE_INDEX_2,
                TYPE_1,
                datastring,
                strlen(datastring)+1
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t5: %08lx\n", status);
        failure++;
    }


    //
    // t6: Read the value back
    //

    RtlZeroMemory(KeyValueInformation, bufsize);
    status = NtQueryValueKey(
                Testhand1,
                &ValueName,
                KeyValueFullInformation,
                KeyValueInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t6: %08lx\n", status);
        goto punt;
    }
    expected = FIELD_OFFSET(KEY_VALUE_FULL_INFORMATION, Name) +
                    ValueName.Length + strlen(datastring) + 1;
    if (ResultLength != expected) {
        printf("rtmisc1: t6a: expected = %08lx actual = %08lx",
                expected, ResultLength);
        failure++;
    }

    if ( (KeyValueInformation->TitleIndex != TITLE_INDEX_2)         ||
         (KeyValueInformation->Type != TYPE_1)                      ||
         (KeyValueInformation->NameLength != ValueName.Length)      ||
         (KeyValueInformation->DataLength != strlen(datastring)+1))
    {
        printf("rtmisc1: t6b: wrong description data\n");
        failure++;
    }


    tp = (PWSTR)&(KeyValueInformation->Name[0]);
    if (wcsncmp(ValueName.Buffer, tp, (ValueName.Length/sizeof(WCHAR))) != 0) {
        printf("rtmisc1: t6c: wrong name\n");
        expectstring(
            ValueName.Buffer,
            (ValueName.Length/sizeof(WCHAR)),
            (PWSTR)&(KeyValueInformation->Name[0]),
            (KeyValueInformation->NameLength/sizeof(WCHAR))
            );
        failure++;
    }


    tp = (PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset;
    if (strcmp(tp, datastring) != 0) {
        printf("rtmisc1: t6d: wrong data\n");
        printf("expected '%s', got '%s'\n", datastring, tp);
        failure++;
    }

    //
    // t7: Create a second value
    //

    RtlInitUnicodeString(
        &ValueName2,
        L"the second value stored in the registry"
        );


    status = NtSetValueKey(
                Testhand1,
                &ValueName2,
                TITLE_INDEX_3,
                TYPE_2,
                datastring2,
                strlen(datastring2)+1
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t7: %08lx\n", status);
        failure++;
    }

    //
    // t8: Read the second value back (short form)
    //

    RtlZeroMemory(KeyValueBasic, bufsize);
    status = NtQueryValueKey(
                Testhand1,
                &ValueName2,
                KeyValueBasicInformation,
                KeyValueBasic,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t8: %08lx\n", status);
        goto punt;
    }

    expected = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name) +
                    ValueName2.Length;
    if (ResultLength != expected) {
        printf("rtmisc1: t8a: expected = %08lx actual = %08lx",
                expected, ResultLength);
        failure++;
    }

    if ( (KeyValueBasic->TitleIndex != TITLE_INDEX_3)         ||
         (KeyValueBasic->Type != TYPE_2)                      ||
         (KeyValueBasic->NameLength != ValueName2.Length))
    {
        printf("rtmisc1: t8b: wrong description data\n");
        failure++;
    }


    tp = (PWSTR)&(KeyValueBasic->Name[0]);
    if (wcsncmp(ValueName2.Buffer, tp, (ValueName2.Length/sizeof(WCHAR))) != 0) {
        printf("rtmisc1: t8c: wrong name\n");
        expectstring(
            ValueName2.Buffer,
            (ValueName2.Length/sizeof(WCHAR)),
            (PWSTR)&(KeyValueBasic->Name[0]),
            (KeyValueBasic->NameLength/sizeof(WCHAR))
            );
        failure++;
    }


    //
    // t9: Enumerate the values (short form)
    //

    RtlZeroMemory(KeyValueBasic, bufsize);
    status = NtEnumerateValueKey(
                Testhand1,
                0,              // Index
                KeyValueBasicInformation,
                KeyValueBasic,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t9: %08lx\n", status);
        goto punt;
    }

    expected = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name) +
                    ValueName.Length;
    if (ResultLength != expected) {
        printf("rtmisc1: t9a: expected = %08lx actual = %08lx",
                expected, ResultLength);
        failure++;
    }

    if (KeyValueBasic->NameLength != ValueName.Length)
    {
        printf("rtmisc1: t9b: wrong description data\n");
        failure++;
    }


    tp = (PWSTR)&(KeyValueBasic->Name[0]);
    if (wcsncmp(ValueName.Buffer, tp, (ValueName.Length/sizeof(WCHAR))) != 0) {
        printf("rtmisc1: t9c: wrong name\n");
        expectstring(
            ValueName.Buffer,
            (ValueName.Length/sizeof(WCHAR)),
            (PWSTR)&(KeyValueBasic->Name[0]),
            (KeyValueBasic->NameLength/sizeof(WCHAR))
            );
        failure++;
    }

    RtlZeroMemory(KeyValueBasic, bufsize);
    status = NtEnumerateValueKey(
                Testhand1,
                1,              // Index
                KeyValueBasicInformation,
                KeyValueBasic,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t9d: %08lx\n", status);
        goto punt;
    }

    expected = FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name) +
                    ValueName2.Length;
    if (ResultLength != expected) {
        printf("rtmisc1: t9e: expected = %08lx actual = %08lx",
                expected, ResultLength);
        failure++;
    }

    if (KeyValueBasic->NameLength != ValueName2.Length)
    {
        printf("rtmisc1: t9f: wrong description data\n");
        failure++;
    }


    tp = (PWSTR)&(KeyValueBasic->Name[0]);
    if (wcsncmp(ValueName2.Buffer, tp, (ValueName2.Length/sizeof(WCHAR))) != 0) {
        printf("rtmisc1: t9g: wrong name\n");
        expectstring(
            ValueName2.Buffer,
            (ValueName2.Length/sizeof(WCHAR)),
            (PWSTR)&(KeyValueBasic->Name[0]),
            (KeyValueBasic->NameLength/sizeof(WCHAR))
            );
        failure++;
    }

    status = NtEnumerateValueKey(
                Testhand1,
                2,              // Index
                KeyValueBasicInformation,
                KeyValueBasic,
                bufsize,
                &ResultLength
                );
    if (status != STATUS_NO_MORE_ENTRIES) {
        printf("rtmisc1: t9h: %08lx\n", status);
        goto punt;
    }

    //
    // t10: create a second subkey and ennumerate the subkeys
    //

    status = NtClose(Testhand1);
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10a: %08lx\n", status);
        failure++;
    }

    RtlInitUnicodeString(
        &ClassName2,
        L"t2 Class Name"
        );

    RtlInitUnicodeString(
        &KeyName2,
        L"second_test_node"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName2,
        0,
        BaseHandle,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtCreateKey(
                &Testhand1,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                TITLE_INDEX_2,
                &ClassName2,
                0,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10b: %08lx\n", status);
        goto punt;
    }

    if (Disposition != REG_CREATED_NEW_KEY) {
        printf("rtmisc1: t10c: got old key, expected to create new one\n");
        failure++;
    }

    //
    // See if we can get data back, and if it makes sense
    //

    RtlZeroMemory(NodeInformation, bufsize);
    status = NtQueryKey(
                Testhand1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10d: %08lx\n", status);
        goto punt;
    }
    CompTime = NodeInformation->LastWriteTime;


    NameClassAndTitle(
        NodeInformation,
        ClassName2,
        TITLE_INDEX_2,
        KeyName2,
        CompTime,
        TRUE,
        "rtmisc1: t10e: "
        );

    status = NtClose(Testhand1);
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10f: %08lx\n");
        goto punt;
    }


    RtlZeroMemory(NodeInformation, bufsize);
    status = NtEnumerateKey(
                BaseHandle,
                0,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10g: %08lx\n", status);
        failure++;
    }
    CompTime = NodeInformation->LastWriteTime;

    NameClassAndTitle(
        NodeInformation,
        ClassName,
        TITLE_INDEX_1,
        KeyName,
        CompTime,
        TRUE,
        "rtmisc1: t10h: "
        );


    RtlZeroMemory(NodeInformation, bufsize);
    status = NtEnumerateKey(
                BaseHandle,
                1,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (!NT_SUCCESS(status)) {
        printf("rtmisc1: t10i: %08lx\n", status);
        failure++;
    }
    CompTime = NodeInformation->LastWriteTime;

    NameClassAndTitle(
        NodeInformation,
        ClassName2,
        TITLE_INDEX_2,
        KeyName2,
        CompTime,
        TRUE,
        "rtmisc1: t10j: "
        );


    status = NtEnumerateKey(
                BaseHandle,
                2,
                KeyNodeInformation,
                NodeInformation,
                bufsize,
                &ResultLength
                );
    if (status != STATUS_NO_MORE_ENTRIES) {
        printf("rtmisc1: t10k: %08lx\n", status);
        failure++;
    }

    //
    // Summary report
    //

    if (!failure) {
        printf("rtmisc1: success");
        exit(0);
    } else {
        printf("rtmisc1: failed, %d failures\n", failure);
        exit(1);
    }

punt:
    failure++;
    printf("rtmisc1: failed, %d failures\n", failure);
    exit(1);
}



VOID
NameClassAndTitle(
    KEY_NODE_INFORMATION    *NodeInformation,
    UNICODE_STRING          ClassName,
    ULONG                   TitleIndex,
    UNICODE_STRING          KeyName,
    LARGE_INTEGER           CompTime,
    BOOLEAN                 Strong,         // time must be >= CompTime
    PUCHAR                  TestName
    )
{
    PWSTR   p;

    if (Strong) {

        //
        // require exact match
        //

        if ((CompTime.HighPart != NodeInformation->LastWriteTime.HighPart) ||
            (CompTime.LowPart != NodeInformation->LastWriteTime.LowPart))
        {
            printf("%s Wrong time (a)\n", TestName);
            expecttime(CompTime, NodeInformation->LastWriteTime);
            failure++;
        }


    } else {

        //
        // >= will do
        //

        if ( (CompTime.HighPart > NodeInformation->LastWriteTime.HighPart) ||
             ((CompTime.HighPart == NodeInformation->LastWriteTime.HighPart) &&
              (CompTime.LowPart > NodeInformation->LastWriteTime.LowPart)) )
        {
            printf("%s Wrong time (b)\n", TestName);
            expecttime(CompTime, NodeInformation->LastWriteTime);
            failure++;
        }
    }


    p = (PWSTR)((PUCHAR)NodeInformation + NodeInformation->ClassOffset);
    if ( (NodeInformation->ClassLength != ClassName.Length) ||
         (wcsncmp(ClassName.Buffer, p, (ClassName.Length/sizeof(WCHAR))) != 0))
    {
        printf("%s wrong class name\n", TestName);
        failure++;
    }

    if (NodeInformation->TitleIndex != TitleIndex) {
        printf("%s wrong title index\n", TestName);
        failure++;
    }

    p = (PWSTR)(&(NodeInformation->Name[0]));
    if ( (NodeInformation->NameLength != KeyName.Length) ||
         (wcsncmp(KeyName.Buffer, p, (KeyName.Length/sizeof(WCHAR))) != 0))
    {
        printf("%s wrong name\n", TestName);
        expectstring(
            KeyName.Buffer,
            (KeyName.Length/sizeof(WCHAR)),
            (PWSTR)&(NodeInformation->Name[0]),
            (NodeInformation->NameLength/sizeof(WCHAR))
            );
        failure++;
    }
}

VOID
expecttime(
    LARGE_INTEGER   ExpectTime,
    LARGE_INTEGER   ActualTime
    )
{
    printf("Expected %08lx%08lx\n", ExpectTime.HighPart, ExpectTime.LowPart);
    printf("Got      %08lx%08lx\n", ActualTime.HighPart, ActualTime.LowPart);
    return;
}

VOID
expectstring(
    PWSTR   expected,
    ULONG   expectedlength,
    PWSTR   actual,
    ULONG   actuallength
    )
{
    ULONG   i;

    printf("Expected Len %d Str = '", expectedlength);
    for (i = 0; i < expectedlength; i++) {
        printf("%c", (UCHAR)(expected[i]));
    }
    printf("'\n");

    printf("Got Len %d Str = '", actuallength);
    for (i = 0; i < actuallength; i++) {
        printf("%c", (UCHAR)(actual[i]));
    }
    printf("'\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtload.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtload.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtLoadKey call to link a hive file into the registry.

    If KeyPath is not present, it loads the hive file at
        \Registry\User\FileName

    rtload  [ <KeyPath> ] <FileName>

    Example:

        rtload \registry\user\JVert JVUser

Author:

    John Vert (jvert) 15-Apr-92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  FileName;
WCHAR           FileNameBuffer[WORK_SIZE];

OBJECT_ATTRIBUTES FileAttributes;
OBJECT_ATTRIBUTES KeyAttributes;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    FileName.MaximumLength = WORK_SIZE;
    FileName.Length = 0L;
    FileName.Buffer = &(FileNameBuffer[0]);

    processargs(argc, argv);


    //
    // Set up FileName
    //

    printf("rtload: starting\n");


    status = NtLoadKey(&KeyAttributes, &FileAttributes);
    if (!NT_SUCCESS(status)) {
        printf("rtload: key load failed status = %08lx\n", status);
        exit(1);
    } else {
        printf("rtload: success!\n");
    }

    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    UNICODE_STRING DosFileName;
    HANDLE UserHandle;
    PWSTR FilePart;
    NTSTATUS Status;

    if ( (argc != 2) && (argc != 3))
    {
        printf("Usage: %s [ <KeyName> ] <FileName>\n",
                argv[0]);
        exit(1);
    }
    if (argc == 3) {

        RtlInitAnsiString(
            &temp,
            argv[1]
            );

        RtlAnsiStringToUnicodeString(
            &KeyPath,
            &temp,
            TRUE
            );

        RtlInitAnsiString(
            &temp,
            argv[2]
            );

        RtlAnsiStringToUnicodeString(
            &DosFileName,
            &temp,
            TRUE
            );

        RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                      &FileName,
                                      NULL,
                                      NULL );

        InitializeObjectAttributes(
            &FileAttributes,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            (HANDLE)NULL,
            NULL
            );

        //
        // Set up KeyPath
        //

        InitializeObjectAttributes(
            &KeyAttributes,
            &KeyPath,
            OBJ_CASE_INSENSITIVE,
            (HANDLE)NULL,
            NULL
            );
    } else if (argc==2) {
        RtlInitAnsiString(&temp, argv[1]);
        RtlAnsiStringToUnicodeString(&DosFileName, &temp, TRUE);
        RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                      &FileName,
                                      &FilePart,
                                      NULL );

        InitializeObjectAttributes( &FileAttributes,
                                    &FileName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );

        RtlInitUnicodeString(&KeyPath, L"\\Registry\\User");
        InitializeObjectAttributes( &KeyAttributes,
                                    &KeyPath,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );
        Status = NtOpenKey( &UserHandle,
                            KEY_READ,
                            &KeyAttributes);
        if (!NT_SUCCESS(Status)) {
            printf("Couldn't open \\Registry\\User, status %08lx\n",Status);
            exit(1);
        }

        RtlInitUnicodeString(&KeyPath, FilePart);
        InitializeObjectAttributes( &KeyAttributes,
                                    &KeyPath,
                                    OBJ_CASE_INSENSITIVE,
                                    UserHandle,
                                    NULL );

    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtflush.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rtflush.c

Abstract:

    NT level registry test program, basic non-error paths.

    Flush a key.

    rtflush <KeyPath>

    Will flush the key named by <KeyPath>

    Example:

        rtflush \REGISTRY\MACHINE\TEST\bigkey

Author:

    Bryan Willman (bryanwi)  10-Jan-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtflush: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtflush: t0: %08lx\n", status);
        exit(1);
    }

    status = NtFlushKey(BaseHandle);
    if (!NT_SUCCESS(status)) {
        printf("rtflush: t0: %08lx\n", status);
        exit(1);
    }

    NtClose(BaseHandle);
    exit(0);
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyPath>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        FALSE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtqkey.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtqkey.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Do a query on a key.

    rtqkey <KeyPath> [infotypenumber] [bufferlength]

    Example:

        rtqkey \REGISTRY\MACHINE\TEST\bigkey 1 100

Author:

    Bryan Willman (bryanwi)  9-Apr-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

UCHAR       Buffer[1024*64];

ULONG       InfoType = KeyFullInformation;
ULONG       BufferSize = -1;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    ULONG   Sizes[] = { sizeof(KEY_BASIC_INFORMATION),
                        sizeof(KEY_NODE_INFORMATION),
                        sizeof(KEY_FULL_INFORMATION) };
    ULONG       ResultLength;
    PKEY_BASIC_INFORMATION pbasic;
    PKEY_NODE_INFORMATION  pnode;
    PKEY_FULL_INFORMATION  pfull;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtqkey: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_QUERY_VALUE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtqkey: t0: %08lx\n", status);
        exit(1);
    }

    //
    // make test call
    //
    RtlFillMemory((PVOID)&(Buffer[0]), 1024*64, 0xaa);

    if (BufferSize == -1) {
        BufferSize = Sizes[InfoType];
    }

    status = NtQueryKey(
                BaseHandle,
                InfoType,
                (PVOID)&(Buffer[0]),
                BufferSize,
                &ResultLength
                );

    printf("status = %08lx  ResultLength = %08lx\n", status, ResultLength);
    switch (InfoType) {
    case KeyBasicInformation:
        pbasic = (PKEY_BASIC_INFORMATION)Buffer;
        printf("LastWriteTime: %08lx:%08lx\n", pbasic->LastWriteTime.HighPart,
                pbasic->LastWriteTime.LowPart);
        printf("TitleIndex: %08lx\n", pbasic->TitleIndex);
        printf("NameLength: %08lx\n", pbasic->NameLength);
        printf("Name: '%.*ws'\n", pbasic->NameLength/2, &(pbasic->Name));
        break;

    case KeyNodeInformation:
        pnode = (PKEY_NODE_INFORMATION)Buffer;
        printf("LastWriteTime: %08lx:%08lx\n", pnode->LastWriteTime.HighPart,
                pnode->LastWriteTime.LowPart);
        printf("TitleIndex: %08lx\n", pnode->TitleIndex);
        printf("ClassOffset: %08lx\n", pnode->ClassOffset);
        printf("ClassLength: %08lx\n", pnode->ClassLength);
        printf("NameLength: %08lx\n", pnode->NameLength);
        printf("Name: '%.*ws'\n", pnode->NameLength/2, &(pnode->Name));
        printf("Class: '%.*ws'\n", pnode->ClassLength/2,
                    (PWSTR)((PUCHAR)pnode + pnode->ClassOffset));
        break;

    case KeyFullInformation:
        pfull = (PKEY_FULL_INFORMATION)Buffer;
        printf("LastWriteTime: %08lx:%08lx\n", pfull->LastWriteTime.HighPart,
                pfull->LastWriteTime.LowPart);
        printf("TitleIndex: %08lx\n", pfull->TitleIndex);
        printf("ClassOffset: %08lx\n", pfull->ClassOffset);
        printf("ClassLength: %08lx\n", pfull->ClassLength);

        printf("SubKeys: %08lx       MaxNameLen: %08lx      MaxClassLen: %08lx\n",
                pfull->SubKeys, pfull->MaxNameLen, pfull->MaxClassLen);

        printf(" Values: %08lx  MaxValueNameLen: %08lx  MaxValueDataLen: %08lx\n",
                pfull->Values, pfull->MaxValueNameLen, pfull->MaxValueDataLen);

        printf("Class: '%.*ws'\n", pfull->ClassLength/2, pfull->Class);

        break;
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc < 2) )
    {
        printf("Usage: %s <KeyPath> [infotype] [bufferlen]\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    if (argc > 2) {
        InfoType = atoi(argv[2]);
    }

    if (argc > 3) {
        BufferSize = atoi(argv[3]);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtnotify.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rtnotify.c

Abstract:

    NT level registry test program, basic non-error paths.

    Wait for notification.

    This program tests waiting for notification on a change to
    a registry node.  It can wait synchronously, for an event,
    for for an Apc.  It can use any filter.

    Only the first letter of option control are significant.

    rtnotify <keyname> {key|tree|event|Apc|hold|name|write|security|prop|*}

        key = key only [default]  (last of these two wins)
        tree = subtree

        event = wait on an event (overrides hold)
        Apc = use an Apc         (overrides hold)
        hold = be synchronous [default]  (overrides event and Apc)

        name = watch for create/delete of children
        write = last set change
        security = acl change
        prop = any attr == security change
        * = all



    Example:

        rtflush \REGISTRY\MACHINE\TEST\bigkey

Author:

    Bryan Willman (bryanwi)  10-Jan-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void main();
void processargs();

ULONG CallCount = 0L;

VOID
ApcTest(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock
    );

UNICODE_STRING  KeyName;
WCHAR           workbuffer[WORK_SIZE];
BOOLEAN         WatchTree;
BOOLEAN         UseEvent;
BOOLEAN         UseApc;
BOOLEAN         ApcSeen;
BOOLEAN         Hold;
BOOLEAN         Filter;
IO_STATUS_BLOCK RtIoStatusBlock;


void
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    HANDLE          EventHandle;
    PIO_APC_ROUTINE ApcRoutine;

    //
    // Process args
    //

    KeyName.MaximumLength = WORK_SIZE;
    KeyName.Length = 0L;
    KeyName.Buffer = &(workbuffer[0]);

    processargs(argc, argv);

    //
    // Set up and open KeyPath
    //

    printf("rtnotify: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_NOTIFY,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtnotify: t0: %08lx\n", status);
        exit(1);
    }

    EventHandle = (HANDLE)NULL;
    if (UseEvent == TRUE) {
        status = NtCreateEvent(
                    &EventHandle,
                    GENERIC_READ | GENERIC_WRITE  | SYNCHRONIZE,
                    NULL,
                    NotificationEvent,
                    FALSE
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtnotify: t1: %08lx\n", status);
            exit(1);
        }
    }

    ApcRoutine = NULL;
    if (UseApc) {
        ApcRoutine = ApcTest;
    }

    printf("rtnotify:\n");
    printf("\tUseEvent = %08lx\n", UseEvent);
    printf("\tApcRoutine = %08lx\n", ApcRoutine);
    printf("\tHold = %08lx\n", Hold);
    printf("\tFilter = %08lx\n", Filter);
    printf("\tWatchTree = %08lx\n", WatchTree);

    while (TRUE) {
        ApcSeen = FALSE;
        printf("\nCallCount = %dt\n", CallCount);
        CallCount++;
        status = NtNotifyChangeKey(
                    BaseHandle,
                    EventHandle,
                    ApcRoutine,
                    (PVOID)1992,           // arbitrary context value
                    &RtIoStatusBlock,
                    Filter,
                    WatchTree,
                    NULL,
                    0,
                    ! Hold
                    );

        exit(0);

        if ( ! NT_SUCCESS(status)) {
            printf("rtnotify: t2: %08lx\n", status);
            exit(1);
        }

        if (Hold) {
            printf("rtnotify: Synchronous Status = %08lx\n", RtIoStatusBlock.Status);
        }

        if (UseEvent) {
            status = NtWaitForSingleObject(
                        EventHandle,
                        TRUE,
                        NULL
                        );
            if (!NT_SUCCESS(status)) {
                printf("rtnotify: t3: status = %08lx\n", status);
                exit(1);
            }
            printf("rtnotify: Event Status = %08lx\n", RtIoStatusBlock.Status);
        }

        if (UseApc) {
            while ((volatile)ApcSeen == FALSE) {
                NtTestAlert();
            }
        }
    }

    NtClose(BaseHandle);
    exit(0);
}


VOID
ApcTest(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock
    )
{
    ApcSeen = TRUE;

    if (ApcContext != (PVOID)1992) {
        printf("rtnotify: Apc: Apccontext is wrong %08lx\n", ApcContext);
        exit(1);
    }
    if (IoStatusBlock != &RtIoStatusBlock) {
        printf("rtnotify: Apc: IoStatusBlock is wrong %08ln", IoStatusBlock);
        exit(1);
    }


    printf("rtnotify: Apc status = %08lx\n", IoStatusBlock->Status);
    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    ULONG   i;

    if (argc < 2) {
        goto Usage;
    }

    //
    // name
    //
    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyName,
        &temp,
        FALSE
        );

    WatchTree = FALSE;
    UseEvent = FALSE;
    UseApc = FALSE;
    Hold = TRUE;
    Filter = 0;

    //
    // switches
    //
    for (i = 2; i < (ULONG)argc; i++) {
        switch (*argv[i]) {

        case 'a':   // Apc
        case 'A':
            Hold = FALSE;
            UseApc = TRUE;
            break;

        case 'e':   // event
        case 'E':
            Hold = FALSE;
            UseEvent = TRUE;
            break;

        case 'h':   // hold
        case 'H':
            UseApc = FALSE;
            UseEvent = FALSE;
            Hold = TRUE;
            break;

        case 'k':   // key only
        case 'K':
            WatchTree = FALSE;
            break;

        case 'n':
        case 'N':
            Filter |= REG_NOTIFY_CHANGE_NAME;
            break;

        case 'p':
        case 'P':
            Filter |= REG_NOTIFY_CHANGE_ATTRIBUTES;
            break;

        case 's':
        case 'S':
            Filter |= REG_NOTIFY_CHANGE_SECURITY;
            break;

        case 't':   // subtree
        case 'T':
            WatchTree = TRUE;
            break;

        case 'w':
        case 'W':
            Filter |= REG_NOTIFY_CHANGE_LAST_SET;
            break;

        case '*':
            Filter = REG_LEGAL_CHANGE_FILTER;
            break;

        default:
            goto Usage;
            break;
        }
    }
    if (Filter == 0) {
        Filter = REG_LEGAL_CHANGE_FILTER;
    }
    return;

Usage:
    printf("Usage: %s <KeyPath> {key|tree|event|Apc|sync|name|write|security|attribute|*}\n",
            argv[0]);
    exit(1);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtrenval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtrenval.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Rename a key value entry.

    rtrenval <KeyPath> <old value entry name> <new value entry name>

    Example:

        rtrenval \REGISTRY\MACHINE\TEST\bigkey apple banana

Author:

    Bryan Willman (bryanwi)  26-Feb-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

void
Delete(
    HANDLE  Handle
    );

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

UNICODE_STRING  ValueName;
WCHAR           valuebuffer[WORK_SIZE];

UNICODE_STRING  NewValueName;
WCHAR           newvaluebuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);


    ValueName.MaximumLength = WORK_SIZE;
    ValueName.Length = 0L;
    ValueName.Buffer = &(valuebuffer[0]);

    NewValueName.MaximumLength = WORK_SIZE;
    NewValueName.Length = 0L;
    NewValueName.Buffer = &(newvaluebuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //
    printf("rtrenval: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_SET_VALUE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtrenval: t0: %08lx\n", status);
        exit(1);
    }

    NtRenameValueKey(
        BaseHandle,
        &ValueName,
        &NewValueName,
        42
        );

    if (!NT_SUCCESS(status)) {
        printf("rtrenval: t1: %08lx\n", status);
        exit(1);
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 4) )
    {
        printf("Usage: %s <KeyPath> <old value entry name> <new value entry name>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &ValueName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[3]
        );

    RtlAnsiStringToUnicodeString(
        &NewValueName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtrest2.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtrest2.c

Abstract:

    NT level registry api test program, basic error path

    Creates a key "Key1" and a subkey, "Key2"

    Calls NtSaveKey on Key1, then NtRestoreKey while a handle to Key2 is
    still open.

    rtrest2  <KeyPath> <FileName>

    Example:

        rtrest2 \registry\machine\system\test tempfile

Author:

    John Vert (jvert) 13-Jun-1992

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  FileName;
WCHAR           FileNameBuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    FileName.MaximumLength = WORK_SIZE;
    FileName.Length = 0L;
    FileName.Buffer = &(FileNameBuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open FileName
    //

    printf("rtrestor: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtCreateFile(
                &FileHandle,
                GENERIC_READ | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                0,                                      // AllocationSize
                FILE_ATTRIBUTE_NORMAL,
                0,                                      // ShareAccess
                FILE_OPEN_IF,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                                   // EaBuffer
                0                                       // EaLength
                );

    if (!NT_SUCCESS(status)) {
        printf("rtsave: file open failed status = %08lx\n", status);
        exit(1);
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &KeyHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtsave: key open failed status = %08lx\n", status);
        exit(1);
    }

    status = NtRestoreKey(KeyHandle, FileHandle);

    if (!NT_SUCCESS(status)) {
        printf("rtrestor: NtRestorKey failed status = %08lx\n", status);
        exit(1);
    }

    printf("rtsave: success\n");
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 3) )
    {
        printf("Usage: %s <KeyName> <FileName>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &FileName,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtrestor.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtrestor.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtRestoreKey call to load part of the registry from a file.

    rtrestor  <KeyPath> <FileName>

    Example:

        rtrestor \registry\machine\user userfile.rd

Author:

    Bryan Willman (bryanwi)  24-Jan-92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  FileName;
WCHAR           FileNameBuffer[WORK_SIZE];

BOOLEAN HiveVolatile;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;
    BOOLEAN WasEnabled;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    FileName.MaximumLength = WORK_SIZE;
    FileName.Length = 0L;
    FileName.Buffer = &(FileNameBuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open FileName
    //

    printf("rtrestor: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtCreateFile(
                &FileHandle,
                GENERIC_READ | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                0,                                      // AllocationSize
                FILE_ATTRIBUTE_NORMAL,
                0,                                      // ShareAccess
                FILE_OPEN_IF,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                                   // EaBuffer
                0                                       // EaLength
                );

    if (!NT_SUCCESS(status)) {
        printf("rtsave: file open failed status = %08lx\n", status);
        exit(1);
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtsave: key open failed status = %08lx\n", status);
        exit(1);
    }

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (HiveVolatile) {
        status = NtRestoreKey(KeyHandle, FileHandle, REG_WHOLE_HIVE_VOLATILE);
    } else {
        status = NtRestoreKey(KeyHandle, FileHandle, 0);
    }

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    if (!NT_SUCCESS(status)) {
        printf("rtrestor: NtRestorKey failed status = %08lx\n", status);
        exit(1);
    }

    printf("rtsave: success\n");
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    UNICODE_STRING DosFileName;

    if ( (argc < 3) || (argc > 4) )
    {
        printf("Usage: %s <KeyName> <FileName> [VOLATILE]\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &DosFileName,
        &temp,
        TRUE
        );

    RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                  &FileName,
                                  NULL,
                                  NULL);

    if ((argc==4) && (_stricmp(argv[3],"volatile")==0)) {
        HiveVolatile = TRUE;
    } else {
        HiveVolatile = FALSE;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtqval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtqval.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Do a query on a value.

    rtqval <KeyPath> <valuename> [infotypenumber] [bufferlength]

    Example:

        rtqval \REGISTRY\MACHINE\TEST\bigkey value1 1 100

Author:

    Bryan Willman (bryanwi)  9-Apr-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];



UNICODE_STRING  WorkName2;
WCHAR           workbuffer2[WORK_SIZE];


UCHAR       Buffer[1024*64];

ULONG       InfoType = KeyValueFullInformation;
ULONG       BufferSize = -1;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    ULONG   Sizes[] = { sizeof(KEY_VALUE_BASIC_INFORMATION),
                        sizeof(KEY_VALUE_FULL_INFORMATION) };
    ULONG       ResultLength;
    PKEY_VALUE_BASIC_INFORMATION pbasic;
    PKEY_VALUE_FULL_INFORMATION  pfull;
    PKEY_VALUE_PARTIAL_INFORMATION  ppartial;

    //
    // Process args
    //

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    WorkName2.MaximumLength = WORK_SIZE;
    WorkName2.Length = 0L;
    WorkName2.Buffer = &(workbuffer2[0]);

    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rtqkey: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                KEY_QUERY_VALUE,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtqkey: t0: %08lx\n", status);
        exit(1);
    }

    //
    // make test call
    //
    RtlFillMemory((PVOID)&(Buffer[0]), 1024*64, 0xaa);

    if (BufferSize == -1) {
        BufferSize = Sizes[InfoType];
    }

    status = NtQueryValueKey(
                BaseHandle,
                &WorkName2,
                InfoType,
                (PVOID)&(Buffer[0]),
                BufferSize,
                &ResultLength
                );

    printf("status = %08lx  ResultLength = %08lx\n", status, ResultLength);
    switch (InfoType) {
    case KeyValueBasicInformation:
        pbasic = (PKEY_VALUE_BASIC_INFORMATION)Buffer;
        printf("TitleIndex: %08lx\n", pbasic->TitleIndex);
        printf("      Type: %08lx\n", pbasic->Type);
        printf("NameLength: %08lx\n", pbasic->NameLength);
        printf("      Name: '%.*ws'\n", pbasic->NameLength/2, &(pbasic->Name));
        break;

    case KeyValueFullInformation:
        pfull = (PKEY_VALUE_FULL_INFORMATION)Buffer;
        printf("TitleIndex: %08lx\n", pfull->TitleIndex);
        printf("      Type: %08lx\n", pfull->Type);
        printf("DataOffset: %08lx\n", pfull->DataOffset);
        printf("DataLength: %08lx\n", pfull->DataLength);
        printf("NameLength: %08lx\n", pfull->NameLength);
        printf("      Name: '%.*ws'\n", pfull->NameLength/2, &(pfull->Name));
        printf("      Data: '%.*ws'\n", pfull->DataLength/2,
                    ((PUCHAR)pfull + pfull->DataOffset) );
        break;

    case KeyValuePartialInformation:
        ppartial = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        printf("TitleIndex: %08lx\n", ppartial->TitleIndex);
        printf("      Type: %08lx\n", ppartial->Type);
        printf("DataLength: %08lx\n", ppartial->DataLength);
        printf("      Data: '%.*ws'\n", ppartial->DataLength/2,
                    ((PUCHAR)&(ppartial->Data)));
        break;
    }

    NtClose(BaseHandle);
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc < 2) )
    {
        printf("Usage: %s <KeyPath> [infotype] [bufferlen]\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &WorkName2,
        &temp,
        TRUE
        );

    if (argc > 3) {
        InfoType = atoi(argv[3]);
    }

    if (argc > 4) {
        BufferSize = atoi(argv[4]);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtreplac.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtreplac.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtReplaceKey call to replace a registry hive.

    rtreplac  <KeyPath> <NewHiveName> <BackupOldHiveName>

    Example:

        rtreplac \registry\machine\user newuser olduser

Author:

    John Vert (jvert) 8-May-1992

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  NewName;
WCHAR           NewNameBuffer[WORK_SIZE];
UNICODE_STRING  OldName;
WCHAR           OldNameBuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES NewAttributes;
    OBJECT_ATTRIBUTES OldAttributes;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;
    BOOLEAN WasEnabled;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    NewName.MaximumLength = WORK_SIZE;
    NewName.Length = 0L;
    NewName.Buffer = &(NewNameBuffer[0]);

    OldName.MaximumLength = WORK_SIZE;
    OldName.Length = 0L;
    OldName.Buffer = &(OldNameBuffer[0]);

    processargs(argc, argv);

    //
    // Set up and open FileName
    //

    printf("rtreplac: starting\n");

    InitializeObjectAttributes(
        &NewAttributes,
        &NewName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    InitializeObjectAttributes(
        &OldAttributes,
        &OldName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    status = NtOpenKey(
                &KeyHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtreplac: key open failed status = %08lx\n", status);
        exit(1);
    }

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    status = NtReplaceKey(&NewAttributes,
                          KeyHandle,
                          &OldAttributes);
    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    if (!NT_SUCCESS(status)) {
        printf("rtreplac: NtReplaceKey failed status = %08lx\n", status);
        exit(1);
    }

    printf("rtreplac: success\n");
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    UNICODE_STRING DosFileName;

    if ( (argc != 4) )
    {
        printf("Usage: %s <KeyName> <NewFileName> <OldFileName>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &DosFileName,
        &temp,
        TRUE
        );

    RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                  &NewName,
                                  NULL,
                                  NULL );

    RtlInitAnsiString(
        &temp,
        argv[3]
        );

    RtlAnsiStringToUnicodeString(
        &DosFileName,
        &temp,
        TRUE
        );

    RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                  &OldName,
                                  NULL,
                                  NULL );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtsave.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtsave.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtSaveKey call to dump part of the registry to a file.

    rtsave  <KeyPath> <FileName>

    Example:

        rtsave \registry\machine\user userfile.rd

Author:

    Bryan Willman (bryanwi)  22-Jan-92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *[]);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

UNICODE_STRING  FileName;
WCHAR           FileNameBuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;
    BOOLEAN WasEnabled;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    FileName.MaximumLength = WORK_SIZE;
    FileName.Length = 0L;
    FileName.Buffer = &(FileNameBuffer[0]);

    processargs(argc, argv);


    //
    // Set up and open FileName
    //

    printf("rtsave: starting\n");
    printf("rtsave: saving hive rooted at\n\t'%ws'\nto file\n\t'%ws'\n",
            KeyPath.Buffer, FileName.Buffer);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &FileName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;


    status = NtCreateFile(
                &FileHandle,
                GENERIC_WRITE | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatus,
                NULL,                                   // AllocationSize
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,                        // ShareAccess
                FILE_CREATE,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,                                   // EaBuffer
                0                                       // EaLength
                );

    if (!NT_SUCCESS(status)) {
        if (status == STATUS_OBJECT_NAME_COLLISION) {
            printf("rtsave: file '%ws' already exists!\n",
                    FileName.Buffer);
            exit(1);
        }
        printf("rtsave: file open failed status = %08lx\n", status);
        exit(1);
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &KeyHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("rtsave: key open failed status = %08lx\n", status);
        exit(1);
    }

    RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    status = NtSaveKey(KeyHandle, FileHandle);

    RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    if (!NT_SUCCESS(status)) {
        printf("rtsave: NtSaveKey failed status = %08lx\n", status);
        exit(1);
    }

    printf("rtsave: success\n");
    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    UNICODE_STRING DosFileName;

    if ( (argc != 3) )
    {
        printf("Usage: %s <KeyName> <FileName>\nWhere <FileName> does NOT already exist\n",
                argv[0]);
        printf("Example: %s \\registry\\machine\\security d:\\backups\\security\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &DosFileName,
        &temp,
        TRUE
        );

    RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                  &FileName,
                                  NULL,
                                  NULL );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtsetsec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rtsetsec.c

Abstract:

    NT level registry security test program

    Assigns a world read-only security descriptor to an existing registry
    key object.

    rtsetsec <KeyPath>

    Example:

        rtsetsec \REGISTRY\MACHINE\TEST\read_only

Author:

    John Vert (jvert) 28-Jan-92

Revision History:

    Richard Ward (richardw) 14 April 92    Changed ACE_HEADER

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

PSID
GetMySid(
    VOID
    );

PSECURITY_DESCRIPTOR
GenerateDescriptor(
    VOID
    );

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  KeyName;
    ANSI_STRING AnsiKeyName;
    HANDLE KeyHandle;
    PSECURITY_DESCRIPTOR NewSecurityDescriptor;

    //
    // Process args
    //

    if (argc != 2) {
        printf("Usage: %s <KeyPath>\n",argv[0]);
        exit(1);
    }

    RtlInitAnsiString(&AnsiKeyName, argv[1]);
    Status = RtlAnsiStringToUnicodeString(&KeyName, &AnsiKeyName, TRUE);
    if (!NT_SUCCESS(Status)) {
        printf("RtlAnsiStringToUnicodeString failed %lx\n",Status);
        exit(1);
    }

    printf("rtsetsec: starting\n");

    //
    // Open node that we want to change the security descriptor for.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    Status = NtOpenKey(
                &KeyHandle,
                WRITE_DAC,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: NtOpenKey failed: %08lx\n", Status);
        exit(1);
    }

    NewSecurityDescriptor = GenerateDescriptor();

    Status = NtSetSecurityObject( KeyHandle,
                                  DACL_SECURITY_INFORMATION,
                                  NewSecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: NtSetSecurity failed: %08lx\n",Status);
        exit(1);
    }

    Status = NtClose(KeyHandle);
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: NtClose failed: %08lx\n", Status);
        exit(1);
    }

    printf("rtsetsec: successful\n");

}

PSECURITY_DESCRIPTOR
GenerateDescriptor(
    VOID
    )
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Acl;
    PSID WorldSid, CreatorSid;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ULONG OwnerAceLength, WorldAceLength;
    ULONG AclLength;
    NTSTATUS Status;
    PACCESS_ALLOWED_ACE OwnerAce;
    PACCESS_ALLOWED_ACE WorldAce;

    WorldSid = malloc(RtlLengthRequiredSid(1));
    if (WorldSid == NULL) {
        printf("rtsetsec: GenerateDescriptor() couldn't malloc WorldSID\n");
        exit(1);
    }
    RtlInitializeSid(WorldSid, &WorldAuthority, 1);
    *(RtlSubAuthoritySid(WorldSid, 0)) = SECURITY_WORLD_RID;
    if (!RtlValidSid(WorldSid)) {
        printf("rtsetsec: GenerateDescriptor() created invalid World SID\n");
        exit(1);
    }

    CreatorSid = GetMySid();

    //
    // Since the ACCESS_DENIED_ACE already contains a ULONG for the
    // SID, we subtract this back out when calculating the size of the ACE
    //

    WorldAceLength = SeLengthSid(WorldSid) -
                     sizeof(ULONG)     +
                     sizeof(ACCESS_ALLOWED_ACE) ;
    WorldAce = malloc(WorldAceLength);
    if (WorldAce == NULL) {
        printf("rtsetsec: GenerateDescriptor() couldn't malloc WorldAce\n");
        exit(1);
    }

    OwnerAceLength = SeLengthSid(CreatorSid) -
                     sizeof(ULONG)     +
                     sizeof(ACCESS_ALLOWED_ACE);

    OwnerAce = malloc( OwnerAceLength );
    if (OwnerAce == NULL) {
        printf("rtsetsec: GenerateDescriptor() couldn't malloc OwnerAce\n");
        exit(1);
    }

    AclLength = OwnerAceLength + WorldAceLength + sizeof(ACL);
    Acl = malloc(AclLength);
    if (Acl == NULL) {
        printf("rtsetsec: GenerateDescriptor() couldn't malloc ACL\n");
        exit(1);
    }

    Status = RtlCreateAcl(Acl, AclLength, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlCreateAcl failed status %08lx\n", Status);
        exit(1);
    }

    //
    // Fill in ACE fields
    //

    WorldAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    WorldAce->Header.AceSize = (USHORT)WorldAceLength;
    WorldAce->Header.AceFlags = 0;  // clear audit and inherit flags
    WorldAce->Mask = KEY_READ;
    Status = RtlCopySid( SeLengthSid(WorldSid),
                         &WorldAce->SidStart,
                         WorldSid );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlCopySid failed status %08lx\n", Status);
        exit(1);
    }

    OwnerAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    OwnerAce->Header.AceSize = (USHORT)OwnerAceLength;
    OwnerAce->Header.AceFlags = 0;  // clear audit and inherit flags
    OwnerAce->Mask = KEY_ALL_ACCESS;
    Status = RtlCopySid( SeLengthSid(CreatorSid),
                         &OwnerAce->SidStart,
                         CreatorSid );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlCopySid failed status %08lx\n", Status);
        exit(1);
    }

    free(WorldSid);

    //
    // Now add the ACE to the beginning of the ACL.
    //

    Status = RtlAddAce( Acl,
                        ACL_REVISION,
                        0,
                        WorldAce,
                        WorldAceLength );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlAddAce (world ace) failed status %08lx\n", Status);
        exit(1);
    }
    Status = RtlAddAce( Acl,
                        ACL_REVISION,
                        0,
                        OwnerAce,
                        OwnerAceLength );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlAddAce (owner ace) failed status %08lx\n", Status);
        exit(1);
    }

    free(OwnerAce);
    free(WorldAce);

    //
    // Allocate and initialize the Security Descriptor
    //

    SecurityDescriptor = malloc(sizeof(SECURITY_DESCRIPTOR));
    Status = RtlCreateSecurityDescriptor( SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlCreateSecurityDescriptor failed status %08lx\n",Status);
        exit(1);
    }

    Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                           TRUE,
                                           Acl,
                                           FALSE );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: RtlSetDaclSecurityDescriptor failed status %08lx\n",Status);
        exit(1);
    }

    //
    // FINALLY we are finished!
    //

    return(SecurityDescriptor);

}

PSID
GetMySid(
    VOID
    )
{
    NTSTATUS Status;
    HANDLE Token;
    PTOKEN_OWNER Owner;
    ULONG Length;

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &Token );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: GetMySid() NtOpenProcessToken failed status %08lx\n",Status);
        exit(1);
    }

    Status = NtQueryInformationToken( Token,
                                      TokenOwner,
                                      Owner,
                                      0,
                                      &Length );
    if (Status != STATUS_BUFFER_TOO_SMALL) {
        printf("rtsetsec: GetMySid() NtQueryInformationToken failed status %08lx\n",Status);
        exit(1);
    }

    Owner = malloc(Length);
    if (Owner==NULL) {
        printf("rtsetsec: GetMySid() Couldn't malloc TOKEN_OWNER buffer\n");
        exit(1);
    }
    Status = NtQueryInformationToken( Token,
                                      TokenOwner,
                                      Owner,
                                      Length,
                                      &Length );
    if (!NT_SUCCESS(Status)) {
        printf("rtsetsec: GetMySid() NtQueryInformationToken failed status %08lx\n",Status);
        exit(1);
    }

    NtClose(Token);

    return(Owner->Owner);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtsymlnk.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rtsymlnk.c

Abstract:

    NT level registry symbolic link test program

    Turns a key into a symbolic link.

    rtsymlnk <KeyPath> <SymbolicLink>

    Example:

        rtsymlnk \Registry\User\The_User\Foo \Registry\User\The_User\Bar

Author:

    John Vert (jvert) 29-Apr-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  KeyName;
    UNICODE_STRING  LinkName;
    UNICODE_STRING  NullName;
    ANSI_STRING AnsiKeyName;
    ANSI_STRING AnsiLinkName;
    HANDLE KeyHandle;

    //
    // Process args
    //

    if (argc != 3) {
        printf("Usage: %s <KeyPath> <SymLink>\n",argv[0]);
        exit(1);
    }

    RtlInitAnsiString(&AnsiKeyName, argv[1]);
    Status = RtlAnsiStringToUnicodeString(&KeyName, &AnsiKeyName, TRUE);
    if (!NT_SUCCESS(Status)) {
        printf("RtlAnsiStringToUnicodeString failed %lx\n",Status);
        exit(1);
    }

    RtlInitAnsiString(&AnsiLinkName, argv[2]);
    Status = RtlAnsiStringToUnicodeString(&LinkName, &AnsiLinkName, TRUE);
    if (!NT_SUCCESS(Status)) {
        printf("RtlAnsiStringToUnicodeString failed %lx\n",Status);
        exit(1);
    }

    printf("rtsetsec: starting\n");

    //
    // Open node that we want to make a symbolic link.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = NtCreateKey(&KeyHandle,
                         KEY_READ | KEY_WRITE,
                         &ObjectAttributes,
                         0,
                         NULL,
                         0,
                         NULL);
    if (!NT_SUCCESS(Status)) {
        printf("rtsymlnk: NtCreateKey failed: %08lx\n", Status);
        exit(1);
    }

    NullName.Length = NullName.MaximumLength = 0;
    NullName.Buffer = NULL;

    Status = NtSetValueKey(KeyHandle,
                           &NullName,
                           0,
                           REG_LINK,
                           LinkName.Buffer,
                           LinkName.Length);
    if (!NT_SUCCESS(Status)) {
        printf("rtsymlnk: NtSetValueKey failed: %08lx\n",Status);
        exit(1);
    }

    Status = NtClose(KeyHandle);
    if (!NT_SUCCESS(Status)) {
        printf("rtsymlnk: NtClose failed: %08lx\n", Status);
        exit(1);
    }

    printf("rtsymlnk: successful\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtsetopt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtsetopt.c

Abstract:

    NT level registry api test program, basic non-error paths.

    This program attempts to force all cases through the various
    optimizations in the NtSetValueKey code.

    This is a whitebox test intended force system errors (crashes)
    when run.  Returned values are not very interesting.

    rtsetopt <root of test tree>

    Example:

        rtsetopt \registry\machine\software\test

    Named key must already exist.


Author:

    Bryan Willman (bryanwi)  17-Nov-92

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char **);
void processargs();

ULONG           failure = 0;

UNICODE_STRING  KeyPath;

UCHAR           TestData[] =
"This is some test data, it is short. But long enough for most of our tests.";

UNICODE_STRING  WorkName;
WCHAR           workbuffer[2 * CM_MAX_STASH];

LONG    testvector0[] = { 0, 3, 4, 5, -1 };

LONG    testvector1[] = { 0, 0, 3, 0, 4, 0, 5, 0, 3, 3, 4, 3, 5, 3,
                          4, 4, 5, 4, 5, 5, -1 };

LONG    testvector2[] = { 8, 6, 8, 32,
                          PAGE_SIZE, PAGE_SIZE-1, PAGE_SIZE, PAGE_SIZE+1,
                          -1 };

LONG    testvector3[] = { CM_MAX_STASH, CM_MAX_STASH-1, CM_MAX_STASH,
                          CM_MAX_STASH+1, -1 };

PLONG   supervector[] = { &(testvector1[0]), &(testvector2[1]),
                          &(testvector3[0]), NULL };


void
__cdecl main(
    int argc,
    char **argv
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    UNICODE_STRING  ValueName;
    ULONG   ResultLength;
    PKEY_VALUE_FULL_INFORMATION pvaluefull;
    PKEY_VALUE_PARTIAL_INFORMATION pvaluepart;
    ULONG   i;
    ULONG  index;
    LONG    testsize;
    PUCHAR  p;
    PLONG   activevector;


    for (i = 0; i < 2 * CM_MAX_STASH; i++) {
        workbuffer[i] = 'e';
    }

    //
    // Process args
    //
    processargs(argc, argv);


    //
    // Open the specified keypath, punt on failure
    //
    printf("rtsetopt: starting\n");

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    RtlCopyString((PSTRING)&WorkName, (PSTRING)&KeyPath);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtOpenKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(status)) {
        printf("line_%4d: abort %08lx\n", __LINE__,  status);
        failure++;
        goto punt;
    }


    //
    // Perform new value entry tests, with an empty list.
    //
    RtlInitUnicodeString(
        &ValueName,
        L"NewValueTest1"
        );

    for (index = 0; testvector0[index] != -1; index++) {

        testsize = testvector0[index];

        printf("AT line_%4d: %d\n", __LINE__,  testsize);

        status = NtSetValueKey(
                    BaseHandle,
                    &ValueName,
                    1,
                    REG_BINARY,
                    &(TestData[0]),
                    testsize
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: %08lx\n", __LINE__,  status);
            failure++;
        }

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        for (i = 0; i < WORK_SIZE; i++) workbuffer[i] = '?';
        status = NtQueryValueKey(
                    BaseHandle,
                    &ValueName,
                    KeyValueFullInformation,
                    &(workbuffer[0]),
                    WORK_SIZE,
                    &ResultLength
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: %08lx\n", __LINE__,  status);
            failure++;
        }

        pvaluefull = (PKEY_VALUE_FULL_INFORMATION)(&(workbuffer[0]));
        if (pvaluefull->DataLength != testsize) {
            printf("line_%4d: %08lx\n", __LINE__,  9999);
            failure++;
        }


        if (testsize > 0) {
            p = (PUCHAR)pvaluefull;
            p = p+pvaluefull->DataOffset;
            if (p[2] != 'i') {
                printf("line_%4d: %08lx\n", __LINE__,  9999);
                failure++;
            }
        }

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        if (testvector0[index+1] != -1) {
            status = NtDeleteValueKey(
                        BaseHandle,
                        &ValueName
                        );
            if (!NT_SUCCESS(status)) {
                printf("line_%4d: abort %08lx\n", __LINE__,  status);
                failure++;
                goto punt;
            }
        }
    }

    //
    // Perform new value entry tests, with a non empty list.
    //
    RtlInitUnicodeString(
        &ValueName,
        L"NewValueTest2"
        );

    for (index = 0; testvector0[index] != -1; index++) {

        testsize = testvector0[index];

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        status = NtSetValueKey(
                    BaseHandle,
                    &ValueName,
                    1,
                    REG_BINARY,
                    &(TestData[0]),
                    testsize
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: %08lx\n", __LINE__,  status);
            failure++;
        }

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        for (i = 0; i < WORK_SIZE; i++) workbuffer[i] = '?';
        status = NtQueryValueKey(
                    BaseHandle,
                    &ValueName,
                    KeyValuePartialInformation,
                    &(workbuffer[0]),
                    WORK_SIZE,
                    &ResultLength
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: %08lx\n", __LINE__,  status);
            failure++;
        }

        pvaluepart = (PKEY_VALUE_PARTIAL_INFORMATION)(&(workbuffer[0]));
        if (pvaluepart->DataLength != testsize) {
            printf("line_%4d: %08lx\n", __LINE__,  9999);
            failure++;
        }


        if (testsize > 0) {
            if (pvaluepart->Data[2] != 'i') {
                printf("line_%4d: %08lx\n", __LINE__,  9999);
                failure++;
            }
        }

        printf("AT line_%4d: %d\n", __LINE__,  testsize);
        status = NtDeleteValueKey(
                    BaseHandle,
                    &ValueName
                    );
        if (!NT_SUCCESS(status)) {
            printf("line_%4d: abort %08lx\n", __LINE__,  status);
            failure++;
            goto punt;
        }
   }


    //
    // Perform existing value entry tests, with all the relevent
    // size transitions.
    //
    RtlInitUnicodeString(
        &ValueName,
        L"NewValueTest3"
        );

    for (i = 0; i < 2 * CM_MAX_STASH; i++) {
        workbuffer[i] = 'e';
    }

    for (i = 0; supervector[i] != NULL; i++) {

        activevector = supervector[i];

        for (index = 0; activevector[index] != -1; index++) {

            testsize = activevector[index];

            printf("AT line_%4d: %d\n", __LINE__,  testsize);
            status = NtSetValueKey(
                        BaseHandle,
                        &ValueName,
                        1,
                        REG_BINARY,
                        &(workbuffer[0]),
                        testsize
                        );
            if (!NT_SUCCESS(status)) {
                printf("line_%4d: %08lx\n", __LINE__,  status);
                failure++;
            }

            printf("AT line_%4d: %d\n", __LINE__,  testsize);
            status = NtQueryValueKey(
                        BaseHandle,
                        &ValueName,
                        KeyValuePartialInformation,
                        &(workbuffer[0]),
                        2 * CM_MAX_STASH,
                        &ResultLength
                        );
            if (!NT_SUCCESS(status)) {
                printf("line_%4d: %08lx\n", __LINE__,  status);
                failure++;
            }
        }
    }


punt:
    printf("rtsetopt: %d failures\n", failure);
    exit(failure);
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if (argc != 2)
    {
        printf("Usage: %s <KeyPath>\n", argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtunload.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtunload.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Perform an NtUnloadKey call to unlink a hive file from the registry.

    rtunload  <KeyPath>

    Example:

        rtunload \registry\user\JVert

Author:

    John Vert (jvert) 17-Apr-92

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

UNICODE_STRING  KeyPath;
WCHAR           KeyPathBuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES KeyAttributes;
    IO_STATUS_BLOCK  IoStatus;
    HANDLE  FileHandle;
    HANDLE  KeyHandle;
    BOOLEAN WasEnabled;

    //
    // Process args
    //

    KeyPath.MaximumLength = WORK_SIZE;
    KeyPath.Length = 0L;
    KeyPath.Buffer = &(KeyPathBuffer[0]);

    processargs(argc, argv);


    printf("rtunload: starting\n");

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    //
    // Set up KeyPath
    //

    InitializeObjectAttributes(
        &KeyAttributes,
        &KeyPath,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    status = NtUnloadKey(&KeyAttributes);

    RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    if (!NT_SUCCESS(status)) {
        printf("rtunload: key unload failed status = %08lx\n", status);
        exit(1);
    } else {
        printf("rtunload: success!\n");
    }

    exit(0);
}

void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 2) )
    {
        printf("Usage: %s <KeyName>\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\symtest.c ===
#include "ntos.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void
main(
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Attr1;
    OBJECT_ATTRIBUTES Attr2;
    UNICODE_STRING  Name1;
    UNICODE_STRING  Name2;
    HANDLE Handle1;
    HANDLE Handle2;
    IO_STATUS_BLOCK IoStatusBlock;


    RtlInitUnicodeString(&Name1, L"\\DosDevices");
    RtlInitUnicodeString(&Name2, L"C:\\Nt");
    InitializeObjectAttributes(&Attr1,
                               &Name1,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenDirectoryObject(&Handle1,
                                   DIRECTORY_QUERY,
                                   &Attr1);
    if (!NT_SUCCESS(Status)) {
        printf("NtOpenDirectoryObject failed %08lx\n",Status);
        exit(1);
    }

    InitializeObjectAttributes(&Attr2,
                               &Name2,
                               OBJ_CASE_INSENSITIVE,
                               Handle1,
                               NULL);
    Status = NtOpenFile(&Handle2,
                        FILE_LIST_DIRECTORY,
                        &Attr2,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0);
    if (!NT_SUCCESS(Status)) {
        printf("NtOpenFile failed %08lx\n",Status);
        exit(1);
    }

    printf("success\n");


}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rttrecpy.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rttrecpy.c

Abstract:

    NT level registry api test program

    tree copy for the registry.

    rtdeltre <SourceKeyPath> <DestKeyPath>

    Will tree-copy the given registry subtree.

    Example:

        rttrecpy \REGISTRY\MACHINE\TEST\bigkey \registry\machine\test\bigcopy

Author:

    John Vert (jvert) 22-Oct-1992

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int argc, char *);
void processargs();

void
Copy(
    HANDLE  Source,
    HANDLE  Dest
    );

UNICODE_STRING  SourceName;
UNICODE_STRING  DestName;
BOOLEAN CopySecurity;

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE  SourceHandle;
    HANDLE  DestHandle;

    //
    // Process args
    //
    processargs(argc, argv);


    //
    // Set up and open KeyPath
    //

    printf("rttrecpy: starting\n");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SourceName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = NtOpenKey(
                &SourceHandle,
                KEY_READ,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(Status)) {
        printf("rttrecpy: NtOpenKey %wS failed %08lx\n", &SourceName, Status);
        exit(1);
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               &DestName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtCreateKey(&DestHandle,
                         KEY_WRITE,
                         &ObjectAttributes,
                         0,
                         NULL,
                         0,
                         NULL);
    if (!NT_SUCCESS(Status)) {
        printf("rttrecpy: NtCreateKey %wS failed %08lx\n",DestName,Status);
        exit(1);
    }

    Copy(SourceHandle, DestHandle);
}


void
Copy(
    HANDLE  Source,
    HANDLE  Dest
    )
{
    NTSTATUS    Status;
    PKEY_BASIC_INFORMATION KeyInformation;
    PKEY_VALUE_FULL_INFORMATION KeyValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG   NamePos;
    ULONG   index;
    STRING  enumname;
    HANDLE  SourceChild;
    HANDLE  DestChild;
    ULONG   ResultLength;
    static  char buffer[WORK_SIZE];
    static  char SecurityBuffer[WORK_SIZE];
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    UNICODE_STRING ValueName;
    UNICODE_STRING KeyName;


    //
    // Enumerate source node's values and copy them to target node.
    //
    KeyValue = (PKEY_VALUE_FULL_INFORMATION)buffer;
    for (index = 0; TRUE; index++) {
        Status = NtEnumerateValueKey(Source,
                                     index,
                                     KeyValueFullInformation,
                                     buffer,
                                     WORK_SIZE,
                                     &ResultLength);

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_ENTRIES) {

                //
                // done with the values
                //
                break;
            } else {
                printf("rttrecpy: NtEnumerateValueKey failed %08lx\n",Status);
                break;
            }
        }

        ValueName.Buffer = KeyValue->Name;
        ValueName.Length = KeyValue->NameLength;

        Status = NtSetValueKey(Dest,
                               &ValueName,
                               KeyValue->TitleIndex,
                               KeyValue->Type,
                               buffer+KeyValue->DataOffset,
                               KeyValue->DataLength);
        if (!NT_SUCCESS(Status)) {
            printf("rttrecpy: NtSetValueKey failed to set value %wS\n",&ValueName);
        }

    }

    //
    // Enumerate node's children and apply ourselves to each one
    //

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    if (CopySecurity) {
        SecurityDescriptor = SecurityBuffer;
    } else {
        SecurityDescriptor = NULL;
    }
    for (index = 0; TRUE; index++) {

        Status = NtEnumerateKey(Source,
                                index,
                                KeyBasicInformation,
                                KeyInformation,
                                WORK_SIZE,
                                &ResultLength);

        if (Status == STATUS_NO_MORE_ENTRIES) {

            break;

        } else if (!NT_SUCCESS(Status)) {
            printf("rttrecpy: NtEnumerateKey failed Status = %08lx\n", Status);
            exit(1);
        }

        KeyName.Buffer = KeyInformation->Name;
        KeyName.Length = KeyInformation->NameLength;

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            Source,
            NULL
            );

        Status = NtOpenKey(
                    &SourceChild,
                    KEY_READ,
                    &ObjectAttributes
                    );
        if (!NT_SUCCESS(Status)) {
            printf("rttrecpy: NtOpenKey %wS failed: %08lx\n", Status);
            exit(1);
        }

        if (CopySecurity) {
            Status = NtQuerySecurityObject(SourceChild,
                                           DACL_SECURITY_INFORMATION,
                                           SecurityDescriptor,
                                           WORK_SIZE,
                                           &ResultLength);
            if (!NT_SUCCESS(Status)) {
                printf("rttrecpy: NtQuerySecurityObject failed %08lx\n",Status);
            }
        }

        InitializeObjectAttributes(&ObjectAttributes,
                                   &KeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   Dest,
                                   SecurityDescriptor);
        Status = NtCreateKey(&DestChild,
                             KEY_READ | KEY_WRITE,
                             &ObjectAttributes,
                             0,
                             NULL,
                             0,
                             NULL);
        if (!NT_SUCCESS(Status)) {
            printf("rttrecpy: NtCreateKey %wS failed %08lx\n",Status);
            exit(1);
        }

        Copy(SourceChild, DestChild);
        NtClose(SourceChild);
        NtClose(DestChild);

    }

    return;
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;
    char **p;

    if ( (argc > 4) || (argc < 3) )
    {
        printf("Usage: %s [-s] <SourceKey> <DestKey>\n",
                argv[0]);
        exit(1);
    }

    p=argv+1;
    if (_stricmp(*p,"-s")==0) {
        CopySecurity = TRUE;
        ++p;
    } else {
        CopySecurity = FALSE;
    }

    RtlInitAnsiString(
        &temp,
        *p
        );

    ++p;

    RtlAnsiStringToUnicodeString(
        &SourceName,
        &temp,
        TRUE
        );

    RtlInitAnsiString(&temp,
                      *p);

    RtlAnsiStringToUnicodeString(&DestName,
                                 &temp,
                                 TRUE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\edithive.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    edithive.h

Abstract:

    include for user-mode hive editing library

Author:

    John Vert (jvert) 27-Mar-1992

Revision History:

--*/

#include "ntos.h"
#include "cmp.h"



#define TYPE_SIMPLE     0
#define TYPE_LOG        1
#define TYPE_ALT        2


HANDLE
EhOpenHive(
    IN PUNICODE_STRING FileName,
    OUT PHANDLE RootCell,
    OUT PUNICODE_STRING RootName,
    IN ULONG HiveType
    );

VOID
EhCloseHive(
    IN HANDLE Hive
    );

NTSTATUS
EhEnumerateValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
EhEnumerateKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
EhOpenChildByName(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    PUNICODE_STRING  Name,
    PHANDLE ChildCell
    );

NTSTATUS
EhCreateChild(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING  Name,
    OUT PHANDLE ChildCell,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
EhQueryKey(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
EhQueryValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

NTSTATUS
EhSetValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

NTSTATUS
EhDeleteValueKey(
    IN HANDLE Hive,
    IN HANDLE Cell,
    IN PUNICODE_STRING ValueName         // RAW
    );

PSECURITY_DESCRIPTOR
EhGetKeySecurity(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\edithive.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    edithive.c

Abstract:

    Provides functionality for dumping and editing registry hive files from
    user-mode.

Author:

    John Vert (jvert) 26-Mar-1992

Revision History:

--*/
#include "edithive.h"
#include "nturtl.h"

extern GENERIC_MAPPING CmpKeyMapping;
extern LIST_ENTRY CmpHiveListHead;            // List of CMHIVEs

#define SECURITY_CELL_LENGTH(pDescriptor) \
    FIELD_OFFSET(CM_KEY_SECURITY,Descriptor) + \
    RtlLengthSecurityDescriptor(pDescriptor)


NTSTATUS
EhpAttachSecurity(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    );

PVOID
EhpAllocate(
    ULONG   Size
    );

VOID
EhpFree(
    PVOID   MemoryBlock
    );

BOOLEAN
EhpFileRead (
    HANDLE      FileHandle,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    );

BOOLEAN
EhpFileWrite(
    HANDLE      FileHandle,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    );

BOOLEAN
EhpFileFlush (
    HANDLE      FileHandle
    );

VOID
CmpGetObjectSecurity(
    IN HCELL_INDEX Cell,
    IN PHHIVE Hive,
    OUT PCM_KEY_SECURITY *Security,
    OUT PHCELL_INDEX SecurityCell OPTIONAL
    )

/*++

Routine Description:

    This routine maps in the security cell of a registry object.

Arguments:

    Cell - Supplies the cell index of the object.

    Hive - Supplies the hive the object's cell is in.

    Security - Returns a pointer to the security cell of the object.

    SecurityCell - Returns the index of the security cell

Return Value:

    NONE.

--*/

{
    HCELL_INDEX CellIndex;
    PCM_KEY_NODE Node;

    //
    // Map the node we need to get the security descriptor for
    //
    Node = (PCM_KEY_NODE) HvGetCell(Hive, Cell);

    CellIndex = Node->u1.s1.Security;

    //
    // Map in the security descriptor cell
    //
    *Security = (PCM_KEY_SECURITY) HvGetCell(Hive, CellIndex);

    if (ARGUMENT_PRESENT(SecurityCell)) {
        *SecurityCell = CellIndex;
    }

    return;
}


VOID
EhCloseHive(
    IN HANDLE HiveHandle
    )

/*++

Routine Description:

    Closes a hive, including writing all the data out to disk and freeing
    the relevant structures.

Arguments:

    HiveHandle - Supplies a handle to the hive control structure

Return Value:

    None.

--*/

{
    HvSyncHive((PHHIVE)HiveHandle);
    NtClose(((PCMHIVE)HiveHandle)->FileHandles[HFILE_TYPE_PRIMARY]);
    NtClose(((PCMHIVE)HiveHandle)->FileHandles[HFILE_TYPE_ALTERNATE]);
    NtClose(((PCMHIVE)HiveHandle)->FileHandles[HFILE_TYPE_LOG]);
    CmpFree((PCMHIVE)HiveHandle, sizeof(CMHIVE));

}


HANDLE
EhOpenHive(
    IN PUNICODE_STRING FileName,
    OUT PHANDLE RootHandle,
    IN PUNICODE_STRING RootName,
    IN ULONG HiveType
    )

/*++

Routine Description:

    Opens an existing hive.  If the filename does not exist it will be
    created.

    WARNING:    Allocate FileName large enough to acomodate .log or
                .alt extension.

Arguments:

    FileName - Supplies the NULL-terminated filename to open as a hive.

    HiveType - TYPE_SIMPLE = no log or alternate
               TYPE_LOG = log
               TYPE_ALT = alternate

Return Value:

    != NULL - Handle to the opened hive.
    == NULL - Indicates file could not be opened.

--*/

{
    NTSTATUS Status;
    HANDLE File;
    BOOLEAN Allocate;
    PCMHIVE Hive;
    IO_STATUS_BLOCK IoStatus;
    ULONG CreateDisposition;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PCM_KEY_NODE RootNode;
    HANDLE Handle;
    HANDLE  Primary;
    HANDLE  Log;
    HANDLE  Alt;
    ULONG   FileType;
    ULONG   Disposition;
    ULONG   SecondaryDisposition;
    ULONG   Operation;

    Alt = NULL;
    Log = NULL;
    InitializeListHead(&CmpHiveListHead);

    switch (HiveType) {
    case TYPE_SIMPLE:
        Status = CmpOpenHiveFiles(
                    FileName,
                    NULL,
                    &Primary,
                    NULL,
                    &Disposition,
                    &SecondaryDisposition,
                    TRUE,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            return NULL;
        }
        FileType = HFILE_TYPE_PRIMARY;
        break;

    case TYPE_LOG:
        Status = CmpOpenHiveFiles(
                    FileName,
                    L".log",
                    &Primary,
                    &Log,
                    &Disposition,
                    &SecondaryDisposition,
                    TRUE,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            return NULL;
        }
        if (Log == NULL) {
            return NULL;
        }
        FileType = HFILE_TYPE_LOG;
        break;

    case TYPE_ALT:
        Status = CmpOpenHiveFiles(
                    FileName,
                    L".alt",
                    &Primary,
                    &Alt,
                    &Disposition,
                    &SecondaryDisposition,
                    TRUE,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            return NULL;
        }
        if (Alt == NULL) {
            return NULL;
        }
        FileType = HFILE_TYPE_ALTERNATE;
        break;

    default:
        return NULL;
    }

    //
    // Initialize hive
    //
    if (Disposition == FILE_CREATED) {
        Operation = HINIT_CREATE;
        Allocate = TRUE;
    } else {
        Operation = HINIT_FILE;
        Allocate = FALSE;
    }

    if ( ! CmpInitializeHive(
                    &Hive,
                    Operation,
                    FALSE,
                    FileType,
                    NULL,
                    Primary,
                    Alt,
                    Log,
                    NULL,
                    NULL
                    ))
    {
        return NULL;
    }

    if (!Allocate) {
        *RootHandle = (HANDLE)(Hive->Hive.BaseBlock->RootCell);
        RootNode = (PCM_KEY_NODE)HvGetCell(
                                (PHHIVE)Hive, Hive->Hive.BaseBlock->RootCell);
        RootName->Length = RootName->MaximumLength = RootNode->NameLength;
        RootName->Buffer = RootNode->Name;
    } else {
        RtlInitUnicodeString(RootName, L"HiveRoot");
        *RootHandle = (HANDLE)HCELL_NIL;
        HvSyncHive((PHHIVE)Hive);
    }


    return((HANDLE)Hive);
}


NTSTATUS
EhEnumerateKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    Enumerate sub keys, return data on Index'th entry.

    CmEnumerateKey returns the name of the Index'th sub key of the open
    key specified.  The value STATUS_NO_MORE_ENTRIES will be
    returned if value of Index is larger than the number of sub keys.

    Note that Index is simply a way to select among child keys.  Two calls
    to CmEnumerateKey with the same Index are NOT guaranteed to return
    the same results.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to whose sub keys are to be found

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK    kcb;

    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.Delete = FALSE;
    kcb.KeyHive = &((PCMHIVE)HiveHandle)->Hive;
    kcb.KeyCell = (HCELL_INDEX)CellHandle;
    kcb.RefCount = 1;

    return(CmEnumerateKey(&kcb,
                          Index,
                          KeyInformationClass,
                          KeyInformation,
                          Length,
                          ResultLength));
}


NTSTATUS
EhEnumerateValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The value entries of an open key may be enumerated.

    CmEnumerateValueKey returns the name of the Index'th value
    entry of the open key specified by KeyHandle.  The value
    STATUS_NO_MORE_ENTRIES will be returned if value of Index is
    larger than the number of sub keys.

    Note that Index is simply a way to select among value
    entries.  Two calls to NtEnumerateValueKey with the same Index
    are NOT guaranteed to return the same results.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a handle to the hive

    Cell - supplies handle to node whose sub keys are to be found

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyValueInformationClass - Specifies the type of information returned
    in Buffer. One of the following types:

        KeyValueBasicInformation - return time of last write,
            title index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write,
            title index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK    kcb;

    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.Delete = FALSE;
    kcb.KeyHive = (PHHIVE)&(((PCMHIVE)HiveHandle)->Hive);
    kcb.KeyCell = (HCELL_INDEX)CellHandle;
    kcb.RefCount = 1;

    return(CmEnumerateValueKey(&kcb,
                               Index,
                               KeyValueInformationClass,
                               KeyValueInformation,
                               Length,
                               ResultLength));
}


NTSTATUS
EhOpenChildByNumber(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN ULONG  Index,
    IN NODE_TYPE   Type,
    OUT PHANDLE ChildCell
    )
/*++

Routine Description:

    Return the cell index of the Nth child cell.

Arguments:

    HiveHandle - handle of hive control structure for hive of interest

    CellHandle - handle for parent cell

    Index - number of desired child

    Type - type of the child object

    ChildCell - supplies a pointer to a variable to receive the
                    HCELL_INDEX of the Index'th child.

Return Value:

    status

--*/
{
    return(CmpFindChildByNumber(&((PCMHIVE)HiveHandle)->Hive,
                                (HCELL_INDEX)CellHandle,
                                Index,
                                Type,
                                (PHCELL_INDEX)ChildCell));

}


NTSTATUS
EhSetValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
/*++

Routine Description:

    A value entry may be created or replaced with EhSetValueKey.

    If a value entry with a Value ID (i.e. name) matching the
    one specified by ValueName exists, it is deleted and replaced
    with the one specified.  If no such value entry exists, a new
    one is created.  NULL is a legal Value ID.  While Value IDs must
    be unique within any given key, the same Value ID may appear
    in many different keys.

Arguments:

    HiveHandle - handle of hive control structure for hive of interest

    CellHandle - handle for parent cell

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    TitleIndex - Supplies the title index for ValueName.  The title
        index specifies the index of the localized alias for the ValueName.

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.


Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK kcb;

    kcb.Delete = FALSE;
    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.KeyHive = (PHHIVE)&(((PCMHIVE)HiveHandle)->Hive);
    kcb.KeyCell = (HCELL_INDEX)CellHandle;
    kcb.FullName.Length = 0;
    kcb.FullName.MaximumLength = 0;
    kcb.FullName.Buffer = NULL;

    return(CmSetValueKey(&kcb,
                         *ValueName,
                         TitleIndex,
                         Type,
                         Data,
                         DataSize));

}


NTSTATUS
EhOpenChildByName(
    HANDLE HiveHandle,
    HANDLE CellHandle,
    PUNICODE_STRING  Name,
    PHANDLE ChildCell
    )
/*++

Routine Description:

    Find the child subkey cell specified by Name.

Arguments:

    HiveHandle - handle of hive control structure for hive of interest

    CellHandle - handle for parent cell

    Name - name of child object to find

    ChildCell - pointer to variable to receive cell index of child

Return Value:

    status

--*/
{
    PHCELL_INDEX    Index;

    return(CmpFindChildByName(&((PCMHIVE)HiveHandle)->Hive,
                              (HCELL_INDEX)CellHandle,
                              *Name,
                              KeyBodyNode,
                              (PHCELL_INDEX)ChildCell,
                              &Index));
}


NTSTATUS
EhCreateChild(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING  Name,
    OUT PHANDLE ChildCell,
    OUT PULONG Disposition OPTIONAL
    )
/*++

Routine Description:

    Attempts to open the given child subkey specified by name.  If the
    child does not exist, it is created.

Arguments:

    HiveHandle - handle of hive control structure for hive of interest

    CellHandle - handle for parent cell


    Name - name of child object to create

    ChildCell - pointer to variable to receive cell index of child

    Disposition - This optional parameter is a pointer to a variable
        that will receive a value indicating whether a new Registry
        key was created or an existing one opened:

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    status

--*/
{
    PHCELL_INDEX Index;
    NTSTATUS Status;
    PHHIVE Hive;
    HCELL_INDEX NewCell;
    HCELL_INDEX NewListCell;
    HCELL_INDEX OldListCell;
    PHCELL_INDEX NewList;
    PHCELL_INDEX OldList;
    PCM_KEY_NODE Child;
    PCM_KEY_NODE Parent;
    PCM_KEY_SECURITY Security;
    HANDLE Handle;
    ULONG oldcount;

    Hive = &((PCMHIVE)HiveHandle)->Hive;

    if ((HCELL_INDEX)CellHandle == HCELL_NIL) {
        if (Hive->BaseBlock->RootCell != HCELL_NIL) {
            *ChildCell = (HANDLE)(Hive->BaseBlock->RootCell);
            if (ARGUMENT_PRESENT(Disposition)) {
                *Disposition = REG_OPENED_EXISTING_KEY;
            }
            return(STATUS_SUCCESS);
        } else {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    } else {
        Parent = (PCM_KEY_NODE)HvGetCell(Hive, (HCELL_INDEX)CellHandle);
        Status = CmpFindChildByName(Hive,
                                    (HCELL_INDEX)CellHandle,
                                    *Name,
                                    KeyBodyNode,
                                    (PHCELL_INDEX)ChildCell,
                                    &Index);
    }
    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

        NewCell = HvAllocateCell(Hive,
                                 CmpHKeyNodeSize(Hive,Name->Length),
                                 Stable);
        if (NewCell != HCELL_NIL) {

            *ChildCell = (HANDLE)NewCell;
            Child = (PCM_KEY_NODE)HvGetCell(Hive, NewCell);

            Child->Signature = CM_KEY_NODE_SIGNATURE;
            Child->Flags = 0;

            KeQuerySystemTime(&(Child->LastWriteTime));

            Child->Spare = 0;
            Child->Parent = (HCELL_INDEX)CellHandle;

            Child->ValueList.Count = 0;
            Child->ValueList.List = HCELL_NIL;
            Child->u1.s1.Security = HCELL_NIL;
            Child->u1.s1.Class = HCELL_NIL;
            Child->NameLength = Name->Length;
            Child->ClassLength = 0;

            Child->SubKeyCounts[Stable] = 0;
            Child->SubKeyCounts[Volatile] = 0;
            Child->SubKeyLists[Stable] = HCELL_NIL;
            Child->SubKeyLists[Volatile] = HCELL_NIL;

            Child->MaxValueDataLen = 0;
            Child->MaxNameLen = 0;
            Child->MaxValueNameLen = 0;
            Child->MaxClassLen = 0;

            if((HCELL_INDEX)CellHandle == HCELL_NIL) {
                Hive->BaseBlock->RootCell = NewCell;
                Status = EhpAttachSecurity(Hive, NewCell);
            } else {
                Child->u1.s1.Security = Parent->u1.s1.Security;
                Security = (PCM_KEY_SECURITY)HvGetCell(Hive, Child->u1.s1.Security);
                ++Security->ReferenceCount;
            }

            RtlMoveMemory(
                &(Child->Name[0]),
                Name->Buffer,
                Name->Length
                );

            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            return(Status);
        }
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = REG_CREATED_NEW_KEY;
        }

        if ((HCELL_INDEX)CellHandle != HCELL_NIL) {

            //
            // put newly created child into parent's sub key list
            //
            if (! CmpAddSubKey(Hive, (HCELL_INDEX)CellHandle, NewCell)) {
                CmpFreeKeyByCell(Hive, NewCell, FALSE);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            Parent = (PCM_KEY_NODE)HvGetCell(Hive, (HCELL_INDEX)CellHandle);

            if (Parent->MaxNameLen < Name->Length) {
                Parent->MaxNameLen = Name->Length;
            }
            Parent->MaxClassLen = 0;
        }
    } else {
        Status = STATUS_SUCCESS;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = REG_OPENED_EXISTING_KEY;
        }
    }
    return(Status);
}


NTSTATUS
EhQueryKey(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    Data about the class of a key, and the numbers and sizes of its
    children and value entries may be queried with CmQueryKey.

    NOTE: The returned lengths are guaranteed to be at least as
          long as the described values, but may be longer in
          some circumstances.

Arguments:

    Hive - supplies a handle to the hive control structure for the hive

    Cell - supplies handle of node to whose sub keys are to be found

    KeyInformationClass - Specifies the type of information
        returned in Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (See KEY_BASIC_INFORMATION)

        KeyNodeInformation - return last write time, title index, name, class.
            (See KEY_NODE_INFORMATION)

        KeyFullInformation - return all data except for name and security.
            (See KEY_FULL_INFORMATION)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK Kcb;

    Kcb.Delete = FALSE;
    Kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    Kcb.KeyHive = &((PCMHIVE)HiveHandle)->Hive;
    Kcb.KeyCell = (HCELL_INDEX)KeyHandle;
    Kcb.FullName.Length = 0;
    Kcb.FullName.MaximumLength = 0;
    Kcb.FullName.Buffer = NULL;

    return(CmQueryKey(&Kcb,
                      KeyInformationClass,
                      KeyInformation,
                      Length,
                      ResultLength));
}

PSECURITY_DESCRIPTOR
EhGetKeySecurity(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle
    )
{
    PCM_KEY_SECURITY Security;

    CmpGetObjectSecurity((HCELL_INDEX)KeyHandle,
                         &((PCMHIVE)HiveHandle)->Hive,
                         &Security,
                         NULL);

    return(&Security->Descriptor);
}


NTSTATUS
EhQueryValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The ValueName, TitleIndex, Type, and Data for any one of a key's
    value entries may be queried with CmQueryValueKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    Hive - supplies a pointer to the hive control structure for the hive

    Cell - supplies index of node to whose sub keys are to be found

    ValueName  - The name of the value entry to return data for.

    KeyValueInformationClass - Specifies the type of information
        returned in KeyValueInformation.  One of the following types:

        KeyValueBasicInformation - return time of last write, title
            index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write, title
            index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK kcb;

    kcb.Delete = FALSE;
    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.KeyHive = &((PCMHIVE)HiveHandle)->Hive;
    kcb.KeyCell = (HCELL_INDEX)KeyHandle;
    kcb.FullName.Length = 0;
    kcb.FullName.MaximumLength = 0;
    kcb.FullName.Buffer = NULL;

    return(CmQueryValueKey(&kcb,
                           *ValueName,
                           KeyValueInformationClass,
                           KeyValueInformation,
                           Length,
                           ResultLength));

}


NTSTATUS
EhDeleteValueKey(
    IN HANDLE HiveHandle,
    IN HANDLE CellHandle,
    IN PUNICODE_STRING ValueName         // RAW
    )
/*++

Routine Description:

    One of the value entries of a registry key may be removed with this call.

    The value entry with ValueName matching ValueName is removed from the key.
    If no such entry exists, an error is returned.

Arguments:

    Hive - Supplies a handle to the hive control structure

    Cell - Supplies a handle to the registry key to be operated on

    ValueName - The name of the value to be deleted.  NULL is a legal name.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    CM_KEY_CONTROL_BLOCK kcb;

    kcb.Delete = FALSE;
    kcb.Signature = CM_KEY_CONTROL_BLOCK_SIGNATURE;
    kcb.KeyHive = &((PCMHIVE)HiveHandle)->Hive;
    kcb.KeyCell = (HCELL_INDEX)CellHandle;
    kcb.FullName.Length = 0;
    kcb.FullName.MaximumLength = 0;
    kcb.FullName.Buffer = NULL;

    return(CmDeleteValueKey(&kcb, *ValueName));
}


NTSTATUS
EhpAttachSecurity(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )

/*++

Routine Description:

    Creates a security descriptor cell and attaches it to the given
    node.

Arguments:

    Hive - Supplies a pointer to the hive control structure.

    Cell - Supplies the cell index of the node to attach the security
           descriptor to.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    HANDLE Token;
    HCELL_INDEX SecurityCell;
    PCM_KEY_NODE Node;
    PCM_KEY_SECURITY Security;
    PSECURITY_DESCRIPTOR Descriptor;
    ULONG DescriptorLength;
    HANDLE Handle;

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &Token );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlNewSecurityObject( NULL,
                                   NULL,
                                   &Descriptor,
                                   FALSE,
                                   Token,
                                   &CmpKeyMapping );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Node = (PCM_KEY_NODE)HvGetCell(Hive, Cell);
    SecurityCell = HvAllocateCell(Hive,
                                  SECURITY_CELL_LENGTH(Descriptor),
                                  Stable);
    if (SecurityCell == HCELL_NIL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Node->u1.s1.Security = SecurityCell;
    Security = (PCM_KEY_SECURITY)HvGetCell(Hive, SecurityCell);
    DescriptorLength = RtlLengthSecurityDescriptor(Descriptor);
    Security->Signature = CM_KEY_SECURITY_SIGNATURE;
    Security->ReferenceCount = 1;
    Security->DescriptorLength = DescriptorLength;
    RtlMoveMemory( &Security->Descriptor,
                   Descriptor,
                   DescriptorLength );
    Security->Flink = Security->Blink = SecurityCell;
    return(STATUS_SUCCESS);

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\hivedmp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivedmp.c

Abstract:

    Utility to display all or part of the registry in a format that
    is suitable for input to the REGINI program.

    HIVEDMP [-r] -f filename

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    Handles all value types (e.g. REG_???) defined in ntregapi.h

    -r forces ALL value type to be output in RAW (hex) form.

    Default KeyPath if none specified is \Registry

Author:

    Steve Wood (stevewo)  12-Mar-92

Revision History:

    30-Nov-92   bryanwi     Add -r switch

--*/

#include "regutil.h"
#include "edithive.h"

void
DumpValues(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    ULONG IndentLevel
    );

void
DumpKeys(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    PUNICODE_STRING KeyName,
    ULONG IndentLevel
    );

void
RegDumpKeyValueR(
    FILE *fh,
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    ULONG IndentLevel
    );

PVOID ValueBuffer;
ULONG ValueBufferSize;

BOOLEAN RawOutput = FALSE;

void
Usage( void )
{
    fprintf( stderr, "usage: HIVEDMP [-f hivefile]\n" );
    exit( 1 );
}


void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    char *s;
    ANSI_STRING AnsiString;
    UNICODE_STRING KeyName;
    UNICODE_STRING DosName;
    UNICODE_STRING FileName;
    UNICODE_STRING RootName;
    HANDLE HiveHandle = NULL;
    HANDLE RootKey = NULL;
    BOOLEAN ArgumentSeen;
    LPSTR HiveFile=NULL;

    ValueBufferSize = VALUE_BUFFER_SIZE;
    ValueBuffer = VirtualAlloc( NULL, ValueBufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (ValueBuffer == NULL) {
        fprintf( stderr, "REGDMP: Unable to allocate value buffer.\n" );
        exit( 1 );
        }

    ArgumentSeen = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'd':
                        DebugOutput = TRUE;
                        break;

                    case 's':
                        SummaryOutput = TRUE;
                        break;

                    case 'r':
                        RawOutput = TRUE;
                        break;

                    case 'f':
                        if (argc--) {
                            RtlInitString( &AnsiString, *++argv );
                            RtlAnsiStringToUnicodeString( &DosName,
                                                          &AnsiString,
                                                          TRUE );
                            RtlDosPathNameToNtPathName_U( DosName.Buffer,
                                                          &FileName,
                                                          NULL,
                                                          NULL );
                            HiveHandle = EhOpenHive( &FileName,
                                                     &RootKey,
                                                     &RootName,
                                                     TYPE_SIMPLE );
                            ArgumentSeen = TRUE;
                            break;
                        }

                    default:    Usage();
                    }
                }
            }
#if 0
        else {
            RtlInitString( &AnsiString, s );
            RtlAnsiStringToUnicodeString( &KeyName, &AnsiString, TRUE );
            DumpKeys( HiveHandle, RootKey, &KeyName, 0 );
            ArgumentSeen = TRUE;
            }
#endif
        }

    if (ArgumentSeen) {
        if (HiveHandle != NULL) {
            DumpKeys( HiveHandle, RootKey, &RootName, 0 );
        } else {
            fprintf(stderr, "Couldn't open hive file %wZ\n",&DosName);
        }
    } else {
        Usage();
    }


    exit( 0 );
}


void
DumpKeys(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    PUNICODE_STRING KeyName,
    ULONG IndentLevel
    )
{
    NTSTATUS Status;
    HANDLE SubKeyHandle;
    WCHAR KeyBuffer[ 512 ];
    PKEY_BASIC_INFORMATION KeyInformation;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG SubKeyIndex;
    UNICODE_STRING SubKeyName;
    ULONG ResultLength;


    //
    // Print name of node we are about to dump out
    //
    printf( "%.*s%wZ\n",
            IndentLevel,
            "                                                                                  ",
            KeyName
          );

    //
    // Print out node's values
    //
    DumpValues( HiveHandle, KeyHandle, IndentLevel+4 );

    //
    // Enumerate node's children and apply ourselves to each one
    //

    KeyInformation = (PKEY_BASIC_INFORMATION)KeyBuffer;
    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        Status = EhEnumerateKey( HiveHandle,
                                 KeyHandle,
                                 SubKeyIndex,
                                 KeyBasicInformation,
                                 KeyInformation,
                                 sizeof( KeyBuffer ),
                                 &ResultLength
                               );

        if (Status == STATUS_NO_MORE_ENTRIES) {
            return;
            }
        else
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr,
                     "REGDMP: NtEnumerateKey failed - Status ==%08lx\n",
                     Status
                   );
            exit( 1 );
            }

        SubKeyName.Buffer = (PWSTR)&(KeyInformation->Name[0]);
        SubKeyName.Length = (USHORT)KeyInformation->NameLength;
        SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;

        Status = EhOpenChildByName( HiveHandle,
                                    KeyHandle,
                                    &SubKeyName,
                                    &SubKeyHandle );
        if (NT_SUCCESS(Status)) {
            DumpKeys( HiveHandle, SubKeyHandle, &SubKeyName, IndentLevel+4 );
        }
    }

}


void
DumpValues(
    HANDLE HiveHandle,
    HANDLE KeyHandle,
    ULONG IndentLevel
    )
{
    NTSTATUS Status;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG ValueIndex;
    ULONG ResultLength;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ValueBuffer;
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        Status = EhEnumerateValueKey( HiveHandle,
                                      KeyHandle,
                                      ValueIndex,
                                      KeyValueFullInformation,
                                      KeyValueInformation,
                                      ValueBufferSize,
                                      &ResultLength
                                    );
        if (Status == STATUS_NO_MORE_ENTRIES) {
            return;
        } else if (!NT_SUCCESS( Status )) {
            fprintf( stderr,
                     "REGDMP: NtEnumerateValueKey failed - Status == %08lx\n",
                     Status
                   );
            exit( 1 );
        }

        if (RawOutput == TRUE) {
            RegDumpKeyValueR( stdout, KeyValueInformation, IndentLevel );
        } else {
            RegDumpKeyValue( stdout, KeyValueInformation, IndentLevel );
        }
    }
}


void
RegDumpKeyValueR(
    FILE *fh,
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    ULONG IndentLevel
    )
{
    PULONG p;
    PWSTR pw, pw1;
    ULONG i, j, k, m, cbPrefix;
    UNICODE_STRING ValueName;
    PUCHAR pbyte;

    cbPrefix = fprintf( fh, "%.*s",
                        IndentLevel,
                        "                                                                                  "
                      );
    ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
    ValueName.Length = (USHORT)KeyValueInformation->NameLength;
    ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;

    if (ValueName.Length) {
        cbPrefix += fprintf( fh, "%wS ", &ValueName );
        }
    cbPrefix += fprintf( fh, "= " );

    if (KeyValueInformation->DataLength == 0) {
        fprintf( fh, " [no data] \n");
        return;
    }

    fprintf( fh, "REG_BINARY 0x%08lx", KeyValueInformation->DataLength );
    p = (PULONG)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
    i = (KeyValueInformation->DataLength + 3) / sizeof( ULONG );
    for (j=0; j<i; j++) {
        if ((j % 8) == 0) {
            fprintf( fh, "\n%.*s",
                     IndentLevel+4,
                     "                                                                                  "
                   );
            }

        fprintf( fh, "0x%08lx  ", *p++ );
        }
    fprintf( fh, "\n" );

    fprintf( fh, "\n" );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\test\rtvbatcr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rtvbatcr.c

Abstract:

    NT level registry api test program, basic non-error paths.

    Do a batch create, VOLATILE.  (Same as rtbatcr, but creates keys volatile.)

    rtvbatcr    <KeyPath> <KeyName> <basename> <#children> <#values>

    Will attempt to create key <KeyName> as child of <KeyPath>  If
    <#children> and <#values> are 0, this is all it does.  If <KeyName>
    already exists, it will simply be used.

    Will create <#children> child cells, with names of the form
    <base>0  <base>1, etc.  Will create <#values> value entries,
    with similar names, for each created child key.  Data of
    values will be a constant string including their name.

    Example:

        rtvbatcr    \REGISTRY\MACHINE\TEST bigkey runa_ 100 100
        rtvbatcr    \REGISTRY\MACHINE\TEST\bigkey runa_1 runb_ 100 100

        Will create bigkey, give it 100 values calls runa_1 through
        runa_100, create 100 subkeys called runa_1 through runa_100
        for each of those children.

        It will then open bigkey\runa_1, and create 100 subkeys and
        100 values each for that.

Author:

    Bryan Willman (bryanwi)  10-Dec-91

Revision History:

--*/

#include "cmp.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WORK_SIZE   1024

void __cdecl main(int, char *);
void processargs();

ULONG           failure = 0;

UNICODE_STRING  KeyPath;
UNICODE_STRING  KeyName;
ULONG           NumberChildren;
ULONG           NumberValues;
UCHAR           BaseName[WORK_SIZE];
UCHAR           formatbuffer[WORK_SIZE];
STRING          format;

UNICODE_STRING  WorkName;
WCHAR           workbuffer[WORK_SIZE];

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE          BaseHandle;
    HANDLE          WorkHandle;
    ULONG           Disposition;
    UNICODE_STRING  ClassName;
    ULONG           i;
    ULONG           j;
    PUCHAR  p;

    //
    // Process args
    //

    processargs(argc, argv);


    //
    // Set up and create/open KeyPath|KeyName
    //

    printf("rtvbatcr: starting\n");

    WorkName.MaximumLength = WORK_SIZE;
    WorkName.Length = 0L;
    WorkName.Buffer = &(workbuffer[0]);

    RtlCopyString((PSTRING)&WorkName, (PSTRING)&KeyPath);

    p = WorkName.Buffer;
    p += WorkName.Length;
    *p = '\\';
    p++;
    *p = '\0';
    WorkName.Length += 2;

    RtlAppendStringToString((PSTRING)&WorkName, (PSTRING)&KeyName);

    RtlInitUnicodeString(
        &ClassName,
        L"Test Class Name"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkName,
        0,
        (HANDLE)NULL,
        NULL
        );
    ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

    status = NtCreateKey(
                &BaseHandle,
                MAXIMUM_ALLOWED,
                &ObjectAttributes,
                0,
                &ClassName,
                REG_OPTION_VOLATILE,
                &Disposition
                );
    if (!NT_SUCCESS(status)) {
        printf("rtvbatcr: t0: %08lx\n", status);
        failure++;
        goto punt;
    }


    //
    // Create NumberChildren subkeys
    //

    for (i = 0; i < NumberChildren; i++) {

        sprintf(formatbuffer, "%s%d", BaseName, i);
        RtlInitString(&format, formatbuffer);
        RtlAnsiStringToUnicodeString(&WorkName, &format, FALSE);


        InitializeObjectAttributes(
            &ObjectAttributes,
            &WorkName,
            0,
            BaseHandle,
            NULL
            );
        ObjectAttributes.Attributes |= OBJ_CASE_INSENSITIVE;

        status = NtCreateKey(
                    &WorkHandle,
                    MAXIMUM_ALLOWED,
                    &ObjectAttributes,
                    0,
                    &ClassName,
                    REG_OPTION_VOLATILE,
                    &Disposition
                    );
        if (!NT_SUCCESS(status)) {
            printf("rtvbatcr: t1: status = %08lx i = %d\n", status, i);
            failure++;
        }

        //
        // Create NumberValues value entries for each (current) key
        //

        for (j = 0; j < NumberValues; j++) {

            sprintf(formatbuffer, "%s%d", BaseName, j);
            RtlInitString(&format, formatbuffer);
            RtlAnsiStringToUnicodeString(&WorkName, &format, FALSE);

            sprintf(
                formatbuffer, "This is a rtvbatcr value for %s%d", BaseName, j
                );

            status = NtSetValueKey(
                        WorkHandle,
                        &WorkName,
                        j,
                        j,
                        formatbuffer,
                        strlen(formatbuffer)+1
                        );
            if (!NT_SUCCESS(status)) {
                printf("rtvbatcr: t2: status = %08lx j = %d\n", status, j);
                failure++;
            }
        }
        NtClose(WorkHandle);
    }

punt:
    printf("rtvbatcr: %d failures\n", failure);
    exit(failure);
}


void
processargs(
    int argc,
    char *argv[]
    )
{
    ANSI_STRING temp;

    if ( (argc != 3) && (argc != 6) )
    {
        printf("Usage: %s <KeyPath> <KeyName> [<basename> <#children> <#values>]\n",
                argv[0]);
        exit(1);
    }

    RtlInitAnsiString(
        &temp,
        argv[1]
        );

    RtlAnsiStringToUnicodeString(
        &KeyPath,
        &temp,
        TRUE
        );

    RtlInitAnsiString(
        &temp,
        argv[2]
        );

    RtlAnsiStringToUnicodeString(
        &KeyName,
        &temp,
        TRUE
        );

    if (argc < 6) {

        NumberChildren = 0;
        NumberValues = 0;

    } else {

        strcpy(BaseName, argv[3]);
        NumberChildren = atoi(argv[4]);
        NumberValues = atoi(argv[5]);

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\cmwraper.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cmwraper.c

Abstract:

    Provides wrapper routines to support ntos\config routines called from
    user-mode.

Author:

    John Vert (jvert) 26-Mar-1992

Revision History:

--*/
#include "edithive.h"
#include "nturtl.h"
#include "stdlib.h"
#include "stdio.h"

extern  ULONG   UsedStorage;

CCHAR KiFindFirstSetRight[256] = {
        0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};


ULONG   MmSizeOfPagedPoolInBytes = 0xffffffff;  // stub out

ULONG
DbgPrint (
    IN PCH Format,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    STRING Output;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    Output.Length = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);
    Output.Buffer = Buffer;
    printf("%s", Buffer);
    return 0;
}


//
// Structure that describes the mapping of generic access rights to object
// specific access rights for registry key and keyroot objects.
//

GENERIC_MAPPING CmpKeyMapping = {
    KEY_READ,
    KEY_WRITE,
    KEY_EXECUTE,
    KEY_ALL_ACCESS
};
BOOLEAN CmpNoWrite = FALSE;
PCMHIVE CmpMasterHive = NULL;
LIST_ENTRY CmpHiveListHead;            // List of CMHIVEs

NTSTATUS
MyCmpInitHiveFromFile(
    IN PUNICODE_STRING FileName,
    OUT PCMHIVE *CmHive,
    OUT PBOOLEAN Allocate
    );


VOID
CmpLazyFlush(
    VOID
    )
{
}


VOID
CmpFreeSecurityDescriptor(
    IN PHHIVE Hive,
    IN HCELL_INDEX Cell
    )
{
    return;
}

VOID
CmpReportNotify(
    UNICODE_STRING          Name,
    PHHIVE                  Hive,
    HCELL_INDEX             Cell,
    ULONG                   Filter
    )
{
}

VOID
CmpLockRegistry(VOID)
{
    return;
}

BOOLEAN
CmpTryLockRegistryExclusive(
    IN BOOLEAN CanWait
    )
{
    return TRUE;
}

VOID
CmpUnlockRegistry(
    )
{
}

BOOLEAN
CmpTestRegistryLock()
{
    return TRUE;
}

BOOLEAN
CmpTestRegistryLockExclusive()
{
    return TRUE;
}
LONG
KeReleaseMutex (
    IN PKMUTEX Mutex,
    IN BOOLEAN Wait
    )
{
    return(0);
}
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    return(STATUS_SUCCESS);
}

BOOLEAN
CmpValidateHiveSecurityDescriptors(
    IN PHHIVE Hive
    )
{
    PCM_KEY_NODE RootNode;
    PCM_KEY_SECURITY SecurityCell;
    HCELL_INDEX ListAnchor;
    HCELL_INDEX NextCell;
    HCELL_INDEX LastCell;
    BOOLEAN ValidHive = TRUE;

    KdPrint(("CmpValidateHiveSecurityDescriptor: Hive = %lx\n",(ULONG)Hive));
    RootNode = (PCM_KEY_NODE) HvGetCell(Hive, Hive->BaseBlock->RootCell);
    ListAnchor = NextCell = RootNode->u1.s1.Security;

    do {
        SecurityCell = (PCM_KEY_SECURITY) HvGetCell(Hive, NextCell);
        if (NextCell != ListAnchor) {
            //
            // Check to make sure that our Blink points to where we just
            // came from.
            //
            if (SecurityCell->Blink != LastCell) {
                KdPrint(("  Invalid Blink (%ld) on security cell %ld\n",SecurityCell->Blink, NextCell));
                KdPrint(("  should point to %ld\n", LastCell));
                ValidHive = FALSE;
            }
        }
        KdPrint(("CmpValidSD:  SD shared by %d nodes\n",SecurityCell->ReferenceCount));
//        SetUsed(Hive, NextCell);
        LastCell = NextCell;
        NextCell = SecurityCell->Flink;
    } while ( NextCell != ListAnchor );
    return(TRUE);
}

VOID
KeBugCheck(
    IN ULONG BugCheckCode
    )
{
    printf("BugCheck: code = %08lx\n", BugCheckCode);
    exit(1);
}

VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG Arg1,
    IN ULONG Arg2,
    IN ULONG Arg3,
    IN ULONG Arg4
    )
{
    printf("BugCheck: code = %08lx\n", BugCheckCode);
    printf("Args =%08lx %08lx %08lx %08lx\n", Arg1, Arg2, Arg3, Arg4);
    exit(1);
}


VOID
KeQuerySystemTime(
    OUT PLARGE_INTEGER SystemTime
    )
{
    NtQuerySystemTime(SystemTime);
}

#ifdef POOL_TAGGING
PVOID
ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    )
{
    PVOID   Address = NULL;
    ULONG   Size;
    NTSTATUS    status;

    Size = ROUND_UP(NumberOfBytes, HBLOCK_SIZE);
    status = NtAllocateVirtualMemory(
                NtCurrentProcess(),
                &Address,
                0,
                &Size,
                MEM_COMMIT,
                PAGE_READWRITE
                );
    if (!NT_SUCCESS(status)) {
        return NULL;
    }
    return Address;
}
#else

PVOID
ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )
{
    PVOID   Address = NULL;
    ULONG   Size;
    NTSTATUS    status;

    Size = ROUND_UP(NumberOfBytes, HBLOCK_SIZE);
    status = NtAllocateVirtualMemory(
                NtCurrentProcess(),
                &Address,
                0,
                &Size,
                MEM_COMMIT,
                PAGE_READWRITE
                );
    if (!NT_SUCCESS(status)) {
        return NULL;
    }
    return Address;
}
#endif

VOID
ExFreePool(
    IN PVOID P
    )
{
    ULONG   size;
    size = HBLOCK_SIZE;

    // if it was really more than 1 page, well, too bad
    NtFreeVirtualMemory(
        NtCurrentProcess(),
        &P,
        &size,
        MEM_DECOMMIT
        );
    return;
}


NTSTATUS
CmpWorkerCommand(
    IN OUT PREGISTRY_COMMAND Command
    )

/*++

Routine Description:

    This routine just encapsulates all the necessary synchronization for
    sending a command to the worker thread.

Arguments:

    Command - Supplies a pointer to an initialized REGISTRY_COMMAND structure
            which will be copied into the global communication structure.

Return Value:

    NTSTATUS = Command.Status

--*/

{
    PCMHIVE CmHive;
    PUNICODE_STRING FileName;
    ULONG i;

    switch (Command->Command) {

        case REG_CMD_FLUSH_KEY:
            return CmFlushKey(Command->Hive, Command->Cell);
            break;

        case REG_CMD_FILE_SET_SIZE:
            return CmpDoFileSetSize(
                      Command->Hive,
                      Command->FileType,
                      Command->FileSize
                      );
            break;

        case REG_CMD_HIVE_OPEN:

            //
            // Open the file.
            //
            FileName = Command->FileAttributes->ObjectName;

            return MyCmpInitHiveFromFile(FileName,
                                         &Command->CmHive,
                                         &Command->Allocate);

            break;

        case REG_CMD_HIVE_CLOSE:

            //
            // Close the files associated with this hive.
            //
            CmHive = Command->CmHive;

            for (i=0; i<HFILE_TYPE_MAX; i++) {
                if (CmHive->FileHandles[i] != NULL) {
                    NtClose(CmHive->FileHandles[i]);
                }
            }
            return STATUS_SUCCESS;
            break;

        case REG_CMD_SHUTDOWN:

            //
            // shut down the registry
            //
            break;

        default:
            return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS
MyCmpInitHiveFromFile(
    IN PUNICODE_STRING FileName,
    OUT PCMHIVE *CmHive,
    OUT PBOOLEAN Allocate
    )

/*++

Routine Description:

    This routine opens a file and log, allocates a CMHIVE, and initializes
    it.

Arguments:

    FileName - Supplies name of file to be loaded.

    CmHive   - Returns pointer to initialized hive (if successful)

    Allocate - Returns whether the hive was allocated or existing.

Return Value:

    NTSTATUS

--*/

{
    PCMHIVE NewHive;
    ULONG Disposition;
    ULONG SecondaryDisposition;
    HANDLE PrimaryHandle;
    HANDLE LogHandle;
    NTSTATUS Status;
    ULONG FileType;
    ULONG Operation;

    BOOLEAN Success;

    *CmHive = NULL;

    Status = CmpOpenHiveFiles(FileName,
                              L".log",
                              &PrimaryHandle,
                              &LogHandle,
                              &Disposition,
                              &SecondaryDisposition,
                              TRUE,
                              NULL
                              );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    if (LogHandle == NULL) {
        FileType = HFILE_TYPE_PRIMARY;
    } else {
        FileType = HFILE_TYPE_LOG;
    }

    if (Disposition == FILE_CREATED) {
        Operation = HINIT_CREATE;
        *Allocate = TRUE;
    } else {
        Operation = HINIT_FILE;
        *Allocate = FALSE;
    }

    Success = CmpInitializeHive(&NewHive,
                                Operation,
                                FALSE,
                                FileType,
                                NULL,
                                PrimaryHandle,
                                NULL,
                                LogHandle,
                                NULL,
                                NULL);
    if (!Success) {
        NtClose(PrimaryHandle);
        if (LogHandle != NULL) {
            NtClose(LogHandle);
        }
        return(STATUS_REGISTRY_CORRUPT);
    } else {
        *CmHive = NewHive;
        return(STATUS_SUCCESS);
    }
}

NTSTATUS
CmpLinkHiveToMaster(
    PUNICODE_STRING LinkName,
    HANDLE RootDirectory,
    PCMHIVE CmHive,
    BOOLEAN Allocate,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    return( STATUS_SUCCESS );
}


BOOLEAN
CmpFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize
    )
/*++

Routine Description:

    This routine sets the size of a file.  It must not return until
    the size is guaranteed, therefore, it does a flush.

    It is environment specific.

    This routine will force execution to the correct thread context.

Arguments:

    Hive - Hive we are doing I/O for

    FileType - which supporting file to use

    FileSize - 32 bit value to set the file's size to

Return Value:

    FALSE if failure
    TRUE if success

--*/
{
    NTSTATUS    status;

    status = CmpDoFileSetSize(Hive, FileType, FileSize);
    if (!NT_SUCCESS(status)) {
        KdPrint(("CmpFileSetSize:\n\t"));
        KdPrint(("Failure: status = %08lx ", status));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\hivehdr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivehdr.c

Abstract:

    Dump the header of a hive primary, alternate, or log file.

    hivehdr filename filename filename ...

Author:

    Bryan Willman (bryanwi)  6-april-92

Revision History:

--*/


#define _ARCCODES_

#include "regutil.h"
#include "edithive.h"

void
DoDump(
    PUCHAR  Filename
    );

void
__cdecl main(
    int argc,
    char *argv[]
    )
{
    int i;

    if (argc == 1) {
        fprintf(stderr, "Usage: hivehdr filename filename...\n", argv[0]);
        exit(1);
    }

    for (i = 1; i < argc; i++) {
        DoDump(argv[i]);
    }

    exit(0);
}

void
DoDump(
    PUCHAR  Filename
    )
{
    HANDLE  infile;
    static char buffer[HSECTOR_SIZE];
    PHBASE_BLOCK bbp;
    char   *validstring[] = { "BAD", "OK" };
    int     valid;
    char   *typename[] = { "primary", "alternate", "log", "external", "unknown" };
    int     typeselect;
    int     readcount;
    unsigned long checksum;
    unsigned long i;

    infile = (HANDLE)CreateFile(
            Filename,                           // file name
            GENERIC_READ,                       // desired access
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share mode
            NULL,                               // security attributes
            OPEN_EXISTING,                      // creation disposition
            FILE_FLAG_SEQUENTIAL_SCAN,          // flags and attributes
            NULL                                // template file
    );
    if (infile == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "hivehdr: Could not open '%s'\n", Filename);
        return;
    }

    if (!ReadFile(infile, buffer, HSECTOR_SIZE, &readcount, NULL)) {
        fprintf(
            stderr, "hivehdr: '%s' - cannot read full base block\n", Filename);
        return;
    }
    if (readcount != HSECTOR_SIZE) {
        fprintf(
            stderr, "hivehdr: '%s' - cannot read full base block\n", Filename);
        return;
    }

    bbp = (PHBASE_BLOCK)&(buffer[0]);

    if ((bbp->Major != 1) || (bbp->Minor != 1)) {
        printf("WARNING: Hive file is newer than hivehdr, or is invalid\n");
    }

    printf("         File: '%s'\n", Filename);
    printf("    BaseBlock:\n");

    valid = (bbp->Signature == HBASE_BLOCK_SIGNATURE);
    printf("    Signature: %08lx  '%4.4s'\t\t%s\n",
            bbp->Signature, (PUCHAR)&(bbp->Signature), validstring[valid]);

    valid = (bbp->Sequence1 == bbp->Sequence2);
    printf(" Sequence1//2: %08lx//%08lx\t%s\n",
            bbp->Sequence1, bbp->Sequence2, validstring[valid]);

    printf("    TimeStamp: %08lx:%08lx\n",
            bbp->TimeStamp.HighPart, bbp->TimeStamp.LowPart,
            (PUCHAR)&(bbp->Signature), validstring[valid]);

    valid = (bbp->Major == HSYS_MAJOR);
    printf("Major Version: %08lx\t\t\t%s\n",
            bbp->Major, validstring[valid]);

    valid = (bbp->Minor == HSYS_MINOR);
    printf("Minor Version: %08lx\t\t\t%s\n",
            bbp->Minor, validstring[valid]);

    valid = ( (bbp->Type == HFILE_TYPE_PRIMARY) ||
              (bbp->Type == HFILE_TYPE_ALTERNATE) ||
              (bbp->Type == HFILE_TYPE_LOG) );
    if (valid) {
        typeselect = bbp->Type;
    } else {
        typeselect = HFILE_TYPE_MAX;
    }

    printf("         Type: %08lx %s\t\t%s\n",
            bbp->Type, typename[typeselect], validstring[valid]);

    valid = (bbp->Format == HBASE_FORMAT_MEMORY);
    printf("       Format: %08lx\t\t\t%s\n",
            bbp->Format, validstring[valid]);

    printf("     RootCell: %08lx\n", bbp->RootCell);

    printf("       Length: %08lx\n", bbp->Length);

    printf("      Cluster: %08lx\n", bbp->Cluster);

    checksum = HvpHeaderCheckSum(bbp);
    valid = (checksum == bbp->CheckSum);
    if (checksum == bbp->CheckSum) {
        printf("     CheckSum: %08lx\t\t\t%s\n",
                bbp->CheckSum, validstring[TRUE]);
    } else {
        printf("     CheckSum: %08lx\t\t\t%s\tCorrect: %08lx\n",
                bbp->CheckSum, validstring[FALSE], checksum);
    }

    //
    // print last part of file name, aid to identification
    //
    printf("Hive/FileName: ");

    for (i = 0; i < HBASE_NAME_ALLOC;i+=sizeof(WCHAR)) {
        printf("%wc", bbp->FileName[i]);
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\hivestat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hivestat.c

Abstract:

    Dumps various statistics on hv (low) level structures in a hive.  (See
    regstat for higher level stuff.)

    Statistics:

        Short:  # of bins
                average bin size
                max bin size
                # of cells
                # of free cells
                # of allocated cells
                average free cell size
                total free size
                max free cell size
                average allocated size
                total allocated size
                max allocated cell size
                overhead summary (header, bin headers, cell headers)

        Long: bin#, offset, size
              cell offset, size, allocated
              cell offset, size, free


    Usage: {[+|-][<option>]} <filename>
           (+ = on by default, - = off by default)
           +s = summary - all of the short statistics
           -t[bafc] = trace, line per entry, bin, allocated, free, all cells
                (+tbc == +tbaf)
           -c = cell type summary
           -a[kvs] = Access Export (key nodes, values, SDs)

Author:

    Bryan M. Willman (bryanwi) 2-Sep-1992

Revision History:

--*/

/*

    NOTE:   Unlike other hive/registry tools, this one will not read the
            entire hive into memory, but will instead read it in via
            file I/O.  This makes it faster/easier to apply to very large
            hives.

*/
#include "regutil.h"
#include "edithive.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

UCHAR *helptext[] = {
 "hivestat:                                                               ",
 "Statistics:                                                             ",
 "    Short:  # of bins                                                   ",
 "            average bin size                                            ",
 "            max bin size                                                ",
 "            # of cells                                                  ",
 "            # of free cells                                             ",
 "            # of allocated cells                                        ",
 "            average free cell size                                      ",
 "            total free size                                             ",
 "            max free cell size                                          ",
 "            average allocated size                                      ",
 "            total allocated size                                        ",
 "            max allocated cell size                                     ",
 "            overhead summary (header, bin headers, cell headers)        ",
 "    Long: bin#, offset, size                                            ",
 "          cell offset, size, allocated                                  ",
 "          cell offset, size, free                                       ",
 "Usage: {[+|-][<option>]} <filename>                                     ",
 "       (+ = on by default, - = off by default)                          ",
 "       +s = summary - all of the short statistics                       ",
 "       -t[bafc] = trace, line per entry, bin, allocated, free, all cells",
 "            (+tbc == +tbaf)                                             ",
 "       -c = cell type summary                                           ",
 "       -a[kvs] = Access Export (key nodes, values, SDs)                 ",
 NULL
};


VOID
ParseArgs(
    int     argc,
    char    *argv[]
    );

VOID
ScanHive(
    VOID
    );

VOID
ScanCell(
    PHCELL Cell,
    ULONG CellSize
    );

VOID
ScanKeyNode(
    IN PCM_KEY_NODE Node,
    IN ULONG CellSize
    );

VOID
ScanKeyValue(
    IN PCM_KEY_VALUE Value,
    IN ULONG CellSize
    );

VOID
ScanKeySD(
    IN PCM_KEY_SECURITY Security,
    IN ULONG CellSize
    );

VOID
ScanKeyIndex(
    IN PCM_KEY_INDEX Index,
    IN ULONG CellSize
    );

VOID
ScanUnknown(
    IN PCELL_DATA Data,
    IN ULONG CellSize
    );


//
//  CONTROL ARGUMENTS
//
BOOLEAN DoCellType = FALSE;
BOOLEAN DoSummary = TRUE;
BOOLEAN DoTraceBin = FALSE;
BOOLEAN DoTraceFree = FALSE;
BOOLEAN DoTraceAlloc = FALSE;

BOOLEAN AccessKeys = FALSE;
BOOLEAN AccessValues = FALSE;
BOOLEAN AccessSD = FALSE;
LPCTSTR FileName = NULL;

ULONG HiveVersion;

//
//  SUMMARY TOTALS
//
ULONG SizeKeyData=0;
ULONG SizeValueData=0;
ULONG SizeSDData=0;
ULONG SizeIndexData=0;
ULONG SizeUnknownData=0;

ULONG NumKeyData=0;
ULONG NumValueData=0;
ULONG NumSDData=0;
ULONG NumIndexData=0;
ULONG NumUnknownData=0;

void
main(
    int argc,
    char *argv[]
    )
{
    ParseArgs(argc, argv);
    ScanHive();
    exit(0);
}

VOID
ParseArgs(
    int     argc,
    char    *argv[]
    )
/*++

Routine Description:

    Read arguments and set control arguments and file name from them.

Arguments:

    argc, argv, standard meaning

Return Value:

    None.

--*/
{
    char *p;
    int i;
    BOOLEAN command;

    if (argc == 1) {
        for (i = 0; helptext[i] != NULL; i++) {
            fprintf(stderr, "%s\n", helptext[i]);
        }
        exit(1);
    }

    for (i = 1; i < argc; i++) {
        p = argv[i];

        if (*p == '+') {
            // switch something on
            command = TRUE;

        } else if (*p == '-') {
            // switch something off
            command = FALSE;

        } else {
            FileName = p;
            continue;
        }

        p++;
        if (*p == '\0')
            continue;

        switch (*p) {
        case 's':
        case 'S':
            DoSummary = command;
            break;

        case 'c':
        case 'C':
            DoCellType = command;
            break;

        case 'a':
        case 'A':
            p++;
            while (*p != '\0') {
                switch (*p) {
                    case 'k':
                    case 'K':
                        AccessKeys = command;
                        break;

                    case 's':
                    case 'S':
                        AccessSD = command;
                        break;

                    case 'v':
                    case 'V':
                        AccessValues = command;
                        break;

                    default:
                        break;
                }
                p++;
            }
            break;

        case 't':
        case 'T':
            p++;
            while (*p != '\0') {

                switch (*p) {
                case 'b':
                case 'B':
                    DoTraceBin = command;
                    break;

                case 'a':
                case 'A':
                    DoTraceAlloc = command;
                    break;

                case 'f':
                case 'F':
                    DoTraceFree = command;
                    break;

                case 'c':
                case 'C':
                    DoTraceAlloc = command;
                    DoTraceFree = command;
                    break;

                default:
                    break;
                }

                p++;
            }
            break;

        default:
            break;
        }
    }
    return;
}

VOID
ScanHive(
    )
/*++

Routine Description:

    Scan the hive, report what we see, based on control arguments.

--*/
{
    static char buffer[HBLOCK_SIZE];
    PHBASE_BLOCK bbp;
    HANDLE filehandle;
    BOOL rf;
    ULONG readcount;
    ULONG hivelength;
    ULONG hiveposition;
    PHCELL cp;
    PHCELL guard;
    PHBIN hbp;
    ULONG hoff;
    ULONG StatBinCount = 0;
    ULONG StatBinTotal = 0;
    ULONG StatBinMax = 0;
    ULONG StatFreeCount = 0;
    ULONG StatFreeTotal = 0;
    ULONG StatFreeMax = 0;
    ULONG StatAllocCount = 0;
    ULONG StatAllocTotal = 0;
    ULONG StatAllocMax = 0;
    ULONG binread;
    ULONG binsize;
    ULONG cellsize;
    ULONG boff;
    ULONG lboff;
    ULONG SizeTotal;

    //
    // open the file
    //
    filehandle = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (filehandle == INVALID_HANDLE_VALUE) {
        fprintf(stderr,
                "hivestat: Could not open file '%s' error = %08lx\n",
                FileName, GetLastError()
                );
        exit(1);
    }


    //
    // read the header
    //
    rf = ReadFile(filehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
    if ( ( ! rf ) || (readcount != HBLOCK_SIZE) ) {
        fprintf(stderr, "hivestat: '%s' - cannot read base block!\n", FileName);
        exit(1);
    }

    bbp = (PHBASE_BLOCK)(&(buffer[0]));

    if ((bbp->Major != HSYS_MAJOR) ||
        (bbp->Minor > HSYS_MINOR))
    {
        fprintf(stderr,
                "hivestat: major/minor != %d/%d get newer hivestat\n",
                HSYS_MAJOR, HSYS_MINOR
                );
        exit(1);
    }

    HiveVersion = bbp->Minor;

    hivelength = bbp->Length + HBLOCK_SIZE;
    hiveposition = HBLOCK_SIZE;
    hoff = 0;

    printf("hivestat: '%s'\n", FileName);
    if (DoTraceBin || DoTraceFree || DoTraceAlloc) {
        printf("\nTrace\n");
        printf("bi=bin, fr=free, al=allocated\n");
        printf("offset is file offset, sub HBLOCK to get HCELL\n");
        printf("type,offset,size\n");
        printf("\n");
    }

    //
    // scan the hive
    //
    guard = (PHCELL)(&(buffer[0]) + HBLOCK_SIZE);

    //
    // hiveposition is file relative offset of next block we will read
    //
    // hoff is the file relative offset of the last block we read
    //
    // hivelength is actual length of file (header's recorded length plus
    // the size of the header.
    //
    // cp is pointer into memory, within range of buffer, it's a cell pointer
    //
    while (hiveposition < hivelength) {

        //
        // read in first block of bin, check signature, get bin stats
        //
        rf = ReadFile(filehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
        if ( ( ! rf ) || (readcount != HBLOCK_SIZE) ) {
            fprintf(stderr, "hivestat: '%s' read error @%08lx\n", FileName, hiveposition);
            exit(1);
        }
        hbp = (PHBIN)(&(buffer[0]));

        if (hbp->Signature != HBIN_SIGNATURE) {
            fprintf(stderr,
                    "hivestat: '%s' bad bin sign. @%08lx\n", FileName, hiveposition);
            exit(1);
        }
        hiveposition += HBLOCK_SIZE;
        hoff += HBLOCK_SIZE;
        ASSERT(hoff+HBLOCK_SIZE == hiveposition);

        StatBinCount++;
        binsize = hbp->Size;
        StatBinTotal += binsize;
        if (binsize > StatBinMax) {
            StatBinMax = binsize;
        }

        if (DoTraceBin) {
            printf("bi,x%08lx,%ld\n", hoff, binsize);
        }

        //
        // scan the bin
        //
        // cp = pointer to cell we are looking at
        // boff = offset within bin
        // lboff = last offset within bin, used only for consistency checks
        // binread = number of bytes of bin we've read so far
        //
        cp = (PHCELL)((PUCHAR)hbp + sizeof(HBIN));
        boff = sizeof(HBIN);
        lboff = -1;
        binread = HBLOCK_SIZE;

        while (binread <= binsize) {

            //
            // if free, do free stuff
            // else do alloc stuff
            // do full stuff
            //
            if (cp->Size > 0) {
                //
                // free
                //
                cellsize = cp->Size;
                StatFreeCount++;
                StatFreeTotal += cellsize;
                if (cellsize > StatFreeMax) {
                    StatFreeMax = cellsize;
                }

                if (DoTraceFree) {
                    printf("fr,x%08lx,%ld\n",
                           hoff+((PUCHAR)cp - &(buffer[0])), cellsize);
                }


            } else {
                //
                // alloc
                //
                cellsize = -1 * cp->Size;
                StatAllocCount++;
                StatAllocTotal += cellsize;
                if (cellsize > StatAllocMax) {
                    StatAllocMax = cellsize;
                }

                if (DoTraceAlloc) {
                    printf("al,x%08lx,%ld\n",
                           hoff+((PUCHAR)cp - &(buffer[0])), cellsize);
                }

                ScanCell(cp,cellsize);

            }

            //
            // do basic consistency check
            //
#if 0
            if (cp->Last != lboff) {
                printf("e!,x%08lx  bad LAST pointer %08lx\n",
                        hoff+((PUCHAR)cp - &(buffer[0])), cp->Last);
            }
#endif

            //
            // advance to next cell
            //
            lboff = boff;
            cp = (PHCELL)((PUCHAR)cp + cellsize);
            boff += cellsize;

            //
            // scan ahead in bin, if cp has reached off end of block,
            // AND there's bin left to read.
            // do this BEFORE breaking out for boff at end.
            //
            while ( (cp >= guard) && (binread < binsize) ) {

                rf = ReadFile(filehandle, buffer, HBLOCK_SIZE, &readcount, NULL);
                if ( ( ! rf ) || (readcount != HBLOCK_SIZE) ) {
                    fprintf(stderr, "hivestat: '%s' read error @%08lx\n", FileName, hiveposition);
                    exit(1);
                }
                cp = (PHCELL)((PUCHAR)cp - HBLOCK_SIZE);
                hiveposition += HBLOCK_SIZE;
                hoff += HBLOCK_SIZE;
                binread += HBLOCK_SIZE;
                ASSERT(hoff+HBLOCK_SIZE == hiveposition);
            }

            if (boff >= binsize) {
                break;              // we are done with this bin
            }
        }
    }

    //
    // Traces are done, stats gathered, print summary
    //
    if (DoSummary) {

        printf("\nSummary:\n");
        printf("type\tcount/max single/total space\n");
        printf("%s\t%7ld\t%7ld\t%7ld\n",
                "bin", StatBinCount, StatBinMax, StatBinTotal);
        printf("%s\t%7ld\t%7ld\t%7ld\n",
                "free", StatFreeCount, StatFreeMax, StatFreeTotal);
        printf("%s\t%7ld\t%7ld\t%7ld\n",
                "alloc", StatAllocCount, StatAllocMax, StatAllocTotal);

    }

    if (DoSummary && DoCellType) {

        printf("\n");

        SizeTotal = SizeKeyData +
                    SizeValueData +
                    SizeSDData +
                    SizeIndexData +
                    SizeUnknownData;

        printf("Total Key Data     %7d (%5.2f %%)\n", SizeKeyData,
            (float)SizeKeyData*100/SizeTotal);
        printf("Total Value Data   %7d (%5.2f %%)\n", SizeValueData,
            (float)SizeValueData*100/SizeTotal);
        printf("Total SD Data      %7d (%5.2f %%)\n", SizeSDData,
            (float)SizeSDData*100/SizeTotal);
        printf("Total Index Data   %7d (%5.2f %%)\n", SizeIndexData,
            (float)SizeIndexData*100/SizeTotal);
        printf("Total Unknown Data %7d (%5.2f %%)\n", SizeUnknownData,
            (float)SizeUnknownData*100/SizeTotal);

        printf("\n");
        printf("Average Key Data     %8.2f (%d cells)\n",
            (float)SizeKeyData/NumKeyData,
            NumKeyData);
        printf("Average Value Data   %8.2f (%d cells)\n",
            (float)SizeValueData/NumValueData,
            NumValueData);
        printf("Average SD Data      %8.2f (%d cells)\n",
            (float)SizeSDData/NumSDData,
            NumSDData);
        printf("Average Index Data   %8.2f (%d cells)\n",
            (float)SizeIndexData/NumIndexData,
            NumIndexData);
        printf("Average Unknown Data %8.2f (%d cells)\n",
            (float)SizeUnknownData/NumUnknownData,
            NumUnknownData);
    }
    return;
}

VOID
ScanCell(
    IN PHCELL Cell,
    IN ULONG CellSize
    )

/*++

Routine Description:

    Given a pointer to an HCELL, this tries to figure out what type
    of data is in it (key, value, SD, etc.) and gather interesting
    statistics about it.

Arguments:

    Cell - Supplies a pointer to the HCELL

    CellSize - Supplies the size of the HCELL

Return Value:

    None, sets some global statistics depending on content of the cell.

--*/

{
    PCELL_DATA Data;

    if (!DoCellType) {
        return;
    }

    if (HiveVersion==1) {
        Data = (PCELL_DATA)&Cell->u.OldCell.u.UserData;
    } else {
        Data = (PCELL_DATA)&Cell->u.NewCell.u.UserData;
    }

    //
    // grovel through the data, see if we can figure out what it looks like
    //
    if ((Data->u.KeyNode.Signature == CM_KEY_NODE_SIGNATURE) &&
        (CellSize > sizeof(CM_KEY_NODE))) {

        //
        // probably a key node
        //
        ScanKeyNode(&Data->u.KeyNode, CellSize);

    } else if ((Data->u.KeyValue.Signature == CM_KEY_VALUE_SIGNATURE) &&
               (CellSize > sizeof(CM_KEY_VALUE))) {

        //
        // probably a key value
        //
        ScanKeyValue(&Data->u.KeyValue, CellSize);

    } else if ((Data->u.KeySecurity.Signature == CM_KEY_SECURITY_SIGNATURE) &&
               (CellSize > sizeof(CM_KEY_SECURITY))) {

        //
        // probably a security descriptor
        //
        ScanKeySD(&Data->u.KeySecurity, CellSize);

    } else if ((Data->u.KeyIndex.Signature == CM_KEY_INDEX_ROOT) ||
               (Data->u.KeyIndex.Signature == CM_KEY_INDEX_LEAF)) {
        //
        // probably a key index
        //
        ScanKeyIndex(&Data->u.KeyIndex, CellSize);

    } else {
        //
        // Nothing with a signature, could be either
        //  name
        //  key list
        //  value data
        //
        ScanUnknown(Data, CellSize);

    }
}

VOID
ScanKeyNode(
    IN PCM_KEY_NODE Node,
    IN ULONG CellSize
    )
{
    int i;

    SizeKeyData += CellSize;
    NumKeyData++;

    if (AccessKeys) {
        printf("%d, %d, %d, %d, \"",
               Node->SubKeyCounts[Stable],
               Node->ValueList.Count,
               Node->NameLength,
               Node->ClassLength);

        for (i=0; i < Node->NameLength/sizeof(WCHAR); i++) {
            printf("%c",(CHAR)Node->Name[i]);
        }
        printf("\"\n");
    }

}
VOID
ScanKeyValue(
    IN PCM_KEY_VALUE Value,
    IN ULONG CellSize
    )
{
    int i;
    int DataLength;

    SizeValueData += CellSize;
    NumValueData++;
    if (AccessValues) {
        DataLength = Value->DataLength;
        if (DataLength >= CM_KEY_VALUE_SPECIAL_SIZE) {
            DataLength -= CM_KEY_VALUE_SPECIAL_SIZE;
        }
        printf("%d, %d, \"",
               DataLength,
               Value->NameLength);

        for (i=0; i < Value->NameLength/sizeof(WCHAR); i++) {
            printf("%c",(CHAR)Value->Name[i]);
        }
        printf("\"\n");
    }

}
VOID
ScanKeySD(
    IN PCM_KEY_SECURITY Security,
    IN ULONG CellSize
    )
{
    SizeSDData += CellSize;
    NumSDData++;

    if (AccessSD) {
        printf("%d,%d\n",
               Security->ReferenceCount,
               Security->DescriptorLength);
    }

}
VOID
ScanKeyIndex(
    IN PCM_KEY_INDEX Index,
    IN ULONG CellSize
    )
{
    SizeIndexData += CellSize;
    NumIndexData++;

}
VOID
ScanUnknown(
    IN PCELL_DATA Data,
    IN ULONG CellSize
    )
{
    SizeUnknownData += CellSize;
    NumUnknownData++;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\regutil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regutil.c

Abstract:

    Utility routines for use by REGINI and REGDMP programs.
Author:

    Steve Wood (stevewo)  10-Mar-92

Revision History:

--*/

#include "regutil.h"

#define RtlAllocateHeap(x,y,z) malloc(z)
#define RtlFreeHeap(x,y,z) free(z)

UNICODE_STRING RiOnKeyword;
UNICODE_STRING RiYesKeyword;
UNICODE_STRING RiTrueKeyword;
UNICODE_STRING RiOffKeyword;
UNICODE_STRING RiNoKeyword;
UNICODE_STRING RiFalseKeyword;
UNICODE_STRING RiDeleteKeyword;
UNICODE_STRING RiRegKeyword;
UNICODE_STRING RiRegNoneKeyword;
UNICODE_STRING RiRegSzKeyword;
UNICODE_STRING RiRegExpandSzKeyword;
UNICODE_STRING RiRegDwordKeyword;
UNICODE_STRING RiRegBinaryKeyword;
UNICODE_STRING RiRegBinaryFileKeyword;
UNICODE_STRING RiRegLinkKeyword;
UNICODE_STRING RiRegMultiSzKeyword;
UNICODE_STRING RiRegMultiSzFileKeyword;
UNICODE_STRING RiRegDateKeyword;

void
RegInitialize( void )
{
    RtlInitUnicodeString( &RiOnKeyword, L"ON" );
    RtlInitUnicodeString( &RiYesKeyword, L"YES" );
    RtlInitUnicodeString( &RiTrueKeyword, L"TRUE" );
    RtlInitUnicodeString( &RiOffKeyword, L"OFF" );
    RtlInitUnicodeString( &RiNoKeyword, L"NO" );
    RtlInitUnicodeString( &RiFalseKeyword, L"FALSE" );
    RtlInitUnicodeString( &RiDeleteKeyword, L"DELETE" );
    RtlInitUnicodeString( &RiRegKeyword, L"REG_" );
    RtlInitUnicodeString( &RiRegNoneKeyword, L"REG_NONE" );
    RtlInitUnicodeString( &RiRegSzKeyword, L"REG_SZ" );
    RtlInitUnicodeString( &RiRegExpandSzKeyword, L"REG_EXPAND_SZ" );
    RtlInitUnicodeString( &RiRegDwordKeyword, L"REG_DWORD" );
    RtlInitUnicodeString( &RiRegBinaryKeyword, L"REG_BINARY" );
    RtlInitUnicodeString( &RiRegBinaryFileKeyword, L"REG_BINARYFILE" );
    RtlInitUnicodeString( &RiRegLinkKeyword, L"REG_LINK" );
    RtlInitUnicodeString( &RiRegMultiSzKeyword, L"REG_MULTI_SZ" );
    RtlInitUnicodeString( &RiRegMultiSzFileKeyword, L"REG_MULTISZFILE" );
    RtlInitUnicodeString( &RiRegDateKeyword, L"REG_DATE" );
}

NTSTATUS
RegReadMultiSzFile(
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    PWSTR s;
    UNICODE_STRING MultiSource;
    UNICODE_STRING MultiValue;
    REG_UNICODE_FILE MultiSzFile;
    ULONG MultiSzFileSize;


    FileName->Buffer[ FileName->Length/sizeof(WCHAR) ] = UNICODE_NULL;

    RtlDosPathNameToNtPathName_U( FileName->Buffer,
                                  &NtFileName,
                                  NULL,
                                  NULL );

    Status = RegLoadAsciiFileAsUnicode( &NtFileName, &MultiSzFile );

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    MultiSzFileSize = (MultiSzFile.EndOfFile -
                       MultiSzFile.NextLine) * sizeof(WCHAR);

    *ValueLength = 0;
    *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                    MultiSzFileSize);

    MultiSource.Buffer = MultiSzFile.NextLine;
    if (MultiSzFileSize <= MAXUSHORT) {
        MultiSource.Length =
        MultiSource.MaximumLength = (USHORT)MultiSzFileSize;
    } else {
        MultiSource.Length =
        MultiSource.MaximumLength = MAXUSHORT;
    }

    while (RegGetMultiString(&MultiSource, &MultiValue)) {
        RtlMoveMemory( (PUCHAR)*ValueBuffer + *ValueLength,
                       MultiValue.Buffer,
                       MultiValue.Length );
        *ValueLength += MultiValue.Length;

        s = MultiSource.Buffer;
        while ( *s != L'"' &&
                *s != L',' &&
                ((s - MultiSource.Buffer) * sizeof(WCHAR)) <
                    MultiSource.Length ) s++;
        if ( ((s - MultiSource.Buffer) * sizeof(WCHAR)) ==
             MultiSource.Length ||
             *s == L',' ||
             *s == L';'   ) {

            ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] =
                UNICODE_NULL;
            *ValueLength += sizeof(UNICODE_NULL);
            if ( *s ==  L';' ) {
                break;
            }
        }

        if ( (MultiSzFile.EndOfFile - MultiSource.Buffer) * sizeof(WCHAR) >=
              MAXUSHORT ) {
            MultiSource.Length =
            MultiSource.MaximumLength = MAXUSHORT;
        } else {
            MultiSource.Length =
            MultiSource.MaximumLength =
                (USHORT)((MultiSzFile.EndOfFile - MultiSource.Buffer) *
                         sizeof(WCHAR));
        }
    }

    ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] = UNICODE_NULL;
    *ValueLength += sizeof(UNICODE_NULL);

    // Virtual memory for reading of MultiSzFile freed at process
    // death?

    return( TRUE );
}

NTSTATUS
RegReadBinaryFile(
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE File;
    FILE_STANDARD_INFORMATION FileInformation;
    WCHAR FileNameBuffer[ 256 ];
    PWSTR s;

    FileName->Buffer[ FileName->Length/sizeof(WCHAR) ] = UNICODE_NULL;
    wcscpy( FileNameBuffer, L"\\DosDevices\\" );
    s = wcscat( FileNameBuffer, FileName->Buffer );
    while (*s != UNICODE_NULL) {
        if (*s == L'/') {
            *s = L'\\';
            }
        s++;
        }
    RtlInitUnicodeString( &NtFileName, FileNameBuffer );

    InitializeObjectAttributes( &ObjectAttributes,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL
                              );

    Status = NtOpenFile( &File,
                         SYNCHRONIZE | GENERIC_READ,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_DELETE |
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = NtQueryInformationFile( File,
                                     &IoStatus,
                                     (PVOID)&FileInformation,
                                     sizeof( FileInformation ),
                                     FileStandardInformation
                                   );
    if (NT_SUCCESS( Status )) {
        if (FileInformation.EndOfFile.HighPart) {
            Status = STATUS_BUFFER_OVERFLOW;
            }
        }
    if (!NT_SUCCESS( Status )) {
        NtClose( File );
        return( Status );
        }

    *ValueLength = FileInformation.EndOfFile.LowPart;
    *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, *ValueLength );
    if (*ValueBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        }

    if (NT_SUCCESS( Status )) {
        Status = NtReadFile( File,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             *ValueBuffer,
                             *ValueLength,
                             NULL,
                             NULL
                           );

        if (NT_SUCCESS( Status )) {
            Status = IoStatus.Status;

            if (NT_SUCCESS( Status )) {
                if (IoStatus.Information != *ValueLength) {
                    Status = STATUS_END_OF_FILE;
                    }
                }
            }

        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, *ValueBuffer );
            }
        }

    NtClose( File );
    return( Status );
}

NTSTATUS
RegLoadAsciiFileAsUnicode(
    IN PUNICODE_STRING FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE File;
    FILE_BASIC_INFORMATION FileDateTimeInfo;
    FILE_STANDARD_INFORMATION FileInformation;
    ULONG BufferSize, i, i1, LineCount;
    PVOID BufferBase;
    PCHAR Src, Src1;
    PWSTR Dst;

    InitializeObjectAttributes( &ObjectAttributes,
                                FileName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL
                              );

    Status = NtOpenFile( &File,
                         SYNCHRONIZE | GENERIC_READ,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_DELETE |
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = NtQueryInformationFile( File,
                                     &IoStatus,
                                     (PVOID)&FileInformation,
                                     sizeof( FileInformation ),
                                     FileStandardInformation
                                   );
    if (NT_SUCCESS( Status )) {
        if (FileInformation.EndOfFile.HighPart) {
            Status = STATUS_BUFFER_OVERFLOW;
            }
        }
    if (!NT_SUCCESS( Status )) {
        NtClose( File );
        return( Status );
        }


    BufferSize = FileInformation.EndOfFile.LowPart * sizeof( WCHAR );
    BufferSize += sizeof( UNICODE_NULL );
    BufferBase = NULL;
    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      (PVOID *)&BufferBase,
                                      0,
                                      &BufferSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if (NT_SUCCESS( Status )) {
        Src = (PCHAR)BufferBase + ((FileInformation.EndOfFile.LowPart+1) & ~1);
        Dst = (PWSTR)BufferBase;
        Status = NtReadFile( File,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             Src,
                             FileInformation.EndOfFile.LowPart,
                             NULL,
                             NULL
                           );

        if (NT_SUCCESS( Status )) {
            Status = IoStatus.Status;

            if (NT_SUCCESS( Status )) {
                if (IoStatus.Information != FileInformation.EndOfFile.LowPart) {
                    Status = STATUS_END_OF_FILE;
                    }
                else {
                    Status = NtQueryInformationFile( File,
                                                     &IoStatus,
                                                     (PVOID)&FileDateTimeInfo,
                                                     sizeof( FileDateTimeInfo ),
                                                     FileBasicInformation
                                                   );
                    }
                }
            }

        if (!NT_SUCCESS( Status )) {
            NtFreeVirtualMemory( NtCurrentProcess(),
                                 (PVOID *)&BufferBase,
                                 &BufferSize,
                                 MEM_RELEASE
                               );
            }
        }

    NtClose( File );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    i = 0;
    while (i < FileInformation.EndOfFile.LowPart) {
        if (i > 1 && (Src[-2] == ' ' || Src[-2] == '\t') &&
            Src[-1] == '\\' && (*Src == '\r' || *Src == '\n')
           ) {
            if (Dst[-1] == L'\\') {
                --Dst;
                }
            while (Dst > (PWSTR)BufferBase) {
                if (Dst[-1] > L' ') {
                    break;
                    }
                Dst--;
                }
            LineCount = 0;
            while (i < FileInformation.EndOfFile.LowPart) {
                if (*Src == '\n') {
                    i++;
                    Src++;
                    LineCount++;
                    }
                else
                if (*Src == '\r' &&
                    (i+1) < FileInformation.EndOfFile.LowPart &&
                    Src[ 1 ] == '\n'
                   ) {
                    i += 2;
                    Src += 2;
                    LineCount++;
                    }
                else {
                    break;
                    }
                }

            if (LineCount > 1) {
                *Dst++ = L'\n';
                }
            else {
                *Dst++ = L' ';
                while (i < FileInformation.EndOfFile.LowPart && (*Src == ' ' || *Src == '\t')) {
                    i++;
                    Src++;
                    }
                }

            if (i >= FileInformation.EndOfFile.LowPart) {
                break;
                }
            }
        else
        if ((*Src == '\r' && Src[1] == '\n') || *Src == '\n') {
            while (TRUE) {
                while (i < FileInformation.EndOfFile.LowPart && (*Src == '\r' || *Src == '\n')) {
                    i++;
                    Src++;
                    }
                Src1 = Src;
                i1 = i;
                while (i1 < FileInformation.EndOfFile.LowPart && (*Src1 == ' ' || *Src1 == '\t')) {
                    i1++;
                    Src1++;
                    }
                if (i1 < FileInformation.EndOfFile.LowPart &&
                    (*Src1 == '\r' && Src1[1] == '\n') || *Src1 == '\n'
                   ) {
                    Src = Src1;
                    i = i1;
                    }
                else {
                    break;
                    }
                }

            *Dst++ = L'\n';
            }
        else {
            i++;
            *Dst++ = RtlAnsiCharToUnicodeChar( &Src );
            }
        }

    if (NT_SUCCESS( Status )) {
        *Dst = UNICODE_NULL;
        UnicodeFile->FileContents = BufferBase;
        UnicodeFile->EndOfFile = Dst;
        UnicodeFile->BeginLine = NULL;
        UnicodeFile->EndOfLine = NULL;
        UnicodeFile->NextLine = BufferBase;
        UnicodeFile->LastWriteTime = FileDateTimeInfo.LastWriteTime;
        }
    else {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             (PVOID *)&BufferBase,
                             &BufferSize,
                             MEM_RELEASE
                           );
        }

    return( Status );
}


BOOLEAN
RegGetNextLine(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PULONG IndentAmount,
    OUT PWSTR *FirstEqual
    )
{
    PWSTR s, s1;

    while (TRUE) {
        if (!(s = UnicodeFile->NextLine)) {
            return( FALSE );
            }

        *IndentAmount = 0;
        while (*s <= L' ') {
            if (*s == L' ') {
                *IndentAmount += 1;
                }
            else
            if (*s == L'\t') {
                *IndentAmount = ((*IndentAmount + 8) -
                                 (*IndentAmount % 8)
                                );
                }

            if (++s >= UnicodeFile->EndOfFile) {
                return( FALSE );
                }
            }

        UnicodeFile->BeginLine = s;

        *FirstEqual = NULL;
        UnicodeFile->NextLine = NULL;
        while (s < UnicodeFile->EndOfFile) {
            if (*s == L'=') {
                if (*FirstEqual == NULL) {
                    *FirstEqual = s;
                    }
                }
            else
            if (*s == L'\n') {
                s1 = s;
                while (s > UnicodeFile->BeginLine && s[ -1 ] <= L' ') {
                    s--;
                    }
                UnicodeFile->EndOfLine = s;
                do {
                    if (++s1 >= UnicodeFile->EndOfFile) {
                        s1 = NULL;
                        break;
                        }
                    }
                while (*s1 == L'\r' || *s1 == L'\n');

                UnicodeFile->NextLine = s1;
                break;
                }

            if (++s == UnicodeFile->EndOfFile) {
                break;
                }
            }

        if (UnicodeFile->EndOfLine > UnicodeFile->BeginLine) {
            if (DebugOutput) {
                fprintf( stderr, "%02u  %.*ws\n",
                         *IndentAmount,
                         UnicodeFile->EndOfLine - UnicodeFile->BeginLine,
                         UnicodeFile->BeginLine
                       );
                }

            return( TRUE );
            }
        }

    return( FALSE );
}


void
RegDumpKeyValue(
    FILE *fh,
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    ULONG IndentLevel
    )
{
    PULONG p;
    PWSTR pw, pw1;
    ULONG i, j, k, m, cbPrefix;
    UNICODE_STRING ValueName;
    PUCHAR pbyte;

    cbPrefix = fprintf( fh, "%.*s",
                        IndentLevel,
                        "                                                                                  "
                      );
    ValueName.Buffer = (PWSTR)&(KeyValueInformation->Name[0]);
    ValueName.Length = (USHORT)KeyValueInformation->NameLength;
    ValueName.MaximumLength = (USHORT)KeyValueInformation->NameLength;

    if (ValueName.Length) {
        cbPrefix += fprintf( fh, "%wZ ", &ValueName );
        }
    cbPrefix += fprintf( fh, "= " );

    if (KeyValueInformation->DataLength == 0) {
        fprintf( fh, " [no data] \n");
        return;
    }

    switch( KeyValueInformation->Type ) {
    case REG_SZ:
    case REG_EXPAND_SZ:

        if (KeyValueInformation->Type == REG_EXPAND_SZ) {
            cbPrefix += fprintf( fh, "REG_EXPAND_SZ " );
        }
        pw = (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        *(PWSTR)((PCHAR)pw + KeyValueInformation->DataLength) = UNICODE_NULL;
        i = 0;
        while (*pw) {
            if ((cbPrefix + wcslen(pw)) > 80) {
                pw1 = pw;
                while (*pw1 && *pw1 > L' ') {
                    pw1++;
                }

                if (*pw1) {
                    *pw1++ = UNICODE_NULL;
                    while (*pw1 && *pw1 <= L' ') {
                        pw1++;
                    }
                }
            } else {
                pw1 = NULL;
            }
            if (i > 0) {
                fprintf( fh, " \\\n%.*s",
                         cbPrefix,
                         "                                                                                  "
                       );
            }

            fprintf( fh, "%ws", pw );
            if (!pw1) {
                break;
                }
            i++;
            pw = pw1;
        }
        break;

    case REG_BINARY:
        fprintf( fh, "REG_BINARY 0x%08lx", KeyValueInformation->DataLength );
        p = (PULONG)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        i = (KeyValueInformation->DataLength + 3) / sizeof( ULONG );
        if (!SummaryOutput || i <= 8) {
            for (j=0; j<i; j++) {
                if ((j % 8) == 0) {
                    fprintf( fh, "\n%.*s",
                             IndentLevel+4,
                             "                                                                                  "
                           );
                    }

                fprintf( fh, "0x%08lx  ", *p++ );
                }
            }
        else {
            fprintf( fh, " *** value display suppressed ***" );
            }
        fprintf( fh, "\n" );
        break;

//  case REG_DWORD_LITTLE_ENDIAN:
    case REG_DWORD:
        fprintf( fh, "REG_DWORD 0x%08lx",
                 *((PULONG)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset))
               );
        break;

    case REG_DWORD_BIG_ENDIAN:
        fprintf( fh, "REG_DWORD_BIG_ENDIAN 0x%08lx",
                 *((PULONG)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset))
               );
        break;

    case REG_LINK:
        fprintf( fh, "REG_LINK %ws",
                 ((PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset))
               );
        break;

    case REG_MULTI_SZ:
        cbPrefix += fprintf( fh, "REG_MULTI_SZ " );
        pw = (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        i  = 0;
        if (*pw)
        while (i < ((KeyValueInformation->DataLength-1) / sizeof(WCHAR))) {
            if (i > 0) {
                fprintf( fh, " \\\n%.*s",
                         cbPrefix,
                         "                                                                                  "
                       );
            }
            fprintf(fh, "\"%ws\" ",pw+i);
            do {
                ++i;
            } while ( pw[i] != UNICODE_NULL );
            ++i;
        }
        break;

    case REG_RESOURCE_LIST:
    case REG_FULL_RESOURCE_DESCRIPTOR:
        {
        PCM_RESOURCE_LIST ResourceList = ((PCM_RESOURCE_LIST)((PCHAR)KeyValueInformation +
                                          KeyValueInformation->DataOffset));
        PCM_FULL_RESOURCE_DESCRIPTOR FullDescriptor;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
        ULONG k, l, count;
        PWSTR TypeName;
        PWSTR FlagName;
        ULONG Size = KeyValueInformation->DataLength;

        if (KeyValueInformation->Type == REG_RESOURCE_LIST) {

            fprintf( fh, "   REG_RESOURCE_LIST\n");

            fprintf( fh, "%.*sNumber of Full resource Descriptors = %d",
                     IndentLevel,
                     "                                                                                  ",
                     ResourceList->Count
                   );

             count = ResourceList->Count;
             FullDescriptor = &ResourceList->List[0];

        } else {

            fprintf( fh, "   REG_FULL_RESOURCE_DESCRIPTOR\n");
            count = 1;
            FullDescriptor = ((PCM_FULL_RESOURCE_DESCRIPTOR)
                ((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset));

        }

        for (i=0; i< count; i++) {

            fprintf( fh, "\n%.*sPartial List number %d\n",
                     IndentLevel+4,
                     "                                                                                  ",
                     i
                   );

            switch(FullDescriptor->InterfaceType) {

            case Internal:      TypeName = L"Internal";         break;
            case Isa:           TypeName = L"Isa";              break;
            case Eisa:          TypeName = L"Eisa";             break;
            case MicroChannel:  TypeName = L"MicroChannel";     break;
            case TurboChannel:  TypeName = L"TurboChannel";     break;
            case PCIBus:        TypeName = L"PCI";              break;
            case VMEBus:        TypeName = L"VME";              break;
            case NuBus:         TypeName = L"NuBus";            break;
            case PCMCIABus:     TypeName = L"PCMCIA";           break;
            case CBus:          TypeName = L"CBUS";             break;
            case MPIBus:        TypeName = L"MPI";              break;

            default:
                TypeName = L"***invalid bus type***";
                break;
            }

            fprintf( fh, "%.*sINTERFACE_TYPE %ws\n",
                     IndentLevel+8,
                     "                                                                                  ",
                     TypeName
                   );

            fprintf( fh, "%.*sBUS_NUMBER  %d\n",
                     IndentLevel+8,
                     "                                                                                  ",
                     FullDescriptor->BusNumber
                   );

            //
            // This is a basic test to see if the data format is right.
            // We know at least some video resource list are bogus ...
            //

            if (Size < FullDescriptor->PartialResourceList.Count *
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) ) {

                fprintf( fh, "\n%.*s *** !!! Invalid ResourceList !!! *** \n",
                         IndentLevel+8,
                         "                                                                                  ",
                         i
                       );

                break;
            }

            Size -= FullDescriptor->PartialResourceList.Count *
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);



            for (j=0; j<FullDescriptor->PartialResourceList.Count; j++) {

                fprintf( fh, "%.*sDescriptor number %d\n",
                         IndentLevel+12,
                         "                                                                                  ",
                         j
                       );

                PartialResourceDescriptor =
            &(FullDescriptor->PartialResourceList.PartialDescriptors[j]);

                switch(PartialResourceDescriptor->ShareDisposition) {

                case CmResourceShareUndetermined:
                    TypeName = L"CmResourceShareUndetermined";
                    break;
                case CmResourceShareDeviceExclusive:
                    TypeName = L"CmResourceDeviceExclusive";
                    break;
                case CmResourceShareDriverExclusive:
                    TypeName = L"CmResourceDriverExclusive";
                    break;
                case CmResourceShareShared:
                    TypeName = L"CmResourceShared";
                    break;
                default:
                    TypeName = L"***invalid share disposition***";
                    break;
                }

                fprintf( fh, "%.*sShare Disposition %ws\n",
                         IndentLevel+12,
                         "                                                                                  ",
                         TypeName
                       );

                FlagName = L"***invalid Flags";

                switch(PartialResourceDescriptor->Type) {

                case CmResourceTypeNull:
                    TypeName = L"NULL";
                    FlagName = L"***Unused";
                    break;
                case CmResourceTypePort:
                    TypeName = L"PORT";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_PORT_MEMORY) {
                        FlagName = L"CM_RESOURCE_PORT_MEMORY";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_PORT_IO) {
                        FlagName = L"CM_RESOURCE_PORT_IO";
                    }
                    break;
                case CmResourceTypeInterrupt:
                    TypeName = L"INTERRUPT";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                        FlagName = L"CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                        FlagName = L"CM_RESOURCE_INTERRUPT_LATCHED";
                    }
                    break;
                case CmResourceTypeMemory:
                    TypeName = L"MEMORY";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_WRITE) {
                        FlagName = L"CM_RESOURCE_MEMORY_READ_WRITE";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_ONLY) {
                        FlagName = L"CM_RESOURCE_MEMORY_READ_ONLY";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_WRITE_ONLY) {
                        FlagName = L"CM_RESOURCE_MEMORY_WRITE_ONLY";
                    }
                    break;
                case CmResourceTypeDma:
                    TypeName = L"DMA";
                    FlagName = L"***Unused";
                    break;
                case CmResourceTypeDeviceSpecific:
                    TypeName = L"DEVICE SPECIFIC";
                    FlagName = L"***Unused";
                    break;
                default:
                    TypeName = L"***invalid type***";
                    break;
                }

                fprintf( fh, "%.*sTYPE              %ws\n",
                         IndentLevel+12,
                         "                                                                                  ",
                         TypeName
                       );

                fprintf( fh, "%.*sFlags             %ws\n",
                         IndentLevel+12,
                         "                                                                                  ",
                         FlagName
                       );

                switch(PartialResourceDescriptor->Type) {

                case CmResourceTypePort:
                    fprintf( fh, "%.*sSTART 0x%08lx  LENGTH 0x%08lx\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.Port.Start.LowPart,
                             PartialResourceDescriptor->u.Port.Length
                           );
                    break;

                case CmResourceTypeInterrupt:
                    fprintf( fh, "%.*sLEVEL %d  VECTOR %d  AFFINITY %d\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.Interrupt.Level,
                             PartialResourceDescriptor->u.Interrupt.Vector,
                             PartialResourceDescriptor->u.Interrupt.Affinity
                           );
                    break;

                case CmResourceTypeMemory:
                    fprintf( fh, "%.*sSTART 0x%08lx%08lx  LENGTH 0x%08lx\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.Memory.Start.HighPart,
                             PartialResourceDescriptor->u.Memory.Start.LowPart,
                             PartialResourceDescriptor->u.Memory.Length
                           );
                    break;

                case CmResourceTypeDma:
                    fprintf( fh, "%.*sCHANNEL %d  PORT %d\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.Dma.Channel,
                             PartialResourceDescriptor->u.Dma.Port
                           );
                    break;

                case CmResourceTypeDeviceSpecific:
                    fprintf( fh, "%.*sDataSize 0x%08lx\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->u.DeviceSpecificData.DataSize
                           );

                    p = (PULONG)(PartialResourceDescriptor + 1);
                    k = (PartialResourceDescriptor->u.DeviceSpecificData.DataSize + 3) / sizeof( ULONG );
                    for (l=0; l<k; l++) {
                        if ((l % 8) == 0) {
                            fprintf( fh, "\n%.*s",
                                IndentLevel+12,
                                "                                                                                  "
                               );
                        }

                        fprintf( fh, "0x%08lx  ", *p++ );
                    }
                    fprintf( fh, "\n" );
                    break;

                default:
                    fprintf( fh, "%.*s*** Unknown resource list type: %c ****\n",
                             IndentLevel+12,
                             "                                                                                  ",
                             PartialResourceDescriptor->Type
                           );
                    break;
                }

                fprintf( fh, "\n" );
            }

            FullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) (PartialResourceDescriptor+1);
        }

        break;
        }

    case REG_NONE:
    default:
        if (KeyValueInformation->Type == REG_NONE) {
            fprintf( fh, "REG_NONE\n");
            }
        else {
            fprintf( fh, "*** Unknown registry type (%08lx)",
                     KeyValueInformation->Type
                   );
            }
        fprintf( fh, "%.*s",
             IndentLevel,
             "                                                                                  "
             );
        fprintf( fh, "    Length: 0x%lx\n", KeyValueInformation->DataLength );
                fprintf( fh, "\n%.*s",
                    IndentLevel,
                    "                                                                                  "
                    );
        fprintf( fh, "      Data: ");
        pbyte = ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        for ( k=0, m=1; k<KeyValueInformation->DataLength; k++,m++) {
            fprintf( fh, "%02x ", (*pbyte) );
            pbyte++;

            if (m==8) {
                fprintf( fh, "\n%.*s",
                    IndentLevel+12,
                    "                                                                                  "
                    );
                m=0;
            }
        }
        break;
    }

    fprintf( fh, "\n" );
    return;
}

//
//  Define an upcase macro for temporary use by the upcase routines
//

#define upcase(C) (WCHAR )(((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C)))

BOOLEAN
RegGetMultiString(
    IN OUT PUNICODE_STRING ValueString,
    OUT PUNICODE_STRING MultiString
    )

/*++

Routine Description:

    This routine parses multi-strings of the form

        "foo" "bar" "bletch"

    Each time it is called, it strips the first string in quotes from
    the input string, and returns it as the multi-string.

    INPUT ValueString: "foo" "bar" "bletch"

    OUTPUT ValueString: "bar" "bletch"
           MultiString: foo

Arguments:

    ValueString - Supplies the string from which the multi-string will be
                  parsed
                - Returns the remaining string after the multi-string is
                  removed

    MultiString - Returns the multi-string removed from ValueString

Return Value:

    TRUE - multi-string found and removed.

    FALSE - no more multi-strings remaining.

--*/

{
    //
    // Find the first quote mark.
    //
    while ((*(ValueString->Buffer) != L'"') &&
           (ValueString->Length > 0)) {
        ++ValueString->Buffer;
        ValueString->Length -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        return(FALSE);
    }

    //
    // We have found the start of the multi-string.  Now find the end,
    // building up our return MultiString as we go.
    //
    ++ValueString->Buffer;
    ValueString->Length -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);
    MultiString->Buffer = ValueString->Buffer;
    MultiString->Length = 0;
    MultiString->MaximumLength = 0;
    while ((*(ValueString->Buffer) != L'"') &&
           (ValueString->Length > 0)) {
        ++ValueString->Buffer;
        ValueString->Length -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);

        MultiString->Length += sizeof(WCHAR);
        MultiString->MaximumLength += sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        return(FALSE);
    }

    ++ValueString->Buffer;
    ValueString->Length -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);

    return( TRUE );

}


BOOLEAN
RegGetKeyValue(
    IN PUNICODE_STRING InitialKeyValue,
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PULONG ValueType,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    )
{
    ULONG PrefixLength;
    PWSTR s;
    PULONG p;
    ULONG n;
    NTSTATUS Status;
    ULONG IndentAmount;
    PWSTR FirstEqual;
    UNICODE_STRING KeyValue;
    UNICODE_STRING MultiValue;
    BOOLEAN GetDataFromBinaryFile = FALSE;
    BOOLEAN GetDataFromMultiSzFile = FALSE;
    BOOLEAN ParseDateTime = FALSE;

    KeyValue = *InitialKeyValue;
    if (RtlPrefixUnicodeString( &RiDeleteKeyword, &KeyValue, TRUE )) {
        *ValueBuffer = NULL;
        return( TRUE );
        }
    else
    if (!RtlPrefixUnicodeString( &RiRegKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_SZ;
        PrefixLength = 0;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegNoneKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_NONE;
        PrefixLength = RiRegNoneKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegSzKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_SZ;
        PrefixLength = RiRegSzKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegExpandSzKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_EXPAND_SZ;
        PrefixLength = RiRegExpandSzKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegDwordKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_DWORD;
        PrefixLength = RiRegDwordKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegBinaryFileKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_BINARY;
        PrefixLength = RiRegBinaryFileKeyword.Length;
        GetDataFromBinaryFile = TRUE;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegBinaryKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_BINARY;
        PrefixLength = RiRegBinaryKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegLinkKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_LINK;
        PrefixLength = RiRegLinkKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegMultiSzFileKeyword, &KeyValue, TRUE)) {
        *ValueType = REG_MULTI_SZ;
        PrefixLength = RiRegMultiSzFileKeyword.Length;
        GetDataFromMultiSzFile = TRUE;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegMultiSzKeyword, &KeyValue, TRUE)) {
        *ValueType = REG_MULTI_SZ;
        PrefixLength = RiRegMultiSzKeyword.Length;
        }
    else
    if (RtlPrefixUnicodeString( &RiRegDateKeyword, &KeyValue, TRUE )) {
        *ValueType = REG_BINARY;
        ParseDateTime = TRUE;
        PrefixLength = RiRegDateKeyword.Length;
        }
    else {
        return( FALSE );
        }

    if (*ValueType != REG_NONE) {
        s = (PWSTR)
            ((PCHAR)KeyValue.Buffer + PrefixLength);
        KeyValue.Length -= (USHORT)PrefixLength;
        while (KeyValue.Length != 0 && *s <= L' ') {
            s++;
            KeyValue.Length -= sizeof( WCHAR );
            }
        KeyValue.Buffer = s;
        }
    else {
        *ValueType = REG_SZ;
        }


    if (GetDataFromBinaryFile) {
        Status = RegReadBinaryFile( &KeyValue, ValueBuffer, ValueLength );
        if (NT_SUCCESS( Status )) {
            return( TRUE );
            }
        else {
            fprintf( stderr, "REGINI: Unable to read data from %wZ - Status == %lx\n", &KeyValue, Status );
            return( FALSE );
            }
        }

    if (GetDataFromMultiSzFile) {
        Status = RegReadMultiSzFile( &KeyValue, ValueBuffer, ValueLength );
        if (NT_SUCCESS( Status )) {
            return( TRUE );
            }
        else {
            fprintf( stderr, "REGINI: Unable to read data from %wZ - Status == %lx\n", &KeyValue, Status );
            return( FALSE );
            }
        }

    switch( *ValueType ) {
    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_LINK:
        *ValueLength = KeyValue.Length + sizeof( UNICODE_NULL );
        *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, *ValueLength );
        if (*ValueBuffer == NULL) {
            return( FALSE );
            }

        RtlMoveMemory( *ValueBuffer, KeyValue.Buffer, KeyValue.Length );
        ((PWSTR)*ValueBuffer)[ KeyValue.Length / sizeof( WCHAR ) ] = UNICODE_NULL;
        return( TRUE );

    case REG_DWORD:
        *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( ULONG ) );
        if (*ValueBuffer == NULL) {
            return( FALSE );
            }

        if (RtlPrefixUnicodeString( &RiTrueKeyword, &KeyValue, TRUE ) ||
            RtlPrefixUnicodeString( &RiYesKeyword, &KeyValue, TRUE ) ||
            RtlPrefixUnicodeString( &RiOnKeyword, &KeyValue, TRUE )
           ) {
            *(PULONG)*ValueBuffer = (ULONG)TRUE;
            }
        else
        if (RtlPrefixUnicodeString( &RiFalseKeyword, &KeyValue, TRUE ) ||
            RtlPrefixUnicodeString( &RiNoKeyword, &KeyValue, TRUE ) ||
            RtlPrefixUnicodeString( &RiOffKeyword, &KeyValue, TRUE )
           ) {
            *(PULONG)*ValueBuffer = (ULONG)FALSE;
            }
        else {
            Status = RtlUnicodeStringToInteger( &KeyValue, 0, (PULONG)*ValueBuffer );
            if (!NT_SUCCESS( Status )) {
                fprintf( stderr, "REGINI: CharToInteger( %wZ ) failed - Status == %lx\n", &KeyValue, Status );
                RtlFreeHeap( RtlProcessHeap(), 0, *ValueBuffer );
                return( FALSE );
                }
            }

        *ValueLength = sizeof( ULONG );
        return( TRUE );

    case REG_BINARY:
        if (ParseDateTime) {
#define NUMBER_DATE_TIME_FIELDS 6
            ULONG FieldIndexes[ NUMBER_DATE_TIME_FIELDS  ] = {1, 2, 0, 3, 4, 7};
            //
            // Month/Day/Year HH:MM DayOfWeek
            //

            ULONG CurrentField = 0;
            PCSHORT Fields;
            TIME_FIELDS DateTimeFields;
            UNICODE_STRING Field;
            ULONG FieldValue;

            RtlZeroMemory( &DateTimeFields, sizeof( DateTimeFields ) );
            Fields = &DateTimeFields.Year;
            while (KeyValue.Length) {
                if (CurrentField >= 7) {
                    return( FALSE );
                    }

                s = KeyValue.Buffer;
                while (KeyValue.Length && *s == L' ') {
                    KeyValue.Length--;
                    s++;
                    }

                Field.Buffer = s;
                while (KeyValue.Length) {
                    if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                        }
                    else
                    if (*s < L'0' || *s > L'9') {
                        break;
                        }

                    KeyValue.Length--;
                    s++;
                    }

                Field.Length = (USHORT)((PCHAR)s - (PCHAR)Field.Buffer);
                Field.MaximumLength = Field.Length;

                if (KeyValue.Length) {
                    KeyValue.Length--;
                    s++;
                    }
                KeyValue.Buffer = s;

                if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                    if (Field.Length < 3) {
                        printf( "REGINI: %wZ invalid day of week length\n", &Field );
                        return FALSE;
                        }

                    if (DateTimeFields.Year != 0) {
                        printf( "REGINI: Year must be zero to specify day of week\n" );
                        return FALSE;
                        }

                    if (!_wcsnicmp( Field.Buffer, L"SUN", 3 )) {
                        FieldValue = 0;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"MON", 3 )) {
                        FieldValue = 1;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"TUE", 3 )) {
                        FieldValue = 2;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"WED", 3 )) {
                        FieldValue = 3;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"THU", 3 )) {
                        FieldValue = 4;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"FRI", 3 )) {
                        FieldValue = 5;
                        }
                    else
                    if (!_wcsnicmp( Field.Buffer, L"SAT", 3 )) {
                        FieldValue = 6;
                        }
                    else {
                        printf( "REGINI: %wZ invalid day of week\n", &Field );
                        return FALSE;
                        }
                    }
                else {
                    Status = RtlUnicodeStringToInteger( &Field, 10, &FieldValue );
                    if (!NT_SUCCESS( Status )) {
                        return( FALSE );
                        }
                    }

                Fields[ FieldIndexes[ CurrentField++ ] ] = (CSHORT)FieldValue;
                }

            if (DateTimeFields.Year == 0) {
                if (DateTimeFields.Day > 5) {
                    printf( "REGINI: Day must be 0 - 5 if year is zero.\n" );
                    return FALSE;
                    }
                }
            else
            if (DateTimeFields.Year < 100) {
                DateTimeFields.Year += 1900;
                }

            *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( DateTimeFields ) );
            *ValueLength = sizeof( DateTimeFields );
            RtlMoveMemory( *ValueBuffer, &DateTimeFields, sizeof( DateTimeFields ) );
            return TRUE;
            }
        else {
            Status = RtlUnicodeStringToInteger( &KeyValue, 0, ValueLength );
            if (!NT_SUCCESS( Status )) {
                return( FALSE );
                }
            s = KeyValue.Buffer;
            while (KeyValue.Length != 0 && *s > L' ') {
                s++;
                KeyValue.Length -= sizeof( WCHAR );
                }
            KeyValue.Buffer = s;
            }
        break;

    case REG_MULTI_SZ:
        *ValueLength = 0;
        *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, KeyValue.Length + sizeof( UNICODE_NULL ) );
        while (RegGetMultiString(&KeyValue, &MultiValue)) {
            RtlMoveMemory( (PUCHAR)*ValueBuffer + *ValueLength,
                           MultiValue.Buffer,
                           MultiValue.Length );
            *ValueLength += MultiValue.Length;
            ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] = UNICODE_NULL;
            *ValueLength += sizeof(UNICODE_NULL);
        }
        ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] = UNICODE_NULL;
        *ValueLength += sizeof(UNICODE_NULL);

        return( TRUE );

    default:
        return( FALSE );
    }

    *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, *ValueLength );
    p = *ValueBuffer;
    n = (*ValueLength + sizeof( ULONG ) - 1) / sizeof( ULONG );
    while (n--) {
        if (KeyValue.Length == 0) {
            if (!RegGetNextLine( UnicodeFile, &IndentAmount, &FirstEqual )) {
                RtlFreeHeap( RtlProcessHeap(), 0, *ValueBuffer );
                return( FALSE );
                }
            KeyValue.Buffer = UnicodeFile->BeginLine;
            KeyValue.Length = (USHORT)
                ((PCHAR)UnicodeFile->EndOfLine - (PCHAR)UnicodeFile->BeginLine);
            KeyValue.MaximumLength = KeyValue.Length;
            }

        s = KeyValue.Buffer;
        while (KeyValue.Length != 0 && *s <= L' ') {
            s++;
            KeyValue.Length -= sizeof( WCHAR );
            }
        KeyValue.Buffer = s;
        if (KeyValue.Length != 0) {
            Status = RtlUnicodeStringToInteger( &KeyValue, 0, p );
            if (!NT_SUCCESS( Status )) {
                RtlFreeHeap( RtlProcessHeap(), 0, *ValueBuffer );
                return( FALSE );
                }
            p++;

            s = KeyValue.Buffer;
            while (KeyValue.Length != 0 && *s > L' ') {
                s++;
                KeyValue.Length -= sizeof( WCHAR );
                }
            KeyValue.Buffer = s;
            }
        }

    return( TRUE );
}

BOOLEAN
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixUnicodeString function determines if the String1
    counted string parameter is a prefix of the String2 counted string
    parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first unicode string.

    String2 - Pointer to the second unicode string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PWSTR s1, s2;
    ULONG n;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    if (String2->Length < String1->Length) {
        return( FALSE );
        }

    n = String1->Length / sizeof( c1 );
    while (n) {
        c1 = *s1++;
        c2 = *s2++;

        if (CaseInSensitive) {
            c1 = upcase(c1);
            c2 = upcase(c2);
        }
        if (c1 != c2) {
            return( FALSE );
            }

        n--;
        }

    return( TRUE );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\hiveini.c ===
#include "regutil.h"
#include "edithive.h"

NTSTATUS
RiInitializeRegistryFromAsciiFile(
    IN PUNICODE_STRING HiveName,
    IN PUNICODE_STRING FileName
    );

void
Usage( void )
{
    fprintf( stderr, "usage: HIVEINI -f hivefile [files...]\n" );
    exit( 1 );
}

PVOID OldValueBuffer;
ULONG OldValueBufferSize;

typedef struct _KEY_INFO {
    ULONG IndentAmount;
    UNICODE_STRING Name;
    HANDLE HiveHandle;
    HANDLE Handle;
    LARGE_INTEGER LastWriteTime;
} KEY_INFO, *PKEY_INFO;

#define MAX_KEY_DEPTH 64

NTSTATUS
RiInitializeRegistryFromAsciiFile(
    IN PUNICODE_STRING HiveName,
    IN PUNICODE_STRING FileName
    )
{
    NTSTATUS Status;
    REG_UNICODE_FILE UnicodeFile;
    PWSTR EndKey, FirstEqual, BeginValue;
    ULONG IndentAmount;
    UNICODE_STRING InputLine;
    UNICODE_STRING KeyName;
    UNICODE_STRING KeyValue;
    PKEY_VALUE_FULL_INFORMATION OldValueInformation;
    PKEY_BASIC_INFORMATION KeyInformation;
    UCHAR KeyInformationBuffer[ 512 ];
    ULONG ResultLength;
    ULONG OldValueLength;
    PVOID ValueBuffer;
    ULONG ValueLength;
    ULONG ValueType;
    KEY_INFO KeyPath[ MAX_KEY_DEPTH ];
    PKEY_INFO CurrentKey;
    ULONG KeyPathLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING Class;
    ULONG Disposition;
    BOOLEAN UpdateKeyValue;
    ULONG i;
    HANDLE HiveHandle;
    HANDLE RootKey;
    UNICODE_STRING RootName;

    HiveHandle = EhOpenHive(HiveName,
                            &KeyPath[0].Handle,
                            &KeyPath[0].Name,
                            TYPE_SIMPLE);
    if (HiveHandle == NULL) {
        return(STATUS_OBJECT_PATH_NOT_FOUND);
    }
    KeyPath[0].Handle = (HANDLE)HCELL_NIL;

    OldValueInformation = (PKEY_VALUE_FULL_INFORMATION)OldValueBuffer;
    Class.Buffer = NULL;
    Class.Length = 0;

    Status = RegLoadAsciiFileAsUnicode( FileName,
                                        &UnicodeFile
                                      );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    KeyPathLength = 0;
    while (RegGetNextLine( &UnicodeFile, &IndentAmount, &FirstEqual )) {
#if 0
        InputLine.Buffer = UnicodeFile.BeginLine;
        InputLine.Length = (USHORT)((PCHAR)UnicodeFile.EndOfLine - (PCHAR)UnicodeFile.BeginLine);
        InputLine.MaximumLength = InputLine.Length;
        printf( "GetNextLine: (%02u) '%wZ'\n", IndentAmount, &InputLine );
#endif
        if (FirstEqual == NULL) {
            KeyName.Buffer = UnicodeFile.BeginLine;
            KeyName.Length = (USHORT)((PCHAR)UnicodeFile.EndOfLine - (PCHAR)KeyName.Buffer);
            KeyName.MaximumLength = (USHORT)(KeyName.Length + 1);

#if 0
            printf( "%02u %04u  KeyName: %wZ\n", KeyPathLength, IndentAmount, &KeyName );
#endif
            CurrentKey = &KeyPath[ KeyPathLength ];
            if (KeyPathLength == 0 ||
                IndentAmount > CurrentKey->IndentAmount
               ) {
                if (KeyPathLength == MAX_KEY_DEPTH) {
                    fprintf( stderr,
                             "HIVEINI: %wZ key exceeded maximum depth (%u) of tree.\n",
                             &KeyName,
                             MAX_KEY_DEPTH
                           );

                    return( STATUS_UNSUCCESSFUL );
                    }
                KeyPathLength++;
                CurrentKey++;
                }
            else {
                do {
                    CurrentKey->Handle = NULL;
                    if (IndentAmount == CurrentKey->IndentAmount) {
                        break;
                        }
                    CurrentKey--;
                    if (--KeyPathLength == 1) {
                        break;
                        }
                    }
                while (IndentAmount <= CurrentKey->IndentAmount);
                }

#if 0
            printf( "  (%02u)\n", KeyPathLength );
#endif
            CurrentKey->Name = KeyName;
            CurrentKey->IndentAmount = IndentAmount;
            Status = EhCreateChild(HiveHandle,
                                   KeyPath[ KeyPathLength-1 ].Handle,
                                   &KeyName,
                                   &CurrentKey->Handle,
                                   &Disposition);

            if (NT_SUCCESS( Status )) {
                if (DebugOutput) {
                    fprintf( stderr, "    Created key %02x %wZ (%08x)\n",
                                     CurrentKey->IndentAmount,
                                     &CurrentKey->Name,
                                     CurrentKey->Handle
                           );
                    }
                KeyInformation = (PKEY_BASIC_INFORMATION)KeyInformationBuffer;
                Status = EhQueryKey( HiveHandle,
                                     CurrentKey->Handle,
                                     KeyBasicInformation,
                                     KeyInformation,
                                     sizeof( KeyInformationBuffer ),
                                     &ResultLength
                                   );
                if (NT_SUCCESS( Status )) {
                    CurrentKey->LastWriteTime = KeyInformation->LastWriteTime;
                    }
                else {
                    RtlZeroMemory( &CurrentKey->LastWriteTime,
                                   sizeof( CurrentKey->LastWriteTime )
                                 );

                    }

                if (Disposition == REG_CREATED_NEW_KEY) {
                    printf( "Created Key: " );
                    for (i=0; i<KeyPathLength; i++) {
                        printf( "%wZ\\", &KeyPath[ i ].Name );
                        }
                    printf( "%wZ\n", &KeyName );
                    }
                }
            else {
                fprintf( stderr,
                         "HIVEINI: CreateKey (%wZ) relative to handle (%lx) failed - %lx\n",
                         &KeyName,
                         ObjectAttributes.RootDirectory,
                         Status
                       );
                }
            }
        else {
            if (FirstEqual == UnicodeFile.BeginLine) {
                KeyName.Buffer = NULL;
                KeyName.Length = 0;
                KeyName.MaximumLength = 0;
                }
            else {
                EndKey = FirstEqual;
                while (EndKey > UnicodeFile.BeginLine && EndKey[ -1 ] <= L' ') {
                    EndKey--;
                    }
                KeyName.Buffer = UnicodeFile.BeginLine;
                KeyName.Length = (USHORT)((PCHAR)EndKey - (PCHAR)KeyName.Buffer);
                KeyName.MaximumLength = (USHORT)(KeyName.Length + 1);
                }

            BeginValue = FirstEqual + 1;
            while (BeginValue < UnicodeFile.EndOfLine && *BeginValue <= L' ') {
                BeginValue++;
                }
            KeyValue.Buffer = BeginValue;
            KeyValue.Length = (USHORT)((PCHAR)UnicodeFile.EndOfLine - (PCHAR)BeginValue);
            KeyValue.MaximumLength = (USHORT)(KeyValue.Length + 1);

            while (IndentAmount <= CurrentKey->IndentAmount) {
                if (DebugOutput) {
                    fprintf( stderr, "    Popping from key %02x %wZ (%08x)\n",
                                     CurrentKey->IndentAmount,
                                     &CurrentKey->Name,
                                     CurrentKey->Handle
                           );
                    }
                CurrentKey->Handle = NULL;
                CurrentKey--;
                if (--KeyPathLength == 1) {
                    break;
                    }
                }
            if (DebugOutput) {
                fprintf( stderr, "    Adding value '%wZ = %wZ' to key %02x %wZ (%08x)\n",
                                 &KeyName,
                                 &KeyValue,
                                 CurrentKey->IndentAmount,
                                 &CurrentKey->Name,
                                 CurrentKey->Handle
                       );
                }

            if (RegGetKeyValue( &KeyValue,
                                &UnicodeFile,
                                &ValueType,
                                &ValueBuffer,
                                &ValueLength
                              )
               ) {
                if (ValueBuffer == NULL) {
                    Status = EhDeleteValueKey( HiveHandle,
                                               KeyPath[ KeyPathLength+1 ].Handle,
                                               &KeyValue
                                             );
                    if (NT_SUCCESS( Status )) {
                        printf( "Delete value for Key: " );
                        for (i=0; i<KeyPathLength; i++) {
                            printf( "%wZ\\", &KeyPath[ i ].Name );
                            }
                        printf( "%wZ\n", &KeyName );
                        }
                    }
                else {
                    if ( UnicodeFile.LastWriteTime.QuadPart >
                         CurrentKey->LastWriteTime.QuadPart
                       ) {
                        Status = STATUS_UNSUCCESSFUL;
                        UpdateKeyValue = TRUE;
                        }
                    else {
                        Status = EhQueryValueKey( HiveHandle,
                                                  CurrentKey->Handle,
                                                  &KeyName,
                                                  KeyValueFullInformation,
                                                  OldValueInformation,
                                                  OldValueBufferSize,
                                                  &OldValueLength
                                                );
                        if (NT_SUCCESS( Status )) {
                            UpdateKeyValue = TRUE;
                            }
                        else {
                            UpdateKeyValue = FALSE;
                            }
                        }

                    if (!NT_SUCCESS( Status ) ||
                        OldValueInformation->Type != ValueType ||
                        OldValueInformation->DataLength != ValueLength ||
                        !RtlEqualMemory( (PCHAR)OldValueInformation +
                                            OldValueInformation->DataOffset,
                                          ValueBuffer,
                                          ValueLength )
                       ) {

                        Status = EhSetValueKey( HiveHandle,
                                                CurrentKey->Handle,
                                                &KeyName,
                                                0,
                                                ValueType,
                                                ValueBuffer,
                                                ValueLength
                                              );
                        if (NT_SUCCESS( Status )) {
                            printf( "%s value for Key: ",
                                    UpdateKeyValue ? "Updated" : "Created"
                                  );
                            for (i=1; i<=KeyPathLength; i++) {
                                printf( "%wZ\\", &KeyPath[ i ].Name );
                                }

                            if (KeyName.Length) {
                                printf( "%wZ ", &KeyName );
                                }
                            printf( "= '%wZ'\n", &KeyValue );
                            }
                        else {
                            fprintf( stderr,
                                     "HIVEINI: SetValueKey (%wZ) failed - %lx\n",
                                     &KeyName,
                                     Status
                                   );
                            }
                        }

                    RtlFreeHeap( RtlProcessHeap(), 0, ValueBuffer );
                    }
                }
            else {
                fprintf( stderr,
                         "HIVEINI: Invalid key (%wZ) value (%wZ)\n", &KeyName,
                         &KeyValue
                       );
                }
            }
        }

        EhCloseHive(HiveHandle);

    return( Status );
}


int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int i;
    char *s;
    NTSTATUS Status;
    BOOL FileArgumentSeen;
    BOOL HiveArgumentSeen=FALSE;
    ANSI_STRING AnsiString;
    UNICODE_STRING DosFileName;
    UNICODE_STRING FileName;
    UNICODE_STRING DosHiveName;
    UNICODE_STRING HiveName;

    OldValueBufferSize = VALUE_BUFFER_SIZE;
    OldValueBuffer = VirtualAlloc( NULL, OldValueBufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (OldValueBuffer == NULL) {
        fprintf( stderr, "HIVEINI: Unable to allocate value buffer.\n" );
        exit( 1 );
        }

    RegInitialize();

    FileArgumentSeen = FALSE;
    HiveName.Length = HiveName.MaximumLength = 0;
    HiveName.Buffer = NULL;
    for (i=1; i<argc; i++) {
        s = argv[ i ];
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'd':
                        DebugOutput = TRUE;
                        break;

                    case 'f':
                        if (++i < argc) {
                            RtlInitAnsiString(&AnsiString, argv[i]);
                            RtlAnsiStringToUnicodeString( &DosHiveName,
                                                          &AnsiString,
                                                          TRUE );
                            RtlDosPathNameToNtPathName_U( DosHiveName.Buffer,
                                                          &HiveName,
                                                          NULL,
                                                          NULL );
                            break;
                        }

                    default:    Usage();
                    }
                }
            }
        else {
            FileArgumentSeen = TRUE;
            RtlInitAnsiString( &AnsiString, s );
            Status = RtlAnsiStringToUnicodeString( &DosFileName, &AnsiString, TRUE );
            if (NT_SUCCESS( Status )) {
                if (RtlDosPathNameToNtPathName_U( DosFileName.Buffer,
                                                  &FileName,
                                                  NULL,
                                                  NULL
                                                )
                   ) {
                    Status = RiInitializeRegistryFromAsciiFile( &HiveName,
                                                                &FileName );
                    if (!NT_SUCCESS( Status )) {
                        fprintf( stderr,
                                 "HIVEINI: Failed to load from %wZ - Status == %lx\n",
                                 &FileName,
                                 Status
                           );
                        }
                    }
                else {
                    Status = STATUS_UNSUCCESSFUL;
                    fprintf( stderr,
                             "HIVEINI: Unable to map Dos Name (%wZ) to NT name\n",
                             &DosFileName
                       );
                    }
                }
            else {
                fprintf( stderr,
                         "HIVEINI: Unable to convert %s to unicode - Status == %lx\n",
                         &AnsiString,
                         Status
                       );
                }
            }
        }

    if (!FileArgumentSeen) {
        RtlInitUnicodeString( &FileName, L"\\SystemRoot\\System32\\Config\\registry.sys" );
        Status = RiInitializeRegistryFromAsciiFile( &HiveName,
                                                    &FileName );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr,
                     "HIVEINI: Failed to load from %wZ - Status == %lx\n",
                     &FileName,
                     Status
                   );
            }
        else {
            RtlInitUnicodeString( &FileName, L"\\SystemRoot\\System32\\Config\\registry.usr" );
            Status = RiInitializeRegistryFromAsciiFile( &HiveName,
                                                        &FileName );
            if (!NT_SUCCESS( Status )) {
                fprintf( stderr,
                         "HIVEINI: Failed to load from %wZ - Status == %lx\n",
                         &FileName,
                         Status
                       );
                }
            }
        }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\dbgk\dbgkobj.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgkobj.c

Abstract:

    This module houses routines to handle the debug object

Author:

    Neill Clift (NeillC) 26-Apr-2000


Revision History:

--*/

#include "dbgkp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DbgkInitialize)
#pragma alloc_text(PAGE, NtCreateDebugObject)
#pragma alloc_text(PAGE, NtDebugActiveProcess)
#pragma alloc_text(PAGE, NtRemoveProcessDebug)
#pragma alloc_text(PAGE, NtWaitForDebugEvent)
#pragma alloc_text(PAGE, NtDebugContinue)
#pragma alloc_text(PAGE, NtSetInformationDebugObject)
#pragma alloc_text(PAGE, DbgkpDeleteObject)
#pragma alloc_text(PAGE, DbgkpCloseObject)
#pragma alloc_text(PAGE, DbgkCopyProcessDebugPort)
#pragma alloc_text(PAGE, DbgkOpenProcessDebugPort)
#pragma alloc_text(PAGE, DbgkpSetProcessDebugObject)
#pragma alloc_text(PAGE, DbgkpQueueMessage)
#pragma alloc_text(PAGE, DbgkpOpenHandles)
#pragma alloc_text(PAGE, DbgkClearProcessDebugObject)
#pragma alloc_text(PAGE, DbgkpConvertKernelToUserStateChange)
#pragma alloc_text(PAGE, DbgkpMarkProcessPeb)
#pragma alloc_text(PAGE, DbgkpFreeDebugEvent)
#pragma alloc_text(PAGE, DbgkpPostFakeProcessCreateMessages)
#pragma alloc_text(PAGE, DbgkpPostFakeModuleMessages)
#pragma alloc_text(PAGE, DbgkpPostFakeThreadMessages)
#pragma alloc_text(PAGE, DbgkpWakeTarget)
#pragma alloc_text(PAGE, DbgkpPostAdditionalThreadMessages)
#endif

//
// Define this to not suspend threads while attaching.
// This makes race conditions more prevelent.
//
//#define DBGK_DONT_SUSPEND

//
// Non-pageable data
//

//
// This mutex protects the debug port object of processes.
//
FAST_MUTEX DbgkpProcessDebugPortMutex;

//
// Pageable data
//

//#ifdef ALLOC_PRAGMA
//#pragma data_seg("PAGEDATA")
//#endif

POBJECT_TYPE DbgkDebugObjectType = NULL;


//#ifdef ALLOC_PRAGMA
//#pragma data_seg()
//#endif

NTSTATUS
DbgkInitialize (
    VOID
    )
/*++

Routine Description:

    Initialize the debug system

Arguments:

    None

Return Value:

    NTSTATUS - Status of operation

--*/
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    OBJECT_TYPE_INITIALIZER oti = {0};
    GENERIC_MAPPING GenericMapping = {STANDARD_RIGHTS_READ | DEBUG_READ_EVENT,
                                      STANDARD_RIGHTS_WRITE | DEBUG_PROCESS_ASSIGN,
                                      STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
                                      DEBUG_ALL_ACCESS};


    PAGED_CODE ();

    ExInitializeFastMutex (&DbgkpProcessDebugPortMutex);

    RtlInitUnicodeString (&Name, L"DebugObject");

    oti.Length                    = sizeof (oti);
    oti.SecurityRequired          = TRUE;
    oti.InvalidAttributes         = 0;
    oti.PoolType                  = NonPagedPool;
    oti.DeleteProcedure           = DbgkpDeleteObject;
    oti.CloseProcedure            = DbgkpCloseObject;
    oti.ValidAccessMask           = DEBUG_ALL_ACCESS;
    oti.GenericMapping            = GenericMapping;
    oti.DefaultPagedPoolCharge    = 0;
    oti.DefaultNonPagedPoolCharge = 0;

    Status = ObCreateObjectType (&Name, &oti, NULL, &DbgkDebugObjectType);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    return Status;
}

VOID
DbgkpDeleteObject (
    IN  PVOID   Object
    )
/*++

Routine Description:

    Called by the object manager when the last reference to the object goes away.

Arguments:

    Object - Debug object being deleted

Return Value:

    None.

--*/
{
#if DBG
    PDEBUG_OBJECT DebugObject;
#endif

    PAGED_CODE();

#if DBG
    DebugObject = Object;

    ASSERT (IsListEmpty (&DebugObject->EventList));
#else
    UNREFERENCED_PARAMETER(Object);
#endif
}

VOID
DbgkpMarkProcessPeb (
    PEPROCESS Process
    )
/*++

Routine Description:

    This routine writes the debug variable in the PEB

Arguments:

    Process - Process that needs its PEB modified

Return Value:

    None.

--*/
{
    KAPC_STATE ApcState;

    PAGED_CODE ();

    //
    // Acquire process rundown protection as we are about to look at the processes address space
    //
    if (ExAcquireRundownProtection (&Process->RundownProtect)) {

        if (Process->Peb != NULL) {
            KeStackAttachProcess(&Process->Pcb, &ApcState);


            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

            try {
                Process->Peb->BeingDebugged = (BOOLEAN)(Process->DebugPort != NULL ? TRUE : FALSE);
#if defined(_WIN64)
                if (Process->Wow64Process != NULL) {
                    PPEB32 Peb32 = (PPEB32)Process->Wow64Process->Wow64;
                    if (Peb32 != NULL) {
                        Peb32->BeingDebugged = Process->Peb->BeingDebugged;
                    }
                }
#endif
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }
            ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

            KeUnstackDetachProcess(&ApcState);

        }

        ExReleaseRundownProtection (&Process->RundownProtect);
    }
}

VOID
DbgkpWakeTarget (
    IN PDEBUG_EVENT DebugEvent
    )
{
    PETHREAD Thread;

    Thread = DebugEvent->Thread;

    if ((DebugEvent->Flags&DEBUG_EVENT_SUSPEND) != 0) {
        PsResumeThread (DebugEvent->Thread, NULL);
    }

    if (DebugEvent->Flags&DEBUG_EVENT_RELEASE) {
        ExReleaseRundownProtection (&Thread->RundownProtect);
    }

    //
    // If we have an actual thread waiting then wake it up else free the memory.
    //
    if ((DebugEvent->Flags&DEBUG_EVENT_NOWAIT) == 0) {
        KeSetEvent (&DebugEvent->ContinueEvent, 0, FALSE); // Wake up waiting process
    } else {
        DbgkpFreeDebugEvent (DebugEvent);
    }
}

VOID
DbgkpCloseObject (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )
/*++

Routine Description:

    Called by the object manager when a handle is closed to the object.

Arguments:

    Process - Process doing the close
    Object - Debug object being deleted
    GrantedAccess - Access ranted for this handle
    ProcessHandleCount - Unused and unmaintained by OB
    SystemHandleCount - Current handle count for this object

Return Value:

    None.

--*/
{
    PDEBUG_OBJECT DebugObject = Object;
    PDEBUG_EVENT DebugEvent;
    PLIST_ENTRY ListPtr;
    BOOLEAN Deref;

    PAGED_CODE ();

    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);

    //
    // If this isn't the last handle then do nothing.
    //
    if (SystemHandleCount > 1) {
        return;
    }

    ExAcquireFastMutex (&DebugObject->Mutex);

    //
    // Mark this object as going away and wake up any processes that are waiting.
    //
    DebugObject->Flags |= DEBUG_OBJECT_DELETE_PENDING;

    //
    // Remove any events and queue them to a temporary queue
    //
    ListPtr = DebugObject->EventList.Flink;
    InitializeListHead (&DebugObject->EventList);

    ExReleaseFastMutex (&DebugObject->Mutex);

    //
    // Wake anyone waiting. They need to leave this object alone now as its deleting
    //
    KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);

    //
    // Loop over all processes and remove the debug port from any that still have it.
    // Debug port propogation was disabled by setting the delete pending flag above so we only have to do this
    // once. No more refs can appear now.
    //
    for (Process = PsGetNextProcess (NULL);
         Process != NULL;
         Process = PsGetNextProcess (Process)) {

        if (Process->DebugPort == DebugObject) {
            Deref = FALSE;
            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
            if (Process->DebugPort == DebugObject) {
                Process->DebugPort = NULL;
                Deref = TRUE;
            }
            ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);


            if (Deref) {
                DbgkpMarkProcessPeb (Process);
                //
                // If the caller wanted process deletion on debugger dying (old interface) then kill off the process.
                //
                if (DebugObject->Flags&DEBUG_OBJECT_KILL_ON_CLOSE) {
                    PsTerminateProcess (Process, STATUS_DEBUGGER_INACTIVE);
                }
                ObDereferenceObject (DebugObject);
            }
        }
    }
    //
    // Wake up all the removed threads.
    //
    while (ListPtr != &DebugObject->EventList) {
        DebugEvent = CONTAINING_RECORD (ListPtr, DEBUG_EVENT, EventList);
        ListPtr = ListPtr->Flink;
        DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
        DbgkpWakeTarget (DebugEvent);
    }

}

VOID
DbgkCopyProcessDebugPort (
    IN PEPROCESS TargetProcess,
    IN PEPROCESS SourceProcess
    )
/*++

Routine Description:

    Copies a debug port from one process to another.

Arguments:

    TargetProcess - Process to move port to
    sourceProcess - Process to move port from

Return Value:

    None

--*/
{
    PDEBUG_OBJECT DebugObject;

    PAGED_CODE ();

    TargetProcess->DebugPort = NULL; // New process. Needs no locks.

    if (SourceProcess->DebugPort != NULL) {
        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
        DebugObject = SourceProcess->DebugPort;
        if (DebugObject != NULL && (SourceProcess->Flags&PS_PROCESS_FLAGS_NO_DEBUG_INHERIT) == 0) {
            //
            // We must not propogate a debug port thats got no handles left.
            //
            ExAcquireFastMutex (&DebugObject->Mutex);

            //
            // If the object is delete pending then don't propogate this object.
            //
            if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
                ObReferenceObject (DebugObject);
                TargetProcess->DebugPort = DebugObject;
            }

            ExReleaseFastMutex (&DebugObject->Mutex);
        }
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);
    }
}

NTSTATUS
DbgkOpenProcessDebugPort (
    IN PEPROCESS Process,
    IN KPROCESSOR_MODE PreviousMode,
    OUT HANDLE *pHandle
    )
/*++

Routine Description:

    References the target processes debug port.

Arguments:

    Process - Process to reference debug port

Return Value:

    PDEBUG_OBJECT - Referenced object or NULL

--*/
{
    PDEBUG_OBJECT DebugObject;
    NTSTATUS Status;

    PAGED_CODE ();

    Status = STATUS_PORT_NOT_SET;
    if (Process->DebugPort != NULL) {
        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);
        DebugObject = Process->DebugPort;
        if (DebugObject != NULL) {
            ObReferenceObject (DebugObject);
        }
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

        if (DebugObject != NULL) {
            Status = ObOpenObjectByPointer (DebugObject,
                                            0,
                                            NULL,
                                            MAXIMUM_ALLOWED,
                                            DbgkDebugObjectType,
                                            PreviousMode,
                                            pHandle);
            if (!NT_SUCCESS (Status)) {
                ObDereferenceObject (DebugObject);
            }
        }
    }
    return Status;

}

NTSTATUS
NtCreateDebugObject (
    OUT PHANDLE DebugObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    )
/*++

Routine Description:

    Creates a new debug object that maintains the context for a single debug session. Multiple processes may be
    associated with a single debug object.

Arguments:

    DebugObjectHandle - Pointer to a handle to recive the output objects handle
    DesiredAccess     - Required handle access
    ObjectAttributes  - Standard object attributes structure
    Flags             - Only one flag DEBUG_KILL_ON_CLOSE

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;

    PAGED_CODE();

    //
    // Get previous processor mode and probe output arguments if necessary.
    // Zero the handle for error paths.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle (DebugObjectHandle);
        }
        *DebugObjectHandle = NULL;

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }

    if (Flags & ~DEBUG_KILL_ON_CLOSE) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Create a new debug object and initialize it.
    //

    Status = ObCreateObject (PreviousMode,
                             DbgkDebugObjectType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (DEBUG_OBJECT),
                             0,
                             0,
                             &DebugObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ExInitializeFastMutex (&DebugObject->Mutex);
    InitializeListHead (&DebugObject->EventList);
    KeInitializeEvent (&DebugObject->EventsPresent, NotificationEvent, FALSE);

    if (Flags & DEBUG_KILL_ON_CLOSE) {
        DebugObject->Flags = DEBUG_OBJECT_KILL_ON_CLOSE;
    } else {
        DebugObject->Flags = 0;
    }

    //
    // Insert the object into the handle table
    //
    Status = ObInsertObject (DebugObject,
                             NULL,
                             DesiredAccess,
                             0,
                             NULL,
                             &Handle);


    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    try {
        *DebugObjectHandle = Handle;
    } except (ExSystemExceptionFilter ()) {
        //
        // The caller changed the page protection or deleted the memory for the handle.
        // No point closing the handle as process rundown will do that and we don't know its still the same handle
        //
        Status = GetExceptionCode ();
    }

    return Status;
}

VOID
DbgkpFreeDebugEvent (
    IN PDEBUG_EVENT DebugEvent
    )
{
    NTSTATUS Status;

    PAGED_CODE ();

    switch (DebugEvent->ApiMsg.ApiNumber) {
        case DbgKmCreateProcessApi :
            if (DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle != NULL) {
                Status = ObCloseHandle (DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle, KernelMode);
            }
            break;

        case DbgKmLoadDllApi :
            if (DebugEvent->ApiMsg.u.LoadDll.FileHandle != NULL) {
                Status = ObCloseHandle (DebugEvent->ApiMsg.u.LoadDll.FileHandle, KernelMode);
            }
            break;

    }
    ObDereferenceObject (DebugEvent->Process);
    ObDereferenceObject (DebugEvent->Thread);
    ExFreePool (DebugEvent);
}


NTSTATUS
DbgkpQueueMessage (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN ULONG Flags,
    IN PDEBUG_OBJECT TargetDebugObject
    )
/*++

Routine Description:

    Queues a debug message to the port for a user mode debugger to get.

Arguments:

    Process           - Process being debugged
    Thread            - Thread making call
    ApiMsg            - Message being sent and received
    NoWait            - Don't wait for a responce. Buffer message and return.
    TargetDebugObject - Port to queue nowait messages to

Return Value:

    NTSTATUS - Status of call.

--*/
{
    PDEBUG_EVENT DebugEvent;
    DEBUG_EVENT StaticDebugEvent;
    PDEBUG_OBJECT DebugObject;
    NTSTATUS Status;

    PAGED_CODE ();

    if (Flags&DEBUG_EVENT_NOWAIT) {
        DebugEvent = ExAllocatePoolWithQuotaTag (NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                                 sizeof (*DebugEvent),
                                                 'EgbD');
        if (DebugEvent == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        DebugEvent->Flags = Flags|DEBUG_EVENT_INACTIVE;
        ObReferenceObject (Process);
        ObReferenceObject (Thread);
        DebugEvent->BackoutThread = PsGetCurrentThread ();
        DebugObject = TargetDebugObject;
    } else {
        DebugEvent = &StaticDebugEvent;
        DebugEvent->Flags = Flags;

        ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

        DebugObject = Process->DebugPort;

        //
        // See if this create message has already been sent.
        //
        if (ApiMsg->ApiNumber == DbgKmCreateThreadApi ||
            ApiMsg->ApiNumber == DbgKmCreateProcessApi) {
            if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG) {
                DebugObject = NULL;
            }
        }

        //
        // See if this exit message is for a thread that never had a create
        //
        if (ApiMsg->ApiNumber == DbgKmExitThreadApi ||
            ApiMsg->ApiNumber == DbgKmExitProcessApi) {
            if (Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG) {
                DebugObject = NULL;
            }
        }
    }

    KeInitializeEvent (&DebugEvent->ContinueEvent, SynchronizationEvent, FALSE);

    DebugEvent->Process = Process;
    DebugEvent->Thread = Thread;
    DebugEvent->ApiMsg = *ApiMsg;
    DebugEvent->ClientId = Thread->Cid;

    if (DebugObject == NULL) {
        Status = STATUS_PORT_NOT_SET;
    } else {

        //
        // We must not use a debug port thats got no handles left.
        //
        ExAcquireFastMutex (&DebugObject->Mutex);

        //
        // If the object is delete pending then don't use this object.
        //
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
            InsertTailList (&DebugObject->EventList, &DebugEvent->EventList);
            //
            // Set the event to say there is an unread event in the object
            //
            if ((Flags&DEBUG_EVENT_NOWAIT) == 0) {
                KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
            }
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_DEBUGGER_INACTIVE;
        }

        ExReleaseFastMutex (&DebugObject->Mutex);
    }


    if ((Flags&DEBUG_EVENT_NOWAIT) == 0) {
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

        if (NT_SUCCESS (Status)) {
            KeWaitForSingleObject (&DebugEvent->ContinueEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);

            Status = DebugEvent->Status;
            *ApiMsg = DebugEvent->ApiMsg;
        }
    } else {
        if (!NT_SUCCESS (Status)) {
            ObDereferenceObject (Process);
            ObDereferenceObject (Thread);
            ExFreePool (DebugEvent);
        }
    }

    return Status;
}

NTSTATUS
DbgkClearProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT SourceDebugObject
    )
/*++

Routine Description:

    Remove a debug object from a process.

Arguments:

    Process           - Process to be debugged
    sourceDebugObject - Debug object to detach

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    PDEBUG_EVENT DebugEvent;
    LIST_ENTRY TempList;
    PLIST_ENTRY Entry;

    PAGED_CODE ();

    ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

    DebugObject = Process->DebugPort;
    if (DebugObject == NULL || (DebugObject != SourceDebugObject && SourceDebugObject != NULL)) {
        DebugObject = NULL;
        Status = STATUS_PORT_NOT_SET;
    } else {
        Process->DebugPort = NULL;
        Status = STATUS_SUCCESS;
    }
    ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

    if (NT_SUCCESS (Status)) {
        DbgkpMarkProcessPeb (Process);
    }

    //
    // Remove any events for this process and wake up the threads.
    //
    if (DebugObject) {
        //
        // Remove any events and queue them to a temporary queue
        //
        InitializeListHead (&TempList);

        ExAcquireFastMutex (&DebugObject->Mutex);
        for (Entry = DebugObject->EventList.Flink;
             Entry != &DebugObject->EventList;
             ) {

            DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
            Entry = Entry->Flink;
            if (DebugEvent->Process == Process) {
                RemoveEntryList (&DebugEvent->EventList);
                InsertTailList (&TempList, &DebugEvent->EventList);
            }
        }
        ExReleaseFastMutex (&DebugObject->Mutex);

        ObDereferenceObject (DebugObject);

        //
        // Wake up all the removed threads.
        //
        while (!IsListEmpty (&TempList)) {
            Entry = RemoveHeadList (&TempList);
            DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
            DebugEvent->Status = STATUS_DEBUGGER_INACTIVE;
            DbgkpWakeTarget (DebugEvent);
        }
    }

    return Status;
}


NTSTATUS
DbgkpSetProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN NTSTATUS MsgStatus,
    IN PETHREAD LastThread
    )
/*++

Routine Description:

    Attach a debug object to a process.

Arguments:

    Process     - Process to be debugged
    DebugObject - Debug object to attach
    MsgStatus   - Status from queing the messages
    LastThread  - Last thread seen in attach loop.

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    PETHREAD ThisThread;
    LIST_ENTRY TempList;
    PLIST_ENTRY Entry;
    PDEBUG_EVENT DebugEvent;
    BOOLEAN First;
    PETHREAD Thread;
    BOOLEAN GlobalHeld;
    PETHREAD FirstThread;

    PAGED_CODE ();

    ThisThread = PsGetCurrentThread ();

    InitializeListHead (&TempList);

    First = TRUE;
    GlobalHeld = FALSE;

    if (!NT_SUCCESS (MsgStatus)) {
        LastThread = NULL;
        Status = MsgStatus;
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Pick up any threads we missed
    //
    if (NT_SUCCESS (Status)) {

        while (1) {
            //
            // Acquire the debug port mutex so we know that any new threads will
            // have to wait to behind us.
            //
            GlobalHeld = TRUE;

            ExAcquireFastMutex (&DbgkpProcessDebugPortMutex);

            //
            // If the port has been set then exit now.
            //
            if (Process->DebugPort != NULL) {
                Status = STATUS_PORT_ALREADY_SET;
                break;
            }
            //
            // Assign the debug port to the process to pick up any new threads
            //
            Process->DebugPort = DebugObject;

            //
            // Reference the last thread so we can deref outside the lock
            //
            ObReferenceObject (LastThread);

            //
            // Search forward for new threads
            //
            Thread = PsGetNextProcessThread (Process, LastThread);
            if (Thread != NULL) {

                //
                // Remove the debug port from the process as we are
                // about to drop the lock
                //
                Process->DebugPort = NULL;

                ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);

                GlobalHeld = FALSE;

                ObDereferenceObject (LastThread);

                //
                // Queue any new thread messages and repeat.
                //

                Status = DbgkpPostFakeThreadMessages (Process,
                                                      DebugObject,
                                                      Thread,
                                                      &FirstThread,
                                                      &LastThread);
                if (!NT_SUCCESS (Status)) {
                    LastThread = NULL;
                    break;
                }
                ObDereferenceObject (FirstThread);
            } else {
                break;
            }
        }
    }

    //
    // Lock the debug object so we can check its deleted status
    //
    ExAcquireFastMutex (&DebugObject->Mutex);

    //
    // We must not propogate a debug port thats got no handles left.
    //

    if (NT_SUCCESS (Status)) {
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {
            PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_NO_DEBUG_INHERIT|PS_PROCESS_FLAGS_CREATE_REPORTED);
            ObReferenceObject (DebugObject);
        } else {
            Process->DebugPort = NULL;
            Status = STATUS_DEBUGGER_INACTIVE;
        }
    }

    for (Entry = DebugObject->EventList.Flink;
         Entry != &DebugObject->EventList;
         ) {

        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
        Entry = Entry->Flink;

        if ((DebugEvent->Flags&DEBUG_EVENT_INACTIVE) != 0 && DebugEvent->BackoutThread == ThisThread) {
            Thread = DebugEvent->Thread;

            //
            // If the thread has not been inserted by CreateThread yet then don't
            // create a handle. We skip system threads here also
            //
            if (NT_SUCCESS (Status) && Thread->GrantedAccess != 0 && !IS_SYSTEM_THREAD (Thread)) {
                //
                // If we could not acquire rundown protection on this
                // thread then we need to supress its exit message.
                //
                if ((DebugEvent->Flags&DEBUG_EVENT_PROTECT_FAILED) != 0) {
                    PS_SET_BITS (&Thread->CrossThreadFlags,
                                 PS_CROSS_THREAD_FLAGS_SKIP_TERMINATION_MSG);
                    RemoveEntryList (&DebugEvent->EventList);
                    InsertTailList (&TempList, &DebugEvent->EventList);
                } else {
                    if (First) {
                         DebugEvent->Flags &= ~DEBUG_EVENT_INACTIVE;
                        KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
                        First = FALSE;
                    }
                    DebugEvent->BackoutThread = NULL;
                    PS_SET_BITS (&Thread->CrossThreadFlags,
                                 PS_CROSS_THREAD_FLAGS_SKIP_CREATION_MSG);

                }
            } else {
                RemoveEntryList (&DebugEvent->EventList);
                InsertTailList (&TempList, &DebugEvent->EventList);
            }

            if (DebugEvent->Flags&DEBUG_EVENT_RELEASE) {
                DebugEvent->Flags &= ~DEBUG_EVENT_RELEASE;
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }

        }
    }

    ExReleaseFastMutex (&DebugObject->Mutex);

    if (GlobalHeld) {
        ExReleaseFastMutex (&DbgkpProcessDebugPortMutex);
    }

    if (LastThread != NULL) {
        ObDereferenceObject (LastThread);
    }

    while (!IsListEmpty (&TempList)) {
        Entry = RemoveHeadList (&TempList);
        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);
        DbgkpWakeTarget (DebugEvent);
    }

    if (NT_SUCCESS (Status)) {
        DbgkpMarkProcessPeb (Process);
    }

    return Status;
}

NTSTATUS
DbgkpPostFakeThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD StartThread,
    OUT PETHREAD *pFirstThread,
    OUT PETHREAD *pLastThread
    )
/*++

Routine Description:

    This routine posts the faked initial process create, thread create messages

Arguments:

    Process      - Process to be debugged
    DebugObject  - Debug object to queue messages to
    StartThread  - Thread to start search from
    pFirstThread - First thread found in the list
    pLastThread  - Last thread found in the list

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    PETHREAD Thread, FirstThread, LastThread;
    DBGKM_APIMSG ApiMsg;
    BOOLEAN First = TRUE;
    BOOLEAN IsFirstThread;
    PIMAGE_NT_HEADERS NtHeaders;
    ULONG Flags;
#if !defined (DBGK_DONT_SUSPEND)
    NTSTATUS Status1;
#endif

    PAGED_CODE ();

    LastThread = FirstThread = NULL;

    Status = STATUS_UNSUCCESSFUL;

    if (StartThread != NULL) {
        First = FALSE;
        FirstThread = StartThread;
        ObReferenceObject (FirstThread);
    } else {
        StartThread = PsGetNextProcessThread (Process, NULL);
        First = TRUE;
    }

    for (Thread = StartThread;
         Thread != NULL;
         Thread = PsGetNextProcessThread (Process, Thread)) {

        Flags = DEBUG_EVENT_NOWAIT;

        //
        // Keep a track ont he last thread we have seen.
        // We use this as a starting point for new threads after we
        // really attach so we can pick up any new threads.
        //
        if (LastThread != NULL) {
            ObDereferenceObject (LastThread);
        }
        LastThread = Thread;
        ObReferenceObject (LastThread);

        //
        // Acquire rundown protection of the thread.
        // This stops the thread exiting so we know it can't send
        // it's termination message
        //
        if (ExAcquireRundownProtection (&Thread->RundownProtect)) {
            Flags |= DEBUG_EVENT_RELEASE;

            //
            // Suspend the thread if we can for the debugger
            // We don't suspend terminating threads as we will not be giving details
            // of these to the debugger.
            //
#if !defined (DBGK_DONT_SUSPEND)

            if (!IS_SYSTEM_THREAD (Thread)) {
                Status1 = PsSuspendThread (Thread, NULL);
                if (NT_SUCCESS (Status1)) {
                    Flags |= DEBUG_EVENT_SUSPEND;
                }
            }
#endif
        } else {
            //
            // Rundown protection failed for this thread.
            // This means the thread is exiting. We will mark this thread
            // later so it doesn't sent a thread termination message.
            // We can't do this now because this attach might fail.
            //
            Flags |= DEBUG_EVENT_PROTECT_FAILED;
        }

        RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

        if (First && (Flags&DEBUG_EVENT_PROTECT_FAILED) == 0 &&
            !IS_SYSTEM_THREAD (Thread) && Thread->GrantedAccess != 0) {
            IsFirstThread = TRUE;
        } else {
            IsFirstThread = FALSE;
        }

        if (IsFirstThread) {
            ApiMsg.ApiNumber = DbgKmCreateProcessApi;
            if (Process->SectionObject != NULL) { // system process doesn't have one of these!
                ApiMsg.u.CreateProcessInfo.FileHandle  = DbgkpSectionToFileHandle (Process->SectionObject);
            } else {
                ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
            }
            ApiMsg.u.CreateProcessInfo.BaseOfImage = Process->SectionBaseAddress;
            try {
                NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);
                if (NtHeaders) {
                    ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress = NULL; // Filling this in breaks MSDEV!
//                        (PVOID)(NtHeaders->OptionalHeader.ImageBase + NtHeaders->OptionalHeader.AddressOfEntryPoint);
                    ApiMsg.u.CreateProcessInfo.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                    ApiMsg.u.CreateProcessInfo.DebugInfoSize       = NtHeaders->FileHeader.NumberOfSymbols;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                ApiMsg.u.CreateProcessInfo.InitialThread.StartAddress = NULL;
                ApiMsg.u.CreateProcessInfo.DebugInfoFileOffset = 0;
                ApiMsg.u.CreateProcessInfo.DebugInfoSize = 0;
            }
        } else {
            ApiMsg.ApiNumber = DbgKmCreateThreadApi;
            ApiMsg.u.CreateThread.StartAddress = Thread->StartAddress;
        }
        Status = DbgkpQueueMessage (Process,
                                    Thread,
                                    &ApiMsg,
                                    Flags,
                                    DebugObject);
        if (!NT_SUCCESS (Status)) {
            if (Flags&DEBUG_EVENT_SUSPEND) {
                PsResumeThread (Thread, NULL);
            }
            if (Flags&DEBUG_EVENT_RELEASE) {
                ExReleaseRundownProtection (&Thread->RundownProtect);
            }
            if (ApiMsg.ApiNumber == DbgKmCreateProcessApi && ApiMsg.u.CreateProcessInfo.FileHandle != NULL) {
                ObCloseHandle (ApiMsg.u.CreateProcessInfo.FileHandle, KernelMode);
            }
            PsQuitNextProcessThread (Thread);
            break;
        } else if (IsFirstThread) {
            First = FALSE;
            ObReferenceObject (Thread);
            FirstThread = Thread;
        }
    }


    if (!NT_SUCCESS (Status)) {
        if (FirstThread) {
            ObDereferenceObject (FirstThread);
        }
        if (LastThread != NULL) {
            ObDereferenceObject (LastThread);
        }
    } else {
        if (FirstThread) {
            *pFirstThread = FirstThread;
            *pLastThread = LastThread;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    return Status;
}

NTSTATUS
DbgkpPostFakeModuleMessages (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN PDEBUG_OBJECT DebugObject)
/*++

Routine Description:

    This routine posts the faked module load messages when we debug an active process.

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    None.

--*/
{
    PPEB Peb = Process->Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead, LdrNext;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    DBGKM_APIMSG ApiMsg;
    ULONG i;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING Name;
    PIMAGE_NT_HEADERS NtHeaders;
    NTSTATUS Status;
    IO_STATUS_BLOCK iosb;

    PAGED_CODE ();

    if (Peb == NULL) {
        return STATUS_SUCCESS;
    }

    try {
        Ldr = Peb->Ldr;

        LdrHead = &Ldr->InLoadOrderModuleList;

        ProbeForReadSmallStructure (LdrHead, sizeof (LIST_ENTRY), sizeof (UCHAR));
        for (LdrNext = LdrHead->Flink, i = 0;
             LdrNext != LdrHead && i < 500;
             LdrNext = LdrNext->Flink, i++) {

            //
            // First image got send with process create message
            //
            if (i > 0) {
                RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

                LdrEntry = CONTAINING_RECORD (LdrNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                ProbeForReadSmallStructure (LdrEntry, sizeof (LDR_DATA_TABLE_ENTRY), sizeof (UCHAR));

                ApiMsg.ApiNumber = DbgKmLoadDllApi;
                ApiMsg.u.LoadDll.BaseOfDll = LdrEntry->DllBase;
                ApiMsg.u.LoadDll.NamePointer = NULL;

                ProbeForReadSmallStructure (ApiMsg.u.LoadDll.BaseOfDll, sizeof (IMAGE_DOS_HEADER), sizeof (UCHAR));

                NtHeaders = RtlImageNtHeader (ApiMsg.u.LoadDll.BaseOfDll);
                if (NtHeaders) {
                    ApiMsg.u.LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                    ApiMsg.u.LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
                }
                Status = MmGetFileNameForAddress (NtHeaders, &Name);
                if (NT_SUCCESS (Status)) {
                    InitializeObjectAttributes (&oa,
                                                &Name,
                                                OBJ_FORCE_ACCESS_CHECK|OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                                NULL,
                                                NULL);

                    Status = ZwOpenFile (&ApiMsg.u.LoadDll.FileHandle,
                                         GENERIC_READ|SYNCHRONIZE,
                                         &oa,
                                         &iosb,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                         FILE_SYNCHRONOUS_IO_NONALERT);
                    if (!NT_SUCCESS (Status)) {
                        ApiMsg.u.LoadDll.FileHandle = NULL;
                    }
                    ExFreePool (Name.Buffer);
                }
                Status = DbgkpQueueMessage (Process,
                                            Thread,
                                            &ApiMsg,
                                            DEBUG_EVENT_NOWAIT,
                                            DebugObject);
                if (!NT_SUCCESS (Status) && ApiMsg.u.LoadDll.FileHandle != NULL) {
                    ObCloseHandle (ApiMsg.u.LoadDll.FileHandle, KernelMode);
                }

            }
            ProbeForReadSmallStructure (LdrNext, sizeof (LIST_ENTRY), sizeof (UCHAR));
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }

#if defined(_WIN64)
    if (Process->Wow64Process != NULL && Process->Wow64Process->Wow64 != NULL) {
        PPEB32 Peb32;
        PPEB_LDR_DATA32 Ldr32;
        PLIST_ENTRY32 LdrHead32, LdrNext32;
        PLDR_DATA_TABLE_ENTRY32 LdrEntry32;
        PWCHAR pSys;

        Peb32 = (PPEB32)Process->Wow64Process->Wow64;

        try {
            Ldr32 = (PVOID) UlongToPtr(Peb32->Ldr);

            LdrHead32 = &Ldr32->InLoadOrderModuleList;

            ProbeForReadSmallStructure (LdrHead32, sizeof (LIST_ENTRY32), sizeof (UCHAR));
            for (LdrNext32 = (PVOID) UlongToPtr(LdrHead32->Flink), i = 0;
                 LdrNext32 != LdrHead32 && i < 500;
                 LdrNext32 = (PVOID) UlongToPtr(LdrNext32->Flink), i++) {

                if (i > 0) {
                    RtlZeroMemory (&ApiMsg, sizeof (ApiMsg));

                    LdrEntry32 = CONTAINING_RECORD (LdrNext32, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);
                    ProbeForReadSmallStructure (LdrEntry32, sizeof (LDR_DATA_TABLE_ENTRY32), sizeof (UCHAR));

                    ApiMsg.ApiNumber = DbgKmLoadDllApi;
                    ApiMsg.u.LoadDll.BaseOfDll = (PVOID) UlongToPtr(LdrEntry32->DllBase);
                    ApiMsg.u.LoadDll.NamePointer = NULL;

                    ProbeForReadSmallStructure (ApiMsg.u.LoadDll.BaseOfDll, sizeof (IMAGE_DOS_HEADER), sizeof (UCHAR));

                    NtHeaders = RtlImageNtHeader(ApiMsg.u.LoadDll.BaseOfDll);
                    if (NtHeaders) {
                        ApiMsg.u.LoadDll.DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                        ApiMsg.u.LoadDll.DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
                    }

                    Status = MmGetFileNameForAddress (NtHeaders, &Name);
                    if (NT_SUCCESS (Status)) {
                        ASSERT (sizeof (L"SYSTEM32") == sizeof (WOW64_SYSTEM_DIRECTORY_U));
                        pSys = wcsstr (Name.Buffer, L"\\SYSTEM32\\");
                        if (pSys != NULL) {
                            RtlCopyMemory (pSys+1,
                                           WOW64_SYSTEM_DIRECTORY_U,
                                           sizeof(WOW64_SYSTEM_DIRECTORY_U) - sizeof(UNICODE_NULL));
                        }

                        InitializeObjectAttributes (&oa,
                                                    &Name,
                                                    OBJ_FORCE_ACCESS_CHECK|OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                                    NULL,
                                                    NULL);

                        Status = ZwOpenFile (&ApiMsg.u.LoadDll.FileHandle,
                                             GENERIC_READ|SYNCHRONIZE,
                                             &oa,
                                             &iosb,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                             FILE_SYNCHRONOUS_IO_NONALERT);
                        if (!NT_SUCCESS (Status)) {
                            ApiMsg.u.LoadDll.FileHandle = NULL;
                        }
                        ExFreePool (Name.Buffer);
                    }

                    Status = DbgkpQueueMessage (Process,
                                                Thread,
                                                &ApiMsg,
                                                DEBUG_EVENT_NOWAIT,
                                                DebugObject);
                    if (!NT_SUCCESS (Status) && ApiMsg.u.LoadDll.FileHandle != NULL) {
                        ObCloseHandle (ApiMsg.u.LoadDll.FileHandle, KernelMode);
                    }
                }

                ProbeForReadSmallStructure (LdrNext32, sizeof (LIST_ENTRY32), sizeof (UCHAR));
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

#endif
    return STATUS_SUCCESS;
}

NTSTATUS
DbgkpPostFakeProcessCreateMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD *pLastThread
    )
/*++

Routine Description:

    This routine posts the faked initial process create, thread create and mudule load messages

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    KAPC_STATE ApcState;
    PETHREAD Thread;
    PETHREAD LastThread;

    PAGED_CODE ();

    //
    // Attach to the process so we can touch its address space
    //
    KeStackAttachProcess(&Process->Pcb, &ApcState);

    Status = DbgkpPostFakeThreadMessages (Process,
                                          DebugObject,
                                          NULL,
                                          &Thread,
                                          &LastThread);

    if (NT_SUCCESS (Status)) {
        Status = DbgkpPostFakeModuleMessages (Process, Thread, DebugObject);
        if (!NT_SUCCESS (Status)) {
            ObDereferenceObject (LastThread);
            LastThread = NULL;
        }
        ObDereferenceObject (Thread);
    } else {
        LastThread = NULL;
    }

    KeUnstackDetachProcess(&ApcState);

    *pLastThread = LastThread;

    return Status;
}

NTSTATUS
NtDebugActiveProcess (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    )
/*++

Routine Description:

    Attach a debug object to a process.

Arguments:

    ProcessHandle     - Handle to a process to be debugged
    DebugObjectHandle - Handle to a debug object

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    PEPROCESS Process;
    PETHREAD LastThread;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Don't let us debug ourselves or the system process.
    //
    if (Process == PsGetCurrentProcess () || Process == PsInitialSystemProcess) {
        ObDereferenceObject (Process);
        return STATUS_ACCESS_DENIED;
    }


    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_PROCESS_ASSIGN,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (NT_SUCCESS (Status)) {
        //
        // We will be touching process address space. Block process rundown.
        //
        if (ExAcquireRundownProtection (&Process->RundownProtect)) {

            //
            // Post the fake process create messages etc.
            //
            Status = DbgkpPostFakeProcessCreateMessages (Process,
                                                         DebugObject,
                                                         &LastThread);

            //
            // Set the debug port. If this fails it will remove any faked messages.
            //
            Status = DbgkpSetProcessDebugObject (Process,
                                                 DebugObject,
                                                 Status,
                                                 LastThread);

            ExReleaseRundownProtection (&Process->RundownProtect);
        } else {
            Status = STATUS_PROCESS_IS_TERMINATING;
        }

        ObDereferenceObject (DebugObject);
    }
    ObDereferenceObject (Process);

    return Status;
}

NTSTATUS
NtRemoveProcessDebug (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    )
/*++

Routine Description:

    Remove a debug object from a process.

Arguments:

    ProcessHandle - Handle to a process currently being debugged

Return Value:

    NTSTATUS - Status of call.

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    PEPROCESS Process;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (ProcessHandle,
                                        PROCESS_SET_PORT,
                                        PsProcessType,
                                        PreviousMode,
                                        &Process,
                                        NULL);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_PROCESS_ASSIGN,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);
    if (NT_SUCCESS (Status)) {
        Status = DbgkClearProcessDebugObject (Process,
                                               DebugObject);
        ObDereferenceObject (DebugObject);
    }

    ObDereferenceObject (Process);
    return Status;
}

VOID
DbgkpOpenHandles (
    PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    PEPROCESS Process,
    PETHREAD Thread
    )
/*++

Routine Description:

    Opens up process, thread and filehandles if need be for some of the requests

Arguments:

    WaitStateChange - User mode format change block
    Process - Pointer to target process
    Thread - Pointer to target thread

Return Value:

    None

--*/
{
    NTSTATUS Status;
    PEPROCESS CurrentProcess;
    HANDLE OldHandle;

    PAGED_CODE ();

    switch (WaitStateChange->NewState) {
        case DbgCreateThreadStateChange :
            //
            // We have the right to open up any thread in the process if we are allowed to debug it.
            // Use kernel mode here so we are always granted it regardless of protection.
            //
            Status = ObOpenObjectByPointer (Thread,
                                            0,
                                            NULL,
                                            THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | \
                                               THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION | THREAD_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsThreadType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateThread.HandleToThread);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateThread.HandleToThread = NULL;
            }
            break;

        case DbgCreateProcessStateChange :

            Status = ObOpenObjectByPointer (Thread,
                                            0,
                                            NULL,
                                            THREAD_GET_CONTEXT | THREAD_SET_CONTEXT | THREAD_SUSPEND_RESUME | \
                                               THREAD_QUERY_INFORMATION | THREAD_SET_INFORMATION | THREAD_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsThreadType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.HandleToThread);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateProcessInfo.HandleToThread = NULL;
            }
            Status = ObOpenObjectByPointer (Process,
                                            0,
                                            NULL,
                                            PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION |
                                               PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION | PROCESS_SET_INFORMATION |
                                               PROCESS_CREATE_THREAD | PROCESS_TERMINATE |
                                               READ_CONTROL | SYNCHRONIZE,
                                            PsProcessType,
                                            KernelMode,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess);
            if (!NT_SUCCESS (Status)) {
                WaitStateChange->StateInfo.CreateProcessInfo.HandleToProcess = NULL;
            }

            OldHandle = WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle;
            if (OldHandle != NULL) {
                CurrentProcess = PsGetCurrentProcess ();
                Status = ObDuplicateObject (CurrentProcess,
                                            OldHandle,
                                            CurrentProcess,
                                            &WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle,
                                            0,
                                            0,
                                            DUPLICATE_SAME_ACCESS,
                                            KernelMode);
                if (!NT_SUCCESS (Status)) {
                    WaitStateChange->StateInfo.CreateProcessInfo.NewProcess.FileHandle = NULL;
                }
                ObCloseHandle (OldHandle, KernelMode);
            }
            break;

        case DbgLoadDllStateChange :

            OldHandle = WaitStateChange->StateInfo.LoadDll.FileHandle;
            if (OldHandle != NULL) {
                CurrentProcess = PsGetCurrentProcess ();
                Status = ObDuplicateObject (CurrentProcess,
                                            OldHandle,
                                            CurrentProcess,
                                            &WaitStateChange->StateInfo.LoadDll.FileHandle,
                                            0,
                                            0,
                                            DUPLICATE_SAME_ACCESS,
                                            KernelMode);
                if (!NT_SUCCESS (Status)) {
                    WaitStateChange->StateInfo.LoadDll.FileHandle = NULL;
                }
                ObCloseHandle (OldHandle, KernelMode);
            }

            break;

        default :
            break;
    }
}

VOID
DbgkpConvertKernelToUserStateChange (
     PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
     PDEBUG_EVENT DebugEvent)
/*++

Routine Description:

    Converts a kernel message to one the user expects

Arguments:

    WaitStateChange - User mode format
    DebugEvent      - Debug event block to copy from

Return Value:

    None

--*/
{

    PAGED_CODE ();

    WaitStateChange->AppClientId = DebugEvent->ClientId;
    switch (DebugEvent->ApiMsg.ApiNumber) {
        case DbgKmExceptionApi :

            switch (DebugEvent->ApiMsg.u.Exception.ExceptionRecord.ExceptionCode) {
                case STATUS_BREAKPOINT :
                    WaitStateChange->NewState = DbgBreakpointStateChange;
                    break;

                case STATUS_SINGLE_STEP :
                    WaitStateChange->NewState = DbgSingleStepStateChange;
                    break;

                default :
                    WaitStateChange->NewState = DbgExceptionStateChange;
                    break;
            }
            WaitStateChange->StateInfo.Exception = DebugEvent->ApiMsg.u.Exception;
            break;

        case DbgKmCreateThreadApi :
            WaitStateChange->NewState = DbgCreateThreadStateChange;
            WaitStateChange->StateInfo.CreateThread.NewThread = DebugEvent->ApiMsg.u.CreateThread;
            break;

        case DbgKmCreateProcessApi :
            WaitStateChange->NewState = DbgCreateProcessStateChange;
            WaitStateChange->StateInfo.CreateProcessInfo.NewProcess = DebugEvent->ApiMsg.u.CreateProcessInfo;
            //
            // clear out the handle in the message as we will close this when we duplicate.
            //
            DebugEvent->ApiMsg.u.CreateProcessInfo.FileHandle = NULL;
            break;

        case DbgKmExitThreadApi :
            WaitStateChange->NewState = DbgExitThreadStateChange;
            WaitStateChange->StateInfo.ExitThread = DebugEvent->ApiMsg.u.ExitThread;
            break;

        case DbgKmExitProcessApi :
            WaitStateChange->NewState = DbgExitProcessStateChange;
            WaitStateChange->StateInfo.ExitProcess = DebugEvent->ApiMsg.u.ExitProcess;
            break;

        case DbgKmLoadDllApi :
            WaitStateChange->NewState = DbgLoadDllStateChange;
            WaitStateChange->StateInfo.LoadDll = DebugEvent->ApiMsg.u.LoadDll;
            //
            // clear out the handle in the message as we will close this when we duplicate.
            //
            DebugEvent->ApiMsg.u.LoadDll.FileHandle = NULL;
            break;

        case DbgKmUnloadDllApi :
            WaitStateChange->NewState = DbgUnloadDllStateChange;
            WaitStateChange->StateInfo.UnloadDll = DebugEvent->ApiMsg.u.UnloadDll;
            break;

        default :
            ASSERT (FALSE);
    }
}

NTSTATUS
NtWaitForDebugEvent (
    IN HANDLE DebugObjectHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    )
/*++

Routine Description:

    Waits for a debug event and returns it to the user if one arives

Arguments:

    DebugObjectHandle - Handle to a debug object
    Alertable - TRUE is the wait is to be alertable
    Timeout - Operation timeout value
    WaitStateChange - Returned debug event

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PDEBUG_OBJECT DebugObject;
    LARGE_INTEGER Tmo = {0};
    LARGE_INTEGER StartTime = {0};
    DBGUI_WAIT_STATE_CHANGE tWaitStateChange = {0};
    PEPROCESS Process;
    PETHREAD Thread;
    PLIST_ENTRY Entry, Entry2;
    PDEBUG_EVENT DebugEvent, DebugEvent2;
    BOOLEAN GotEvent;

    PAGED_CODE ();

    PreviousMode = KeGetPreviousMode();

    try {
        if (ARGUMENT_PRESENT (Timeout)) {
            if (PreviousMode != KernelMode) {
                ProbeForReadSmallStructure (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            Tmo = *Timeout;
            Timeout = &Tmo;
            KeQuerySystemTime (&StartTime);
        }
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure (WaitStateChange, sizeof (*WaitStateChange), sizeof (UCHAR));
        }

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }


    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_READ_EVENT,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Process = NULL;
    Thread = NULL;

    while (1) {
        Status = KeWaitForSingleObject (&DebugObject->EventsPresent,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);
        if (!NT_SUCCESS (Status) || Status == STATUS_TIMEOUT || Status == STATUS_ALERTED || Status == STATUS_USER_APC) {
            break;
        }

        GotEvent = FALSE;

        DebugEvent = NULL;

        ExAcquireFastMutex (&DebugObject->Mutex);

        //
        // If the object is delete pending then return an error.
        //
        if ((DebugObject->Flags&DEBUG_OBJECT_DELETE_PENDING) == 0) {


            for (Entry = DebugObject->EventList.Flink;
                 Entry != &DebugObject->EventList;
                 Entry = Entry->Flink) {

                DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);

                //
                // If this event has not been given back to the user yet and is not
                // inactive then pass it back.
                // We check to see if we have any other outstanding messages for this
                // thread as this confuses VC. You can only get multiple events
                // for the same thread for the attach faked messages.
                //
                if ((DebugEvent->Flags&(DEBUG_EVENT_READ|DEBUG_EVENT_INACTIVE)) == 0) {
                    GotEvent = TRUE;
                    for (Entry2 = DebugObject->EventList.Flink;
                         Entry2 != Entry;
                         Entry2 = Entry2->Flink) {

                        DebugEvent2 = CONTAINING_RECORD (Entry2, DEBUG_EVENT, EventList);

                        if (DebugEvent->ClientId.UniqueProcess == DebugEvent2->ClientId.UniqueProcess) {
                            //
                            // This event has the same process as an earlier event. Mark it as inactive.
                            //
                            DebugEvent->Flags |= DEBUG_EVENT_INACTIVE;
                            DebugEvent->BackoutThread = NULL;
                            GotEvent = FALSE;
                            break;
                        }
                    }
                    if (GotEvent) {
                        break;
                    }
                }
            }

            if (GotEvent) {
                Process = DebugEvent->Process;
                Thread = DebugEvent->Thread;
                ObReferenceObject (Thread);
                ObReferenceObject (Process);
                DbgkpConvertKernelToUserStateChange (&tWaitStateChange, DebugEvent);
                DebugEvent->Flags |= DEBUG_EVENT_READ;
            } else {
                //
                // No unread events there. Clear the event.
                //
                KeClearEvent (&DebugObject->EventsPresent);
            }
            Status = STATUS_SUCCESS;

        } else {
            Status = STATUS_DEBUGGER_INACTIVE;
        }

        ExReleaseFastMutex (&DebugObject->Mutex);

        if (NT_SUCCESS (Status)) {
            //
            // If we woke up and found nothing
            //
            if (GotEvent == FALSE) {
                //
                // If timeout is a delta time then adjust it for the wait so far.
                //
                if (Tmo.QuadPart < 0) {
                    LARGE_INTEGER NewTime;
                    KeQuerySystemTime (&NewTime);
                    Tmo.QuadPart = Tmo.QuadPart + (NewTime.QuadPart - StartTime.QuadPart);
                    StartTime = NewTime;
                    if (Tmo.QuadPart >= 0) {
                        Status = STATUS_TIMEOUT;
                        break;
                    }
                }
            } else {
                //
                // Fixup needed handles. The caller could have guessed the thread id etc by now and made the target thread
                // continue. This isn't a problem as we won't do anything damaging to the system in this case. The caller
                // won't get the correct results but they set out to break us.
                //
                DbgkpOpenHandles (&tWaitStateChange, Process, Thread);
                ObDereferenceObject (Thread);
                ObDereferenceObject (Process);
                break;
            }
        } else {
            break;
        }
    }

    ObDereferenceObject (DebugObject);

    try {
        *WaitStateChange = tWaitStateChange;
    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        Status = GetExceptionCode ();
    }
    return Status;
}

NTSTATUS
NtDebugContinue (
    IN HANDLE DebugObjectHandle,
    IN PCLIENT_ID ClientId,
    IN NTSTATUS ContinueStatus
    )
/*++

Routine Description:

    Coninues a stalled debugged thread

Arguments:

    DebugObjectHandle - Handle to a debug object
    ClientId - ClientId of thread tro continue
    ContinueStatus - Status of continue

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    PDEBUG_EVENT DebugEvent, FoundDebugEvent;
    KPROCESSOR_MODE PreviousMode;
    CLIENT_ID Clid;
    PLIST_ENTRY Entry;
    BOOLEAN GotEvent;

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (ClientId, sizeof (*ClientId), sizeof (UCHAR));
        }
        Clid = *ClientId;

    } except (ExSystemExceptionFilter ()) { // If previous mode is kernel then don't handle the exception
        return GetExceptionCode ();
    }

    switch (ContinueStatus) {
        case DBG_EXCEPTION_HANDLED :
        case DBG_EXCEPTION_NOT_HANDLED :
        case DBG_TERMINATE_THREAD :
        case DBG_TERMINATE_PROCESS :
        case DBG_CONTINUE :
            break;
        default :
            return STATUS_INVALID_PARAMETER;
    }

    Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                        DEBUG_READ_EVENT,
                                        DbgkDebugObjectType,
                                        PreviousMode,
                                        &DebugObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    GotEvent = FALSE;
    FoundDebugEvent = NULL;

    ExAcquireFastMutex (&DebugObject->Mutex);

    for (Entry = DebugObject->EventList.Flink;
         Entry != &DebugObject->EventList;
         Entry = Entry->Flink) {

        DebugEvent = CONTAINING_RECORD (Entry, DEBUG_EVENT, EventList);

        //
        // Make sure the client ID matches and that the debugger saw all the events.
        // We don't allow the caller to start a thread that it never saw a message for.
        // This would do no harm but its probably a bug in the debugger.
        //
        if (DebugEvent->ClientId.UniqueProcess == Clid.UniqueProcess) {
            if (!GotEvent) {
                if (DebugEvent->ClientId.UniqueThread == Clid.UniqueThread &&
                    (DebugEvent->Flags&DEBUG_EVENT_READ) != 0) {
                    RemoveEntryList (Entry);
                    FoundDebugEvent = DebugEvent;
                    GotEvent = TRUE;
                }
            } else {
                //
                // VC breaks if it sees more than one event at a time
                // for the same process.
                //
                DebugEvent->Flags &= ~DEBUG_EVENT_INACTIVE;
                KeSetEvent (&DebugObject->EventsPresent, 0, FALSE);
                break;
            }
        }
    }

    ExReleaseFastMutex (&DebugObject->Mutex);

    ObDereferenceObject (DebugObject);

    if (GotEvent) {
        FoundDebugEvent->ApiMsg.ReturnedStatus = ContinueStatus;
        FoundDebugEvent->Status = STATUS_SUCCESS;
        DbgkpWakeTarget (FoundDebugEvent);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
NtSetInformationDebugObject (
    IN HANDLE DebugObjectHandle,
    IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    IN PVOID DebugInformation,
    IN ULONG DebugInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
/*++

Routine Description:

    This function sets the state of a debug object.

Arguments:

    ProcessHandle - Supplies a handle to a process object.

    ProcessInformationClass - Supplies the class of information being
        set.

    ProcessInformation - Supplies a pointer to a record that contains the
        information to set.

    ProcessInformationLength - Supplies the length of the record that contains
        the information to set.

Return Value:

    NTSTATUS - Status of call

--*/
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PDEBUG_OBJECT DebugObject;
    ULONG Flags;

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForRead (DebugInformation,
                          DebugInformationLength,
                          sizeof (ULONG));
            if (ARGUMENT_PRESENT (ReturnLength)) {
                ProbeForWriteUlong (ReturnLength);
            }
        }
        if (ARGUMENT_PRESENT (ReturnLength)) {
            *ReturnLength = 0;
        }

        switch (DebugObjectInformationClass) {
            case DebugObjectFlags : {

                if (DebugInformationLength != sizeof (ULONG)) {
                    if (ARGUMENT_PRESENT (ReturnLength)) {
                        *ReturnLength = sizeof (ULONG);
                    }
                    return STATUS_INFO_LENGTH_MISMATCH;
                }
                Flags = *(PULONG) DebugInformation;

                break;
            }
            default : {
                return STATUS_INVALID_PARAMETER;
            }
        }
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }


    switch (DebugObjectInformationClass) {
        case DebugObjectFlags : {
            if (Flags & ~DEBUG_KILL_ON_CLOSE) {
                return STATUS_INVALID_PARAMETER;
            }
            Status = ObReferenceObjectByHandle (DebugObjectHandle,
                                                DEBUG_SET_INFORMATION,
                                                DbgkDebugObjectType,
                                                PreviousMode,
                                                &DebugObject,
                                                NULL);

            if (!NT_SUCCESS (Status)) {
                return Status;
            }
            ExAcquireFastMutex (&DebugObject->Mutex);

            if (Flags&DEBUG_KILL_ON_CLOSE) {
                DebugObject->Flags |= DEBUG_OBJECT_KILL_ON_CLOSE;
            } else {
                DebugObject->Flags &= ~DEBUG_OBJECT_KILL_ON_CLOSE;
            }

            ExReleaseFastMutex (&DebugObject->Mutex);

            ObDereferenceObject (DebugObject);
        }
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\dbgk\dbgkport.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgkport.c

Abstract:

    This module implements the dbg primitives to access a process'
    DebugPort and ExceptionPort.

Author:

    Mark Lucovsky (markl) 19-Jan-1990

Revision History:

--*/

#include "dbgkp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DbgkpSendApiMessage)
#pragma alloc_text(PAGE, DbgkForwardException)
#pragma alloc_text(PAGE, DbgkpSendApiMessageLpc)
#endif


NTSTATUS
DbgkpSendApiMessage(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN BOOLEAN SuspendProcess
    )

/*++

Routine Description:

    This function sends the specified API message over the specified
    port. It is the caller's responsibility to format the API message
    prior to calling this function.

    If the SuspendProcess flag is supplied, then all threads in the
    calling process are first suspended. Upon receipt of the reply
    message, the threads are resumed.

Arguments:

    ApiMsg - Supplies the API message to send.

    SuspendProcess - A flag that if set to true, causes all of the
        threads in the process to be suspended prior to the call,
        and resumed upon receipt of a reply.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    PEPROCESS Process;

    PAGED_CODE();

    if ( SuspendProcess ) {
        SuspendProcess = DbgkpSuspendProcess();
    }

    ApiMsg->ReturnedStatus = STATUS_PENDING;

    Process = PsGetCurrentProcess();

    PS_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);

    st = DbgkpQueueMessage (Process, PsGetCurrentThread (), ApiMsg, 0, NULL);

    ZwFlushInstructionCache (NtCurrentProcess (), NULL, 0);
    if ( SuspendProcess ) {
        DbgkpResumeProcess();
    }

    return st;
}

NTSTATUS
DbgkpSendApiMessageLpc(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN PVOID Port,
    IN BOOLEAN SuspendProcess
    )

/*++

Routine Description:

    This function sends the specified API message over the specified
    port. It is the caller's responsibility to format the API message
    prior to calling this function.

    If the SuspendProcess flag is supplied, then all threads in the
    calling process are first suspended. Upon receipt of the reply
    message, the threads are resumed.

Arguments:

    ApiMsg - Supplies the API message to send.

    Port - Supplies the address of a port to send the api message.

    SuspendProcess - A flag that if set to true, causes all of the
        threads in the process to be suspended prior to the call,
        and resumed upon receipt of a reply.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS st;
    ULONG_PTR MessageBuffer[PORT_MAXIMUM_MESSAGE_LENGTH/sizeof(ULONG_PTR)];

    PAGED_CODE();

    if ( SuspendProcess ) {
        SuspendProcess = DbgkpSuspendProcess();
    }

    ApiMsg->ReturnedStatus = STATUS_PENDING;

    PS_SET_BITS (&PsGetCurrentProcess()->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED);

    st = LpcRequestWaitReplyPortEx (Port,
                    (PPORT_MESSAGE) ApiMsg,
                    (PPORT_MESSAGE) &MessageBuffer[0]);

    ZwFlushInstructionCache(NtCurrentProcess(), NULL, 0);
    if (NT_SUCCESS (st)) {
        RtlCopyMemory(ApiMsg,MessageBuffer,sizeof(*ApiMsg));
    }

    if (SuspendProcess) {
        DbgkpResumeProcess();
    }

    return st;
}

BOOLEAN
DbgkForwardException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN DebugException,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This function is called forward an exception to the calling process's
    debug or subsystem exception port.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    DebugException - Supplies a boolean variable that specifies whether
        this exception is to be forwarded to the process's
        DebugPort(TRUE), or to its ExceptionPort(FALSE).

Return Value:

    TRUE - The process has a DebugPort or an ExceptionPort, and the reply
        received from the port indicated that the exception was handled.

    FALSE - The process either does not have a DebugPort or
        ExceptionPort, or the process has a port, but the reply received
        from the port indicated that the exception was not handled.

--*/

{
    PEPROCESS Process;
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXCEPTION args;
    NTSTATUS st;
    BOOLEAN LpcPort;

    PAGED_CODE();

    args = &m.u.Exception;

    //
    // Initialize the debug LPC message with default infomaation.
    //

    DBGKM_FORMAT_API_MSG(m,DbgKmExceptionApi,sizeof(*args));

    //
    // Get the address of the destination LPC port.
    //

    Process = PsGetCurrentProcess();
    if (DebugException) {
        if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
            Port = NULL;
        } else {
            Port = Process->DebugPort;
        }
        LpcPort = FALSE;
    } else {
        Port = Process->ExceptionPort;
        m.h.u2.ZeroInit = LPC_EXCEPTION;
        LpcPort = TRUE;
    }

    //
    // If the destination LPC port address is NULL, then return FALSE.
    //

    if (Port == NULL) {
        return FALSE;
    }

    //
    // Fill in the remainder of the debug LPC message.
    //

    args->ExceptionRecord = *ExceptionRecord;
    args->FirstChance = !SecondChance;

    //
    // Send the debug message to the destination LPC port.
    //

    if (LpcPort) {
        st = DbgkpSendApiMessageLpc(&m,Port,DebugException);
    } else {
        st = DbgkpSendApiMessage(&m,DebugException);
    }


    //
    // If the send was not successful, then return a FALSE indicating that
    // the port did not handle the exception. Otherwise, if the debug port
    // is specified, then look at the return status in the message.
    //

    if (!NT_SUCCESS(st) ||
        ((DebugException) &&
        (m.ReturnedStatus == DBG_EXCEPTION_NOT_HANDLED || !NT_SUCCESS(m.ReturnedStatus)))) {
        return FALSE;

    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\config\utils\regutil.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regutil.h

Abstract:

    This is the include file for the registry utility functions.

Author:

    Steve Wood (stevewo) 10-Mar-1992

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
// #include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>


#define VALUE_BUFFER_SIZE (4096 * 100)

void
RegInitialize( void );

typedef struct _REG_UNICODE_FILE {
    LARGE_INTEGER LastWriteTime;
    PWSTR FileContents;
    PWSTR EndOfFile;
    PWSTR BeginLine;
    PWSTR EndOfLine;
    PWSTR NextLine;
} REG_UNICODE_FILE, *PREG_UNICODE_FILE;

NTSTATUS
RegReadBinaryFile(
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    );

NTSTATUS
RegLoadAsciiFileAsUnicode(
    IN PUNICODE_STRING FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    );

BOOLEAN DebugOutput;
BOOLEAN SummaryOutput;

BOOLEAN
RegGetNextLine(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PULONG IndentAmount,
    OUT PWSTR *FirstEqual
    );

BOOLEAN
RegGetKeyValue(
    IN PUNICODE_STRING KeyValue,
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PULONG ValueType,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    );

BOOLEAN
RegGetMultiString(
    IN OUT PUNICODE_STRING ValueString,
    OUT PUNICODE_STRING MultiString
    );

void
RegDumpKeyValue(
    FILE *fh,
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    ULONG IndentLevel
    );

//
// routines for creating security descriptors (regacl.c)
//

BOOLEAN
RegInitializeSecurity(
    VOID
    );

BOOLEAN
RegCreateSecurity(
    IN PUNICODE_STRING Description,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    );

VOID
RegDestroySecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\dbgk\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=dbgk

TARGETNAME=dbgk
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntosdbgk$(NT_UP)

INCLUDES=..;..\..\inc;$(SDKTOOLS_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\dbgkport.c \
        ..\dbgkproc.c \
        ..\dbgkobj.c

UMTEST=udbgk

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\dbgk\dbgkp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgkp.h

Abstract:

    This header file describes private data structures and functions
    that make up the kernel mode portion of the Dbg subsystem.

Author:

    Mark Lucovsky (markl) 19-Jan-1990

[Environment:]

    optional-environment-info (e.g. kernel mode only...)

[Notes:]

    optional-notes

Revision History:

--*/

#ifndef _DBGKP_
#define _DBGKP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses

#include "ntos.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include <zwapi.h>
#include <string.h>
#if defined(_WIN64)
#include <wow64t.h>
#endif

#define DEBUG_EVENT_READ            (0x01)  // Event had been seen by win32 app
#define DEBUG_EVENT_NOWAIT          (0x02)  // No waiter one this. Just free the pool
#define DEBUG_EVENT_INACTIVE        (0x04)  // The message is in inactive. It may be activated or deleted later
#define DEBUG_EVENT_RELEASE         (0x08)  // Release rundown protection on this thread
#define DEBUG_EVENT_PROTECT_FAILED  (0x10)  // Rundown protection failed to be acquired on this thread
#define DEBUG_EVENT_SUSPEND         (0x20)  // Resume thread on continue


#define DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER(hdrs,field) \
            ((hdrs)->OptionalHeader.##field)

typedef struct _DEBUG_EVENT {
    LIST_ENTRY EventList;      // Queued to event object through this
    KEVENT ContinueEvent;
    CLIENT_ID ClientId;
    PEPROCESS Process;         // Waiting process
    PETHREAD Thread;           // Waiting thread
    NTSTATUS Status;           // Status of operation
    ULONG Flags;
    PETHREAD BackoutThread;    // Backout key for faked messages
    DBGKM_APIMSG ApiMsg;       // Message being sent
} DEBUG_EVENT, *PDEBUG_EVENT;


NTSTATUS
DbgkpSendApiMessage(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN BOOLEAN SuspendProcess
    );

BOOLEAN
DbgkpSuspendProcess(
    VOID
    );

VOID
DbgkpResumeProcess(
    VOID
    );

HANDLE
DbgkpSectionToFileHandle(
    IN PVOID SectionObject
    );

VOID
DbgkpDeleteObject (
    IN  PVOID   Object
    );

VOID
DbgkpCloseObject (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

NTSTATUS
DbgkpQueueMessage (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN ULONG Flags,
    IN PDEBUG_OBJECT TargetDebugObject
    );

VOID
DbgkpOpenHandles (
    PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    PEPROCESS Process,
    PETHREAD Thread
    );

VOID
DbgkpMarkProcessPeb (
    PEPROCESS Process
    );

VOID
DbgkpConvertKernelToUserStateChange (
    IN OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange,
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpSendApiMessageLpc(
    IN OUT PDBGKM_APIMSG ApiMsg,
    IN PVOID Port,
    IN BOOLEAN SuspendProcess
    );

VOID
DbgkpFreeDebugEvent (
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpPostFakeProcessCreateMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD *pLastThread
    );

NTSTATUS
DbgkpPostFakeModuleMessages (
    IN PEPROCESS Process,
    IN PETHREAD Thread,
    IN PDEBUG_OBJECT DebugObject
    );

NTSTATUS
DbgkpPostFakeThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD StartThread,
    OUT PETHREAD *pFirstThread,
    OUT PETHREAD *pLastThread
    );

NTSTATUS
DbgkpPostAdditionalThreadMessages (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN PETHREAD LastThread
    );

VOID
DbgkpWakeTarget (
    IN PDEBUG_EVENT DebugEvent
    );

NTSTATUS
DbgkpSetProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT DebugObject,
    IN NTSTATUS MsgStatus,
    IN PETHREAD LastThread
    );



#endif // _DBGKP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\dbgk\udbgk.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    udbg.c

Abstract:

    Usermode test for debugger

Author:

    Mark Lucovsky (markl) 19-Jan-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdbg.h>

HANDLE DebugPort;


NTSTATUS
ThreadThatExits (
    IN PVOID ThreadParameter
    )
{
    NtTerminateThread(NtCurrentThread(),(NTSTATUS) ThreadParameter );
}

ULONG
foo(PULONG l)
{
    //ULONG x;
    //x = *l;
    //return x + 1;

    return *l;

}

NTSTATUS
ThreadThatExcepts (
    IN PVOID ThreadParameter
    )
{
    foo((PULONG)0x00000001);
    NtTerminateThread(NtCurrentThread(),(NTSTATUS) ThreadParameter );
}



NTSTATUS
ThreadThatSpins (
    IN PVOID ThreadParameter
    )
{
    for(;;);
    NtTerminateThread(NtCurrentThread(),STATUS_SUCCESS);
}


UdbgTest1()
{
    NTSTATUS st;
    HANDLE ExitThread, SpinThread, DebugProcess;
    CLIENT_ID ExitClientId, SpinClientId;
    DBGKM_APIMSG m;
    PDBGKM_CREATE_THREAD CreateThreadArgs;
    PDBGKM_CREATE_PROCESS CreateProcessArgs;
    PDBGKM_EXIT_THREAD ExitThreadArgs;
    PDBGKM_EXIT_PROCESS ExitProcessArgs;
    ULONG Psp;

    DbgPrint("UdbgTest1: (1)...\n");

        //
        // Verify that a process can be created with a debug
        // port.
        //

        st = NtCreateProcess(
                &DebugProcess,
                PROCESS_ALL_ACCESS,
                NULL,
                NtCurrentProcess(),
                FALSE,
                NULL,
                DebugPort,
                NULL
                );
        ASSERT(NT_SUCCESS(st));

        st = RtlCreateUserThread(
                DebugProcess,
                NULL,
                TRUE,
                0L,
                0L,
                0L,
                ThreadThatExits,
                (PVOID) STATUS_ABANDONED,
                &ExitThread,
                &ExitClientId
                );
        ASSERT(NT_SUCCESS(st));

        st = RtlCreateUserThread(
                DebugProcess,
                NULL,
                TRUE,
                0L,
                0L,
                0L,
                ThreadThatSpins,
                NULL,
                &SpinThread,
                &SpinClientId
                );
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest1: (2)...\n");

        //
        // Verify that CreateProcess Messages Arrive, and that
        // they are correct
        //

        st = NtResumeThread(SpinThread,NULL);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmCreateProcessApi);

        CreateThreadArgs = &m.u.CreateProcess.InitialThread;
        CreateProcessArgs = &m.u.CreateProcess;
        ASSERT( CreateThreadArgs->SubSystemKey == 0 && CreateThreadArgs->StartAddress == (PVOID)ThreadThatSpins );
        ASSERT( CreateProcessArgs->SubSystemKey == 0);

    DbgPrint("UdbgTest1: (3)...\n");

        //
        // Verify that other threads in the process are properly suspended
        //

        st = NtSuspendThread(ExitThread,&Psp);
        ASSERT(NT_SUCCESS(st) && Psp == 2);

        st = NtResumeThread(ExitThread,&Psp);
        ASSERT(NT_SUCCESS(st) && Psp == 3);

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));


    DbgPrint("UdbgTest1: (4)...\n");

        //
        // Verify that CreateThread Messages Arrive, and that
        // they are correct
        //

        st = NtResumeThread(ExitThread,&Psp);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmCreateThreadApi);

        CreateThreadArgs = &m.u.CreateThread;
        ASSERT( CreateThreadArgs->SubSystemKey == 0 && CreateThreadArgs->StartAddress == (PVOID)ThreadThatExits );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest1: (5)...\n");

        //
        // Verify that ExitThread Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitThreadApi);

        ExitThreadArgs = &m.u.ExitThread;
        ASSERT( ExitThreadArgs->ExitStatus == STATUS_ABANDONED );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

        st = NtWaitForSingleObject(ExitThread,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest1: (6)...\n");

        //
        // Verify that ExitThread Messages Arrive, and that
        // they are correct
        //

        st = NtTerminateProcess(DebugProcess,STATUS_REPARSE);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitThreadApi);

        ExitThreadArgs = &m.u.ExitThread;
        ASSERT( ExitThreadArgs->ExitStatus == STATUS_REPARSE );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest1: (7)...\n");

        //
        // Verify that ExitProcess Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitProcessApi);

        ExitProcessArgs = &m.u.ExitProcess;
        ASSERT( ExitProcessArgs->ExitStatus == STATUS_REPARSE );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));


        st = NtWaitForSingleObject(ExitThread,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

        st = NtWaitForSingleObject(DebugProcess,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

    NtClose(ExitThread);
    NtClose(SpinThread);
    NtClose(DebugProcess);

    DbgPrint("UdbgTest1: END OF TEST ***\n");

}

UdbgTest2()
{
    NTSTATUS st;
    HANDLE ExceptionThread, DebugProcess;
    DBGKM_APIMSG m;
    PDBGKM_CREATE_THREAD CreateThreadArgs;
    PDBGKM_CREATE_PROCESS CreateProcessArgs;
    PDBGKM_EXIT_THREAD ExitThreadArgs;
    PDBGKM_EXIT_PROCESS ExitProcessArgs;
    PDBGKM_EXCEPTION ExceptionArgs;
    ULONG Psp;

    DbgPrint("UdbgTest2: (1)...\n");

        //
        // Verify that a process can be created with a debug
        // port.
        //

        st = NtCreateProcess(
                &DebugProcess,
                PROCESS_ALL_ACCESS,
                NULL,
                NtCurrentProcess(),
                FALSE,
                NULL,
                DebugPort,
                NULL
                );
        ASSERT(NT_SUCCESS(st));

        st = RtlCreateUserThread(
                DebugProcess,
                NULL,
                TRUE,
                0L,
                0L,
                0L,
                ThreadThatExcepts,
                (PVOID) STATUS_ABANDONED,
                &ExceptionThread,
                NULL
                );
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest2: (2)...\n");

        //
        // Verify that CreateThread Messages Arrive, and that
        // they are correct
        //

        st = NtResumeThread(ExceptionThread,NULL);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmCreateProcessApi);

        CreateThreadArgs = &m.u.CreateProcess.InitialThread;
        CreateProcessArgs = &m.u.CreateProcess;
        ASSERT( CreateThreadArgs->SubSystemKey == 0 && CreateThreadArgs->StartAddress == (PVOID)ThreadThatExcepts );
        ASSERT( CreateProcessArgs->SubSystemKey == 0);

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest2: (3)...\n");

        //
        // Verify that First Chance Exception Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExceptionApi);

        ExceptionArgs = &m.u.Exception;
        ASSERT( ExceptionArgs->FirstChance == TRUE );

        m.ReturnedStatus = DBG_EXCEPTION_NOT_HANDLED;

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest2: (4)...\n");

        //
        // Verify that First Chance Exception Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExceptionApi);

        ExceptionArgs = &m.u.Exception;
        ASSERT( ExceptionArgs->FirstChance == FALSE );

        m.ReturnedStatus = DBG_EXCEPTION_HANDLED;
skip4:
        st = NtTerminateProcess(DebugProcess,STATUS_REPARSE);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitThreadApi);

        ExitThreadArgs = &m.u.ExitThread;
        ASSERT( ExitThreadArgs->ExitStatus == STATUS_REPARSE );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));

    DbgPrint("UdbgTest2: (5)...\n");

        //
        // Verify that ExitProcess Messages Arrive, and that
        // they are correct
        //

        st = NtReplyWaitReceivePort(
                DebugPort,
                NULL,
                NULL,
                (PPORT_MESSAGE)&m
                );
        ASSERT(NT_SUCCESS(st));
        ASSERT(m.ApiNumber == DbgKmExitProcessApi);

        ExitProcessArgs = &m.u.ExitProcess;
        ASSERT( ExitProcessArgs->ExitStatus == STATUS_REPARSE );

        st = NtReplyPort(DebugPort,(PPORT_MESSAGE)&m);
        ASSERT(NT_SUCCESS(st));


        st = NtWaitForSingleObject(ExceptionThread,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

        st = NtWaitForSingleObject(DebugProcess,FALSE,NULL);
        ASSERT(NT_SUCCESS(st));

    NtClose(ExceptionThread);
    NtClose(DebugProcess);

    DbgPrint("UdbgTest2: END OF TEST ***\n");
}

main()
{
    NTSTATUS st;
    OBJECT_ATTRIBUTES Obja;

    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);

    st = NtCreatePort(
            &DebugPort,
            &Obja,
            0L,
            256,
            256 * 16
            );
    ASSERT(NT_SUCCESS(st));

    UdbgTest2();
    UdbgTest1();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\dbgk\dbgkproc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgkproc.c

Abstract:

    This module implements process control primitives for the
    Dbg component of NT

Author:

    Mark Lucovsky (markl) 19-Jan-1990

Revision History:

--*/

#include "dbgkp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DbgkpSuspendProcess)
#pragma alloc_text(PAGE, DbgkpResumeProcess)
#pragma alloc_text(PAGE, DbgkpSectionToFileHandle)
#pragma alloc_text(PAGE, DbgkCreateThread)
#pragma alloc_text(PAGE, DbgkExitThread)
#pragma alloc_text(PAGE, DbgkExitProcess)
#pragma alloc_text(PAGE, DbgkMapViewOfSection)
#pragma alloc_text(PAGE, DbgkUnMapViewOfSection)
#endif

                 

BOOLEAN
DbgkpSuspendProcess (
    VOID
    )

/*++

Routine Description:

    This function causes all threads in the calling process except for
    the calling thread to suspend.

Arguments:

    CreateDeleteLockHeld - Supplies a flag that specifies whether or not
        the caller is holding the process create delete lock.  If the
        caller holds the lock, than this function will not aquire the
        lock before suspending the process.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Freeze the execution of all threads in the current process, but
    // the calling thread. If we are in the process of being deleted don't do this.
    //
    if ((PsGetCurrentProcess()->Flags&PS_PROCESS_FLAGS_PROCESS_DELETE) == 0) {
        KeFreezeAllThreads();
        return TRUE;
    }

    return FALSE;
}

VOID
DbgkpResumeProcess (
    VOID
    )

/*++

Routine Description:

    This function causes all threads in the calling process except for
    the calling thread to resume.

Arguments:

    CreateDeleteLockHeld - Supplies a flag that specifies whether or not
        the caller is holding the process create delete lock.  If the
        caller holds the lock, than this function will not aquire the
        lock before suspending the process.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    //
    // Thaw the execution of all threads in the current process, but
    // the calling thread.
    //

    KeThawAllThreads();

    return;
}

HANDLE
DbgkpSectionToFileHandle(
    IN PVOID SectionObject
    )

/*++

Routine Description:

    This function Opens a handle to the file associated with the processes
    section. The file is opened such that it can be dupped all the way to
    the UI where the UI can either map the file or read the file to get
    the debug info.

Arguments:

    SectionHandle - Supplies a handle to the section whose associated file
        is to be opened.

Return Value:

    NULL - The file could not be opened.

    NON-NULL - Returns a handle to the file associated with the specified
        section.

--*/

{
    NTSTATUS Status;
    ANSI_STRING FileName;
    UNICODE_STRING UnicodeFileName;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;

    PAGED_CODE();

    Status = MmGetFileNameForSection(SectionObject, (PSTRING)&FileName);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
    }

    Status = RtlAnsiStringToUnicodeString(&UnicodeFileName,&FileName,TRUE);
    ExFreePool(FileName.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
    }

    InitializeObjectAttributes(
        &Obja,
        &UnicodeFileName,
        OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)(GENERIC_READ | SYNCHRONIZE),
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    RtlFreeUnicodeString(&UnicodeFileName);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
    } else {
        return Handle;
    }
}


VOID
DbgkCreateThread(
    PETHREAD Thread,
    PVOID StartAddress
    )

/*++

Routine Description:

    This function is called when a new thread begins to execute. If the
    thread has an associated DebugPort, then a message is sent thru the
    port.

    If this thread is the first thread in the process, then this event
    is translated into a CreateProcessInfo message.

    If a message is sent, then while the thread is awaiting a reply,
    all other threads in the process are suspended.

Arguments:

    Thread - New thread just being started

    StartAddress - Supplies the start address for the thread that is
        starting.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_CREATE_THREAD CreateThreadArgs;
    PDBGKM_CREATE_PROCESS CreateProcessArgs;
    PEPROCESS Process;
    PDBGKM_LOAD_DLL LoadDllArgs;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    PIMAGE_NT_HEADERS NtHeaders;
    PTEB Teb;
    ULONG OldFlags;
#if defined(_WIN64)
    PVOID Wow64Process;
#endif

    PAGED_CODE();

    Process = PsGetCurrentProcessByThread (Thread);

#if defined(_WIN64)
    Wow64Process = Process->Wow64Process;
#endif

    OldFlags = PS_TEST_SET_BITS (&Process->Flags, PS_PROCESS_FLAGS_CREATE_REPORTED|PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE);

    if ((OldFlags&PS_PROCESS_FLAGS_IMAGE_NOTIFY_DONE) == 0 && PsImageNotifyEnabled) {
        IMAGE_INFO ImageInfo;
        ANSI_STRING FileName;
        UNICODE_STRING UnicodeFileName;
        PUNICODE_STRING pUnicodeFileName;

        //
        // notification of main .exe
        //
        ImageInfo.Properties = 0;
        ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
        ImageInfo.ImageBase = Process->SectionBaseAddress;
        ImageInfo.ImageSize = 0;

        try {
            NtHeaders = RtlImageNtHeader (Process->SectionBaseAddress);
    
            if (NtHeaders) {
#if defined(_WIN64)
                if (Wow64Process != NULL) {
                    ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER ((PIMAGE_NT_HEADERS32)NtHeaders, SizeOfImage);
                } else {
#endif
                    ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER (NtHeaders, SizeOfImage);
#if defined(_WIN64)
                }
#endif
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ImageInfo.ImageSize = 0;
        }
        ImageInfo.ImageSelector = 0;
        ImageInfo.ImageSectionNumber = 0;

        pUnicodeFileName = NULL;
        Status = MmGetFileNameForSection (Process->SectionObject, (PSTRING)&FileName);
        if (NT_SUCCESS (Status)) {
            Status = RtlAnsiStringToUnicodeString (&UnicodeFileName, &FileName,TRUE);
            ExFreePool (FileName.Buffer);
            if (NT_SUCCESS (Status)) {
                pUnicodeFileName = &UnicodeFileName;
            }
        }
        PsCallImageNotifyRoutines (pUnicodeFileName,
                                   Process->UniqueProcessId,
                                   &ImageInfo);
        if (pUnicodeFileName != NULL) {
            RtlFreeUnicodeString (pUnicodeFileName);
        }

        //
        // and of ntdll.dll
        //
        ImageInfo.Properties = 0;
        ImageInfo.ImageAddressingMode = IMAGE_ADDRESSING_MODE_32BIT;
        ImageInfo.ImageBase = PsSystemDllBase;
        ImageInfo.ImageSize = 0;

        try {
            NtHeaders = RtlImageNtHeader (PsSystemDllBase);
            if ( NtHeaders ) {
#if defined(_WIN64)
                if (Wow64Process != NULL) {
                    ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER ((PIMAGE_NT_HEADERS32)NtHeaders, SizeOfImage);
                } else {
#endif
                    ImageInfo.ImageSize = DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER (NtHeaders, SizeOfImage);
#if defined(_WIN64)
                }
#endif
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ImageInfo.ImageSize = 0;
        }

        ImageInfo.ImageSelector = 0;
        ImageInfo.ImageSectionNumber = 0;

        RtlInitUnicodeString (&UnicodeFileName,
                              L"\\SystemRoot\\System32\\ntdll.dll");
        PsCallImageNotifyRoutines (&UnicodeFileName,
                                   Process->UniqueProcessId,
                                   &ImageInfo);
    }


    Port = Process->DebugPort;

    if (Port == NULL) {
        return;
    }

    //
    // Make sure we only get one create process message
    //

    if ((OldFlags&PS_PROCESS_FLAGS_CREATE_REPORTED) == 0) {

        //
        // This is a create process
        //

        CreateThreadArgs = &m.u.CreateProcessInfo.InitialThread;
        CreateThreadArgs->SubSystemKey = 0;

        CreateProcessArgs = &m.u.CreateProcessInfo;
        CreateProcessArgs->SubSystemKey = 0;
        CreateProcessArgs->FileHandle = DbgkpSectionToFileHandle(
                                            Process->SectionObject
                                            );
        CreateProcessArgs->BaseOfImage = Process->SectionBaseAddress;
        CreateThreadArgs->StartAddress = NULL;
        CreateProcessArgs->DebugInfoFileOffset = 0;
        CreateProcessArgs->DebugInfoSize = 0;

        try {
                        
            NtHeaders = RtlImageNtHeader(Process->SectionBaseAddress);

            if ( NtHeaders ) {

#if defined(_WIN64)
                if (Wow64Process != NULL) {
                    CreateThreadArgs->StartAddress = UlongToPtr (DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER ((PIMAGE_NT_HEADERS32)NtHeaders, ImageBase) +
                        DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER ((PIMAGE_NT_HEADERS32)NtHeaders, AddressOfEntryPoint));
                } else {
#endif
                    CreateThreadArgs->StartAddress = (PVOID) (DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER (NtHeaders, ImageBase) +
                        DBGKP_FIELD_FROM_IMAGE_OPTIONAL_HEADER (NtHeaders, AddressOfEntryPoint));
#if defined(_WIN64)
                }
#endif

                //
                // The following fields are safe for Wow64 as the offsets are the same for a PE32+
                // as a PE32 header.
                //
                
                CreateProcessArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                CreateProcessArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            CreateThreadArgs->StartAddress = NULL;
            CreateProcessArgs->DebugInfoFileOffset = 0;
            CreateProcessArgs->DebugInfoSize = 0;
        }

        DBGKM_FORMAT_API_MSG(m,DbgKmCreateProcessApi,sizeof(*CreateProcessArgs));

        DbgkpSendApiMessage(&m,FALSE);

        if (CreateProcessArgs->FileHandle != NULL) {
            ObCloseHandle(CreateProcessArgs->FileHandle, KernelMode);
        }

        LoadDllArgs = &m.u.LoadDll;
        LoadDllArgs->BaseOfDll = PsSystemDllBase;
        LoadDllArgs->DebugInfoFileOffset = 0;
        LoadDllArgs->DebugInfoSize = 0;
        LoadDllArgs->NamePointer = NULL;

        Teb = NULL;
        try {
            NtHeaders = RtlImageNtHeader(PsSystemDllBase);
            if ( NtHeaders ) {
                LoadDllArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
                LoadDllArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
            }

            //
            // Normaly the ntdll loaded fills in this pointer for the debug API's. We fake it here
            // as ntdll isn't loaded yet and it can't load itself.
            //

            Teb = Thread->Tcb.Teb;
            if (Teb != NULL) {
                wcsncpy (Teb->StaticUnicodeBuffer,
                         L"ntdll.dll",
                         sizeof (Teb->StaticUnicodeBuffer) / sizeof (Teb->StaticUnicodeBuffer[0]));
                Teb->NtTib.ArbitraryUserPointer = Teb->StaticUnicodeBuffer;
                LoadDllArgs->NamePointer = &Teb->NtTib.ArbitraryUserPointer;
            }
            
        } except (EXCEPTION_EXECUTE_HANDLER) {
            LoadDllArgs->DebugInfoFileOffset = 0;
            LoadDllArgs->DebugInfoSize = 0;
            LoadDllArgs->NamePointer = NULL;
        }

        //
        // Send load dll section for NT dll !
        //

        InitializeObjectAttributes(
            &Obja,
            (PUNICODE_STRING)&PsNtDllPathName,
            OBJ_CASE_INSENSITIVE | OBJ_FORCE_ACCESS_CHECK | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

        Status = ZwOpenFile(
                    &LoadDllArgs->FileHandle,
                    (ACCESS_MASK)(GENERIC_READ | SYNCHRONIZE),
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_SYNCHRONOUS_IO_NONALERT
                    );

        if (!NT_SUCCESS (Status)) {
            LoadDllArgs->FileHandle = NULL;
        }

        DBGKM_FORMAT_API_MSG(m,DbgKmLoadDllApi,sizeof(*LoadDllArgs));
        DbgkpSendApiMessage(&m,TRUE);

        if (LoadDllArgs->FileHandle != NULL) {
            ObCloseHandle(LoadDllArgs->FileHandle, KernelMode);
        }

        try {
            if (Teb != NULL) {
                Teb->NtTib.ArbitraryUserPointer = NULL;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }

    } else {

        CreateThreadArgs = &m.u.CreateThread;
        CreateThreadArgs->SubSystemKey = 0;
        CreateThreadArgs->StartAddress = StartAddress;

        DBGKM_FORMAT_API_MSG (m,DbgKmCreateThreadApi,sizeof(*CreateThreadArgs));

        DbgkpSendApiMessage (&m,TRUE);
    }
}

VOID
DbgkExitThread(
    NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function is called when a new thread terminates. At this
    point, the thread will no longer execute in user-mode. No other
    exit processing has occured.

    If a message is sent, then while the thread is awaiting a reply,
    all other threads in the process are suspended.

Arguments:

    ExitStatus - Supplies the ExitStatus of the exiting thread.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXIT_THREAD args;
    PEPROCESS Process;
    BOOLEAN Frozen;

    PAGED_CODE();

    Process = PsGetCurrentProcess();
    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) {
        return;
    }

    args = &m.u.ExitThread;
    args->ExitStatus = ExitStatus;

    DBGKM_FORMAT_API_MSG(m,DbgKmExitThreadApi,sizeof(*args));

    Frozen = DbgkpSuspendProcess();

    DbgkpSendApiMessage(&m,FALSE);

    if (Frozen) {
        DbgkpResumeProcess();
    }
}

VOID
DbgkExitProcess(
    NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function is called when a process terminates. The address
    space of the process is still intact, but no threads exist in
    the process.

Arguments:

    ExitStatus - Supplies the ExitStatus of the exiting process.

Return Value:

    None.

--*/

{
    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_EXIT_PROCESS args;
    PEPROCESS Process;

    PAGED_CODE();

    Process = PsGetCurrentProcess();

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_DEADTHREAD) {
        return;
    }

    //
    // this ensures that other timed lockers of the process will bail
    // since this call is done while holding the process lock, and lock duration
    // is controlled by debugger
    //
    KeQuerySystemTime(&PsGetCurrentProcess()->ExitTime);

    args = &m.u.ExitProcess;
    args->ExitStatus = ExitStatus;

    DBGKM_FORMAT_API_MSG(m,DbgKmExitProcessApi,sizeof(*args));

    DbgkpSendApiMessage(&m,FALSE);

}

VOID
DbgkMapViewOfSection(
    IN PVOID SectionObject,
    IN PVOID BaseAddress,
    IN ULONG SectionOffset,
    IN ULONG_PTR ViewSize
    )

/*++

Routine Description:

    This function is called when the current process successfully
    maps a view of an image section. If the process has an associated
    debug port, then a load dll message is sent.

Arguments:

    SectionObject - Supplies a pointer to the section mapped by the
        process.

    BaseAddress - Supplies the base address of where the section is
        mapped in the current process address space.

    SectionOffset - Supplies the offset in the section where the
        processes mapped view begins.

    ViewSize - Supplies the size of the mapped view.

Return Value:

    None.

--*/

{

    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_LOAD_DLL LoadDllArgs;
    PEPROCESS Process;
    PIMAGE_NT_HEADERS NtHeaders;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (SectionOffset);
    UNREFERENCED_PARAMETER (ViewSize);

    if ( KeGetPreviousMode() == KernelMode ) {
        return;
    }

    Process = PsGetCurrentProcess();

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    LoadDllArgs = &m.u.LoadDll;
    LoadDllArgs->FileHandle = DbgkpSectionToFileHandle(SectionObject);
    LoadDllArgs->BaseOfDll = BaseAddress;
    LoadDllArgs->DebugInfoFileOffset = 0;
    LoadDllArgs->DebugInfoSize = 0;

    //
    // The loader fills in the module name in this pointer before mapping the section.
    // Its a very poor linkage.
    //

    LoadDllArgs->NamePointer = &NtCurrentTeb()->NtTib.ArbitraryUserPointer;

    try {

        NtHeaders = RtlImageNtHeader (BaseAddress);

        if (NtHeaders != NULL) {
            LoadDllArgs->DebugInfoFileOffset = NtHeaders->FileHeader.PointerToSymbolTable;
            LoadDllArgs->DebugInfoSize = NtHeaders->FileHeader.NumberOfSymbols;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        LoadDllArgs->DebugInfoFileOffset = 0;
        LoadDllArgs->DebugInfoSize = 0;
        LoadDllArgs->NamePointer = NULL;

    }

    DBGKM_FORMAT_API_MSG(m,DbgKmLoadDllApi,sizeof(*LoadDllArgs));

    DbgkpSendApiMessage(&m,TRUE);
    if (LoadDllArgs->FileHandle != NULL) {
        ObCloseHandle(LoadDllArgs->FileHandle, KernelMode);
    }
}

VOID
DbgkUnMapViewOfSection(
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This function is called when the current process successfully
    un maps a view of an image section. If the process has an associated
    debug port, then an "unmap view of section" message is sent.

Arguments:

    BaseAddress - Supplies the base address of the section being
        unmapped.

Return Value:

    None.

--*/

{

    PVOID Port;
    DBGKM_APIMSG m;
    PDBGKM_UNLOAD_DLL UnloadDllArgs;
    PEPROCESS Process;

    PAGED_CODE();

    Process = PsGetCurrentProcess();

    if ( KeGetPreviousMode() == KernelMode ) {
        return;
    }

    if (PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HIDEFROMDBG) {
        Port = NULL;
    } else {
        Port = Process->DebugPort;
    }

    if ( !Port ) {
        return;
    }

    UnloadDllArgs = &m.u.UnloadDll;
    UnloadDllArgs->BaseAddress = BaseAddress;

    DBGKM_FORMAT_API_MSG(m,DbgKmUnloadDllApi,sizeof(*UnloadDllArgs));

    DbgkpSendApiMessage(&m,TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\callperf.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    callperf.c

Abstract:

   This module implements the functions necessary to collect call data.

Author:

    David N. Cutler (davec) 22-May-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

VOID
ExInitializeCallData (
    IN PCALL_PERFORMANCE_DATA CallData
    )

/*++

Routine Description:

    This function initializes a call performance data structure.

Arguments:

    CallData - Supplies a pointer to the call performance data structure
        that is initialized.

Return Value:

    None.

--*/

{

    ULONG Index;

    //
    // Initialize the spinlock and listheads for the call performance
    // data structure.
    //

    KeInitializeSpinLock(&CallData->SpinLock);
    for (Index = 0; Index < CALL_HASH_TABLE_SIZE; Index += 1) {
        InitializeListHead(&CallData->HashTable[Index]);
    }
}

VOID
ExRecordCallerInHashTable (
    IN PCALL_PERFORMANCE_DATA CallData,
    IN PVOID CallersAddress,
    IN PVOID CallersCaller
    )

/*++

Routine Description:

    This function records call data in the specified call performance
    data structure.

Arguments:

    CallData - Supplies a pointer to the call performance data structure
        in which the call data is recorded.

    CallersAddress - Supplies the address of the caller of a fucntion.

    CallersCaller - Supplies the address of the caller of a caller of
        a function.

Return Value:

    None.

--*/

{

    PCALL_HASH_ENTRY HashEntry;
    ULONG Hash;
    PCALL_HASH_ENTRY MatchEntry;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;

    //
    // If the initialization phase is not zero, then collect call performance
    // data.
    //

    if (InitializationPhase != 0) {

        //
        // Acquire the call performance data structure spinlock.
        //

        ExAcquireSpinLock(&CallData->SpinLock, &OldIrql);

        //
        // Lookup the callers address in call performance data hash table. If
        // the address does not exist in the table, then create a new entry.
        //

        Hash = (ULONG)((ULONG_PTR)CallersAddress ^ (ULONG_PTR)CallersCaller);
        Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ (Hash)) & (CALL_HASH_TABLE_SIZE - 1);
        MatchEntry = NULL;
        NextEntry = CallData->HashTable[Hash].Flink;
        while (NextEntry != &CallData->HashTable[Hash]) {
            HashEntry = CONTAINING_RECORD(NextEntry,
                                          CALL_HASH_ENTRY,
                                          ListEntry);

            if ((HashEntry->CallersAddress == CallersAddress) &&
                (HashEntry->CallersCaller == CallersCaller)) {
                MatchEntry = HashEntry;
                break;
            }

            NextEntry = NextEntry->Flink;
        }

        //
        // If a matching caller address was found, then update the call site
        // statistics. Otherwise, allocate a new hash entry and initialize
        // call site statistics.
        //

        if (MatchEntry != NULL) {
            MatchEntry->CallCount += 1;

        } else {
            MatchEntry = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(CALL_HASH_ENTRY),
                                              'CdHe');

            if (MatchEntry != NULL) {
                MatchEntry->CallersAddress = CallersAddress;
                MatchEntry->CallersCaller = CallersCaller;
                MatchEntry->CallCount = 1;
                InsertTailList(&CallData->HashTable[Hash],
                               &MatchEntry->ListEntry);
            }
        }

        //
        // Release the call performance data structure spinlock.
        //

        ExReleaseSpinLock(&CallData->SpinLock, OldIrql);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\callback.c ===
/*++

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    callback.c

Abstract:

   This module implements the executive callbaqck object. Functions are
   provided to open, register, unregister , and notify callback objects.

Author:

    Ken Reneris  (kenr) 7-March-1995

    Neill Clift  (NeillC) 17-Feb-2001

    Added low overhead callbacks for critical components like thread/registry etc.
    These routines have a high probability of not requiring any locks for an
    individual call.

Environment:

    Kernel mode only.

Revision History:

--*/


#include "exp.h"

//
// Callback Specific Access Rights.
//

#define CALLBACK_MODIFY_STATE    0x0001

#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|\
                             CALLBACK_MODIFY_STATE )



//
// Event to wait for registration to become idle
//

KEVENT ExpCallbackEvent;


//
// Lock used when fast referencing fails.
//
EX_PUSH_LOCK ExpCallBackFlush;

//
// Debug flag to force certain code paths. Let it get optimized away on free builds.
//
#if DBG

BOOLEAN ExpCallBackReturnRefs = FALSE;

#else

const
BOOLEAN ExpCallBackReturnRefs = FALSE;

#endif

//
// Address of callback object type descriptor.
//

POBJECT_TYPE ExCallbackObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for callback objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpCallbackMapping = {
    STANDARD_RIGHTS_READ ,
    STANDARD_RIGHTS_WRITE | CALLBACK_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE,
    CALLBACK_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

//
// Executive callback object structure definition.
//

typedef struct _CALLBACK_OBJECT {
    ULONG               Signature;
    KSPIN_LOCK          Lock;
    LIST_ENTRY          RegisteredCallbacks;
    BOOLEAN             AllowMultipleCallbacks;
    UCHAR               reserved[3];
} CALLBACK_OBJECT , *PCALLBACK_OBJECT;

//
// Executive callback registration structure definition.
//

typedef struct _CALLBACK_REGISTRATION {
    LIST_ENTRY          Link;
    PCALLBACK_OBJECT    CallbackObject;
    PCALLBACK_FUNCTION  CallbackFunction;
    PVOID               CallbackContext;
    ULONG               Busy;
    BOOLEAN             UnregisterWaiting;
} CALLBACK_REGISTRATION , *PCALLBACK_REGISTRATION;


VOID
ExpDeleteCallback (
    IN PCALLBACK_OBJECT     CallbackObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpInitializeCallbacks)
#pragma alloc_text(PAGE, ExCreateCallback)
#pragma alloc_text(PAGE, ExpDeleteCallback)
#pragma alloc_text(PAGE, ExInitializeCallBack)
#pragma alloc_text(PAGE, ExCompareExchangeCallBack)
#pragma alloc_text(PAGE, ExCallCallBack)
#pragma alloc_text(PAGE, ExFreeCallBack)
#pragma alloc_text(PAGE, ExAllocateCallBack)
#pragma alloc_text(PAGE, ExReferenceCallBackBlock)
#pragma alloc_text(PAGE, ExGetCallBackBlockRoutine)
#pragma alloc_text(PAGE, ExWaitForCallBacks)
#pragma alloc_text(PAGE, ExGetCallBackBlockContext)
#pragma alloc_text(PAGE, ExDereferenceCallBackBlock)
#endif

BOOLEAN
ExpInitializeCallbacks (
    )

/*++

Routine Description:

    This function creates the callback object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the timer object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    UNICODE_STRING unicodeString;
    ULONG           i;
    HANDLE          handle;

    //
    // Initialize the slow referencing lock
    //
    ExInitializePushLock (&ExpCallBackFlush);

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&unicodeString, L"Callback");

    //
    // Create timer object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpCallbackMapping;
    ObjectTypeInitializer.DeleteProcedure = ExpDeleteCallback;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.ValidAccessMask = CALLBACK_ALL_ACCESS;
    Status = ObCreateObjectType(&unicodeString,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExCallbackObjectType);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    RtlInitUnicodeString( &unicodeString, ExpWstrCallback );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        SePublicDefaultSd
        );

    Status = NtCreateDirectoryObject(
                &handle,
                DIRECTORY_ALL_ACCESS,
                &ObjectAttributes
            );

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    NtClose (handle);

    //
    // Initialize event to wait on for Unregisters which occur while
    // notifications are in progress
    //

    KeInitializeEvent (&ExpCallbackEvent, NotificationEvent, 0);

    //
    // Initialize NT global callbacks
    //

    for (i=0; ExpInitializeCallback[i].CallBackObject; i++) {

        //
        // Create named calledback
        //

        RtlInitUnicodeString(&unicodeString, ExpInitializeCallback[i].CallbackName);


        InitializeObjectAttributes(
            &ObjectAttributes,
            &unicodeString,
            OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
        );

        Status = ExCreateCallback (
                        ExpInitializeCallback[i].CallBackObject,
                        &ObjectAttributes,
                        TRUE,
                        TRUE
                        );

        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    return TRUE;
}

NTSTATUS
ExCreateCallback (
    OUT PCALLBACK_OBJECT * CallbackObject,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN Create,
    IN BOOLEAN AllowMultipleCallbacks
    )

/*++

Routine Description:

    This function opens a callback object with the specified callback
    object. If the callback object does not exist or it is a NULL then
    a callback object will be created if create is TRUE. If a callbackobject
    is created it will only support multiple registered callbacks if
    AllowMulitipleCallbacks is TRUE.

Arguments:

    CallbackObject - Supplies a pointer to a variable that will receive the
        Callback object.

    CallbackName  - Supplies a pointer to a object name that will receive the

    Create - Supplies a flag which indicates whether a callback object will
        be created or not .

    AllowMultipleCallbacks - Supplies a flag which indicates only support
        mulitiple registered callbacks.

Return Value:

    NTSTATUS.

--*/

{
    PCALLBACK_OBJECT cbObject;
    NTSTATUS Status;
    HANDLE Handle;

    PAGED_CODE();

    //
    // Initializing cbObject & Handle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    Handle = NULL;
    cbObject = NULL;

    //
    // If named callback, open handle to it
    //

    if (ObjectAttributes->ObjectName) {
        Status = ObOpenObjectByName(ObjectAttributes,
                                    ExCallbackObjectType,
                                    KernelMode,
                                    NULL,
                                    0,   // DesiredAccess,
                                    NULL,
                                    &Handle);
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    //
    // If not opened, check if callback should be created
    //

    if (!NT_SUCCESS(Status) && Create ) {

        Status = ObCreateObject(KernelMode,
                                ExCallbackObjectType,
                                ObjectAttributes,
                                KernelMode,
                                NULL,
                                sizeof(CALLBACK_OBJECT),
                                0,
                                0,
                                (PVOID *)&cbObject );

        if(NT_SUCCESS(Status)){

            //
            // Fill in structure signature
            //

            cbObject->Signature = 'llaC';

            //
            // It will support multiple registered callbacks if
            // AllowMultipleCallbacks is TRUE.
            //

            cbObject->AllowMultipleCallbacks = AllowMultipleCallbacks;

            //
            // Initialize CallbackObject queue.
            //

            InitializeListHead( &cbObject->RegisteredCallbacks );

            //
            // Initialize spinlock
            //

            KeInitializeSpinLock (&cbObject->Lock);


            //
            // Put the object in the root directory
            //

            Status = ObInsertObject (
                     cbObject,
                     NULL,
                     FILE_READ_DATA,
                     0,
                     NULL,
                     &Handle );

        }

    }

    if(NT_SUCCESS(Status)){

        //
        // Add one to callback object reference count.
        //

        Status = ObReferenceObjectByHandle (
                    Handle,
                    0,          // DesiredAccess
                    ExCallbackObjectType,
                    KernelMode,
                    &cbObject,
                    NULL
                    );

        ZwClose (Handle);
    }

    //
    // If success, returns a referenced pointer to the CallbackObject.
    //

    if (NT_SUCCESS(Status)) {
        *CallbackObject = cbObject;
    }

    return Status;
}

VOID
ExpDeleteCallback (
    IN PCALLBACK_OBJECT     CallbackObject
    )
{
#if !DBG
    UNREFERENCED_PARAMETER (CallbackObject);
#endif

    ASSERT (IsListEmpty(&CallbackObject->RegisteredCallbacks));
}

PVOID
ExRegisterCallback (
    IN PCALLBACK_OBJECT   CallbackObject,
    IN PCALLBACK_FUNCTION CallbackFunction,
    IN PVOID CallbackContext
    )

/*++

Routine Description:

    This routine allows a caller to register that it would like to have its
    callback Function invoked when the callback notification call occurs.

Arguments:

    CallbackObject - Supplies a pointer to a CallbackObject.

    CallbackFunction - Supplies a pointer to a function which is to
        be executed when the Callback notification occures.

    CallbackContext - Supplies a pointer to an arbitrary data structure
        that will be passed to the function specified by the CallbackFunction
        parameter.

Return Value:

    Returns handle to callback registration.

--*/
{
    PCALLBACK_REGISTRATION  CallbackRegistration;
    BOOLEAN                 Inserted;
    KIRQL                   OldIrql;

    ASSERT (CallbackFunction);
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Add reference to object
    //

    ObReferenceObject (CallbackObject);

    //
    // Begin by attempting to allocate storage for the CallbackRegistration.
    // one cannot be allocated, return the error status.
    //

    CallbackRegistration = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( CALLBACK_REGISTRATION ),
                                'eRBC'
                                );


    if( !CallbackRegistration ) {
       ObDereferenceObject (CallbackObject);
       return NULL;
    }


    //
    // Initialize the callback packet
    //

    CallbackRegistration->CallbackObject    = CallbackObject;
    CallbackRegistration->CallbackFunction  = CallbackFunction;
    CallbackRegistration->CallbackContext   = CallbackContext;
    CallbackRegistration->Busy              = 0;
    CallbackRegistration->UnregisterWaiting = FALSE;


    Inserted = FALSE;
    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    if( CallbackObject->AllowMultipleCallbacks ||
        IsListEmpty( &CallbackObject->RegisteredCallbacks ) ) {

       //
       // add CallbackRegistration to tail
       //


       Inserted = TRUE;
       InsertTailList( &CallbackObject->RegisteredCallbacks,
                       &CallbackRegistration->Link );
    }

    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

    if (!Inserted) {
       ExFreePool (CallbackRegistration);
       CallbackRegistration = NULL;
    }

    return (PVOID) CallbackRegistration;
}


VOID
ExUnregisterCallback (
    IN PVOID CbRegistration
    )

/*++

Routine Description:

    This function removes the callback registration for the callbacks
    from the list of callback object .

Arguments:

    CallbackRegistration - Pointer to device object for the file system.

Return Value:

    None.

--*/

{
    PCALLBACK_REGISTRATION  CallbackRegistration;
    PCALLBACK_OBJECT        CallbackObject;
    KIRQL                   OldIrql;

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    CallbackRegistration = (PCALLBACK_REGISTRATION) CbRegistration;
    CallbackObject = CallbackRegistration->CallbackObject;

    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    //
    // Wait for registration
    //

    while (CallbackRegistration->Busy) {

        //
        // Set waiting flag, then wait.  (not performance critical - use
        // single global event to wait for any and all unregister waits)
        //

        CallbackRegistration->UnregisterWaiting = TRUE;
        KeClearEvent (&ExpCallbackEvent);
        KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

        KeWaitForSingleObject (
            &ExpCallbackEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
        );

        //
        // Synchronize with callback object and recheck registration busy
        //

        KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);
    }

    //
    // Registration not busy, remove it from the callback object
    //

    RemoveEntryList (&CallbackRegistration->Link);
    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

    //
    // Free memory used for CallbackRegistration
    //

    ExFreePool (CallbackRegistration);

    //
    // Remove reference count on CallbackObject
    //

    ObDereferenceObject (CallbackObject);
}

VOID
ExNotifyCallback (
    IN PCALLBACK_OBJECT     CallbackObject,
    IN PVOID                Argument1,
    IN PVOID                Argument2
    )

/*++

Routine Description:

    This function notifies all registered callbacks .

Arguments:

    CallbackObject - supplies a pointer to the callback object should be
            notified.

    SystemArgument1 - supplies a pointer will be passed to callback function.

    SystemArgument2 - supplies a pointer will be passed to callback function.

Return Value:

    None.

--*/

{
    PLIST_ENTRY             Link;
    PCALLBACK_REGISTRATION  CallbackRegistration;
    KIRQL                   OldIrql;

    if (CallbackObject == NULL || IsListEmpty (&CallbackObject->RegisteredCallbacks)) {
        return ;
    }

    //
    // Synchronize with callback object
    //

    KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

    //
    // call registered callbacks at callers IRQL level
    // ( done if FIFO order of registration )
    //

    if (OldIrql == DISPATCH_LEVEL) {

        //
        // OldIrql is DISPATCH_LEVEL, just invoke all callbacks without
        // releasing the lock
        //

        for (Link = CallbackObject->RegisteredCallbacks.Flink;
             Link != &CallbackObject->RegisteredCallbacks;
             Link = Link->Flink) {

            //
            // Get current registration to notify
            //

            CallbackRegistration = CONTAINING_RECORD (Link,
                                                      CALLBACK_REGISTRATION,
                                                      Link);

            //
            // Notify reigstration
            //

            CallbackRegistration->CallbackFunction(
                       CallbackRegistration->CallbackContext,
                       Argument1,
                       Argument2
                       );

        }   // next registration

    } else {

        //
        // OldIrql is < DISPATCH_LEVEL, the code being called may be pagable
        // and the callback object spinlock needs to be released around
        // each registration callback.
        //

        for (Link = CallbackObject->RegisteredCallbacks.Flink;
             Link != &CallbackObject->RegisteredCallbacks;
             Link = Link->Flink ) {

            //
            // Get current registration to notify
            //

            CallbackRegistration = CONTAINING_RECORD (Link,
                                                      CALLBACK_REGISTRATION,
                                                      Link);

            //
            // If registration is being removed, don't bothing calling it
            //

            if (!CallbackRegistration->UnregisterWaiting) {

                //
                // Set registration busy
                //

                CallbackRegistration->Busy += 1;

                //
                // Release SpinLock and notify this callback
                //

                KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);

                CallbackRegistration->CallbackFunction(
                           CallbackRegistration->CallbackContext,
                           Argument1,
                           Argument2
                           );

                //
                // Synchronize with CallbackObject
                //

                KeAcquireSpinLock (&CallbackObject->Lock, &OldIrql);

                //
                // Remove our busy count
                //

                CallbackRegistration->Busy -= 1;

                //
                // If the registriation removal is pending, kick global
                // event let unregister conitnue
                //

                if (CallbackRegistration->UnregisterWaiting  &&
                    CallbackRegistration->Busy == 0) {
                    KeSetEvent (&ExpCallbackEvent, 0, FALSE);
                }
            }
        }
    }


    //
    // Release callback
    //

    KeReleaseSpinLock (&CallbackObject->Lock, OldIrql);
}

VOID
ExInitializeCallBack (
    IN OUT PEX_CALLBACK CallBack
    )
/*++

Routine Description:

    This function initializes a low overhead callback.

Arguments:

    CallBack - Pointer to the callback structure

Return Value:

    None.

--*/
{
    ExFastRefInitialize (&CallBack->RoutineBlock, NULL);
}


PEX_CALLBACK_ROUTINE_BLOCK
ExAllocateCallBack (
    IN PEX_CALLBACK_FUNCTION Function,
    IN PVOID Context
    )
/*++

Routine Description:

    This function allocates a low overhead callback.

Arguments:

    Function - Routine to issue callbacks to
    Context  - A context value to issue

Return Value:

    PEX_CALLBACK_ROUTINE_BLOCK - Allocated block or NULL if allocation fails.

--*/
{
    PEX_CALLBACK_ROUTINE_BLOCK NewBlock;

    NewBlock = ExAllocatePoolWithTag (PagedPool,
                                      sizeof (EX_CALLBACK_ROUTINE_BLOCK),
                                      'brbC');
    if (NewBlock != NULL) {
        NewBlock->Function = Function;
        NewBlock->Context = Context;
        ExInitializeRundownProtection (&NewBlock->RundownProtect);
    }
    return NewBlock;
}

VOID
ExFreeCallBack (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function destroys a low overhead callback block.

Arguments:

    CallBackBlock - Call back block to destroy

Return Value:

    None.

--*/
{

    ExFreePool (CallBackBlock);
}

VOID
ExWaitForCallBacks (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function waits for all outcalls on the specified
    callback block to complete

Arguments:

    CallBackBlock - Call back block to wait for

Return Value:

    None.

--*/
{
    //
    // Wait for all active callbacks to be finished.
    //
    ExWaitForRundownProtectionRelease (&CallBackBlock->RundownProtect);
}


BOOLEAN
ExCompareExchangeCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK NewBlock,
    IN PEX_CALLBACK_ROUTINE_BLOCK OldBlock
    )
/*++

Routine Description:

    This function assigns, removes or swaps a low overhead callback function.

Arguments:

    CallBack - Callback structure to be modified

    NewBlock - New block to be installed in the callback

    OldBlock - The old block that must be there now to be replaced

Return Value:

    BOOLEAN - TRUE: The swap occured, FALSE: The swap failed

--*/
{
    EX_FAST_REF OldRef;
    PEX_CALLBACK_ROUTINE_BLOCK ReplacedBlock;

    if (NewBlock != NULL) {
        //
        // Add the additional references to the routine block
        //
        if (!ExAcquireRundownProtectionEx (&NewBlock->RundownProtect,
                                           ExFastRefGetAdditionalReferenceCount () + 1)) {
            ASSERTMSG ("Callback block is already undergoing rundown", FALSE);
            return FALSE;
        }
    }

    //
    // Attempt to replace the existing object and balance all the reference counts
    //
    OldRef = ExFastRefCompareSwapObject (&CallBack->RoutineBlock,
                                         NewBlock,
                                         OldBlock);

    ReplacedBlock = ExFastRefGetObject (OldRef);

    //
    // See if the swap occured. If it didn't undo the original references we added.
    // If it did then release remaining references on the original
    //
    if (ReplacedBlock == OldBlock) {
        PKTHREAD CurrentThread;
        //
        // We need to flush out any slow referencers at this point. We do this by
        // acquiring and releasing a lock.
        //
        if (ReplacedBlock != NULL) {
            CurrentThread = KeGetCurrentThread ();

            KeEnterCriticalRegionThread (CurrentThread);

            ExAcquireReleasePushLockExclusive (&ExpCallBackFlush);

            KeLeaveCriticalRegionThread (CurrentThread);

            ExReleaseRundownProtectionEx (&ReplacedBlock->RundownProtect,
                                          ExFastRefGetUnusedReferences (OldRef) + 1);

        }
        return TRUE;
    } else {
        //
        // The swap failed. Remove the addition references if we had added any.
        //
        if (NewBlock != NULL) {
            ExReleaseRundownProtectionEx (&NewBlock->RundownProtect,
                                          ExFastRefGetAdditionalReferenceCount () + 1);
        }
        return FALSE;
    }
}

PEX_CALLBACK_ROUTINE_BLOCK
ExReferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack
    )
/*++

Routine Description:

    This function takes a reference on the call back block inside the
    callback structure.

Arguments:

    CallBack - Call back to obtain the call back block from

Return Value:

    PEX_CALLBACK_ROUTINE_BLOCK - Referenced structure or NULL if these wasn't one

--*/
{
    EX_FAST_REF OldRef;
    PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock;

    //
    // Get a reference to the callback block if we can.
    //
    OldRef = ExFastReference (&CallBack->RoutineBlock);

    //
    // If there is no callback then return
    //
    if (ExFastRefObjectNull (OldRef)) {
        return NULL;
    }
    //
    // If we didn't get a reference then use a lock to get one.
    //
    if (!ExFastRefCanBeReferenced (OldRef)) {
        PKTHREAD CurrentThread;
        CurrentThread = KeGetCurrentThread ();

        KeEnterCriticalRegionThread (CurrentThread);

        ExAcquirePushLockExclusive (&ExpCallBackFlush);

        CallBackBlock = ExFastRefGetObject (CallBack->RoutineBlock);
        if (CallBackBlock && !ExAcquireRundownProtection (&CallBackBlock->RundownProtect)) {
            CallBackBlock = NULL;
        }

        ExReleasePushLockExclusive (&ExpCallBackFlush);

        KeLeaveCriticalRegionThread (CurrentThread);

        if (CallBackBlock == NULL) {
            return NULL;
        }

    } else {
        CallBackBlock = ExFastRefGetObject (OldRef);

        //
        // If we just removed the last reference then attempt fix it up.
        //
        if (ExFastRefIsLastReference (OldRef) && !ExpCallBackReturnRefs) {
            ULONG RefsToAdd;

            RefsToAdd = ExFastRefGetAdditionalReferenceCount ();

            //
            // If we can't add the references then just give up
            //
            if (ExAcquireRundownProtectionEx (&CallBackBlock->RundownProtect,
                                              RefsToAdd)) {
                //
                // Repopulate the cached refs. If this fails we just give them back.
                //
                if (!ExFastRefAddAdditionalReferenceCounts (&CallBack->RoutineBlock,
                                                            CallBackBlock,
                                                            RefsToAdd)) {
                    ExReleaseRundownProtectionEx (&CallBackBlock->RundownProtect,
                                                  RefsToAdd);
                }
            }
        }
    }

    return CallBackBlock;
}

PEX_CALLBACK_FUNCTION
ExGetCallBackBlockRoutine (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function gets the routine associated with a call back block

Arguments:

    CallBackBlock - Call back block to obtain routine for

Return Value:

    PEX_CALLBACK_FUNCTION - The function pointer associated with this block

--*/
{
    return CallBackBlock->Function;
}

PVOID
ExGetCallBackBlockContext (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This function gets the context associated with a call back block

Arguments:

    CallBackBlock - Call back block to obtain context for

Return Value:

    PVOID - The context associated with this block

--*/
{
    return CallBackBlock->Context;
}


VOID
ExDereferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    )
/*++

Routine Description:

    This returns a reference previous obtained on a call back block

Arguments:

    CallBackBlock - Call back block to return reference to

Return Value:

    None

--*/
{
    if (ExpCallBackReturnRefs || !ExFastRefDereference (&CallBack->RoutineBlock, CallBackBlock)) {
        ExReleaseRundownProtection (&CallBackBlock->RundownProtect);
    }
}


NTSTATUS
ExCallCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
/*++

Routine Description:

    This function calls the callback thats inside a callback structure

Arguments:

    CallBack - Call back that needs to be called through

    Argument1 - Caller provided argument to pass on

    Argument2 - Caller provided argument to pass on

Return Value:

    NTSTATUS - Status returned by callback or STATUS_SUCCESS if theres wasn't one

--*/
{
    PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock;
    NTSTATUS Status;

    CallBackBlock = ExReferenceCallBackBlock (CallBack);
    if (CallBackBlock) {
        //
        // Call the function
        //
        Status = CallBackBlock->Function (CallBackBlock->Context, Argument1, Argument2);

        ExDereferenceCallBackBlock (CallBack, CallBackBlock);
    } else {
        Status = STATUS_SUCCESS;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\dbgctrl.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    dbgctrl.c

Abstract:

    This module implements the NtDebugControl service

Author:

    Chuck Lenzmeier (chuckl) 2-Dec-1992

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

#pragma hdrstop
#include "kdp.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtSystemDebugControl)
#endif


NTSTATUS
NtSystemDebugControl (
    IN SYSDBG_COMMAND Command,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function controls the system debugger.

Arguments:

    Command - The command to be executed.  One of the following:

        SysDbgQueryTraceInformation
        SysDbgSetTracepoint
        SysDbgSetSpecialCall
        SysDbgClearSpecialCalls
        SysDbgQuerySpecialCalls

    InputBuffer - A pointer to a buffer describing the input data for
        the request, if any.  The structure of this buffer varies
        depending upon Command.

    InputBufferLength - The length in bytes of InputBuffer.

    OutputBuffer - A pointer to a buffer that is to receive the output
        data for the request, if any.  The structure of this buffer
        varies depending upon Command.

    OutputBufferLength - The length in bytes of OutputBuffer.

    ReturnLength - A optional pointer to a ULONG that is to receive the
        output data length for the request.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The Command parameter did not
            specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the Length field in the
            Parameters buffer was not correct.

        STATUS_ACCESS_VIOLATION - Either the Parameters buffer pointer
            or a pointer within the Parameters buffer specified an
            invalid address.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG length = 0;
    KPROCESSOR_MODE PreviousMode;
    PVOID LockedBuffer = NULL;
    PVOID LockVariable = NULL;

    PreviousMode = KeGetPreviousMode();

    if (!SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Operate within a try block in order to catch errors.
    //

    try {

        //
        // Probe input and output buffers, if previous mode is not
        // kernel.
        //

        if ( PreviousMode != KernelMode ) {

            if ( InputBufferLength != 0 ) {
                ProbeForRead( InputBuffer, InputBufferLength, sizeof(ULONG) );
            }

            if ( OutputBufferLength != 0 ) {
                ProbeForWrite( OutputBuffer, OutputBufferLength, sizeof(ULONG) );
            }

            if ( ARGUMENT_PRESENT(ReturnLength) ) {
                ProbeForWriteUlong( ReturnLength );
            }
        }

        //
        // Switch on the command code.
        //

        switch ( Command ) {

#if i386

        case SysDbgQueryTraceInformation:

            status = KdGetTraceInformation(
                        OutputBuffer,
                        OutputBufferLength,
                        &length
                        );

            break;

        case SysDbgSetTracepoint:

            if ( InputBufferLength != sizeof(DBGKD_MANIPULATE_STATE64) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KdSetInternalBreakpoint( InputBuffer );

            break;

        case SysDbgSetSpecialCall:

            if ( InputBufferLength != sizeof(PVOID) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KdSetSpecialCall( InputBuffer, NULL );

            break;

        case SysDbgClearSpecialCalls:

            KdClearSpecialCalls( );

            break;

        case SysDbgQuerySpecialCalls:

            status = KdQuerySpecialCalls(
                        OutputBuffer,
                        OutputBufferLength,
                        &length
                        );

            break;

#endif

        case SysDbgBreakPoint:
            if (KdDebuggerEnabled) {
                DbgBreakPointWithStatus(DBG_STATUS_DEBUG_CONTROL);
            } else {
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        case SysDbgQueryVersion:
            if (OutputBufferLength != sizeof(DBGKD_GET_VERSION64)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KdpSysGetVersion((PDBGKD_GET_VERSION64)OutputBuffer);
            status = STATUS_SUCCESS;
            break;
            
        case SysDbgReadVirtual:
            if (InputBufferLength != sizeof(SYSDBG_VIRTUAL)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_VIRTUAL Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_VIRTUAL)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }

                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoWriteAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpCopyMemoryChunks((ULONG_PTR)Cmd.Address,
                                             LockedBuffer,
                                             Cmd.Request,
                                             0,
                                             0,
                                             &length);
            }
            break;
            
        case SysDbgWriteVirtual:
            if (InputBufferLength != sizeof(SYSDBG_VIRTUAL)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_VIRTUAL Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_VIRTUAL)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }
                
                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoReadAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpCopyMemoryChunks((ULONG_PTR)Cmd.Address,
                                             LockedBuffer,
                                             Cmd.Request,
                                             0,
                                             MMDBG_COPY_WRITE,
                                             &length);
            }
            break;
            
        case SysDbgReadPhysical:
            if (InputBufferLength != sizeof(SYSDBG_PHYSICAL)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_PHYSICAL Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_PHYSICAL)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }
                
                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoWriteAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpCopyMemoryChunks(Cmd.Address.QuadPart,
                                             LockedBuffer,
                                             Cmd.Request,
                                             0,
                                             MMDBG_COPY_PHYSICAL,
                                             &length);
            }
            break;
            
        case SysDbgWritePhysical:
            if (InputBufferLength != sizeof(SYSDBG_PHYSICAL)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_PHYSICAL Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_PHYSICAL)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }

                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoReadAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpCopyMemoryChunks(Cmd.Address.QuadPart,
                                             LockedBuffer,
                                             Cmd.Request,
                                             0,
                                             MMDBG_COPY_WRITE | MMDBG_COPY_PHYSICAL,
                                             &length);
            }
            break;

        case SysDbgReadControlSpace:
            if (InputBufferLength != sizeof(SYSDBG_CONTROL_SPACE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_CONTROL_SPACE Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_CONTROL_SPACE)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }
                
                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoWriteAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            
                status = KdpSysReadControlSpace(Cmd.Processor,
                                                Cmd.Address,
                                                LockedBuffer,
                                                Cmd.Request,
                                                &length);
            }
            break;

        case SysDbgWriteControlSpace:
            if (InputBufferLength != sizeof(SYSDBG_CONTROL_SPACE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_CONTROL_SPACE Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_CONTROL_SPACE)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }

                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoReadAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                
                status = KdpSysWriteControlSpace(Cmd.Processor,
                                                 Cmd.Address,
                                                 LockedBuffer,
                                                 Cmd.Request,
                                                 &length);
            }
            break;

        case SysDbgReadIoSpace:
            if (InputBufferLength != sizeof(SYSDBG_IO_SPACE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_IO_SPACE Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_IO_SPACE)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }

                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoWriteAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                
                status = KdpSysReadIoSpace(Cmd.InterfaceType,
                                           Cmd.BusNumber,
                                           Cmd.AddressSpace,
                                           Cmd.Address,
                                           LockedBuffer,
                                           Cmd.Request,
                                           &length);
            }
            break;

        case SysDbgWriteIoSpace:
            if (InputBufferLength != sizeof(SYSDBG_IO_SPACE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_IO_SPACE Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_IO_SPACE)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }
                
                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoReadAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                
                status = KdpSysWriteIoSpace(Cmd.InterfaceType,
                                            Cmd.BusNumber,
                                            Cmd.AddressSpace,
                                            Cmd.Address,
                                            LockedBuffer,
                                            Cmd.Request,
                                            &length);
            }
            break;

        case SysDbgReadMsr:
            if (InputBufferLength != sizeof(SYSDBG_MSR)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_MSR Cmd = (PSYSDBG_MSR)InputBuffer;
                
                status = KdpSysReadMsr(Cmd->Msr, &Cmd->Data);
            }
            break;

        case SysDbgWriteMsr:
            if (InputBufferLength != sizeof(SYSDBG_MSR)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                PSYSDBG_MSR Cmd = (PSYSDBG_MSR)InputBuffer;
                
                status = KdpSysWriteMsr(Cmd->Msr, &Cmd->Data);
            }
            break;

        case SysDbgReadBusData:
            if (InputBufferLength != sizeof(SYSDBG_BUS_DATA)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_BUS_DATA Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_BUS_DATA)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }
                
                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoWriteAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                
                status = KdpSysReadBusData(Cmd.BusDataType,
                                           Cmd.BusNumber,
                                           Cmd.SlotNumber,
                                           Cmd.Address,
                                           LockedBuffer,
                                           Cmd.Request,
                                           &length);
            }
            break;

        case SysDbgWriteBusData:
            if (InputBufferLength != sizeof(SYSDBG_BUS_DATA)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            {
                SYSDBG_BUS_DATA Cmd;
                
                //
                // Capture the user information so a malicious app cannot
                // change it on us after we validate it.
                //

                Cmd = *(PSYSDBG_BUS_DATA)InputBuffer;

                if (Cmd.Request == 0) {
                    status = STATUS_ACCESS_VIOLATION;
                    break;
                }
                
                status = ExLockUserBuffer(Cmd.Buffer,
                                          Cmd.Request,
                                          PreviousMode,
                                          IoReadAccess,
                                          &LockedBuffer,
                                          &LockVariable);
                if (!NT_SUCCESS(status)) {
                    break;
                }
                
                status = KdpSysWriteBusData(Cmd.BusDataType,
                                            Cmd.BusNumber,
                                            Cmd.SlotNumber,
                                            Cmd.Address,
                                            LockedBuffer,
                                            Cmd.Request,
                                            &length);
            }
            break;

        case SysDbgCheckLowMemory:
            status = KdpSysCheckLowMemory(0);
            break;

        case SysDbgEnableKernelDebugger:
            status = KdEnableDebugger();
            break;
            
        case SysDbgDisableKernelDebugger:
            status = KdDisableDebugger();
            break;
            
        case SysDbgGetAutoKdEnable:
            if (OutputBufferLength != sizeof(BOOLEAN)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            *(PBOOLEAN)OutputBuffer = KdAutoEnableOnEvent;
            status = STATUS_SUCCESS;
            break;
                
        case SysDbgSetAutoKdEnable:
            if (InputBufferLength != sizeof(BOOLEAN)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (KdPitchDebugger) {
                status = STATUS_ACCESS_DENIED;
            } else {
                KdAutoEnableOnEvent = *(PBOOLEAN)InputBuffer;
                status = STATUS_SUCCESS;
            }
            break;
            
        case SysDbgGetPrintBufferSize:
            if (OutputBufferLength != sizeof(ULONG)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (KdPitchDebugger) {
                *(PULONG)OutputBuffer = 0;
            } else {
                *(PULONG)OutputBuffer = KdPrintBufferSize;
            }
            status = STATUS_SUCCESS;
            break;
                
        case SysDbgSetPrintBufferSize:
            if (InputBufferLength != sizeof(ULONG)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            status = KdSetDbgPrintBufferSize(*(PULONG)InputBuffer);
            break;
            
        case SysDbgGetKdUmExceptionEnable:
            if (OutputBufferLength != sizeof(BOOLEAN)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            // Reverse sense of flag from enable-um-exceptions
            // to ignore-um-exceptions.
            *(PBOOLEAN)OutputBuffer = KdIgnoreUmExceptions ? FALSE : TRUE;
            status = STATUS_SUCCESS;
            break;
                
        case SysDbgSetKdUmExceptionEnable:
            if (InputBufferLength != sizeof(BOOLEAN)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (KdPitchDebugger) {
                status = STATUS_ACCESS_DENIED;
            } else {
                // Reverse sense of flag from enable-um-exceptions
                // to ignore-um-exceptions.
                KdIgnoreUmExceptions = *(PBOOLEAN)InputBuffer ? FALSE : TRUE;
                status = STATUS_SUCCESS;
            }
            break;
            
        default:

            //
            // Invalid Command.
            //

            status = STATUS_INVALID_INFO_CLASS;
        }

        if ( ARGUMENT_PRESENT(ReturnLength) ) {
            *ReturnLength = length;
        }
    }

    except ( EXCEPTION_EXECUTE_HANDLER ) {

        status = GetExceptionCode();

    }

    if (LockedBuffer) {
        ExUnlockUserBuffer(LockVariable);
    }
    
    return status;

} // NtSystemDebugControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\event.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    event.c

Abstract:

   This module implements the executive event object. Functions are provided
   to create, open, set, reset, pulse, and query event objects.

Author:

    David N. Cutler (davec) 8-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Temporary so boost is patchable
//

ULONG ExpEventBoost = EVENT_INCREMENT;

//
// Address of event object type descriptor.
//

POBJECT_TYPE ExEventObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for event objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpEventMapping = {
    STANDARD_RIGHTS_READ |
        EVENT_QUERY_STATE,
    STANDARD_RIGHTS_WRITE |
        EVENT_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    EVENT_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpEventInitialization)
#pragma alloc_text(PAGE, NtClearEvent)
#pragma alloc_text(PAGE, NtCreateEvent)
#pragma alloc_text(PAGE, NtOpenEvent)
#pragma alloc_text(PAGE, NtPulseEvent)
#pragma alloc_text(PAGE, NtQueryEvent)
#pragma alloc_text(PAGE, NtResetEvent)
#pragma alloc_text(PAGE, NtSetEvent)
#pragma alloc_text(PAGE, NtSetEventBoostPriority)
#endif

BOOLEAN
ExpEventInitialization (
    )

/*++

Routine Description:

    This function creates the event object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the event object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Event");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpEventMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KEVENT);
    ObjectTypeInitializer.ValidAccessMask = EVENT_ALL_ACCESS;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExEventObjectType);

    //
    // If the event object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtClearEvent (
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       KeGetPreviousMode(),
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled and dereference event object.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        KeClearEvent((PKEVENT)Event);
        ObDereferenceObject(Event);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    )

/*++

Routine Description:

    This function creates an event object, sets it initial state to the
    specified value, and opens a handle to the object with the specified
    desired access.

Arguments:

    EventHandle - Supplies a pointer to a variable that will receive the
        event object handle.

    DesiredAccess - Supplies the desired types of access for the event object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    EventType - Supplies the type of the event (autoclearing or notification).

    InitialState - Supplies the initial state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create an event object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    PreviousMode = KeGetPreviousMode();

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if ((EventType != NotificationEvent) && (EventType != SynchronizationEvent)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate event object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExEventObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(KEVENT),
                            0,
                            0,
                            (PVOID *)&Event);

    //
    // If the event object was successfully allocated, then initialize the
    // event object and attempt to insert the event object in the current
    // process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeEvent((PKEVENT)Event, EventType, InitialState);
        Status = ObInsertObject(Event,
                                NULL,
                                DesiredAccess,
                                0,
                                (PVOID *)NULL,
                                &Handle);

        //
        // If the event object was successfully inserted in the current
        // process' handle table, then attempt to write the event object
        // handle value. If the write attempt fails, then do not report
        // an error. When the caller attempts to access the handle value,
        // an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *EventHandle = Handle;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *EventHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an event object with the specified
    desired access.

Arguments:

    EventHandle - Supplies a pointer to a variable that will receive the
        event object handle.

    DesiredAccess - Supplies the desired types of access for the event object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the event object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the event object with the specified desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExEventObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the event object
    // handle value. If the write attempt fails, then do not report an
    // error. When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *EventHandle = Handle;

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            *EventHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtPulseEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state, attempts to
    satisfy as many waits as possible, and then resets the state of the
    event object to Not-Signaled.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous state address if
    // specified, reference the event object, and pulse the event object. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the reference object by
    // handle routine.
    //

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (ARGUMENT_PRESENT(PreviousState) && (PreviousMode != KernelMode)) {
        try {
            ProbeForWriteLong(PreviousState);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then pulse the event object,
    // dereference event object, and write the previous state value if
    // specified. If the write of the previous state fails, then do not
    // report an error. When the caller attempts to access the previous
    // state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        State = KePulseEvent((PKEVENT)Event, ExpEventBoost, FALSE);
        ObDereferenceObject(Event);
        if (ARGUMENT_PRESENT(PreviousState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousState = State;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *PreviousState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInformationClass,
    OUT PVOID EventInformation,
    IN ULONG EventInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of an event object and returns the
    requested information in the specified record structure.

Arguments:

    EventHandle - Supplies a handle to an event object.

    EventInformationClass - Supplies the class of information being requested.

    EventInformation - Supplies a pointer to a record that is to receive the
        requested information.

    EventInformationLength - Supplies the length of the record that is to
        receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that is to
        receive the actual length of information that is returned.

Return Value:

    NTSTATUS.

--*/

{

    PKEVENT Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;
    EVENT_TYPE EventType;

    //
    // Check argument validity.
    //

    if (EventInformationClass != EventBasicInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (EventInformationLength != sizeof(EVENT_BASIC_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Establish an exception handler, probe the output arguments, reference
    // the event object, and return the specified information. If the probe
    // fails, then return the exception code as the service status. Otherwise
    // return the status value returned by the reference object by handle
    // routine.
    //

    //
    // Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {

            ProbeForWrite(EventInformation,
                          sizeof(EVENT_BASIC_INFORMATION),
                          sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_QUERY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       (PVOID *)&Event,
                                       NULL);

    //
    // If the reference was successful, then read the current state of
    // the event object, deference event object, fill in the information
    // structure, and return the length of the information structure if
    // specified. If the write of the event information or the return
    // length fails, then do not report an error. When the caller accesses
    // the information structure or length an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        State = KeReadStateEvent(Event);
        EventType = Event->Header.Type;
        ObDereferenceObject(Event);

        if (PreviousMode != KernelMode) {
            try {
                ((PEVENT_BASIC_INFORMATION)EventInformation)->EventType = EventType;
                ((PEVENT_BASIC_INFORMATION)EventInformation)->EventState = State;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(EVENT_BASIC_INFORMATION);
                }

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            ((PEVENT_BASIC_INFORMATION)EventInformation)->EventType = EventType;
            ((PEVENT_BASIC_INFORMATION)EventInformation)->EventState = State;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(EVENT_BASIC_INFORMATION);
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtResetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Not-Signaled state.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous state address if
    // specified, reference the event object, and reset the event object. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the reference object by
    // handle routine.
    //

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if ((ARGUMENT_PRESENT(PreviousState)) && (PreviousMode != KernelMode)) {

        try {
            ProbeForWriteLong(PreviousState);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       PreviousMode,
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then set the state of the event
    // object to Not-Signaled, dereference event object, and write the
    // previous state value if specified. If the write of the previous
    // state fails, then do not report an error. When the caller attempts
    // to access the previous state value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        PERFINFO_DECLARE_OBJECT(Event);
        State = KeResetEvent((PKEVENT)Event);
        ObDereferenceObject(Event);

        if (ARGUMENT_PRESENT(PreviousState)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousState = State;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *PreviousState = State;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetEvent (
    IN HANDLE EventHandle,
    OUT PLONG PreviousState OPTIONAL
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state and attempts to
    satisfy as many waits as possible.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Event;
    KPROCESSOR_MODE PreviousMode;
    LONG State;
    NTSTATUS Status;
#if DBG

    //
    // Sneaky trick here to catch sleazy apps (csrss) that erroneously call
    // NtSetEvent on an event that happens to be somebody else's
    // critical section. Only allow setting a protected handle if the low
    // bit of PreviousState is set.
    //
    OBJECT_HANDLE_INFORMATION HandleInfo;

#endif

    //
    // Establish an exception handler, probe the previous state address if
    // specified, reference the event object, and set the event object. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the reference object by
    // handle routine.
    //

    //
    // Get previous processor mode and probe previous state address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    try {

#if DBG
        if ((PreviousMode != KernelMode) &&
            (ARGUMENT_PRESENT(PreviousState)) &&
            (PreviousState != (PLONG)1)) {
            ProbeForWriteLong(PreviousState);
        }
#else
        if ((PreviousMode != KernelMode) && (ARGUMENT_PRESENT(PreviousState))) {
            ProbeForWriteLong(PreviousState);
        }
#endif

        //
        // Reference event object by handle.
        //

#if DBG
        Status = ObReferenceObjectByHandle(EventHandle,
                                           EVENT_MODIFY_STATE,
                                           ExEventObjectType,
                                           PreviousMode,
                                           &Event,
                                           &HandleInfo);
        if (NT_SUCCESS(Status)) {

            if ((HandleInfo.HandleAttributes & 1) &&
                (PreviousState != (PLONG)1)) {
#if 0
                //
                // This is a protected handle. If the low bit of PreviousState is NOT set,
                // break into the debugger
                //

                DbgPrint("NtSetEvent: Illegal call to NtSetEvent on a protected handle\n");
                DbgBreakPoint();
                PreviousState = NULL;
#endif
            }
        } else {
            if ((KeGetPreviousMode() != KernelMode) &&
                (EventHandle != NULL) &&
                ((NtGlobalFlag & FLG_ENABLE_CLOSE_EXCEPTIONS) ||
                 (PsGetCurrentProcess()->DebugPort != NULL))) {

                if (!KeIsAttachedProcess()) {
                    KeRaiseUserException (STATUS_INVALID_HANDLE);
                }
                return Status;
            }
        }
#else
        Status = ObReferenceObjectByHandle(EventHandle,
                                           EVENT_MODIFY_STATE,
                                           ExEventObjectType,
                                           PreviousMode,
                                           &Event,
                                           NULL);
#endif

        //
        // If the reference was successful, then set the event object to the
        // Signaled state, dereference event object, and write the previous
        // state value if specified. If the write of the previous state fails,
        // then do not report an error. When the caller attempts to access the
        // previous state value, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            PERFINFO_DECLARE_OBJECT(Event);
            State = KeSetEvent((PKEVENT)Event, ExpEventBoost, FALSE);
            ObDereferenceObject(Event);
            if (ARGUMENT_PRESENT(PreviousState)) {
                try {
                    *PreviousState = State;

                } except(ExSystemExceptionFilter()) {
                }
            }
        }

    //
    // If an exception occurs during the probe of the previous state, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetEventBoostPriority (
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    This function sets an event object to a Signaled state and performs
    a special priority boost operation.

    N.B. This service can only be performed on synchronization events.

Arguments:

    EventHandle - Supplies a handle to an event object.

    PreviousState - Supplies an optional pointer to a variable that will
        receive the previous state of the event object.

Return Value:

    NTSTATUS.

--*/

{

    PKEVENT Event;
    NTSTATUS Status;

    //
    // Reference event object by handle.
    //

    Status = ObReferenceObjectByHandle(EventHandle,
                                       EVENT_MODIFY_STATE,
                                       ExEventObjectType,
                                       KeGetPreviousMode(),
                                       &Event,
                                       NULL);

    //
    // If the reference was successful, then check the type of event object.
    // If the event object is a notification event, then return an object
    // type mismatch status. Otherwise, set the specified event and boost
    // the unwaited thread priority as appropriate.
    //

    if (NT_SUCCESS(Status)) {
        if (Event->Header.Type == NotificationEvent) {
            Status = STATUS_OBJECT_TYPE_MISMATCH;

        } else {
            KeSetEventBoostPriority(Event, NULL);
        }

        ObDereferenceObject(Event);
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\exatom.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    exatom.c

Abstract:

    This file contains functions for manipulating global atom tables
    stored in kernel space.

Author:

    Steve Wood (stevewo) 13-Dec-1995

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

//
//  Local Procedure prototype
//

PVOID
ExpGetGlobalAtomTable (
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtAddAtom)
#pragma alloc_text(PAGE, NtFindAtom)
#pragma alloc_text(PAGE, NtDeleteAtom)
#pragma alloc_text(PAGE, NtQueryInformationAtom)
#pragma alloc_text(PAGE, ExpGetGlobalAtomTable)
#endif

#define COPY_STACK_SIZE         128


NTSYSAPI
NTSTATUS
NTAPI
NtAddAtom (
    IN PWSTR AtomName,
    IN ULONG Length,
    OUT PRTL_ATOM Atom OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    RTL_ATOM ReturnAtom;
    PVOID AtomTable = ExpGetGlobalAtomTable();
    KPROCESSOR_MODE PreviousMode;
    PWSTR CapturedAtomNameBuffer;
    ULONG AllocLength;
    UCHAR StackArray[COPY_STACK_SIZE];

    PAGED_CODE();

    if (AtomTable == NULL) {

        return STATUS_ACCESS_DENIED;
    }

    if (Length > (RTL_ATOM_MAXIMUM_NAME_LENGTH * sizeof(WCHAR))) {

        return STATUS_INVALID_PARAMETER;
    }

    PreviousMode = KeGetPreviousMode();
    CapturedAtomNameBuffer = AtomName;

    Status = STATUS_SUCCESS;

    if (PreviousMode != KernelMode) {

        if (ARGUMENT_PRESENT (Atom)) {
            try {
                ProbeForWriteUshort( Atom );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
        }

        if (ARGUMENT_PRESENT (AtomName)) {

            AllocLength = (Length + sizeof( UNICODE_NULL ))&~(sizeof (WCHAR)-1);

            try {
                ProbeForRead( AtomName, Length, sizeof( WCHAR ) );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }

            if (AllocLength <= COPY_STACK_SIZE) {
                CapturedAtomNameBuffer = (PWSTR) StackArray;
            }
            else {
                CapturedAtomNameBuffer
                    = ExAllocatePoolWithQuotaTag(PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                                 AllocLength,
                                                 'motA');

                if (CapturedAtomNameBuffer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            try {
                RtlCopyMemory( CapturedAtomNameBuffer, AtomName, Length );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                if (CapturedAtomNameBuffer != (PWSTR) StackArray) {
                    ExFreePool (CapturedAtomNameBuffer);
                }
                return GetExceptionCode();
            }

            CapturedAtomNameBuffer[Length / sizeof (WCHAR)] = '\0';
        }
    }

    if (NT_SUCCESS (Status)) {

        Status = RtlAddAtomToAtomTable (AtomTable, CapturedAtomNameBuffer, &ReturnAtom);

        if ((ARGUMENT_PRESENT (Atom)) && (NT_SUCCESS (Status))) {

            if (PreviousMode != KernelMode) {
                try {

                    *Atom = ReturnAtom;

                } except (EXCEPTION_EXECUTE_HANDLER) {

                    Status = GetExceptionCode();
                }
            }
            else {
                *Atom = ReturnAtom;
            }
        }
    }

    if ((CapturedAtomNameBuffer != AtomName) &&
        (CapturedAtomNameBuffer != (PWSTR) StackArray)) {
        ExFreePool (CapturedAtomNameBuffer);
    }

    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
NtFindAtom (
    IN PWSTR AtomName,
    IN ULONG Length,
    OUT PRTL_ATOM Atom OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    RTL_ATOM ReturnAtom;
    PVOID AtomTable = ExpGetGlobalAtomTable();
    KPROCESSOR_MODE PreviousMode;
    PWSTR CapturedAtomNameBuffer;
    ULONG AllocLength;
    UCHAR StackArray[COPY_STACK_SIZE];

    PAGED_CODE();

    if (AtomTable == NULL) {

        return STATUS_ACCESS_DENIED;
    }

    if (Length > (RTL_ATOM_MAXIMUM_NAME_LENGTH * sizeof(WCHAR))) {

        return STATUS_INVALID_PARAMETER;
    }

    PreviousMode = KeGetPreviousMode();
    CapturedAtomNameBuffer = AtomName;

    Status = STATUS_SUCCESS;

    if (PreviousMode != KernelMode) {

        if (ARGUMENT_PRESENT (Atom)) {
            try {
                ProbeForWriteUshort (Atom);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
        }

        if (ARGUMENT_PRESENT (AtomName)) {

            AllocLength = (Length + sizeof( UNICODE_NULL ))&~(sizeof (WCHAR)-1);

            try {
                ProbeForRead (AtomName, Length, sizeof (WCHAR));
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }

            if (AllocLength <= COPY_STACK_SIZE) {
                CapturedAtomNameBuffer = (PWSTR) StackArray;
            }
            else {
                CapturedAtomNameBuffer
                    = ExAllocatePoolWithQuotaTag(PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                                 AllocLength,
                                                 'motA');

                if (CapturedAtomNameBuffer == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            try {
                RtlCopyMemory (CapturedAtomNameBuffer, AtomName, Length);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                if (CapturedAtomNameBuffer != (PWSTR) StackArray) {
                    ExFreePool (CapturedAtomNameBuffer);
                }
                return GetExceptionCode();
            }

            CapturedAtomNameBuffer[Length / sizeof (WCHAR)] = '\0';
        }
    }

    if (NT_SUCCESS( Status )) {

        Status = RtlLookupAtomInAtomTable (AtomTable, CapturedAtomNameBuffer, &ReturnAtom);

        if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(Atom)) {

            try {

                *Atom = ReturnAtom;

            } except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();
            }
        }
    }

    if ((CapturedAtomNameBuffer != AtomName) &&
        (CapturedAtomNameBuffer != (PWSTR) StackArray)) {
        ExFreePool (CapturedAtomNameBuffer);
    }

    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
NtDeleteAtom (
    IN RTL_ATOM Atom
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PVOID AtomTable = ExpGetGlobalAtomTable();

    PAGED_CODE();

    if (AtomTable == NULL) {

        return STATUS_ACCESS_DENIED;
    }

    Status = RtlDeleteAtomFromAtomTable( AtomTable, Atom );

    return Status;
}


NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationAtom(
    IN RTL_ATOM Atom,
    IN ATOM_INFORMATION_CLASS AtomInformationClass,
    OUT PVOID AtomInformation,
    IN ULONG AtomInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    ULONG RequiredLength;
    ULONG UsageCount;
    ULONG NameLength;
    ULONG AtomFlags;
    PATOM_BASIC_INFORMATION BasicInfo;
    PATOM_TABLE_INFORMATION TableInfo;
    PVOID AtomTable = ExpGetGlobalAtomTable();

    PAGED_CODE();

    if (AtomTable == NULL) {
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Assume successful completion.
    //

    Status = STATUS_SUCCESS;

    try {

        //
        //  Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();

        if (PreviousMode != KernelMode) {

            ProbeForWrite( AtomInformation,
                           AtomInformationLength,
                           sizeof( ULONG ));

            if (ARGUMENT_PRESENT( ReturnLength )) {

                ProbeForWriteUlong( ReturnLength );
            }
        }

        RequiredLength = 0;

        switch (AtomInformationClass) {

        case AtomBasicInformation:

            RequiredLength = FIELD_OFFSET( ATOM_BASIC_INFORMATION, Name );

            if (AtomInformationLength < RequiredLength) {

                return STATUS_INFO_LENGTH_MISMATCH;
            }

            BasicInfo = (PATOM_BASIC_INFORMATION)AtomInformation;
            UsageCount = 0;
            NameLength = AtomInformationLength - RequiredLength;
            BasicInfo->Name[ 0 ] = UNICODE_NULL;

            Status = RtlQueryAtomInAtomTable( AtomTable,
                                              Atom,
                                              &UsageCount,
                                              &AtomFlags,
                                              &BasicInfo->Name[0],
                                              &NameLength );

            if (NT_SUCCESS(Status)) {

                BasicInfo->UsageCount = (USHORT)UsageCount;
                BasicInfo->Flags = (USHORT)AtomFlags;
                BasicInfo->NameLength = (USHORT)NameLength;
                RequiredLength += NameLength + sizeof( UNICODE_NULL );
            }

            break;

        case AtomTableInformation:

            RequiredLength = FIELD_OFFSET( ATOM_TABLE_INFORMATION, Atoms );

            if (AtomInformationLength < RequiredLength) {

                return STATUS_INFO_LENGTH_MISMATCH;
            }

            TableInfo = (PATOM_TABLE_INFORMATION)AtomInformation;

            Status = RtlQueryAtomsInAtomTable( AtomTable,
                                               (AtomInformationLength - RequiredLength) / sizeof( RTL_ATOM ),
                                               &TableInfo->NumberOfAtoms,
                                               &TableInfo->Atoms[0] );

            if (NT_SUCCESS(Status)) {

                RequiredLength += TableInfo->NumberOfAtoms * sizeof( RTL_ATOM );
            }

            break;

        default:

            Status = STATUS_INVALID_INFO_CLASS;

            break;
        }

        if (ARGUMENT_PRESENT( ReturnLength )) {

            *ReturnLength = RequiredLength;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    return Status;
}


//
//  Local support routine
//

PKWIN32_GLOBALATOMTABLE_CALLOUT ExGlobalAtomTableCallout;

PVOID
ExpGetGlobalAtomTable (
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (ExGlobalAtomTableCallout != NULL) {

        return ((*ExGlobalAtomTableCallout)());

    }

#if DBG
    DbgPrint( "EX: ExpGetGlobalAtomTable is about to return NULL!\n" );
    DbgBreakPoint();
#endif
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\delay.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    delay.c

Abstract:

   This module implements the executive delay execution system service.

Author:

    David N. Cutler (davec) 13-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtDelayExecution)
#endif


NTSTATUS
NtDelayExecution (
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER DelayInterval
    )

/*++

Routine Description:

    This function delays the execution of the current thread for the specified
    interval of time.

Arguments:

    Alertable - Supplies a boolean value that specifies whether the delay
        is alertable.

    DelayInterval - Supplies the absolute of relative time over which the
        delay is to occur.

Return Value:

    NTSTATUS.

--*/

{

    LARGE_INTEGER Interval;
    KPROCESSOR_MODE PreviousMode;

    //
    // Establish an exception handler and probe delay interval address. If
    // the probe fails, then return the exception code as the service status.
    // Otherwise return the status value returned by the delay execution
    // routine.
    //
    // Get previous processor mode and probe delay interval address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {
            ProbeForReadSmallStructure (DelayInterval, sizeof(LARGE_INTEGER), sizeof(ULONG));
            Interval = *DelayInterval;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }
    else {
        Interval = *DelayInterval;
    }

    //
    // Delay execution for the specified amount of time.
    //

    return KeDelayExecutionThread(PreviousMode, Alertable, &Interval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\eventpr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eventpr.c

Abstract:

    This module implements the executive event pair object.  Functions
    are provided to create, open, waitlow, waithi, setlow, sethi,
    sethiwaitlo, setlowaithi.

Author:

    Mark Lucovsky (markl) 18-Oct-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Define performance counters.
//

ULONG EvPrSetHigh = 0;
ULONG EvPrSetLow = 0;

//
// Address of event pair object type descriptor.
//

POBJECT_TYPE ExEventPairObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for event pair objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpEventPairMapping = {
    STANDARD_RIGHTS_READ |
        SYNCHRONIZE,
    STANDARD_RIGHTS_WRITE |
        SYNCHRONIZE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    EVENT_PAIR_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpEventPairInitialization)
#pragma alloc_text(PAGE, NtCreateEventPair)
#pragma alloc_text(PAGE, NtOpenEventPair)
#pragma alloc_text(PAGE, NtWaitLowEventPair)
#pragma alloc_text(PAGE, NtWaitHighEventPair)
#pragma alloc_text(PAGE, NtSetLowWaitHighEventPair)
#pragma alloc_text(PAGE, NtSetHighWaitLowEventPair)
#pragma alloc_text(PAGE, NtSetHighEventPair)
#pragma alloc_text(PAGE, NtSetLowEventPair)
#endif

BOOLEAN
ExpEventPairInitialization (
    )

/*++

Routine Description:

    This function creates the event pair object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the event pair object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"EventPair");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpEventPairMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(EEVENT_PAIR);
    ObjectTypeInitializer.ValidAccessMask = EVENT_PAIR_ALL_ACCESS;
    ObjectTypeInitializer.UseDefaultObject = TRUE;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExEventPairObjectType);

    //
    // If the event pair object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateEventPair (
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    )

/*++

Routine Description:

    This function creates an event pair object, sets it initial state,
    and opens a handle to the object with the specified desired access.

Arguments:

    EventPairHandle - Supplies a pointer to a variable that will receive the
        event pair object handle.

    DesiredAccess - Supplies the desired types of access for the event
        pair object.

    ObjectAttributes - Supplies a pointer to an object attributes
        structure.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create an event object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventPairHandle);
        } except (ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Allocate event object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExEventPairObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(EEVENT_PAIR),
                            0,
                            0,
                            (PVOID *)&EventPair);

    //
    // If the event pair object was successfully allocated, then
    // initialize the event pair object and attempt to insert the
    // event pair object in the current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeEventPair(&EventPair->KernelEventPair);
        Status = ObInsertObject((PVOID)EventPair,
                                NULL,
                                DesiredAccess,
                                0,
                                (PVOID *)NULL,
                                &Handle);

        //
        // If the event pair object was successfully inserted in the
        // current process' handle table, then attempt to write the
        // event pair object handle value.  If the write attempt
        // fails, then do not report an error.  When the caller
        // attempts to access the handle value, an access violation
        // will occur.

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *EventPairHandle = Handle;

                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *EventPairHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenEventPair(
    OUT PHANDLE EventPairHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to an event pair object with the specified
    desired access.

Arguments:

    EventPairHandle - Supplies a pointer to a variable that will receive
        the event pair object handle.

    DesiredAccess - Supplies the desired types of access for the event
        pair object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the event object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(EventPairHandle);
        } except (ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the event pair object with the specified
    // desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExEventPairObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the event
    // pair object handle value.  If the write attempt fails, then do
    // not report an error.  When the caller attempts to access the
    // handle value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *EventPairHandle = Handle;

            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            *EventPairHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtWaitLowEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function waits on the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        Status = KeWaitForLowEventPair(&EventPair->KernelEventPair,
                                       PreviousMode,
                                       FALSE,
                                       NULL);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtWaitHighEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function waits on the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        Status = KeWaitForHighEventPair(&EventPair->KernelEventPair,
                                        PreviousMode,
                                        FALSE,
                                        NULL);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetLowWaitHighEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the low event of an event pair and then
    waits on the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        EvPrSetLow += 1;
        Status = KeSetLowWaitHighEventPair(&EventPair->KernelEventPair,
                                           PreviousMode);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetHighWaitLowEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the high event of an event pair and then
    waits on the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        EvPrSetHigh += 1;
        Status = KeSetHighWaitLowEventPair(&EventPair->KernelEventPair,
                                           PreviousMode);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetLowEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the low event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        EvPrSetLow += 1;
        KeSetLowEventPair(&EventPair->KernelEventPair,
                          EVENT_PAIR_INCREMENT,FALSE);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetHighEventPair(
    IN HANDLE EventPairHandle
    )

/*++

Routine Description:

    This function sets the high event of an event pair object.

Arguments:

    EventPairHandle - Supplies a handle to an event pair object.

Return Value:

    NTSTATUS.

--*/

{

    PEEVENT_PAIR EventPair;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Reference event pair object by handle.
    //

    PreviousMode = KeGetPreviousMode();
    Status = ObReferenceObjectByHandle(EventPairHandle,
                                       SYNCHRONIZE,
                                       ExEventPairObjectType,
                                       PreviousMode,
                                       (PVOID *)&EventPair,
                                       NULL);

    //
    // If the reference was successful, then wait on the Low event
    // of the event pair.
    //

    if (NT_SUCCESS(Status)) {
        EvPrSetHigh += 1;
        KeSetHighEventPair(&EventPair->KernelEventPair,
                           EVENT_PAIR_INCREMENT,FALSE);

        ObDereferenceObject(EventPair);
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\exhotp.c ===
/*

Copyright (c) 2001  Microsoft Corporation

File name:

    hotpatch.c
   
Author:
    
    Adrian Marinescu (adrmarin)  Nov 20 2001

Environment:

    Kernel mode only.

Revision History:

*/

#include "exp.h"
#pragma hdrstop

NTSTATUS
ExpSyncRenameFiles(
    IN HANDLE FileHandle1,
    OUT PIO_STATUS_BLOCK IoStatusBlock1,
    IN PFILE_RENAME_INFORMATION RenameInformation1,
    IN ULONG RenameInformationLength1,
    IN HANDLE FileHandle2,
    OUT PIO_STATUS_BLOCK IoStatusBlock2,
    IN PFILE_RENAME_INFORMATION RenameInformation2,
    IN ULONG RenameInformationLength2
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE,ExApplyCodePatch)
#pragma alloc_text(PAGE,ExpSyncRenameFiles)

#endif

#define EXP_MAX_HOTPATCH_INFO_SIZE PAGE_SIZE

//
//  Privileged flags define the operations where we require privilege check 
//

#define FLG_HOTPATCH_PRIVILEGED_FLAGS (FLG_HOTPATCH_KERNEL | FLG_HOTPATCH_RELOAD_NTDLL | FLG_HOTPATCH_RENAME_INFO | FLG_HOTPATCH_MAP_ATOMIC_SWAP)

//
//  Exclusive flags define the flags that cannot be used in combinations with other flags
//

#define FLG_HOTPATCH_EXCLUSIVE_FLAGS (FLG_HOTPATCH_RELOAD_NTDLL | FLG_HOTPATCH_RENAME_INFO | FLG_HOTPATCH_MAP_ATOMIC_SWAP)

volatile LONG ExHotpSyncRenameSequence = 0;


NTSTATUS
ExpSyncRenameFiles(
    IN HANDLE FileHandle1,
    OUT PIO_STATUS_BLOCK IoStatusBlock1,
    IN PFILE_RENAME_INFORMATION RenameInformation1,
    IN ULONG RenameInformationLength1,
    IN HANDLE FileHandle2,
    OUT PIO_STATUS_BLOCK IoStatusBlock2,
    IN PFILE_RENAME_INFORMATION RenameInformation2,
    IN ULONG RenameInformationLength2
    )

/*++

Routine Description:

    This service changes the provided information about a specified file.  The
    information that is changed is determined by the FileInformationClass that
    is specified.  The new information is taken from the FileInformation buffer.

Arguments:

    FileHandle1 - Supplies a first handle to the file to be renamed.
    
    IoStatusBlock1 - Address of the caller's I/O status block.

    FileInformation1 - Supplies the new name for the first file.

    RenameInformationLength1 - Supplies the lengtd of the rename information buffer
    
    FileHandle2 - Supplies a second handle to the file to be renamed.
    
    IoStatusBlock2 - Address of the second caller's I/O status block.

    FileInformation2 - Supplies the new name for the second file.

    RenameInformationLength2 - Supplies the lengtd of the rename information buffer
    
Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS Status;
    LONG CapturedSeqNumber;

    PAGED_CODE();
    
    CapturedSeqNumber = ExHotpSyncRenameSequence;

    if ((CapturedSeqNumber & 1)
            ||
        InterlockedCompareExchange(&ExHotpSyncRenameSequence, CapturedSeqNumber + 1, CapturedSeqNumber) != CapturedSeqNumber) {

        return STATUS_UNSUCCESSFUL;
    }

    Status = NtSetInformationFile( FileHandle1,
                                   IoStatusBlock1,
                                   RenameInformation1,
                                   RenameInformationLength1,
                                   FileRenameInformation);

    if ( NT_SUCCESS(Status) ) {

        Status = NtSetInformationFile( FileHandle2,
                                       IoStatusBlock2,
                                       RenameInformation2,
                                       RenameInformationLength2,
                                       FileRenameInformation);
    }

    InterlockedIncrement(&ExHotpSyncRenameSequence);

    return Status;
}


NTSTATUS
ExApplyCodePatch (
    IN PVOID    PatchInfoPtr,
    IN SIZE_T   PatchSize
    )

/*++

Routine Description:

    This routine is handling the common tasks to both user-mode
    and kernel-mode patching

Arguments:

    PatchInfoPtr - Pointer to PSYSTEM_HOTPATCH_CODE_INFORMATION structure
        describing the patch. The pointer is user-mode.
        
    PatchSize    - the size of the PatchInfoPtr buffer passed in
    
Return Value:

    NTSTATUS.

--*/

{
    PSYSTEM_HOTPATCH_CODE_INFORMATION PatchInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    KPROCESSOR_MODE PreviousMode;

    //
    //  Allocate a temporary non-paged buffer to capture the used information
    //  Restrict the size of the data to be patched to EXP_MAX_HOTPATCH_INFO_SIZE
    //  The buffer must be non-paged because the information is accessed at DPC of higher level
    //

    if ( (PatchSize > (sizeof(SYSTEM_HOTPATCH_CODE_INFORMATION) + EXP_MAX_HOTPATCH_INFO_SIZE))
            ||
         (PatchSize < sizeof(SYSTEM_HOTPATCH_CODE_INFORMATION)) ) {

        return STATUS_INVALID_PARAMETER;
    }

    PatchInfo = ExAllocatePoolWithQuotaTag (NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, 
                                            PatchSize, 
                                            'PtoH');

    if (PatchInfo == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    PreviousMode = KeGetPreviousMode ();

    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        if (PreviousMode != KernelMode) {

            ProbeForRead (PatchInfoPtr, PatchSize, sizeof(ULONG_PTR));
        }

        RtlCopyMemory (PatchInfo, PatchInfoPtr, PatchSize);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode ();
    }
    
    if (!NT_SUCCESS(Status)) {

        ExFreePool (PatchInfo);

        return Status;
    }

    if (PatchInfo->Flags & FLG_HOTPATCH_PRIVILEGED_FLAGS) {
        
        if (!SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)
                ||
            !SeSinglePrivilegeCheck (SeLoadDriverPrivilege, PreviousMode)) {

            ExFreePool (PatchInfo);

            return STATUS_ACCESS_DENIED;
        }
    }

    if (PatchInfo->Flags & FLG_HOTPATCH_EXCLUSIVE_FLAGS) {

        //
        //  Special hotpatch operation
        //
        
        if (PatchInfo->Flags & FLG_HOTPATCH_RELOAD_NTDLL) {

            Status = PsLocateSystemDll( TRUE );

        } else if (PatchInfo->Flags & FLG_HOTPATCH_RENAME_INFO) {

            //
            //  The io routine is expected to perform the parameter check
            //
            
            Status = ExpSyncRenameFiles( PatchInfo->RenameInfo.FileHandle1,
                                         PatchInfo->RenameInfo.IoStatusBlock1,
                                         PatchInfo->RenameInfo.RenameInformation1,
                                         PatchInfo->RenameInfo.RenameInformationLength1,
                                         PatchInfo->RenameInfo.FileHandle2,
                                         PatchInfo->RenameInfo.IoStatusBlock2,
                                         PatchInfo->RenameInfo.RenameInformation2,
                                         PatchInfo->RenameInfo.RenameInformationLength2);

        } else if (PatchInfo->Flags & FLG_HOTPATCH_MAP_ATOMIC_SWAP) {

            Status = ObSwapObjectNames( PatchInfo->AtomicSwap.ParentDirectory,
                                        PatchInfo->AtomicSwap.ObjectHandle1,
                                        PatchInfo->AtomicSwap.ObjectHandle2,
                                        0);
        }

    } else {

        //
        //  Regular patch operation which can be in either kernel mode or user mode
        //

        if (PatchInfo->Flags & FLG_HOTPATCH_KERNEL) {

            //
            //          Kernel-mode patch
            //

            if ( (PatchInfo->InfoSize != PatchSize)
                    ||
                 !(PatchInfo->Flags & FLG_HOTPATCH_NAME_INFO)
                    ||
                 (PatchInfo->KernelInfo.NameOffset >= PatchSize)
                    ||
                 (PatchInfo->KernelInfo.NameLength >= PatchSize)
                    ||
                 ((ULONG)(PatchInfo->KernelInfo.NameOffset + PatchInfo->KernelInfo.NameLength) > PatchSize)) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = MmHotPatchRoutine (PatchInfo);
            }

        } else {

            //
            //          User-mode patch
            //
            //  No privilege check is required for the user mode patching 
            //  as it can only be done to the current process
            //

            //
            //  Lock the user buffer. This function also performs the 
            //  validation of the patch address to be USER
            //

            if ((PatchSize < sizeof(SYSTEM_HOTPATCH_CODE_INFORMATION))
                    ||
                (PatchInfo->InfoSize != PatchSize)
                    ||
                ((PatchInfo->CodeInfo.DescriptorsCount - 1) > 
                    (PatchSize - sizeof(SYSTEM_HOTPATCH_CODE_INFORMATION))/sizeof(HOTPATCH_HOOK_DESCRIPTOR))) {

                ExFreePool (PatchInfo);

                return STATUS_INVALID_PARAMETER;
            }

            Status = MmLockAndCopyMemory(PatchInfo, PreviousMode);
        }
    }

    ExFreePool (PatchInfo);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\exp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exp.h

Abstract:

    This module contains the private (internal) header file for the
    executive.

Author:

    David N. Cutler (davec) 23-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _EXP_
#define _EXP_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4206)   // translation unit empty
#pragma warning(disable:4706)   // assignment within conditional
#pragma warning(disable:4324)   // structure was padded
#pragma warning(disable:4328)   // greater alignment than needed
#pragma warning(disable:4054)   // cast of function pointer to PVOID

#include "ntos.h"
#include "zwapi.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "ki.h"
#include "stdio.h"
#include "pool.h"



#define COMPLUS_PACKAGE_KEYPATH      L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\.NETFramework"
#define COMPLUS_PACKAGE_ENABLE64BIT  L"Enable64Bit"
#define COMPLUS_PACKAGE_INVALID      (ULONG)-1

//
// Executive information initialization structure
//

typedef struct {
    PCALLBACK_OBJECT    *CallBackObject;
    PWSTR               CallbackName;
} EXP_INITIALIZE_GLOBAL_CALLBACKS;

typedef struct _EXP_LICENSE_INFO {
    HANDLE           RegKey;
    ULONG            Count;
    PWSTR            SubKeyName;
    WORK_QUEUE_ITEM  ExpWatchLicenseInfoWorkItem;
    IO_STATUS_BLOCK  ExpLicenseInfoIoSb;
    ULONG            ExpLicenseInfoChangeBuffer;
} EXP_LICENSE_INFO, *PEXP_LICENSE_INFO;


//
// Executive object and other initialization function definitions.
//

NTSTATUS
ExpWorkerInitialization (
    VOID
    );

BOOLEAN
ExpEventInitialization (
    VOID
    );

BOOLEAN
ExpEventPairInitialization (
    VOID
    );

BOOLEAN
ExpMutantInitialization (
    VOID
    );

BOOLEAN
ExpSemaphoreInitialization (
    VOID
    );

BOOLEAN
ExpTimerInitialization (
    VOID
    );

BOOLEAN
ExpWin32Initialization (
    VOID
    );

BOOLEAN
ExpResourceInitialization (
    VOID
    );

PVOID
ExpCheckForResource (
    IN PVOID p,
    IN SIZE_T Size
    );

BOOLEAN
ExpInitSystemPhase0 (
    VOID
    );

BOOLEAN
ExpInitSystemPhase1 (
    VOID
    );

BOOLEAN
ExpProfileInitialization (
    );

BOOLEAN
ExpUuidInitialization (
    );

VOID
ExpProfileDelete (
    IN PVOID    Object
    );


BOOLEAN
ExpInitializeCallbacks (
    VOID
    );

BOOLEAN
ExpSysEventInitialization(
    VOID
    );

VOID
ExpCheckSystemInfoWork (
    IN PVOID Context
    );

VOID
ExInitSystemPhase2 (
    VOID
    );

NTSTATUS
ExpKeyedEventInitialization (
    VOID
    );

VOID
ExpCheckSystemInformation (
    PVOID       Context,
    PVOID       InformationClass,
    PVOID       Argument2
    );


VOID
ExpTimeZoneWork(
    IN PVOID Context
    );

VOID
ExpTimeRefreshDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
ExpTimeRefreshWork(
    IN PVOID Context
    );

VOID
ExpTimeZoneDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
ExInitializeTimeRefresh(
    VOID
    );

VOID
ExpExpirationThread(
    IN PVOID StartContext
    );

ULONG
ExpComputeTickCountMultiplier(
    IN ULONG TimeIncrement
    );

BOOLEAN
static
ExpWatchProductTypeInitialization(
    VOID
    );

VOID
static
ExpWatchProductTypeWork(
    IN PVOID Context
    );

VOID
static
ExpWatchLicenseInfoWork(
    IN PVOID Context
    );

VOID
static
ExpWatchSystemPrefixWork(
    IN PVOID Context
    );

VOID
static
ExpWatchExpirationDataWork(
    IN PVOID Context
    );

VOID
ExpCheckForWorker(
    IN PVOID p,
    IN SIZE_T Size
    );

VOID
ExpShutdownWorkerThreads(
    VOID
    );

NTSTATUS
ExpReadComPlusPackage(
    VOID
    );

NTSTATUS
ExpUpdateComPlusPackage(
    IN ULONG ComPlusPackageStatus
    );

#if defined(_WIN64)
NTSTATUS
ExpGetSystemEmulationProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    );
#endif

NTSTATUS
ExApplyCodePatch(
    IN PVOID    PatchInfoPtr,
    IN SIZE_T   PatchSize
    );


ULONG ExpNtExpirationData[3];
BOOLEAN ExpSetupModeDetected;
LARGE_INTEGER ExpSetupSystemPrefix;
HANDLE ExpSetupKey;
BOOLEAN ExpSystemPrefixValid;


#ifdef _PNP_POWER_

extern WORK_QUEUE_ITEM  ExpCheckSystemInfoWorkItem;
extern LONG             ExpCheckSystemInfoBusy;
extern const WCHAR      ExpWstrSystemInformation[];
extern const WCHAR      ExpWstrSystemInformationValue[];

#endif // _PNP_POWER_

extern const WCHAR      ExpWstrCallback[];
extern const EXP_INITIALIZE_GLOBAL_CALLBACKS  ExpInitializeCallback[];


extern FAST_MUTEX       ExpEnvironmentLock;
extern ERESOURCE        ExpKeyManipLock;

extern GENERAL_LOOKASIDE ExpSmallPagedPoolLookasideLists[POOL_SMALL_LISTS];
extern GENERAL_LOOKASIDE ExpSmallNPagedPoolLookasideLists[POOL_SMALL_LISTS];

extern LIST_ENTRY ExNPagedLookasideListHead;
extern KSPIN_LOCK ExNPagedLookasideLock;
extern LIST_ENTRY ExPagedLookasideListHead;
extern KSPIN_LOCK ExPagedLookasideLock;
extern LIST_ENTRY ExPoolLookasideListHead;
extern PEPROCESS  ExpDefaultErrorPortProcess;
extern HANDLE     ExpDefaultErrorPort;
extern HANDLE     ExpProductTypeKey;
extern PVOID      ExpControlKey[2];

#endif // _EXP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\exinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exinfo.c

Abstract:

    This module implements the NT set and query system information services.

Author:

    Ken Reneris (kenr) 19-July-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

#if _PNP_POWER_
#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, ExpCheckSystemInformation)
#pragma alloc_text(PAGE, ExpCheckSystemInfoWork)
#endif // _PNP_POWER_

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

VOID
ExpCheckSystemInformation (
    PVOID       Context,
    PVOID       InformationClass,
    PVOID       Argument2
    )
/*++

Routine Description:

    Callback function invoked when something in the system information
    may have changed.

Arguments:

    Context - Where invoked from.

    InformationClass - which class for the given context was set
        (ignored for now)

    Argument2

Return Value:

--*/
{
	PAGED_CODE();

	if (InterlockedIncrement(&ExpCheckSystemInfoBusy) == 1) {
		ExQueueWorkItem (&ExpCheckSystemInfoWorkItem, DelayedWorkQueue);
	}
}


VOID
ExpCheckSystemInfoWork (
    IN PVOID Context
    )
/*++

Routine Description:

    Verifies registery data for various system information classes
    is up to date.

Arguments:

Return Value:

--*/
{
    static struct {
        SYSTEM_INFORMATION_CLASS         InformationLevel;
        ULONG                            BufferSize;
    } const RegistryInformation[] = {
        SystemBasicInformation,          sizeof (SYSTEM_BASIC_INFORMATION),
        SystemPowerInformation,          sizeof (SYSTEM_POWER_INFORMATION),
        SystemProcessorSpeedInformation, sizeof (SYSTEM_PROCESSOR_SPEED_INFORMATION),
        0,                               0
    };

    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Key;
        union {
            SYSTEM_BASIC_INFORMATION BasicInformation;
            SYSTEM_POWER_INFORMATION PowerSettings;
            SYSTEM_PROCESSOR_SPEED_INFORMATION  ProcessorSpeed;
        };
    } RegistryBuffer, QueryBuffer;

    ULONG               Index, BufferSize, disposition, length;
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString, ValueString;
    HANDLE              CurrentControlSet, SystemInformation, LevelInformation;
    LARGE_INTEGER       Interval;
    WCHAR               wstr[10];

    PAGED_CODE();

    RtlInitUnicodeString (&ValueString,  ExpWstrSystemInformationValue);

    //
    // Open CurrentControlSet
    //

    InitializeObjectAttributes( &objectAttributes,
                                &CmRegistryMachineSystemCurrentControlSet,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenKey (&CurrentControlSet,
                        KEY_READ | KEY_WRITE,
                        &objectAttributes );

    if (NT_SUCCESS(Status)) {

        //
        // Open SystemInformation
        //

        RtlInitUnicodeString( &unicodeString, ExpWstrSystemInformation );
        InitializeObjectAttributes( &objectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    CurrentControlSet,
                                    NULL );

        Status = NtCreateKey ( &SystemInformation,
                               KEY_READ | KEY_WRITE,
                               &objectAttributes,
                               0,
                               NULL,
                               REG_OPTION_VOLATILE,
                               &disposition );

        NtClose (CurrentControlSet);
    }

    if (!NT_SUCCESS(Status)) {
        ExpCheckSystemInfoBusy = 0;
        return ;
    }

    //
    // Loop and check SystemInformation data in registry
    //

    do {
        //
        // For now just check each SystemInformation level and update
        // any level which is out of date
        //

        for (Index=0; RegistryInformation[Index].BufferSize; Index++) {

            //
            // Initialize registry data buffer
            //

            BufferSize = RegistryInformation[Index].BufferSize;
            RtlZeroMemory (RegistryBuffer.Key.Data, BufferSize);

            //
            // Open appropiate SystemInformation level key
            //

            swprintf (wstr, L"%d", RegistryInformation[Index].InformationLevel);
            RtlInitUnicodeString (&unicodeString, wstr);
            InitializeObjectAttributes( &objectAttributes,
                                        &unicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        SystemInformation,
                                        NULL );

            Status = NtCreateKey ( &LevelInformation,
                                   KEY_READ | KEY_WRITE,
                                   &objectAttributes,
                                   0,
                                   NULL,
                                   REG_OPTION_VOLATILE,
                                   &disposition );

            //
            // If key opened, read current data value from the registry
            //

            if (NT_SUCCESS(Status)) {
                NtQueryValueKey (
                    LevelInformation,
                    &ValueString,
                    KeyValuePartialInformation,
                    &RegistryBuffer.Key,
                    sizeof (RegistryBuffer),
                    &length
                    );
            }

            //
            // Query current SystemInformation data
            //

            Status = NtQuerySystemInformation (
                            RegistryInformation[Index].InformationLevel,
                            &QueryBuffer.Key.Data,
                            BufferSize,
                            NULL
                        );

            //
            // Check if current SystemInformation matches the registry
            // information
            //

            if (NT_SUCCESS(Status)  &&
                !RtlEqualMemory (RegistryBuffer.Key.Data,
                                 QueryBuffer.Key.Data,
                                 BufferSize) ) {

                //
                // Did not match - update registry to current SystemInfomration
                //

                Status = NtSetValueKey (
                            LevelInformation,
                            &ValueString,
                            0L,
                            REG_BINARY,
                            QueryBuffer.Key.Data,
                            BufferSize
                            );

                //
                // Make notificant that this information level has changed
                //

                ExNotifyCallback (
                    ExCbSetSystemInformation,
                    (PVOID) RegistryInformation[Index].InformationLevel,
                    (PVOID) NULL
                );
            }

            //
            // Close this InformatiobLevel and check the next one
            //

            NtClose (LevelInformation);
        }

    } while (InterlockedDecrement(&ExpCheckSystemInfoBusy));

    //
    // Cleanup
    //

    NtClose (SystemInformation);
}

#endif  // _PNP_POWER_

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\exdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exdata.c

Abstract:

    This module contains the global read/write data for the I/O system.

Author:

    Ken Reneris (kenr)

Revision History:


--*/

#include "exp.h"

//
// Executive callbacks.
//

PCALLBACK_OBJECT ExCbSetSystemTime;
PCALLBACK_OBJECT ExCbSetSystemState;
PCALLBACK_OBJECT ExCbPowerState;

#ifdef _PNP_POWER_

//
// Work Item to scan SystemInformation levels
//

WORK_QUEUE_ITEM ExpCheckSystemInfoWorkItem;

#endif


//
// Pageable data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

#ifdef _PNP_POWER_

const WCHAR ExpWstrSystemInformation[] = L"Control\\System Information";
const WCHAR ExpWstrSystemInformationValue[] = L"Value";

#endif

//
// Initialization time data
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif

const WCHAR ExpWstrCallback[] = L"\\Callback";

const EXP_INITIALIZE_GLOBAL_CALLBACKS  ExpInitializeCallback[] = {
    &ExCbSetSystemTime,             L"\\Callback\\SetSystemTime",
    &ExCbSetSystemState,            L"\\Callback\\SetSystemState",
    &ExCbPowerState,                L"\\Callback\\PowerState",
    NULL,                           NULL
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif

#ifdef _PNP_POWER_

LONG ExpCheckSystemInfoBusy = 0;

#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\hdlsterm.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    hdlsterm.c

Abstract:

    This file implements functions for dealing with a terminal attached.

Author:

    Sean Selitrennikoff (v-seans) Oct, 1999

Environment:

    kernel mode

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include <hdlsblk.h>
#include <hdlsterm.h>
#include <inbv.h>


//
// Defines for headless
//
//
#define HEADLESS_OOM_STRING L"Entry could not be recorded due to lack of memory.\n"
#define HEADLESS_LOG_NUMBER_OF_ENTRIES 256
#define HEADLESS_TMP_BUFFER_SIZE 80


//
// Note: HdlspAddLogEntry() allocates a buffer off the stack of this size, 
// so keep this number small.  Anything longer than 80 is probably useless, as 
// a VT100 can only handle 80 characters across.
// Do not make this any shorter than the string for HEADLESS_LOG_LOADING_FILENAME
//
#define HDLSP_LOG_MAX_STRING_LENGTH 80


#define HEADLESS_ACQUIRE_SPIN_LOCK() \
        if (!HeadlessGlobals->InBugCheck) { \
            KeAcquireSpinLock(&(HeadlessGlobals->SpinLock), &OldIrql); \
        } else { \
            OldIrql = (KIRQL)-1; \
        }

#define HEADLESS_RELEASE_SPIN_LOCK() \
        if (OldIrql != (KIRQL)-1) { \
            KeReleaseSpinLock(&(HeadlessGlobals->SpinLock), OldIrql); \
        } else { \
            ASSERT(HeadlessGlobals->InBugCheck); \
        }

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8


//
// This table provides a quick lookup conversion between ASCII values
// that fall between 128 and 255, and their UNICODE counterpart.
//
// Note that ASCII values between 0 and 127 are equvilent to their
// unicode counter parts, so no lookups would be required.
//
// Therefore when using this table, remove the high bit from the ASCII
// value and use the resulting value as an offset into this array.  For
// example, 0x80 ->(remove the high bit) 00 -> 0x00C7.
//
USHORT PcAnsiToUnicode[0xFF] = {
        0x00C7,
        0x00FC,
        0x00E9,
        0x00E2,
        0x00E4,
        0x00E0,
        0x00E5,
        0x0087,
        0x00EA,
        0x00EB,
        0x00E8,
        0x00EF,
        0x00EE,
        0x00EC,
        0x00C4,
        0x00C5,
        0x00C9,
        0x00E6,
        0x00C6,
        0x00F4,
        0x00F6,
        0x00F2,
        0x00FB,
        0x00F9,
        0x00FF,
        0x00D6,
        0x00DC,
        0x00A2,
        0x00A3,
        0x00A5,
        0x20A7,
        0x0192,
        0x00E1,
        0x00ED,
        0x00F3,
        0x00FA,
        0x00F1,
        0x00D1,
        0x00AA,
        0x00BA,
        0x00BF,
        0x2310,
        0x00AC,
        0x00BD,
        0x00BC,
        0x00A1,
        0x00AB,
        0x00BB,
        0x2591,
        0x2592,
        0x2593,
        0x2502,
        0x2524,
        0x2561,
        0x2562,
        0x2556,
        0x2555,
        0x2563,
        0x2551,
        0x2557,
        0x255D,
        0x255C,
        0x255B,
        0x2510,
        0x2514,
        0x2534,
        0x252C,
        0x251C,
        0x2500,
        0x253C,
        0x255E,
        0x255F,
        0x255A,
        0x2554,
        0x2569,
        0x2566,
        0x2560,
        0x2550,
        0x256C,
        0x2567,
        0x2568,
        0x2564,
        0x2565,
        0x2559,
        0x2558,
        0x2552,
        0x2553,
        0x256B,
        0x256A,
        0x2518,
        0x250C,
        0x2588,
        0x2584,
        0x258C,
        0x2590,
        0x2580,
        0x03B1,
        0x00DF,
        0x0393,
        0x03C0,
        0x03A3,
        0x03C3,
        0x00B5,
        0x03C4,
        0x03A6,
        0x0398,
        0x03A9,
        0x03B4,
        0x221E,
        0x03C6,
        0x03B5,
        0x2229,
        0x2261,
        0x00B1,
        0x2265,
        0x2264,
        0x2320,
        0x2321,
        0x00F7,
        0x2248,
        0x00B0,
        0x2219,
        0x00B7,
        0x221A,
        0x207F,
        0x00B2,
        0x25A0,
        0x00A0
        };





//
// Log entry structure
//
typedef struct _HEADLESS_LOG_ENTRY {
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfEntry;
    PWCHAR String;
} HEADLESS_LOG_ENTRY, *PHEADLESS_LOG_ENTRY;

// Blue Screen Data Structure
//
typedef struct _HEADLESS_BLUE_SCREEN_DATA {
        PUCHAR Property;
        PUCHAR XMLData;
        struct _HEADLESS_BLUE_SCREEN_DATA *Next;
}HEADLESS_BLUE_SCREEN_DATA, * PHEADLESS_BLUE_SCREEN_DATA;

//
// Global variables headless component uses
//
typedef struct _HEADLESS_GLOBALS {
    
    //
    // Global spin lock for accessing headless internal routines.
    // 
    KSPIN_LOCK SpinLock;

    //
    // Handle for when routines are locked down into memory.
    //
    HANDLE PageLockHandle;

    //
    // List of log entries. 
    //
    PHEADLESS_LOG_ENTRY LogEntries;
    
    //
    // Global temp buffer, not to be held across lock release/acquires.
    //
    PUCHAR TmpBuffer;

    //
    // Current user input line
    //
    PUCHAR InputBuffer;

    //
    // Blue Screen Data 
    //
    PHEADLESS_BLUE_SCREEN_DATA BlueScreenData;

    //
    // Flags and parameters for determining headless state
    //
    union {
        struct {
            ULONG TerminalEnabled    : 1;
            ULONG InBugCheck         : 1;
            ULONG NewLogEntryAdded   : 1;
            ULONG UsedBiosSettings   : 1;
            ULONG InputProcessing    : 1;
            ULONG InputLineDone      : 1;
            ULONG ProcessingCmd      : 1;
            ULONG TerminalParity     : 1;
            ULONG TerminalStopBits   : 1;
            ULONG TerminalPortNumber : 3;
            ULONG IsNonLegacyDevice  : 1;
        };
        ULONG AllFlags;
    };

    //
    // Port settings
    //
    ULONG TerminalBaudRate;
    ULONG TerminalPort;
    PUCHAR TerminalPortAddress;
    LARGE_INTEGER DelayTime;            // in 100ns units
    ULONG MicroSecondsDelayTime;
    UCHAR TerminalType;                 // What kind of terminal do we think
                                        // we're talking to?
                                        // 0 = VT100
                                        // 1 = VT100+
                                        // 2 = VT-UTF8
                                        // 3 = PC ANSI
                                        // 4-255 = reserved


    //
    // Current location in Input buffer;
    //
    SIZE_T InputBufferIndex;

    //
    // Logging Indexes.
    //
    USHORT LogEntryLast;
    USHORT LogEntryStart;

    //
    // Machine's GUID.
    //
    GUID    SystemGUID;

    BOOLEAN IsMMIODevice;               // Is UART in SysIO or MMIO space?

    //
    // if this is TRUE, then the last character was a CR.
    // if this is TRUE and the current character is a LF, 
    //      then we filter the LF. 
    //
    BOOLEAN IsLastCharCR;

} HEADLESS_GLOBALS, *PHEADLESS_GLOBALS;


//
// The one and only resident global variable
//
PHEADLESS_GLOBALS HeadlessGlobals = NULL;


//
// Forward declarations.
//
NTSTATUS
HdlspDispatch(
    IN  HEADLESS_CMD Command,
    IN  PVOID  InputBuffer OPTIONAL,
    IN  SIZE_T InputBufferSize OPTIONAL,
    OUT PVOID OutputBuffer OPTIONAL,
    OUT PSIZE_T OutputBufferSize OPTIONAL
    );

NTSTATUS
HdlspEnableTerminal(
    BOOLEAN bEnable
    );

VOID
HdlspPutString(
    PUCHAR String
    );

VOID
HdlspPutData(
    PUCHAR InputBuffer,
    SIZE_T InputBufferLength
    );

BOOLEAN
HdlspGetLine(
    PUCHAR InputBuffer,
    SIZE_T InputBufferLength
    );

VOID
HdlspBugCheckProcessing(
    VOID
    );

VOID
HdlspProcessDumpCommand(
    IN BOOLEAN Paging
    );

VOID
HdlspPutMore(
    OUT PBOOLEAN Stop
    );

VOID
HdlspAddLogEntry(
    IN PWCHAR String
    );

NTSTATUS
HdlspSetBlueScreenInformation(
    IN PHEADLESS_CMD_SET_BLUE_SCREEN_DATA pData,
    IN SIZE_T cData
    );

VOID
HdlspSendBlueScreenInfo(
    ULONG BugcheckCode
    );

VOID
HdlspKernelAddLogEntry(
    IN ULONG StringCode,
    IN PUNICODE_STRING DriverName OPTIONAL
    );

VOID
HdlspSendStringAtBaud(
    IN PUCHAR String
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,     HeadlessInit)
#pragma alloc_text(PAGE,     HeadlessTerminalAddResources)
#pragma alloc_text(PAGEHDLS, HdlspDispatch)
#pragma alloc_text(PAGEHDLS, HdlspEnableTerminal)
#pragma alloc_text(PAGEHDLS, HdlspPutString)
#pragma alloc_text(PAGEHDLS, HdlspPutData)
#pragma alloc_text(PAGEHDLS, HdlspGetLine)
#pragma alloc_text(PAGEHDLS, HdlspBugCheckProcessing)
#pragma alloc_text(PAGEHDLS, HdlspProcessDumpCommand)
#pragma alloc_text(PAGEHDLS, HdlspPutMore)
#pragma alloc_text(PAGEHDLS, HdlspAddLogEntry)
#pragma alloc_text(PAGEHDLS, HdlspSetBlueScreenInformation)
#pragma alloc_text(PAGEHDLS, HdlspSendBlueScreenInfo)
#pragma alloc_text(PAGEHDLS, HdlspKernelAddLogEntry)
#pragma alloc_text(PAGEHDLS, HdlspSendStringAtBaud)
#endif



VOID
HeadlessInit(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine sets up all the information for supporting a headless terminal.  It
    does not initialize the terminal.

Arguments:

    
    HeadlessLoaderBlock - The loader block passed in from the loader. 
    
Environment:

    Only to be called at INIT time.

--*/
{
    PHEADLESS_LOADER_BLOCK HeadlessLoaderBlock;
    PHEADLESS_GLOBALS GlobalBlock;
    ULONG TmpUlong;


    if (LoaderBlock->Extension->HeadlessLoaderBlock == NULL) {
        return;
    }


    HeadlessLoaderBlock = LoaderBlock->Extension->HeadlessLoaderBlock;


    if ((HeadlessLoaderBlock->PortNumber <= 4) || (BOOLEAN)(HeadlessLoaderBlock->UsedBiosSettings)) {

        //
        // Allocate space for the global variables we will use.
        //
        GlobalBlock =  ExAllocatePoolWithTag(NonPagedPool,
                                             sizeof(HEADLESS_GLOBALS),
                                             ((ULONG)'sldH')
                                            );

        if (GlobalBlock == NULL) {

            return;
        }

        //
        // Start everything at zero, and then init the rest by hand.
        //
        RtlZeroMemory(GlobalBlock, sizeof(HEADLESS_GLOBALS));
        
        
        KeInitializeSpinLock(&(GlobalBlock->SpinLock));

        //
        // Copy stuff from loader block
        //
        GlobalBlock->TerminalPortNumber = HeadlessLoaderBlock->PortNumber;
        GlobalBlock->TerminalPortAddress = HeadlessLoaderBlock->PortAddress;
        GlobalBlock->TerminalBaudRate = HeadlessLoaderBlock->BaudRate;
        GlobalBlock->TerminalParity = (BOOLEAN)(HeadlessLoaderBlock->Parity);
        GlobalBlock->TerminalStopBits = HeadlessLoaderBlock->StopBits;
        GlobalBlock->UsedBiosSettings = (BOOLEAN)(HeadlessLoaderBlock->UsedBiosSettings);
        GlobalBlock->IsMMIODevice = (BOOLEAN)(HeadlessLoaderBlock->IsMMIODevice);
        GlobalBlock->IsLastCharCR = FALSE;
        GlobalBlock->TerminalType = (UCHAR)(HeadlessLoaderBlock->TerminalType);
        
        RtlCopyMemory( &GlobalBlock->SystemGUID,
                       &HeadlessLoaderBlock->SystemGUID,
                       sizeof(GUID) );


        //
        // We need to determine if this is a non-legacy device that we're
        // speaking through.  This can happen in several different ways,
        // including a PCI device placing a UART in System I/O space (which
        // wouldn't qualify as being "non-legacy"), or even a NON-PCI
        // device placing a UART up in MMIO (which again wouldn't qualify).
        //
        // Therefore, if the address is outside of System I/O, *or* if it's
        // sitting on a PCI device, then set the IsNonLegacyDevice entry.
        //
        if( GlobalBlock->IsMMIODevice ) {
            GlobalBlock->IsNonLegacyDevice = TRUE;
        }


        //
        // If we're speaking through a PCI device, we need to secure it.  We'll
        // use the debugger APIs to make sure the device is understood and that it
        // doesn't get moved.
        //
        if( (HeadlessLoaderBlock->PciDeviceId != (USHORT)0xFFFF) &&
            (HeadlessLoaderBlock->PciDeviceId != 0) &&
            (HeadlessLoaderBlock->PciVendorId != (USHORT)0xFFFF) &&
            (HeadlessLoaderBlock->PciVendorId != 0) ) {

            //
            // The loader thinks he spoke through a PCI device.  Remember
            // that it's non-legacy.
            //
            GlobalBlock->IsNonLegacyDevice = TRUE;

            //
            // Tell everyone else in the system to leave this device alone.
            // before we do that, the user may actually want PnP to enumerate the
            // device and possibly apply power management to it.  They can indicate
            // this by setting bit 0 of PciFlags.
            //
            if( !(HeadlessLoaderBlock->PciFlags & 0x1) ) {

                DEBUG_DEVICE_DESCRIPTOR  DebugDeviceDescriptor;

                RtlZeroMemory( &DebugDeviceDescriptor,
                               sizeof(DEBUG_DEVICE_DESCRIPTOR) );

                //
                // We're required to understand exactly what this structure looks like
                // because we need to set every value to (-1), then fill in only the
                // fields that we explicitly know about.
                //
                DebugDeviceDescriptor.DeviceID = HeadlessLoaderBlock->PciDeviceId;
                DebugDeviceDescriptor.VendorID = HeadlessLoaderBlock->PciVendorId;
                DebugDeviceDescriptor.Bus = HeadlessLoaderBlock->PciBusNumber;
                DebugDeviceDescriptor.Slot = HeadlessLoaderBlock->PciSlotNumber;

                //
                // Now fill in the rest with (-1).
                //
                DebugDeviceDescriptor.BaseClass = 0xFF;
                DebugDeviceDescriptor.SubClass = 0xFF;
                DebugDeviceDescriptor.ProgIf = 0xFF;


                //
                // Do it.
                //
                KdSetupPciDeviceForDebugging( LoaderBlock,
                                              &DebugDeviceDescriptor );
            }
        }



        //
        // Allocate space for log entries.
        //
        GlobalBlock->LogEntries = ExAllocatePoolWithTag(NonPagedPool,
                                                        HEADLESS_LOG_NUMBER_OF_ENTRIES *
                                                            sizeof(HEADLESS_LOG_ENTRY),
                                                        ((ULONG)'sldH')
                                                       );

        if (GlobalBlock->LogEntries == NULL) {

            goto Fail;
        }

        GlobalBlock->LogEntryLast = (USHORT)-1;
        GlobalBlock->LogEntryStart = (USHORT)-1;


        //
        // Allocate a temporary buffer for general use.
        //
        GlobalBlock->TmpBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                                       HEADLESS_TMP_BUFFER_SIZE,
                                                       ((ULONG)'sldH')
                                                      );

        if (GlobalBlock->TmpBuffer == NULL) {

            goto Fail;
        }

        GlobalBlock->InputBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                                         HEADLESS_TMP_BUFFER_SIZE,
                                                         ((ULONG)'sldH')
                                                        );

        if (GlobalBlock->InputBuffer == NULL) {

            goto Fail;
        }

        GlobalBlock->PageLockHandle = MmLockPagableCodeSection((PVOID)(ULONG_PTR)HdlspDispatch);

        if (GlobalBlock->PageLockHandle == NULL) {

            goto Fail;
        }

        //
        // Figure to delay time between bytes to satify the baud rate given.
        //
        if (GlobalBlock->TerminalBaudRate == 9600) {

            TmpUlong = GlobalBlock->TerminalBaudRate;

            //
            // Convert to chars per second.
            //
            TmpUlong = TmpUlong / 10;        // 10 bits per character (8-1-1) is the max.

            GlobalBlock->MicroSecondsDelayTime = ((1000000 /  TmpUlong) * 10) / 8;      // We will send at 80% speed to be sure.
            GlobalBlock->DelayTime.HighPart = -1;                                    
            GlobalBlock->DelayTime.LowPart = -10 * GlobalBlock->MicroSecondsDelayTime;  // relative time
        }

        HeadlessGlobals = GlobalBlock;


        //
        // If all went well, go ahead and initialize the headless port.
        // Do this here so we have it ready to go in case of an early
        // bugcheck.  In that case, we will have the port ready to accept
        // traffic without having to initialize it while we're trying to
        // bugcheck the machine.
        //
        HdlspEnableTerminal(TRUE);

    }

    return;

Fail:

    if (GlobalBlock->LogEntries != NULL) {
        ExFreePool(GlobalBlock->LogEntries);
    }

    if (GlobalBlock->TmpBuffer != NULL) {
        ExFreePool(GlobalBlock->TmpBuffer);
    }

    if (GlobalBlock->InputBuffer != NULL) {
        ExFreePool(GlobalBlock->InputBuffer);
    }

    ExFreePool(GlobalBlock);
}


NTSTATUS
HeadlessDispatch(
    IN  HEADLESS_CMD Command,
    IN  PVOID   InputBuffer OPTIONAL,
    IN  SIZE_T  InputBufferSize OPTIONAL,
    OUT PVOID   OutputBuffer OPTIONAL,
    OUT PSIZE_T OutputBufferSize OPTIONAL
    )

/*++

Routine Description:

    This routine is the main entry point for all headless interaction with clients.

Arguments:
    
    Command - The command to execute.
    
    InputBuffer - An optionally supplied buffer containing input parameters.
    
    InputBufferSize - Size of the supplied input buffer.
    
    OutputBuffer - An optionally supplied buffer where to place output parameters.
    
    OutputBufferSize - Size of the supplied output buffer, if the buffer is too small
        then STATUS_BUFFER_TOO_SMALL is returned and this parameter contains the total
        bytes necessary to complete the operation.
    
Environment:

    If headless is enabled, it will acquire spin locks, so call from DPC level or 
    less, only from kernel mode.

--*/
{
    //
    // If headless is not enabled on this machine, then some commands need special
    // processing, and all other we fool by saying that it succeeded.
    //
    // If for some reason we were unable to lock the headless component down into
    // memory when we initialized, treat this as the terminal not being connected.
    //
    if ((HeadlessGlobals == NULL) || (HeadlessGlobals->PageLockHandle == NULL)) {

        if (Command == HeadlessCmdEnableTerminal) {
            return STATUS_UNSUCCESSFUL;
        }        
        
        //
        // The following command all have responses, so we must fill in the
        // correct response for when headless is not enabled.
        //
        if ((Command == HeadlessCmdQueryInformation) ||
            (Command == HeadlessCmdGetByte) ||
            (Command == HeadlessCmdGetLine) ||
            (Command == HeadlessCmdCheckForReboot) ||
            (Command == HeadlessCmdTerminalPoll)) {

            if ((OutputBuffer == NULL) || (OutputBufferSize == NULL)) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // All structures are designed such that a 0 or FALSE is the correct
            // response when headless is not present.
            //
            RtlZeroMemory(OutputBuffer, *OutputBufferSize);
        }

        return STATUS_SUCCESS;
    }

    return HdlspDispatch(Command, 
                         InputBuffer, 
                         InputBufferSize, 
                         OutputBuffer, 
                         OutputBufferSize
                        );

}


NTSTATUS
HdlspDispatch(
    IN  HEADLESS_CMD Command,
    IN  PVOID InputBuffer OPTIONAL,
    IN  SIZE_T InputBufferSize OPTIONAL,
    OUT PVOID OutputBuffer OPTIONAL,
    OUT PSIZE_T OutputBufferSize OPTIONAL
    )

/*++

Routine Description:

    This routine is the pageable version of the dispatch routine.

    In general this routine is not intended to be used by more than one thread at
    a time.  There are two exceptions, see below, but otherwise any second command
    that is submitted is rejected.
    
    There are only a couple of things that allowed to be called in parallel:
       AddLogEntry can be called when another command is being processed.
       StartBugCheck and BugCheckProcessing can as well.
    
    AddLogEntry is synchronized with all the other commands.  It atomically adds
    the entry while holding the spin lock. Thus, all other command should try and
    hold the spin lock when manipulating global variables.
    
    The BugCheck routines do not use any spinlocking - an unfortunate side effect 
    of that is that since another thread may still be executing and in this code, 
    terminal I/O is indeterminable during this time.  We cannot wait for the other 
    thread to exit, as it may be that thread itself has already been stopped.  Thus, 
    in the case of a bugcheck, this is unsolvable.  However, since bugchecks should 
    never happen - having the possibility of a small overlap is acceptable, since 
    the other thread either exits or is stopped, I/O will happen correctly with the 
    terminal.  This may require the user to press ENTER a couple of times, but that
    is acceptable in a bugcheck situation.
    
Arguments:
    
    Command - The command to execute.
    
    InputBuffer - An optionally supplied buffer containing input parameters.
    
    InputBufferSize - Size of the supplied input buffer.
    
    OutputBuffer - An optionally supplied buffer where to place output parameters.
    
    OutputBufferSize - Size of the supplied output buffer, if the buffer is too small
        then STATUS_BUFFER_TOO_SMALL is returned and this parameter contains the total
        bytes necessary to complete the operation.
    
Environment:

    Only called from HeadlessDispatch, which guarantees it is paged in and locked down.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Tmp;
    UCHAR LocalBuffer[HEADLESS_TMP_BUFFER_SIZE];
    PHEADLESS_RSP_QUERY_INFO Response;
    KIRQL OldIrql;

    ASSERT(HeadlessGlobals != NULL);
    ASSERT(HeadlessGlobals->PageLockHandle != NULL);


    if ((Command != HeadlessCmdAddLogEntry) &&
        (Command != HeadlessCmdStartBugCheck) &&
        (Command != HeadlessCmdSendBlueScreenData) &&
        (Command != HeadlessCmdDoBugCheckProcessing)) {

        HEADLESS_ACQUIRE_SPIN_LOCK();

        if (HeadlessGlobals->ProcessingCmd) {
            
            HEADLESS_RELEASE_SPIN_LOCK();
            return STATUS_UNSUCCESSFUL;
        }
        
        HeadlessGlobals->ProcessingCmd = TRUE;

        HEADLESS_RELEASE_SPIN_LOCK();
    }

    //
    // Verify parameters for each command and then call the appropriate subroutine
    // to process it.
    //
    switch (Command) {

        //
        // Enable terminal
        //
    case HeadlessCmdEnableTerminal:
        
        if ((InputBuffer == NULL) || 
            (InputBufferSize != sizeof(HEADLESS_CMD_ENABLE_TERMINAL))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        Status = HdlspEnableTerminal(((PHEADLESS_CMD_ENABLE_TERMINAL)InputBuffer)->Enable);
        goto EndOfFunction;


        //
        // Check for reboot string
        //
    case HeadlessCmdCheckForReboot:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize != sizeof(HEADLESS_RSP_REBOOT))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            if (HdlspGetLine(LocalBuffer, HEADLESS_TMP_BUFFER_SIZE)) {

                ((PHEADLESS_RSP_REBOOT)OutputBuffer)->Reboot = (BOOLEAN)
                       (!strcmp((LPCSTR)LocalBuffer, "reboot") || 
                        !strcmp((LPCSTR)LocalBuffer, "shutdown"));

            }

        } else {

            ((PHEADLESS_RSP_REBOOT)OutputBuffer)->Reboot = FALSE;

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;



        //
        // Output a string.
        //
    case HeadlessCmdPutString:
        
        if (InputBuffer == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            HdlspPutString(&(((PHEADLESS_CMD_PUT_STRING)InputBuffer)->String[0]));

        }
        Status = STATUS_SUCCESS;
        goto EndOfFunction;
        

        //
        // Output a data stream.
        //
    case HeadlessCmdPutData:
        
        if ( (InputBuffer == NULL) ||
             (InputBufferSize == 0) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            HdlspPutData(&(((PHEADLESS_CMD_PUT_STRING)InputBuffer)->String[0]),
                         InputBufferSize);

        }
        Status = STATUS_SUCCESS;
        goto EndOfFunction;
        

        //
        // Poll for input
        //
    case HeadlessCmdTerminalPoll:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize != sizeof(HEADLESS_RSP_POLL))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            ((PHEADLESS_RSP_POLL)OutputBuffer)->QueuedInput = InbvPortPollOnly(HeadlessGlobals->TerminalPort);

        } else {

            ((PHEADLESS_RSP_POLL)OutputBuffer)->QueuedInput = FALSE;

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Get a single byte of input
        //
    case HeadlessCmdGetByte:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize != sizeof(HEADLESS_RSP_GET_BYTE))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            if (InbvPortPollOnly(HeadlessGlobals->TerminalPort)) {
                InbvPortGetByte(HeadlessGlobals->TerminalPort,
                                &(((PHEADLESS_RSP_GET_BYTE)OutputBuffer)->Value)
                               );
            } else {
                ((PHEADLESS_RSP_GET_BYTE)OutputBuffer)->Value = 0;
            }

        } else {

            ((PHEADLESS_RSP_GET_BYTE)OutputBuffer)->Value = 0;

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Get an entire line of input, if available.
        //
    case HeadlessCmdGetLine:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize < sizeof(HEADLESS_RSP_GET_LINE))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        if (HeadlessGlobals->TerminalEnabled) {

            ((PHEADLESS_RSP_GET_LINE)OutputBuffer)->LineComplete = 
                HdlspGetLine(&(((PHEADLESS_RSP_GET_LINE)OutputBuffer)->Buffer[0]),
                             *OutputBufferSize - 
                               sizeof(HEADLESS_RSP_GET_LINE) + 
                               sizeof(UCHAR)
                            );

        } else {

            ((PHEADLESS_RSP_GET_LINE)OutputBuffer)->LineComplete = FALSE;

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Let the kernel know to convert to bug check processing mode.
        //
    case HeadlessCmdStartBugCheck:
        
        HeadlessGlobals->InBugCheck = TRUE;
        Status = STATUS_SUCCESS;

        goto EndOfFunction;



        //
        // Process user I/O during a bugcheck
        //
    case HeadlessCmdDoBugCheckProcessing:
        
        if (HeadlessGlobals->TerminalEnabled) {

            //
            // NOTE: No spin lock here because we are in bugcheck.
            //
            HdlspBugCheckProcessing();

        }

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Process query information command
        //
    case HeadlessCmdQueryInformation:
        
        if ((OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize < sizeof(HEADLESS_RSP_QUERY_INFO))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        Response = (PHEADLESS_RSP_QUERY_INFO)OutputBuffer;

        Response->PortType = HeadlessSerialPort;
        Response->Serial.TerminalAttached = TRUE;
        Response->Serial.UsedBiosSettings = (BOOLEAN)(HeadlessGlobals->UsedBiosSettings);
        Response->Serial.TerminalBaudRate = HeadlessGlobals->TerminalBaudRate;

        if( (HeadlessGlobals->TerminalPortNumber >= 1) ||  (BOOLEAN)(HeadlessGlobals->UsedBiosSettings) ) {

            Response->Serial.TerminalPort = HeadlessGlobals->TerminalPortNumber;
            Response->Serial.TerminalPortBaseAddress = HeadlessGlobals->TerminalPortAddress;
            Response->Serial.TerminalType = HeadlessGlobals->TerminalType;

        } else {

            Response->Serial.TerminalPort = SerialPortUndefined;
            Response->Serial.TerminalPortBaseAddress = 0;
            Response->Serial.TerminalType = HeadlessGlobals->TerminalType;

        }
        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Process add log entry command
        //
    case HeadlessCmdAddLogEntry:
        
        if (InputBuffer == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        ASSERT(KeIsExecutingDpc() == FALSE);

        HdlspAddLogEntry(&(((PHEADLESS_CMD_ADD_LOG_ENTRY)InputBuffer)->String[0]));
        Status = STATUS_SUCCESS;
        goto EndOfFunction;


        //
        // Print log entries
        //
    case HeadlessCmdDisplayLog:
        
        if ((InputBuffer == NULL) || 
            (InputBufferSize != sizeof(HEADLESS_CMD_DISPLAY_LOG))) {
            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        HdlspProcessDumpCommand(((PHEADLESS_CMD_DISPLAY_LOG)InputBuffer)->Paging);
        Status = STATUS_SUCCESS;
        goto EndOfFunction;

        //
        // Various output commands
        //
    case HeadlessCmdClearDisplay:
    case HeadlessCmdClearToEndOfDisplay:
    case HeadlessCmdClearToEndOfLine:
    case HeadlessCmdDisplayAttributesOff:
    case HeadlessCmdDisplayInverseVideo:
    case HeadlessCmdSetColor:
    case HeadlessCmdPositionCursor:
        
        if (HeadlessGlobals->TerminalEnabled) {

            switch (Command) {
            case HeadlessCmdClearDisplay:
                Tmp = (PUCHAR)"\033[2J";
                break;

            case HeadlessCmdClearToEndOfDisplay:
                Tmp = (PUCHAR)"\033[0J";
                break;

            case HeadlessCmdClearToEndOfLine:
                Tmp = (PUCHAR)"\033[0K";
                break;

            case HeadlessCmdDisplayAttributesOff:
                Tmp = (PUCHAR)"\033[0m";
                break;

            case HeadlessCmdDisplayInverseVideo:
                Tmp = (PUCHAR)"\033[7m";
                break;

            case HeadlessCmdSetColor:

                if ((InputBuffer == NULL) || 
                    (InputBufferSize != sizeof(HEADLESS_CMD_SET_COLOR))) {
                    Status = STATUS_INVALID_PARAMETER;
                    goto EndOfFunction;
                }

                sprintf((LPSTR)LocalBuffer, 
                        "\033[%d;%dm", 
                        ((PHEADLESS_CMD_SET_COLOR)InputBuffer)->BkgColor, 
                        ((PHEADLESS_CMD_SET_COLOR)InputBuffer)->FgColor
                       );

                Tmp = &(LocalBuffer[0]);
                break;

            case HeadlessCmdPositionCursor:

                if ((InputBuffer == NULL) || 
                    (InputBufferSize != sizeof(HEADLESS_CMD_POSITION_CURSOR))) {
                    Status = STATUS_INVALID_PARAMETER;
                    goto EndOfFunction;
                }

                sprintf((LPSTR)LocalBuffer, 
                        "\033[%d;%dH", 
                        ((PHEADLESS_CMD_POSITION_CURSOR)InputBuffer)->Y + 1, 
                        ((PHEADLESS_CMD_POSITION_CURSOR)InputBuffer)->X + 1
                       );

                Tmp = &(LocalBuffer[0]);
                break;


            default:
                //
                // should never get here...
                //
                ASSERT(0);
                Status = STATUS_INVALID_PARAMETER;
                goto EndOfFunction;

            }

            HdlspSendStringAtBaud(Tmp);

        }
        Status = STATUS_SUCCESS;
        goto EndOfFunction;

    case HeadlessCmdSetBlueScreenData:

        if (InputBuffer == NULL) {
            return STATUS_INVALID_PARAMETER;
        }

        Status = HdlspSetBlueScreenInformation(InputBuffer, InputBufferSize);
        goto EndOfFunction;

    case HeadlessCmdSendBlueScreenData:            

        if (HeadlessGlobals->TerminalEnabled && HeadlessGlobals->InBugCheck) {

            if ((InputBuffer == NULL) || 
                (InputBufferSize != sizeof(HEADLESS_CMD_SEND_BLUE_SCREEN_DATA))) {
                ASSERT(0);
                return STATUS_INVALID_PARAMETER;
            }

            HdlspSendBlueScreenInfo(((PHEADLESS_CMD_SEND_BLUE_SCREEN_DATA)InputBuffer)->BugcheckCode);

            HdlspSendStringAtBaud((PUCHAR)"\n\r!SAC>");

        }
        goto EndOfFunction;

    case HeadlessCmdQueryGUID:
        
        if( (OutputBuffer == NULL) || 
            (OutputBufferSize == NULL) ||
            (*OutputBufferSize < sizeof(GUID)) ) {

            Status = STATUS_INVALID_PARAMETER;
            goto EndOfFunction;
        }

        RtlCopyMemory( OutputBuffer,
                       &HeadlessGlobals->SystemGUID,
                       sizeof(GUID) );

        Status = STATUS_SUCCESS;
        goto EndOfFunction;


    default:
        Status = STATUS_INVALID_PARAMETER;
        goto EndOfFunction;
        
    }

EndOfFunction:

    if ((Command != HeadlessCmdAddLogEntry) &&
        (Command != HeadlessCmdStartBugCheck) &&
        (Command != HeadlessCmdSendBlueScreenData) &&
        (Command != HeadlessCmdDoBugCheckProcessing)) {

        ASSERT(HeadlessGlobals->ProcessingCmd);

        HeadlessGlobals->ProcessingCmd = FALSE;
    }

    return Status;
}

NTSTATUS
HdlspEnableTerminal(
    BOOLEAN bEnable
    )

/*++

Routine Description:

    This routine attempts to initialize the terminal, if there is one attached, or 
    disconnect the terminal.
    
    Note: Assumes it is called with the global spin lock held!

Arguments:

    bEnable - If TRUE, we will allow Inbv calls to display,
              otherwise we will not.
              
Returns:

    STATUS_SUCCESS if successful, else STATUS_UNSUCCESSFUL.

Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/
{

    //
    // Only enable the port if:
    // - they've asked us to
    // - it's not already enabled
    // - we aren't in bugcheck mode and the port is in MMIO space.  We
    //   need to be careful here because if we are in bugcheck mode, and
    //   the port is in mmio space, then InbvPortInitialize() will call
    //   off to MmMapIoSpace(), which we can't very well do if we're in
    //   the process of bugchecking the machine.

    if ( (bEnable == TRUE) && 
         (!HeadlessGlobals->TerminalEnabled) &&
         !(HeadlessGlobals->IsMMIODevice && HeadlessGlobals->InBugCheck) ) {

        HeadlessGlobals->TerminalEnabled = InbvPortInitialize(
                                               HeadlessGlobals->TerminalBaudRate, 
                                               HeadlessGlobals->TerminalPortNumber, 
                                               HeadlessGlobals->TerminalPortAddress, 
                                               &(HeadlessGlobals->TerminalPort),
                                               HeadlessGlobals->IsMMIODevice
                                              );

        if (!HeadlessGlobals->TerminalEnabled) {
            return STATUS_UNSUCCESSFUL;
        }


        //
        // There's likely stale data on the screen from the loader.
        // Let's clear the screen here before the SAC or anyone else
        // has a chance to put up any data they want.
        //
        HdlspSendStringAtBaud((PUCHAR)"\033[2J");


        //
        // Let's home the cursor too.
        //
        HdlspSendStringAtBaud((PUCHAR)"\033[H");

        //
        // We know we want the FIFO on while using the headless port
        //
        InbvPortEnableFifo(
            HeadlessGlobals->TerminalPort, 
            bEnable
            );

    } else if (bEnable == FALSE) {

        InbvPortTerminate(HeadlessGlobals->TerminalPort);

        HeadlessGlobals->TerminalPort = 0;
        HeadlessGlobals->TerminalEnabled = FALSE;

    }


    
    return STATUS_SUCCESS;
}

VOID
UTF8Encode(
    USHORT  InputValue,
    PUCHAR UTF8Encoding
    )
/*++

Routine Description:

    Generates the UTF8 translation for a 16-bit value.

Arguments:

    InputValue - 16-bit value to be encoded.
    UTF8Encoding - receives the UTF8-encoding of the 16-bit value

Return Value:

    NONE.
--*/
{

    //
    // convert into UTF8 for actual transmission
    //
    // UTF-8 encodes 2-byte Unicode characters as follows:
    // If the first nine bits are zero (00000000 0xxxxxxx), encode it as one byte 0xxxxxxx
    // If the first five bits are zero (00000yyy yyxxxxxx), encode it as two bytes 110yyyyy 10xxxxxx
    // Otherwise (zzzzyyyy yyxxxxxx), encode it as three bytes 1110zzzz 10yyyyyy 10xxxxxx
    //
    if( (InputValue & 0xFF80) == 0 ) {
        //
        // if the top 9 bits are zero, then just
        // encode as 1 byte.  (ASCII passes through unchanged).
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0xFF);
    } else if( (InputValue & 0xF800) == 0 ) {
        //
        // if the top 5 bits are zero, then encode as 2 bytes
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0x3F) | 0x80;
        UTF8Encoding[1] = (UCHAR)((InputValue >> 6) & 0x1F) | 0xC0;
    } else {
        //
        // encode as 3 bytes
        //
        UTF8Encoding[2] = (UCHAR)(InputValue & 0x3F) | 0x80;
        UTF8Encoding[1] = (UCHAR)((InputValue >> 6) & 0x3F) | 0x80;
        UTF8Encoding[0] = (UCHAR)((InputValue >> 12) & 0xF) | 0xE0;
    }
}

VOID
HdlspPutString(
    PUCHAR String
    )

/*++

Routine Description:

    This routine writes a string out to the terminal. 
    
    Note: the routine assumes it is called with the global spin lock held.

Arguments:

    String - NULL terminated string to write.
    
Returns:

    None.

Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/
{
    PUCHAR Src, Dest;
    UCHAR  Char = 0;

    //
    // We need to worry about sending a vt100 characters not in the standard
    // ASCII set, so we copy over only ASCII characters into a new buffer and
    // then send that one to the terminal.
    //
    Src = String;
    Dest = &(HeadlessGlobals->TmpBuffer[0]);

    while (*Src != '\0') {

        if (Dest >= &(HeadlessGlobals->TmpBuffer[HEADLESS_TMP_BUFFER_SIZE - 1])) {
            
            HeadlessGlobals->TmpBuffer[HEADLESS_TMP_BUFFER_SIZE - 1] = '\0';
            HdlspSendStringAtBaud(HeadlessGlobals->TmpBuffer);
            Dest = &(HeadlessGlobals->TmpBuffer[0]);

        } else {

            Char = *Src;

            //
            // filter some characters that aren't printable in VT100
            // into substitute characters which are printable
            //
            if (Char & 0x80) {

                switch (Char) {
                case 0xB0:  // Light shaded block
                case 0xB3:  // Light vertical
                case 0xBA:  // Double vertical line
                    Char = '|';
                    break;
                case 0xB1:  // Middle shaded block
                case 0xDC:  // Lower half block
                case 0xDD:  // Right half block
                case 0xDE:  // Left half block
                case 0xDF:  // Upper half block
                    Char = '%';
                    break;
                case 0xB2:  // Dark shaded block
                case 0xDB:  // Full block
                    Char = '#';
                    break;
                case 0xA9:  // Reversed NOT sign
                case 0xAA:  // NOT sign
                case 0xBB:  // ''
                case 0xBC:  // ''
                case 0xBF:  // ''
                case 0xC0:  // ''
                case 0xC8:  // ''
                case 0xC9:  // ''
                case 0xD9:  // ''
                case 0xDA:  // ''
                    Char = '+';
                    break;
                case 0xC4:  // ''
                    Char = '-';
                    break;
                case 0xCD:  // ''
                    Char = '=';
                    break;
                }

            }



            //
            // If the high-bit is still set, and we're here, then we are going to
            // spew UTF8-encoded data (assuming our terminal type says it's okay).
            //
            if( (Char & 0x80) ) {

                UCHAR  UTF8Encoding[3] = {0};
                ULONG  i;

                //
                // Lookup the Unicode equivilent of this 8-bit ANSI value.
                //
                UTF8Encode( PcAnsiToUnicode[(Char & 0x7F)],
                            UTF8Encoding );

                for( i = 0; i < 3; i++ ) {
                    if( UTF8Encoding[i] != 0 ) {
                        *Dest = UTF8Encoding[i];
                        Dest++;
                    }
                }


            } else {

                //
                // He's 7-bit ASCII.  Put it in the Destination buffer 
                // and move on.
                //
                *Dest = Char;
                Dest++;

            }

            Src++;

        }

    }

    *Dest = '\0';

    HdlspSendStringAtBaud(HeadlessGlobals->TmpBuffer);

}

VOID
HdlspPutData(
    PUCHAR InputBuffer,
    SIZE_T InputBufferSize  
    )

/*++

Routine Description:

    This routine writes an array of UCHARs out to the terminal. 
    
    Note: the routine assumes it is called with the global spin lock held.

Arguments:

    InputBuffer - Array of characters to write.
    
    InputBufferSize - Number of characters to write.
    
Returns:

    None.

Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/
{
    ULONG   i;

    for (i = 0; i < InputBufferSize; i++) {
        
        InbvPortPutByte(HeadlessGlobals->TerminalPort, InputBuffer[i]);
    }

}

BOOLEAN
HdlspGetLine(
    PUCHAR InputBuffer,
    SIZE_T InputBufferLength
    )


/*++

Routine Description:

    This function fills the given buffer with an input line, once the user has
    pressed return.  Until then it will return FALSE.  It strips of leading and
    trailing whitespace.

Arguments:

    InputBuffer - Place to store the terminal input line.
    
    InputBufferLength - Length, in bytes, of InputBuffer.

Return Value:

    TRUE if InputBuffer is filled, else FALSE.

Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/

{
    UCHAR NewByte;
    SIZE_T i;
    KIRQL OldIrql;
    BOOLEAN CheckForLF;

    CheckForLF = FALSE;

    HEADLESS_ACQUIRE_SPIN_LOCK();

    if (HeadlessGlobals->InputProcessing) {
        HEADLESS_RELEASE_SPIN_LOCK();
        return FALSE;
    }

    HeadlessGlobals->InputProcessing = TRUE;

    HEADLESS_RELEASE_SPIN_LOCK();

    //
    // Check if we already have a line to be returned (could happen if 
    // InputBuffer is/was too small to contain the whole line)
    //
    if (HeadlessGlobals->InputLineDone) {
        goto ReturnInputLine;
    }

GetByte:

    if (!InbvPortPollOnly(HeadlessGlobals->TerminalPort) ||
        !InbvPortGetByte(HeadlessGlobals->TerminalPort, &NewByte)) {
        NewByte = 0;
    }

    // 
    // If no waiting input, leave
    //
    if (NewByte == 0) {
        HeadlessGlobals->InputProcessing = FALSE;
        return FALSE;
    }

    //
    // Store input character in our buffer
    //
    HeadlessGlobals->InputBuffer[HeadlessGlobals->InputBufferIndex] = NewByte;

    //
    // filter out the LF if we JUST received a CR
    //
    if (HeadlessGlobals->IsLastCharCR) {
        
        //
        // if this is a LF, then ignore it and go get the next character.
        // if this is NOT an LF, then there is nothing to do
        //
        if (NewByte == 0x0A) {
        
            HeadlessGlobals->IsLastCharCR = FALSE;
            
            goto GetByte;
        
        }

    }

    //
    // if this is a CR, then remember it
    //
    HeadlessGlobals->IsLastCharCR = (NewByte == 0x0D) ? TRUE : FALSE;

    // 
    // If this is a return, then we are done and need to return the line
    //
    if ((NewByte == (UCHAR)'\n') || (NewByte == (UCHAR)'\r')) {
        HdlspSendStringAtBaud((PUCHAR)"\r\n");
        HeadlessGlobals->InputBuffer[HeadlessGlobals->InputBufferIndex] = '\0';
        HeadlessGlobals->InputBufferIndex++;
        goto StripWhitespaceAndReturnLine;
    }

    //
    // If this is a backspace or delete, then we need to do that.
    //
    if ((NewByte == 0x8) || (NewByte == 0x7F)) {  // backspace (^H) or delete

        if (HeadlessGlobals->InputBufferIndex > 0) {
            HdlspSendStringAtBaud((PUCHAR)"\010 \010");
            HeadlessGlobals->InputBufferIndex--;
        }

    } else if (NewByte == 0x3) { // Control-C

        //
        // Terminate the string and return it.
        //
        HeadlessGlobals->InputBufferIndex++;
        HeadlessGlobals->InputBuffer[HeadlessGlobals->InputBufferIndex] = '\0';
        HeadlessGlobals->InputBufferIndex++;
        goto StripWhitespaceAndReturnLine;

    } else if ((NewByte == 0x9) || (NewByte == 0x1B)) { // Tab or Esc

        //
        // Ignore tabs and escapes
        //
        HdlspSendStringAtBaud((PUCHAR)"\007");
        HeadlessGlobals->InputProcessing = FALSE;
        return FALSE;

    } else if (HeadlessGlobals->InputBufferIndex == HEADLESS_TMP_BUFFER_SIZE - 2) {
        
        //
        // We are at the end of the buffer - remove the last character from 
        // the terminal screen and replace it with this one.
        //
        sprintf((LPSTR)HeadlessGlobals->TmpBuffer, "\010%c", NewByte);
        HdlspSendStringAtBaud(HeadlessGlobals->TmpBuffer);

    } else {

        //
        // Echo the character to the screen
        //
        sprintf((LPSTR)HeadlessGlobals->TmpBuffer, "%c", NewByte);
        HdlspSendStringAtBaud(HeadlessGlobals->TmpBuffer);
        HeadlessGlobals->InputBufferIndex++;

    }

    goto GetByte;

StripWhitespaceAndReturnLine:

    //
    // Before returning the input line, strip off all leading and trailing blanks
    //
    ASSERT(HeadlessGlobals->InputBufferIndex > 0);

    i = HeadlessGlobals->InputBufferIndex - 1;

    while ((i != 0) &&
           ((HeadlessGlobals->InputBuffer[i] == '\0') ||
            (HeadlessGlobals->InputBuffer[i] == ' ') ||
            (HeadlessGlobals->InputBuffer[i] == '\t'))) {
        i--;
    }

    if (HeadlessGlobals->InputBuffer[i] != '\0') {      
        HeadlessGlobals->InputBuffer[i + 1] = '\0';
    }

    i = 0;

    while ((HeadlessGlobals->InputBuffer[i] != '\0') &&
           ((HeadlessGlobals->InputBuffer[i] == '\t') ||
            (HeadlessGlobals->InputBuffer[i] == ' '))) {
        i++;
    }

    if (i != 0) {
        strcpy(
            (LPSTR)&(HeadlessGlobals->InputBuffer[0]), 
            (LPSTR)&(HeadlessGlobals->InputBuffer[i]));
    }

ReturnInputLine:

    //
    // Return the line.
    //

    if (InputBufferLength >= HeadlessGlobals->InputBufferIndex) {

        RtlCopyMemory(InputBuffer, HeadlessGlobals->InputBuffer, HeadlessGlobals->InputBufferIndex);
        HeadlessGlobals->InputBufferIndex = 0;
        HeadlessGlobals->InputLineDone = FALSE;

    } else {

        RtlCopyMemory(InputBuffer, HeadlessGlobals->InputBuffer, InputBufferLength);
        RtlCopyBytes(HeadlessGlobals->InputBuffer, 
                     &(HeadlessGlobals->InputBuffer[InputBufferLength]), 
                     HeadlessGlobals->InputBufferIndex - InputBufferLength
                    );
        HeadlessGlobals->InputLineDone = TRUE;
        HeadlessGlobals->InputBufferIndex -= InputBufferLength;

    }    

    HeadlessGlobals->InputProcessing = FALSE;

    return TRUE;
}

NTSTATUS
HeadlessTerminalAddResources(
    PCM_RESOURCE_LIST Resources,
    ULONG ResourceListSize,
    BOOLEAN TranslatedList,
    PCM_RESOURCE_LIST *NewList,
    PULONG NewListSize
    )


/*++

Routine Description:

    This function adds any resources that the terminal needs to the list of resources
    given, reallocating to a new block if necessary.

Arguments:

    Resources - The current resource list.
    
    ResourceListSize - Length, in bytes, of the list.
    
    TranslatedList - Is this a translated list or not.
    
    NewList - A pointer to an allocated new list, if headless adds something, otherwise
          it will return NULL, indicating no new resources were added.
    
    NewListSize - Returns the length, in bytes, of the returned list.

Return Value:

    STATUS_SUCCESS if successful, else STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR NewDescriptor;
    PHYSICAL_ADDRESS Address;
    PHYSICAL_ADDRESS TranslatedAddress;
    ULONG AddressSpace;

    if (HeadlessGlobals == NULL) {        
        *NewList = NULL;
        *NewListSize = 0;
        return STATUS_SUCCESS;
    }

    if( HeadlessGlobals->IsNonLegacyDevice ) {
        *NewList = NULL;
        *NewListSize = 0;
        return STATUS_SUCCESS;
    }

    //
    // Allocate space for a new list.
    //
    *NewListSize = ResourceListSize + sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

    *NewList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(PagedPool,
                                                        *NewListSize,
                                                        'sldH');
    
    if (*NewList == NULL) {
        *NewListSize = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy old list into the new buffer
    // 
    RtlCopyMemory(*NewList, Resources, ResourceListSize);

    Address.QuadPart = (ULONG_PTR)HeadlessGlobals->TerminalPortAddress;

    //
    // If this port information is supposed to be translated, do it.
    //
    if (TranslatedList) {
        AddressSpace = 1;   // Address space port.
        HalTranslateBusAddress(Internal,                    // device bus or internal
                               0,                           // bus number
                               Address,                     // source address
                               &AddressSpace,               // address space
                               &TranslatedAddress           // translated address
                              ); 

    } else {
        TranslatedAddress = Address;
    }


    //
    // Add our stuff to the end.
    //
    (*NewList)->Count++;

    NewDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)(((PUCHAR)(*NewList)) + ResourceListSize);

    NewDescriptor->BusNumber = 0;
    NewDescriptor->InterfaceType = Isa;

    NewDescriptor->PartialResourceList.Count = 1;
    NewDescriptor->PartialResourceList.Revision = 0;
    NewDescriptor->PartialResourceList.Version = 0;
    NewDescriptor->PartialResourceList.PartialDescriptors[0].Type = CmResourceTypePort;
    NewDescriptor->PartialResourceList.PartialDescriptors[0].ShareDisposition = 
        CmResourceShareDriverExclusive; 
    NewDescriptor->PartialResourceList.PartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO;
    NewDescriptor->PartialResourceList.PartialDescriptors[0].u.Port.Start = 
        TranslatedAddress;
    NewDescriptor->PartialResourceList.PartialDescriptors[0].u.Port.Length = 0x8;

    return STATUS_SUCCESS;
}

VOID
HdlspBugCheckProcessing(
    VOID
    )
/*++

Routine Description:

    This function is used to prompt and display information to the user via the 
    terminal.  The system is assumed to be singly threaded and at a raised IRQL state.
    
    NOTE: This is pre-emptive to the system, so no locking required.

Arguments:

    None.

Return Value:

    None.
    
Environment:

    ONLY IN BUGCHECK!

--*/
{
    UCHAR InputBuffer[HEADLESS_TMP_BUFFER_SIZE];
    ULONG i;

    ASSERT(HeadlessGlobals->InBugCheck);

    //
    // Check for characters
    //
    if (HdlspGetLine(InputBuffer, HEADLESS_TMP_BUFFER_SIZE)) {
        
        //
        // Process the line
        //
        if ((_stricmp((LPCSTR)InputBuffer, "?") == 0) ||
            (_stricmp((LPCSTR)InputBuffer, "help") == 0)) {

            HdlspSendStringAtBaud((PUCHAR)"\r\n");
            HdlspSendStringAtBaud((PUCHAR)"d        Display all log entries, paging is on.\r\n");
            HdlspSendStringAtBaud((PUCHAR)"help     Display this list.\r\n");
            HdlspSendStringAtBaud((PUCHAR)"restart  Restart the system immediately.\r\n");
            HdlspSendStringAtBaud((PUCHAR)"?        Display this list.\r\n");
            HdlspSendStringAtBaud((PUCHAR)"\r\n");

        } else if (_stricmp((LPCSTR)InputBuffer, "d") == 0) {

            HdlspProcessDumpCommand(TRUE);

        } else if (_stricmp((LPCSTR)InputBuffer, "restart") == 0) {

            InbvSolidColorFill(0,0,639,479,0); // make the screen black
            for (i =0; i<10; i++) { // pause long enough for things to get out serial port
                KeStallExecutionProcessor(100000);
            }
            HalReturnToFirmware(HalRebootRoutine);

        } else {
            HdlspSendStringAtBaud((PUCHAR)"Type ? or Help for a list of commands.\r\n");
        }

        //
        // Put a new command prompt
        //
        HdlspSendStringAtBaud((PUCHAR)"\n\r!SAC>");
    }

}

VOID
HdlspProcessDumpCommand( 
    IN BOOLEAN Paging
    )
/*++

Routine Description:

    This function is used to display all current log entries.

Arguments:

    Paging - Should this do paging or not.

Return Value:

    None.

Environment: 
    
    May only be called from a raised IRQL if a StartBugCheck command has been issued.

--*/
{
    PHEADLESS_LOG_ENTRY LogEntry;
    ULONG LogEntryIndex;
    TIME_FIELDS TimeFields;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    ULONG LineNumber;
    BOOLEAN Stop;
    KIRQL OldIrql;
    
    HEADLESS_ACQUIRE_SPIN_LOCK();

    if (HeadlessGlobals->LogEntryStart == (USHORT)-1) {
        
        HEADLESS_RELEASE_SPIN_LOCK();
        return;
    }

    HeadlessGlobals->NewLogEntryAdded = FALSE;

    AnsiString.Length = 0;
    AnsiString.MaximumLength = HEADLESS_TMP_BUFFER_SIZE;
    AnsiString.Buffer = (PCHAR)HeadlessGlobals->TmpBuffer;

    LogEntryIndex = HeadlessGlobals->LogEntryStart;
    LineNumber = 0;

    while (TRUE) {

        LogEntry = &(HeadlessGlobals->LogEntries[LogEntryIndex]);

        //
        // Print the log entry out to the terminal.
        //

        HEADLESS_RELEASE_SPIN_LOCK();

        RtlTimeToTimeFields(&(LogEntry->TimeOfEntry.CurrentTime), &TimeFields);

        sprintf((LPSTR)HeadlessGlobals->TmpBuffer, 
                "%02d:%02d:%02d.%03d : ",
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second,
                TimeFields.Milliseconds
               );


        HdlspPutString(HeadlessGlobals->TmpBuffer);

        if (wcslen(LogEntry->String) >= HEADLESS_TMP_BUFFER_SIZE - 1) {
            LogEntry->String[HEADLESS_TMP_BUFFER_SIZE - 1] = UNICODE_NULL;
        }

        RtlInitUnicodeString(&UnicodeString, LogEntry->String);
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);        
        
        HEADLESS_ACQUIRE_SPIN_LOCK();

        if (HeadlessGlobals->NewLogEntryAdded) {

            //
            // Inform user and quite current output
            //
            HdlspPutString((PUCHAR)"New log entries have been added during dump, command aborted.\r\n");

            HEADLESS_RELEASE_SPIN_LOCK();
            return;
        }

        HdlspPutString(HeadlessGlobals->TmpBuffer);
        HdlspPutString((PUCHAR)"\r\n");
        LineNumber++;

        //
        // if last item, exit loop.
        //
        if (LogEntryIndex == HeadlessGlobals->LogEntryLast) {
            HEADLESS_RELEASE_SPIN_LOCK();
            return;
        }

        //
        // If screen is full, pause for paging.
        //
        if (Paging && (LineNumber > 20)) {

            HEADLESS_RELEASE_SPIN_LOCK();

            HdlspPutMore(&Stop);

            HEADLESS_ACQUIRE_SPIN_LOCK();

            if (Stop) {

                HdlspPutString((PUCHAR)"\r\n");

                HEADLESS_RELEASE_SPIN_LOCK();
                return;
            }

            if (HeadlessGlobals->NewLogEntryAdded) {

                //
                // Inform user and quite current output
                //
                HdlspPutString((PUCHAR)"New log entries have been added while waiting, command aborted.\r\n");

                HEADLESS_RELEASE_SPIN_LOCK();
                return;
            }

            LineNumber = 0;
        }

        //
        // Next entry please
        //
        LogEntryIndex++;
        LogEntryIndex %= HEADLESS_LOG_NUMBER_OF_ENTRIES;
    }
    
}

VOID
HdlspPutMore(
    OUT PBOOLEAN Stop
    )
/*++

Routine Description:

    This function is used to display a paging prompt.

Arguments:

    Stop - Returns TRUE if Control-C was pressed, else FALSE.

Return Value:

    Stop - Returns TRUE if Control-C was pressed, else FALSE.

--*/
{
    UCHAR Buffer[10];
    LARGE_INTEGER WaitTime;
    
    WaitTime.QuadPart = Int32x32To64((LONG)100, -1000); // 100ms from now.

    HdlspPutString((PUCHAR)"----Press <Enter> for more----");

    while (!HdlspGetLine(Buffer, 10)) {
        if (!HeadlessGlobals->InBugCheck) {
            KeDelayExecutionThread(KernelMode, FALSE, &WaitTime);
        }
    }
    if (Buffer[0] == 0x3) { // Control-C
        *Stop = TRUE;
    } else {
        *Stop = FALSE;
    }
    
    // 
    // Drain any remaining buffered input
    //
    while (HdlspGetLine(Buffer, 10)) {
    }
}

VOID
HdlspAddLogEntry(
    PWCHAR String
    )
/*++

Routine Description:

    This function is used to add a string to the internal log buffer.

Arguments:

    String - The string to add.

Return Value:

    None.
    
Environment:

    Only called from HdlspDispatch, which guarantees it is paged in and locked down.

--*/
{
    SIZE_T StringSize;
    PWCHAR OldString = NULL;    
    PWCHAR NewString;    
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfEntry;
    NTSTATUS Status;
    KIRQL OldIrql;

    StringSize = (wcslen(String) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);

    //
    // Guard against ZwQuery..() call being paged out.
    //
    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
        return;
    }

    //
    // Get the time so we can log it.
    //
    Status = ZwQuerySystemInformation(SystemTimeOfDayInformation,
                                      &TimeOfEntry,
                                      sizeof(TimeOfEntry),
                                      NULL
                                     );

    if (!NT_SUCCESS(Status)) {
        
        RtlZeroMemory(&TimeOfEntry, sizeof(TimeOfEntry));

    }
    
    //
    // Allocate a string for the log entry.
    //
    NewString = ExAllocatePoolWithTag(NonPagedPool, StringSize, ((ULONG)'sldH'));

    if (NewString != NULL) {
        RtlCopyMemory(NewString, String, StringSize);
    }

    HEADLESS_ACQUIRE_SPIN_LOCK();

    HeadlessGlobals->NewLogEntryAdded = TRUE;
    
    //
    // Get the entry to use.
    //
    HeadlessGlobals->LogEntryLast++;
    HeadlessGlobals->LogEntryLast %= HEADLESS_LOG_NUMBER_OF_ENTRIES;

    //
    // See if we have to move the start entry index
    //
    if (HeadlessGlobals->LogEntryLast == HeadlessGlobals->LogEntryStart) {

        //
        // Store away the old string so we can free it later.
        //
        if (wcscmp(HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryStart].String,
                   HEADLESS_OOM_STRING) != 0) {

            OldString = HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryStart].String;
        }

        HeadlessGlobals->LogEntryStart++;;
        HeadlessGlobals->LogEntryStart %= HEADLESS_LOG_NUMBER_OF_ENTRIES;

    } else if (HeadlessGlobals->LogEntryStart == (USHORT)-1) {

        HeadlessGlobals->LogEntryStart = 0;

    }


    //
    // Fill in the entry part
    //
    RtlCopyMemory(&(HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryLast].TimeOfEntry),
                  &(TimeOfEntry),
                  sizeof(TimeOfEntry)
                 );

    //
    // Set the entry pointer
    //
    if (NewString == NULL) {
        HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryLast].String = HEADLESS_OOM_STRING;
    } else {
        HeadlessGlobals->LogEntries[HeadlessGlobals->LogEntryLast].String = NewString;
    }

    HEADLESS_RELEASE_SPIN_LOCK();
    
    if (OldString != NULL) {
        ExFreePool(OldString);
    }

}


NTSTATUS
HdlspSetBlueScreenInformation(
    IN PHEADLESS_CMD_SET_BLUE_SCREEN_DATA pData,
    IN SIZE_T cData
    )
/*++

Routine Description:

    This routines allows components to set bugcheck information about the headless 
    terminal.

Arguments:

    pData - A pointer to the data, value pair to store.
    
    cData - Length, in bytes, of pData.

Return Value:

    Status of the operation - STATUS_SUCCESS, STATUS_NO_MEMORY e.g.

Environment: 

    HdlspDispatch guarantess only one person to enter this procedure.
    
    This is the only procedure modifying the HeadlessGlobals->BlueScreenData
    However, bugcheck processing uses this information to send it across the 
    blue screen at dispatch level. No hand shaking required except ensuring that 
    changes to the list are done such that once bugcheck processing starts, the list
    is unchanged. May cause a memory leak in a bugcheck situation, but in essence 
    that is better than an access violation, and acceptable since the machine is stopping.

--*/
{

    PHEADLESS_BLUE_SCREEN_DATA HeadlessProp,Prev;
    NTSTATUS Status;
    PUCHAR pVal,pOldVal;
    PUCHAR pNewVal;
    SIZE_T len;
    
    ASSERT(FIELD_OFFSET(HEADLESS_CMD_SET_BLUE_SCREEN_DATA,Data) == sizeof(ULONG));

    if (HeadlessGlobals->InBugCheck) { 
        return STATUS_UNSUCCESSFUL;
    }

    if ((pData == NULL) || 
        (pData->ValueIndex < 2) || // There must be at least two \0 characters in the pair.
        (pData->ValueIndex  >= (cData - sizeof(HEADLESS_CMD_SET_BLUE_SCREEN_DATA)) / sizeof (UCHAR)) ||
        (pData->Data[pData->ValueIndex-1] != '\0') ||
        (pData->Data[(cData - sizeof(HEADLESS_CMD_SET_BLUE_SCREEN_DATA))/sizeof(UCHAR)] != '\0' )) {

        return STATUS_INVALID_PARAMETER;
    }

    Status = STATUS_SUCCESS;

    //
    // Manipulation of this linked list is done only by this single entrant
    // function.
    //
    HeadlessProp = Prev = HeadlessGlobals->BlueScreenData;

    while (HeadlessProp) {

        if (strcmp((LPCSTR)HeadlessProp->Property, (LPCSTR)pData->Data) == 0) {
            break;
        }
        Prev = HeadlessProp;
        HeadlessProp = HeadlessProp->Next;
    }

    
    pVal = (PUCHAR)&((pData->Data)[pData->ValueIndex]);

    len = strlen((LPCSTR)pVal);    

    if (HeadlessProp != NULL) {

        //
        // The property exists. So replace it.
        //
        if (len) {

            //
            // need to replace old string.
            //
            pNewVal = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool,
                                                   len+1,
                                                   ((ULONG)'sldH') 
                                                  );

            if (pNewVal) {
                strcpy( (LPSTR)pNewVal, (LPCSTR)pVal );

                pOldVal = HeadlessProp->XMLData;
                HeadlessProp->XMLData = pNewVal;

                if (HeadlessGlobals->InBugCheck == FALSE) {
                    ExFreePool(pOldVal);
                }

            } else {
                Status = STATUS_NO_MEMORY;
            }

        } else {

            //
            // We want to delete it, hence we passed an empty string
            //
            Prev->Next = HeadlessProp->Next;

            if (HeadlessGlobals->BlueScreenData == HeadlessProp) {
                HeadlessGlobals->BlueScreenData = Prev->Next;
            }

            if (HeadlessGlobals->InBugCheck == FALSE) {
                ExFreePool ( HeadlessProp->XMLData );
                ExFreePool ( HeadlessProp->Property );
                ExFreePool ( HeadlessProp );
            }

        }

    } else {
    
        //
        // Create a new Property-XMLValue Pair
        //
        if (len) { // Must be a non-empty string
            
            HeadlessProp = (PHEADLESS_BLUE_SCREEN_DATA)ExAllocatePoolWithTag(NonPagedPool,
                                                                             sizeof(HEADLESS_BLUE_SCREEN_DATA),
                                                                             ((ULONG) 'sldH' )
                                                                            );

            if (HeadlessProp) {
                
                HeadlessProp->XMLData = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool,
                                                                      len+1,
                                                                      ((ULONG)'sldH')
                                                                     );
                if (HeadlessProp->XMLData) {

                    strcpy((LPSTR)HeadlessProp->XMLData,(LPCSTR)pVal);
                    pVal = pData->Data; 
                    len = strlen ((LPCSTR)pVal);

                    if (len) {

                        HeadlessProp->Property = (PUCHAR)ExAllocatePoolWithTag(NonPagedPool,
                                                                               len+1,
                                                                               ((ULONG)'sldH')
                                                                              );

                        if (HeadlessProp->Property) {

                            strcpy((LPSTR)HeadlessProp->Property,(LPCSTR) pVal);
                            HeadlessProp->Next = HeadlessGlobals->BlueScreenData;
                            HeadlessGlobals->BlueScreenData = HeadlessProp;

                        } else {
                            
                            Status = STATUS_NO_MEMORY;
                            ExFreePool(HeadlessProp->XMLData);
                            ExFreePool ( HeadlessProp );

                        }

                    } else { // empty property string ( will never come here ) 

                        Status = STATUS_INVALID_PARAMETER;
                        ExFreePool(HeadlessProp->XMLData);
                        ExFreePool(HeadlessProp);

                    }

                } else {

                    Status = STATUS_NO_MEMORY;
                    ExFreePool(HeadlessProp);

                }
            }

        } else {// empty value string.

            Status = STATUS_INVALID_PARAMETER;

        }

    }

    return Status;
}


VOID
HdlspSendBlueScreenInfo(
    ULONG BugcheckCode
    )
/*++

Routine Description:

    This routines dumps all the current blue screen data to the terminal.

Arguments:

    BugcheckCode - the NT defined bug check code.
    
Return Value:

    None.

Environment: 

    Only called once in a bugcheck.
    
--*/
{
    PHEADLESS_BLUE_SCREEN_DATA pData;
    UCHAR Temp[160];

    ASSERT(HeadlessGlobals->InBugCheck);

    HdlspSendStringAtBaud((PUCHAR)"\007\007\007<?xml>\007<BP>");

    HdlspSendStringAtBaud((PUCHAR)"\r\n<INSTANCE CLASSNAME=\"BLUESCREEN\">");

    sprintf((LPSTR)Temp,"\r\n<PROPERTY NAME=\"STOPCODE\" TYPE=\"string\"><VALUE>\"0x%0X\"</VALUE></PROPERTY>",BugcheckCode);

    HdlspSendStringAtBaud(Temp);

    pData = HeadlessGlobals->BlueScreenData;

    while (pData) {

        HdlspSendStringAtBaud(pData->XMLData);
        pData = pData->Next;

    }

    HdlspSendStringAtBaud((PUCHAR)"\r\n</INSTANCE>\r\n</BP>\007");

}

VOID
HeadlessKernelAddLogEntry(
    IN ULONG StringCode,
    IN PUNICODE_STRING DriverName OPTIONAL
    )

/*++

Routine Description:

    This routine adds a string to the headless log if possible.

Parameters:

    StringCode - The string to add.
    
    DriverName - An optional parameter that some string codes require.

Return Value:

    None.

--*/

{
    //
    // If headless not enabled, just exit now.
    //
    if ((HeadlessGlobals == NULL) || (HeadlessGlobals->PageLockHandle == NULL)) {
        return;
    }

    //
    // Call the paged version of this routine.  Note: it will not be paged here,
    // as the handle is non-NULL.
    //
    HdlspKernelAddLogEntry(StringCode, DriverName);
}

VOID
HdlspKernelAddLogEntry(
    IN ULONG StringCode,
    IN PUNICODE_STRING DriverName OPTIONAL
    )

/*++

Routine Description:

    This routine adds a string to the headless log if possible.

Parameters:

    StringCode - The string to add.
    
    DriverName - An optional parameter that some string codes require.

Return Value:

    None.

--*/

{
    PHEADLESS_CMD_ADD_LOG_ENTRY HeadlessLogEntry;
    UCHAR LocalBuffer[sizeof(HEADLESS_CMD_ADD_LOG_ENTRY) + 
                        (HDLSP_LOG_MAX_STRING_LENGTH * sizeof(WCHAR))];
    SIZE_T Index;
    SIZE_T StringLength;
    PWCHAR String;


    HeadlessLogEntry = (PHEADLESS_CMD_ADD_LOG_ENTRY)LocalBuffer;

    //
    // Get the string associated with this string code.
    //
    switch (StringCode) {
    case HEADLESS_LOG_LOADING_FILENAME:
        String = L"KRNL: Loading ";
        break;

    case HEADLESS_LOG_LOAD_SUCCESSFUL:
        String = L"KRNL: Load succeeded.";
        break;

    case HEADLESS_LOG_LOAD_FAILED:
        String = L"KRNL: Load failed.";
        break;

    case HEADLESS_LOG_EVENT_CREATE_FAILED:
        String = L"KRNL: Failed to create event.";
        break;

    case HEADLESS_LOG_OBJECT_TYPE_CREATE_FAILED:
        String = L"KRNL: Failed to create object types.";
        break;

    case HEADLESS_LOG_ROOT_DIR_CREATE_FAILED:
        String = L"KRNL: Failed to create root directories.";
        break;

    case HEADLESS_LOG_PNP_PHASE0_INIT_FAILED:
        String = L"KRNL: Failed to initialize (phase 0) plug and play services.";
        break;

    case HEADLESS_LOG_PNP_PHASE1_INIT_FAILED:
        String = L"KRNL: Failed to initialize (phase 1) plug and play services.";
        break;

    case HEADLESS_LOG_BOOT_DRIVERS_INIT_FAILED:
        String = L"KRNL: Failed to initialize boot drivers.";
        break;

    case HEADLESS_LOG_LOCATE_SYSTEM_DLL_FAILED:
        String = L"KRNL: Failed to locate system dll.";
        break;

    case HEADLESS_LOG_SYSTEM_DRIVERS_INIT_FAILED:
        String = L"KRNL: Failed to initialize system drivers.";
        break;
    
    case HEADLESS_LOG_ASSIGN_SYSTEM_ROOT_FAILED:
        String = L"KRNL: Failed to reassign system root.";
        break;

    case HEADLESS_LOG_PROTECT_SYSTEM_ROOT_FAILED:
        String = L"KRNL: Failed to protect system partition.";
        break;

    case HEADLESS_LOG_UNICODE_TO_ANSI_FAILED:
        String = L"KRNL: Failed to UnicodeToAnsi system root.";
        break;

    case HEADLESS_LOG_ANSI_TO_UNICODE_FAILED:
        String = L"KRNL: Failed to AnsiToUnicode system root.";
        break;

    case HEADLESS_LOG_FIND_GROUPS_FAILED:
        String = L"KRNL: Failed to find any groups.";
        break;

    case HEADLESS_LOG_WAIT_BOOT_DEVICES_DELETE_FAILED:
        String = L"KRNL: Failed waiting for boot devices to delete.";
        break;

    case HEADLESS_LOG_WAIT_BOOT_DEVICES_START_FAILED:
        String = L"KRNL: Failed waiting for boot devices to start.";
        break;

    case HEADLESS_LOG_WAIT_BOOT_DEVICES_REINIT_FAILED:
        String = L"KRNL: Failed waiting for boot devices to reinit.";
        break;

    case HEADLESS_LOG_MARK_BOOT_PARTITION_FAILED:
        String = L"KRNL: Failed marking boot partition.";
        break;

    default:
        ASSERT(0);
        String = NULL;
    }

    if (String != NULL) {
        
        //
        // Start by copying in the given string.
        //
        wcscpy(&(HeadlessLogEntry->String[0]), String);

    } else {

        HeadlessLogEntry->String[0] = UNICODE_NULL;

    }

    //
    // If this is the loading_filename command, then we need to append the
    // name to the end.
    //
    if ((StringCode == HEADLESS_LOG_LOADING_FILENAME) && (DriverName != NULL)) {

        ASSERT(String != NULL);

        StringLength = wcslen(String);

        //
        // Only copy as many bytes as we have room for.
        //
        if ((DriverName->Length / sizeof(WCHAR)) >= (HDLSP_LOG_MAX_STRING_LENGTH - StringLength)) {
            Index = (HDLSP_LOG_MAX_STRING_LENGTH - StringLength - 1);
        } else {
            Index = DriverName->Length / sizeof(WCHAR);
        }

        //
        // Copy in this many bytes.
        //
        RtlCopyBytes(&(HeadlessLogEntry->String[StringLength]),
                     DriverName->Buffer,
                     Index * sizeof(WCHAR)
                    );

        if (DriverName->Buffer[(DriverName->Length / sizeof(WCHAR)) - 1] != UNICODE_NULL) {
            HeadlessLogEntry->String[StringLength + Index] = UNICODE_NULL;
        }
    }

    //
    // Log it.
    //
    HdlspDispatch(HeadlessCmdAddLogEntry,
                  HeadlessLogEntry,
                  sizeof(HEADLESS_CMD_ADD_LOG_ENTRY) + 
                      (wcslen(&(HeadlessLogEntry->String[0])) * sizeof(WCHAR)),
                  NULL,
                  NULL
                 );
}

VOID
HdlspSendStringAtBaud(
    IN PUCHAR String
    )

/*++

Routine Description:

    This routine outputs a string one character at a time to the terminal, fitting the
    baud rate specified for the connection.

Parameters:

    String - The string to send.
    
Return Value:

    None.

--*/

{
    PUCHAR Dest;

    for (Dest = String; *Dest != '\0'; Dest++) {
        
        InbvPortPutByte(HeadlessGlobals->TerminalPort, *Dest);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\handle.c ===
/*++

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module implements a set of functions for supporting handles.

Author:

    Steve Wood (stevewo) 25-Apr-1989
    David N. Cutler (davec) 17-May-1995 (rewrite)
    Gary Kimura (GaryKi) 9-Dec-1997 (rerewrite)

    Adrian Marinescu (adrmarin) 24-May-2000
        Support dynamic changes to the number of levels we use. The code
        performs the best for typical handle table sizes and scales better.

    Neill Clift (NeillC) 24-Jul-2000
        Make the handle allocate, free and duplicate paths mostly lock free except
        for the lock entry locks, table expansion and locks to solve the A-B-A problem.

Revision History:

--*/

#include "exp.h"
#pragma hdrstop


//
//  Local constants and support routines
//

//
//  Define global structures that link all handle tables together except the
//  ones where the user has called RemoveHandleTable
//


#if !DBG // Make this a const varible so its optimized away on free
const
#endif
BOOLEAN ExTraceAllTables = FALSE;

EX_PUSH_LOCK HandleTableListLock;

ULONG TotalTraceBuffers = 0;

#ifdef ALLOC_PRAGMA
#pragma data_seg("PAGED")
#endif

LIST_ENTRY HandleTableListHead;

#ifdef ALLOC_PRAGMA
#pragma data_seg()
#endif

#if DBG
#define EXHANDLE_EXTRA_CHECKS 0
#else
#define EXHANDLE_EXTRA_CHECKS 0
#endif

#if EXHANDLE_EXTRA_CHECKS

#define EXASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)

#else

#define EXASSERT ASSERT

#endif

//
//  This is the sign low bit used to lock handle table entries
//

#define EXHANDLE_TABLE_ENTRY_LOCK_BIT    1

#define EX_ADDITIONAL_INFO_SIGNATURE (-2)

#define ExpIsValidObjectEntry(Entry) \
    ( (Entry != NULL) && (Entry->Object != NULL) && (Entry->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE) )


#define TABLE_PAGE_SIZE PAGE_SIZE

//
// Absolute maximum number of handles allowed
//
#define MAX_HANDLES (1<<24)

#if EXHANDLE_EXTRA_CHECKS

//
// Mask for next free value from the free lists.
//
#define FREE_HANDLE_MASK ((MAX_HANDLES<<2) - 1)

#else

//
// When no checks compiled in this gets optimized away
//
#define FREE_HANDLE_MASK 0xFFFFFFFF

#endif

//
// Mask for the free list sequence number
//
#define FREE_SEQ_MASK (0xFFFFFFFF & ~FREE_HANDLE_MASK)


#if (FREE_HANDLE_MASK == 0xFFFFFFFF)
#define FREE_SEQ_INC 0
#define GetNextSeq() 0
#else
//
// Increment value to progress the sequence number
//
#define FREE_SEQ_INC  (FREE_HANDLE_MASK + 1)
ULONG CurrentSeq = 0;
#define GetNextSeq() (CurrentSeq += FREE_SEQ_INC)
#endif



#define LOWLEVEL_COUNT (TABLE_PAGE_SIZE / sizeof(HANDLE_TABLE_ENTRY))
#define MIDLEVEL_COUNT (PAGE_SIZE / sizeof(PHANDLE_TABLE_ENTRY))
#define HIGHLEVEL_COUNT  MAX_HANDLES / (LOWLEVEL_COUNT * MIDLEVEL_COUNT)

#define LOWLEVEL_THRESHOLD LOWLEVEL_COUNT
#define MIDLEVEL_THRESHOLD (MIDLEVEL_COUNT * LOWLEVEL_COUNT)
#define HIGHLEVEL_THRESHOLD (MIDLEVEL_COUNT * MIDLEVEL_COUNT * LOWLEVEL_COUNT)

#define HIGHLEVEL_SIZE (HIGHLEVEL_COUNT * sizeof (PHANDLE_TABLE_ENTRY))

#define LEVEL_CODE_MASK 3

//
//  Local support routines
//

PHANDLE_TABLE
ExpAllocateHandleTable (
    IN PEPROCESS Process OPTIONAL,
    IN BOOLEAN DoInit
    );

VOID
ExpFreeHandleTable (
    IN PHANDLE_TABLE HandleTable
    );

BOOLEAN
ExpAllocateHandleTableEntrySlow (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit
    );

PHANDLE_TABLE_ENTRY
ExpAllocateHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    OUT PEXHANDLE Handle
    );

VOID
ExpFreeHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    );

PHANDLE_TABLE_ENTRY
ExpLookupHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle
    );

PHANDLE_TABLE_ENTRY *
ExpAllocateMidLevelTable (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit,
    OUT PHANDLE_TABLE_ENTRY *pNewLowLevel
    );

PVOID
ExpAllocateTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    );

VOID
ExpFreeTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN PVOID PoolMemory,
    IN SIZE_T NumberOfBytes
    );

PHANDLE_TABLE_ENTRY
ExpAllocateLowLevelTable (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit
    );

VOID
ExpFreeLowLevelTable (
    IN PEPROCESS QuotaProcess,
    IN PHANDLE_TABLE_ENTRY TableLevel1
    );

VOID
ExpBlockOnLockedHandleEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    );

ULONG
ExpMoveFreeHandles (
    IN PHANDLE_TABLE HandleTable
    );

VOID
ExpUpdateDebugInfo(
    PHANDLE_TABLE HandleTable,
    PETHREAD CurrentThread,
    HANDLE Handle,
    ULONG Type
    );

PVOID
ExpAllocateTablePagedPoolNoZero (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExInitializeHandleTablePackage)
#pragma alloc_text(INIT, ExSetHandleTableStrictFIFO)
#pragma alloc_text(PAGE, ExUnlockHandleTableEntry)
#pragma alloc_text(PAGE, ExCreateHandleTable)
#pragma alloc_text(PAGE, ExRemoveHandleTable)
#pragma alloc_text(PAGE, ExDestroyHandleTable)
#pragma alloc_text(PAGE, ExEnumHandleTable)
#pragma alloc_text(PAGE, ExDupHandleTable)
#pragma alloc_text(PAGE, ExSnapShotHandleTables)
#pragma alloc_text(PAGE, ExCreateHandle)
#pragma alloc_text(PAGE, ExDestroyHandle)
#pragma alloc_text(PAGE, ExChangeHandle)
#pragma alloc_text(PAGE, ExMapHandleToPointer)
#pragma alloc_text(PAGE, ExMapHandleToPointerEx)
#pragma alloc_text(PAGE, ExpAllocateHandleTable)
#pragma alloc_text(PAGE, ExpFreeHandleTable)
#pragma alloc_text(PAGE, ExpAllocateHandleTableEntry)
#pragma alloc_text(PAGE, ExpAllocateHandleTableEntrySlow)
#pragma alloc_text(PAGE, ExpFreeHandleTableEntry)
#pragma alloc_text(PAGE, ExpLookupHandleTableEntry)
#pragma alloc_text(PAGE, ExSweepHandleTable)
#pragma alloc_text(PAGE, ExpAllocateMidLevelTable)
#pragma alloc_text(PAGE, ExpAllocateTablePagedPool)
#pragma alloc_text(PAGE, ExpAllocateTablePagedPoolNoZero)
#pragma alloc_text(PAGE, ExpFreeTablePagedPool)
#pragma alloc_text(PAGE, ExpAllocateLowLevelTable)
#pragma alloc_text(PAGE, ExSetHandleInfo)
#pragma alloc_text(PAGE, ExpGetHandleInfo)
#pragma alloc_text(PAGE, ExSnapShotHandleTablesEx)
#pragma alloc_text(PAGE, ExpFreeLowLevelTable)
#pragma alloc_text(PAGE, ExpBlockOnLockedHandleEntry)
#pragma alloc_text(PAGE, ExpMoveFreeHandles)
#pragma alloc_text(PAGE, ExEnableHandleTracing)
#pragma alloc_text(PAGE, ExDereferenceHandleDebugInfo)
#pragma alloc_text(PAGE, ExReferenceHandleDebugInfo)
#pragma alloc_text(PAGE, ExpUpdateDebugInfo)
#endif

//
// Define macros to lock and unlock the handle table.
// We use this lock only for handle table expansion.
//
#define ExpLockHandleTableExclusive(xxHandleTable,xxCurrentThread) { \
    KeEnterCriticalRegionThread (xxCurrentThread);                   \
    ExAcquirePushLockExclusive (&xxHandleTable->HandleTableLock[0]); \
}


#define ExpUnlockHandleTableExclusive(xxHandleTable,xxCurrentThread) { \
    ExReleasePushLockExclusive (&xxHandleTable->HandleTableLock[0]);   \
    KeLeaveCriticalRegionThread (xxCurrentThread);                     \
}
    
#define ExpLockHandleTableShared(xxHandleTable,xxCurrentThread,xxIdx) { \
    KeEnterCriticalRegionThread (xxCurrentThread);                      \
    ExAcquirePushLockShared (&xxHandleTable->HandleTableLock[xxIdx]);   \
}


#define ExpUnlockHandleTableShared(xxHandleTable,xxCurrentThread,xxIdx) { \
    ExReleasePushLockShared (&xxHandleTable->HandleTableLock[xxIdx]);     \
    KeLeaveCriticalRegionThread (xxCurrentThread);                        \
}



FORCEINLINE
ULONG
ExpInterlockedExchange (
    IN OUT PULONG Index,
    IN ULONG FirstIndex,
    IN PHANDLE_TABLE_ENTRY Entry
    )
/*++

Routine Description:

    This performs the following steps:
    1. Set Entry->NextFreeTableEntry = *Index
    2. Loops until *Index == (the value of *Index when we entered the function)
       When they're equal, we set *Index = FirstIndex


Arguments:

    Index - Points to the ULONG we want to set.
    
    FirstIndex - New value to set Index to.

    Entry - TableEntry that will get the initial value of *Index before it's
            updated.

Return Value:

    New value of *Index (i.e. FirstIndex).

--*/
{
    ULONG OldIndex, NewIndex;

    EXASSERT (Entry->Object == NULL);

    //
    // Load new value and generate the sequence number on pushes
    //

    NewIndex = FirstIndex + GetNextSeq();

    while (1) {

        //
        // remember original value and
        // archive it in NextFreeTableEntry.
        //

        OldIndex = *Index;
        Entry->NextFreeTableEntry = OldIndex;

        
        //
        // Swap in the new value, and if the swap occurs
        // successfully, we're done.
        //
        if (OldIndex == (ULONG) InterlockedCompareExchange ((PLONG)Index,
                                                            NewIndex,
                                                            OldIndex)) {
            return OldIndex;
        }
    }
}

ULONG
ExpMoveFreeHandles (
    IN PHANDLE_TABLE HandleTable
    )
{
    ULONG OldValue, NewValue;
    ULONG Index, OldIndex, NewIndex, FreeSize;
    PHANDLE_TABLE_ENTRY Entry, FirstEntry;
    EXHANDLE Handle;
    ULONG Idx;
    BOOLEAN StrictFIFO;

    //
    // First remove all the handles from the free list so we can add them to the
    // list we use for allocates.
    //

    OldValue = InterlockedExchange ((PLONG)&HandleTable->LastFree,
                                    0);
    Index = OldValue;
    if (Index == 0) {
        //
        // There are no free handles.  Nothing to do.
        //
        return OldValue;
    }

       
    //
    // We are pushing old entries onto the free list.
    // We have the A-B-A problem here as these items may have been moved here because
    // another thread was using them in the pop code.
    //
    for (Idx = 1; Idx < HANDLE_TABLE_LOCKS; Idx++) {
        ExAcquireReleasePushLockExclusive (&HandleTable->HandleTableLock[Idx]);
    }
    StrictFIFO = HandleTable->StrictFIFO;
 
    //
    // If we are strict FIFO then reverse the list to make handle reuse rare.
    //
    if (!StrictFIFO) {
        //
        // We have a complete chain here. If there is no existing chain we
        // can just push this one without any hassles. If we can't then
        // we can just fall into the reversing code anyway as we need
        // to find the end of the chain to continue it.
        //

        //
        // This is a push so create a new sequence number
        //

        if (InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                        OldValue + GetNextSeq(),
                                        0) == 0) {
            return OldValue;
        }
    }

    //
    // Loop over all the entries and reverse the chain.
    //
    FreeSize = OldIndex = 0;
    FirstEntry = NULL;
    while (1) {
        FreeSize++;
        Handle.Value = Index;
        Entry = ExpLookupHandleTableEntry (HandleTable, Handle);

        EXASSERT (Entry->Object == NULL);

        NewIndex = Entry->NextFreeTableEntry;
        Entry->NextFreeTableEntry = OldIndex;
        if (OldIndex == 0) {
            FirstEntry = Entry;
        }
        OldIndex = Index;
        if (NewIndex == 0) {
            break;
        }
        Index = NewIndex;
    }

    NewValue = ExpInterlockedExchange (&HandleTable->FirstFree,
                                       OldIndex,
                                       FirstEntry);

    //
    // If we haven't got a pool of a few handles then force
    // table expansion to keep the free handle size high
    //
    if (FreeSize < 100 && StrictFIFO) {
        OldValue = 0;
    }
    return OldValue;
}

PHANDLE_TABLE_ENTRY
ExpAllocateHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    OUT PEXHANDLE pHandle
    )
/*++

Routine Description:

    This routine does a fast allocate of a free handle. It's lock free if
    possible.

    Only the rare case of handle table expansion is covered by the handle
    table lock.

Arguments:

    HandleTable - Supplies the handle table being allocated from.

    pHandle - Handle returned

Return Value:

    PHANDLE_TABLE_ENTRY - The allocated handle table entry pointer or NULL
                          on failure.

--*/
{
    PKTHREAD CurrentThread;
    ULONG OldValue, NewValue, NewValue1;
    PHANDLE_TABLE_ENTRY Entry;
    EXHANDLE Handle;
    BOOLEAN RetVal;
    ULONG Idx;


    CurrentThread = KeGetCurrentThread ();
    while (1) {

        OldValue = HandleTable->FirstFree;


        while (OldValue == 0) {
            //
            //  Lock the handle table for exclusive access as we will be
            //  allocating a new table level.
            //
            ExpLockHandleTableExclusive (HandleTable, CurrentThread);

            //
            // If we have multiple threads trying to expand the table at
            // the same time then by just acquiring the table lock we
            // force those threads to complete their allocations and
            // populate the free list. We must check the free list here
            // so we don't expand the list twice without needing to.
            //

            OldValue = HandleTable->FirstFree;
            if (OldValue != 0) {
                ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);
                break;
            }

            //
            // See if we have any handles on the alternate free list
            // These handles need some locking to move them over.
            //
            OldValue = ExpMoveFreeHandles (HandleTable);
            if (OldValue != 0) {
                ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);
                break;
            }

            //
            // This must be the first thread attempting expansion or all the
            // free handles allocated by another thread got used up in the gap.
            //

            RetVal = ExpAllocateHandleTableEntrySlow (HandleTable, TRUE);

            ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);


            OldValue = HandleTable->FirstFree;

            //
            // If ExpAllocateHandleTableEntrySlow had a failed allocation
            // then we want to fail the call.  We check for free entries
            // before we exit just in case they got allocated or freed by
            // somebody else in the gap.
            //

            if (!RetVal) {
                if (OldValue == 0) {
                    pHandle->GenericHandleOverlay = NULL;
                    return NULL;
                }            
            }
        }


        Handle.Value = (OldValue & FREE_HANDLE_MASK);

        Entry = ExpLookupHandleTableEntry (HandleTable, Handle);

        Idx = ((OldValue & FREE_HANDLE_MASK)>>2) % HANDLE_TABLE_LOCKS;
        ExpLockHandleTableShared (HandleTable, CurrentThread, Idx);

        if (OldValue != *(volatile ULONG *) &HandleTable->FirstFree) {
            ExpUnlockHandleTableShared (HandleTable, CurrentThread, Idx);
            continue;
        }

        KeMemoryBarrier ();

        NewValue = *(volatile ULONG *) &Entry->NextFreeTableEntry;

        NewValue1 = InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                                NewValue,
                                                OldValue);

        ExpUnlockHandleTableShared (HandleTable, CurrentThread, Idx);

        if (NewValue1 == OldValue) {
            EXASSERT ((NewValue & FREE_HANDLE_MASK) < HandleTable->NextHandleNeedingPool);
            break;
        } else {
            //
            // We should have eliminated the A-B-A problem so if only the sequence number has
            // changed we are broken.
            //
            EXASSERT ((NewValue1 & FREE_HANDLE_MASK) != (OldValue & FREE_HANDLE_MASK));
        }
    }
    InterlockedIncrement (&HandleTable->HandleCount);

    *pHandle = Handle;
    
    return Entry;
}


VOID
ExpBlockOnLockedHandleEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    )
{
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;
    LONG_PTR CurrentValue;

    //
    // Queue our wait block to be signaled by a releasing thread.
    //

    ExBlockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);

    CurrentValue = HandleTableEntry->Value;
    if (CurrentValue == 0 || (CurrentValue&EXHANDLE_TABLE_ENTRY_LOCK_BIT) != 0) {
        ExUnblockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);
    } else {
        ExWaitForUnblockPushLock (&HandleTable->HandleContentionEvent, &WaitBlock);
   }
}


BOOLEAN
FORCEINLINE
ExpLockHandleTableEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This routine locks the specified handle table entry.  After the entry is
    locked the sign bit will be set.

Arguments:

    HandleTable - Supplies the handle table containing the entry being locked.

    HandleTableEntry - Supplies the handle table entry being locked.

Return Value:

    TRUE if the entry is valid and locked, and FALSE if the entry is
    marked free.

--*/

{
    LONG_PTR NewValue;
    LONG_PTR CurrentValue;

    //
    // We are about to take a lock. Make sure we are protected.
    //
    ASSERT ((KeGetCurrentThread()->CombinedApcDisable != 0) || (KeGetCurrentIrql() == APC_LEVEL));

    //
    //  We'll keep on looping reading in the value, making sure it is not null,
    //  and if it is not currently locked we'll try for the lock and return
    //  true if we get it.  Otherwise we'll pause a bit and then try again.
    //


    while (TRUE) {

        CurrentValue = *((volatile LONG_PTR *)&HandleTableEntry->Object);

        //
        //  If the handle value is greater than zero then it is not currently
        //  locked and we should try for the lock, by setting the lock bit and
        //  doing an interlocked exchange.
        //

        if (CurrentValue & EXHANDLE_TABLE_ENTRY_LOCK_BIT) {

            //
            // Remove the
            //
            NewValue = CurrentValue - EXHANDLE_TABLE_ENTRY_LOCK_BIT;

            if ((LONG_PTR)(InterlockedCompareExchangePointer (&HandleTableEntry->Object,
                                                              (PVOID)NewValue,
                                                              (PVOID)CurrentValue)) == CurrentValue) {

                return TRUE;
            }
        } else {
            //
            //  Make sure the handle table entry is not freed
            //

            if (CurrentValue == 0) {

                return FALSE;
            }
        }
        ExpBlockOnLockedHandleEntry (HandleTable, HandleTableEntry);
    }
}


NTKERNELAPI
VOID
FORCEINLINE
ExUnlockHandleTableEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This routine unlocks the specified handle table entry.  After the entry is
    unlocked the sign bit will be clear.

Arguments:

    HandleTable - Supplies the handle table containing the entry being unlocked.

    HandleTableEntry - Supplies the handle table entry being unlocked.

Return Value:

    None.

--*/

{
    LONG_PTR OldValue;

    PAGED_CODE();

    //
    // We are about to release a lock. Make sure we are protected from suspension.
    //
    ASSERT ((KeGetCurrentThread()->CombinedApcDisable != 0) || (KeGetCurrentIrql() == APC_LEVEL));

    //
    //  This routine does not need to loop and attempt the unlock opeation more
    //  than once because by definition the caller has the entry already locked
    //  and no one can be changing the value without the lock.
    //


#if defined (_WIN64)

    OldValue = InterlockedExchangeAdd64 ((PLONGLONG) &HandleTableEntry->Value, EXHANDLE_TABLE_ENTRY_LOCK_BIT);


#else

    OldValue = InterlockedOr ((LONG *) &HandleTableEntry->Value, EXHANDLE_TABLE_ENTRY_LOCK_BIT);


#endif

    EXASSERT ((OldValue&EXHANDLE_TABLE_ENTRY_LOCK_BIT) == 0);

    //
    // Unblock any waiters waiting for this table entry.
    //
    ExUnblockPushLock (&HandleTable->HandleContentionEvent, NULL);

    return;
}


NTKERNELAPI
VOID
ExInitializeHandleTablePackage (
    VOID
    )

/*++

Routine Description:

    This routine is called once at system initialization to setup the ex handle
    table package

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    //  Initialize the handle table synchronization resource and list head
    //

    InitializeListHead( &HandleTableListHead );
    ExInitializePushLock( &HandleTableListLock );

    return;
}


NTKERNELAPI
PHANDLE_TABLE
ExCreateHandleTable (
    IN struct _EPROCESS *Process OPTIONAL
    )

/*++

Routine Description:

    This function allocate and initialize a new new handle table

Arguments:

    Process - Supplies an optional pointer to the process against which quota
        will be charged.

Return Value:

    If a handle table is successfully created, then the address of the
    handle table is returned as the function value. Otherwize, a value
    NULL is returned.

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE HandleTable;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  Allocate and initialize a handle table descriptor
    //

    HandleTable = ExpAllocateHandleTable( Process, TRUE );

    if (HandleTable == NULL) {
        return NULL;
    }
    //
    //  Insert the handle table in the handle table list.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockExclusive( &HandleTableListLock );

    InsertTailList( &HandleTableListHead, &HandleTable->HandleTableList );

    ExReleasePushLockExclusive( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);


    //
    //  And return to our caller
    //

    return HandleTable;
}


NTKERNELAPI
VOID
ExRemoveHandleTable (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This function removes the specified exhandle table from the list of
    exhandle tables.  Used by PS and ATOM packages to make sure their handle
    tables are not in the list enumerated by the ExSnapShotHandleTables
    routine and the !handle debugger extension.

Arguments:

    HandleTable - Supplies a pointer to a handle table

Return Value:

    None.

--*/

{
    PKTHREAD CurrentThread;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  First, acquire the global handle table lock
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockExclusive( &HandleTableListLock );

    //
    //  Remove the handle table from the handle table list.  This routine is
    //  written so that multiple calls to remove a handle table will not
    //  corrupt the system.
    //

    RemoveEntryList( &HandleTable->HandleTableList );
    InitializeListHead( &HandleTable->HandleTableList );

    //
    //  Now release the global lock and return to our caller
    //

    ExReleasePushLockExclusive( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return;
}


NTKERNELAPI
VOID
ExDestroyHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_DESTROY_HANDLE_ROUTINE DestroyHandleProcedure OPTIONAL
    )

/*++

Routine Description:

    This function destroys the specified handle table.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    DestroyHandleProcedure - Supplies a pointer to a function to call for each
        valid handle entry in the handle table.

Return Value:

    None.

--*/

{
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    //
    //  Remove the handle table from the handle table list
    //

    ExRemoveHandleTable( HandleTable );

    //
    //  Iterate through the handle table and for each handle that is allocated
    //  we'll invoke the call back.  Note that this loop exits when we get a
    //  null handle table entry.  We know there will be no more possible
    //  entries after the first null one is encountered because we allocate
    //  memory of the handles in a dense fashion.  But first test that we have
    //  call back to use
    //

    if (ARGUMENT_PRESENT(DestroyHandleProcedure)) {

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                (*DestroyHandleProcedure)( Handle.GenericHandleOverlay );
            }
        }
    }

    //
    //  Now free up the handle table memory and return to our caller
    //

    ExpFreeHandleTable( HandleTable );

    return;
}


NTKERNELAPI
VOID
ExSweepHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
    IN PVOID EnumParameter
    )

/*++

Routine Description:

    This function sweeps a handle table in a unsynchronized manner.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    EnumHandleProcedure - Supplies a pointer to a fucntion to call for
        each valid handle in the enumerated handle table.

    EnumParameter - Supplies an uninterpreted 32-bit value that is passed
        to the EnumHandleProcedure each time it is called.

Return Value:

    None.

--*/

{
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    //
    //  Iterate through the handle table and for each handle that is allocated
    //  we'll invoke the call back.  Note that this loop exits when we get a
    //  null handle table entry.  We know there will be no more possible
    //  entries after the first null one is encountered because we allocate
    //  memory of the handles in a dense fashion.
    //
    Handle.Value = HANDLE_VALUE_INC;

    while ((HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL) {

        do {

            //
            //  Only do the callback if the entry is not free
            //
            //

            if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                (*EnumHandleProcedure)( HandleTableEntry,
                                        Handle.GenericHandleOverlay,
                                        EnumParameter );
            }
            Handle.Value += HANDLE_VALUE_INC;
            HandleTableEntry++;
        } while ((Handle.Value % (LOWLEVEL_COUNT * HANDLE_VALUE_INC)) != 0);
        // Skip past the first entry that's not a real entry
        Handle.Value += HANDLE_VALUE_INC;
    }

    return;
}



NTKERNELAPI
BOOLEAN
ExEnumHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
    IN PVOID EnumParameter,
    OUT PHANDLE Handle OPTIONAL
    )

/*++

Routine Description:

    This function enumerates all the valid handles in a handle table.
    For each valid handle in the handle table, the specified eumeration
    function is called. If the enumeration function returns TRUE, then
    the enumeration is stopped, the current handle is returned to the
    caller via the optional Handle parameter, and this function returns
    TRUE to indicated that the enumeration stopped at a specific handle.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    EnumHandleProcedure - Supplies a pointer to a fucntion to call for
        each valid handle in the enumerated handle table.

    EnumParameter - Supplies an uninterpreted 32-bit value that is passed
        to the EnumHandleProcedure each time it is called.

    Handle - Supplies an optional pointer a variable that receives the
        Handle value that the enumeration stopped at. Contents of the
        variable only valid if this function returns TRUE.

Return Value:

    If the enumeration stopped at a specific handle, then a value of TRUE
    is returned. Otherwise, a value of FALSE is returned.

--*/

{
    PKTHREAD CurrentThread;
    BOOLEAN ResultValue;
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  Our initial return value is false until the enumeration callback
    //  function tells us otherwise
    //

    ResultValue = FALSE;

    //
    //  Iterate through the handle table and for each handle that is
    //  allocated we'll invoke the call back.  Note that this loop exits
    //  when we get a null handle table entry.  We know there will be no
    //  more possible entries after the first null one is encountered
    //  because we allocate memory for the handles in a dense fashion
    //

    KeEnterCriticalRegionThread (CurrentThread);

    for (LocalHandle.Value = 0; // does essentially the following "LocalHandle.Index = 0, LocalHandle.TagBits = 0;"
         (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, LocalHandle )) != NULL;
         LocalHandle.Value += HANDLE_VALUE_INC) {

        //
        //  Only do the callback if the entry is not free
        //

        if ( ExpIsValidObjectEntry( HandleTableEntry ) ) {

            //
            //  Lock the handle table entry because we're about to give
            //  it to the callback function, then release the entry
            //  right after the call back.
            //

            if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                //
                //  Invoke the callback, and if it returns true then set
                //  the proper output values and break out of the loop.
                //

                ResultValue = (*EnumHandleProcedure)( HandleTableEntry,
                                                      LocalHandle.GenericHandleOverlay,
                                                      EnumParameter );

                ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );

                if (ResultValue) {
                    if (ARGUMENT_PRESENT( Handle )) {

                        *Handle = LocalHandle.GenericHandleOverlay;
                    }
                    break;
                }
            }
        }
    }
    KeLeaveCriticalRegionThread (CurrentThread);


    return ResultValue;
}


NTKERNELAPI
PHANDLE_TABLE
ExDupHandleTable (
    IN struct _EPROCESS *Process OPTIONAL,
    IN PHANDLE_TABLE OldHandleTable,
    IN EX_DUPLICATE_HANDLE_ROUTINE DupHandleProcedure,
    IN ULONG_PTR Mask
    )

/*++

Routine Description:

    This function creates a duplicate copy of the specified handle table.

Arguments:

    Process - Supplies an optional to the process to charge quota to.

    OldHandleTable - Supplies a pointer to a handle table.

    DupHandleProcedure - Supplies an optional pointer to a function to call
        for each valid handle in the duplicated handle table.

    Mask - Mask applied to the object pointer to work outif we need to duplicate

Return Value:

    If the specified handle table is successfully duplicated, then the
    address of the new handle table is returned as the function value.
    Otherwize, a value NULL is returned.

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE NewHandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY OldHandleTableEntry;
    PHANDLE_TABLE_ENTRY NewHandleTableEntry;
    BOOLEAN FreeEntry;
    NTSTATUS Status;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    //
    //  First allocate a new handle table.  If this fails then
    //  return immediately to our caller
    //

    NewHandleTable = ExpAllocateHandleTable( Process, FALSE );

    if (NewHandleTable == NULL) {

        return NULL;
    }


    //
    //  Now we'll build up the new handle table. We do this by calling
    //  allocating new handle table entries, and "fooling" the worker
    //  routine to allocate keep on allocating until the next free
    //  index needing pool are equal
    //
    while (NewHandleTable->NextHandleNeedingPool < OldHandleTable->NextHandleNeedingPool) {

        //
        //  Call the worker routine to grow the new handle table.  If
        //  not successful then free the new table as far as we got,
        //  set our output variable and exit out here
        //
        if (!ExpAllocateHandleTableEntrySlow (NewHandleTable, FALSE)) {

            ExpFreeHandleTable (NewHandleTable);
            return NULL;
        }
    }

    //
    // Make sure any table reads occur after the value we fetched from NextHandleNeedingPool
    //

    KeMemoryBarrier ();

    //
    //  Now modify the new handle table to think it has zero handles
    //  and set its free list to start on the same index as the old
    //  free list
    //

    NewHandleTable->HandleCount = 0;
    NewHandleTable->ExtraInfoPages = 0;
    NewHandleTable->FirstFree = 0;

    //
    //  Now for every valid index value we'll copy over the old entry into
    //  the new entry
    //


    Handle.Value = HANDLE_VALUE_INC;

    KeEnterCriticalRegionThread (CurrentThread);
    while ((NewHandleTableEntry = ExpLookupHandleTableEntry( NewHandleTable, Handle )) != NULL) {

        //
        // Lookup the old entry.
        //

        OldHandleTableEntry = ExpLookupHandleTableEntry( OldHandleTable, Handle );

        do {

            //
            //  If the old entry is free then simply copy over the entire
            //  old entry to the new entry.  The lock command will tell us
            //  if the entry is free.
            //
            if ((OldHandleTableEntry->Value&Mask) == 0 ||
                !ExpLockHandleTableEntry( OldHandleTable, OldHandleTableEntry )) {
                FreeEntry = TRUE;
            } else {

                PHANDLE_TABLE_ENTRY_INFO EntryInfo;
                
                //
                //  Otherwise we have a non empty entry.  So now copy it
                //  over, and unlock the old entry.  In both cases we bump
                //  the handle count because either the entry is going into
                //  the new table or we're going to remove it with Exp Free
                //  Handle Table Entry which will decrement the handle count
                //

                *NewHandleTableEntry = *OldHandleTableEntry;

                //
                //  Copy the entry info data, if any
                //

                Status = STATUS_SUCCESS;
                EntryInfo = ExGetHandleInfo(OldHandleTable, Handle.GenericHandleOverlay, TRUE);

                if (EntryInfo) {

                    Status = ExSetHandleInfo(NewHandleTable, Handle.GenericHandleOverlay, EntryInfo, TRUE);
                }


                //
                //  Invoke the callback and if it returns true then we
                //  unlock the new entry
                //

                if (NT_SUCCESS (Status)) {
                    if  ((*DupHandleProcedure) (Process,
                                                OldHandleTable,
                                                OldHandleTableEntry,
                                                NewHandleTableEntry)) {

                        if (NewHandleTable->DebugInfo != NULL) {
                            ExpUpdateDebugInfo(
                                NewHandleTable,
                                PsGetCurrentThread (),
                                Handle.GenericHandleOverlay,
                                HANDLE_TRACE_DB_OPEN);
                        }
                        //
                        // Since there is no route to the new table yet we can just
                        // clear the lock bit
                        //
                        NewHandleTableEntry->Value |= EXHANDLE_TABLE_ENTRY_LOCK_BIT;
                        NewHandleTable->HandleCount += 1;
                        FreeEntry = FALSE;
                    } else {
                        if (EntryInfo) {
                            EntryInfo->AuditMask = 0;
                        }

                        FreeEntry = TRUE;
                    }
                } else {
                    //
                    // Duplicate routine doesn't want this handle duplicated so free it
                    //
                    ExUnlockHandleTableEntry( OldHandleTable, OldHandleTableEntry );
                    FreeEntry = TRUE;
                }

            }
            if (FreeEntry) {
                NewHandleTableEntry->Object = NULL;
                NewHandleTableEntry->NextFreeTableEntry =
                    NewHandleTable->FirstFree;
                NewHandleTable->FirstFree = (ULONG) Handle.Value;
            }
            Handle.Value += HANDLE_VALUE_INC;
            NewHandleTableEntry++;
            OldHandleTableEntry++;

        } while ((Handle.Value % (LOWLEVEL_COUNT * HANDLE_VALUE_INC)) != 0);

        Handle.Value += HANDLE_VALUE_INC; // Skip past the first entry thats not a real entry
    }

    //
    //  Insert the handle table in the handle table list.
    //

    ExAcquirePushLockExclusive( &HandleTableListLock );

    InsertTailList( &HandleTableListHead, &NewHandleTable->HandleTableList );

    ExReleasePushLockExclusive( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    //
    //  lastly return the new handle table to our caller
    //

    return NewHandleTable;
}


NTKERNELAPI
NTSTATUS
ExSnapShotHandleTables (
    IN PEX_SNAPSHOT_HANDLE_ENTRY SnapShotHandleEntry,
    IN OUT PSYSTEM_HANDLE_INFORMATION HandleInformation,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    )

/*++

Routine Description:

    This function visits and invokes the specified callback for every valid
    handle that it can find off of the handle table.

Arguments:

    SnapShotHandleEntry - Supplies a pointer to a function to call for
        each valid handle we encounter.

    HandleInformation - Supplies a handle information structure to
        be filled in for each handle table we encounter.  This routine
        fills in the handle count, but relies on a callback to fill in
        entry info fields.

    Length - Supplies a parameter for the callback.  In reality this is
        the total size, in bytes, of the Handle Information buffer.

    RequiredLength - Supplies a parameter for the callback.  In reality
        this is a final size in bytes used to store the requested
        information.

Return Value:

    The last return status of the callback

--*/

{
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO HandleEntryInfo;
    PLIST_ENTRY NextEntry;
    PHANDLE_TABLE HandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();


    Status = STATUS_SUCCESS;

    //
    //  Setup the output buffer pointer that the callback will maintain
    //

    HandleEntryInfo = &HandleInformation->Handles[0];

    //
    //  Zero out the handle count
    //

    HandleInformation->NumberOfHandles = 0;

    //
    //  Lock the handle table list exclusive and traverse the list of handle
    //  tables.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockShared( &HandleTableListLock );

    //
    //  Iterate through all the handle tables in the system.
    //

    for (NextEntry = HandleTableListHead.Flink;
         NextEntry != &HandleTableListHead;
         NextEntry = NextEntry->Flink) {

        //
        //  Get the address of the next handle table, lock the handle
        //  table exclusive, and scan the list of handle entries.
        //

        HandleTable = CONTAINING_RECORD( NextEntry,
                                         HANDLE_TABLE,
                                         HandleTableList );


        //  Iterate through the handle table and for each handle that
        //  is allocated we'll invoke the call back.  Note that this
        //  loop exits when we get a null handle table entry.  We know
        //  there will be no more possible entries after the first null
        //  one is encountered because we allocate memory of the
        //  handles in a dense fashion
        //

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                //
                //  Increment the handle count information in the
                //  information buffer
                //

                HandleInformation->NumberOfHandles += 1;

                //
                //  Lock the handle table entry because we're about to
                //  give it to the callback function, then release the
                //  entry right after the call back.
                //

                if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                    Status = (*SnapShotHandleEntry)( &HandleEntryInfo,
                                                     HandleTable->UniqueProcessId,
                                                     HandleTableEntry,
                                                     Handle.GenericHandleOverlay,
                                                     Length,
                                                     RequiredLength );

                    ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );
                }
            }
        }
    }

    ExReleasePushLockShared( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return Status;
}


NTKERNELAPI
NTSTATUS
ExSnapShotHandleTablesEx (
    IN PEX_SNAPSHOT_HANDLE_ENTRY_EX SnapShotHandleEntry,
    IN OUT PSYSTEM_HANDLE_INFORMATION_EX HandleInformation,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    )

/*++

Routine Description:

    This function visits and invokes the specified callback for every valid
    handle that it can find off of the handle table.

Arguments:

    SnapShotHandleEntry - Supplies a pointer to a function to call for
        each valid handle we encounter.

    HandleInformation - Supplies a handle information structure to
        be filled in for each handle table we encounter.  This routine
        fills in the handle count, but relies on a callback to fill in
        entry info fields.

    Length - Supplies a parameter for the callback.  In reality this is
        the total size, in bytes, of the Handle Information buffer.

    RequiredLength - Supplies a parameter for the callback.  In reality
        this is a final size in bytes used to store the requested
        information.

Return Value:

    The last return status of the callback

--*/

{
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX HandleEntryInfo;
    PLIST_ENTRY NextEntry;
    PHANDLE_TABLE HandleTable;
    EXHANDLE Handle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    CurrentThread = KeGetCurrentThread ();

    Status = STATUS_SUCCESS;


    //
    //  Setup the output buffer pointer that the callback will maintain
    //

    HandleEntryInfo = &HandleInformation->Handles[0];

    //
    //  Zero out the handle count
    //

    HandleInformation->NumberOfHandles = 0;

    //
    //  Lock the handle table list exclusive and traverse the list of handle
    //  tables.
    //

    KeEnterCriticalRegionThread (CurrentThread);
    ExAcquirePushLockShared( &HandleTableListLock );

    //
    //  Iterate through all the handle tables in the system.
    //

    for (NextEntry = HandleTableListHead.Flink;
         NextEntry != &HandleTableListHead;
         NextEntry = NextEntry->Flink) {

        //
        //  Get the address of the next handle table, lock the handle
        //  table exclusive, and scan the list of handle entries.
        //

        HandleTable = CONTAINING_RECORD( NextEntry,
                                         HANDLE_TABLE,
                                         HandleTableList );


        //  Iterate through the handle table and for each handle that
        //  is allocated we'll invoke the call back.  Note that this
        //  loop exits when we get a null handle table entry.  We know
        //  there will be no more possible entries after the first null
        //  one is encountered because we allocate memory of the
        //  handles in a dense fashion
        //

        for (Handle.Value = 0;
             (HandleTableEntry = ExpLookupHandleTableEntry( HandleTable, Handle )) != NULL;
             Handle.Value += HANDLE_VALUE_INC) {

            //
            //  Only do the callback if the entry is not free
            //

            if ( ExpIsValidObjectEntry(HandleTableEntry) ) {

                //
                //  Increment the handle count information in the
                //  information buffer
                //

                HandleInformation->NumberOfHandles += 1;

                //
                //  Lock the handle table entry because we're about to
                //  give it to the callback function, then release the
                //  entry right after the call back.
                //

                if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

                    Status = (*SnapShotHandleEntry)( &HandleEntryInfo,
                                                     HandleTable->UniqueProcessId,
                                                     HandleTableEntry,
                                                     Handle.GenericHandleOverlay,
                                                     Length,
                                                     RequiredLength );

                    ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );
                }
            }
        }
    }

    ExReleasePushLockShared( &HandleTableListLock );
    KeLeaveCriticalRegionThread (CurrentThread);

    return Status;
}


NTKERNELAPI
HANDLE
ExCreateHandle (
    IN PHANDLE_TABLE HandleTable,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This function creates a handle entry in the specified handle table and
    returns a handle for the entry.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    HandleEntry - Supplies a poiner to the handle entry for which a
        handle entry is created.

Return Value:

    If the handle entry is successfully created, then value of the created
    handle is returned as the function value.  Otherwise, a value of zero is
    returned.

--*/

{
    EXHANDLE Handle;
    PETHREAD CurrentThread;
    PHANDLE_TABLE_ENTRY NewHandleTableEntry;

    PAGED_CODE();

    //
    //  Set out output variable to zero (i.e., null) before going on
    //

    //
    // Clears Handle.Index and Handle.TagBits
    //

    Handle.GenericHandleOverlay = NULL;


    //
    //  Allocate a new handle table entry, and get the handle value
    //

    NewHandleTableEntry = ExpAllocateHandleTableEntry( HandleTable,
                                                       &Handle );

    //
    //  If we really got a handle then copy over the template and unlock
    //  the entry
    //

    if (NewHandleTableEntry != NULL) {

        CurrentThread = PsGetCurrentThread ();

        //
        // We are about to create a locked entry so protect against suspension
        //
        KeEnterCriticalRegionThread (&CurrentThread->Tcb);

        *NewHandleTableEntry = *HandleTableEntry;

        //
        // If we are debugging handle operations then save away the details
        //
        if (HandleTable->DebugInfo != NULL) {
            ExpUpdateDebugInfo(HandleTable, CurrentThread, Handle.GenericHandleOverlay, HANDLE_TRACE_DB_OPEN);
        }

        ExUnlockHandleTableEntry( HandleTable, NewHandleTableEntry );

        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    return Handle.GenericHandleOverlay;
}


NTKERNELAPI
BOOLEAN
ExDestroyHandle (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry OPTIONAL
    )

/*++

Routine Description:

    This function removes a handle from a handle table.

Arguments:

    HandleTable - Supplies a pointer to a handle table

    Handle - Supplies the handle value of the entry to remove.

    HandleTableEntry - Optionally supplies a pointer to the handle
        table entry being destroyed.  If supplied the entry is
        assume to be locked.

Return Value:

    If the specified handle is successfully removed, then a value of
    TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{
    EXHANDLE LocalHandle;
    PETHREAD CurrentThread;
    PVOID Object;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    CurrentThread = PsGetCurrentThread ();

    //
    //  If the caller did not supply the optional handle table entry then
    //  locate the entry via the supplied handle, make sure it is real, and
    //  then lock the entry.
    //

    KeEnterCriticalRegionThread (&CurrentThread->Tcb);

    if (HandleTableEntry == NULL) {

        HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                      LocalHandle );

        if (!ExpIsValidObjectEntry(HandleTableEntry)) {

            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            return FALSE;
        }


        if (!ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {

            KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
            return FALSE;
        }
    } else {
        EXASSERT ((HandleTableEntry->Value&EXHANDLE_TABLE_ENTRY_LOCK_BIT) == 0);
    }


    //
    // If we are debugging handle operations then save away the details
    //

    if (HandleTable->DebugInfo != NULL) {
        ExpUpdateDebugInfo(HandleTable, CurrentThread, Handle, HANDLE_TRACE_DB_CLOSE);
    }

    //
    //  At this point we have a locked handle table entry.  Now mark it free
    //  which does the implicit unlock.  The system will not allocate it
    //  again until we add it to the free list which we will do right after
    //  we take out the lock
    //

    Object = InterlockedExchangePointer (&HandleTableEntry->Object, NULL);

    EXASSERT (Object != NULL);
    EXASSERT ((((ULONG_PTR)Object)&EXHANDLE_TABLE_ENTRY_LOCK_BIT) == 0);

    //
    // Unblock any waiters waiting for this table entry.
    //
    ExUnblockPushLock (&HandleTable->HandleContentionEvent, NULL);


    ExpFreeHandleTableEntry( HandleTable,
                             LocalHandle,
                             HandleTableEntry );

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    return TRUE;
}


NTKERNELAPI
BOOLEAN
ExChangeHandle (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PEX_CHANGE_HANDLE_ROUTINE ChangeRoutine,
    IN ULONG_PTR Parameter
    )

/*++

Routine Description:

    This function provides the capability to change the contents of the
    handle entry corrsponding to the specified handle.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle for the handle entry that is changed.

    ChangeRoutine - Supplies a pointer to a function that is called to
        perform the change.

    Parameter - Supplies an uninterpreted parameter that is passed to
        the change routine.

Return Value:

    If the operation was successfully performed, then a value of TRUE
    is returned. Otherwise, a value of FALSE is returned.

--*/

{
    EXHANDLE LocalHandle;
    PKTHREAD CurrentThread;

    PHANDLE_TABLE_ENTRY HandleTableEntry;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    CurrentThread = KeGetCurrentThread ();

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //

    HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                  LocalHandle );

    if ((HandleTableEntry == NULL) ||
        !ExpIsValidObjectEntry(HandleTableEntry)) {

        return FALSE;
    }



    //
    //  Try and lock the handle table entry,  If this fails then that's
    //  because someone freed the handle
    //

    //
    //  Make sure we can't get suspended and then invoke the callback
    //

    KeEnterCriticalRegionThread (CurrentThread);

    if (ExpLockHandleTableEntry( HandleTable, HandleTableEntry )) {


        ReturnValue = (*ChangeRoutine)( HandleTableEntry, Parameter );
        
        ExUnlockHandleTableEntry( HandleTable, HandleTableEntry );

    } else {
        ReturnValue = FALSE;
    }

    KeLeaveCriticalRegionThread (CurrentThread);

    return ReturnValue;
}


NTKERNELAPI
PHANDLE_TABLE_ENTRY
ExMapHandleToPointer (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle
    )

/*++

Routine Description:

    This function maps a handle to a pointer to a handle table entry. If the
    map operation is successful then the handle table entry is locked when
    we return.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle to be mapped to a handle entry.

Return Value:

    If the handle was successfully mapped to a pointer to a handle entry,
    then the address of the handle table entry is returned as the function
    value with the entry locked. Otherwise, a value of NULL is returned.

--*/

{
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    if ((LocalHandle.Index & (LOWLEVEL_COUNT - 1)) == 0) {
        return NULL;
    }

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //

    HandleTableEntry = ExpLookupHandleTableEntry( HandleTable,
                                                  LocalHandle );

    if ((HandleTableEntry == NULL) ||
        !ExpLockHandleTableEntry( HandleTable, HandleTableEntry)) {
        //
        // If we are debugging handle operations then save away the details
        //

        if (HandleTable->DebugInfo != NULL) {
            ExpUpdateDebugInfo(HandleTable, PsGetCurrentThread (), Handle, HANDLE_TRACE_DB_BADREF);
        }
        return NULL;
    }


    //
    //  Return the locked valid handle table entry
    //

    return HandleTableEntry;
}

NTKERNELAPI
PHANDLE_TABLE_ENTRY
ExMapHandleToPointerEx (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This function maps a handle to a pointer to a handle table entry. If the
    map operation is successful then the handle table entry is locked when
    we return.

Arguments:

    HandleTable - Supplies a pointer to a handle table.

    Handle - Supplies the handle to be mapped to a handle entry.

    PreviousMode - Previous mode of caller

Return Value:

    If the handle was successfully mapped to a pointer to a handle entry,
    then the address of the handle table entry is returned as the function
    value with the entry locked. Otherwise, a value of NULL is returned.

--*/

{
    EXHANDLE LocalHandle;
    PHANDLE_TABLE_ENTRY HandleTableEntry = NULL;
    PETHREAD CurrentThread;

    PAGED_CODE();

    LocalHandle.GenericHandleOverlay = Handle;

    //
    //  Translate the input handle to a handle table entry and make
    //  sure it is a valid handle.
    //    

    if (((LocalHandle.Index & (LOWLEVEL_COUNT - 1)) == 0) ||
        ((HandleTableEntry = ExpLookupHandleTableEntry(HandleTable, LocalHandle)) == NULL) ||
        !ExpLockHandleTableEntry( HandleTable, HandleTableEntry)) {

        //
        // If we are debugging handle operations then save away the details
        //

        if (HandleTable->DebugInfo != NULL) {
            CurrentThread = PsGetCurrentThread ();
            ExpUpdateDebugInfo(HandleTable, CurrentThread, Handle, HANDLE_TRACE_DB_BADREF);

            //
            // Since we have a non-null DebugInfo for the handle table of this
            // process it means application verifier was enabled for this process.
            //

            if (PreviousMode == UserMode) {

                if (!KeIsAttachedProcess()) {

                    //
                    // If the current process is marked for verification
                    // then we will raise an exception in user mode. In case
                    // application verifier is enabled system wide we will 
                    // break first.
                    //
                                                 
                    if ((NtGlobalFlag & FLG_APPLICATION_VERIFIER)) {
                        
                        DbgPrint ("AVRF: Invalid handle %p in process %p \n", 
                                  Handle,
                                  PsGetCurrentProcess());

//                        DbgBreakPoint ();
                    }

                    KeRaiseUserException (STATUS_INVALID_HANDLE);
                }
            } else {

                //
                // We bugcheck for kernel handles only if we have the handle
                // exceptions flag set system-wide. This way a user enabling
                // application verifier for a process will not get bugchecks
                // only user mode errors.
                //

                if ((NtGlobalFlag & FLG_ENABLE_HANDLE_EXCEPTIONS)) {

                    KeBugCheckEx(INVALID_KERNEL_HANDLE,
                                 (ULONG_PTR)Handle,
                                 (ULONG_PTR)HandleTable,
                                 (ULONG_PTR)HandleTableEntry,
                                 0x1);
                }
            }
        }
        
        return NULL;
    }


    //
    //  Return the locked valid handle table entry
    //

    return HandleTableEntry;
}

//
//  Local Support Routine
//

PVOID
ExpAllocateTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    )
{
    PVOID PoolMemory;

    PoolMemory = ExAllocatePoolWithTag( PagedPool,
                                        NumberOfBytes,
                                        'btbO' );
    if (PoolMemory != NULL) {

        RtlZeroMemory( PoolMemory,
                       NumberOfBytes );

        if (ARGUMENT_PRESENT(QuotaProcess)) {

            if (!NT_SUCCESS (PsChargeProcessPagedPoolQuota ( QuotaProcess,
                                                             NumberOfBytes ))) {
                ExFreePool( PoolMemory );
                PoolMemory = NULL;
            }

        }
    }

    return PoolMemory;
}

PVOID
ExpAllocateTablePagedPoolNoZero (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN SIZE_T NumberOfBytes
    )
{
    PVOID PoolMemory;

    PoolMemory = ExAllocatePoolWithTag( PagedPool,
                                        NumberOfBytes,
                                        'btbO' );
    if (PoolMemory != NULL) {

        if (ARGUMENT_PRESENT(QuotaProcess)) {

            if (!NT_SUCCESS (PsChargeProcessPagedPoolQuota ( QuotaProcess,
                                                             NumberOfBytes ))) {
                ExFreePool( PoolMemory );
                PoolMemory = NULL;
            }

        }
    }

    return PoolMemory;
}


//
//  Local Support Routine
//

VOID
ExpFreeTablePagedPool (
    IN PEPROCESS QuotaProcess OPTIONAL,
    IN PVOID PoolMemory,
    IN SIZE_T NumberOfBytes
    )
{

    ExFreePool( PoolMemory );

    if ( QuotaProcess ) {

        PsReturnProcessPagedPoolQuota( QuotaProcess,
                                       NumberOfBytes
                                     );
    }
}



PHANDLE_TRACE_DEBUG_INFO
ExReferenceHandleDebugInfo (
    IN PHANDLE_TABLE HandleTable
    )
{
    LONG RetVal;
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PKTHREAD CurrentThread;

    CurrentThread = KeGetCurrentThread ();

    ExpLockHandleTableShared (HandleTable, CurrentThread, 0);

    DebugInfo = HandleTable->DebugInfo;

    if (DebugInfo != NULL) {
        RetVal = InterlockedIncrement (&DebugInfo->RefCount);
        ASSERT (RetVal > 0);
    }

    ExpUnlockHandleTableShared (HandleTable, CurrentThread, 0);

    return DebugInfo;
}


VOID
ExDereferenceHandleDebugInfo (
    IN PHANDLE_TABLE HandleTable,
    IN PHANDLE_TRACE_DEBUG_INFO DebugInfo
    )
{
    ULONG TraceSize;
    ULONG TableSize;
    LONG RetVal;

    RetVal = InterlockedDecrement (&DebugInfo->RefCount);

    ASSERT (RetVal >= 0);

    if (RetVal == 0) {

        TableSize = DebugInfo->TableSize;
        TraceSize = sizeof (*DebugInfo) + TableSize * sizeof (DebugInfo->TraceDb[0]) - sizeof (DebugInfo->TraceDb);

        ExFreePool (DebugInfo);

        if (HandleTable->QuotaProcess != NULL) {
            PsReturnProcessNonPagedPoolQuota (HandleTable->QuotaProcess,
                                              TraceSize);
        }

        InterlockedExchangeAdd ((PLONG) &TotalTraceBuffers, -(LONG)TableSize);
    }
}

NTKERNELAPI
NTSTATUS
ExDisableHandleTracing (
    IN PHANDLE_TABLE HandleTable
    )
/*++

Routine Description:

    This routine turns off handle tracing for the specified table

Arguments:

    HandleTable - Table to disable tracing in


Return Value:

    NTSTATUS - Status of operation

--*/
{
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;
    PKTHREAD CurrentThread;

    CurrentThread = KeGetCurrentThread ();

    ExpLockHandleTableExclusive (HandleTable, CurrentThread);

    DebugInfo = HandleTable->DebugInfo;

    HandleTable->DebugInfo = NULL;

    ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);

    if (DebugInfo != NULL) {
        ExDereferenceHandleDebugInfo (HandleTable, DebugInfo);
    }

    return STATUS_SUCCESS;
}


NTKERNELAPI
NTSTATUS
ExEnableHandleTracing (
    IN PHANDLE_TABLE HandleTable,
    IN ULONG Slots
    )
/*++

Routine Description:

    This routine turns on handle tracing for the specified table

Arguments:

    HandleTable - Table to enable tracing in


Return Value:

    NTSTATUS - Status of operation

--*/

{
    PHANDLE_TRACE_DEBUG_INFO DebugInfo, OldDebugInfo;
    PEPROCESS Process;
    PKTHREAD CurrentThread;
    NTSTATUS Status;
    SIZE_T TotalNow;
    extern SIZE_T MmMaximumNonPagedPoolInBytes;
    SIZE_T TraceSize;
    LONG TotalSlots;

    if (Slots == 0) {
        TotalSlots = HANDLE_TRACE_DB_DEFAULT_STACKS;
    } else {
        if (Slots < HANDLE_TRACE_DB_MIN_STACKS) {
            TotalSlots = HANDLE_TRACE_DB_MIN_STACKS;
        } else {
            TotalSlots = Slots;
        }

        if (TotalSlots > HANDLE_TRACE_DB_MAX_STACKS) {
            TotalSlots = HANDLE_TRACE_DB_MAX_STACKS;
        }

        //
        // Round the value up to the next power of 2
        //

        while ((TotalSlots & (TotalSlots - 1)) != 0) {
            TotalSlots |= (TotalSlots - 1);
            TotalSlots += 1;
        }
    }

    //
    // Total slots needs to be a power of two
    //
    ASSERT ((TotalSlots & (TotalSlots - 1)) == 0);
    ASSERT (TotalSlots > 0 && TotalSlots <= HANDLE_TRACE_DB_MAX_STACKS);

    TraceSize = sizeof (*DebugInfo) + TotalSlots * sizeof (DebugInfo->TraceDb[0]) - sizeof (DebugInfo->TraceDb);

    TotalNow = InterlockedExchangeAdd ((PLONG) &TotalTraceBuffers, TotalSlots);

    //
    // See if we used more than 30% of nonpaged pool.
    //
    if ((SIZE_T)TotalNow * sizeof (DebugInfo->TraceDb[0]) > (MmMaximumNonPagedPoolInBytes * 30 / 100)) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto return_and_exit;
    }

    Process = HandleTable->QuotaProcess;

    if (Process) {
        Status = PsChargeProcessNonPagedPoolQuota (Process,
                                                   TraceSize);
        if (!NT_SUCCESS (Status)) {
            goto return_and_exit;
        }
    }

    //
    // Allocate the handle debug database
    //
    DebugInfo = ExAllocatePoolWithTag (NonPagedPool,
                                       TraceSize,
                                       'dtbO');
    if (DebugInfo == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto quota_return_and_exit;
    }
    RtlZeroMemory (DebugInfo, TraceSize);

    DebugInfo->RefCount = 1;
    DebugInfo->TableSize = TotalSlots;

    ExInitializeFastMutex(&DebugInfo->CloseCompactionLock);

    //
    // Since we are tracing then we should enforce strict FIFO
    // Only do this for tables with processes so we leave atom tables alone.
    //
    if (Process != NULL) {
        HandleTable->StrictFIFO = TRUE;
    }

    //
    // Put the new table in place releasing any existing table
    //

    CurrentThread = KeGetCurrentThread ();

    ExpLockHandleTableExclusive (HandleTable, CurrentThread);

    OldDebugInfo = HandleTable->DebugInfo;

    HandleTable->DebugInfo = DebugInfo;

    ExpUnlockHandleTableExclusive (HandleTable, CurrentThread);

    if (OldDebugInfo != NULL) {
        ExDereferenceHandleDebugInfo (HandleTable, OldDebugInfo);
    }

    return STATUS_SUCCESS;

quota_return_and_exit:

    if (Process) {
        PsReturnProcessNonPagedPoolQuota (Process,
                                          TraceSize);
    }


return_and_exit:

    InterlockedExchangeAdd ((PLONG) &TotalTraceBuffers, -TotalSlots);
    return Status;
}


//
//  Local Support Routine
//

PHANDLE_TABLE
ExpAllocateHandleTable (
    IN PEPROCESS Process OPTIONAL,
    IN BOOLEAN DoInit
    )

/*++

Routine Description:

    This worker routine will allocate and initialize a new handle table
    structure.  The new structure consists of the basic handle table
    struct plus the first allocation needed to store handles.  This is
    really one page divided up into the top level node, the first mid
    level node, and one bottom level node.

Arguments:

    Process - Optionally supplies the process to charge quota for the
        handle table

    DoInit - If FALSE then we are being called by duplicate and we don't need
             the free list built for the caller

Return Value:

    A pointer to the new handle table or NULL if unsuccessful at getting
    pool.

--*/

{
    PHANDLE_TABLE HandleTable;
    PHANDLE_TABLE_ENTRY HandleTableTable, HandleEntry;
    ULONG i, Idx;

    PAGED_CODE();

    //
    //  If any alloation or quota failures happen we will catch it in the
    //  following try-except clause and cleanup after outselves before
    //  we return null
    //

    //
    //  First allocate the handle table, make sure we got one, charge quota
    //  for it and then zero it out
    //

    HandleTable = (PHANDLE_TABLE)ExAllocatePoolWithTag (PagedPool,
                                                        sizeof(HANDLE_TABLE),
                                                        'btbO');
    if (HandleTable == NULL) {
        return NULL;
    }

    if (ARGUMENT_PRESENT(Process)) {

        if (!NT_SUCCESS (PsChargeProcessPagedPoolQuota( Process,
                                                        sizeof(HANDLE_TABLE)))) {
            ExFreePool( HandleTable );
            return NULL;
        }
    }


    RtlZeroMemory( HandleTable, sizeof(HANDLE_TABLE) );


    //
    //  Now allocate space of the top level, one mid level and one bottom
    //  level table structure.  This will all fit on a page, maybe two.
    //

    HandleTableTable = ExpAllocateTablePagedPoolNoZero ( Process,
                                                         TABLE_PAGE_SIZE
                                                        );

    if ( HandleTableTable == NULL ) {

        ExFreePool( HandleTable );

        if (ARGUMENT_PRESENT(Process)) {

            PsReturnProcessPagedPoolQuota (Process,
                                           sizeof(HANDLE_TABLE));
        }
            
        return NULL;
    }
        
    HandleTable->TableCode = (ULONG_PTR)HandleTableTable;


    //
    //  We stamp with EX_ADDITIONAL_INFO_SIGNATURE to recognize in the future this
    //  is a special information entry
    //

    HandleEntry = &HandleTableTable[0];

    HandleEntry->NextFreeTableEntry = EX_ADDITIONAL_INFO_SIGNATURE;
    HandleEntry->Value = 0;

    //
    // For duplicate calls we skip building the free list as we rebuild it manually as
    // we traverse the old table we are duplicating
    //
    if (DoInit) {
        HandleEntry++;
        //
        //  Now setup the free list.  We do this by chaining together the free
        //  entries such that each free entry give the next free index (i.e.,
        //  like a fat chain).  The chain is terminated with a 0.  Note that
        //  we'll skip handle zero because our callers will get that value
        //  confused with null.
        //


        for (i = 1; i < LOWLEVEL_COUNT - 1; i += 1) {

            HandleEntry->Value = 0;
            HandleEntry->NextFreeTableEntry = (i+1)*HANDLE_VALUE_INC;
            HandleEntry++;
        }
        HandleEntry->Value = 0;
        HandleEntry->NextFreeTableEntry = 0;

        HandleTable->FirstFree = HANDLE_VALUE_INC;

    }
    

    HandleTable->NextHandleNeedingPool = LOWLEVEL_COUNT * HANDLE_VALUE_INC;

    //
    //  Setup the necessary process information
    //

    HandleTable->QuotaProcess = Process;
    HandleTable->UniqueProcessId = PsGetCurrentProcess()->UniqueProcessId;
    HandleTable->Flags = 0;

#if DBG && !EXHANDLE_EXTRA_CHECKS
    if (Process != NULL) {
        HandleTable->StrictFIFO = TRUE;
    }
#endif

    //
    //  Initialize the handle table lock. This is only used by table expansion.
    //

    for (Idx = 0; Idx < HANDLE_TABLE_LOCKS; Idx++) {
        ExInitializePushLock (&HandleTable->HandleTableLock[Idx]);
    }

    //
    //  Initialize the blocker for handle entry lock contention.
    //

    ExInitializePushLock (&HandleTable->HandleContentionEvent);

    if (ExTraceAllTables) {
        ExEnableHandleTracing (HandleTable, 0);    
    }
    //
    //  And return to our caller
    //

    return HandleTable;
}


//
//  Local Support Routine
//

VOID
ExpFreeLowLevelTable (
    IN PEPROCESS QuotaProcess,
    IN PHANDLE_TABLE_ENTRY TableLevel1
    )

/*++

Routine Description:

    This worker routine frees a low-level handle table
    and the additional info memory, if any.

Arguments:

    HandleTable - Supplies the handle table being freed

Return Value:

    None.

--*/

{
    //
    //  Check whether we have a pool allocated for the additional info
    //

    if (TableLevel1[0].Object) {

        ExpFreeTablePagedPool( QuotaProcess,
                               TableLevel1[0].Object,
                               LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO)
                             );
    }

    //
    //  Now free the low level table and return the quota for the process
    //

    ExpFreeTablePagedPool( QuotaProcess,
                           TableLevel1,
                           TABLE_PAGE_SIZE
                         );
    
    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

VOID
ExpFreeHandleTable (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This worker routine tears down and frees the specified handle table.

Arguments:

    HandleTable - Supplies the handle table being freed

Return Value:

    None.

--*/

{
    PEPROCESS Process;
    ULONG i,j;
    ULONG_PTR CapturedTable = HandleTable->TableCode;
    ULONG TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);

    PAGED_CODE();

    //
    //  Unmask the level bits
    //

    CapturedTable = CapturedTable & ~LEVEL_CODE_MASK;
    Process = HandleTable->QuotaProcess;

    //
    //  We need to free all pages. We have 3 cases, depending on the number
    //  of levels
    //


    if (TableLevel == 0) {

        //
        //  There is a single level handle table. We'll simply free the buffer
        //

        PHANDLE_TABLE_ENTRY TableLevel1 = (PHANDLE_TABLE_ENTRY)CapturedTable;
        
        ExpFreeLowLevelTable( Process, TableLevel1 );

    } else if (TableLevel == 1) {

        //
        //  We have 2 levels in the handle table
        //
        
        PHANDLE_TABLE_ENTRY *TableLevel2 = (PHANDLE_TABLE_ENTRY *)CapturedTable;

        for (i = 0; i < MIDLEVEL_COUNT; i++) {

            //
            //  loop through the pointers to the low-level tables, and free each one
            //

            if (TableLevel2[i] == NULL) {

                break;
            }
            
            ExpFreeLowLevelTable( Process, TableLevel2[i] );
        }
        
        //
        //  Free the top level table
        //

        ExpFreeTablePagedPool( Process,
                               TableLevel2,
                               PAGE_SIZE
                             );

    } else {

        //
        //  Here we handle the case where we have a 3 level handle table
        //

        PHANDLE_TABLE_ENTRY **TableLevel3 = (PHANDLE_TABLE_ENTRY **)CapturedTable;

        //
        //  Iterates through the high-level pointers to mid-table
        //

        for (i = 0; i < HIGHLEVEL_COUNT; i++) {

            if (TableLevel3[i] == NULL) {

                break;
            }
            
            //
            //  Iterate through the mid-level table
            //  and free every low-level page
            //

            for (j = 0; j < MIDLEVEL_COUNT; j++) {

                if (TableLevel3[i][j] == NULL) {

                    break;
                }
                
                ExpFreeLowLevelTable( Process, TableLevel3[i][j] );
            }

            ExpFreeTablePagedPool( Process,
                                   TableLevel3[i],
                                   PAGE_SIZE
                                 );
        }
        
        //
        //  Free the top-level array
        //

        ExpFreeTablePagedPool( Process,
                               TableLevel3,
                               HIGHLEVEL_SIZE
                             );
    }

    //
    // Free any debug info if we have any.
    //

    if (HandleTable->DebugInfo != NULL) {
        ExDereferenceHandleDebugInfo (HandleTable, HandleTable->DebugInfo);
    }

    //
    //  Finally deallocate the handle table itself
    //

    ExFreePool( HandleTable );

    if (Process != NULL) {

        PsReturnProcessPagedPoolQuota (Process,
                                       sizeof(HANDLE_TABLE));
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

PHANDLE_TABLE_ENTRY
ExpAllocateLowLevelTable (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit
    )

/*++

Routine Description:

    This worker routine allocates a new low level table
    
    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

    DoInit - If FALSE the caller (duplicate) doesn't need the free list maintained

Return Value:

    Returns - a pointer to a low-level table if allocation is
        successful otherwise the return value is null.

--*/

{
    ULONG k;
    PHANDLE_TABLE_ENTRY NewLowLevel = NULL, HandleEntry;
    ULONG BaseHandle;
    
    //
    //  Allocate the pool for lower level
    //

    NewLowLevel = ExpAllocateTablePagedPoolNoZero( HandleTable->QuotaProcess,
                                                   TABLE_PAGE_SIZE
                                                 );

    if (NewLowLevel == NULL) {

        return NULL;
    }

    //
    //  We stamp with EX_ADDITIONAL_INFO_SIGNATURE to recognize in the future this
    //  is a special information entry
    //

    HandleEntry = &NewLowLevel[0];

    HandleEntry->NextFreeTableEntry = EX_ADDITIONAL_INFO_SIGNATURE;
    HandleEntry->Value = 0;

    //
    // Initialize the free list within this page if the caller wants this
    //
    if (DoInit) {

        HandleEntry++;

        //
        //  Now add the new entries to the free list.  To do this we
        //  chain the new free entries together.  We are guaranteed to
        //  have at least one new buffer.  The second buffer we need
        //  to check for.
        //
        //  We reserve the first entry in the table to the structure with
        //  additional info
        //
        //
        //  Do the guaranteed first buffer
        //

        BaseHandle = HandleTable->NextHandleNeedingPool + 2 * HANDLE_VALUE_INC;
        for (k = BaseHandle; k < BaseHandle + (LOWLEVEL_COUNT - 2) * HANDLE_VALUE_INC; k += HANDLE_VALUE_INC) {

            HandleEntry->NextFreeTableEntry = k;
            HandleEntry->Value = 0;
            HandleEntry++;
        }
        HandleEntry->NextFreeTableEntry = 0;
        HandleEntry->Value = 0;
    }


    return NewLowLevel;    
}

PHANDLE_TABLE_ENTRY *
ExpAllocateMidLevelTable (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit,
    OUT PHANDLE_TABLE_ENTRY *pNewLowLevel
    )

/*++

Routine Description:

    This worker routine allocates a mid-level table. This is an array with
    pointers to low-level tables.
    It will allocate also a low-level table and will save it in the first index
    
    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

    DoInit - If FALSE the caller (duplicate) does not want the free list build

    pNewLowLevel - Returns the new low level taible for later free list chaining

Return Value:

    Returns a pointer to the new mid-level table allocated
    
--*/

{
    PHANDLE_TABLE_ENTRY *NewMidLevel;
    PHANDLE_TABLE_ENTRY NewLowLevel;
    
    NewMidLevel = ExpAllocateTablePagedPool( HandleTable->QuotaProcess,
                                             PAGE_SIZE
                                           );

    if (NewMidLevel == NULL) {

        return NULL;
    }

    //
    //  If we need a new mid-level, we'll need a low-level too.
    //  We'll create one and if success we'll save it at the first position
    //

    NewLowLevel = ExpAllocateLowLevelTable( HandleTable, DoInit );

    if (NewLowLevel == NULL) {

        ExpFreeTablePagedPool( HandleTable->QuotaProcess,
                               NewMidLevel,
                               PAGE_SIZE
                             );

        return NULL;
    }
    
    //
    //  Set the low-level table at the first index
    //

    NewMidLevel[0] = NewLowLevel;
    *pNewLowLevel = NewLowLevel;

    return NewMidLevel;
}



BOOLEAN
ExpAllocateHandleTableEntrySlow (
    IN PHANDLE_TABLE HandleTable,
    IN BOOLEAN DoInit
    )

/*++

Routine Description:

    This worker routine allocates a new handle table entry for the specified
    handle table.

    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the handle table being used

    DoInit - If FALSE then the caller (duplicate) doesn't need the free list built

Return Value:

    BOOLEAN - TRUE, Retry the fast allocation path, FALSE, We failed to allocate memory

--*/

{
    ULONG i,j;

    PHANDLE_TABLE_ENTRY NewLowLevel;
    PHANDLE_TABLE_ENTRY *NewMidLevel;
    PHANDLE_TABLE_ENTRY **NewHighLevel;
    ULONG NewFree, OldFree;
    ULONG OldIndex;
    PVOID OldValue;
    
    ULONG_PTR CapturedTable = HandleTable->TableCode;
    ULONG TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);
    
    PAGED_CODE();

    //
    // Initializing NewLowLevel is not needed for
    // correctness but without it the compiler cannot compile this code
    // W4 to check for use of uninitialized variables.
    //

    NewLowLevel = NULL;

    CapturedTable = CapturedTable & ~LEVEL_CODE_MASK;


    if ( TableLevel == 0 ) {

        //
        //  We have a single level. We need to ad a mid-layer
        //  to the process handle table
        //

        NewMidLevel = ExpAllocateMidLevelTable( HandleTable, DoInit, &NewLowLevel );

        if (NewMidLevel == NULL) {
            return FALSE;
        }

        //
        //  Since ExpAllocateMidLevelTable initialize the 
        //  first position with a new table, we need to move it in 
        //  the second position, and store in the first position the current one
        //

        NewMidLevel[1] = NewMidLevel[0];
        NewMidLevel[0] = (PHANDLE_TABLE_ENTRY)CapturedTable;
            
        //
        //  Encode the current level and set it to the handle table process
        //

        CapturedTable = ((ULONG_PTR)NewMidLevel) | 1;
            
        OldValue = InterlockedExchangePointer( (PVOID *)&HandleTable->TableCode, (PVOID)CapturedTable );


    } else if (TableLevel == 1) {

        //
        //  We have a 2 levels handle table
        //

        PHANDLE_TABLE_ENTRY *TableLevel2 = (PHANDLE_TABLE_ENTRY *)CapturedTable;

        //
        //  Test whether the index we need to create is still in the 
        //  range for a 2 layers table
        //

        i = HandleTable->NextHandleNeedingPool / (LOWLEVEL_COUNT * HANDLE_VALUE_INC);

        if (i < MIDLEVEL_COUNT) {

            //
            //  We just need to allocate a new low-level
            //  table
            //
                
            NewLowLevel = ExpAllocateLowLevelTable( HandleTable, DoInit );

            if (NewLowLevel == NULL) {
                return FALSE;
            }

            //
            //  Set the new one to the table, at appropriate position
            //

            OldValue = InterlockedExchangePointer( (PVOID *) (&TableLevel2[i]), NewLowLevel );
            EXASSERT (OldValue == NULL);

        } else {

            //
            //  We exhausted the 2 level domain. We need to insert a new one
            //

            NewHighLevel = ExpAllocateTablePagedPool( HandleTable->QuotaProcess,
                                                      HIGHLEVEL_SIZE
                                                    );

            if (NewHighLevel == NULL) {

                return FALSE;
            }
                
            NewMidLevel = ExpAllocateMidLevelTable( HandleTable, DoInit, &NewLowLevel );

            if (NewMidLevel == NULL) {
                    
                ExpFreeTablePagedPool( HandleTable->QuotaProcess,
                                       NewHighLevel,
                                       HIGHLEVEL_SIZE
                                     );

                return FALSE;
            }

            //
            //  Initialize the first index with the previous mid-level layer
            //

            NewHighLevel[0] = (PHANDLE_TABLE_ENTRY*)CapturedTable;
            NewHighLevel[1] = NewMidLevel;

            //
            //  Encode the level into the table pointer
            //

            CapturedTable = ((ULONG_PTR)NewHighLevel) | 2;

            //
            //  Change the handle table pointer with this one
            //

            OldValue = InterlockedExchangePointer( (PVOID *)&HandleTable->TableCode, (PVOID)CapturedTable );

        }

    } else if (TableLevel == 2) {

        //
        //  we have already a table with 3 levels
        //

        ULONG RemainingIndex;
        PHANDLE_TABLE_ENTRY **TableLevel3 = (PHANDLE_TABLE_ENTRY **)CapturedTable;

        i = HandleTable->NextHandleNeedingPool / (MIDLEVEL_THRESHOLD * HANDLE_VALUE_INC);

        //
        //  Check whether we exhausted all possible indexes.
        //

        if (i >= HIGHLEVEL_COUNT) {

            return FALSE;
        }

        if (TableLevel3[i] == NULL) {

            //
            //  The new available handle points to a free mid-level entry
            //  We need then to allocate a new one and save it in that position
            //

            NewMidLevel = ExpAllocateMidLevelTable( HandleTable, DoInit, &NewLowLevel );
                
            if (NewMidLevel == NULL) {
                    
                return FALSE;
            }             

            OldValue = InterlockedExchangePointer( (PVOID *) &(TableLevel3[i]), NewMidLevel );
            EXASSERT (OldValue == NULL);

        } else {

            //
            //  We have already a mid-level table. We just need to add a new low-level one
            //  at the end
            //
                
            RemainingIndex = (HandleTable->NextHandleNeedingPool / HANDLE_VALUE_INC) -
                              i * MIDLEVEL_THRESHOLD;
            j = RemainingIndex / LOWLEVEL_COUNT;

            NewLowLevel = ExpAllocateLowLevelTable( HandleTable, DoInit );

            if (NewLowLevel == NULL) {

                return FALSE;
            }

            OldValue = InterlockedExchangePointer( (PVOID *)(&TableLevel3[i][j]) , NewLowLevel );
            EXASSERT (OldValue == NULL);
        }
    }

    //
    // This must be done after the table pointers so that new created handles
    // are valid before being freed.
    //
    OldIndex = InterlockedExchangeAdd ((PLONG) &HandleTable->NextHandleNeedingPool,
                                       LOWLEVEL_COUNT * HANDLE_VALUE_INC);


    if (DoInit) {
        //
        // Generate a new sequence number since this is a push
        //
        OldIndex += HANDLE_VALUE_INC + GetNextSeq();

        //
        // Now free the handles. These are all ready to be accepted by the lookup logic now.
        //
        while (1) {
            OldFree = HandleTable->FirstFree;
            NewLowLevel[LOWLEVEL_COUNT - 1].NextFreeTableEntry = OldFree;

            //
            // These are new entries that have never existed before. We can't have an A-B-A problem
            // with these so we don't need to take any locks
            //


            NewFree = InterlockedCompareExchange ((PLONG)&HandleTable->FirstFree,
                                                  OldIndex,
                                                  OldFree);
            if (NewFree == OldFree) {
                break;
            }
        }
    }
    return TRUE;
}


VOID
ExSetHandleTableStrictFIFO (
    IN PHANDLE_TABLE HandleTable
    )

/*++

Routine Description:

    This routine marks a handle table so that handle allocation is done in
    a strict FIFO order.


Arguments:

    HandleTable - Supplies the handle table being changed to FIFO

Return Value:

    None.

--*/

{
    HandleTable->StrictFIFO = TRUE;
}


//
//  Local Support Routine
//

//
//  The following is a global variable only present in the checked builds
//  to help catch apps that reuse handle values after they're closed.
//

#if DBG
BOOLEAN ExReuseHandles = 1;
#endif //DBG

VOID
ExpFreeHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    )

/*++

Routine Description:

    This worker routine returns the specified handle table entry to the free
    list for the handle table.

    Note: The caller must have already locked the handle table

Arguments:

    HandleTable - Supplies the parent handle table being modified

    Handle - Supplies the handle of the entry being freed

    HandleTableEntry - Supplies the table entry being freed

Return Value:

    None.

--*/

{
    PHANDLE_TABLE_ENTRY_INFO EntryInfo;
    ULONG OldFree, NewFree, *Free;
    PKTHREAD CurrentThread;
    ULONG Idx;
    ULONG SeqInc;

    PAGED_CODE();

    EXASSERT (HandleTableEntry->Object == NULL);
    EXASSERT (HandleTableEntry == ExpLookupHandleTableEntry (HandleTable, Handle));

    //
    //  Clear the AuditMask flags if these are present into the table
    //

    EntryInfo = ExGetHandleInfo(HandleTable, Handle.GenericHandleOverlay, TRUE);

    if (EntryInfo) {

        EntryInfo->AuditMask = 0;
    }

    //
    //  A free is simply a push onto the free table entry stack, or in the
    //  debug case we'll sometimes just float the entry to catch apps who
    //  reuse a recycled handle value.
    //

    InterlockedDecrement (&HandleTable->HandleCount);
    CurrentThread = KeGetCurrentThread ();

    NewFree = (ULONG) Handle.Value & ~(HANDLE_VALUE_INC - 1);

#if DBG
    if (ExReuseHandles) {
#endif //DBG

        if (!HandleTable->StrictFIFO) {


            //
            // We are pushing potentialy old entries onto the free list.
            // Prevent the A-B-A problem by shifting to an alternate list
            // read this element has the list head out of the loop.
            //
            Idx = (NewFree>>2) % HANDLE_TABLE_LOCKS;
            if (ExTryAcquireReleasePushLockExclusive (&HandleTable->HandleTableLock[Idx])) {
                SeqInc = GetNextSeq();
                Free = &HandleTable->FirstFree;
            } else {
                SeqInc = 0;
                Free = &HandleTable->LastFree;
            }
        } else {
            SeqInc = 0;
            Free = &HandleTable->LastFree;
        }

        while (1) {


            OldFree = *Free;
            HandleTableEntry->NextFreeTableEntry = OldFree;


            if ((ULONG)InterlockedCompareExchange ((PLONG)Free,
                                                   NewFree + SeqInc,
                                                   OldFree) == OldFree) {

                EXASSERT ((OldFree & FREE_HANDLE_MASK) < HandleTable->NextHandleNeedingPool);

                break;
            }
        }

#if DBG
    } else {

        HandleTableEntry->NextFreeTableEntry = 0;
    }
#endif //DBG


    return;
}


//
//  Local Support Routine
//

PHANDLE_TABLE_ENTRY
ExpLookupHandleTableEntry (
    IN PHANDLE_TABLE HandleTable,
    IN EXHANDLE tHandle
    )

/*++

Routine Description:

    This routine looks up and returns the table entry for the
    specified handle value.

Arguments:

    HandleTable - Supplies the handle table being queried

    tHandle - Supplies the handle value being queried

Return Value:

    Returns a pointer to the corresponding table entry for the input
        handle.  Or NULL if the handle value is invalid (i.e., too large
        for the tables current allocation.

--*/

{
    ULONG_PTR i,j,k;
    ULONG_PTR CapturedTable;
    ULONG TableLevel;
    PHANDLE_TABLE_ENTRY Entry = NULL;
    EXHANDLE Handle;

    PUCHAR TableLevel1;
    PUCHAR TableLevel2;
    PUCHAR TableLevel3;

    ULONG_PTR MaxHandle;

    PAGED_CODE();


    //
    // Extract the handle index
    //
    Handle = tHandle;

    Handle.TagBits = 0;

    MaxHandle = *(volatile ULONG *) &HandleTable->NextHandleNeedingPool;

    //
    // See if this can be a valid handle given the table levels.
    //
    if (Handle.Value >= MaxHandle) {
        return NULL;        
    }

    //
    // Now fetch the table address and level bits. We must preserve the
    // ordering here.
    //
    CapturedTable = *(volatile ULONG_PTR *) &HandleTable->TableCode;

    //
    //  we need to capture the current table. This routine is lock free
    //  so another thread may change the table at HandleTable->TableCode
    //

    TableLevel = (ULONG)(CapturedTable & LEVEL_CODE_MASK);
    CapturedTable = CapturedTable - TableLevel;

    //
    //  The lookup code depends on number of levels we have
    //

    switch (TableLevel) {
        
        case 0:
            
            //
            //  We have a simple index into the array, for a single level
            //  handle table
            //


            TableLevel1 = (PUCHAR) CapturedTable;

            //
            // The index for this level is already scaled by a factor of 4. Take advantage of this
            //

            Entry = (PHANDLE_TABLE_ENTRY) &TableLevel1[Handle.Value *
                                                       (sizeof (HANDLE_TABLE_ENTRY) / HANDLE_VALUE_INC)];

            break;
        
        case 1:
            
            //
            //  we have a 2 level handle table. We need to get the upper index
            //  and lower index into the array
            //


            TableLevel2 = (PUCHAR) CapturedTable;

            i = Handle.Value % (LOWLEVEL_COUNT * HANDLE_VALUE_INC);

            Handle.Value -= i;
            j = Handle.Value / ((LOWLEVEL_COUNT * HANDLE_VALUE_INC) / sizeof (PHANDLE_TABLE_ENTRY));

            TableLevel1 =  (PUCHAR) *(PHANDLE_TABLE_ENTRY *) &TableLevel2[j];
            Entry = (PHANDLE_TABLE_ENTRY) &TableLevel1[i * (sizeof (HANDLE_TABLE_ENTRY) / HANDLE_VALUE_INC)];

            break;
        
        case 2:
            
            //
            //  We have here a three level handle table.
            //


            TableLevel3 = (PUCHAR) CapturedTable;

            i = Handle.Value  % (LOWLEVEL_COUNT * HANDLE_VALUE_INC);

            Handle.Value -= i;

            k = Handle.Value / ((LOWLEVEL_COUNT * HANDLE_VALUE_INC) / sizeof (PHANDLE_TABLE_ENTRY));

            j = k % (MIDLEVEL_COUNT * sizeof (PHANDLE_TABLE_ENTRY));

            k -= j;

            k /= MIDLEVEL_COUNT;


            TableLevel2 = (PUCHAR) *(PHANDLE_TABLE_ENTRY *) &TableLevel3[k];
            TableLevel1 = (PUCHAR) *(PHANDLE_TABLE_ENTRY *) &TableLevel2[j];
            Entry = (PHANDLE_TABLE_ENTRY) &TableLevel1[i * (sizeof (HANDLE_TABLE_ENTRY) / HANDLE_VALUE_INC)];

            break;

        default :
            _assume (0);
    }

    return Entry;
}

NTKERNELAPI
NTSTATUS
ExSetHandleInfo (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PHANDLE_TABLE_ENTRY_INFO EntryInfo,
    IN BOOLEAN EntryLocked
    )

/*++

Routine Description:
    
    The routine set the entry info for the specified handle table
    
    Note: the handle entry must be locked when this function is called

Arguments:

    HandleTable - Supplies the handle table being queried

    Handle - Supplies the handle value being queried

Return Value:

--*/

{
    PKTHREAD CurrentThread;
    PHANDLE_TABLE_ENTRY InfoStructure;
    EXHANDLE ExHandle;
    NTSTATUS Status;
    PHANDLE_TABLE_ENTRY TableEntry;
    PHANDLE_TABLE_ENTRY_INFO InfoTable;

    Status = STATUS_UNSUCCESSFUL;
    TableEntry = NULL;
    CurrentThread = NULL;

    ExHandle.GenericHandleOverlay = Handle;
    ExHandle.Index &= ~(LOWLEVEL_COUNT - 1);

    if (!EntryLocked) {
        CurrentThread = KeGetCurrentThread ();
        KeEnterCriticalRegionThread (CurrentThread);
        TableEntry = ExMapHandleToPointer(HandleTable, Handle);

        if (TableEntry == NULL) {
            KeLeaveCriticalRegionThread (CurrentThread);
            
            return STATUS_UNSUCCESSFUL;
        }
    }
    
    //
    //  The info structure is at the first position in each low-level table
    //

    InfoStructure = ExpLookupHandleTableEntry( HandleTable,
                                               ExHandle
                                             );

    if (InfoStructure == NULL || InfoStructure->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE) {

        if ( TableEntry ) {
            ExUnlockHandleTableEntry( HandleTable, TableEntry );
            KeLeaveCriticalRegionThread (CurrentThread);
        }

        return STATUS_UNSUCCESSFUL;
    }

    //
    //  Check whether we need to allocate a new table
    //
    InfoTable = InfoStructure->InfoTable;
    if (InfoTable == NULL) {
        //
        //  Nobody allocated the Infotable so far.
        //  We'll do it right now
        //

        InfoTable = ExpAllocateTablePagedPool (HandleTable->QuotaProcess,
                                               LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO));
            
        if (InfoTable) {

            //
            // Update the number of pages for extra info. If somebody beat us to it then free the
            // new table
            //
            if (InterlockedCompareExchangePointer (&InfoStructure->InfoTable,
                                                   InfoTable,
                                                   NULL) == NULL) {

                InterlockedIncrement(&HandleTable->ExtraInfoPages);

            } else {
                ExpFreeTablePagedPool (HandleTable->QuotaProcess,
                                       InfoTable,
                                       LOWLEVEL_COUNT * sizeof(HANDLE_TABLE_ENTRY_INFO));
                InfoTable = InfoStructure->InfoTable;
            }
        }
    }

    if (InfoTable != NULL) {
        
        //
        //  Calculate the index and copy the structure
        //

        ExHandle.GenericHandleOverlay = Handle;

        InfoTable[ExHandle.Index % LOWLEVEL_COUNT] = *EntryInfo;

        Status = STATUS_SUCCESS;
    }

    if ( TableEntry ) {

        ExUnlockHandleTableEntry( HandleTable, TableEntry );
        KeLeaveCriticalRegionThread (CurrentThread);
    }
    
    return Status;
}

NTKERNELAPI
PHANDLE_TABLE_ENTRY_INFO
ExpGetHandleInfo (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN BOOLEAN EntryLocked
    )

/*++

Routine Description:
    
    The routine reads the entry info for the specified handle table
    
    Note: the handle entry must be locked when this function is called

Arguments:

    HandleTable - Supplies the handle table being queried

    Handle - Supplies the handle value being queried

Return Value:

--*/

{
    PHANDLE_TABLE_ENTRY InfoStructure;
    EXHANDLE ExHandle;
    PHANDLE_TABLE_ENTRY TableEntry = NULL;
    
    ExHandle.GenericHandleOverlay = Handle;
    ExHandle.Index &= ~(LOWLEVEL_COUNT - 1);

    if (!EntryLocked) {

        TableEntry = ExMapHandleToPointer(HandleTable, Handle);

        if (TableEntry == NULL) {
            
            return NULL;
        }
    }
    
    //
    //  The info structure is at the first position in each low-level table
    //

    InfoStructure = ExpLookupHandleTableEntry( HandleTable,
                                               ExHandle 
                                             );

    if (InfoStructure == NULL || InfoStructure->NextFreeTableEntry != EX_ADDITIONAL_INFO_SIGNATURE ||
        InfoStructure->InfoTable == NULL) {

        if ( TableEntry ) {
            
            ExUnlockHandleTableEntry( HandleTable, TableEntry );
        }

        return NULL;
    }


    //
    //  Return a pointer to the info structure
    //

    ExHandle.GenericHandleOverlay = Handle;

    return &(InfoStructure->InfoTable[ExHandle.Index % LOWLEVEL_COUNT]);
}

#if DBG
ULONG g_ulExpUpdateDebugInfoDebugLevel = 0;
#endif
void ExpUpdateDebugInfo(
    PHANDLE_TABLE HandleTable,
    PETHREAD CurrentThread,
    HANDLE Handle,
    ULONG Type) 
{
    BOOLEAN LockAcquired = FALSE;
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;

    DebugInfo = ExReferenceHandleDebugInfo (HandleTable);

    if (DebugInfo == NULL) {
        return;
    }

#if DBG
    if (g_ulExpUpdateDebugInfoDebugLevel > 10)
    {
        DbgPrint ("ExpUpdateDebugInfo() BitMaskFlags=0x%x, CurrentStackIndex=%d, Handle=0x%p, Type=%d \n", 
                  DebugInfo->BitMaskFlags,
                  DebugInfo->CurrentStackIndex,
                  Handle,
                  Type);
    }
#endif
    if (DebugInfo->BitMaskFlags & (HANDLE_TRACE_DEBUG_INFO_CLEAN_DEBUG_INFO | HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE)) {
        //
        // we wish to presenve lock-free behavior in the non-compation path
        // so we lock only in this path
        //
        ExAcquireFastMutex(&DebugInfo->CloseCompactionLock);
        LockAcquired = TRUE;
    }

    if (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_CLEAN_DEBUG_INFO) {
        //
        // clean debug info, but not the fast mutex!
        //

        ASSERT(LockAcquired);

        DebugInfo->BitMaskFlags &= ~HANDLE_TRACE_DEBUG_INFO_CLEAN_DEBUG_INFO;
        DebugInfo->BitMaskFlags &= ~HANDLE_TRACE_DEBUG_INFO_WAS_WRAPPED_AROUND;
        DebugInfo->BitMaskFlags |= HANDLE_TRACE_DEBUG_INFO_WAS_SOMETIME_CLEANED;
        DebugInfo->CurrentStackIndex = 0;
        RtlZeroMemory (DebugInfo->TraceDb,
                       sizeof (*DebugInfo) +
                       DebugInfo->TableSize * sizeof (DebugInfo->TraceDb[0]) -
                       sizeof (DebugInfo->TraceDb));
    }

    if (
        (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE) &&
        (Type == HANDLE_TRACE_DB_CLOSE)
       ){
        //
        // i am asuming that either:
        // 1) this flag was set from the beginning, so there are no close items.
        // 2) this flag was set via KD, in which case HANDLE_TRACE_DEBUG_INFO_CLEAN_DEBUG_INFO
        //    must have been set also, so again there are no close items
        //
        ULONG uiMaxNumOfItemsInTraceDb;
        ULONG uiNextItem;

        ASSERT(LockAcquired);

        //
        // look for the matching open item, remove them from the list, and compact the list
        //
        uiMaxNumOfItemsInTraceDb = (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_WAS_WRAPPED_AROUND) ? DebugInfo->TableSize : DebugInfo->CurrentStackIndex ;
        for (uiNextItem = 1; uiNextItem <= uiMaxNumOfItemsInTraceDb; uiNextItem++) {
            //
            // if HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE is on
            // there could be no HANDLE_TRACE_DB_CLOSE items
            // This ASSERT can fire if the HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE flag
            // is set dynamically, so another thread was not using the locks to add
            // items to the list, and could have added a HANDLE_TRACE_DB_CLOSE item.
            //
            ASSERT(DebugInfo->TraceDb[uiNextItem%DebugInfo->TableSize].Type != HANDLE_TRACE_DB_CLOSE);

            if (
                (DebugInfo->TraceDb[uiNextItem%DebugInfo->TableSize].Type == HANDLE_TRACE_DB_OPEN) &&
                (DebugInfo->TraceDb[uiNextItem%DebugInfo->TableSize].Handle == Handle) 
                ) {
                //
                // found the matching open, compact the list
                //
                ULONG IndexToMoveBack;
                DebugInfo->CurrentStackIndex--;
                IndexToMoveBack = DebugInfo->CurrentStackIndex % DebugInfo->TableSize;
                if (0 != IndexToMoveBack)
                {
                    DebugInfo->TraceDb[uiNextItem%DebugInfo->TableSize] = DebugInfo->TraceDb[IndexToMoveBack];
                }
                else
                {
                    //
                    // the list is already empty
                    //
                }
                break;
            }
        }
        if (!(uiNextItem <= uiMaxNumOfItemsInTraceDb)) {
            //
            // a matching open was not found.
            // this must mean that we wrapped around, or cleaned the list sometime after
            // it was created
            // or that a duplicated handle was created before handle tracking was initiated
            // so we cannot ASSERT for that
            //
            /*
            ASSERT(
                (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_WAS_SOMETIME_CLEANED) ||
                (DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_WAS_WRAPPED_AROUND)
                );
                */
            //
            // just ignore this HANDLE_TRACE_DB_CLOSE
            //
        }
    }
    else
    {
        PHANDLE_TRACE_DB_ENTRY DebugEntry;
        ULONG Index = ((ULONG) InterlockedIncrement ((PLONG)&DebugInfo->CurrentStackIndex))
                   % DebugInfo->TableSize;
        ASSERT((Type != HANDLE_TRACE_DB_CLOSE) || (!(DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_COMPACT_CLOSE_HANDLE)));
        if (0 == Index) {
            //
            // this is a wraparound of the db, mark it as such, and if there's 
            // a debugger attached break into it
            //
            DebugInfo->BitMaskFlags |= HANDLE_TRACE_DEBUG_INFO_WAS_WRAPPED_AROUND;
            if(DebugInfo->BitMaskFlags & HANDLE_TRACE_DEBUG_INFO_BREAK_ON_WRAP_AROUND)
            {
                __try {
                    DbgBreakPoint();
                }
                __except(1) {
                    NOTHING;
                }
            }
        }
        DebugEntry = &DebugInfo->TraceDb[Index];
        DebugEntry->ClientId = CurrentThread->Cid;
        DebugEntry->Handle   = Handle;
        DebugEntry->Type     = Type;
        Index = RtlWalkFrameChain (DebugEntry->StackTrace, HANDLE_TRACE_DB_STACK_SIZE, 0);
        RtlWalkFrameChain (&DebugEntry->StackTrace[Index], HANDLE_TRACE_DB_STACK_SIZE - Index, 1);
    }

    if (LockAcquired)
    {
        ExReleaseFastMutex(&DebugInfo->CloseCompactionLock);
    }

    ExDereferenceHandleDebugInfo (HandleTable, DebugInfo);
}

VOID
ExHandleTest (
    )
{
    PHANDLE_TABLE HandleTable;
    ULONG i, j, k;
#define MAX_ALLOCS 20
    PHANDLE_TABLE_ENTRY HandleEntryArray[MAX_ALLOCS];
    EXHANDLE Handle[MAX_ALLOCS];
    LARGE_INTEGER CurrentTime;

    HandleTable = PsGetCurrentProcess ()->ObjectTable;
    HandleTable->StrictFIFO = 0;

    k = 0;
    for (i = 0; i < 100000; i++) {
        KeQuerySystemTime (&CurrentTime);
        for (j = 0; j < MAX_ALLOCS; j++) {
            //
            // Clears Handle.Index and Handle.TagBits
            //

            Handle[j].GenericHandleOverlay = NULL;


            //
            //  Allocate a new handle table entry, and get the handle value
            //

            HandleEntryArray[j] = ExpAllocateHandleTableEntry (HandleTable,
                                                               &Handle[j]);
            if (HandleEntryArray[j] != NULL) {
                HandleEntryArray[j]->NextFreeTableEntry = 0x88888888;
            }
        }

        for (j = MAX_ALLOCS; j > 0; j--) {
            k = k + CurrentTime.LowPart;
            k = k % j;
            CurrentTime.QuadPart >>= 3;
            if (HandleEntryArray[k] != NULL) {
                //
                // Free the entry
                //
                ExpFreeHandleTableEntry (HandleTable,
                                         Handle[k],
                                         HandleEntryArray[k]);
                HandleEntryArray[k] = HandleEntryArray[j-1];
                HandleEntryArray[j-1] = NULL;
                Handle[k] = Handle[j-1];
                Handle[j-1].GenericHandleOverlay = NULL;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\intrloc2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    intrloc2.c

Abstract:

   This module implements the *portable*  (i.e. SLOW) versions of
   the executive's simple atomic increment/decrement procedures.
   Real implementation should be in assembler.

Author:

    Bryan Willman  (bryanwi)  2-Aug-90

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

INTERLOCKED_RESULT
ExInterlockedIncrementLong (
    IN PLONG Addend,
    IN PKSPIN_LOCK Lock
    )

/*++

Routine Description:

    This function atomically increments Addend, returning an ennumerated
    type which indicates what interesting transitions in the value of
    Addend occurred due the operation.

Arguments:

    Addend - Pointer to variable to increment.

    Lock - Spinlock used to implement atomicity.

Return Value:

    An ennumerated type:

    ResultNegative if Addend is < 0 after increment.
    ResultZero     if Addend is = 0 after increment.
    ResultPositive if Addend is > 0 after increment.

--*/

{
    LONG    OldValue;

    OldValue = (LONG)ExInterlockedAddUlong((PULONG)Addend, 1, Lock);

    if (OldValue < -1)
        return ResultNegative;

    if (OldValue == -1)
        return ResultZero;

    if (OldValue > -1)
        return ResultPositive;
}

INTERLOCKED_RESULT
ExInterlockedDecrementLong (
    IN PLONG Addend,
    IN PKSPIN_LOCK Lock
    )

/*++

Routine Description:

    This function atomically decrements Addend, returning an ennumerated
    type which indicates what interesting transitions in the value of
    Addend occurred due the operation.

Arguments:

    Addend - Pointer to variable to decrement.

    Lock - Spinlock used to implement atomicity.

Return Value:

    An ennumerated type:

    ResultNegative if Addend is < 0 after decrement.
    ResultZero     if Addend is = 0 after decrement.
    ResultPositive if Addend is > 0 after decrement.

--*/

{
    LONG    OldValue;

    OldValue = (LONG)ExInterlockedAddUlong((PULONG)Addend, -1, Lock);

    if (OldValue > 1)
        return ResultPositive;

    if (OldValue == 1)
        return ResultZero;

    if (OldValue < 1)
        return ResultNegative;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\fmutexc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    fmutexc.c

Abstract:

    This module implements the code necessary to acquire and release fast
    mutexes.

Author:

    David N. Cutler (davec) 23-Jun-2000

Environment:

    Any mode.

Revision History:

--*/

#include "exp.h"

#if !defined (_X86_)

#undef ExAcquireFastMutex

VOID
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function acquires ownership of a fast mutex and raises IRQL to
    APC Level.

Arguments:

    FastMutex  - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxAcquireFastMutex(FastMutex);
    return;
}

#undef ExReleaseFastMutex

VOID
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function releases ownership to a fast mutex and lowers IRQL to
    its previous level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxReleaseFastMutex(FastMutex);
    return;
}

#undef ExTryToAcquireFastMutex

BOOLEAN
ExTryToAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function attempts to acquire ownership of a fast mutex, and if
    successful, raises IRQL to APC level.

Arguments:

    FastMutex  - Supplies a pointer to a fast mutex.

Return Value:

    If the fast mutex was successfully acquired, then a value of TRUE
    is returned as the function value. Otherwise, a value of FALSE is
    returned.

--*/

{

    return xxTryToAcquireFastMutex(FastMutex);
}

#undef ExAcquireFastMutexUnsafe

VOID
ExAcquireFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function acquires ownership of a fast mutex, but does not raise
    IRQL to APC Level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxAcquireFastMutexUnsafe(FastMutex);
    return;
}

#undef ExReleaseFastMutexUnsafe

VOID
ExReleaseFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This function releases ownership to a fast mutex, and does not restore
    IRQL to its previous level.

Arguments:

    FastMutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

    xxReleaseFastMutexUnsafe(FastMutex);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\harderr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    harderr.c

Abstract:

    This module implements NT Hard Error APIs

Author:

    Mark Lucovsky (markl) 04-Jul-1991

Revision History:

--*/

#include "exp.h"

NTSTATUS
ExpRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );

VOID
ExpSystemErrorHandler (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN BOOLEAN CallShutdown
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtRaiseHardError)
#pragma alloc_text(PAGE, NtSetDefaultHardErrorPort)
#pragma alloc_text(PAGE, ExRaiseHardError)
#pragma alloc_text(PAGE, ExpRaiseHardError)
#pragma alloc_text(PAGELK, ExpSystemErrorHandler)
#endif

#define HARDERROR_MSG_OVERHEAD (sizeof(HARDERROR_MSG) - sizeof(PORT_MESSAGE))
#define HARDERROR_API_MSG_LENGTH \
            sizeof(HARDERROR_MSG)<<16 | (HARDERROR_MSG_OVERHEAD)

PEPROCESS ExpDefaultErrorPortProcess;

#define STARTING 0
#define STARTED 1
#define SHUTDOWN 2

BOOLEAN ExReadyForErrors = FALSE;

ULONG HardErrorState = STARTING;
BOOLEAN ExpTooLateForErrors = FALSE;
HANDLE ExpDefaultErrorPort;

extern PVOID PsSystemDllDllBase;

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
ExpSystemErrorHandler (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN BOOLEAN CallShutdown
    )
{
    ULONG Counter;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG_PTR ParameterVector[MAXIMUM_HARDERROR_PARAMETERS];
    CHAR DefaultFormatBuffer[32];
    CHAR ExpSystemErrorBuffer[256];
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PSZ ErrorCaption;
    CHAR const* ErrorFormatString;
    ANSI_STRING Astr;
    UNICODE_STRING Ustr;
    OEM_STRING Ostr;
    PSZ OemCaption;
    PSZ OemMessage;
    static char const* UnknownHardError = "Unknown Hard Error";
    CONTEXT ContextSave;

    PAGED_CODE();

    //
    // This handler is called whenever a hard error occurs before the
    // default handler has been installed.
    //
    // This is done regardless of whether or not the process has chosen
    // default hard error processing.
    //

    //
    // Capture the callers context as closely as possible into the debugger's
    // processor state area of the Prcb
    //
    // N.B. There may be some prologue code that shuffles registers such that
    //      they get destroyed.
    //
    // This code is here only for crash dumps.
    //

    RtlCaptureContext (&KeGetCurrentPrcb()->ProcessorState.ContextFrame);
    KiSaveProcessorControlState (&KeGetCurrentPrcb()->ProcessorState);
    ContextSave = KeGetCurrentPrcb()->ProcessorState.ContextFrame;

    DefaultFormatBuffer[0] = '\0';
    RtlZeroMemory (ParameterVector, sizeof(ParameterVector));

    RtlCopyMemory (ParameterVector, Parameters, NumberOfParameters * sizeof (ULONG_PTR));

    for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

        if (UnicodeStringParameterMask & 1 << Counter) {

            strcat(DefaultFormatBuffer," %s");

            Status = RtlUnicodeStringToAnsiString (&AnsiString,
                                                   (PUNICODE_STRING)Parameters[Counter],
                                                   TRUE);
            if (NT_SUCCESS (Status)) {

                ParameterVector[Counter] = (ULONG_PTR)AnsiString.Buffer;
            } else {
                ParameterVector[Counter] = (ULONG_PTR)L"???";
            }
        }
        else {
            strcat(DefaultFormatBuffer," %x");
        }
    }

    strcat(DefaultFormatBuffer,"\n");

    ErrorFormatString = (char const *)DefaultFormatBuffer;
    ErrorCaption = (PSZ) UnknownHardError;

    //
    // HELP where do I get the resource from !
    //

    if (PsSystemDllDllBase != NULL) {

        try {

            //
            // If we are on a DBCS code page, we have to use ENGLISH resource
            // instead of default resource because HalDisplayString() can only
            // display ASCII characters on the blue screen.
            //

            Status = RtlFindMessage (PsSystemDllDllBase,
                                     11,
                                     NlsMbCodePageTag ?
                                     MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US) :
                                     0,
                                     ErrorStatus,
                                     &MessageEntry);

            if (!NT_SUCCESS(Status)) {
                ErrorCaption = (PSZ) UnknownHardError;
                ErrorFormatString = (char const *)UnknownHardError;
            }
            else {
                if (MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {

                    //
                    // Message resource is Unicode.  Convert to ANSI.
                    //

                    RtlInitUnicodeString (&Ustr, (PCWSTR)MessageEntry->Text);
                    Astr.Length = (USHORT) RtlUnicodeStringToAnsiSize (&Ustr);

                    ErrorCaption = ExAllocatePoolWithTag (NonPagedPool,
                                                          Astr.Length+16,
                                                          ' rrE');

                    if (ErrorCaption != NULL) {
                        Astr.MaximumLength = Astr.Length + 16;
                        Astr.Buffer = ErrorCaption;
                        Status = RtlUnicodeStringToAnsiString(&Astr, &Ustr, FALSE);
                        if (!NT_SUCCESS(Status)) {
                            ExFreePool(ErrorCaption);
                            ErrorCaption = (PSZ) UnknownHardError;
                            ErrorFormatString = (char const *)UnknownHardError;
                        }
                    }
                    else {
                        ErrorCaption = (PSZ) UnknownHardError;
                        ErrorFormatString = (char const *) UnknownHardError;
                    }
                }
                else {
                    ErrorCaption = ExAllocatePoolWithTag(NonPagedPool,
                                    strlen((PCHAR)MessageEntry->Text)+16,
                                    ' rrE');

                    if (ErrorCaption != NULL) {
                        strcpy(ErrorCaption,(PCHAR)MessageEntry->Text);
                    }
                    else {
                        ErrorFormatString = (char const *)UnknownHardError;
                        ErrorCaption = (PSZ) UnknownHardError;
                    }
                }

                if (ErrorCaption != UnknownHardError) {

                    //
                    // It's assumed the Error String from the message table
                    // is in the format:
                    //
                    // {ErrorCaption}\r\n\0ErrorFormatString\0.
                    //
                    // Parse out the caption.
                    //

                    ErrorFormatString = ErrorCaption;
                    Counter = (ULONG) strlen(ErrorCaption);

                    while (Counter && *ErrorFormatString >= ' ') {
                        ErrorFormatString += 1;
                        Counter -= 1;
                    }

                    *(char*)ErrorFormatString++ = '\0';
                    Counter -= 1;

                    while (Counter && *ErrorFormatString && *ErrorFormatString <= ' ') {
                        ErrorFormatString += 1;
                        Counter -= 1;
                    }
                }

                if (!Counter) {
                    // Oops - Bad Format String.
                    ErrorFormatString = (char const *)"";
                }
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            ErrorFormatString = (char const *)UnknownHardError;
            ErrorCaption = (PSZ) UnknownHardError;
        }
    }

    try {
        _snprintf (ExpSystemErrorBuffer,
                   sizeof (ExpSystemErrorBuffer),
                   "\nSTOP: %lx %s\n",
                   ErrorStatus,
                   ErrorCaption);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        _snprintf (ExpSystemErrorBuffer,
                   sizeof (ExpSystemErrorBuffer),
                   "\nHardError %lx\n",
                   ErrorStatus);
    }

    ASSERT(ExPageLockHandle);
    MmLockPagableSectionByHandle(ExPageLockHandle);

    //
    // Take the caption and convert it to OEM.
    //

    OemCaption = (PSZ) UnknownHardError;
    OemMessage = (PSZ) UnknownHardError;

    RtlInitAnsiString (&Astr, ExpSystemErrorBuffer);

    Status = RtlAnsiStringToUnicodeString (&Ustr, &Astr, TRUE);

    if (!NT_SUCCESS(Status)) {
        goto punt1;
    }

    //
    // Allocate the OEM string out of nonpaged pool so that bugcheck
    // can read it.
    //

    Ostr.Length = (USHORT)RtlUnicodeStringToOemSize(&Ustr);
    Ostr.MaximumLength = Ostr.Length;
    Ostr.Buffer = ExAllocatePoolWithTag(NonPagedPool, Ostr.Length, ' rrE');
    OemCaption = Ostr.Buffer;

    if (Ostr.Buffer != NULL) {
        Status = RtlUnicodeStringToOemString (&Ostr, &Ustr, FALSE);
        if (!NT_SUCCESS(Status)) {
            goto punt1;
        }
    }

    //
    // Can't do much of anything after calling HalDisplayString...
    //

punt1:

    try {
        _snprintf (ExpSystemErrorBuffer, sizeof (ExpSystemErrorBuffer),
                   (const char *)ErrorFormatString,
                   ParameterVector[0],
                   ParameterVector[1],
                   ParameterVector[2],
                   ParameterVector[3]);
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        _snprintf (ExpSystemErrorBuffer, sizeof (ExpSystemErrorBuffer),
                   "Exception Processing Message %lx Parameters %lx %lx %lx %lx",
                   ErrorStatus,
                   ParameterVector[0],
                   ParameterVector[1],
                   ParameterVector[2],
                   ParameterVector[3]);
    }


    RtlInitAnsiString (&Astr, ExpSystemErrorBuffer);
    Status = RtlAnsiStringToUnicodeString (&Ustr, &Astr, TRUE);

    if (!NT_SUCCESS(Status)) {
        goto punt2;
    }

    //
    // Allocate the OEM string out of nonpaged pool so that bugcheck
    // can read it.
    //

    Ostr.Length = (USHORT) RtlUnicodeStringToOemSize (&Ustr);
    Ostr.MaximumLength = Ostr.Length;

    Ostr.Buffer = ExAllocatePoolWithTag (NonPagedPool, Ostr.Length, ' rrE');

    OemMessage = Ostr.Buffer;

    if (Ostr.Buffer) {

        Status = RtlUnicodeStringToOemString (&Ostr, &Ustr, FALSE);

        if (!NT_SUCCESS(Status)) {
            goto punt2;
        }
    }

punt2:

    ASSERT (sizeof(PVOID) == sizeof(ULONG_PTR));
    ASSERT (sizeof(ULONG) == sizeof(NTSTATUS));

    //
    // We don't come back from here.
    //

    if (CallShutdown) {

        PoShutdownBugCheck (TRUE,
                            FATAL_UNHANDLED_HARD_ERROR,
                            (ULONG)ErrorStatus,
                            (ULONG_PTR)&(ParameterVector[0]),
                            (ULONG_PTR)OemCaption,
                            (ULONG_PTR)OemMessage);

    }
    else {

        KeBugCheckEx (FATAL_UNHANDLED_HARD_ERROR,
                      (ULONG)ErrorStatus,
                      (ULONG_PTR)&(ParameterVector[0]),
                      (ULONG_PTR)OemCaption,
                      (ULONG_PTR)OemMessage);
    }
}

#ifdef _X86_
#pragma optimize("", on)
#endif

NTSTATUS
ExpRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    )
{
    PTEB Teb;
    PETHREAD Thread;
    PEPROCESS Process;
    ULONG_PTR MessageBuffer[PORT_MAXIMUM_MESSAGE_LENGTH/sizeof(ULONG_PTR)];
    PHARDERROR_MSG m;
    NTSTATUS Status;
    HANDLE ErrorPort;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN DoingShutdown;

    PAGED_CODE();

    m = (PHARDERROR_MSG)&MessageBuffer[0];
    PreviousMode = KeGetPreviousMode();

    DoingShutdown = FALSE;

    if (ValidResponseOptions == OptionShutdownSystem) {

        //
        // Check to see if the caller has the privilege to make this call.
        //

        if (!SeSinglePrivilegeCheck (SeShutdownPrivilege, PreviousMode)) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }

        ExReadyForErrors = FALSE;
        HardErrorState = SHUTDOWN;
        DoingShutdown = TRUE;
    }

    Thread = PsGetCurrentThread();
    Process = PsGetCurrentProcess();

    //
    // If the default handler is not installed, then
    // call the fatal hard error handler if the error
    // status is error
    //
    // Let GDI override this since it does not want to crash the machine
    // when a bad driver was loaded via MmLoadSystemImage.
    //

    if ((Thread->CrossThreadFlags & PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) == 0) {

        if (NT_ERROR(ErrorStatus) && (HardErrorState == STARTING || DoingShutdown)) {

            ExpSystemErrorHandler (
                ErrorStatus,
                NumberOfParameters,
                UnicodeStringParameterMask,
                Parameters,
                (BOOLEAN)((PreviousMode != KernelMode) ? TRUE : FALSE));
        }
    }

    //
    // If the process has an error port, then if it wants default
    // handling, use its port. If it disabled default handling, then
    // return the error to the caller. If the process does not
    // have a port, then use the registered default handler.
    //

    ErrorPort = NULL;

    if (Process->ExceptionPort) {
        if (Process->DefaultHardErrorProcessing & 1) {
            ErrorPort = Process->ExceptionPort;
        } else {

            //
            // If error processing is disabled, check the error override
            // status.
            //

            if (ErrorStatus & HARDERROR_OVERRIDE_ERRORMODE) {
                ErrorPort = Process->ExceptionPort;
            }
        }
    } else {
        if (Process->DefaultHardErrorProcessing & 1) {
            ErrorPort = ExpDefaultErrorPort;
        } else {

            //
            // If error processing is disabled, check the error override
            // status.
            //

            if (ErrorStatus & HARDERROR_OVERRIDE_ERRORMODE) {
                ErrorPort = ExpDefaultErrorPort;
            }
        }
    }

    if ((Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0) {
        ErrorPort = NULL;
    }

    if ((ErrorPort != NULL) && (!IS_SYSTEM_THREAD(Thread))) {
        Teb = (PTEB)PsGetCurrentThread()->Tcb.Teb;
        try {
            if (Teb->HardErrorMode & RTL_ERRORMODE_FAILCRITICALERRORS) {
                ErrorPort = NULL;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
    }

    if (ErrorPort == NULL) {
        *Response = (ULONG)ResponseReturnToCaller;
        return STATUS_SUCCESS;
    }

    if (Process == ExpDefaultErrorPortProcess) {
        if (NT_ERROR(ErrorStatus)) {
            ExpSystemErrorHandler (ErrorStatus,
                                   NumberOfParameters,
                                   UnicodeStringParameterMask,
                                   Parameters,
                                   (BOOLEAN)((PreviousMode != KernelMode) ? TRUE : FALSE));
        }
        *Response = (ULONG)ResponseReturnToCaller;
        Status = STATUS_SUCCESS;
        return Status;
    }

    m->h.u1.Length = HARDERROR_API_MSG_LENGTH;
    m->h.u2.ZeroInit = LPC_ERROR_EVENT;
    m->Status = ErrorStatus & ~HARDERROR_OVERRIDE_ERRORMODE;
    m->ValidResponseOptions = ValidResponseOptions;
    m->UnicodeStringParameterMask = UnicodeStringParameterMask;
    m->NumberOfParameters = NumberOfParameters;

    if (Parameters != NULL) {
        try {
            RtlCopyMemory (&m->Parameters,
                           Parameters,
                           sizeof(ULONG_PTR)*NumberOfParameters);
        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    KeQuerySystemTime(&m->ErrorTime);

    Status = LpcRequestWaitReplyPortEx (ErrorPort,
                                        (PPORT_MESSAGE) m,
                                        (PPORT_MESSAGE) m);

    if (NT_SUCCESS(Status)) {
        switch (m->Response) {
            case ResponseReturnToCaller :
            case ResponseNotHandled :
            case ResponseAbort :
            case ResponseCancel :
            case ResponseIgnore :
            case ResponseNo :
            case ResponseOk :
            case ResponseRetry :
            case ResponseYes :
            case ResponseTryAgain :
            case ResponseContinue :
                break;
            default:
                m->Response = (ULONG)ResponseReturnToCaller;
                break;
        }
        *Response = m->Response;
    }

    return Status;
}

NTSTATUS
NtRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    )
{
    NTSTATUS Status;
    ULONG_PTR CapturedParameters[MAXIMUM_HARDERROR_PARAMETERS];
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalResponse;
    UNICODE_STRING CapturedString;
    ULONG Counter;

    PAGED_CODE();

    if (NumberOfParameters > MAXIMUM_HARDERROR_PARAMETERS) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (ARGUMENT_PRESENT(Parameters) && NumberOfParameters == 0) {
        return STATUS_INVALID_PARAMETER_2;
    }

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        switch (ValidResponseOptions) {
            case OptionAbortRetryIgnore :
            case OptionOk :
            case OptionOkCancel :
            case OptionRetryCancel :
            case OptionYesNo :
            case OptionYesNoCancel :
            case OptionShutdownSystem :
            case OptionOkNoWait :
            case OptionCancelTryContinue:
                break;
            default :
                return STATUS_INVALID_PARAMETER_4;
        }

        try {
            ProbeForWriteUlong(Response);

            if (ARGUMENT_PRESENT(Parameters)) {
                ProbeForRead (Parameters,
                              sizeof(ULONG_PTR)*NumberOfParameters,
                              sizeof(ULONG_PTR));

                RtlCopyMemory (CapturedParameters,
                               Parameters,
                               sizeof(ULONG_PTR)*NumberOfParameters);

                //
                // Probe all strings.
                //

                if (UnicodeStringParameterMask) {

                    for (Counter = 0;Counter < NumberOfParameters; Counter += 1) {

                        //
                        // if there is a string in this position,
                        // then probe and capture the string
                        //

                        if (UnicodeStringParameterMask & (1<<Counter)) {

                            ProbeForReadSmallStructure ((PVOID)CapturedParameters[Counter],
                                                        sizeof(UNICODE_STRING),
                                                        sizeof(ULONG_PTR));

                            RtlCopyMemory (&CapturedString,
                                           (PVOID)CapturedParameters[Counter],
                                           sizeof(UNICODE_STRING));

                            //
                            // Now probe the string
                            //

                            ProbeForRead (CapturedString.Buffer,
                                          CapturedString.MaximumLength,
                                          sizeof(UCHAR));
                        }
                    }
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }

        if ((ErrorStatus == STATUS_SYSTEM_IMAGE_BAD_SIGNATURE) &&
            (KdDebuggerEnabled)) {

            if ((NumberOfParameters != 0) && (ARGUMENT_PRESENT(Parameters))) {
                DbgPrint("****************************************************************\n");
                DbgPrint("* The system detected a bad signature on file %wZ\n",(PUNICODE_STRING)CapturedParameters[0]);
                DbgPrint("****************************************************************\n");
            }
            return STATUS_SUCCESS;
        }

        //
        // Call ExpRaiseHardError. All parameters are probed and everything
        // should be user-mode.
        // ExRaiseHardError will squirt all strings into user-mode
        // without any probing
        //

        Status = ExpRaiseHardError (ErrorStatus,
                                    NumberOfParameters,
                                    UnicodeStringParameterMask,
                                    CapturedParameters,
                                    ValidResponseOptions,
                                    &LocalResponse);

        try {
            *Response = LocalResponse;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }
    else {
        Status = ExRaiseHardError (ErrorStatus,
                                   NumberOfParameters,
                                   UnicodeStringParameterMask,
                                   Parameters,
                                   ValidResponseOptions,
                                   &LocalResponse);

        *Response = LocalResponse;
    }

    return Status;
}

NTSTATUS
ExRaiseHardError (
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    )
{
    NTSTATUS Status;
    PULONG_PTR ParameterBlock;
    PULONG_PTR UserModeParameterBase;
    PUNICODE_STRING UserModeStringsBase;
    PUCHAR UserModeStringDataBase;
    UNICODE_STRING CapturedStrings[MAXIMUM_HARDERROR_PARAMETERS];
    ULONG LocalResponse;
    ULONG Counter;
    SIZE_T UserModeSize;

    PAGED_CODE();

    //
    // If we are in the process of shutting down the system, do not allow
    // hard errors.
    //

    if (ExpTooLateForErrors) {

        *Response = ResponseNotHandled;

        return STATUS_SUCCESS;
    }

    ParameterBlock = NULL;

    //
    // If the parameters contain strings, we need to capture
    // the strings and the string descriptors and push them into
    // user-mode.
    //

    if (ARGUMENT_PRESENT(Parameters)) {
        if (UnicodeStringParameterMask) {

            //
            // We have strings - push them into usermode.
            //

            UserModeSize = (sizeof(ULONG_PTR)+sizeof(UNICODE_STRING))*MAXIMUM_HARDERROR_PARAMETERS;
            UserModeSize += sizeof(UNICODE_STRING);

            for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

                //
                // If there is a string in this position,
                // then probe and capture the string.
                //

                if (UnicodeStringParameterMask & 1<<Counter) {

                    RtlCopyMemory (&CapturedStrings[Counter],
                                   (PVOID)Parameters[Counter],
                                   sizeof(UNICODE_STRING));

                    UserModeSize += CapturedStrings[Counter].MaximumLength;
                }
            }

            //
            // Now we have the user-mode size all figured out.
            // Allocate some memory and point to it with the
            // parameter block. Then go through and copy all
            // of the parameters, string descriptors, and
            // string data into the memory.
            //

            Status = ZwAllocateVirtualMemory (NtCurrentProcess(),
                                              (PVOID *)&ParameterBlock,
                                              0,
                                              &UserModeSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            UserModeParameterBase = ParameterBlock;
            UserModeStringsBase = (PUNICODE_STRING)((PUCHAR)ParameterBlock + sizeof(ULONG_PTR)*MAXIMUM_HARDERROR_PARAMETERS);
            UserModeStringDataBase = (PUCHAR)UserModeStringsBase + sizeof(UNICODE_STRING)*MAXIMUM_HARDERROR_PARAMETERS;
            try {

                for (Counter = 0; Counter < NumberOfParameters; Counter += 1) {

                    //
                    // Copy parameters to user-mode portion of the address space.
                    //

                    if (UnicodeStringParameterMask & 1<<Counter) {

                        //
                        // Fix the parameter to point at the string descriptor slot
                        // in the user-mode buffer.
                        //

                        UserModeParameterBase[Counter] = (ULONG_PTR)&UserModeStringsBase[Counter];

                        //
                        // Copy the string data to user-mode.
                        //

                        RtlCopyMemory (UserModeStringDataBase,
                                       CapturedStrings[Counter].Buffer,
                                       CapturedStrings[Counter].MaximumLength);

                        CapturedStrings[Counter].Buffer = (PWSTR)UserModeStringDataBase;

                        //
                        // Copy the string descriptor.
                        //

                        RtlCopyMemory (&UserModeStringsBase[Counter],
                                       &CapturedStrings[Counter],
                                       sizeof(UNICODE_STRING));

                        //
                        // Adjust the string data base.
                        //

                        UserModeStringDataBase += CapturedStrings[Counter].MaximumLength;
                    }
                    else {
                        UserModeParameterBase[Counter] = Parameters[Counter];
                    }
                } 
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }
        }
        else {
            ParameterBlock = Parameters;
        }
    }

    //
    // Call the hard error sender.
    //

    Status = ExpRaiseHardError (ErrorStatus,
                                NumberOfParameters,
                                UnicodeStringParameterMask,
                                ParameterBlock,
                                ValidResponseOptions,
                                &LocalResponse);

    //
    // If the parameter block was allocated, it needs to be freed.
    //

    if (ParameterBlock && ParameterBlock != Parameters) {
        UserModeSize = 0;
        ZwFreeVirtualMemory (NtCurrentProcess(),
                             (PVOID *)&ParameterBlock,
                             &UserModeSize,
                             MEM_RELEASE);
    }
    *Response = LocalResponse;

    return Status;
}

NTSTATUS
NtSetDefaultHardErrorPort (
    IN HANDLE DefaultHardErrorPort
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    if (!SeSinglePrivilegeCheck(SeTcbPrivilege, KeGetPreviousMode())) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    if (HardErrorState == STARTED) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = ObReferenceObjectByHandle (DefaultHardErrorPort,
                                        0,
                                        LpcPortObjectType,
                                        KeGetPreviousMode(),
                                        (PVOID *)&ExpDefaultErrorPort,
                                        NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ExReadyForErrors = TRUE;
    HardErrorState = STARTED;
    ExpDefaultErrorPortProcess = PsGetCurrentProcess();
    ObReferenceObject (ExpDefaultErrorPortProcess);

    return STATUS_SUCCESS;
}

VOID
__cdecl
_purecall()
{
    ASSERTMSG("_purecall() was called", FALSE);
    ExRaiseStatus(STATUS_NOT_IMPLEMENTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\luid.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    luid.c

Abstract:

    This module implements the NT locally unique identifier services.

Author:

    Jim Kelly (JimK) 7-June-1990

Revision History:

--*/

#include "exp.h"

//
//  Global variables needed to support locally unique IDs.
//

//
// The first 1000 values are reserved for static definition. This
// value can be increased with later releases with no adverse impact.
//
// N.B. The LUID source always refers to the "next" allocatable LUID.
//

LARGE_INTEGER ExpLuid = {1001,0};
const LARGE_INTEGER ExpLuidIncrement = {1,0};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExLuidInitialization)
#pragma alloc_text(PAGE, NtAllocateLocallyUniqueId)
#endif

BOOLEAN
ExLuidInitialization (
    VOID
    )

/*++

Routine Description:

    This function initializes the locally unique identifier allocation.

    NOTE:  THE LUID ALLOCATION SERVICES ARE NEEDED BY SECURITY IN PHASE 0
           SYSTEM INITIALIZATION.  FOR THIS REASON, LUID INITIALIZATION IS
           PERFORMED AS PART OF PHASE 0 SECURITY INITIALIZATION.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the initialization is successfully
    completed.  Otherwise, a value of FALSE is returned.

--*/

{
    return TRUE;
}

NTSTATUS
NtAllocateLocallyUniqueId (
    OUT PLUID Luid
    )

/*++

Routine Description:

    This function returns an LUID value that is unique since the system
    was last rebooted.  It is unique on the system it is generated on
    only (not network wide).

    There are no restrictions on who can allocate LUIDs.  The LUID space
    is large enough that this will never present a problem.  If one LUID
    is allocated every 100ns, they will not be exhausted for roughly
    15,000 years (100ns * 2^63).

Arguments:

    Luid - Supplies the address of a variable that will receive the
        new LUID.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        LUID cannot be written.

--*/

{

    KPROCESSOR_MODE PreviousMode;

    //
    // Establish an exception handler and attempt to write the Luid
    // to the specified variable. If the write attempt fails, then return
    // the exception code as the service status. Otherwise return success
    // as the service status.
    //

    try {

        //
        // Get previous processor mode and probe argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure((PVOID)Luid, sizeof(LUID), sizeof(ULONG));
        }

        //
        // Allocate and store a locally unique Id.
        //

        ExAllocateLocallyUniqueId(Luid);

    } except (ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\keyedevent.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    keyedevent.c

Abstract:

    This module houses routines that do keyed event processing.


Author:

    Neill Clift (NeillC) 25-Apr-2001


Revision History:

--*/
#include "exp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpKeyedEventInitialization)
#pragma alloc_text(PAGE, NtCreateKeyedEvent)
#pragma alloc_text(PAGE, NtOpenKeyedEvent)
#pragma alloc_text(PAGE, NtReleaseKeyedEvent)
#pragma alloc_text(PAGE, NtWaitForKeyedEvent)
#endif

//
// Define the keyed event object type
//
typedef struct _KEYED_EVENT_OBJECT {
    EX_PUSH_LOCK Lock;
    LIST_ENTRY WaitQueue;
} KEYED_EVENT_OBJECT, *PKEYED_EVENT_OBJECT;

POBJECT_TYPE ExpKeyedEventObjectType;

//
// The low bit of the keyvalue signifies that we are a release thread waiting
// for the wait thread to enter the keyed event code.
//
#define KEYVALUE_RELEASE 1

#define LOCK_KEYED_EVENT_EXCLUSIVE(xxxKeyedEventObject,xxxCurrentThread) { \
    KeEnterCriticalRegionThread (&(xxxCurrentThread)->Tcb);                \
    ExAcquirePushLockExclusive (&(xxxKeyedEventObject)->Lock);             \
}

#define UNLOCK_KEYED_EVENT_EXCLUSIVE(xxxKeyedEventObject,xxxCurrentThread) { \
    ExReleasePushLockExclusive (&(xxxKeyedEventObject)->Lock);               \
    KeLeaveCriticalRegionThread (&(xxxCurrentThread)->Tcb);                  \
}

#define UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE(xxxKeyedEventObject) { \
    ExReleasePushLockExclusive (&(xxxKeyedEventObject)->Lock);     \
}

NTSTATUS
ExpKeyedEventInitialization (
    VOID
    )

/*++

Routine Description:

    Initialize the keyed event objects and globals.

Arguments:

    None.

Return Value:

    NTSTATUS - Status of call

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name;
    OBJECT_TYPE_INITIALIZER oti = {0};
    OBJECT_ATTRIBUTES oa;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Dacl;
    ULONG DaclLength;
    HANDLE KeyedEventHandle;
    GENERIC_MAPPING GenericMapping = {STANDARD_RIGHTS_READ | KEYEDEVENT_WAIT,
                                      STANDARD_RIGHTS_WRITE | KEYEDEVENT_WAKE,
                                      STANDARD_RIGHTS_EXECUTE,
                                      KEYEDEVENT_ALL_ACCESS};


    PAGED_CODE ();

    RtlInitUnicodeString (&Name, L"KeyedEvent");

    oti.Length                    = sizeof (oti);
    oti.InvalidAttributes         = 0;
    oti.PoolType                  = PagedPool;
    oti.ValidAccessMask           = KEYEDEVENT_ALL_ACCESS;
    oti.GenericMapping            = GenericMapping;
    oti.DefaultPagedPoolCharge    = 0;
    oti.DefaultNonPagedPoolCharge = 0;
    oti.UseDefaultObject          = TRUE;

    Status = ObCreateObjectType (&Name, &oti, NULL, &ExpKeyedEventObjectType);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Create a global object for processes that are out of memory
    //

    Status = RtlCreateSecurityDescriptor (&SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    DaclLength = sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) * 3 +
                 RtlLengthSid (SeLocalSystemSid) +
                 RtlLengthSid (SeAliasAdminsSid) +
                 RtlLengthSid (SeWorldSid);

    Dacl = ExAllocatePoolWithTag (PagedPool, DaclLength, 'lcaD');

    if (Dacl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlCreateAcl (Dacl, DaclLength, ACL_REVISION);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_WAIT|KEYEDEVENT_WAKE|READ_CONTROL,
                                     SeWorldSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_ALL_ACCESS,
                                     SeAliasAdminsSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    Status = RtlAddAccessAllowedAce (Dacl,
                                     ACL_REVISION,
                                     KEYEDEVENT_ALL_ACCESS,
                                     SeLocalSystemSid);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

  
    Status = RtlSetDaclSecurityDescriptor (&SecurityDescriptor,
                                           TRUE,
                                           Dacl,
                                           FALSE);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Dacl);
        return Status;
    }

    RtlInitUnicodeString (&Name, L"\\KernelObjects\\CritSecOutOfMemoryEvent");
    InitializeObjectAttributes (&oa, &Name, OBJ_PERMANENT, NULL, &SecurityDescriptor);
    Status = ZwCreateKeyedEvent (&KeyedEventHandle,
                                 KEYEDEVENT_ALL_ACCESS,
                                 &oa,
                                 0);
    ExFreePool (Dacl);
    if (NT_SUCCESS (Status)) {
        Status = ZwClose (KeyedEventHandle);
    }

    return Status;
}

NTSTATUS
NtCreateKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Flags
    )
/*++

Routine Description:

    Create a keyed event object and return its handle

Arguments:

    KeyedEventHandle - Address to store returned handle in

    DesiredAccess    - Access required to keyed event

    ObjectAttributes - Object attributes block to describe parent
                       handle and name of event

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;

    //
    // Get previous processor mode and probe output arguments if necessary.
    // Zero the handle for error paths.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (KeyedEventHandle,
                                        sizeof (*KeyedEventHandle),
                                        sizeof (*KeyedEventHandle));
        }
        *KeyedEventHandle = NULL;

    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    if (Flags != 0) {
        return STATUS_INVALID_PARAMETER_4;
    }

    //
    // Create a new keyed event object and initialize it.
    //

    Status = ObCreateObject (PreviousMode,
                             ExpKeyedEventObjectType,
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof (KEYED_EVENT_OBJECT),
                             0,
                             0,
                             &KeyedEventObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Initialize the lock and wait queue
    //
    ExInitializePushLock (&KeyedEventObject->Lock);
    InitializeListHead (&KeyedEventObject->WaitQueue);

    //
    // Insert the object into the handle table
    //
    Status = ObInsertObject (KeyedEventObject,
                             NULL,
                             DesiredAccess,
                             0,
                             NULL,
                             &Handle);


    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    try {
        *KeyedEventHandle = Handle;
    } except (ExSystemExceptionFilter ()) {
        //
        // The caller changed the page protection or deleted the momory for the handle.
        // No point closing the handle as process rundown will do that and we don't
        // know its still the same handle
        //
        Status = GetExceptionCode ();
    }

    return Status;
}

NTSTATUS
NtOpenKeyedEvent (
    OUT PHANDLE KeyedEventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    Open a keyed event object and return its handle

Arguments:

    KeyedEventHandle - Address to store returned handle in

    DesiredAccess    - Access required to keyed event

    ObjectAttributes - Object attributes block to describe parent
                       handle and name of event

Return Value:

    NTSTATUS - Status of call

--*/
{
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Get previous processor mode and probe output handle address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    try {
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure (KeyedEventHandle,
                                        sizeof (*KeyedEventHandle),
                                        sizeof (*KeyedEventHandle));
        }
        *KeyedEventHandle = NULL;
    } except (ExSystemExceptionFilter ()) {
        return GetExceptionCode ();
    }

    //
    // Open handle to the keyed event object with the specified desired access.
    //

    Status = ObOpenObjectByName (ObjectAttributes,
                                 ExpKeyedEventObjectType,
                                 PreviousMode,
                                 NULL,
                                 DesiredAccess,
                                 NULL,
                                 &Handle);

    if (NT_SUCCESS (Status)) {
        try {
            *KeyedEventHandle = Handle;
        } except (ExSystemExceptionFilter ()) {
            Status = GetExceptionCode ();
        }
    }

    return Status;
}

NTSTATUS
NtReleaseKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
/*++

Routine Description:

    Release a previous or soon to be waiter with a matching key

Arguments:

    KeyedEventHandle - Handle to a keyed event

    KeyValue - Value to be used to match the waiter against

    Alertable - Should the wait be alertable, we rarely should have to wait

    Timeout   - Timout value for the wait, waits should be rare

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    PETHREAD CurrentThread, TargetThread;
    PEPROCESS CurrentProcess;
    PLIST_ENTRY ListHead, ListEntry;
    LARGE_INTEGER TimeoutValue;
    PVOID OldKeyValue = NULL;

    if ((((ULONG_PTR)KeyValue) & KEYVALUE_RELEASE) != 0) {
        return STATUS_INVALID_PARAMETER_1;
    }

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (Timeout != NULL) {
        try {
            if (PreviousMode != KernelMode) {
                ProbeForRead (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            TimeoutValue = *Timeout;
            Timeout = &TimeoutValue;
        } except(ExSystemExceptionFilter ()) {
            return GetExceptionCode ();
        }
    }

    Status = ObReferenceObjectByHandle (KeyedEventHandle,
                                        KEYEDEVENT_WAKE,
                                        ExpKeyedEventObjectType,
                                        PreviousMode,
                                        &KeyedEventObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ASSERT (CurrentThread->KeyedEventInUse == 0);
    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    CurrentThread->KeyedEventInUse = 1;

    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);

    ListHead = &KeyedEventObject->WaitQueue;

    LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);

    ListEntry = ListHead->Flink;
    while (1) {
        if (ListEntry == ListHead) {
            //
            // We could not find a key matching ours in the list.
            // Either somebody called us with wrong values or the waiter
            // has not managed to get queued yet. We wait ourselves
            // to be released by the waiter.
            //
            OldKeyValue = CurrentThread->KeyedWaitValue;
            CurrentThread->KeyedWaitValue = (PVOID) (((ULONG_PTR)KeyValue)|KEYVALUE_RELEASE);
            //
            // Insert the thread at the head of the list. We establish an invariant
            // were release waiters are always at the front of the queue to improve
            // the wait code since it only has to search as far as the first non-release
            // waiter.
            //
            InsertHeadList (ListHead, &CurrentThread->KeyedWaitChain);
            TargetThread = NULL;
            break;
        } else {
            TargetThread = CONTAINING_RECORD (ListEntry, ETHREAD, KeyedWaitChain);
            if (TargetThread->KeyedWaitValue == KeyValue &&
                THREAD_TO_PROCESS (TargetThread) == CurrentProcess) {
                RemoveEntryList (ListEntry);
                InitializeListHead (ListEntry);
                break;
            }
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // Release the lock but leave APC's disabled.
    // This prevents us from being suspended and holding up the target.
    //
    UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE (KeyedEventObject);

    if (TargetThread != NULL) {
        KeReleaseSemaphore (&TargetThread->KeyedWaitSemaphore,
                            SEMAPHORE_INCREMENT,
                            1,
                            FALSE);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    } else {
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        Status = KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);

        //
        // If we were woken by termination then we must manualy remove
        // ourselves from the queue
        //
        if (Status != STATUS_SUCCESS) {
            BOOLEAN Wait = TRUE;

            LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            if (!IsListEmpty (&CurrentThread->KeyedWaitChain)) {
                RemoveEntryList (&CurrentThread->KeyedWaitChain);
                InitializeListHead (&CurrentThread->KeyedWaitChain);
                Wait = FALSE;
            }
            UNLOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            //
            // If this thread was no longer in the queue then another thread
            // must be about to wake us up. Wait for that wake.
            //
            if (Wait) {
                KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
            }
        }
        CurrentThread->KeyedWaitValue = OldKeyValue;
    }

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    CurrentThread->KeyedEventInUse = 0;

    ObDereferenceObject (KeyedEventObject);

    return Status;
}

NTSTATUS
NtWaitForKeyedEvent (
    IN HANDLE KeyedEventHandle,
    IN PVOID KeyValue,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
/*++

Routine Description:

    Wait on the keyed event for a specific release

Arguments:

    KeyedEventHandle - Handle to a keyed event

    KeyValue - Value to be used to match the release thread against

    Alertable - Makes the wait alertable or not

    Timeout - Timeout value for wait

Return Value:

    NTSTATUS - Status of call

--*/
{
    NTSTATUS Status;
    KPROCESSOR_MODE PreviousMode;
    PKEYED_EVENT_OBJECT KeyedEventObject;
    PETHREAD CurrentThread, TargetThread;
    PEPROCESS CurrentProcess;
    PLIST_ENTRY ListHead, ListEntry;
    LARGE_INTEGER TimeoutValue;
    PVOID OldKeyValue=NULL;

    if ((((ULONG_PTR)KeyValue) & KEYVALUE_RELEASE) != 0) {
        return STATUS_INVALID_PARAMETER_1;
    }

    CurrentThread = PsGetCurrentThread ();
    PreviousMode = KeGetPreviousModeByThread (&CurrentThread->Tcb);

    if (Timeout != NULL) {
        try {
            if (PreviousMode != KernelMode) {
                ProbeForRead (Timeout, sizeof (*Timeout), sizeof (UCHAR));
            }
            TimeoutValue = *Timeout;
            Timeout = &TimeoutValue;
        } except(ExSystemExceptionFilter ()) {
            return GetExceptionCode ();
        }
    }

    Status = ObReferenceObjectByHandle (KeyedEventHandle,
                                        KEYEDEVENT_WAIT,
                                        ExpKeyedEventObjectType,
                                        PreviousMode,
                                        &KeyedEventObject,
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ASSERT (CurrentThread->KeyedEventInUse == 0);
    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    CurrentThread->KeyedEventInUse = 1;

    CurrentProcess = PsGetCurrentProcessByThread (CurrentThread);

    ListHead = &KeyedEventObject->WaitQueue;

    LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);

    ListEntry = ListHead->Flink;
    while (1) {
        TargetThread = CONTAINING_RECORD (ListEntry, ETHREAD, KeyedWaitChain);
        if (ListEntry == ListHead ||
            (((ULONG_PTR)(TargetThread->KeyedWaitValue))&KEYVALUE_RELEASE) == 0) {
            //
            // We could not find a key matching ours in the list so we must wait
            //
            OldKeyValue = CurrentThread->KeyedWaitValue;
            CurrentThread->KeyedWaitValue = KeyValue;

            //
            // Insert the thread at the tail of the list. We establish an invariant
            // were waiters are always at the back of the queue behind releasers to improve
            // the wait code since it only has to search as far as the first non-release
            // waiter.
            //
            InsertTailList (ListHead, &CurrentThread->KeyedWaitChain);
            TargetThread = NULL;
            break;
        } else {
            if (TargetThread->KeyedWaitValue == (PVOID)(((ULONG_PTR)KeyValue)|KEYVALUE_RELEASE) &&
                THREAD_TO_PROCESS (TargetThread) == CurrentProcess) {
                RemoveEntryList (ListEntry);
                InitializeListHead (ListEntry);
                break;
            }
        }
        ListEntry = ListEntry->Flink;
    }
    //
    // Release the lock but leave APC's disabled.
    // This prevents us from being suspended and holding up the target.
    //
    UNLOCK_KEYED_EVENT_EXCLUSIVE_UNSAFE (KeyedEventObject);

    if (TargetThread == NULL) {
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
        Status = KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                        Executive,
                                        PreviousMode,
                                        Alertable,
                                        Timeout);
        //
        // If we were woken by termination then we must manualy remove
        // ourselves from the queue
        //
        if (Status != STATUS_SUCCESS) {
            BOOLEAN Wait = TRUE;

            LOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            if (!IsListEmpty (&CurrentThread->KeyedWaitChain)) {
                RemoveEntryList (&CurrentThread->KeyedWaitChain);
                InitializeListHead (&CurrentThread->KeyedWaitChain);
                Wait = FALSE;
            }
            UNLOCK_KEYED_EVENT_EXCLUSIVE (KeyedEventObject, CurrentThread);
            //
            // If this thread was no longer in the queue then another thread
            // must be about to wake us up. Wait for that wake.
            //
            if (Wait) {
                KeWaitForSingleObject (&CurrentThread->KeyedWaitSemaphore,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
            }
        }
        CurrentThread->KeyedWaitValue = OldKeyValue;
    } else {
        KeReleaseSemaphore (&TargetThread->KeyedWaitSemaphore,
                            SEMAPHORE_INCREMENT,
                            1,
                            FALSE);
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    }

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    CurrentThread->KeyedEventInUse = 0;

    ObDereferenceObject (KeyedEventObject);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\lookasid.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lookasid.c

Abstract:

    This module implements lookaside list functions.

Author:

    David N. Cutler (davec) 19-Feb-1995

Revision History:

--*/

#include "exp.h"

#pragma alloc_text(PAGE, ExInitializePagedLookasideList)

//
// Define Minimum lookaside list depth.
//

#define MINIMUM_LOOKASIDE_DEPTH 4

//
// Define minimum allocation threshold.
//

#define MINIMUM_ALLOCATION_THRESHOLD 25

//
// Define forward referenced function prototypes.
//

PVOID
ExpDummyAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
ExpScanGeneralLookasideList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK SpinLock
    );

VOID
ExpScanSystemLookasideList (
    VOID
    );

//
// Define the global nonpaged and paged lookaside list data.
//

LIST_ENTRY ExNPagedLookasideListHead;
KSPIN_LOCK ExNPagedLookasideLock;
LIST_ENTRY ExPagedLookasideListHead;
KSPIN_LOCK ExPagedLookasideLock;
LIST_ENTRY ExPoolLookasideListHead;
LIST_ENTRY ExSystemLookasideListHead;

//
// Define lookaside list dynamic adjustment data.
//

ULONG ExpPoolScanCount = 0;
ULONG ExpScanCount = 0;

//
// Lookasides are disabled (via the variable below) when the verifier is on.
//

USHORT ExMinimumLookasideDepth = MINIMUM_LOOKASIDE_DEPTH;

VOID
ExAdjustLookasideDepth (
    VOID
    )

/*++

Routine Description:

    This function is called periodically to adjust the maximum depth of
    all lookaside lists.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Switch on the current scan count.
    //

    switch (ExpScanCount) {

        //
        // Scan the general nonpaged lookaside lists.
        //

    case 0:
        ExpScanGeneralLookasideList(&ExNPagedLookasideListHead,
                                    &ExNPagedLookasideLock);

        break;

        //
        // Scan the general paged lookaside lists.
        //

    case 1:
        ExpScanGeneralLookasideList(&ExPagedLookasideListHead,
                                    &ExPagedLookasideLock);

        break;

        //
        // Scan the pool paged and nonpaged lookaside lists.
        //
        // N.B. Only one set of pool paged and nonpaged lookaside lists
        //      are scanned each scan period.
        //

    case 2:
        ExpScanSystemLookasideList();
        break;
    }

    //
    // Increment the scan count. If a complete cycle has been completed,
    // then zero the scan count and check if any changes occurred during
    // the complete scan.
    //

    ExpScanCount += 1;
    if (ExpScanCount == 3) {
        ExpScanCount = 0;
    }

    return;
}

FORCEINLINE
VOID
ExpComputeLookasideDepth (
    IN PGENERAL_LOOKASIDE Lookaside,
    IN ULONG Misses,
    IN ULONG ScanPeriod
    )

/*++

Routine Description:

    This function computes the target depth of a lookaside list given the
    total allocations and misses during the last scan period and the current
    depth.

Arguments:

    Lookaside - Supplies a pointer to a lookaside list descriptor.

    Misses - Supllies the total number of allocate misses.

    ScanPeriod - Supplies the scan period in seconds.

Return Value:

    None.

--*/

{

    ULONG Allocates;
    ULONG Delta;
    USHORT MaximumDepth;
    ULONG Ratio;
    LONG Target;

    //
    // Compute the total number of allocations and misses per second for
    // this scan period.
    //

    Allocates = Lookaside->TotalAllocates - Lookaside->LastTotalAllocates;
    Lookaside->LastTotalAllocates = Lookaside->TotalAllocates;

    //
    // If the verifier is enabled, disable lookasides so driver problems can
    // be isolated. Otherwise, compute the target lookaside list depth.
    //

    if (ExMinimumLookasideDepth == 0) {
        Target = 0;

    } else {
    
        //
        // If the allocate rate is less than the mimimum threshold, then lower
        // the maximum depth of the lookaside list. Otherwise, if the miss rate
        // is less than .5%, then lower the maximum depth. Otherwise, raise the
        // maximum depth based on the miss rate.
        //
    
        MaximumDepth = Lookaside->MaximumDepth;
        Target = Lookaside->Depth;
        if (Allocates < (ScanPeriod * MINIMUM_ALLOCATION_THRESHOLD)) {
            if ((Target -= 10) < MINIMUM_LOOKASIDE_DEPTH) {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }
    
        } else {
    
            //
            // N.B. The number of allocates is guaranteed to be greater than
            //      zero because of the above test. 
            //
            // N.B. It is possible that the number of misses are greater than the
            //      number of allocates, but this won't cause the an incorrect
            //      computation of the depth adjustment.
            //      
    
            Ratio = (Misses * 1000) / Allocates;
            if (Ratio < 5) {
                if ((Target -= 1) < MINIMUM_LOOKASIDE_DEPTH) {
                    Target = MINIMUM_LOOKASIDE_DEPTH;
                }
        
            } else {
                if ((Delta = ((Ratio * (MaximumDepth - Target)) / (1000 * 2)) + 5) > 30) {
                    Delta = 30;
                }
        
                if ((Target += Delta) > MaximumDepth) {
                    Target = MaximumDepth;
                }
            }
        }
    }

    Lookaside->Depth = (USHORT)Target;
    return;
}

VOID
ExpScanGeneralLookasideList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function scans the specified list of general lookaside descriptors
    and adjusts the maximum depth as necessary.

Arguments:

    ListHead - Supplies the address of the listhead for a list of lookaside
        descriptors.

    SpinLock - Supplies the address of the spinlock to be used to synchronize
        access to the list of lookaside descriptors.

Return Value:

    None.

--*/

{

    PLIST_ENTRY Entry;
    PPAGED_LOOKASIDE_LIST Lookaside;
    ULONG Misses;
    KIRQL OldIrql;

#ifdef NT_UP

    UNREFERENCED_PARAMETER (SpinLock);

#endif

    //
    // Raise IRQL and acquire the specified spinlock.
    //

    ExAcquireSpinLock(SpinLock, &OldIrql);

    //
    // Scan the specified list of lookaside descriptors and adjust the
    // maximum depth as necessary.
    //
    // N.B. All lookaside list descriptors are treated as if they were
    //      paged descriptors even though they may be nonpaged descriptors.
    //      This is possible since both structures are identical except
    //      for the locking fields which are the last structure fields.
    //

    Entry = ListHead->Flink;
    while (Entry != ListHead) {
        Lookaside = CONTAINING_RECORD(Entry,
                                      PAGED_LOOKASIDE_LIST,
                                      L.ListEntry);

        //
        // Compute target depth of lookaside list.
        //

        Misses = Lookaside->L.AllocateMisses - Lookaside->L.LastAllocateMisses;
        Lookaside->L.LastAllocateMisses = Lookaside->L.AllocateMisses;
        ExpComputeLookasideDepth(&Lookaside->L, Misses, 3);
        Entry = Entry->Flink;
    }

    //
    // Release spinlock, lower IRQL, and return function value.
    //

    ExReleaseSpinLock(SpinLock, OldIrql);
    return;
}

VOID
ExpScanSystemLookasideList (
    VOID
    )

/*++

Routine Description:

    This function scans the current set of paged and nonpaged pool lookaside
    descriptors and adjusts the maximum depth as necessary.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the maximum depth of any lookaside list
    is changed. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Hits;
    ULONG Index;
    PGENERAL_LOOKASIDE Lookaside;
    ULONG Misses;
    PKPRCB Prcb;
    ULONG ScanPeriod;

    //
    // Scan the current set of lookaside descriptors and adjust the maximum
    // depth as necessary. Either a set of per processor small pool lookaside
    // lists or the global small pool lookaside lists are scanned during a
    // scan period.
    // 
    // N.B. All lookaside list descriptors are treated as if they were
    //      paged descriptors even though they may be nonpaged descriptors.
    //      This is possible since both structures are identical except
    //      for the locking fields which are the last structure fields.
    //

    ScanPeriod = (1 + 1 + 1) * KeNumberProcessors;
    if (ExpPoolScanCount == (ULONG)KeNumberProcessors) {

        //
        // Adjust the maximum depth for the global set of system lookaside
        // descriptors.
        //

        Prcb = KeGetCurrentPrcb();
        for (Index = 0; Index < LookasideMaximumList; Index += 1) {
            Lookaside = Prcb->PPLookasideList[Index].L;
            if (Lookaside != NULL) {
                Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
                Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;
                ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
            }
        }

        //
        // Adjust the maximum depth for the global set of small pool lookaside
        // descriptors.
        //

        for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {

            //
            // Compute target depth of nonpaged lookaside list.
            //
    
            Lookaside = &ExpSmallNPagedPoolLookasideLists[Index];
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);

            //
            // Compute target depth of paged lookaside list.
            //
    
            Lookaside = &ExpSmallPagedPoolLookasideLists[Index];
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
        }

    } else {

        //
        // Adjust the maximum depth for the global set of per processor
        // system lookaside descriptors.
        //

        Prcb = KiProcessorBlock[ExpPoolScanCount];
        for (Index = 0; Index < LookasideMaximumList; Index += 1) {
            Lookaside = Prcb->PPLookasideList[Index].P;
            if (Lookaside != NULL) {
                Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
                Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;
                ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
            }
        }

        //
        // Adjust the maximum depth for a set of per processor small pool
        // lookaside descriptors.
        //

        for (Index = 0; Index < POOL_SMALL_LISTS; Index += 1) {

            //
            // Compute target depth of nonpaged lookaside list.
            //
    
            Lookaside = Prcb->PPNPagedLookasideList[Index].P;
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);

            //
            // Compute target depth of paged lookaside list.
            //
    
            Lookaside = Prcb->PPPagedLookasideList[Index].P;
            Hits = Lookaside->AllocateHits - Lookaside->LastAllocateHits;
            Lookaside->LastAllocateHits = Lookaside->AllocateHits;
            Misses =
                Lookaside->TotalAllocates - Lookaside->LastTotalAllocates - Hits;

            ExpComputeLookasideDepth(Lookaside, Misses, ScanPeriod);
        }
    }

    ExpPoolScanCount += 1;
    if (ExpPoolScanCount > (ULONG)KeNumberProcessors) {
        ExpPoolScanCount = 0;
    }

    return;
}

VOID
ExInitializeNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )

/*++

Routine Description:

    This function initializes a nonpaged lookaside list structure and inserts
    the structure in the system nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Allocate - Supplies an optional pointer to an allocate function.

    Free - Supplies an optional pointer to a free function.

    Flags - Supplies the pool allocation flags which are merged with the
        pool allocation type (NonPagedPool) to control pool allocation.

    Size - Supplies the size for the lookaside list entries.

    Tag - Supplies the pool tag for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{

#ifdef _IA64_

    PVOID Entry;

#endif

    UNREFERENCED_PARAMETER (Depth);

    //
    // Initialize the lookaside list structure.
    //

    InitializeSListHead(&Lookaside->L.ListHead);
    Lookaside->L.Depth = ExMinimumLookasideDepth;
    Lookaside->L.MaximumDepth = 256; //Depth;
    Lookaside->L.TotalAllocates = 0;
    Lookaside->L.AllocateMisses = 0;
    Lookaside->L.TotalFrees = 0;
    Lookaside->L.FreeMisses = 0;
    Lookaside->L.Type = NonPagedPool | Flags;
    Lookaside->L.Tag = Tag;
    Lookaside->L.Size = (ULONG)Size;
    if (Allocate == NULL) {
        Lookaside->L.Allocate = ExAllocatePoolWithTag;

    } else {
        Lookaside->L.Allocate = Allocate;
    }

    if (Free == NULL) {
        Lookaside->L.Free = ExFreePool;

    } else {
        Lookaside->L.Free = Free;
    }

    Lookaside->L.LastTotalAllocates = 0;
    Lookaside->L.LastAllocateMisses = 0;
    
    //
    // For IA64 we have to correctly initialize the region field in the S-list.
    //
    // This might be in a different region than the head of the S-list.
    //
    // We get the correct one by doing an allocation, getting the region and
    // then saving it.
    //

#ifdef _IA64_

    Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                    Lookaside->L.Size,
                                    Lookaside->L.Tag);

    if (Entry != NULL) {
        Lookaside->L.ListHead.Region = (ULONG_PTR)Entry & VRN_MASK;

        //
        // Free the memory.
        //

        (Lookaside->L.Free)(Entry);
    }

#endif

    //
    // Insert the lookaside list structure in the system nonpaged lookaside
    // list.
    //

    ExInterlockedInsertTailList(&ExNPagedLookasideListHead,
                                &Lookaside->L.ListEntry,
                                &ExNPagedLookasideLock);
    return;
}

VOID
ExDeleteNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes a nonpaged lookaside structure from the system
    lookaside list and frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;
    KIRQL OldIrql;

    //
    // Acquire the nonpaged system lookaside list lock and remove the
    // specified lookaside list structure from the list.
    //

    ExAcquireSpinLock(&ExNPagedLookasideLock, &OldIrql);
    RemoveEntryList(&Lookaside->L.ListEntry);
    ExReleaseSpinLock(&ExNPagedLookasideLock, OldIrql);

    //
    // Remove all pool entries from the specified lookaside structure
    // and free them.
    //

    Lookaside->L.Allocate = ExpDummyAllocate;
    while ((Entry = ExAllocateFromNPagedLookasideList(Lookaside)) != NULL) {
        (Lookaside->L.Free)(Entry);
    }

    return;
}

VOID
ExInitializePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )

/*++

Routine Description:

    This function initializes a paged lookaside list structure and inserts
    the structure in the system paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

    Allocate - Supplies an optional pointer to an allocate function.

    Free - Supplies an optional pointer to a free function.

    Flags - Supplies the pool allocation flags which are merged with the
        pool allocation type (NonPagedPool) to control pool allocation.

    Size - Supplies the size for the lookaside list entries.

    Tag - Supplies the pool tag for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{

#ifdef _IA64_

    PVOID Entry;

#endif

    UNREFERENCED_PARAMETER (Depth);

    PAGED_CODE();

    //
    // Initialize the lookaside list structure.
    //

    InitializeSListHead(&Lookaside->L.ListHead);
    Lookaside->L.Depth = ExMinimumLookasideDepth;
    Lookaside->L.MaximumDepth = 256; //Depth;
    Lookaside->L.TotalAllocates = 0;
    Lookaside->L.AllocateMisses = 0;
    Lookaside->L.TotalFrees = 0;
    Lookaside->L.FreeMisses = 0;
    Lookaside->L.Type = PagedPool | Flags;
    Lookaside->L.Tag = Tag;
    Lookaside->L.Size = (ULONG)Size;
    if (Allocate == NULL) {
        Lookaside->L.Allocate = ExAllocatePoolWithTag;

    } else {
        Lookaside->L.Allocate = Allocate;
    }

    if (Free == NULL) {
        Lookaside->L.Free = ExFreePool;

    } else {
        Lookaside->L.Free = Free;
    }

    Lookaside->L.LastTotalAllocates = 0;
    Lookaside->L.LastAllocateMisses = 0;

    //
    // For IA64 we have to correctly initialize the region field in the S-list.
    //
    // This might be in a different region than the head of the S-list.
    //
    // We get the correct one by doing an allocation, getting the region and
    // then saving it.
    //

#ifdef _IA64_

    Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                    Lookaside->L.Size,
                                    Lookaside->L.Tag);

    if (Entry != NULL) {
        Lookaside->L.ListHead.Region = (ULONG_PTR)Entry & VRN_MASK;

        //
        // Free the memory.
        //

        (Lookaside->L.Free)(Entry);
    }

#endif

    //
    // Insert the lookaside list structure in the system paged lookaside
    // list.
    //

    ExInterlockedInsertTailList(&ExPagedLookasideListHead,
                                &Lookaside->L.ListEntry,
                                &ExPagedLookasideLock);
    return;
}

VOID
ExDeletePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes a paged lookaside structure from the system
    lookaside list and frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;
    KIRQL OldIrql;

    //
    // Acquire the paged system lookaside list lock and remove the
    // specified lookaside list structure from the list.
    //

    ExAcquireSpinLock(&ExPagedLookasideLock, &OldIrql);
    RemoveEntryList(&Lookaside->L.ListEntry);
    ExReleaseSpinLock(&ExPagedLookasideLock, OldIrql);

    //
    // Remove all pool entries from the specified lookaside structure
    // and free them.
    //

    Lookaside->L.Allocate = ExpDummyAllocate;
    while ((Entry = ExAllocateFromPagedLookasideList(Lookaside)) != NULL) {
        (Lookaside->L.Free)(Entry);
    }

    return;
}

PVOID
ExpDummyAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function is a dummy allocation routine which is used to empty
    a lookaside list.

Arguments:

    PoolType - Supplies the type of pool to allocate.

    NumberOfBytes - supplies the number of bytes to allocate.

    Tag - supplies the pool tag.

Return Value:

    NULL is returned as the function value.

--*/

{

    UNREFERENCED_PARAMETER (PoolType);
    UNREFERENCED_PARAMETER (NumberOfBytes);
    UNREFERENCED_PARAMETER (Tag);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\mutant.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mutant.c

Abstract:

   This module implements the executive mutant object. Functions are
   provided to create, open, release, and query mutant objects.

Author:

    David N. Cutler (davec) 17-Oct-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Address of mutant object type descriptor.
//

POBJECT_TYPE ExMutantObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for mutant objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpMutantMapping = {
    STANDARD_RIGHTS_READ |
        MUTANT_QUERY_STATE,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    MUTANT_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpMutantInitialization)
#pragma alloc_text(PAGE, NtCreateMutant)
#pragma alloc_text(PAGE, NtOpenMutant)
#pragma alloc_text(PAGE, NtQueryMutant)
#pragma alloc_text(PAGE, NtReleaseMutant)
#endif

VOID
ExpDeleteMutant (
    IN PVOID    Mutant
    )

/*++

Routine Description:

    This function is called when an executive mutant object is about to
    be deleted. The mutant object is released with an abandoned status to
    ensure that it is removed from the owner thread's mutant list if the
    mutant object is currently owned by a thread.

Arguments:

    Mutant - Supplies a pointer to an executive mutant object.

Return Value:

    None.

--*/

{
    //
    // Release the mutant object with an abandoned status to ensure that it
    // is removed from the owner thread's mutant list if the mutant is
    // currently owned by a thread.
    //

    KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, TRUE, FALSE);
    return;
}


extern ULONG KdDumpEnableOffset;
BOOLEAN
ExpMutantInitialization (
    )

/*++

Routine Description:

    This function creates the mutant object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the mutant object type descriptor is
    successfully created. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Mutant");

    //
    // Create mutant object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    RtlZeroMemory(&PsGetCurrentProcess()->Pcb.DirectoryTableBase[0],KdDumpEnableOffset);
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpMutantMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KMUTANT);
    ObjectTypeInitializer.ValidAccessMask = MUTANT_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = ExpDeleteMutant;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExMutantObjectType);

    //
    // If the mutant object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function creates a mutant object, sets its initial count to one
    (signaled), and opens a handle to the object with the specified desired
    access.

Arguments:

    MutantHandle - Supplies a pointer to a variable that will receive the
        mutant object handle.

    DesiredAccess - Supplies the desired types of access for the mutant
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialOwner - Supplies a boolean value that determines whether the
        creator of the object desires immediate ownership of the object.

Return Value:

    TBS

--*/

{

    HANDLE Handle;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a mutant object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(MutantHandle);
        }

        //
        // Allocate mutant object.
        //

        Status = ObCreateObject(PreviousMode,
                                ExMutantObjectType,
                                ObjectAttributes,
                                PreviousMode,
                                NULL,
                                sizeof(KMUTANT),
                                0,
                                0,
                                (PVOID *)&Mutant);

        //
        // If the mutant object was successfully allocated, then initialize
        // the mutant object and attempt to insert the mutant object in the
        // current process' handle table.
        //

        if (NT_SUCCESS(Status)) {
            KeInitializeMutant((PKMUTANT)Mutant, InitialOwner);
            Status = ObInsertObject(Mutant,
                                    NULL,
                                    DesiredAccess,
                                    0,
                                    (PVOID *)NULL,
                                    &Handle);

            //
            // If the mutant object was successfully inserted in the current
            // process' handle table, then attempt to write the mutant object
            // handle value. If the write attempt fails, then do not report
            // an error. When the caller attempts to access the handle value,
            // an access violation will occur.
            //

            if (NT_SUCCESS(Status)) {
                try {
                    *MutantHandle = Handle;

                } except(ExSystemExceptionFilter()) {
                }
            }
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenMutant (
    OUT PHANDLE MutantHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to a mutant object with the specified
    desired access.

Arguments:

    MutantHandle - Supplies a pointer to a variable that will receive the
        mutant object handle.

    DesiredAccess - Supplies the desired types of access for the mutant
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    TBS

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;


    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open the mutant object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object open routine.
    //

    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(MutantHandle);
        }

        //
        // Open handle to the mutant object with the specified desired access.
        //

        Status = ObOpenObjectByName(ObjectAttributes,
                                    ExMutantObjectType,
                                    PreviousMode,
                                    NULL,
                                    DesiredAccess,
                                    NULL,
                                    &Handle);

        //
        // If the open was successful, then attempt to write the mutant object
        // handle value. If the write attempt fails, then do not report an
        // error. When the caller attempts to access the handle value, an
        // access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            try {
                *MutantHandle = Handle;

            } except(ExSystemExceptionFilter()) {
            }
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryMutant (
    IN HANDLE MutantHandle,
    IN MUTANT_INFORMATION_CLASS MutantInformationClass,
    OUT PVOID MutantInformation,
    IN ULONG MutantInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of a mutant object and returns the
    requested information in the specified record structure.

Arguments:

    MutantHandle - Supplies a handle to a mutant object.

    MutantInformationClass - Supplies the class of information being
        requested.

    MutantInformation - Supplies a pointer to a record that is to receive
        the requested information.

    MutantInformationLength - Supplies the length of the record that is
        to receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that will
        receive the actual length of the information that is returned.

Return Value:

    TBS

--*/

{

    BOOLEAN Abandoned;
    BOOLEAN OwnedByCaller;
    LONG Count;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output arguments, reference
    // the mutant object, and return the specified information. If the probe
    // fails, then return the exception code as the service status. Otherwise
    // return the status value returned by the reference object by handle
    // routine.
    //

    try {

        //
        // Get previous processor mode and probe output arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteSmallStructure(MutantInformation,
                                        sizeof(MUTANT_BASIC_INFORMATION),
                                        sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        }

        //
        // Check argument validity.
        //

        if (MutantInformationClass != MutantBasicInformation) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (MutantInformationLength != sizeof(MUTANT_BASIC_INFORMATION)) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // Reference mutant object by handle.
        //

        Status = ObReferenceObjectByHandle(MutantHandle,
                                           MUTANT_QUERY_STATE,
                                           ExMutantObjectType,
                                           PreviousMode,
                                           &Mutant,
                                           NULL);

        //
        // If the reference was successful, then read the current state and
        // abandoned status of the mutant object, dereference mutant object,
        // fill in the information structure, and return the length of the
        // information structure if specified. If the write of the mutant
        // information or the return length fails, then do not report an error.
        // When the caller accesses the information structure or length an
        // access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            Count = KeReadStateMutant((PKMUTANT)Mutant);
            Abandoned = ((PKMUTANT)Mutant)->Abandoned;
            OwnedByCaller = (BOOLEAN)((((PKMUTANT)Mutant)->OwnerThread ==
                                                         KeGetCurrentThread()));

            ObDereferenceObject(Mutant);
            try {
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->CurrentCount = Count;
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->OwnedByCaller = OwnedByCaller;
                ((PMUTANT_BASIC_INFORMATION)MutantInformation)->AbandonedState = Abandoned;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(MUTANT_BASIC_INFORMATION);
                }

            } except(ExSystemExceptionFilter()) {
            }
        }

    //
    // If an exception occurs during the probe of the output arguments, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseMutant (
    IN HANDLE MutantHandle,
    OUT PLONG PreviousCount OPTIONAL
    )

/*++

Routine Description:

    This function releases a mutant object.

Arguments:

    Mutant - Supplies a handle to a mutant object.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous mutant count.

Return Value:

    TBS

--*/

{

    LONG Count;
    PVOID Mutant;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous count address if
    // specified, reference the mutant object, and release the mutant object.
    // If the probe fails, then return the exception code as the service
    // status. Otherwise return the status value returned by the reference
    // object by handle routine.
    //

    try {

        //
        // Get previous processor mode and probe previous count address
        // if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if ((PreviousMode != KernelMode) && (ARGUMENT_PRESENT(PreviousCount))) {
            ProbeForWriteLong(PreviousCount);
        }

        //
        // Reference mutant object by handle.
        //
        // Note that the desired access is specified as zero since only the
        // owner can release a mutant object.
        //

        Status = ObReferenceObjectByHandle(MutantHandle,
                                           0,
                                           ExMutantObjectType,
                                           PreviousMode,
                                           &Mutant,
                                           NULL);

        //
        // If the reference was successful, then release the mutant object. If
        // an exception occurs because the caller is not the owner of the mutant
        // object, then dereference mutant object and return the exception code
        // as the service status. Otherise write the previous count value if
        // specified. If the write of the previous count fails, then do not
        // report an error. When the caller attempts to access the previous
        // count value, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            try {
                PERFINFO_DECLARE_OBJECT(Mutant);
                Count = KeReleaseMutant((PKMUTANT)Mutant, MUTANT_INCREMENT, FALSE, FALSE);
                ObDereferenceObject(Mutant);
                if (ARGUMENT_PRESENT(PreviousCount)) {
                    try {
                        *PreviousCount = Count;

                    } except(ExSystemExceptionFilter()) {
                    }
                }

            //
            // If an exception occurs because the caller is not the owner of
            // the mutant object, then always handle the exception, dereference
            // the mutant object, and return the exception code as the status
            // value.
            //

            } except(ExSystemExceptionFilter()) {
                ObDereferenceObject(Mutant);
                return GetExceptionCode();
            }
        }

    //
    // If an exception occurs during the probe of the previous count, then
    // always handle the exception and return the exception code as the status
    // value.
    //

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\probe.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation

Module Name:

    probe.c

Abstract:

    This module implements the probe for write function.

Author:

    David N. Cutler (davec) 19-Jan-1990

Environment:

    Any mode.

Revision History:

--*/

#include "exp.h"
#if defined(_WIN64)
#include <wow64t.h>
#endif

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, ProbeForWrite)
#pragma alloc_text(PAGE, ProbeForRead)
#endif


VOID
ProbeForWrite (
    IN PVOID Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for write accessibility and ensures
    correct alignment of the structure. If the structure is not accessible
    or has incorrect alignment, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/

{

    ULONG_PTR EndAddress;
    ULONG_PTR StartAddress;
#if defined(_WIN64)
    ULONG_PTR PageSize;
#else
    #define PageSize  PAGE_SIZE
#endif


    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility or alignment.
    //

    if (Length != 0) {

        //
        // If the structure is not properly aligned, then raise a data
        // misalignment exception.
        //

        ASSERT((Alignment == 1) || (Alignment == 2) ||
               (Alignment == 4) || (Alignment == 8) ||
               (Alignment == 16));

        StartAddress = (ULONG_PTR)Address;
        if ((StartAddress & (Alignment - 1)) == 0) {

            //
            // Compute the ending address of the structure and probe for
            // write accessibility.
            //

            EndAddress = StartAddress + Length - 1;
            if ((StartAddress <= EndAddress) &&
                (EndAddress < MM_USER_PROBE_ADDRESS)) {

                //
                // N.B. Only the contents of the buffer may be probed.
                //      Therefore the starting byte is probed for the
                //      first page, and then the first byte in the page
                //      for each succeeding page.
                //

#if defined(_WIN64)
                //
                // If this is a Wow64 process, then the native page is 4K, which
                // could be smaller than the native page size/
                //

                if (PsGetCurrentProcess()->Wow64Process != NULL) {
                    PageSize = PAGE_SIZE_X86NT;
                } else {
                    PageSize = PAGE_SIZE;
                }
#endif

                EndAddress = (EndAddress & ~(PageSize - 1)) + PageSize;
                do {
                    *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;

                    StartAddress = (StartAddress & ~(PageSize - 1)) + PageSize;
                } while (StartAddress != EndAddress);

                return;

            } else {
                ExRaiseAccessViolation();
            }

        } else {
            ExRaiseDatatypeMisalignment();
        }
    }

    return;
}

#undef ProbeForRead
NTKERNELAPI
VOID
NTAPI
ProbeForRead(
    IN CONST VOID *Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This function probes a structure for read accessibility and ensures
    correct alignment of the structure. If the structure is not accessible
    or has incorrect alignment, then an exception is raised.

Arguments:

    Address - Supplies a pointer to the structure to be probed.

    Length - Supplies the length of the structure.

    Alignment - Supplies the required alignment of the structure expressed
        as the number of bytes in the primitive datatype (e.g., 1 for char,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    None.

--*/
{
    PAGED_CODE();

    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||
           ((Alignment) == 4) || ((Alignment) == 8) ||
           ((Alignment) == 16));

    if ((Length) != 0) {
        if (((ULONG_PTR)(Address) & ((Alignment) - 1)) != 0) {
            ExRaiseDatatypeMisalignment();

        } else if ((((ULONG_PTR)(Address) + (Length)) < (ULONG_PTR)(Address)) ||
                   (((ULONG_PTR)(Address) + (Length)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) {
            ExRaiseAccessViolation();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\memprint.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    memprint.c

Abstract:

    This module contains the routines to implement in-memory DbgPrint.
    DbgPrint text is stored in a large circular buffer, and optionally
    written to a file and/or the debug console.  Output to file is
    buffered to allow high performance by the file system.

Author:

    David Treadwell (davidtr) 05-Oct-1990

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include <stdarg.h>
#include <string.h>
#include <memprint.h>
#undef DbgPrint

//
// Forward declarations.
//

VOID
MemPrintWriteCompleteApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
MemPrintWriteThread (
    IN PVOID Dummy
    );


//
// The maximum message size is the largest message that can be written
// by a single call to MemPrint.

#define MEM_PRINT_MAX_MESSAGE_SIZE 256

//
// These macros aid in determining the size of a subbuffer and the
// subbuffer corresponding to an index into the circular buffer.
//

#define MEM_PRINT_SUBBUFFER_SIZE (MemPrintBufferSize / MemPrintSubbufferCount)

#define GET_MEM_PRINT_SUBBUFFER(i) ((CSHORT)( (i) / MEM_PRINT_SUBBUFFER_SIZE ))

//
// The definition of the header put before each message if the
// MEM_PRINT_FLAG_HEADER bit of MemPrintFlags is turned on.
//

typedef struct _MEM_PRINT_MESSAGE_HEADER {
    USHORT Size;
    USHORT Type;
} MEM_PRINT_MESSAGE_HEADER, *PMEM_PRINT_MESSAGE_HEADER;

//
// Global data.  It is all protected by MemPrintSpinLock.
//

CLONG MemPrintBufferSize = MEM_PRINT_DEF_BUFFER_SIZE;
CLONG MemPrintSubbufferCount = MEM_PRINT_DEF_SUBBUFFER_COUNT;
PCHAR MemPrintBuffer;

ULONG MemPrintFlags = MEM_PRINT_FLAG_CONSOLE;

KSPIN_LOCK MemPrintSpinLock;

CHAR MemPrintTempBuffer[MEM_PRINT_MAX_MESSAGE_SIZE];

BOOLEAN MemPrintInitialized = FALSE;

//
// MemPrintIndex stores the current index into the circular buffer.
//

CLONG MemPrintIndex = 0;

//
// MemPrintCurrentSubbuffer stores the index of the subbuffer currently
// being used to hold data.  It has a range between 0 and
// MemPrintSubbufferCount-1.
//

CLONG MemPrintCurrentSubbuffer = 0;

//
// The MemPrintSubbufferWriting array is used to indicate when a
// subbuffer is being written to disk.  While this occurs, new data
// cannot be written to the subbuffer.
//

BOOLEAN MemPrintSubbufferWriting[MEM_PRINT_MAX_SUBBUFFER_COUNT];

//
// The MemPrintSubbufferFullEvent array is used to communicate between
// threads calling MemPrintMemory and the thread that writes the log
// file.  When a subbuffer is full and ready to be written to disk,
// the corresponding event in this array is signaled, which causes
// the write thread to wake up and perform the write.
//

KEVENT MemPrintSubbufferFullEvent[MEM_PRINT_MAX_SUBBUFFER_COUNT];


VOID
MemPrintInitialize (
    VOID
    )

/*++

Routine Description:

    This is the initialization routine for the in-memory DbgPrint routine.
    It should be called before the first call to MemPrint to set up the
    various structures used and to start the log file write thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CLONG i;
    NTSTATUS status;
    HANDLE threadHandle;

    if ( MemPrintInitialized ) {
        return;
    }

    //
    // Allocate memory for the circular buffer that will receive
    // the text and data.  If we can't do it, try again with a buffer
    // half as large.  If that fails, quit trying.
    //

    MemPrintBuffer = ExAllocatePoolWithTag( NonPagedPool, MemPrintBufferSize, 'rPeM' );

    if ( MemPrintBuffer == NULL ) {

        MemPrintBufferSize /= 2;
        DbgPrint( "Unable to allocate DbgPrint buffer--trying size = %ld\n",
                      MemPrintBufferSize );
        MemPrintBuffer = ExAllocatePoolWithTag( NonPagedPool, MemPrintBufferSize, 'rPeM' );

        if ( MemPrintBuffer == NULL ) {
            DbgPrint( "Couldn't allocate DbgPrint buffer.\n" );
            return;
        } else {
            //DbgPrint( "MemPrint buffer from %lx to %lx\n",
            //            MemPrintBuffer, MemPrintBuffer + MemPrintBufferSize );
        }

    } else {
        //DbgPrint( "MemPrint buffer from %lx to %lx\n",
        //              MemPrintBuffer, MemPrintBuffer + MemPrintBufferSize );
    }

    //
    // Allocate the spin lock that protects access to the various
    // pointers and the circular buffer.  This ensures integrity of the
    // buffer.
    //

    KeInitializeSpinLock( &MemPrintSpinLock );

    //
    // Make sure that the subbuffer count is in range.  (We assume that
    // the number is a power of 2.)
    //

    if ( MemPrintSubbufferCount < 2 ) {
        MemPrintSubbufferCount = 2;
    } else if ( MemPrintSubbufferCount > MEM_PRINT_MAX_SUBBUFFER_COUNT ) {
        MemPrintSubbufferCount = MEM_PRINT_MAX_SUBBUFFER_COUNT;
    }

    //
    // Initialize the array of BOOLEANs that determines which subbuffers
    // are being written to disk and therefore cannot be used to store
    // new DbgPrint data.
    //
    // Initialize the array of events that indicates that a subbuffer is
    // ready to be written to disk.
    //

    for ( i = 0; i < MemPrintSubbufferCount; i++ ) {
        MemPrintSubbufferWriting[i] = FALSE;
        KeInitializeEvent(
            &MemPrintSubbufferFullEvent[i],
            SynchronizationEvent,
            FALSE
            );
    }

    //
    // Start the thread that writes subbuffers from the large circular
    // buffer to disk.
    //

    status = PsCreateSystemThread(
                &threadHandle,
                PROCESS_ALL_ACCESS,
                NULL,
                NtCurrentProcess(),
                NULL,
                MemPrintWriteThread,
                NULL
                );

    if ( !NT_SUCCESS(status) ) {
        DbgPrint( "MemPrintInitialize: PsCreateSystemThread failed: %X\n",
                      status );
        return;
    }

    MemPrintInitialized = TRUE;
    ZwClose( threadHandle );

    return;

} // MemPrintInitialize


VOID
MemPrint (
    CHAR *Format, ...
    )

/*++

Routine Description:

    This routine is called in place of DbgPrint to process in-memory
    printing.

Arguments:

    Format - A format string in the style of DbgPrint.

           - formatting arguments.

Return Value:

    None.

--*/

{
    va_list arglist;
    KIRQL oldIrql;
    CLONG nextSubbuffer;
    PMEM_PRINT_MESSAGE_HEADER messageHeader;
    CHAR tempBuffer[MEM_PRINT_MAX_MESSAGE_SIZE];

    va_start(arglist, Format);
    _vsnprintf( tempBuffer, sizeof( tempBuffer ), Format, arglist );
    va_end(arglist);

    //
    // If memory DbgPrint has not been initialized, simply print to the
    // console.
    //

    if ( !MemPrintInitialized ) {

        DbgPrint( "%s", tempBuffer );
        return;
    }

    //
    // Acquire the spin lock that synchronizes access to the pointers
    // and circular buffer.
    //

    KeAcquireSpinLock( &MemPrintSpinLock, &oldIrql );

    //
    // Make sure that the request will fit.  xx_sprintf will just dump
    // all it gets, so assume the message is maximum size, and, if the
    // request would go into the next subbuffer and it is writing, fail
    // the request.
    //

    nextSubbuffer =
        GET_MEM_PRINT_SUBBUFFER( MemPrintIndex + MEM_PRINT_MAX_MESSAGE_SIZE );

    if (  nextSubbuffer != MemPrintCurrentSubbuffer ) {

        //
        // The request will go to a new subbuffer.  Check if we should
        // wrap around to the first subbuffer (i.e. start of circular
        // buffer).
        //

        if ( nextSubbuffer == MemPrintSubbufferCount ) {
            nextSubbuffer = 0;
        }

        //
        // Is that subbuffer available for use?
        //

        if ( MemPrintSubbufferWriting[nextSubbuffer] ) {

            //
            // It is in use.  Print to the console.  Oh well.
            //

            KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

            DbgPrint( "%s", tempBuffer );

            return;
        }

        //
        // If we went to subbuffer 0 and it is available to receive
        // data, set up the "end of last subbuffer" conditions and reset
        // the index into the circular buffer.  By setting a special
        // type value in the message header that precedes the garbage at
        // the end of the last subbuffer, an interpreter program can
        // know to skip over the garbage by using the size in the
        // header.  This is done instead of writing only good data so
        // that we can write just full sectors to disk, thereby
        // enhancing write performance.
        //

        if ( nextSubbuffer == 0 ) {

            //
            // Set up the message header.  This always gets done at the
            // end of the circular buffer, regardless of the flags bit.
            //

            messageHeader =
                (PMEM_PRINT_MESSAGE_HEADER)&MemPrintBuffer[MemPrintIndex];
            RtlStoreUshort(
                &messageHeader->Size,
                (USHORT)(MemPrintBufferSize - MemPrintIndex - 1)
                );
            RtlStoreUshort(
                &messageHeader->Type,
                (USHORT)0xffff
                );

            //
            // Zero out the rest of the subbuffer.
            //

            for ( MemPrintIndex += sizeof(MEM_PRINT_MESSAGE_HEADER);
                  MemPrintIndex < MemPrintBufferSize;
                  MemPrintIndex++ ) {

                MemPrintBuffer[MemPrintIndex] = 0;
            }

            //
            // Reset the index to start at the beginning of the circular
            // buffer.
            //

            MemPrintIndex = 0;
        }
    }

    //
    // Store a pointer to the location that will contain the message
    // header.
    //

    messageHeader = (PMEM_PRINT_MESSAGE_HEADER)&MemPrintBuffer[MemPrintIndex];

    if ( MemPrintFlags & MEM_PRINT_FLAG_HEADER ) {
        MemPrintIndex += sizeof(MEM_PRINT_MESSAGE_HEADER);
    }

    //
    // Dump the formatted string to the subbuffer.  xx_sprintf is a special
    // version of sprintf that takes a variable argument list.
    //

    ASSERT( MemPrintIndex + MEM_PRINT_MAX_MESSAGE_SIZE -
                sizeof(MEM_PRINT_MESSAGE_HEADER) <= MemPrintBufferSize );


    RtlCopyMemory( &MemPrintBuffer[MemPrintIndex], tempBuffer, strlen(tempBuffer)+1 );

    MemPrintIndex += strlen(tempBuffer);

    //
    // Write the total message size to the message header.
    //

    if ( MemPrintFlags & MEM_PRINT_FLAG_HEADER ) {
        messageHeader->Size =
            (USHORT)( &MemPrintBuffer[MemPrintIndex] - (PCHAR)messageHeader );
        messageHeader->Type = (USHORT)0xdead;
        messageHeader++;
    }

    //
    // If it was too large, there's a potential problem with writing off
    // the end of the circular buffer.  Print the offending message to
    // the console and breakpoint.
    //

    if ( &MemPrintBuffer[MemPrintIndex] - (PCHAR)messageHeader >
                                                MEM_PRINT_MAX_MESSAGE_SIZE ) {
        DbgPrint( "Message too long!! :\n" );
        DbgPrint( "%s", messageHeader );
        DbgBreakPoint( );
    }

    //
    // Print to the console if the appropriate flag is on.
    //

    if ( MemPrintFlags & MEM_PRINT_FLAG_CONSOLE ) {
        DbgPrint( "%s", messageHeader );
    }

    //
    // Calculate whether we have stepped into a new subbuffer.
    //

    nextSubbuffer = GET_MEM_PRINT_SUBBUFFER( MemPrintIndex );

    if ( nextSubbuffer != MemPrintCurrentSubbuffer ) {

        //DbgPrint( "Subbuffer %ld complete.\n", MemPrintCurrentSubbuffer );

        //
        // We did step into a new subbuffer, so set the boolean to
        // indicate that the old subbuffer is writing to disk, thereby
        // preventing it from being overwritten until the write is
        // complete.
        //

        MemPrintSubbufferWriting[MemPrintCurrentSubbuffer] = TRUE;

        //
        // Set the event that will wake up the thread writing subbuffers
        // to disk.
        //

        KeSetEvent(
            &MemPrintSubbufferFullEvent[MemPrintCurrentSubbuffer],
            2,
            FALSE
            );

        //
        // Update the current subbuffer.
        //

        MemPrintCurrentSubbuffer = nextSubbuffer;
    }

    KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

    return;

} // MemPrint


VOID
MemPrintFlush (
    VOID
    )

/*++

Routine Description:

    This routine causes the current subbuffer to be written to disk,
    regardless of how full it is.  The unwritten part of the subbuffer
    is zeroed before writing.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    PMEM_PRINT_MESSAGE_HEADER messageHeader;
    CLONG nextSubbufferIndex;
    LARGE_INTEGER delayInterval;

    //
    // Acquire the spin lock that protects memory DbgPrint variables.
    //

    KeAcquireSpinLock( &MemPrintSpinLock, &oldIrql );

    DbgPrint( "Flushing subbuffer %ld\n", MemPrintCurrentSubbuffer );

    //
    // Set up the header that indicates that unused space follows.
    //

    messageHeader =
        (PMEM_PRINT_MESSAGE_HEADER)&MemPrintBuffer[MemPrintIndex];
    messageHeader->Size =
        (USHORT)(MemPrintBufferSize - MemPrintIndex - 1);
    messageHeader->Type = (USHORT)0xffff;

    //
    // Determine where the next subbuffer starts.
    //

    nextSubbufferIndex =
        (MemPrintCurrentSubbuffer + 1) * MEM_PRINT_SUBBUFFER_SIZE;

    //
    // Zero out the rest of the subbuffer.
    //

    for ( MemPrintIndex += sizeof(MEM_PRINT_MESSAGE_HEADER);
          MemPrintIndex < nextSubbufferIndex;
          MemPrintIndex++ ) {

        MemPrintBuffer[MemPrintIndex] = 0;
    }

    //
    // Indicate that the subbuffer should be written to disk.
    //

    MemPrintSubbufferWriting[MemPrintCurrentSubbuffer] = TRUE;

    KeSetEvent(
        &MemPrintSubbufferFullEvent[MemPrintCurrentSubbuffer],
        8,
        FALSE
        );

    //
    // Increment the current subbuffer so that it corresponds with the
    // buffer index.
    //

    MemPrintCurrentSubbuffer++;

    KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

    //
    // Delay so that the memory print write thread wakes up and performs
    // the write to disk.
    //
    // !!! This is obviously not a perfect solution--the write thread
    //     may never wake up, so this could complete before the flush
    //     is really done.
    //

    delayInterval.QuadPart = -10*10*1000*1000;

    DbgPrint( "Delaying...\n" );
    KeDelayExecutionThread( KernelMode, TRUE, &delayInterval );
    DbgPrint( "Woke up.\n" );

    return;

} // MemPrintFlush


VOID
MemPrintWriteThread (
    IN PVOID Dummy
    )

/*++

Routine Description:

    The log file write thread executes this routine.  It sets up the
    log file for writing, then waits for subbuffers to fill, writing
    them to disk when they do.  When the log file fills, new space
    for it is allocated on disk to prevent the file system from
    having to do it.

Arguments:

    Dummy - Ignored.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock[MEM_PRINT_MAX_SUBBUFFER_COUNT];
    IO_STATUS_BLOCK localIoStatusBlock;
    CLONG i;
    KPRIORITY threadPriorityLevel;

    NTSTATUS waitStatus;
    PVOID waitObjects[64];
    KWAIT_BLOCK waitBlockArray[MEM_PRINT_MAX_SUBBUFFER_COUNT];

    OBJECT_ATTRIBUTES objectAttributes;
    PCHAR fileName = MEM_PRINT_LOG_FILE_NAME;
    ANSI_STRING fileNameString;
    HANDLE fileHandle;

    LARGE_INTEGER fileAllocation;
    LARGE_INTEGER fileAllocationIncrement;
    LARGE_INTEGER totalBytesWritten;
    LARGE_INTEGER writeSize;

    LARGE_INTEGER delayInterval;
    ULONG attempts = 0;

    UNICODE_STRING UnicodeFileName;

    Dummy;

    //
    // Initialize the string containing the file name and the object
    // attributes structure that will describe the log file to open.
    //

    RtlInitAnsiString( &fileNameString, fileName );
    status = RtlAnsiStringToUnicodeString(&UnicodeFileName,&fileNameString,TRUE);
    if ( !NT_SUCCESS(status) ) {
        NtTerminateThread( NtCurrentThread(), status );
    }

    InitializeObjectAttributes(
        &objectAttributes,
        &UnicodeFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Set the allocation size of the log file to be three times the
    // size of the circular buffer.  When it fills up, we'll extend
    // it.
    //

    fileAllocationIncrement.LowPart = MemPrintBufferSize * 8;
    fileAllocationIncrement.HighPart = 0;
    fileAllocation = fileAllocationIncrement;

    //
    // Open the log file.
    //
    // !!! The loop here is to help avoid a system initialization
    //     timing problem, and should be removed when the problem is
    //     fixed.
    //

    while ( TRUE ) {

        status = NtCreateFile(
                     &fileHandle,
                     FILE_WRITE_DATA,
                     &objectAttributes,
                     &localIoStatusBlock,
                     &fileAllocation,
                     FILE_ATTRIBUTE_NORMAL,
                     FILE_SHARE_READ,
                     FILE_OVERWRITE_IF,
                     FILE_SEQUENTIAL_ONLY,
                     NULL,
                     0L
                     );

        if ( (status != STATUS_OBJECT_PATH_NOT_FOUND) || (++attempts >= 3) ) {
            RtlFreeUnicodeString(&UnicodeFileName);
            break;
        }

        delayInterval.QuadPart = -5*10*1000*1000;    // five second delay
        KeDelayExecutionThread( KernelMode, FALSE, &delayInterval );

    }

    if ( !NT_SUCCESS(status) ) {
        DbgPrint( "NtCreateFile for log file failed: %X\n", status );
        NtTerminateThread( NtCurrentThread(), status );
    }

    //
    // Initialize the total bytes written and write size variables.
    //

    totalBytesWritten.LowPart = 0;
    totalBytesWritten.HighPart = 0;
    writeSize.LowPart = MEM_PRINT_SUBBUFFER_SIZE;
    writeSize.HighPart = 0;

    //
    // Set up the wait objects array for a call to KeWaitForMultipleObjects.
    //

    for ( i = 0; i < MemPrintSubbufferCount; i++ ) {
        waitObjects[i] = &MemPrintSubbufferFullEvent[i];
    }

    //
    // Set the priority of the write thread.
    //

    threadPriorityLevel = LOW_REALTIME_PRIORITY + 1;

    status = NtSetInformationThread(
                NtCurrentThread(),
                ThreadPriority,
                &threadPriorityLevel,
                sizeof(threadPriorityLevel)
                );

    if ( !NT_SUCCESS(status) ) {
        DbgPrint( "Unable to set error log thread priority: %X\n", status );
    }

    //
    // Loop waiting for one of the subbuffer full events to be signaled.
    // When one is signaled, wake up and write the subbuffer to the log
    // file.
    //

    while ( TRUE ) {

        waitStatus = KeWaitForMultipleObjects(
                         (CCHAR)MemPrintSubbufferCount,
                         waitObjects,
                         WaitAny,
                         Executive,
                         KernelMode,
                         TRUE,
                         NULL,
                         waitBlockArray
                         );

        if ( !NT_SUCCESS(waitStatus) ) {
            DbgPrint( "KeWaitForMultipleObjects failed: %X\n", waitStatus );
            NtTerminateThread( NtCurrentThread(), waitStatus );
        } //else {
            //DbgPrint( "Writing subbuffer %ld...\n", waitStatus );
        //}

        ASSERT( (CCHAR)waitStatus < (CCHAR)MemPrintSubbufferCount );

        //
        // Check the DbgPrint flags to see if we really want to write
        // this.
        //

        if ( (MemPrintFlags & MEM_PRINT_FLAG_FILE) == 0 ) {

            KIRQL oldIrql;

            KeAcquireSpinLock( &MemPrintSpinLock, &oldIrql );
            MemPrintSubbufferWriting[ waitStatus ] = FALSE;
            KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

            continue;
        }

        //
        // Start the write operation.  The APC routine will handle
        // checking the return status from the write and resetting
        // the MemPrintSubbufferWriting boolean.
        //

        status = NtWriteFile(
                     fileHandle,
                     NULL,
                     MemPrintWriteCompleteApc,
                     (PVOID)waitStatus,
                     &ioStatusBlock[waitStatus],
                     &MemPrintBuffer[waitStatus * MEM_PRINT_SUBBUFFER_SIZE],
                     MEM_PRINT_SUBBUFFER_SIZE,
                     &totalBytesWritten,
                     NULL
                     );

        if ( !NT_SUCCESS(status) ) {
            DbgPrint( "NtWriteFile for log file failed: %X\n", status );
        }

        //
        // Update the count of bytes written to the log file.
        //

        totalBytesWritten.QuadPart = totalBytesWritten.QuadPart + writeSize.QuadPart;

        //
        // Extend the file if we have reached the end of what we have
        // thus far allocated for the file.  This increases performance
        // by extending the file here rather than in the file system,
        // which would have to extend it each time a write past end of
        // file comes in.
        //

        if ( totalBytesWritten.QuadPart >= fileAllocation.QuadPart ) {

            fileAllocation.QuadPart =
                        fileAllocation.QuadPart + fileAllocationIncrement.QuadPart;

            DbgPrint( "Enlarging log file to %ld bytes.\n",
                          fileAllocation.LowPart );

            status = NtSetInformationFile(
                         fileHandle,
                         &localIoStatusBlock,
                         &fileAllocation,
                         sizeof(fileAllocation),
                         FileAllocationInformation
                         );

            if ( !NT_SUCCESS(status) ) {
                DbgPrint( "Attempt to extend log file failed: %X\n", status );
                fileAllocation.QuadPart =
                        fileAllocation.QuadPart - fileAllocationIncrement.QuadPart;
            }
        }
    }

    return;

} // MemPrintWriteThread


VOID
MemPrintWriteCompleteApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )

/*++

Routine Description:

    This APC routine is called when subbuffer writes to disk complete.
    It checks for success, printing a message if the write failed.
    It also sets the appropriate MemPrintSubbufferWriting location to
    FALSE so that the subbuffer can be reused.

Arguments:

    ApcContext - contains the index of the subbuffer just written.

    IoStatusBlock - the status block for the operation.

    Reserved - not used; reserved for future use.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( !NT_SUCCESS(IoStatusBlock->Status) ) {
        DbgPrint( "NtWriteFile for subbuffer %ld failed: %X\n",
                      ApcContext, IoStatusBlock->Status );
        return;
    }

    //DbgPrint( "Write complete for subbuffer %ld.\n", ApcContext );
    DbgPrint( "." );

    //
    // Acquire the spin lock that protects memory print global variables
    // and set the subbuffer writing boolean to FALSE so that other
    // threads can write to the subbuffer if necessary.
    //

    KeAcquireSpinLock( &MemPrintSpinLock, &oldIrql );
    MemPrintSubbufferWriting[ (ULONG_PTR)ApcContext ] = FALSE;
    KeReleaseSpinLock( &MemPrintSpinLock, oldIrql );

    return;

    Reserved;

} // MemPrintWriteCompleteApc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\pool.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    pool.c

Abstract:

    This module implements the NT executive pool allocator.

Author:

    Mark Lucovsky     16-Feb-1989
    Lou Perazzoli     31-Aug-1991 (change from binary buddy)
    David N. Cutler (davec) 27-May-1994
    Landy Wang        17-Oct-1997

Environment:

    Kernel mode only

Revision History:

--*/

#include "exp.h"

#pragma hdrstop

#undef ExAllocatePoolWithTag
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#undef ExAllocatePoolWithQuotaTag
#undef ExFreePool
#undef ExFreePoolWithTag

//
// These bitfield definitions are based on EX_POOL_PRIORITY in inc\ex.h.
//

#define POOL_SPECIAL_POOL_BIT               0x8
#define POOL_SPECIAL_POOL_UNDERRUN_BIT      0x1

#if defined (_WIN64)
#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((PLONGLONG)a, b)
#else
#define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd((PLONG)(a), b)
#endif


//
// Define forward referenced function prototypes.
//

#ifdef ALLOC_PRAGMA
PVOID
ExpAllocateStringRoutine (
    IN SIZE_T NumberOfBytes
    );

VOID
ExDeferredFreePool (
     IN PPOOL_DESCRIPTOR PoolDesc
     );

VOID
ExpSeedHotTags (
    VOID
    );

NTSTATUS
ExGetSessionPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnedEntries,
    IN OUT PULONG ActualEntries
    );

NTSTATUS
ExGetPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    );

#pragma alloc_text(PAGE, ExpAllocateStringRoutine)
#pragma alloc_text(INIT, InitializePool)
#pragma alloc_text(INIT, ExpSeedHotTags)
#pragma alloc_text(PAGE, ExInitializePoolDescriptor)
#pragma alloc_text(PAGE, ExDrainPoolLookasideList)
#pragma alloc_text(PAGE, ExCreatePoolTagTable)
#pragma alloc_text(PAGE, ExGetSessionPoolTagInfo)
#pragma alloc_text(PAGE, ExGetPoolTagInfo)
#pragma alloc_text(PAGEVRFY, ExAllocatePoolSanityChecks)
#pragma alloc_text(PAGEVRFY, ExFreePoolSanityChecks)
#pragma alloc_text(POOLCODE, ExAllocatePoolWithTag)
#pragma alloc_text(POOLCODE, ExFreePool)
#pragma alloc_text(POOLCODE, ExFreePoolWithTag)
#pragma alloc_text(POOLCODE, ExDeferredFreePool)
#endif

#if defined (NT_UP)
#define USING_HOT_COLD_METRICS (ExpPoolFlags & EX_SEPARATE_HOT_PAGES_DURING_BOOT)
#else
#define USING_HOT_COLD_METRICS 0
#endif

#define EXP_MAXIMUM_POOL_FREES_PENDING 32

PPOOL_DESCRIPTOR ExpSessionPoolDescriptor;
PGENERAL_LOOKASIDE ExpSessionPoolLookaside;
PPOOL_TRACKER_TABLE ExpSessionPoolTrackTable;
SIZE_T ExpSessionPoolTrackTableSize;
SIZE_T ExpSessionPoolTrackTableMask;
PPOOL_TRACKER_BIG_PAGES ExpSessionPoolBigPageTable;
SIZE_T ExpSessionPoolBigPageTableSize;
SIZE_T ExpSessionPoolBigPageTableHash;
ULONG ExpSessionPoolSmallLists;

#if DBG
ULONG ExpLargeSessionPoolUnTracked;
#endif
ULONG FirstPrint;

extern SIZE_T MmSizeOfNonPagedPoolInBytes;

#if defined (NT_UP)
KDPC ExpBootFinishedTimerDpc;
KTIMER ExpBootFinishedTimer;

VOID
ExpBootFinishedDispatch (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#else

#if defined (_WIN64)
#define MAXIMUM_PROCESSOR_TAG_TABLES    64      // Must be a power of 2.
#else
#define MAXIMUM_PROCESSOR_TAG_TABLES    32      // Must be a power of 2.
#endif

PPOOL_TRACKER_TABLE ExPoolTagTables[MAXIMUM_PROCESSOR_TAG_TABLES];

#endif

#define DEFAULT_TRACKER_TABLE 1024

PPOOL_TRACKER_TABLE PoolTrackTable;

//
// Registry-overridable, but must be a power of 2.
//

SIZE_T PoolTrackTableSize;

SIZE_T PoolTrackTableMask;

PPOOL_TRACKER_TABLE PoolTrackTableExpansion;
SIZE_T PoolTrackTableExpansionSize;
SIZE_T PoolTrackTableExpansionPages;

#define DEFAULT_BIGPAGE_TABLE 4096

PPOOL_TRACKER_BIG_PAGES PoolBigPageTable;

//
// Registry-overridable, but must be a power of 2.
//

SIZE_T PoolBigPageTableSize;   // Must be a power of 2.

SIZE_T PoolBigPageTableHash;

#define POOL_BIG_TABLE_ENTRY_FREE   0x1

ULONG PoolHitTag = 0xffffff0f;

#define POOLTAG_HASH(Key,TableMask) (((40543*((((((((PUCHAR)&Key)[0]<<2)^((PUCHAR)&Key)[1])<<2)^((PUCHAR)&Key)[2])<<2)^((PUCHAR)&Key)[3]))>>2) & (ULONG)TableMask)

VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    );

VOID
ExpInsertPoolTrackerExpansion (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    );

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    );

VOID
ExpRemovePoolTrackerExpansion (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    );

LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages,
    IN POOL_TYPE PoolType
    );

ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va,
    OUT PULONG BigPages,
    IN POOL_TYPE PoolType
    );

PVOID
ExpAllocateStringRoutine (
    IN SIZE_T NumberOfBytes
    )
{
    return ExAllocatePoolWithTag (PagedPool,NumberOfBytes,'grtS');
}

BOOLEAN
ExOkayToLockRoutine (
    IN PVOID Lock
    )
{
    UNREFERENCED_PARAMETER (Lock);

    if (KeIsExecutingDpc()) {
        return FALSE;
    }
    else {
        return TRUE;
    }
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = ExpAllocateStringRoutine;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = (PRTL_FREE_STRING_ROUTINE)ExFreePool;
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

ULONG ExPoolFailures;

//
// Define macros to pack and unpack a pool index.
//

#define ENCODE_POOL_INDEX(POOLHEADER,INDEX) {(POOLHEADER)->PoolIndex = ((UCHAR)(INDEX));}
#define DECODE_POOL_INDEX(POOLHEADER)       ((ULONG)((POOLHEADER)->PoolIndex))

//
// The allocated bit carefully overlays the unused cachealign bit in the type.
//

#define POOL_IN_USE_MASK                            0x4

#define MARK_POOL_HEADER_FREED(POOLHEADER)          {(POOLHEADER)->PoolType &= ~POOL_IN_USE_MASK;}
#define IS_POOL_HEADER_MARKED_ALLOCATED(POOLHEADER) ((POOLHEADER)->PoolType & POOL_IN_USE_MASK)

//
// The hotpage bit carefully overlays the raise bit in the type.
//

#define POOL_HOTPAGE_MASK   POOL_RAISE_IF_ALLOCATION_FAILURE

//
// Define the number of paged pools. This value may be overridden at boot
// time.
//

ULONG ExpNumberOfPagedPools = NUMBER_OF_PAGED_POOLS;

ULONG ExpNumberOfNonPagedPools = 1;

//
// The pool descriptor for nonpaged pool is static.
// The pool descriptors for paged pool are dynamically allocated
// since there can be more than one paged pool. There is always one more
// paged pool descriptor than there are paged pools. This descriptor is
// used when a page allocation is done for a paged pool and is the first
// descriptor in the paged pool descriptor array.
//

POOL_DESCRIPTOR NonPagedPoolDescriptor;

#define EXP_MAXIMUM_POOL_NODES 16

PPOOL_DESCRIPTOR ExpNonPagedPoolDescriptor[EXP_MAXIMUM_POOL_NODES];

//
// The pool vector contains an array of pointers to pool descriptors. For
// nonpaged pool this is just a pointer to the nonpaged pool descriptor.
// For paged pool, this is a pointer to an array of pool descriptors.
// The pointer to the paged pool descriptor is duplicated so
// it can be found easily by the kernel debugger.
//

PPOOL_DESCRIPTOR PoolVector[NUMBER_OF_POOLS];
PPOOL_DESCRIPTOR ExpPagedPoolDescriptor[EXP_MAXIMUM_POOL_NODES + 1];
PKGUARDED_MUTEX ExpPagedPoolMutex;

volatile ULONG ExpPoolIndex = 1;
KSPIN_LOCK ExpTaggedPoolLock;

#if DBG

LONG ExConcurrentQuotaPool;
LONG ExConcurrentQuotaPoolMax;

PSZ PoolTypeNames[MaxPoolType] = {
    "NonPaged",
    "Paged",
    "NonPagedMustSucceed",
    "NotUsed",
    "NonPagedCacheAligned",
    "PagedCacheAligned",
    "NonPagedCacheAlignedMustS"
    };

#endif //DBG


//
// Define paged and nonpaged pool lookaside descriptors.
//

GENERAL_LOOKASIDE ExpSmallNPagedPoolLookasideLists[POOL_SMALL_LISTS];

GENERAL_LOOKASIDE ExpSmallPagedPoolLookasideLists[POOL_SMALL_LISTS];



#define LOCK_POOL(PoolDesc, LockHandle) {                                   \
    if ((PoolDesc->PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {       \
        if (PoolDesc == &NonPagedPoolDescriptor) {                          \
            LockHandle.OldIrql = KeAcquireQueuedSpinLock(LockQueueNonPagedPoolLock); \
        }                                                                   \
        else {                                                              \
            ASSERT (ExpNumberOfNonPagedPools > 1);                          \
            KeAcquireInStackQueuedSpinLock (PoolDesc->LockAddress, &LockHandle); \
        }                                                                   \
    }                                                                       \
    else {                                                                  \
        KeAcquireGuardedMutex ((PKGUARDED_MUTEX)PoolDesc->LockAddress);     \
    }                                                                       \
}



#define UNLOCK_POOL(PoolDesc, LockHandle) {                                 \
    if ((PoolDesc->PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {       \
        if (PoolDesc == &NonPagedPoolDescriptor) {                          \
            KeReleaseQueuedSpinLock(LockQueueNonPagedPoolLock, LockHandle.OldIrql); \
        }                                                                   \
        else {                                                              \
            ASSERT (ExpNumberOfNonPagedPools > 1);                          \
            KeReleaseInStackQueuedSpinLock (&LockHandle);                   \
        }                                                                   \
    }                                                                       \
    else {                                                                  \
        KeReleaseGuardedMutex ((PKGUARDED_MUTEX)PoolDesc->LockAddress);     \
    }                                                                       \
}

#ifndef NO_POOL_CHECKS


//
// We redefine the LIST_ENTRY macros to have each pointer biased
// by one so any rogue code using these pointers will access
// violate.  See \nt\public\sdk\inc\ntrtl.h for the original
// definition of these macros.
//
// This is turned off in the shipping product.
//

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) & ~1))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link) |  1))

#define PrivateInitializeListHead(ListHead) (                     \
    (ListHead)->Flink = (ListHead)->Blink = EncodeLink(ListHead))

#define PrivateIsListEmpty(ListHead)              \
    (DecodeLink((ListHead)->Flink) == (ListHead))

#define PrivateRemoveHeadList(ListHead)                     \
    DecodeLink((ListHead)->Flink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Flink))}

#define PrivateRemoveTailList(ListHead)                     \
    DecodeLink((ListHead)->Blink);                          \
    {PrivateRemoveEntryList(DecodeLink((ListHead)->Blink))}

#define PrivateRemoveEntryList(Entry) {       \
    PLIST_ENTRY _EX_Blink;                    \
    PLIST_ENTRY _EX_Flink;                    \
    _EX_Flink = DecodeLink((Entry)->Flink);   \
    _EX_Blink = DecodeLink((Entry)->Blink);   \
    _EX_Blink->Flink = EncodeLink(_EX_Flink); \
    _EX_Flink->Blink = EncodeLink(_EX_Blink); \
    }

#define CHECK_LIST(LIST)                                                    \
    if ((DecodeLink(DecodeLink((LIST)->Flink)->Blink) != (LIST)) ||         \
        (DecodeLink(DecodeLink((LIST)->Blink)->Flink) != (LIST))) {         \
            KeBugCheckEx (BAD_POOL_HEADER,                                  \
                          3,                                                \
                          (ULONG_PTR)LIST,                                  \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Flink)->Blink),     \
                          (ULONG_PTR)DecodeLink(DecodeLink((LIST)->Blink)->Flink));    \
    }

#define PrivateInsertTailList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    CHECK_LIST(_EX_ListHead);                    \
    _EX_Blink = DecodeLink(_EX_ListHead->Blink); \
    (Entry)->Flink = EncodeLink(_EX_ListHead);   \
    (Entry)->Blink = EncodeLink(_EX_Blink);      \
    _EX_Blink->Flink = EncodeLink(Entry);        \
    _EX_ListHead->Blink = EncodeLink(Entry);     \
    CHECK_LIST(_EX_ListHead);                    \
    }

#define PrivateInsertHeadList(ListHead,Entry) {  \
    PLIST_ENTRY _EX_Flink;                       \
    PLIST_ENTRY _EX_ListHead;                    \
    _EX_ListHead = (ListHead);                   \
    CHECK_LIST(_EX_ListHead);                    \
    _EX_Flink = DecodeLink(_EX_ListHead->Flink); \
    (Entry)->Flink = EncodeLink(_EX_Flink);      \
    (Entry)->Blink = EncodeLink(_EX_ListHead);   \
    _EX_Flink->Blink = EncodeLink(Entry);        \
    _EX_ListHead->Flink = EncodeLink(Entry);     \
    CHECK_LIST(_EX_ListHead);                    \
    }

VOID
FORCEINLINE
ExCheckPoolHeader (
    IN PPOOL_HEADER Entry
    )
{
    PPOOL_HEADER PreviousEntry;
    PPOOL_HEADER NextEntry;

    if (Entry->PreviousSize != 0) {

        PreviousEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (PAGE_ALIGN (Entry) != PAGE_ALIGN (PreviousEntry)) {
            KeBugCheckEx (BAD_POOL_HEADER,
                          6,
                          (ULONG_PTR) PreviousEntry,
                          __LINE__,
                          (ULONG_PTR)Entry);
        }

        if ((PreviousEntry->BlockSize != Entry->PreviousSize) ||
            (DECODE_POOL_INDEX(PreviousEntry) != DECODE_POOL_INDEX(Entry))) {

            KeBugCheckEx (BAD_POOL_HEADER,
                          5,
                          (ULONG_PTR) PreviousEntry,
                          __LINE__,
                          (ULONG_PTR)Entry);
        }
    }
    else if (!PAGE_ALIGNED (Entry)) {
        KeBugCheckEx (BAD_POOL_HEADER,
                      7,
                      0,
                      __LINE__,
                      (ULONG_PTR)Entry);
    }

    if (Entry->BlockSize == 0) {
        KeBugCheckEx (BAD_POOL_HEADER,
                      8,
                      0,
                      __LINE__,
                      (ULONG_PTR)Entry);
    }

    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);

    if (!PAGE_END(NextEntry)) {

        if (PAGE_ALIGN (Entry) != PAGE_ALIGN (NextEntry)) {
            KeBugCheckEx (BAD_POOL_HEADER,
                          9,
                          (ULONG_PTR) NextEntry,
                          __LINE__,
                          (ULONG_PTR)Entry);
        }

        if ((NextEntry->PreviousSize != (Entry)->BlockSize) ||
            (DECODE_POOL_INDEX(NextEntry) != DECODE_POOL_INDEX(Entry))) {

            KeBugCheckEx (BAD_POOL_HEADER,
                          5,
                          (ULONG_PTR) NextEntry,
                          __LINE__,
                          (ULONG_PTR)Entry);
        }
    }
}

#define CHECK_POOL_HEADER(ENTRY) ExCheckPoolHeader(ENTRY)

#define ASSERT_ALLOCATE_IRQL(_PoolType, _NumberOfBytes)                 \
    if ((_PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {               \
        if (KeGetCurrentIrql() > APC_LEVEL) {                           \
            KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), _PoolType, _NumberOfBytes);                                                           \
        }                                                               \
    }                                                                   \
    else {                                                              \
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                      \
            KeBugCheckEx (BAD_POOL_CALLER, 8, KeGetCurrentIrql(), _PoolType, _NumberOfBytes);                                                           \
        }                                                               \
    }

#define ASSERT_FREE_IRQL(_PoolType, _P)                                 \
    if ((_PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {               \
        if (KeGetCurrentIrql() > APC_LEVEL) {                           \
            KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), _PoolType, (ULONG_PTR)_P);                                                            \
        }                                                               \
    }                                                                   \
    else {                                                              \
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {                      \
            KeBugCheckEx (BAD_POOL_CALLER, 9, KeGetCurrentIrql(), _PoolType, (ULONG_PTR)P);                                                             \
        }                                                               \
    }

#define ASSERT_POOL_NOT_FREE(_Entry)                                    \
    if ((_Entry->PoolType & POOL_TYPE_MASK) == 0) {                     \
        KeBugCheckEx (BAD_POOL_CALLER, 6, __LINE__, (ULONG_PTR)_Entry, _Entry->Ulong1);                                                                 \
    }

#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)                               \
    if (_Entry->PoolType == 0) {                                        \
        KeBugCheckEx(BAD_POOL_CALLER, 1, (ULONG_PTR)_Entry, (ULONG_PTR)(*(PULONG)_Entry), 0);                                                           \
    }

#define CHECK_POOL_PAGE(PAGE) \
    {                                                                         \
        PPOOL_HEADER P = (PPOOL_HEADER)PAGE_ALIGN(PAGE);                      \
        ULONG SIZE = 0;                                                       \
        LOGICAL FOUND=FALSE;                                                  \
        ASSERT (P->PreviousSize == 0);                                        \
        do {                                                                  \
            if (P == (PPOOL_HEADER)PAGE) {                                    \
                FOUND = TRUE;                                                 \
            }                                                                 \
            CHECK_POOL_HEADER(P);                                             \
            SIZE += P->BlockSize;                                             \
            P = (PPOOL_HEADER)((PPOOL_BLOCK)P + P->BlockSize);                \
        } while ((SIZE < (PAGE_SIZE / POOL_SMALLEST_BLOCK)) &&                \
                 (PAGE_END(P) == FALSE));                                     \
        if ((PAGE_END(P) == FALSE) || (FOUND == FALSE)) {                     \
            KeBugCheckEx (BAD_POOL_HEADER, 0xA, (ULONG_PTR) PAGE, __LINE__, (ULONG_PTR) P); \
        }                                                                     \
    }

#else

#define DecodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define EncodeLink(Link) ((PLIST_ENTRY)((ULONG_PTR)(Link)))
#define PrivateInitializeListHead InitializeListHead
#define PrivateIsListEmpty        IsListEmpty
#define PrivateRemoveHeadList     RemoveHeadList
#define PrivateRemoveTailList     RemoveTailList
#define PrivateRemoveEntryList    RemoveEntryList
#define PrivateInsertTailList     InsertTailList
#define PrivateInsertHeadList     InsertHeadList

#define ASSERT_ALLOCATE_IRQL(_PoolType, _P) {NOTHING;}
#define ASSERT_FREE_IRQL(_PoolType, _P)     {NOTHING;}
#define ASSERT_POOL_NOT_FREE(_Entry)        {NOTHING;}
#define ASSERT_POOL_TYPE_NOT_ZERO(_Entry)   {NOTHING;}

//
// The check list macros come in two flavors - there is one in the checked
// and free build that will bugcheck the system if a list is ill-formed, and
// there is one for the final shipping version that has all the checked
// disabled.
//
// The check lookaside list macros also comes in two flavors and is used to
// verify that the look aside lists are well formed.
//
// The check pool header macro (two flavors) verifies that the specified
// pool header matches the preceeding and succeeding pool headers.
//

#define CHECK_LIST(LIST)                        {NOTHING;}
#define CHECK_POOL_HEADER(ENTRY)                {NOTHING;}

#define CHECK_POOL_PAGE(PAGE)                   {NOTHING;}

#endif

#define EX_FREE_POOL_BACKTRACE_LENGTH 8

typedef struct _EX_FREE_POOL_TRACES {

    PETHREAD Thread;
    PVOID PoolAddress;
    POOL_HEADER PoolHeader;
    PVOID StackTrace [EX_FREE_POOL_BACKTRACE_LENGTH];

} EX_FREE_POOL_TRACES, *PEX_FREE_POOL_TRACES;

LONG ExFreePoolIndex;
LONG ExFreePoolMask = 0x4000 - 1;

PEX_FREE_POOL_TRACES ExFreePoolTraces;


VOID
ExInitializePoolDescriptor (
    IN PPOOL_DESCRIPTOR PoolDescriptor,
    IN POOL_TYPE PoolType,
    IN ULONG PoolIndex,
    IN ULONG Threshold,
    IN PVOID PoolLock
    )

/*++

Routine Description:

    This function initializes a pool descriptor.

    Note that this routine is called directly by the memory manager.

Arguments:

    PoolDescriptor - Supplies a pointer to the pool descriptor.

    PoolType - Supplies the type of the pool.

    PoolIndex - Supplies the pool descriptor index.

    Threshold - Supplies the threshold value for the specified pool.

    PoolLock - Supplies a pointer to the lock for the specified pool.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY LastListEntry;
    PPOOL_TRACKER_BIG_PAGES p;
    PPOOL_TRACKER_BIG_PAGES pend;

    //
    // Initialize statistics fields, the pool type, the threshold value,
    // and the lock address.
    //

    PoolDescriptor->PoolType = PoolType;
    PoolDescriptor->PoolIndex = PoolIndex;
    PoolDescriptor->RunningAllocs = 0;
    PoolDescriptor->RunningDeAllocs = 0;
    PoolDescriptor->TotalPages = 0;
    PoolDescriptor->TotalBytes = 0;
    PoolDescriptor->TotalBigPages = 0;
    PoolDescriptor->Threshold = Threshold;
    PoolDescriptor->LockAddress = PoolLock;

    PoolDescriptor->PendingFrees = NULL;
    PoolDescriptor->PendingFreeDepth = 0;

    //
    // Initialize the allocation listheads.
    //

    ListEntry = PoolDescriptor->ListHeads;
    LastListEntry = ListEntry + POOL_LIST_HEADS;

    while (ListEntry < LastListEntry) {
        PrivateInitializeListHead (ListEntry);
        ListEntry += 1;
    }

    if (PoolType == PagedPoolSession) {
            
        if (ExpSessionPoolDescriptor == NULL) {
            ExpSessionPoolDescriptor = (PPOOL_DESCRIPTOR) MiSessionPoolVector ();
            ExpSessionPoolLookaside = MiSessionPoolLookaside ();

            ExpSessionPoolTrackTable = (PPOOL_TRACKER_TABLE) MiSessionPoolTrackTable ();
            ExpSessionPoolTrackTableSize = MiSessionPoolTrackTableSize ();
            ExpSessionPoolTrackTableMask = ExpSessionPoolTrackTableSize - 1;

            ExpSessionPoolBigPageTable = (PPOOL_TRACKER_BIG_PAGES) MiSessionPoolBigPageTable ();
            ExpSessionPoolBigPageTableSize = MiSessionPoolBigPageTableSize ();
            ExpSessionPoolBigPageTableHash = ExpSessionPoolBigPageTableSize - 1;
            ExpSessionPoolSmallLists = MiSessionPoolSmallLists ();
        }

        p = &ExpSessionPoolBigPageTable[0];
        pend = p + ExpSessionPoolBigPageTableSize;

        while (p < pend) {
            p->Va = (PVOID) POOL_BIG_TABLE_ENTRY_FREE;
            p += 1;
        }
    }

    return;
}

PVOID
ExpDummyAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
ExDrainPoolLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function drains the entries from the specified lookaside list.

    This is needed before deleting a pool lookaside list because the
    entries on the lookaside are already marked as free (by ExFreePoolWithTag)
    and so the normal lookaside deletion macros would hit false double free
    bugchecks if the list is not empty when the macros are called.

Arguments:

    Lookaside - Supplies a pointer to a lookaside list structure.

Return Value:

    None.

--*/

{
    PVOID Entry;
    PPOOL_HEADER PoolHeader;

    //
    // Remove all pool entries from the specified lookaside structure,
    // mark them as active, then free them.
    //

    Lookaside->L.Allocate = ExpDummyAllocate;

    while ((Entry = ExAllocateFromPagedLookasideList(Lookaside)) != NULL) {

        PoolHeader = (PPOOL_HEADER)Entry - 1;

        PoolHeader->PoolType = (USHORT)(Lookaside->L.Type + 1);
        PoolHeader->PoolType |= POOL_IN_USE_MASK;

        ExpInsertPoolTracker (PoolHeader->PoolTag,
                              PoolHeader->BlockSize << POOL_BLOCK_SHIFT,
                              Lookaside->L.Type);

        //
        // Set the depth to zero every time as a periodic scan may set it
        // nonzero.  This isn't worth interlocking as the list will absolutely
        // deplete regardless in this fashion anyway.
        //

        Lookaside->L.Depth = 0;

        (Lookaside->L.Free)(Entry);
    }

    return;
}

//
// FREE_CHECK_ERESOURCE - If enabled causes each free pool to verify
// no active ERESOURCEs are in the pool block being freed.
//
// FREE_CHECK_KTIMER - If enabled causes each free pool to verify no
// active KTIMERs are in the pool block being freed.
//

//
// Checking for resources in pool being freed is expensive as there can
// easily be thousands of resources, so don't do it by default but do
// leave the capability for individual systems to enable it.
//

//
// Runtime modifications to these flags must use interlocked sequences.
//

#if DBG && !defined(_AMD64_SIMULATOR_PERF_)
ULONG ExpPoolFlags = EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS | \
                     EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS;
#else
ULONG ExpPoolFlags = 0;
#endif

#define FREE_CHECK_ERESOURCE(Va, NumberOfBytes)                             \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES) {  \
                ExpCheckForResource(Va, NumberOfBytes);                     \
            }

#define FREE_CHECK_KTIMER(Va, NumberOfBytes)                                \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS) {     \
                KeCheckForTimer(Va, NumberOfBytes);                         \
            }

#define FREE_CHECK_WORKER(Va, NumberOfBytes)                                \
            if (ExpPoolFlags & EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS) {    \
                ExpCheckForWorker(Va, NumberOfBytes);                       \
            }


VOID
ExSetPoolFlags (
    IN ULONG PoolFlag
    )

/*++

Routine Description:

    This procedure enables the specified pool flag(s).

Arguments:

    PoolFlag - Supplies the pool flag(s) to enable.

Return Value:

    None.

--*/
{
    RtlInterlockedSetBits (&ExpPoolFlags, PoolFlag);
}


VOID
InitializePool (
    IN POOL_TYPE PoolType,
    IN ULONG Threshold
    )

/*++

Routine Description:

    This procedure initializes a pool descriptor for the specified pool
    type.  Once initialized, the pool may be used for allocation and
    deallocation.

    This function should be called once for each base pool type during
    system initialization.

    Each pool descriptor contains an array of list heads for free
    blocks.  Each list head holds blocks which are a multiple of
    the POOL_BLOCK_SIZE.  The first element on the list [0] links
    together free entries of size POOL_BLOCK_SIZE, the second element
    [1] links together entries of POOL_BLOCK_SIZE * 2, the third
    POOL_BLOCK_SIZE * 3, etc, up to the number of blocks which fit
    into a page.

Arguments:

    PoolType - Supplies the type of pool being initialized (e.g.
               nonpaged pool, paged pool...).

    Threshold - Supplies the threshold value for the specified pool.

Return Value:

    None.

--*/

{
    ULONG i;
    PKSPIN_LOCK SpinLock;
    PPOOL_TRACKER_BIG_PAGES p;
    PPOOL_DESCRIPTOR Descriptor;
    ULONG Index;
    PKGUARDED_MUTEX GuardedMutex;
    SIZE_T NumberOfBytes;

    ASSERT((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) == 0);

    if (PoolType == NonPagedPool) {

        //
        // Initialize nonpaged pools.
        //
        // Ensure PoolTrackTableSize is a power of 2, then add 1 to it.
        //
        // Ensure PoolBigPageTableSize is a power of 2.
        //

        NumberOfBytes = PoolTrackTableSize;
        if (NumberOfBytes > MmSizeOfNonPagedPoolInBytes >> 8) {
            NumberOfBytes = MmSizeOfNonPagedPoolInBytes >> 8;
        }

        for (i = 0; i < 32; i += 1) {
            if (NumberOfBytes & 0x1) {
                ASSERT ((NumberOfBytes & ~0x1) == 0);
                if ((NumberOfBytes & ~0x1) == 0) {
                    break;
                }
            }
            NumberOfBytes >>= 1;
        }

        if (i == 32) {
            PoolTrackTableSize = DEFAULT_TRACKER_TABLE;
        }
        else {
            PoolTrackTableSize = 1 << i;
            if (PoolTrackTableSize < 64) {
                PoolTrackTableSize = 64;
            }
        }

        do {
            if (PoolTrackTableSize + 1 > (MAXULONG_PTR / sizeof(POOL_TRACKER_TABLE))) {
                PoolTrackTableSize >>= 1;
                continue;
            }

            PoolTrackTable = MiAllocatePoolPages (NonPagedPool,
                                                  (PoolTrackTableSize + 1) *
                                                    sizeof(POOL_TRACKER_TABLE));

            if (PoolTrackTable != NULL) {
                break;
            }

            if (PoolTrackTableSize == 1) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1);
            }

            PoolTrackTableSize >>= 1;

        } while (TRUE);

        PoolTrackTableSize += 1;
        PoolTrackTableMask = PoolTrackTableSize - 2;

#if !defined (NT_UP)
        ExPoolTagTables[0] = PoolTrackTable;
#endif

        RtlZeroMemory (PoolTrackTable,
                       PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

        ExpSeedHotTags ();

        //
        // Initialize the large allocation tag table.
        //

        NumberOfBytes = PoolBigPageTableSize;
        if (NumberOfBytes > MmSizeOfNonPagedPoolInBytes >> 8) {
            NumberOfBytes = MmSizeOfNonPagedPoolInBytes >> 8;
        }

        for (i = 0; i < 32; i += 1) {
            if (NumberOfBytes & 0x1) {
                ASSERT ((NumberOfBytes & ~0x1) == 0);
                if ((NumberOfBytes & ~0x1) == 0) {
                    break;
                }
            }
            NumberOfBytes >>= 1;
        }

        if (i == 32) {
            PoolBigPageTableSize = DEFAULT_BIGPAGE_TABLE;
        }
        else {
            PoolBigPageTableSize = 1 << i;
            if (PoolBigPageTableSize < 64) {
                PoolBigPageTableSize = 64;
            }
        }

        do {
            if (PoolBigPageTableSize > (MAXULONG_PTR / sizeof(POOL_TRACKER_BIG_PAGES))) {
                PoolBigPageTableSize >>= 1;
                continue;
            }

            PoolBigPageTable = MiAllocatePoolPages (NonPagedPool,
                                                PoolBigPageTableSize *
                                                sizeof(POOL_TRACKER_BIG_PAGES));

            if (PoolBigPageTable != NULL) {
                break;
            }

            if (PoolBigPageTableSize == 1) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1);
            }

            PoolBigPageTableSize >>= 1;

        } while (TRUE);

        PoolBigPageTableHash = PoolBigPageTableSize - 1;

        RtlZeroMemory (PoolBigPageTable,
                       PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES));

        p = &PoolBigPageTable[0];
        for (i = 0; i < PoolBigPageTableSize; i += 1, p += 1) {
            p->Va = (PVOID) POOL_BIG_TABLE_ENTRY_FREE;
        }

        ExpInsertPoolTracker ('looP',
                              ROUND_TO_PAGES(PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES)),
                              NonPagedPool);

        if (KeNumberNodes > 1) {

            ExpNumberOfNonPagedPools = KeNumberNodes;

            //
            // Limit the number of pools to the number of bits in the PoolIndex.
            //

            if (ExpNumberOfNonPagedPools > 127) {
                ExpNumberOfNonPagedPools = 127;
            }

            //
            // Further limit the number of pools by our array of pointers.
            //

            if (ExpNumberOfNonPagedPools > EXP_MAXIMUM_POOL_NODES) {
                ExpNumberOfNonPagedPools = EXP_MAXIMUM_POOL_NODES;
            }

            NumberOfBytes = sizeof(POOL_DESCRIPTOR) + sizeof(KLOCK_QUEUE_HANDLE);

            for (Index = 0; Index < ExpNumberOfNonPagedPools; Index += 1) {

                //
                // Here's a thorny problem.  We'd like to use
                // MmAllocateIndependentPages but can't because we'd need
                // system PTEs to map the pages with and PTEs are not
                // available until nonpaged pool exists.  So just use
                // regular pool pages to hold the descriptors and spinlocks
                // and hope they either a) happen to fall onto the right node 
                // or b) that these lines live in the local processor cache
                // all the time anyway due to frequent usage.
                //

                Descriptor = (PPOOL_DESCRIPTOR) MiAllocatePoolPages (
                                                         NonPagedPool,
                                                         NumberOfBytes);

                if (Descriptor == NULL) {
                    KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                                  NumberOfBytes,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1);
                }

                ExpNonPagedPoolDescriptor[Index] = Descriptor;

                SpinLock = (PKSPIN_LOCK)(Descriptor + 1);

                KeInitializeSpinLock (SpinLock);

                ExInitializePoolDescriptor (Descriptor,
                                            NonPagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID)SpinLock);
            }
        }

        //
        // Initialize the spinlocks for nonpaged pool.
        //

        KeInitializeSpinLock (&ExpTaggedPoolLock);

        //
        // Initialize the nonpaged pool descriptor.
        //

        PoolVector[NonPagedPool] = &NonPagedPoolDescriptor;
        ExInitializePoolDescriptor (&NonPagedPoolDescriptor,
                                    NonPagedPool,
                                    0,
                                    Threshold,
                                    NULL);
    }
    else {

        //
        // Allocate memory for the paged pool descriptors and fast mutexes.
        //

        if (KeNumberNodes > 1) {

            ExpNumberOfPagedPools = KeNumberNodes;

            //
            // Limit the number of pools to the number of bits in the PoolIndex.
            //

            if (ExpNumberOfPagedPools > 127) {
                ExpNumberOfPagedPools = 127;
            }
        }

        //
        // Further limit the number of pools by our array of pointers.
        //

        if (ExpNumberOfPagedPools > EXP_MAXIMUM_POOL_NODES) {
            ExpNumberOfPagedPools = EXP_MAXIMUM_POOL_NODES;
        }

        //
        // For NUMA systems, allocate both the pool descriptor and the
        // associated lock from the local node for performance (even though
        // it costs a little more memory).
        //
        // For non-NUMA systems, allocate everything together in one chunk
        // to reduce memory consumption as there is no performance cost
        // for doing it this way.
        //

        if (KeNumberNodes > 1) {

            NumberOfBytes = sizeof(KGUARDED_MUTEX) + sizeof(POOL_DESCRIPTOR);

            for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {

                ULONG Node;

                if (Index == 0) {
                    Node = 0;
                }
                else {
                    Node = Index - 1;
                }

                Descriptor = (PPOOL_DESCRIPTOR) MmAllocateIndependentPages (
                                                                      NumberOfBytes,
                                                                      Node);
                if (Descriptor == NULL) {
                    KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                                  NumberOfBytes,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1,
                                  (ULONG_PTR)-1);
                }
                ExpPagedPoolDescriptor[Index] = Descriptor;

                GuardedMutex = (PKGUARDED_MUTEX)(Descriptor + 1);

                if (Index == 0) {
                    PoolVector[PagedPool] = Descriptor;
                    ExpPagedPoolMutex = GuardedMutex;
                }

                KeInitializeGuardedMutex (GuardedMutex);

                ExInitializePoolDescriptor (Descriptor,
                                            PagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID) GuardedMutex);
            }
        }
        else {

            NumberOfBytes = (ExpNumberOfPagedPools + 1) * (sizeof(KGUARDED_MUTEX) + sizeof(POOL_DESCRIPTOR));

            Descriptor = (PPOOL_DESCRIPTOR)ExAllocatePoolWithTag (NonPagedPool,
                                                                  NumberOfBytes,
                                                                  'looP');
            if (Descriptor == NULL) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1,
                              (ULONG_PTR)-1);
            }

            GuardedMutex = (PKGUARDED_MUTEX)(Descriptor + ExpNumberOfPagedPools + 1);

            PoolVector[PagedPool] = Descriptor;
            ExpPagedPoolMutex = GuardedMutex;

            for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {
                KeInitializeGuardedMutex (GuardedMutex);
                ExpPagedPoolDescriptor[Index] = Descriptor;
                ExInitializePoolDescriptor (Descriptor,
                                            PagedPool,
                                            Index,
                                            Threshold,
                                            (PVOID) GuardedMutex);

                Descriptor += 1;
                GuardedMutex += 1;
            }
        }

        ExpInsertPoolTracker('looP',
                              ROUND_TO_PAGES(PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE)),
                             NonPagedPool);

#if defined (NT_UP)
        if (MmNumberOfPhysicalPages < 32 * 1024) {

            LARGE_INTEGER TwoMinutes;

            //
            // Set the flag to disable lookasides and use hot/cold page
            // separation during bootup.
            //

            ExSetPoolFlags (EX_SEPARATE_HOT_PAGES_DURING_BOOT);

            //
            // Start a timer so the above behavior is disabled once bootup
            // has finished.
            //

            KeInitializeTimer (&ExpBootFinishedTimer);

            KeInitializeDpc (&ExpBootFinishedTimerDpc,
                             (PKDEFERRED_ROUTINE) ExpBootFinishedDispatch,
                             NULL);

            TwoMinutes.QuadPart = Int32x32To64 (120, -10000000);

            KeSetTimer (&ExpBootFinishedTimer,
                        TwoMinutes,
                        &ExpBootFinishedTimerDpc);
        }
#endif
        if ((MmNumberOfPhysicalPages >= 127 * 1024) &&
            ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) == 0) &&
            (!NT_SUCCESS (MmIsVerifierEnabled (&i)))) {

            ExSetPoolFlags (EX_DELAY_POOL_FREES);
        }

        if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) ||
            (NT_SUCCESS (MmIsVerifierEnabled (&i)))) {

#if DBG

            //
            // Ensure ExFreePoolMask is a power of 2 minus 1 (or zero).
            //

            if (ExFreePoolMask != 0) {

                NumberOfBytes = ExFreePoolMask + 1;
                ASSERT (NumberOfBytes != 0);

                for (i = 0; i < 32; i += 1) {
                    if (NumberOfBytes & 0x1) {
                        ASSERT ((NumberOfBytes & ~0x1) == 0);
                        break;
                    }
                    NumberOfBytes >>= 1;
                }
            }

#endif

            ExFreePoolTraces = MiAllocatePoolPages (NonPagedPool,
                                                (ExFreePoolMask + 1) *
                                                sizeof (EX_FREE_POOL_TRACES));

            if (ExFreePoolTraces != NULL) {
                RtlZeroMemory (ExFreePoolTraces,
                           (ExFreePoolMask + 1) * sizeof (EX_FREE_POOL_TRACES));
            }
        }
    }
}

#if DBG
ULONG ExStopBadTags;
#endif


__forceinline
VOID
ExpInsertPoolTrackerInline (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the tag table, increments the
    number of allocates and updates the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfBytes - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held except during the rare case of expansion table growth.
    so pool may be freely allocated here as needed.  In expansion table growth,
    the tagged spinlock is held on entry, but we are guaranteed to find an
    entry in the builtin table so a recursive acquire cannot occur.

--*/

{
    ULONG Hash;
    ULONG Index;
    LONG OriginalKey;
    KIRQL OldIrql;
    PPOOL_TRACKER_TABLE TrackTable;
    PPOOL_TRACKER_TABLE TrackTableEntry;
    SIZE_T TrackTableMask;
    SIZE_T TrackTableSize;
#if !defined (NT_UP)
    ULONG Processor;
#endif

    //
    // Strip the protected pool bit.
    //

    Key &= ~PROTECTED_POOL;

    if (Key == PoolHitTag) {
        DbgBreakPoint();
    }

#if DBG
    if (ExStopBadTags) {
        ASSERT (Key & 0xFFFFFF00);
    }
#endif

    //
    // Compute the hash index and search (lock-free) for the pool tag
    // in the builtin table.
    //

    if (PoolType & SESSION_POOL_MASK) {
        TrackTable = ExpSessionPoolTrackTable;
        TrackTableMask = ExpSessionPoolTrackTableMask;
        TrackTableSize = ExpSessionPoolTrackTableSize;
    }
    else {

#if !defined (NT_UP)

        //
        // Use the current processor to pick a pool tag table to use.  Note that
        // in rare cases, this thread may context switch to another processor
        // but the algorithms below will still be correct.
        //

        Processor = KeGetCurrentProcessorNumber ();

        ASSERT (Processor < MAXIMUM_PROCESSOR_TAG_TABLES);

        TrackTable = ExPoolTagTables[Processor];

#else

        TrackTable = PoolTrackTable;

#endif

        TrackTableMask = PoolTrackTableMask;
        TrackTableSize = PoolTrackTableSize;
    }

    Hash = POOLTAG_HASH (Key, TrackTableMask);

    Index = Hash;

    do {

        TrackTableEntry = &TrackTable[Hash];

        if (TrackTableEntry->Key == Key) {

            //
            // Update the fields with interlocked operations as other
            // threads may also have begun doing so by this point.
            //

            if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
                InterlockedIncrement ((PLONG) &TrackTableEntry->PagedAllocs);
                InterlockedExchangeAddSizeT (&TrackTableEntry->PagedBytes,
                                             NumberOfBytes);
            }
            else {
                InterlockedIncrement ((PLONG) &TrackTableEntry->NonPagedAllocs);
                InterlockedExchangeAddSizeT (&TrackTableEntry->NonPagedBytes,
                                             NumberOfBytes);

            }

            return;
        }

        if (TrackTableEntry->Key == 0) {

            if (PoolType & SESSION_POOL_MASK) {

                if (Hash == TrackTableSize - 1) {
                    Hash = 0;
                    if (Hash == Index) {
                        break;
                    }
                }
                else {

                    OriginalKey = InterlockedCompareExchange ((PLONG)&TrackTable[Hash].Key,
                                                              (LONG)Key,
                                                              0);
                }

                //
                // Either this thread has won the race and the requested tag
                // is now in or some other thread won the race and took this
                // slot (using this tag or a different one).
                //
                // Just fall through to common checks starting at this slot
                // for both cases.
                //

                continue;
            }

#if !defined (NT_UP)

            if (PoolTrackTable[Hash].Key != 0) {
                TrackTableEntry->Key = PoolTrackTable[Hash].Key;
                continue;
            }

#endif

            if (Hash != PoolTrackTableSize - 1) {

                //
                // New entries cannot be created with an interlocked compare
                // exchange because any new entry must reside at the same index
                // in each processor's private PoolTrackTable.  This is to make
                // ExGetPoolTagInfo statistics gathering much simpler (faster).
                //

                ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);

                if (PoolTrackTable[Hash].Key == 0) {

                    ASSERT (TrackTable[Hash].Key == 0);

                    PoolTrackTable[Hash].Key = Key;
                    TrackTableEntry->Key = Key;
                }

                ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

                //
                // Either this thread has won the race and the requested tag
                // is now in or some other thread won the race and took this
                // slot (using this tag or a different one).
                //
                // Just fall through to common checks starting at this slot
                // for both cases.
                //

                continue;
            }
        }

        Hash = (Hash + 1) & (ULONG)TrackTableMask;

        if (Hash == Index) {
            break;
        }

    } while (TRUE);

    //
    // No matching entry and no free entry was found.
    //
    // Use the expansion table instead.
    //

    ExpInsertPoolTrackerExpansion (Key, NumberOfBytes, PoolType);
}

__forceinline
VOID
ExpRemovePoolTrackerInline (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfBytes - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

--*/

{
    ULONG Hash;
    ULONG Index;
    PPOOL_TRACKER_TABLE TrackTable;
    PPOOL_TRACKER_TABLE TrackTableEntry;
    SIZE_T TrackTableMask;
    SIZE_T TrackTableSize;
#if !defined (NT_UP)
    ULONG Processor;
#endif

    //
    // Strip protected pool bit.
    //

    Key &= ~PROTECTED_POOL;
    if (Key == PoolHitTag) {
        DbgBreakPoint ();
    }

    //
    // Compute the hash index and search (lock-free) for the pool tag
    // in the builtin table.
    //

    if (PoolType & SESSION_POOL_MASK) {
        TrackTable = ExpSessionPoolTrackTable;
        TrackTableMask = ExpSessionPoolTrackTableMask;
        TrackTableSize = ExpSessionPoolTrackTableSize;
    }
    else {

#if !defined (NT_UP)

        //
        // Use the current processor to pick a pool tag table to use.  Note that
        // in rare cases, this thread may context switch to another processor
        // but the algorithms below will still be correct.
        //

        Processor = KeGetCurrentProcessorNumber ();

        ASSERT (Processor < MAXIMUM_PROCESSOR_TAG_TABLES);

        TrackTable = ExPoolTagTables[Processor];

#else

        TrackTable = PoolTrackTable;

#endif

        TrackTableMask = PoolTrackTableMask;
        TrackTableSize = PoolTrackTableSize;
    }

    Hash = POOLTAG_HASH (Key, TrackTableMask);

    Index = Hash;

    do {
        TrackTableEntry = &TrackTable[Hash];

        if (TrackTableEntry->Key == Key) {

            if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
                InterlockedIncrement ((PLONG) &TrackTableEntry->PagedFrees);
                InterlockedExchangeAddSizeT (&TrackTableEntry->PagedBytes,
                                             0 - NumberOfBytes);
            }
            else {
                InterlockedIncrement ((PLONG) &TrackTableEntry->NonPagedFrees);
                InterlockedExchangeAddSizeT (&TrackTableEntry->NonPagedBytes,
                                             0 - NumberOfBytes);
            }
            return;
        }

        //
        // Since each processor's table is lazy updated, handle the case
        // here where this processor's table still has no entry for the tag
        // being freed because the allocation happened on a different
        // processor.
        //

        if (TrackTableEntry->Key == 0) {

#if !defined (NT_UP)

            if (((PoolType & SESSION_POOL_MASK) == 0) &&
                (PoolTrackTable[Hash].Key != 0)) {

                TrackTableEntry->Key = PoolTrackTable[Hash].Key;
                continue;
            }

#endif

            ASSERT (Hash == TrackTableMask);
        }

        Hash = (Hash + 1) & (ULONG)TrackTableMask;

        if (Hash == Index) {
            break;
        }

    } while (TRUE);

    //
    // No matching entry and no free entry was found.
    //
    // Linear search through the expansion table.  This is ok because
    // the existence of an expansion table at all is extremely rare.
    //

    ExpRemovePoolTrackerExpansion (Key, NumberOfBytes, PoolType);
}
PVOID
VeAllocatePoolWithTagPriority (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN EX_POOL_PRIORITY Priority,
    IN PVOID CallingAddress
    );


PVOID
ExAllocatePoolWithTag (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block. This function is used to
    access both the page-aligned pools and the list head entries (less
    than a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned pool
    allocator is used. The allocated block will be page-aligned and a
    page-sized multiple.

    Otherwise, the appropriate pool list entry is used. The allocated
    block will be 64-bit aligned, but will not be page aligned. The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request. If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split. One piece is placed back into the pool, and
    the other piece is used to satisfy the request. If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called. The page is split and added
    to the pool.

Arguments:

    PoolType - Supplies the type of pool to allocate. If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustSucceed

    Tag - Supplies the caller's identifying tag.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    PKGUARDED_MUTEX Lock;
    PVOID Block;
    PPOOL_HEADER Entry;
    PGENERAL_LOOKASIDE LookasideList;
    PPOOL_HEADER NextEntry;
    PPOOL_HEADER SplitEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PPOOL_DESCRIPTOR PoolDesc;
    ULONG Index;
    ULONG ListNumber;
    ULONG NeededSize;
    ULONG PoolIndex;
    POOL_TYPE CheckType;
    POOL_TYPE RequestType;
    PLIST_ENTRY ListHead;
    POOL_TYPE NewPoolType;
    PKPRCB Prcb;
    ULONG NumberOfPages;
    ULONG RetryCount;
    PVOID CallingAddress;
#if defined (_X86_)
    PVOID CallersCaller;
#endif

#define CacheOverhead POOL_OVERHEAD

    PERFINFO_EXALLOCATEPOOLWITHTAG_DECL();

    ASSERT (Tag != 0);
    ASSERT (Tag != ' GIB');
    ASSERT (NumberOfBytes != 0);
    ASSERT_ALLOCATE_IRQL (PoolType, NumberOfBytes);

    if (ExpPoolFlags & (EX_KERNEL_VERIFIER_ENABLED | EX_SPECIAL_POOL_ENABLED)) {

        if (ExpPoolFlags & EX_KERNEL_VERIFIER_ENABLED) {

            if ((PoolType & POOL_DRIVER_MASK) == 0) {

                //
                // Use the Driver Verifier pool framework.  Note this will
                // result in a recursive callback to this routine.
                //

#if defined (_X86_)
                RtlGetCallersAddress (&CallingAddress, &CallersCaller);
#else
                CallingAddress = (PVOID)_ReturnAddress();
#endif

                return VeAllocatePoolWithTagPriority (PoolType | POOL_DRIVER_MASK,
                                                  NumberOfBytes,
                                                  Tag,
                                                  HighPoolPriority,
                                                  CallingAddress);
            }
            PoolType &= ~POOL_DRIVER_MASK;
        }

        //
        // Use special pool if there is a tag or size match.
        //

        if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
            (MmUseSpecialPool (NumberOfBytes, Tag))) {

            Entry = MmAllocateSpecialPool (NumberOfBytes,
                                           Tag,
                                           PoolType,
                                           2);
            if (Entry != NULL) {
                return (PVOID)Entry;
            }
        }
    }

    //
    // Isolate the base pool type and select a pool from which to allocate
    // the specified block size.
    //

    CheckType = PoolType & BASE_POOL_TYPE_MASK;

    if ((PoolType & SESSION_POOL_MASK) == 0) {
        PoolDesc = PoolVector[CheckType];
    }
    else {
        PoolDesc = ExpSessionPoolDescriptor;
    }

    ASSERT (PoolDesc != NULL);

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    //
    // Check to determine if the requested block can be allocated from one
    // of the pool lists or must be directly allocated from virtual memory.
    //

    if (NumberOfBytes > POOL_BUDDY_MAX) {

        //
        // The requested size is greater than the largest block maintained
        // by allocation lists.
        //

        RequestType = (PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK));

        Entry = (PPOOL_HEADER) MiAllocatePoolPages (RequestType,
                                                    NumberOfBytes);

        if (Entry == NULL) {

            //
            // If there are deferred free blocks, free them now and retry.
            //

            if (ExpPoolFlags & EX_DELAY_POOL_FREES) {

                ExDeferredFreePool (PoolDesc);

                Entry = (PPOOL_HEADER) MiAllocatePoolPages (RequestType,
                                                            NumberOfBytes);
            }
        }

        if (Entry == NULL) {

            if (PoolType & MUST_SUCCEED_POOL_TYPE_MASK) {
                KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                              NumberOfBytes,
                              NonPagedPoolDescriptor.TotalPages,
                              NonPagedPoolDescriptor.TotalBigPages,
                              0);
            }

            ExPoolFailures += 1;

            if (ExpPoolFlags & EX_PRINT_POOL_FAILURES) {
                KdPrint(("EX: ExAllocatePool (%p, 0x%x) returning NULL\n",
                    NumberOfBytes,
                    PoolType));
                if (ExpPoolFlags & EX_STOP_ON_POOL_FAILURES) {
                    DbgBreakPoint ();
                }
            }

            if ((PoolType & POOL_RAISE_IF_ALLOCATION_FAILURE) != 0) {
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }

            return NULL;
        }

        NumberOfPages = (ULONG) BYTES_TO_PAGES (NumberOfBytes);

        InterlockedExchangeAdd ((PLONG)&PoolDesc->TotalBigPages,
                                (LONG)NumberOfPages);

        InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes,
                                     (SIZE_T)NumberOfPages << PAGE_SHIFT);

        InterlockedIncrement ((PLONG)&PoolDesc->RunningAllocs);

        //
        // Mark the allocation as session-based so that when it is freed
        // we can detect that the session pool descriptor is the one to
        // be credited (not the global nonpaged descriptor).
        //

        if ((PoolType & SESSION_POOL_MASK) && (CheckType == NonPagedPool)) {
            MiMarkPoolLargeSession (Entry);
        }

        //
        // Note nonpaged session allocations get turned into global
        // session allocations internally, so they must be added to the
        // global tag tables.  Paged session allocations go into their
        // own tables.
        //

        if (ExpAddTagForBigPages ((PVOID)Entry,
                                  Tag,
                                  NumberOfPages,
                                  PoolType) == FALSE) {

            //
            // Note that not being able to add the tag entry above
            // implies 2 things: The allocation must now be tagged
            // as BIG because the subsequent free also won't find it
            // in the big page tag table and so it must use BIG when
            // removing it from the PoolTrackTable.  Also that the free
            // must get the size from MiFreePoolPages since the
            // big page tag table won't have the size in this case.
            //

            Tag = ' GIB';
        }

        ExpInsertPoolTracker (Tag,
                              ROUND_TO_PAGES(NumberOfBytes),
                              PoolType);

        PERFINFO_BIGPOOLALLOC (PoolType, Tag, NumberOfBytes, Entry);

        return Entry;
    }

    if (NumberOfBytes == 0) {

        //
        // Besides fragmenting pool, zero byte requests would not be handled
        // in cases where the minimum pool block size is the same as the 
        // pool header size (no room for flink/blinks, etc).
        //

#if DBG
        KeBugCheckEx (BAD_POOL_CALLER, 0, 0, PoolType, Tag);
#else
        NumberOfBytes = 1;
#endif
    }

    //
    // The requested size is less than or equal to the size of the
    // maximum block maintained by the allocation lists.
    //

    PERFINFO_POOLALLOC (PoolType, Tag, NumberOfBytes);

    //
    // Compute the index of the listhead for blocks of the requested size.
    //

    ListNumber = (ULONG)((NumberOfBytes + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) >> POOL_BLOCK_SHIFT);

    NeededSize = ListNumber;

    if (CheckType == PagedPool) {

        //
        // If the requested pool block is a small block, then attempt to
        // allocate the requested pool from the per processor lookaside
        // list. If the attempt fails, then attempt to allocate from the
        // system lookaside list. If the attempt fails, then select a
        // pool to allocate from and allocate the block normally.
        //
        // Also note that if hot/cold separation is enabled, allocations are
        // not satisfied from lookaside lists as these are either :
        //
        // 1. cold references
        //
        // or
        //
        // 2. we are still booting on a small machine, thus keeping pool
        //    locality dense (to reduce the working set footprint thereby
        //    reducing page stealing) is a bigger win in terms of overall
        //    speed than trying to satisfy individual requests more quickly.
        //

        if ((PoolType & SESSION_POOL_MASK) == 0) {

            //
            // Check for prototype pool - always allocate it from its own
            // pages as the sharecounts applied on these allocations by
            // memory management make it more difficult to trim these pages.
            // This is an optimization so that other pagable allocation pages
            // (which are much easier to trim because their sharecount is
            // almost always only 1) don't end up being mostly resident because
            // of a single prototype pool allocation within in.  Note this
            // also makes it easier to remove specific pages for hot remove
            // or callers that need contiguous physical memory.
            //

            if (PoolType & POOL_MM_ALLOCATION) {
                PoolIndex = 0;
                ASSERT (PoolDesc->PoolIndex == 0);
                goto restart1;
            }

            if ((NeededSize <= POOL_SMALL_LISTS) &&
                (USING_HOT_COLD_METRICS == 0)) {

                Prcb = KeGetCurrentPrcb ();
                LookasideList = Prcb->PPPagedLookasideList[NeededSize - 1].P;
                LookasideList->TotalAllocates += 1;

                Entry = (PPOOL_HEADER)
                    InterlockedPopEntrySList (&LookasideList->ListHead);

                if (Entry == NULL) {
                    LookasideList = Prcb->PPPagedLookasideList[NeededSize - 1].L;
                    LookasideList->TotalAllocates += 1;

                    Entry = (PPOOL_HEADER)
                        InterlockedPopEntrySList (&LookasideList->ListHead);
                }

                if (Entry != NULL) {

                    Entry -= 1;
                    LookasideList->AllocateHits += 1;
                    NewPoolType = (PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1;
                    NewPoolType |= POOL_IN_USE_MASK;

                    Entry->PoolType = (UCHAR)NewPoolType;

                    Entry->PoolTag = Tag;

                    ExpInsertPoolTrackerInline (Tag,
                                                Entry->BlockSize << POOL_BLOCK_SHIFT,
                                                PoolType);

                    //
                    // Zero out any back pointer to our internal structures
                    // to stop someone from corrupting us via an
                    // uninitialized pointer.
                    //

                    ((PULONG_PTR)((PCHAR)Entry + CacheOverhead))[0] = 0;

                    PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);

                    return (PUCHAR)Entry + CacheOverhead;
                }
            }

            //
            // If there is more than one paged pool, then attempt to find
            // one that can be immediately locked.
            //
            //
            // N.B. The paged pool is selected in a round robin fashion using a
            //      simple counter.  Note that the counter is incremented using
            //      a a noninterlocked sequence, but the pool index is never
            //      allowed to get out of range.
            //

            if (USING_HOT_COLD_METRICS)  {

                if ((PoolType & POOL_COLD_ALLOCATION) == 0) {

                    //
                    // Hot allocations come from the first paged pool.
                    //

                    PoolIndex = 1;
                }
                else {

                    //
                    // Force cold allocations to come from
                    // the last paged pool.
                    //

                    PoolIndex = ExpNumberOfPagedPools;
                }
            }
            else {

                if (KeNumberNodes > 1) {

                    //
                    // Use the pool descriptor which contains memory
                    // local to the current processor even if we have to
                    // wait for it.  While it is possible that the
                    // paged pool addresses in the local descriptor
                    // have been paged out, on large memory
                    // NUMA machines this should be less common.
                    //

                    Prcb = KeGetCurrentPrcb ();

                    PoolIndex = Prcb->ParentNode->Color;

                    if (PoolIndex < ExpNumberOfPagedPools) {
                        PoolIndex += 1;
                        PoolDesc = ExpPagedPoolDescriptor[PoolIndex];
                        RequestType = PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK);
                        RetryCount = 0;
                        goto restart2;
                    }
                }

                PoolIndex = 1;
                if (ExpNumberOfPagedPools != PoolIndex) {
                    ExpPoolIndex += 1;
                    PoolIndex = ExpPoolIndex;
                    if (PoolIndex > ExpNumberOfPagedPools) {
                        PoolIndex = 1;
                        ExpPoolIndex = 1;
                    }

                    Index = PoolIndex;
                    do {
                        Lock = (PKGUARDED_MUTEX) ExpPagedPoolDescriptor[PoolIndex]->LockAddress;

                        if (KeGetOwnerGuardedMutex (Lock) == NULL) {
                            break;
                        }

                        PoolIndex += 1;
                        if (PoolIndex > ExpNumberOfPagedPools) {
                            PoolIndex = 1;
                        }

                    } while (PoolIndex != Index);
                }
            }

            PoolDesc = ExpPagedPoolDescriptor[PoolIndex];
        }
        else {

            if (NeededSize <= ExpSessionPoolSmallLists) {

                LookasideList = (PGENERAL_LOOKASIDE)(ULONG_PTR)(ExpSessionPoolLookaside + NeededSize - 1);
                LookasideList->TotalAllocates += 1;

                Entry = (PPOOL_HEADER)
                    InterlockedPopEntrySList (&LookasideList->ListHead);

                if (Entry != NULL) {

                    Entry -= 1;
                    LookasideList->AllocateHits += 1;
                    NewPoolType = (PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1;
                    NewPoolType |= POOL_IN_USE_MASK;

                    Entry->PoolType = (UCHAR)NewPoolType;

                    Entry->PoolTag = Tag;

                    ExpInsertPoolTrackerInline (Tag,
                                                Entry->BlockSize << POOL_BLOCK_SHIFT,
                                                PoolType);

                    //
                    // Zero out any back pointer to our internal structures
                    // to stop someone from corrupting us via an
                    // uninitialized pointer.
                    //

                    ((PULONG_PTR)((PCHAR)Entry + CacheOverhead))[0] = 0;

                    PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);

                    return (PUCHAR)Entry + CacheOverhead;
                }
            }

            //
            // Only one paged pool is available per session.
            //

            PoolIndex = 0;
            ASSERT (PoolDesc == ExpSessionPoolDescriptor);
            ASSERT (PoolDesc->PoolIndex == 0);
        }
    }
    else {

        //
        // If the requested pool block is a small block, then attempt to
        // allocate the requested pool from the per processor lookaside
        // list. If the attempt fails, then attempt to allocate from the
        // system lookaside list. If the attempt fails, then select a
        // pool to allocate from and allocate the block normally.
        //
        // Only session paged pool allocations come from the per session pools.
        // Nonpaged session pool allocations still come from global pool.
        //

        if (NeededSize <= POOL_SMALL_LISTS) {

            Prcb = KeGetCurrentPrcb ();
            LookasideList = Prcb->PPNPagedLookasideList[NeededSize - 1].P;
            LookasideList->TotalAllocates += 1;

            Entry = (PPOOL_HEADER)
                        InterlockedPopEntrySList (&LookasideList->ListHead);

            if (Entry == NULL) {
                LookasideList = Prcb->PPNPagedLookasideList[NeededSize - 1].L;
                LookasideList->TotalAllocates += 1;

                Entry = (PPOOL_HEADER)
                        InterlockedPopEntrySList (&LookasideList->ListHead);
            }

            if (Entry != NULL) {

                Entry -= 1;
                LookasideList->AllocateHits += 1;
                NewPoolType = (PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1;
                NewPoolType |= POOL_IN_USE_MASK;

                Entry->PoolType = (UCHAR)NewPoolType;

                Entry->PoolTag = Tag;

                ExpInsertPoolTrackerInline (Tag,
                                            Entry->BlockSize << POOL_BLOCK_SHIFT,
                                            PoolType);

                //
                // Zero out any back pointer to our internal structures
                // to stop someone from corrupting us via an
                // uninitialized pointer.
                //

                ((PULONG_PTR)((PCHAR)Entry + CacheOverhead))[0] = 0;

                PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);

                return (PUCHAR)Entry + CacheOverhead;
            }
        }

        if (PoolType & SESSION_POOL_MASK) {
            PoolDesc = PoolVector[CheckType];
        }

        if (ExpNumberOfNonPagedPools <= 1) {
            PoolIndex = 0;
        }
        else {

            //
            // Use the pool descriptor which contains memory local to
            // the current processor even if we have to contend for its lock.
            //

            Prcb = KeGetCurrentPrcb ();

            PoolIndex = Prcb->ParentNode->Color;

            if (PoolIndex >= ExpNumberOfNonPagedPools) {
                PoolIndex = ExpNumberOfNonPagedPools - 1;
            }

            PoolDesc = ExpNonPagedPoolDescriptor[PoolIndex];
        }

        ASSERT(PoolIndex == PoolDesc->PoolIndex);
    }

restart1:

    RequestType = PoolType & (BASE_POOL_TYPE_MASK | SESSION_POOL_MASK);
    RetryCount = 0;

restart2:

    ListHead = &PoolDesc->ListHeads[ListNumber];

    //
    // Walk the listheads looking for a free block.
    //

    do {

        //
        // If the list is not empty, then allocate a block from the
        // selected list.
        //

        if (PrivateIsListEmpty (ListHead) == FALSE) {

            LOCK_POOL (PoolDesc, LockHandle);

            if (PrivateIsListEmpty (ListHead)) {

                //
                // The block is no longer available, march on.
                //

                UNLOCK_POOL (PoolDesc, LockHandle);
                ListHead += 1;
                continue;
            }

            CHECK_LIST (ListHead);
            Block = PrivateRemoveHeadList (ListHead);
            CHECK_LIST (ListHead);
            Entry = (PPOOL_HEADER)((PCHAR)Block - POOL_OVERHEAD);

            CHECK_POOL_PAGE (Entry);

            ASSERT(Entry->BlockSize >= NeededSize);

            ASSERT(DECODE_POOL_INDEX(Entry) == PoolIndex);

            ASSERT(Entry->PoolType == 0);

            if (Entry->BlockSize != NeededSize) {

                //
                // The selected block is larger than the allocation
                // request. Split the block and insert the remaining
                // fragment in the appropriate list.
                //
                // If the entry is at the start of a page, then take
                // the allocation from the front of the block so as
                // to minimize fragmentation. Otherwise, take the
                // allocation from the end of the block which may
                // also reduce fragmentation if the block is at the
                // end of a page.
                //

                if (Entry->PreviousSize == 0) {

                    //
                    // The entry is at the start of a page.
                    //

                    SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                    SplitEntry->BlockSize = (USHORT)(Entry->BlockSize - NeededSize);
                    SplitEntry->PreviousSize = (USHORT) NeededSize;

                    //
                    // If the allocated block is not at the end of a
                    // page, then adjust the size of the next block.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)SplitEntry + SplitEntry->BlockSize);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = SplitEntry->BlockSize;
                    }

                }
                else {

                    //
                    // The entry is not at the start of a page.
                    //

                    SplitEntry = Entry;
                    Entry->BlockSize = (USHORT)(Entry->BlockSize - NeededSize);
                    Entry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
                    Entry->PreviousSize = SplitEntry->BlockSize;

                    //
                    // If the allocated block is not at the end of a
                    // page, then adjust the size of the next block.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = (USHORT) NeededSize;
                    }
                }

                //
                // Set the size of the allocated entry, clear the pool
                // type of the split entry, set the index of the split
                // entry, and insert the split entry in the appropriate
                // free list.
                //

                Entry->BlockSize = (USHORT) NeededSize;
                ENCODE_POOL_INDEX(Entry, PoolIndex);
                SplitEntry->PoolType = 0;
                ENCODE_POOL_INDEX(SplitEntry, PoolIndex);
                Index = SplitEntry->BlockSize;

                CHECK_LIST(&PoolDesc->ListHeads[Index - 1]);

                //
                // Only insert split pool blocks which contain more than just
                // a header as only those have room for a flink/blink !
                // Note if the minimum pool block size is bigger than the
                // header then there can be no blocks like this.
                //

                if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                    (SplitEntry->BlockSize != 1)) {

                    PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));

                    CHECK_LIST(((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));
                }
            }

            Entry->PoolType = (UCHAR)(((PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1) | POOL_IN_USE_MASK);

            CHECK_POOL_PAGE (Entry);

            UNLOCK_POOL(PoolDesc, LockHandle);

            InterlockedIncrement ((PLONG)&PoolDesc->RunningAllocs);

            InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes,
                                         Entry->BlockSize << POOL_BLOCK_SHIFT);

            Entry->PoolTag = Tag;

            ExpInsertPoolTrackerInline (Tag,
                                        Entry->BlockSize << POOL_BLOCK_SHIFT,
                                        PoolType);

            //
            // Zero out any back pointer to our internal structures
            // to stop someone from corrupting us via an
            // uninitialized pointer.
            //

            ((PULONGLONG)((PCHAR)Entry + CacheOverhead))[0] = 0;

            PERFINFO_POOLALLOC_ADDR((PUCHAR)Entry + CacheOverhead);
            return (PCHAR)Entry + CacheOverhead;
        }

        ListHead += 1;

    } while (ListHead != &PoolDesc->ListHeads[POOL_LIST_HEADS]);

    //
    // A block of the desired size does not exist and there are
    // no large blocks that can be split to satisfy the allocation.
    // Attempt to expand the pool by allocating another page and
    // adding it to the pool.
    //

    Entry = (PPOOL_HEADER) MiAllocatePoolPages (RequestType, PAGE_SIZE);

    if (Entry == NULL) {

        //
        // If there are deferred free blocks, free them now and retry.
        //

        RetryCount += 1;

        if ((RetryCount == 1) && (ExpPoolFlags & EX_DELAY_POOL_FREES)) {
            ExDeferredFreePool (PoolDesc);
            goto restart2;
        }

        if ((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) != 0) {

            //
            // Must succeed pool was requested so bugcheck.
            //

            KeBugCheckEx (MUST_SUCCEED_POOL_EMPTY,
                          PAGE_SIZE,
                          NonPagedPoolDescriptor.TotalPages,
                          NonPagedPoolDescriptor.TotalBigPages,
                          0);
        }

        //
        // No more pool of the specified type is available.
        //

        ExPoolFailures += 1;

        if (ExpPoolFlags & EX_PRINT_POOL_FAILURES) {
            KdPrint(("EX: ExAllocatePool (%p, 0x%x) returning NULL\n",
                NumberOfBytes,
                PoolType));
            if (ExpPoolFlags & EX_STOP_ON_POOL_FAILURES) {
                DbgBreakPoint ();
            }
        }

        if ((PoolType & POOL_RAISE_IF_ALLOCATION_FAILURE) != 0) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }

        PERFINFO_POOLALLOC_ADDR (NULL);
        return NULL;
    }

    //
    // Initialize the pool header for the new allocation.
    //

    Entry->Ulong1 = 0;
    Entry->PoolIndex = (UCHAR) PoolIndex;
    Entry->BlockSize = (USHORT) NeededSize;

    Entry->PoolType = (UCHAR)(((PoolType & (BASE_POOL_TYPE_MASK | POOL_QUOTA_MASK | SESSION_POOL_MASK | POOL_VERIFIER_MASK)) + 1) | POOL_IN_USE_MASK);


    SplitEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + NeededSize);

    SplitEntry->Ulong1 = 0;

    Index = (PAGE_SIZE / sizeof(POOL_BLOCK)) - NeededSize;

    SplitEntry->BlockSize = (USHORT) Index;
    SplitEntry->PreviousSize = (USHORT) NeededSize;
    SplitEntry->PoolIndex = (UCHAR) PoolIndex;

    //
    // Split the allocated page and insert the remaining
    // fragment in the appropriate listhead.
    //
    // Set the size of the allocated entry, clear the pool
    // type of the split entry, set the index of the split
    // entry, and insert the split entry in the appropriate
    // free list.
    //

    //
    // Note that if the request was for nonpaged session pool, we are
    // not updating the session pool descriptor for this.  Instead we
    // are deliberately updating the global nonpaged pool descriptor
    // because the rest of the fragment goes into global nonpaged pool.
    // This is ok because the session pool descriptor TotalPages count
    // is not relied upon.
    //
    // The individual pool tracking by tag, however, is critical and
    // is properly maintained below (ie: session allocations are charged
    // to the session tracking table and regular nonpaged allocations are
    // charged to the global nonpaged tracking table).
    //

    InterlockedIncrement ((PLONG)&PoolDesc->TotalPages);

    NeededSize <<= POOL_BLOCK_SHIFT;

    InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes, NeededSize);

    PERFINFO_ADDPOOLPAGE(CheckType, PoolIndex, Entry, PoolDesc);

    //
    // Only insert split pool blocks which contain more than just
    // a header as only those have room for a flink/blink !
    // Note if the minimum pool block size is bigger than the
    // header then there can be no blocks like this.
    //

    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
        (SplitEntry->BlockSize != 1)) {

        //
        // Now lock the pool and insert the fragment.
        //

        LOCK_POOL (PoolDesc, LockHandle);

        CHECK_LIST(&PoolDesc->ListHeads[Index - 1]);

        PrivateInsertTailList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));

        CHECK_LIST(((PLIST_ENTRY)((PCHAR)SplitEntry + POOL_OVERHEAD)));

        CHECK_POOL_PAGE (Entry);

        UNLOCK_POOL (PoolDesc, LockHandle);
    }
    else {
        CHECK_POOL_PAGE (Entry);
    }

    InterlockedIncrement ((PLONG)&PoolDesc->RunningAllocs);

    Block = (PVOID) ((PCHAR)Entry + CacheOverhead);

    Entry->PoolTag = Tag;

    ExpInsertPoolTrackerInline (Tag, NeededSize, PoolType);

    PERFINFO_POOLALLOC_ADDR (Block);

    return Block;
}


PVOID
ExAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustS

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    return ExAllocatePoolWithTag (PoolType,
                                  NumberOfBytes,
                                  'enoN');
}


PVOID
ExAllocatePoolWithTagPriority (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN EX_POOL_PRIORITY Priority
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type and
    returns a pointer to the allocated block.  This function is used to
    access both the page-aligned pools, and the list head entries (less than
    a page) pools.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate list, then the page-aligned
    pool allocator is used.  The allocated block will be page-aligned
    and a page-sized multiple.

    Otherwise, the appropriate pool list entry is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  The
    pool allocator calculates the smallest number of POOL_BLOCK_SIZE
    that can be used to satisfy the request.  If there are no blocks
    available of this size, then a block of the next larger block size
    is allocated and split.  One piece is placed back into the pool, and
    the other piece is used to satisfy the request.  If the allocator
    reaches the paged-sized block list, and nothing is there, the
    page-aligned pool allocator is called.  The page is split and added
    to the pool...

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types, then this call will
        succeed and return a pointer to allocated pool or bugcheck on failure.
        For all other cases, if the system cannot allocate the requested amount
        of memory, NULL is returned.

        Valid pool types:

        NonPagedPool
        PagedPool
        NonPagedPoolMustSucceed,
        NonPagedPoolCacheAligned
        PagedPoolCacheAligned
        NonPagedPoolCacheAlignedMustS

    NumberOfBytes - Supplies the number of bytes to allocate.

    Tag - Supplies the caller's identifying tag.

    Priority - Supplies an indication as to how important it is that this
               request succeed under low available pool conditions.  This
               can also be used to specify special pool.

Return Value:

    NULL - The PoolType is not one of the "MustSucceed" pool types, and
           not enough pool exists to satisfy the request.

    NON-NULL - Returns a pointer to the allocated pool.

--*/

{
    ULONG i;
    ULONG Ratio;
    PVOID Entry;
    SIZE_T TotalBytes;
    SIZE_T TotalFullPages;
    POOL_TYPE CheckType;
    PPOOL_DESCRIPTOR PoolDesc;

    if ((Priority & POOL_SPECIAL_POOL_BIT) && (NumberOfBytes <= POOL_BUDDY_MAX)) {
        Entry = MmAllocateSpecialPool (NumberOfBytes,
                                       Tag,
                                       PoolType,
                                       (Priority & POOL_SPECIAL_POOL_UNDERRUN_BIT) ? 1 : 0);

        if (Entry != NULL) {
            return Entry;
        }
        Priority &= ~(POOL_SPECIAL_POOL_BIT | POOL_SPECIAL_POOL_UNDERRUN_BIT);
    }

    //
    // Pool and other resources can be allocated directly through the Mm
    // without the pool code knowing - so always call the Mm for the
    // up-to-date counters.
    //

    if ((Priority != HighPoolPriority) &&
        ((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) == 0)) {

        if (MmResourcesAvailable (PoolType, NumberOfBytes, Priority) == FALSE) {

            //
            // The Mm does not have very many full pages left.  Leave those
            // for true high priority callers.  But first see if this request
            // is small, and if so, if there is a lot of fragmentation, then
            // it is likely the request can be satisfied from pre-existing
            // fragments.
            //

            if (NumberOfBytes > POOL_BUDDY_MAX) {
                return NULL;
            }

            //
            // Sum the pool descriptors.
            //

            CheckType = PoolType & BASE_POOL_TYPE_MASK;

            if ((CheckType == NonPagedPool) ||
                ((PoolType & SESSION_POOL_MASK) == 0)) {

                PoolDesc = PoolVector[CheckType];

                TotalBytes = 0;
                TotalFullPages = 0;

                if (CheckType == PagedPool) {

                    if (KeNumberNodes > 1) {
                        for (i = 0; i <= ExpNumberOfPagedPools; i += 1) {
                            PoolDesc = ExpPagedPoolDescriptor[i];
                            TotalFullPages += PoolDesc->TotalPages;
                            TotalFullPages += PoolDesc->TotalBigPages;
                            TotalBytes += PoolDesc->TotalBytes;
                        }
                    }
                    else {
                        for (i = 0; i <= ExpNumberOfPagedPools; i += 1) {
                            TotalFullPages += PoolDesc->TotalPages;
                            TotalFullPages += PoolDesc->TotalBigPages;
                            TotalBytes += PoolDesc->TotalBytes;
                            PoolDesc += 1;
                        }
                    }
                }
                else {
                    if (ExpNumberOfNonPagedPools == 1) {
                        TotalFullPages += PoolDesc->TotalPages;
                        TotalFullPages += PoolDesc->TotalBigPages;
                        TotalBytes += PoolDesc->TotalBytes;
                    }
                    else {
                        for (i = 0; i < ExpNumberOfNonPagedPools; i += 1) {
                            PoolDesc = ExpNonPagedPoolDescriptor[i];
                            TotalFullPages += PoolDesc->TotalPages;
                            TotalFullPages += PoolDesc->TotalBigPages;
                            TotalBytes += PoolDesc->TotalBytes;
                        }
                    }
                }
            }
            else {
                PoolDesc = ExpSessionPoolDescriptor;
                TotalFullPages = PoolDesc->TotalPages;
                TotalFullPages += PoolDesc->TotalBigPages;
                TotalBytes = PoolDesc->TotalBytes;
            }

            //
            // If the pages are more than 80% populated then don't assume
            // we're going to be able to satisfy ths request via a fragment.
            //

            TotalFullPages |= 1;        // Ensure we never divide by zero.
            TotalBytes >>= PAGE_SHIFT;

            //
            // The additions above were performed lock free so we must handle
            // slicing which can cause nonexact sums.
            //

            if (TotalBytes > TotalFullPages) {
                TotalBytes = TotalFullPages;
            }

            Ratio = (ULONG)((TotalBytes * 100) / TotalFullPages);

            if (Ratio >= 80) {
                return NULL;
            }
        }
    }

    //
    // There is a window between determining whether to proceed and actually
    // doing the allocation.  In this window the pool may deplete.  This is not
    // worth closing at this time.
    //

    return ExAllocatePoolWithTag (PoolType, NumberOfBytes, Tag);
}


PVOID
ExAllocatePoolWithQuota (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type,
    returns a pointer to the allocated block, and if the binary buddy
    allocator was used to satisfy the request, charges pool quota to the
    current process.  This function is used to access both the
    page-aligned pools, and the binary buddy.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate binary buddy pool, then the
    page-aligned pool allocator is used.  The allocated block will be
    page-aligned and a page-sized multiple.  No quota is charged to the
    current process if this is the case.

    Otherwise, the appropriate binary buddy pool is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  After
    the allocation completes, an attempt will be made to charge pool
    quota (of the appropriate type) to the current process object.  If
    the quota charge succeeds, then the pool block's header is adjusted
    to point to the current process.  The process object is not
    dereferenced until the pool is deallocated and the appropriate
    amount of quota is returned to the process.  Otherwise, the pool is
    deallocated, a "quota exceeded" condition is raised.

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types and sufficient quota
        exists, then this call will always succeed and return a pointer
        to allocated pool.  Otherwise, if the system cannot allocate
        the requested amount of memory a STATUS_INSUFFICIENT_RESOURCES
        status is raised.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NON-NULL - Returns a pointer to the allocated pool.

    Unspecified - If insufficient quota exists to complete the pool
        allocation, the return value is unspecified.

--*/

{
    return ExAllocatePoolWithQuotaTag (PoolType, NumberOfBytes, 'enoN');
}

//
// The following assert macro is used to check that an input process object is
// really a PROCESS and not something else, like deallocated pool.
//

#define ASSERT_KPROCESS(P) {                                    \
    ASSERT(((PKPROCESS)(P))->Header.Type == ProcessObject);     \
}

__forceinline
PEPROCESS
ExpGetBilledProcess (
    IN PPOOL_HEADER Entry
    )
{
    PEPROCESS ProcessBilled;

    if ((Entry->PoolType & POOL_QUOTA_MASK) == 0) {
        return NULL;
    }

#if defined(_WIN64)
    ProcessBilled = Entry->ProcessBilled;
#else
    ProcessBilled =  * (PVOID *)((PCHAR)Entry + (Entry->BlockSize << POOL_BLOCK_SHIFT) - sizeof (PVOID));
#endif

    if (ProcessBilled != NULL) {
        if (((PKPROCESS)(ProcessBilled))->Header.Type != ProcessObject) {
            KeBugCheckEx (BAD_POOL_CALLER,
                          0xD,
                          (ULONG_PTR)(Entry + 1),
                          Entry->PoolTag,
                          (ULONG_PTR)ProcessBilled);
        }
    }

    return ProcessBilled;
}

PVOID
ExAllocatePoolWithQuotaTag (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This function allocates a block of pool of the specified type,
    returns a pointer to the allocated block, and if the binary buddy
    allocator was used to satisfy the request, charges pool quota to the
    current process.  This function is used to access both the
    page-aligned pools, and the binary buddy.

    If the number of bytes specifies a size that is too large to be
    satisfied by the appropriate binary buddy pool, then the
    page-aligned pool allocator is used.  The allocated block will be
    page-aligned and a page-sized multiple.  No quota is charged to the
    current process if this is the case.

    Otherwise, the appropriate binary buddy pool is used.  The allocated
    block will be 64-bit aligned, but will not be page aligned.  After
    the allocation completes, an attempt will be made to charge pool
    quota (of the appropriate type) to the current process object.  If
    the quota charge succeeds, then the pool block's header is adjusted
    to point to the current process.  The process object is not
    dereferenced until the pool is deallocated and the appropriate
    amount of quota is returned to the process.  Otherwise, the pool is
    deallocated, a "quota exceeded" condition is raised.

Arguments:

    PoolType - Supplies the type of pool to allocate.  If the pool type
        is one of the "MustSucceed" pool types and sufficient quota
        exists, then this call will always succeed and return a pointer
        to allocated pool.  Otherwise, if the system cannot allocate
        the requested amount of memory a STATUS_INSUFFICIENT_RESOURCES
        status is raised.

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NON-NULL - Returns a pointer to the allocated pool.

    Unspecified - If insufficient quota exists to complete the pool
        allocation, the return value is unspecified.

--*/

{
    PVOID p;
    PEPROCESS Process;
    PPOOL_HEADER Entry;
    LOGICAL RaiseOnQuotaFailure;
    NTSTATUS Status;
#if DBG
    LONG ConcurrentQuotaPool;
#endif

    RaiseOnQuotaFailure = TRUE;

    if (PoolType & POOL_QUOTA_FAIL_INSTEAD_OF_RAISE) {
        RaiseOnQuotaFailure = FALSE;
        PoolType &= ~POOL_QUOTA_FAIL_INSTEAD_OF_RAISE;
    }

    PoolType = (POOL_TYPE)((UCHAR)PoolType + POOL_QUOTA_MASK);

    Process = PsGetCurrentProcess ();

#if !defined(_WIN64)

    //
    // Add in room for the quota pointer at the end of the caller's allocation.
    // Note for NT64, there is room in the pool header for both the tag and
    // the quota pointer so no extra space is needed at the end.
    //
    // Only add in the quota pointer if doing so won't cause us to spill the
    // allocation into a full page.
    //

    ASSERT (NumberOfBytes != 0);

    if (NumberOfBytes <= PAGE_SIZE - POOL_OVERHEAD - sizeof (PVOID)) {
        if (Process != PsInitialSystemProcess) {
            NumberOfBytes += sizeof (PVOID);
        }
        else {
            PoolType = (POOL_TYPE)((UCHAR)PoolType - POOL_QUOTA_MASK);
        }
    }
    else {

        //
        // Turn off the quota bit prior to allocating if we're not charging
        // as there's no room to put (or subsequently query for) a quota
        // pointer.
        //

        PoolType = (POOL_TYPE)((UCHAR)PoolType - POOL_QUOTA_MASK);
    }

#endif

    p = ExAllocatePoolWithTag (PoolType, NumberOfBytes, Tag);

    //
    // Note - NULL is page aligned.
    //

    if (!PAGE_ALIGNED(p)) {

        if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
            (MmIsSpecialPoolAddress (p))) {
            return p;
        }

        Entry = (PPOOL_HEADER)((PCH)p - POOL_OVERHEAD);

#if defined(_WIN64)
        Entry->ProcessBilled = NULL;
#endif

        if (Process != PsInitialSystemProcess) {

            Status = PsChargeProcessPoolQuota (Process,
                                 PoolType & BASE_POOL_TYPE_MASK,
                                 (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));


            if (!NT_SUCCESS(Status)) {

                //
                // Back out the allocation.
                //

#if !defined(_WIN64)
                //
                // The quota flag cannot be blindly cleared in NT32 because
                // it's used to denote the allocation is larger (and the
                // verifier finds its own header based on this).
                //
                // Instead of clearing the flag above, instead zero the quota
                // pointer.
                //

                * (PVOID *)((PCHAR)Entry + (Entry->BlockSize << POOL_BLOCK_SHIFT) - sizeof (PVOID)) = NULL;
#endif

                ExFreePoolWithTag (p, Tag);

                if (RaiseOnQuotaFailure) {
                    ExRaiseStatus (Status);
                }
                return NULL;
            }

#if DBG
            ConcurrentQuotaPool = InterlockedIncrement (&ExConcurrentQuotaPool);
            if (ConcurrentQuotaPool > ExConcurrentQuotaPoolMax) {
                ExConcurrentQuotaPoolMax = ConcurrentQuotaPool;
            }
#endif

#if defined(_WIN64)
            Entry->ProcessBilled = Process;
#else

            if ((UCHAR)PoolType & POOL_QUOTA_MASK) {
                * (PVOID *)((PCHAR)Entry + (Entry->BlockSize << POOL_BLOCK_SHIFT) - sizeof (PVOID)) = Process;
            }

#endif

            ObReferenceObject (Process);
        }
    }
    else {
        if ((p == NULL) && (RaiseOnQuotaFailure)) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return p;
}

VOID
ExInsertPoolTag (
    ULONG Tag,
    PVOID Va,
    SIZE_T NumberOfBytes,
    POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the tag table and increments the
    number of allocates and updates the total allocation size.

    This function also inserts the pool tag in the big page tag table.

    N.B. This function is for use by memory management ONLY.

Arguments:

    Tag - Supplies the tag used to insert an entry in the tag table.

    Va - Supplies the allocated virtual address.

    NumberOfBytes - Supplies the allocation size in bytes.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

--*/

{
    ULONG NumberOfPages;

#if !DBG
    UNREFERENCED_PARAMETER (PoolType);
#endif

    ASSERT ((PoolType & SESSION_POOL_MASK) == 0);

    if (NumberOfBytes >= PAGE_SIZE) {

        NumberOfPages = (ULONG) BYTES_TO_PAGES (NumberOfBytes);

        if (ExpAddTagForBigPages((PVOID)Va, Tag, NumberOfPages, PoolType) == FALSE) {
            Tag = ' GIB';
        }
    }

    ExpInsertPoolTracker (Tag, NumberOfBytes, NonPagedPool);
}

VOID
ExpSeedHotTags (
    VOID
    )

/*++

Routine Description:

    This function seeds well-known hot tags into the pool tag tracking table
    when the table is first created.  The goal is to increase the likelihood
    that the hash generated for these tags always gets a direct hit.

Arguments:

    None.

Return Value:

    None.

Environment:

    INIT time, no locks held.

--*/

{
    ULONG i;
    ULONG Key;
    ULONG Hash;
    ULONG Index;
    PPOOL_TRACKER_TABLE TrackTable;

    ULONG KeyList[] = {
            '  oI',
            ' laH',
            'PldM',
            'LooP',
            'tSbO',
            ' prI',
            'bdDN',
            'LprI',
            'pOoI',
            ' ldM',
            'eliF',
            'aVMC',
            'dSeS',
            'CFtN',
            'looP',
            'rPCT',
            'bNMC',
            'dTeS',
            'sFtN',
            'TPCT',
            'CPCT',
            ' yeK',
            'qSbO',
            'mNoI',
            'aEoI',
            'cPCT',
            'aFtN',
            '0ftN',
            'tceS',
            'SprI',
            'ekoT',
            '  eS',
            'lCbO',
            'cScC',
            'lFtN',
            'cAeS',
            'mfSF',
            'kWcC',
            'miSF',
            'CdfA',
            'EdfA',
            'orSF',
            'nftN',
            'PRIU',

            'rFpN',
            'RFpN',
            'aPeS',
            'sUeS',
            'FpcA',
            'MpcA',
            'cSeS',
            'mNbO',
            'sFpN',
            'uLeS',
            'DPcS',
            'nevE',
            'vrqR',
            'ldaV',
            '  pP',
            'SdaV',
            ' daV',
            'LdaV',
            'FdaV',

            //
            // BIG is preseeded not because it is hot, but because allocations
            // with this tag must be inserted successfully (ie: cannot be
            // retagged into the Ovfl bucket) because we need a tag to account
            // for them in the PoolTrackTable counting when freeing the pool.
            //

            ' GIB',
    };

    TrackTable = PoolTrackTable;

    for (i = 0; i < sizeof (KeyList) / sizeof (ULONG); i += 1) {

        Key = KeyList[i];

        Hash = POOLTAG_HASH(Key,PoolTrackTableMask);

        Index = Hash;

        do {

            ASSERT (TrackTable[Hash].Key != Key);

            if ((TrackTable[Hash].Key == 0) &&
                (Hash != PoolTrackTableSize - 1)) {

                TrackTable[Hash].Key = Key;
                break;
            }

            ASSERT (TrackTable[Hash].Key != Key);

            Hash = (Hash + 1) & (ULONG)PoolTrackTableMask;

            if (Hash == Index) {
                break;
            }

        } while (TRUE);
    }
}


VOID
ExpInsertPoolTrackerExpansion (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the expansion tag table (taking a
    spinlock to do so), increments the number of allocates and updates
    the total allocation size.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfBytes - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

Environment:

    No pool locks held so pool may be freely allocated here as needed.

    This routine is only called if ExpInsertPoolTracker encounters a full
    builtin list.

--*/

{
    ULONG Hash;
    KIRQL OldIrql;
    ULONG BigPages;
    SIZE_T NewSize;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    PPOOL_TRACKER_TABLE OldTable;
    PPOOL_TRACKER_TABLE NewTable;

    //
    // The protected pool bit has already been stripped.
    //

    ASSERT ((Key & PROTECTED_POOL) == 0);

    if (PoolType & SESSION_POOL_MASK) {

        //
        // Use the very last entry as a bit bucket for overflows.
        //

        NewTable = ExpSessionPoolTrackTable + ExpSessionPoolTrackTableSize - 1;

        ASSERT ((NewTable->Key == 0) || (NewTable->Key == 'lfvO'));

        NewTable->Key = 'lfvO';

        //
        // Update the fields with interlocked operations as other
        // threads may also have begun doing so by this point.
        //

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            InterlockedIncrement ((PLONG) &NewTable->PagedAllocs);
            InterlockedExchangeAddSizeT (&NewTable->PagedBytes,
                                         NumberOfBytes);
        }
        else {
            InterlockedIncrement ((PLONG) &NewTable->NonPagedAllocs);
            InterlockedExchangeAddSizeT (&NewTable->NonPagedBytes,
                                         NumberOfBytes);
        }
        return;
    }

    //
    // Linear search through the expansion table.  This is ok because
    // the case of no free entries in the built-in table is extremely rare.
    //

    ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);

    for (Hash = 0; Hash < PoolTrackTableExpansionSize; Hash += 1) {

        if (PoolTrackTableExpansion[Hash].Key == Key) {
            break;
        }

        if (PoolTrackTableExpansion[Hash].Key == 0) {
            ASSERT (PoolTrackTable[PoolTrackTableSize - 1].Key == 0);
            PoolTrackTableExpansion[Hash].Key = Key;
            break;
        }
    }

    if (Hash != PoolTrackTableExpansionSize) {

        //
        // The entry was found (or created).  Update the other fields now.
        //

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            PoolTrackTableExpansion[Hash].PagedAllocs += 1;
            PoolTrackTableExpansion[Hash].PagedBytes += NumberOfBytes;
        }
        else {
            PoolTrackTableExpansion[Hash].NonPagedAllocs += 1;
            PoolTrackTableExpansion[Hash].NonPagedBytes += NumberOfBytes;
        }

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);
        return;
    }

    //
    // The entry was not found and the expansion table is full (or nonexistent).
    // Try to allocate a larger expansion table now.
    //

    if (PoolTrackTable[PoolTrackTableSize - 1].Key != 0) {

        //
        // The overflow bucket has been used so expansion of the tracker table
        // is not allowed because a subsequent free of a tag can go negative
        // as the original allocation is in overflow and a newer allocation
        // may be distinct.
        //

        //
        // Use the very last entry as a bit bucket for overflows.
        //

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

        Hash = (ULONG)PoolTrackTableSize - 1;

        //
        // Update the fields with interlocked operations as other
        // threads may also have begun doing so by this point.
        //

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            InterlockedIncrement ((PLONG) &PoolTrackTable[Hash].PagedAllocs);
            InterlockedExchangeAddSizeT (&PoolTrackTable[Hash].PagedBytes,
                                         NumberOfBytes);
        }
        else {
            InterlockedIncrement ((PLONG) &PoolTrackTable[Hash].NonPagedAllocs);
            InterlockedExchangeAddSizeT (&PoolTrackTable[Hash].NonPagedBytes,
                                         NumberOfBytes);

        }

        return;
    }

    SizeInBytes = PoolTrackTableExpansionSize * sizeof(POOL_TRACKER_TABLE);

    //
    // Use as much of the slush in the final page as possible.
    //

    NewSizeInBytes = (PoolTrackTableExpansionPages + 1) << PAGE_SHIFT;
    NewSize = NewSizeInBytes / sizeof (POOL_TRACKER_TABLE);
    NewSizeInBytes = NewSize * sizeof(POOL_TRACKER_TABLE);

    NewTable = MiAllocatePoolPages (NonPagedPool, NewSizeInBytes);

    if (NewTable != NULL) {

        if (PoolTrackTableExpansion != NULL) {

            //
            // Copy all the existing entries into the new table.
            //

            RtlCopyMemory (NewTable,
                           PoolTrackTableExpansion,
                           SizeInBytes);
        }

        RtlZeroMemory ((PVOID)(NewTable + PoolTrackTableExpansionSize),
                       NewSizeInBytes - SizeInBytes);

        OldTable = PoolTrackTableExpansion;

        PoolTrackTableExpansion = NewTable;
        PoolTrackTableExpansionSize = NewSize;
        PoolTrackTableExpansionPages += 1;

        //
        // Recursively call ourself to insert the new table entry.  This entry
        // must be inserted before releasing the tagged spinlock because
        // another thread may be further growing the table and as soon as we
        // release the spinlock, that thread may grow and try to free our
        // new table !
        //

        ExpInsertPoolTracker ('looP',
                              PoolTrackTableExpansionPages << PAGE_SHIFT,
                              NonPagedPool);

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

        //
        // Free the old table if there was one.
        //

        if (OldTable != NULL) {

            BigPages = MiFreePoolPages (OldTable);

            ExpRemovePoolTracker ('looP',
                                  (SIZE_T) BigPages * PAGE_SIZE,
                                  NonPagedPool);
        }

        //
        // Finally insert the caller's original allocation.
        //

        ExpInsertPoolTrackerExpansion (Key, NumberOfBytes, PoolType);
    }
    else {

        //
        // Use the very last entry as a bit bucket for overflows.
        //

        Hash = (ULONG)PoolTrackTableSize - 1;

        ASSERT (PoolTrackTable[Hash].Key == 0);

        PoolTrackTable[Hash].Key = 'lfvO';

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

        //
        // Update the fields with interlocked operations as other
        // threads may also have begun doing so by this point.
        //

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            InterlockedIncrement ((PLONG) &PoolTrackTable[Hash].PagedAllocs);
            InterlockedExchangeAddSizeT (&PoolTrackTable[Hash].PagedBytes,
                                         NumberOfBytes);
        }
        else {
            InterlockedIncrement ((PLONG) &PoolTrackTable[Hash].NonPagedAllocs);
            InterlockedExchangeAddSizeT (&PoolTrackTable[Hash].NonPagedBytes,
                                         NumberOfBytes);
        }
    }

    return;
}
VOID
ExpInsertPoolTracker (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )
{
    ExpInsertPoolTrackerInline (Key, NumberOfBytes, PoolType);
}


VOID
ExpRemovePoolTrackerExpansion (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function increments the number of frees and updates the total
    allocation size in the expansion table.

Arguments:

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfBytes - Supplies the allocation size.

    PoolType - Supplies the pool type.

Return Value:

    None.

--*/

{
    ULONG Hash;
    KIRQL OldIrql;
    PPOOL_TRACKER_TABLE TrackTable;
#if !defined (NT_UP)
    ULONG Processor;
#endif

    //
    // The protected pool bit has already been stripped.
    //

    ASSERT ((Key & PROTECTED_POOL) == 0);

    if (PoolType & SESSION_POOL_MASK) {

        //
        // This entry must have been charged to the overflow bucket.
        // Update the pool tracker table entry for it.
        //

        Hash = (ULONG)ExpSessionPoolTrackTableSize - 1;
        TrackTable = ExpSessionPoolTrackTable;
        goto OverflowEntry;
    }

    //
    // Linear search through the expansion table.  This is ok because
    // the existence of an expansion table at all is extremely rare.
    //

    ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);

    for (Hash = 0; Hash < PoolTrackTableExpansionSize; Hash += 1) {

        if (PoolTrackTableExpansion[Hash].Key == Key) {

            if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
                ASSERT (PoolTrackTableExpansion[Hash].PagedAllocs != 0);
                ASSERT (PoolTrackTableExpansion[Hash].PagedAllocs >=
                        PoolTrackTableExpansion[Hash].PagedFrees);
                ASSERT (PoolTrackTableExpansion[Hash].PagedBytes >= NumberOfBytes);
                PoolTrackTableExpansion[Hash].PagedFrees += 1;
                PoolTrackTableExpansion[Hash].PagedBytes -= NumberOfBytes;
            }
            else {
                ASSERT (PoolTrackTableExpansion[Hash].NonPagedAllocs != 0);
                ASSERT (PoolTrackTableExpansion[Hash].NonPagedAllocs >=
                        PoolTrackTableExpansion[Hash].NonPagedFrees);
                ASSERT (PoolTrackTableExpansion[Hash].NonPagedBytes >= NumberOfBytes);
                PoolTrackTableExpansion[Hash].NonPagedFrees += 1;
                PoolTrackTableExpansion[Hash].NonPagedBytes -= NumberOfBytes;
            }

            ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);
            return;
        }
        if (PoolTrackTableExpansion[Hash].Key == 0) {
            break;
        }
    }

    ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

    //
    // This entry must have been charged to the overflow bucket.
    // Update the pool tracker table entry for it.
    //

    Hash = (ULONG)PoolTrackTableSize - 1;

#if !defined (NT_UP)

    //
    // Use the current processor to pick a pool tag table to use.  Note that
    // in rare cases, this thread may context switch to another processor but
    // the algorithms below will still be correct.
    //

    Processor = KeGetCurrentProcessorNumber ();

    ASSERT (Processor < MAXIMUM_PROCESSOR_TAG_TABLES);

    TrackTable = ExPoolTagTables[Processor];

#else

    TrackTable = PoolTrackTable;

#endif

OverflowEntry:

    if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
        ASSERT (TrackTable[Hash].PagedAllocs != 0);
        ASSERT (TrackTable[Hash].PagedBytes >= NumberOfBytes);
        InterlockedIncrement ((PLONG) &TrackTable[Hash].PagedFrees);
        InterlockedExchangeAddSizeT (&TrackTable[Hash].PagedBytes,
                                     0 - NumberOfBytes);
    }
    else {
        ASSERT (TrackTable[Hash].NonPagedAllocs != 0);
        ASSERT (TrackTable[Hash].NonPagedBytes >= NumberOfBytes);
        InterlockedIncrement ((PLONG) &TrackTable[Hash].NonPagedFrees);
        InterlockedExchangeAddSizeT (&TrackTable[Hash].NonPagedBytes,
                                     0 - NumberOfBytes);
    }
    return;
}

VOID
ExpRemovePoolTracker (
    IN ULONG Key,
    IN SIZE_T NumberOfBytes,
    IN POOL_TYPE PoolType
    )
{
    ExpRemovePoolTrackerInline (Key, NumberOfBytes, PoolType);
}


LOGICAL
ExpAddTagForBigPages (
    IN PVOID Va,
    IN ULONG Key,
    IN ULONG NumberOfPages,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function inserts a pool tag in the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    Key - Supplies the key value used to locate a matching entry in the
          tag table.

    NumberOfPages - Supplies the number of pages that were allocated.

    PoolType - Supplies the type of the pool.

Return Value:

    TRUE if an entry was allocated, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/
{
    ULONG i;
    ULONG Hash;
    PVOID OldVa;
    ULONG BigPages;
    PVOID OldTable;
    LOGICAL Inserted;
    KIRQL OldIrql;
    SIZE_T SizeInBytes;
    SIZE_T NewSizeInBytes;
    PPOOL_TRACKER_BIG_PAGES NewTable;
    PPOOL_TRACKER_BIG_PAGES p;

    //
    // The low bit of the address is set to indicate a free entry.  The high
    // bit cannot be used because in some configurations the high bit is not
    // set for all kernelmode addresses.
    //

    ASSERT (((ULONG_PTR)Va & POOL_BIG_TABLE_ENTRY_FREE) == 0);

    if (PoolType & SESSION_POOL_MASK) {
        Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & ExpSessionPoolBigPageTableHash);
        i = Hash;

        do {
            OldVa = ExpSessionPoolBigPageTable[Hash].Va;

            if (((ULONG_PTR)OldVa & POOL_BIG_TABLE_ENTRY_FREE) &&
                (InterlockedCompareExchangePointer (
                                        &ExpSessionPoolBigPageTable[Hash].Va,
                                        Va,
                                        OldVa) == OldVa)) {

                ExpSessionPoolBigPageTable[Hash].Key = Key;
                ExpSessionPoolBigPageTable[Hash].NumberOfPages = NumberOfPages;

                return TRUE;
            }

            Hash += 1;
            if (Hash >= ExpSessionPoolBigPageTableSize) {
                Hash = 0;
            }
        } while (Hash != i);

#if DBG
        ExpLargeSessionPoolUnTracked += 1;
#endif
        return FALSE;
    }

retry:

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);
    ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);
    while (((ULONG_PTR)PoolBigPageTable[Hash].Va & POOL_BIG_TABLE_ENTRY_FREE) == 0) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {

                //
                // Try to expand the tracker table.
                //

                SizeInBytes = PoolBigPageTableSize * sizeof(POOL_TRACKER_BIG_PAGES);
                NewSizeInBytes = (SizeInBytes << 1);

                if (NewSizeInBytes > SizeInBytes) {

                    NewTable = MiAllocatePoolPages (NonPagedPool,
                                                    NewSizeInBytes);

                    if (NewTable != NULL) {

                        OldTable = (PVOID)PoolBigPageTable;

                        RtlCopyMemory ((PVOID)NewTable,
                                       OldTable,
                                       SizeInBytes);

                        RtlZeroMemory ((PVOID)(NewTable + PoolBigPageTableSize),
                                       NewSizeInBytes - SizeInBytes);

                        //
                        // Mark all the new entries as free.  Note this loop
                        // uses the fact that the table size always doubles.
                        //

                        i = (ULONG)PoolBigPageTableSize;
                        p = &NewTable[i];
                        for (i = 0; i < PoolBigPageTableSize; i += 1, p += 1) {
                            p->Va = (PVOID) POOL_BIG_TABLE_ENTRY_FREE;
                        }

                        PoolBigPageTable = NewTable;
                        PoolBigPageTableSize <<= 1;
                        PoolBigPageTableHash = PoolBigPageTableSize - 1;

                        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

                        BigPages = MiFreePoolPages (OldTable);

                        ExpRemovePoolTracker ('looP',
                                              (SIZE_T) BigPages * PAGE_SIZE,
                                              NonPagedPool);

                        ExpInsertPoolTracker ('looP',
                                              ROUND_TO_PAGES(NewSizeInBytes),
                                              NonPagedPool);

                        goto retry;
                    }
                }

                if (!FirstPrint) {
                    KdPrint(("POOL:unable to insert big page slot %p\n",Key));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);
                return FALSE;
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    p = &PoolBigPageTable[Hash];

    ASSERT (((ULONG_PTR)p->Va & POOL_BIG_TABLE_ENTRY_FREE) != 0);
    ASSERT (((ULONG_PTR)Va & POOL_BIG_TABLE_ENTRY_FREE) == 0);

    p->Va = Va;
    p->Key = Key;
    p->NumberOfPages = NumberOfPages;

    ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

    return TRUE;
}


ULONG
ExpFindAndRemoveTagBigPages (
    IN PVOID Va,
    OUT PULONG BigPages,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function removes a pool tag from the big page tag table.

Arguments:

    Va - Supplies the allocated virtual address.

    BigPages - Returns the number of pages that were allocated.

    PoolType - Supplies the type of the pool.

Return Value:

    TRUE if an entry was found and removed, FALSE if not.

Environment:

    No pool locks held so the table may be freely expanded here as needed.

--*/

{
    ULONG Hash;
    LOGICAL Inserted;
    KIRQL OldIrql;
    ULONG ReturnKey;

    ASSERT (((ULONG_PTR)Va & POOL_BIG_TABLE_ENTRY_FREE) == 0);

    if (PoolType & SESSION_POOL_MASK) {
        Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & ExpSessionPoolBigPageTableHash);

        ReturnKey = Hash;

        do {
            if (ExpSessionPoolBigPageTable[Hash].Va == Va) {

                *BigPages = ExpSessionPoolBigPageTable[Hash].NumberOfPages;
                ReturnKey = ExpSessionPoolBigPageTable[Hash].Key;

                InterlockedOr ((PLONG) &ExpSessionPoolBigPageTable[Hash].Va,
                               POOL_BIG_TABLE_ENTRY_FREE);

                return ReturnKey;
            }

            Hash += 1;
            if (Hash >= ExpSessionPoolBigPageTableSize) {
                Hash = 0;
            }
        } while (Hash != ReturnKey);

        *BigPages = 0;
        return ' GIB';
    }

    Inserted = TRUE;
    Hash = (ULONG)(((ULONG_PTR)Va >> PAGE_SHIFT) & PoolBigPageTableHash);

    ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);

    while (PoolBigPageTable[Hash].Va != Va) {
        Hash += 1;
        if (Hash >= PoolBigPageTableSize) {
            if (!Inserted) {
                if (!FirstPrint) {
                    KdPrint(("POOL:unable to find big page slot %p\n",Va));
                    FirstPrint = TRUE;
                }

                ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);
                *BigPages = 0;
                return ' GIB';
            }

            Hash = 0;
            Inserted = FALSE;
        }
    }

    PoolBigPageTable[Hash].Va =
        (PVOID)((ULONG_PTR)PoolBigPageTable[Hash].Va | POOL_BIG_TABLE_ENTRY_FREE);

    *BigPages = PoolBigPageTable[Hash].NumberOfPages;
    ReturnKey = PoolBigPageTable[Hash].Key;

    ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);
    return ReturnKey;
}


VOID
ExFreePoolWithTag (
    IN PVOID P,
    IN ULONG TagToFree
    )

/*++

Routine Description:

    This function deallocates a block of pool. This function is used to
    deallocate to both the page aligned pools and the buddy (less than
    a page) pools.

    If the address of the block being deallocated is page-aligned, then
    the page-aligned pool deallocator is used.

    Otherwise, the binary buddy pool deallocator is used.  Deallocation
    looks at the allocated block's pool header to determine the pool
    type and block size being deallocated.  If the pool was allocated
    using ExAllocatePoolWithQuota, then after the deallocation is
    complete, the appropriate process's pool quota is adjusted to reflect
    the deallocation, and the process object is dereferenced.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

    TagToFree - Supplies the tag of the block being freed.

Return Value:

    None.

--*/

{
    PVOID OldValue;
    POOL_TYPE CheckType;
    PPOOL_HEADER Entry;
    ULONG BlockSize;
    KLOCK_QUEUE_HANDLE LockHandle;
    PPOOL_HEADER NextEntry;
    POOL_TYPE PoolType;
    POOL_TYPE EntryPoolType;
    PPOOL_DESCRIPTOR PoolDesc;
    PEPROCESS ProcessBilled;
    LOGICAL Combined;
    ULONG BigPages;
    ULONG BigPages2;
    SIZE_T NumberOfBytes;
    ULONG Tag;
    PKPRCB Prcb;
    PGENERAL_LOOKASIDE LookasideList;

    PERFINFO_FREEPOOL(P);

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    if (ExpPoolFlags & (EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS |
                        EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS |
                        EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES |
                        EX_KERNEL_VERIFIER_ENABLED |
                        EX_VERIFIER_DEADLOCK_DETECTION_ENABLED |
                        EX_SPECIAL_POOL_ENABLED)) {

        if (ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) {

            //
            // Log all pool frees in this mode.
            //

            ULONG Hash;
            ULONG Index;
            LOGICAL SpecialPool;
            PEX_FREE_POOL_TRACES Information;

            SpecialPool = MmIsSpecialPoolAddress (P);

            if (ExFreePoolTraces != NULL) {

                Index = InterlockedIncrement (&ExFreePoolIndex);
                Index &= ExFreePoolMask;
                Information = &ExFreePoolTraces[Index];

                Information->Thread = PsGetCurrentThread ();
                Information->PoolAddress = P;
                if (SpecialPool == TRUE) {
                    Information->PoolHeader = *(PPOOL_HEADER) PAGE_ALIGN (P);
                }
                else if (!PAGE_ALIGNED(P)) {
                    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);
                    Information->PoolHeader = *Entry;
                }
                else {
                    RtlZeroMemory (&Information->PoolHeader,
                                   sizeof (POOL_HEADER));
                    Information->PoolHeader.Ulong1 = MmGetSizeOfBigPoolAllocation (P);
                }

                RtlZeroMemory (&Information->StackTrace[0],
                               EX_FREE_POOL_BACKTRACE_LENGTH * sizeof(PVOID)); 

                RtlCaptureStackBackTrace (1,
                                          EX_FREE_POOL_BACKTRACE_LENGTH,
                                          Information->StackTrace,
                                          &Hash);
            }

            if (SpecialPool == TRUE) {

                if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                    VerifierDeadlockFreePool (P, PAGE_SIZE);
                }

                MmFreeSpecialPool (P);

                return;
            }
        }

        if (!PAGE_ALIGNED(P)) {

            Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

            ASSERT_POOL_NOT_FREE(Entry);

            PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

            CheckType = PoolType & BASE_POOL_TYPE_MASK;

            ASSERT_FREE_IRQL(PoolType, P);

            ASSERT_POOL_TYPE_NOT_ZERO(Entry);

            if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
                KeBugCheckEx (BAD_POOL_CALLER,
                              7,
                              __LINE__,
                              (ULONG_PTR)Entry->Ulong1,
                              (ULONG_PTR)P);
            }

            NumberOfBytes = (SIZE_T)Entry->BlockSize << POOL_BLOCK_SHIFT;

            if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                VerifierDeadlockFreePool (P, NumberOfBytes - POOL_OVERHEAD);
            }

            if (Entry->PoolType & POOL_VERIFIER_MASK) {
                VerifierFreeTrackedPool (P,
                                         NumberOfBytes,
                                         CheckType,
                                         FALSE);
            }

            //
            // Check if an ERESOURCE is currently active in this memory block.
            //

            FREE_CHECK_ERESOURCE (Entry, NumberOfBytes);

            //
            // Check if a KTIMER is currently active in this memory block.
            //

            FREE_CHECK_KTIMER (Entry, NumberOfBytes);

            //
            // Look for work items still queued.
            //

            FREE_CHECK_WORKER (Entry, NumberOfBytes);
        }
    }

    //
    // If the entry is page aligned, then free the block to the page aligned
    // pool.  Otherwise, free the block to the allocation lists.
    //

    if (PAGE_ALIGNED(P)) {

        PoolType = MmDeterminePoolType (P);

        ASSERT_FREE_IRQL(PoolType, P);

        CheckType = PoolType & BASE_POOL_TYPE_MASK;

        if (PoolType == PagedPoolSession) {
            PoolDesc = ExpSessionPoolDescriptor;
        }
        else {

            PoolDesc = PoolVector[PoolType];

            if (CheckType == NonPagedPool) {
                if (MiIsPoolLargeSession (P) == TRUE) {
                    PoolDesc = ExpSessionPoolDescriptor;
                    PoolType = NonPagedPoolSession;
                }
            }
        }

        Tag = ExpFindAndRemoveTagBigPages (P, &BigPages, PoolType);

        if (BigPages == 0) {

            //
            // This means the allocator wasn't able to insert this
            // entry into the big page tag table.  This allocation must
            // have been re-tagged as BIG at the time, our problem here
            // is that we don't know the size (or the real original tag).
            //
            // Ask Mm directly for the size.
            //

            BigPages = MmGetSizeOfBigPoolAllocation (P);

            ASSERT (BigPages != 0);

            ASSERT (Tag == ' GIB');
        }
        else if (Tag & PROTECTED_POOL) {

            Tag &= ~PROTECTED_POOL;

            TagToFree &= ~PROTECTED_POOL;

            if (Tag != TagToFree) {

                KeBugCheckEx (BAD_POOL_CALLER,
                              0xA,
                              (ULONG_PTR)P,
                              Tag,
                              TagToFree);
            }
        }

        NumberOfBytes = (SIZE_T)BigPages << PAGE_SHIFT;

        ExpRemovePoolTracker (Tag, NumberOfBytes, PoolType);

        if (ExpPoolFlags & (EX_CHECK_POOL_FREES_FOR_ACTIVE_TIMERS |
                            EX_CHECK_POOL_FREES_FOR_ACTIVE_WORKERS |
                            EX_CHECK_POOL_FREES_FOR_ACTIVE_RESOURCES |
                            EX_VERIFIER_DEADLOCK_DETECTION_ENABLED)) {

            if (ExpPoolFlags & EX_VERIFIER_DEADLOCK_DETECTION_ENABLED) {
                VerifierDeadlockFreePool (P, NumberOfBytes);
            }

            //
            // Check if an ERESOURCE is currently active in this memory block.
            //

            FREE_CHECK_ERESOURCE (P, NumberOfBytes);

            //
            // Check if a KTIMER is currently active in this memory block.
            //

            FREE_CHECK_KTIMER (P, NumberOfBytes);

            //
            // Search worker queues for work items still queued.
            //

            FREE_CHECK_WORKER (P, NumberOfBytes);
        }

        InterlockedIncrement ((PLONG)&PoolDesc->RunningDeAllocs);

        InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes, 0 - NumberOfBytes);

        BigPages2 = MiFreePoolPages (P);

        ASSERT (BigPages == BigPages2);

        InterlockedExchangeAdd ((PLONG)&PoolDesc->TotalBigPages, (LONG)(0 - BigPages2));

        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    BlockSize = Entry->BlockSize;

    EntryPoolType = Entry->PoolType;

    PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

    CheckType = PoolType & BASE_POOL_TYPE_MASK;

    ASSERT_POOL_NOT_FREE (Entry);

    ASSERT_FREE_IRQL (PoolType, P);

    ASSERT_POOL_TYPE_NOT_ZERO (Entry);

    if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
        KeBugCheckEx (BAD_POOL_CALLER,
                      7,
                      __LINE__,
                      (ULONG_PTR)Entry->Ulong1,
                      (ULONG_PTR)P);
    }

    Tag = Entry->PoolTag;
    if (Tag & PROTECTED_POOL) {
        Tag &= ~PROTECTED_POOL;
        TagToFree &= ~PROTECTED_POOL;
        if (Tag != TagToFree) {
            KeBugCheckEx (BAD_POOL_CALLER,
                          0xA,
                          (ULONG_PTR)P,
                          Tag,
                          TagToFree);
        }
    }

    PoolDesc = PoolVector[CheckType];

    MARK_POOL_HEADER_FREED (Entry);

    if (EntryPoolType & SESSION_POOL_MASK) {

        if (CheckType == PagedPool) {
            PoolDesc = ExpSessionPoolDescriptor;
        }
        else if (ExpNumberOfNonPagedPools > 1) {
            PoolDesc = ExpNonPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
        }

        //
        // All session space allocations have an index of 0 unless there
        // are multiple nonpaged (session) pools.
        //

        ASSERT ((DECODE_POOL_INDEX(Entry) == 0) || (ExpNumberOfNonPagedPools > 1));
    }
    else {

        if (CheckType == PagedPool) {
            ASSERT (DECODE_POOL_INDEX(Entry) <= ExpNumberOfPagedPools);
            PoolDesc = ExpPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
        }
        else {
            ASSERT ((DECODE_POOL_INDEX(Entry) == 0) || (ExpNumberOfNonPagedPools > 1));
            if (ExpNumberOfNonPagedPools > 1) {
                PoolDesc = ExpNonPagedPoolDescriptor[DECODE_POOL_INDEX(Entry)];
            }
        }
    }

    //
    // Update the pool tracking database.
    //

    ExpRemovePoolTrackerInline (Tag,
                                BlockSize << POOL_BLOCK_SHIFT,
                                EntryPoolType - 1);

    //
    // If quota was charged when the pool was allocated, release it now.
    //

    if (EntryPoolType & POOL_QUOTA_MASK) {
        ProcessBilled = ExpGetBilledProcess (Entry);
        if (ProcessBilled != NULL) {
            ASSERT_KPROCESS(ProcessBilled);
            PsReturnPoolQuota (ProcessBilled,
                               PoolType & BASE_POOL_TYPE_MASK,
                               BlockSize << POOL_BLOCK_SHIFT);

            if (((PKPROCESS)(ProcessBilled))->Header.Type != ProcessObject) {
                KeBugCheckEx (BAD_POOL_CALLER,
                              0xB,
                              (ULONG_PTR)P,
                              Tag,
                              (ULONG_PTR)ProcessBilled);
            }

            ObDereferenceObject (ProcessBilled);
#if DBG
            InterlockedDecrement (&ExConcurrentQuotaPool);
#endif
        }
    }

    //
    // If the pool block is a small block, then attempt to free the block
    // to the single entry lookaside list. If the free attempt fails, then
    // free the block by merging it back into the pool data structures.
    //

    if (((EntryPoolType & SESSION_POOL_MASK) == 0) ||
        (CheckType == NonPagedPool)) {

        if ((BlockSize <= POOL_SMALL_LISTS) && (USING_HOT_COLD_METRICS == 0)) {

            //
            // Try to free the small block to a per processor lookaside list.
            //

            Prcb = KeGetCurrentPrcb ();

            if (CheckType == PagedPool) {

                //
                // Prototype pool is never put on general lookaside lists
                // due to the sharecounts applied on these allocations when
                // they are in use (ie: the rest of this page is comprised of
                // prototype allocations even though this allocation is being
                // freed).  Pages containing prototype allocations are much
                // more difficult for memory management to trim (unlike the
                // rest of paged pool) due to the sharecounts generally applied.
                //

                if (PoolDesc->PoolIndex == 0) {
                    goto NoLookaside;
                }

                //
                // Only free the small block to the current processor's
                // lookaside list if the block is local to this node.
                //

                if (KeNumberNodes > 1) {
                    if (Prcb->ParentNode->Color != PoolDesc->PoolIndex - 1) {
                        goto NoLookaside;
                    }
                }

                LookasideList = Prcb->PPPagedLookasideList[BlockSize - 1].P;
                LookasideList->TotalFrees += 1;

                if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                    LookasideList->FreeHits += 1;
                    InterlockedPushEntrySList (&LookasideList->ListHead,
                                               (PSLIST_ENTRY)P);

                    return;
                }

                LookasideList = Prcb->PPPagedLookasideList[BlockSize - 1].L;
                LookasideList->TotalFrees += 1;

                if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                    LookasideList->FreeHits += 1;
                    InterlockedPushEntrySList (&LookasideList->ListHead,
                                               (PSLIST_ENTRY)P);

                    return;
                }

            }
            else {

                //
                // Only free the small block to the current processor's
                // lookaside list if the block is local to this node.
                //

                if (KeNumberNodes > 1) {
                    if (Prcb->ParentNode->Color != PoolDesc->PoolIndex) {
                        goto NoLookaside;
                    }
                }

                LookasideList = Prcb->PPNPagedLookasideList[BlockSize - 1].P;
                LookasideList->TotalFrees += 1;

                if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                    LookasideList->FreeHits += 1;
                    InterlockedPushEntrySList (&LookasideList->ListHead,
                                               (PSLIST_ENTRY)P);

                    return;

                }

                LookasideList = Prcb->PPNPagedLookasideList[BlockSize - 1].L;
                LookasideList->TotalFrees += 1;

                if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                    LookasideList->FreeHits += 1;
                    InterlockedPushEntrySList (&LookasideList->ListHead,
                                               (PSLIST_ENTRY)P);

                    return;
                }
            }
        }
    }
    else {

        if (BlockSize <= ExpSessionPoolSmallLists) {

            //
            // Attempt to free the small block to the session lookaside list.
            //

            LookasideList = (PGENERAL_LOOKASIDE)(ULONG_PTR)(ExpSessionPoolLookaside + BlockSize - 1);

            LookasideList->TotalFrees += 1;

            if (ExQueryDepthSList(&LookasideList->ListHead) < LookasideList->Depth) {
                LookasideList->FreeHits += 1;
                InterlockedPushEntrySList (&LookasideList->ListHead,
                                           (PSLIST_ENTRY)P);

                return;
            }
        }
    }

NoLookaside:

    //
    // If the pool block release can be queued so the pool mutex/spinlock
    // acquisition/release can be amortized then do so.  Note "hot" blocks
    // are generally in the lookasides above to provide fast reuse to take
    // advantage of hardware caching.
    //

    if (ExpPoolFlags & EX_DELAY_POOL_FREES) {

        if (PoolDesc->PendingFreeDepth >= EXP_MAXIMUM_POOL_FREES_PENDING) {
            ExDeferredFreePool (PoolDesc);
        }

        //
        // Push this entry on the deferred list.
        //

        do {

            OldValue = PoolDesc->PendingFrees;
            ((PSINGLE_LIST_ENTRY)P)->Next = OldValue;

        } while (InterlockedCompareExchangePointer (
                        &PoolDesc->PendingFrees,
                        P,
                        OldValue) != OldValue);

        InterlockedIncrement (&PoolDesc->PendingFreeDepth);

        return;
    }

    Combined = FALSE;

    ASSERT (BlockSize == Entry->BlockSize);

    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + BlockSize);

    InterlockedIncrement ((PLONG)&PoolDesc->RunningDeAllocs);

    InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes, 0 - ((SIZE_T)BlockSize << POOL_BLOCK_SHIFT));

    LOCK_POOL (PoolDesc, LockHandle);

    CHECK_POOL_PAGE (Entry);

    //
    // Free the specified pool block.
    //
    // Check to see if the next entry is free.
    //

    if (PAGE_END(NextEntry) == FALSE) {

        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            //
            // If the split pool block contains only a header, then
            // it was not inserted and therefore cannot be removed.
            //
            // Note if the minimum pool block size is bigger than the
            // header then there can be no blocks like this.
            //

            if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                (NextEntry->BlockSize != 1)) {

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
            }

            Entry->BlockSize = Entry->BlockSize + NextEntry->BlockSize;
        }
    }

    //
    // Check to see if the previous entry is free.
    //

    if (Entry->PreviousSize != 0) {
        NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
        if (NextEntry->PoolType == 0) {

            //
            // This block is free, combine with the released block.
            //

            Combined = TRUE;

            //
            // If the split pool block contains only a header, then
            // it was not inserted and therefore cannot be removed.
            //
            // Note if the minimum pool block size is bigger than the
            // header then there can be no blocks like this.
            //

            if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                (NextEntry->BlockSize != 1)) {

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
            }

            NextEntry->BlockSize = NextEntry->BlockSize + Entry->BlockSize;
            Entry = NextEntry;
        }
    }

    //
    // If the block being freed has been combined into a full page,
    // then return the free page to memory management.
    //

    if (PAGE_ALIGNED(Entry) &&
        (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

        UNLOCK_POOL (PoolDesc, LockHandle);

        InterlockedExchangeAdd ((PLONG)&PoolDesc->TotalPages, (LONG)-1);

        PERFINFO_FREEPOOLPAGE(CheckType, Entry->PoolIndex, Entry, PoolDesc);

        MiFreePoolPages (Entry);
    }
    else {

        //
        // Insert this element into the list.
        //

        Entry->PoolType = 0;
        BlockSize = Entry->BlockSize;

        ASSERT (BlockSize != 1);

        //
        // If the freed block was combined with any other block, then
        // adjust the size of the next block if necessary.
        //

        if (Combined != FALSE) {

            //
            // The size of this entry has changed, if this entry is
            // not the last one in the page, update the pool block
            // after this block to have a new previous allocation size.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {
                NextEntry->PreviousSize = (USHORT) BlockSize;
            }
        }

        //
        // Always insert at the head in hopes of reusing cache lines.
        //

        PrivateInsertHeadList (&PoolDesc->ListHeads[BlockSize - 1],
                               ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

        CHECK_LIST(((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

        UNLOCK_POOL(PoolDesc, LockHandle);
    }
}

VOID
ExFreePool (
    IN PVOID P
    )
{
    ExFreePoolWithTag (P, 0);
    return;
}


VOID
ExDeferredFreePool (
     IN PPOOL_DESCRIPTOR PoolDesc
     )

/*++

Routine Description:

    This routine frees a number of pool allocations at once to amortize the
    synchronization overhead cost.

Arguments:

    PoolDesc - Supplies the relevant pool descriptor.

Return Value:

    None.

Environment:

    Kernel mode.  May be as high as APC_LEVEL for paged pool or DISPATCH_LEVEL
    for nonpaged pool.

--*/

{
    LONG ListCount;
    KLOCK_QUEUE_HANDLE LockHandle;
    POOL_TYPE CheckType;
    PPOOL_HEADER Entry;
    ULONG Index;
    ULONG WholePageCount;
    PPOOL_HEADER NextEntry;
    ULONG PoolIndex;
    LOGICAL Combined;
    PSINGLE_LIST_ENTRY SingleListEntry;
    PSINGLE_LIST_ENTRY NextSingleListEntry;
    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY LastEntry;
    PSINGLE_LIST_ENTRY WholePages;

    CheckType = PoolDesc->PoolType & BASE_POOL_TYPE_MASK;

    //
    // Initializing LockHandle is not needed for correctness but without
    // it the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    LockHandle.OldIrql = 0;

    ListCount = 0;
    WholePages = NULL;
    WholePageCount = 0;
    LastEntry = NULL;

    LOCK_POOL (PoolDesc, LockHandle);

    if (PoolDesc->PendingFrees == NULL) {
        UNLOCK_POOL (PoolDesc, LockHandle);
        return;
    }

    //
    // Free each deferred pool entry until they're all done.
    //

    do {

        SingleListEntry = PoolDesc->PendingFrees;

        FirstEntry = SingleListEntry;

        do {

            NextSingleListEntry = SingleListEntry->Next;

            //
            // Process the deferred entry.
            //

            ListCount += 1;

            Entry = (PPOOL_HEADER)((PCHAR)SingleListEntry - POOL_OVERHEAD);

            PoolIndex = DECODE_POOL_INDEX(Entry);

            //
            // Process the block.
            //

            Combined = FALSE;

            CHECK_POOL_PAGE (Entry);

            InterlockedIncrement ((PLONG)&PoolDesc->RunningDeAllocs);

            InterlockedExchangeAddSizeT (&PoolDesc->TotalBytes,
                            0 - ((SIZE_T)Entry->BlockSize << POOL_BLOCK_SHIFT));

            //
            // Free the specified pool block.
            //
            // Check to see if the next entry is free.
            //

            NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Entry->BlockSize);
            if (PAGE_END(NextEntry) == FALSE) {

                if (NextEntry->PoolType == 0) {

                    //
                    // This block is free, combine with the released block.
                    //

                    Combined = TRUE;

                    //
                    // If the split pool block contains only a header, then
                    // it was not inserted and therefore cannot be removed.
                    //
                    // Note if the minimum pool block size is bigger than the
                    // header then there can be no blocks like this.
                    //

                    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                        (NextEntry->BlockSize != 1)) {

                        CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
                    }

                    Entry->BlockSize = Entry->BlockSize + NextEntry->BlockSize;
                }
            }

            //
            // Check to see if the previous entry is free.
            //

            if (Entry->PreviousSize != 0) {
                NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry - Entry->PreviousSize);
                if (NextEntry->PoolType == 0) {

                    //
                    // This block is free, combine with the released block.
                    //

                    Combined = TRUE;

                    //
                    // If the split pool block contains only a header, then
                    // it was not inserted and therefore cannot be removed.
                    //
                    // Note if the minimum pool block size is bigger than the
                    // header then there can be no blocks like this.
                    //

                    if ((POOL_OVERHEAD != POOL_SMALLEST_BLOCK) ||
                        (NextEntry->BlockSize != 1)) {

                        CHECK_LIST(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        PrivateRemoveEntryList(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD)));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Flink));
                        CHECK_LIST(DecodeLink(((PLIST_ENTRY)((PCHAR)NextEntry + POOL_OVERHEAD))->Blink));
                    }

                    NextEntry->BlockSize = NextEntry->BlockSize + Entry->BlockSize;
                    Entry = NextEntry;
                }
            }

            //
            // If the block being freed has been combined into a full page,
            // then return the free page to memory management.
            //

            if (PAGE_ALIGNED(Entry) &&
                (PAGE_END((PPOOL_BLOCK)Entry + Entry->BlockSize) != FALSE)) {

                ((PSINGLE_LIST_ENTRY)Entry)->Next = WholePages;
                WholePages = (PSINGLE_LIST_ENTRY) Entry;
                WholePageCount += 1;
            }
            else {

                //
                // Insert this element into the list.
                //

                Entry->PoolType = 0;
                ENCODE_POOL_INDEX(Entry, PoolIndex);
                Index = Entry->BlockSize;

                ASSERT (Index != 1);

                //
                // If the freed block was combined with any other block, then
                // adjust the size of the next block if necessary.
                //

                if (Combined != FALSE) {

                    //
                    // The size of this entry has changed, if this entry is
                    // not the last one in the page, update the pool block
                    // after this block to have a new previous allocation size.
                    //

                    NextEntry = (PPOOL_HEADER)((PPOOL_BLOCK)Entry + Index);
                    if (PAGE_END(NextEntry) == FALSE) {
                        NextEntry->PreviousSize = (USHORT) Index;
                    }
                }

                //
                // Always insert at the head in hopes of reusing cache lines.
                //

                PrivateInsertHeadList(&PoolDesc->ListHeads[Index - 1], ((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));

                CHECK_LIST(((PLIST_ENTRY)((PCHAR)Entry + POOL_OVERHEAD)));
            }

            //
            // March on to the next entry if there is one.
            //

            if (NextSingleListEntry == LastEntry) {
                break;
            }

            SingleListEntry = NextSingleListEntry;

        } while (TRUE);

        if ((PoolDesc->PendingFrees == FirstEntry) &&
            (InterlockedCompareExchangePointer (&PoolDesc->PendingFrees,
                                                NULL,
                                                FirstEntry) == FirstEntry)) {
            break;
        }
        LastEntry = FirstEntry;

    } while (TRUE);

    UNLOCK_POOL (PoolDesc, LockHandle);

    if (WholePages != NULL) {

        //
        // If the pool type is paged pool, then the global paged pool mutex
        // must be held during the free of the pool pages.  Hence any
        // full pages were batched up and are now dealt with in one go.
        //

        Entry = (PPOOL_HEADER) WholePages;

        InterlockedExchangeAdd ((PLONG)&PoolDesc->TotalPages, 0 - WholePageCount);
        do {

            NextEntry = (PPOOL_HEADER) (((PSINGLE_LIST_ENTRY)Entry)->Next);

            PERFINFO_FREEPOOLPAGE(CheckType, PoolIndex, Entry, PoolDesc);

            MiFreePoolPages (Entry);

            Entry = NextEntry;

        } while (Entry != NULL);
    }

    InterlockedExchangeAdd (&PoolDesc->PendingFreeDepth, (0 - ListCount));

    return;
}

SIZE_T
ExQueryPoolBlockSize (
    IN PVOID PoolBlock,
    OUT PBOOLEAN QuotaCharged
    )

/*++

Routine Description:

    This function returns the size of the pool block.

Arguments:

    PoolBlock - Supplies the address of the block of pool.

    QuotaCharged - Supplies a BOOLEAN variable to receive whether or not the
        pool block had quota charged.

    NOTE: If the entry is bigger than a page, the value PAGE_SIZE is returned
          rather than the correct number of bytes.

Return Value:

    Size of pool block.

--*/

{
    PPOOL_HEADER Entry;
    SIZE_T size;

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (PoolBlock))) {
        *QuotaCharged = FALSE;
        return MmQuerySpecialPoolBlockSize (PoolBlock);
    }

    if (PAGE_ALIGNED(PoolBlock)) {
        *QuotaCharged = FALSE;
        return PAGE_SIZE;
    }

    Entry = (PPOOL_HEADER)((PCHAR)PoolBlock - POOL_OVERHEAD);
    size = (ULONG)((Entry->BlockSize << POOL_BLOCK_SHIFT) - POOL_OVERHEAD);

    if (ExpGetBilledProcess (Entry)) {
        *QuotaCharged = TRUE;
    }
    else {
        *QuotaCharged = FALSE;
    }

    return size;
}

VOID
ExQueryPoolUsage (
    OUT PULONG PagedPoolPages,
    OUT PULONG NonPagedPoolPages,
    OUT PULONG PagedPoolAllocs,
    OUT PULONG PagedPoolFrees,
    OUT PULONG PagedPoolLookasideHits,
    OUT PULONG NonPagedPoolAllocs,
    OUT PULONG NonPagedPoolFrees,
    OUT PULONG NonPagedPoolLookasideHits
    )

{
    ULONG Index;
    PGENERAL_LOOKASIDE Lookaside;
    PLIST_ENTRY NextEntry;
    PPOOL_DESCRIPTOR pd;

    //
    // Sum all the paged pool usage.
    //

    *PagedPoolPages = 0;
    *PagedPoolAllocs = 0;
    *PagedPoolFrees = 0;

    for (Index = 0; Index < ExpNumberOfPagedPools + 1; Index += 1) {
        pd = ExpPagedPoolDescriptor[Index];
        *PagedPoolPages += pd->TotalPages + pd->TotalBigPages;
        *PagedPoolAllocs += pd->RunningAllocs;
        *PagedPoolFrees += pd->RunningDeAllocs;
    }

    //
    // Sum all the nonpaged pool usage.
    //

    pd = &NonPagedPoolDescriptor;
    *NonPagedPoolPages = pd->TotalPages + pd->TotalBigPages;
    *NonPagedPoolAllocs = pd->RunningAllocs;
    *NonPagedPoolFrees = pd->RunningDeAllocs;

    //
    // Sum all the lookaside hits for paged and nonpaged pool.
    //

    NextEntry = ExPoolLookasideListHead.Flink;
    while (NextEntry != &ExPoolLookasideListHead) {
        Lookaside = CONTAINING_RECORD(NextEntry,
                                      GENERAL_LOOKASIDE,
                                      ListEntry);

        if (Lookaside->Type == NonPagedPool) {
            *NonPagedPoolLookasideHits += Lookaside->AllocateHits;

        }
        else {
            *PagedPoolLookasideHits += Lookaside->AllocateHits;
        }

        NextEntry = NextEntry->Flink;
    }

    return;
}


VOID
ExReturnPoolQuota (
    IN PVOID P
    )

/*++

Routine Description:

    This function returns quota charged to a subject process when the
    specified pool block was allocated.

Arguments:

    P - Supplies the address of the block of pool being deallocated.

Return Value:

    None.

--*/

{

    PPOOL_HEADER Entry;
    POOL_TYPE PoolType;
    PEPROCESS ProcessBilled;

    //
    // Do nothing for special pool. No quota was charged.
    //

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (P))) {
        return;
    }

    //
    // Align the entry address to a pool allocation boundary.
    //

    Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

    //
    // If quota was charged, then return the appropriate quota to the
    // subject process.
    //

    if (Entry->PoolType & POOL_QUOTA_MASK) {

        PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

        ProcessBilled = ExpGetBilledProcess (Entry);

#if defined (_WIN64)

        //
        // This flag cannot be cleared in NT32 because it's used to denote the
        // allocation is larger (and the verifier finds its own header
        // based on this).
        //

        Entry->PoolType &= ~POOL_QUOTA_MASK;

#else

        //
        // Instead of clearing the flag above, instead zero the quota pointer.
        //

        * (PVOID *)((PCHAR)Entry + (Entry->BlockSize << POOL_BLOCK_SHIFT) - sizeof (PVOID)) = NULL;

#endif

        if (ProcessBilled != NULL) {
            ASSERT_KPROCESS(ProcessBilled);
            PsReturnPoolQuota (ProcessBilled,
                               PoolType & BASE_POOL_TYPE_MASK,
                               (ULONG)Entry->BlockSize << POOL_BLOCK_SHIFT);

            if (((PKPROCESS)(ProcessBilled))->Header.Type != ProcessObject) {
                KeBugCheckEx (BAD_POOL_CALLER,
                              0xC,
                              (ULONG_PTR)P,
                              Entry->PoolTag,
                              (ULONG_PTR)ProcessBilled);
            }

            ObDereferenceObject (ProcessBilled);
#if DBG
            InterlockedDecrement (&ExConcurrentQuotaPool);
#endif
        }
    }

    return;
}

#if !defined (NT_UP)

PVOID
ExCreatePoolTagTable (
    IN ULONG NewProcessorNumber,
    IN UCHAR NodeNumber
    )
{
    SIZE_T NumberOfBytes;
    PPOOL_TRACKER_TABLE NewTagTable;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    ASSERT (NewProcessorNumber < MAXIMUM_PROCESSOR_TAG_TABLES);
    ASSERT (ExPoolTagTables[NewProcessorNumber] == NULL);

    NumberOfBytes = (PoolTrackTableSize + 1) * sizeof(POOL_TRACKER_TABLE);

    NewTagTable = MmAllocateIndependentPages (NumberOfBytes, NodeNumber);

    if (NewTagTable != NULL) {

        //
        // Just zero the table here, the tags are lazy filled as various pool
        // allocations and frees occur.  Note no memory barrier is needed
        // because only this processor will read it except when an
        // ExGetPoolTagInfo call occurs, and in that case, explicit memory
        // barriers are used as needed.
        //

        RtlZeroMemory (NewTagTable,
                       PoolTrackTableSize * sizeof(POOL_TRACKER_TABLE));

        ExPoolTagTables[NewProcessorNumber] = NewTagTable;
    }

    return (PVOID) NewTagTable;
}

VOID
ExDeletePoolTagTable (
    IN ULONG NewProcessorNumber
    )

/*++

Routine Description:

    This function deletes the tag table for the specified processor
    number because the processor did not boot.

Arguments:

    NewProcessorNumber - Supplies the processor number that did not boot.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
    ASSERT (NewProcessorNumber < MAXIMUM_PROCESSOR_TAG_TABLES);
    ASSERT (ExPoolTagTables[NewProcessorNumber] != NULL);

    NumberOfBytes = (PoolTrackTableSize + 1) * sizeof(POOL_TRACKER_TABLE);

    VirtualAddress = ExPoolTagTables[NewProcessorNumber];

    //
    // Raise to DISPATCH to prevent a race when attempting to hot-add a
    // processor while a pool-usage query is active.
    //

    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);

    ExPoolTagTables[NewProcessorNumber] = NULL;

    KeLowerIrql (OldIrql);

    MmFreeIndependentPages (VirtualAddress, NumberOfBytes);

    return;
}
#endif

typedef struct _POOL_DPC_CONTEXT {

    PPOOL_TRACKER_TABLE PoolTrackTable;
    SIZE_T PoolTrackTableSize;

    PPOOL_TRACKER_TABLE PoolTrackTableExpansion;
    SIZE_T PoolTrackTableSizeExpansion;

} POOL_DPC_CONTEXT, *PPOOL_DPC_CONTEXT;

VOID
ExpGetPoolTagInfoTarget (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    )
/*++

Routine Description:

    Called by all processors during a pool tag table query.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Deferred context.

    SystemArgument1 - Used to signal completion of this call.

    SystemArgument2 - Used for internal lockstepping during this call.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL since this is called from a DPC.

--*/
{
    PPOOL_DPC_CONTEXT Context;
#if !defined (NT_UP)
    ULONG i;
    PPOOL_TRACKER_TABLE TrackerEntry;
    PPOOL_TRACKER_TABLE LastTrackerEntry;
    PPOOL_TRACKER_TABLE TargetTrackerEntry;
#endif

    UNREFERENCED_PARAMETER (Dpc);

    ASSERT (KeGetCurrentIrql () == DISPATCH_LEVEL);

    Context = DeferredContext;

    //
    // Make sure all DPCs are running (ie: spinning at DISPATCH_LEVEL)
    // to prevent any pool allocations or frees from happening until
    // all the counters are snapped.  Otherwise the counters could
    // be misleading (ie: more frees than allocs, etc).
    //

    if (KeSignalCallDpcSynchronize (SystemArgument2)) {

        //
        // This processor (could be the caller or a target) is the final
        // processor to enter the DPC spinloop.  Snap the data now.
        //

#if defined (NT_UP)

        RtlCopyMemory ((PVOID)Context->PoolTrackTable,
                       (PVOID)PoolTrackTable,
                       Context->PoolTrackTableSize * sizeof (POOL_TRACKER_TABLE));

#else

        RtlCopyMemory ((PVOID)Context->PoolTrackTable,
                       (PVOID)ExPoolTagTables[0],
                       Context->PoolTrackTableSize * sizeof (POOL_TRACKER_TABLE));

        LastTrackerEntry = Context->PoolTrackTable + Context->PoolTrackTableSize;

        for (i = 1; i < MAXIMUM_PROCESSOR_TAG_TABLES; i += 1) {

            TargetTrackerEntry = ExPoolTagTables[i];

            if (TargetTrackerEntry == NULL) {
                continue;
            }

            TrackerEntry = Context->PoolTrackTable;

            while (TrackerEntry != LastTrackerEntry) {

                if (TargetTrackerEntry->Key != 0) {

                    ASSERT (TargetTrackerEntry->Key == TrackerEntry->Key);

                    TrackerEntry->NonPagedAllocs += TargetTrackerEntry->NonPagedAllocs;
                    TrackerEntry->NonPagedFrees += TargetTrackerEntry->NonPagedFrees;
                    TrackerEntry->NonPagedBytes += TargetTrackerEntry->NonPagedBytes;
                    TrackerEntry->PagedAllocs += TargetTrackerEntry->PagedAllocs;
                    TrackerEntry->PagedFrees += TargetTrackerEntry->PagedFrees;
                    TrackerEntry->PagedBytes += TargetTrackerEntry->PagedBytes;
                }
                TrackerEntry += 1;
                TargetTrackerEntry += 1;
            }
        }

#endif

        if (Context->PoolTrackTableSizeExpansion != 0) {
            RtlCopyMemory ((PVOID)(Context->PoolTrackTableExpansion),
                           (PVOID)PoolTrackTableExpansion,
                           Context->PoolTrackTableSizeExpansion * sizeof (POOL_TRACKER_TABLE));
        }
    }

    //
    // Wait until everyone has got to this point before continuing.
    //

    KeSignalCallDpcSynchronize (SystemArgument2);

    //
    // Signal that all processing has been done.
    //

    KeSignalCallDpcDone (SystemArgument1);

    return;
}

NTSTATUS
ExGetPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function copies the system pool tag information to the supplied
    USER space buffer.  Note that the caller has already probed the USER
    address and wrapped this routine inside a try-except.

Arguments:

    SystemInformation - Supplies a user space buffer to copy the data to.

    SystemInformationLength - Supplies the length of the user buffer.

    ReturnLength - Receives the actual length of the data returned.

Return Value:

    Various NTSTATUS codes.

--*/

{
    SIZE_T NumberOfBytes;
    SIZE_T NumberOfExpansionTableBytes;
    ULONG totalBytes;
    NTSTATUS status;
    PSYSTEM_POOLTAG_INFORMATION taginfo;
    PSYSTEM_POOLTAG poolTag;
    PPOOL_TRACKER_TABLE PoolTrackInfo;
    PPOOL_TRACKER_TABLE TrackerEntry;
    PPOOL_TRACKER_TABLE LastTrackerEntry;
    POOL_DPC_CONTEXT Context;
    SIZE_T LocalTrackTableSize;
    SIZE_T LocalTrackTableSizeExpansion;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

    totalBytes = 0;
    status = STATUS_SUCCESS;

    taginfo = (PSYSTEM_POOLTAG_INFORMATION)SystemInformation;
    poolTag = &taginfo->TagInfo[0];
    totalBytes = FIELD_OFFSET(SYSTEM_POOLTAG_INFORMATION, TagInfo);
    taginfo->Count = 0;

    LocalTrackTableSize = PoolTrackTableSize;
    LocalTrackTableSizeExpansion = PoolTrackTableExpansionSize;

    NumberOfBytes = LocalTrackTableSize * sizeof(POOL_TRACKER_TABLE);
    NumberOfExpansionTableBytes = LocalTrackTableSizeExpansion * sizeof (POOL_TRACKER_TABLE);

    PoolTrackInfo = (PPOOL_TRACKER_TABLE) ExAllocatePoolWithTag (
                                    NonPagedPool,
                                    NumberOfBytes + NumberOfExpansionTableBytes,
                                    'ofnI');

    if (PoolTrackInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Context.PoolTrackTable = PoolTrackInfo;
    Context.PoolTrackTableSize = PoolTrackTableSize;

    Context.PoolTrackTableExpansion = (PoolTrackInfo + PoolTrackTableSize);
    Context.PoolTrackTableSizeExpansion = PoolTrackTableExpansionSize;

    KeGenericCallDpc (ExpGetPoolTagInfoTarget, &Context);

    TrackerEntry = PoolTrackInfo;
    LastTrackerEntry = PoolTrackInfo + (LocalTrackTableSize + LocalTrackTableSizeExpansion);

    //
    // Wrap the user space accesses with an exception handler so we can free the
    // pool track info allocation if the user address was bogus.
    //

    try {
        while (TrackerEntry < LastTrackerEntry) {
            if (TrackerEntry->Key != 0) {
                taginfo->Count += 1;
                totalBytes += sizeof (SYSTEM_POOLTAG);
                if (SystemInformationLength < totalBytes) {
                    status = STATUS_INFO_LENGTH_MISMATCH;
                }
                else {
                    ASSERT (TrackerEntry->PagedAllocs >= TrackerEntry->PagedFrees);
                    ASSERT (TrackerEntry->NonPagedAllocs >= TrackerEntry->NonPagedFrees);

                    poolTag->TagUlong = TrackerEntry->Key;
                    poolTag->PagedAllocs = TrackerEntry->PagedAllocs;
                    poolTag->PagedFrees = TrackerEntry->PagedFrees;
                    poolTag->PagedUsed = TrackerEntry->PagedBytes;
                    poolTag->NonPagedAllocs = TrackerEntry->NonPagedAllocs;
                    poolTag->NonPagedFrees = TrackerEntry->NonPagedFrees;
                    poolTag->NonPagedUsed = TrackerEntry->NonPagedBytes;
                    poolTag += 1;
                }
            }
            TrackerEntry += 1;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
    }

    ExFreePool (PoolTrackInfo);

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = totalBytes;
    }

    return status;
}

NTSTATUS
ExGetSessionPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnedEntries,
    IN OUT PULONG ActualEntries
    )

/*++

Routine Description:

    This function copies the current session's pool tag information to the
    supplied system-mapped buffer.

Arguments:

    SystemInformation - Supplies a system mapped buffer to copy the data to.

    SystemInformationLength - Supplies the length of the buffer.

    ReturnedEntries - Receives the actual number of entries returned.

    ActualEntries - Receives the total number of entries.
                    This can be more than ReturnedEntries if the caller's
                    buffer is not large enough to hold all the data.

Return Value:

    Various NTSTATUS codes.

--*/

{
    ULONG totalBytes;
    ULONG ActualCount;
    ULONG ReturnedCount;
    NTSTATUS status;
    PSYSTEM_POOLTAG poolTag;
    PPOOL_TRACKER_TABLE TrackerEntry;
    PPOOL_TRACKER_TABLE LastTrackerEntry;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

    totalBytes = 0;
    ActualCount = 0;
    ReturnedCount = 0;
    status = STATUS_SUCCESS;

    poolTag = (PSYSTEM_POOLTAG) SystemInformation;

    //
    // Capture the current session's pool information.
    //

    TrackerEntry = ExpSessionPoolTrackTable;
    LastTrackerEntry = TrackerEntry + ExpSessionPoolTrackTableSize;

    while (TrackerEntry < LastTrackerEntry) {
        if (TrackerEntry->Key != 0) {
            ActualCount += 1;
            totalBytes += sizeof (SYSTEM_POOLTAG);

            if (totalBytes > SystemInformationLength) {
                status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else {
                ReturnedCount += 1;

                poolTag->TagUlong = TrackerEntry->Key;
                poolTag->PagedAllocs = TrackerEntry->PagedAllocs;
                poolTag->PagedFrees = TrackerEntry->PagedFrees;
                poolTag->PagedUsed = TrackerEntry->PagedBytes;
                poolTag->NonPagedAllocs = TrackerEntry->NonPagedAllocs;
                poolTag->NonPagedFrees = TrackerEntry->NonPagedFrees;
                poolTag->NonPagedUsed = TrackerEntry->NonPagedBytes;

                //
                // Session pool tag entries are updated with interlocked
                // sequences so it is possible here that we can read one
                // that is in the middle of being updated.  Sanitize the
                // data here so callers don't have to.
                //

                ASSERT ((SSIZE_T)poolTag->PagedUsed >= 0);
                ASSERT ((SSIZE_T)poolTag->NonPagedUsed >= 0);

                if (poolTag->PagedAllocs < poolTag->PagedFrees) {
                    poolTag->PagedAllocs = poolTag->PagedFrees;
                }

                if (poolTag->NonPagedAllocs < poolTag->NonPagedFrees) {
                    poolTag->NonPagedAllocs = poolTag->NonPagedFrees;
                }

                poolTag += 1;
            }
        }
        TrackerEntry += 1;
    }

    *ReturnedEntries = ReturnedCount;
    *ActualEntries = ActualCount;

    return status;
}

NTSTATUS
ExGetBigPoolInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function copies the system big pool entry information to the supplied
    USER space buffer.  Note that the caller has already probed the USER
    address and wrapped this routine inside a try-except.

    PAGELK was not used for this function so that calling it causes minimal
    disruption to actual memory usage.

Arguments:

    SystemInformation - Supplies a user space buffer to copy the data to.

    SystemInformationLength - Supplies the length of the user buffer.

    ReturnLength - Supplies the actual length of the data returned.

Return Value:

    Various NTSTATUS codes.

--*/

{
    ULONG TotalBytes;
    KIRQL OldIrql;
    NTSTATUS Status;
    PVOID NewTable;
    PPOOL_TRACKER_BIG_PAGES SystemPoolEntry;
    PPOOL_TRACKER_BIG_PAGES SystemPoolEntryEnd;
    SIZE_T SnappedBigTableSize;
    SIZE_T SnappedBigTableSizeInBytes;

    PSYSTEM_BIGPOOL_ENTRY UserPoolEntry;
    PSYSTEM_BIGPOOL_INFORMATION UserPoolInfo;

    ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);

    NewTable = NULL;
    Status = STATUS_SUCCESS;

    UserPoolInfo = (PSYSTEM_BIGPOOL_INFORMATION)SystemInformation;
    UserPoolEntry = &UserPoolInfo->AllocatedInfo[0];
    TotalBytes = FIELD_OFFSET(SYSTEM_BIGPOOL_INFORMATION, AllocatedInfo);
    UserPoolInfo->Count = 0;

    do {

        SnappedBigTableSize = PoolBigPageTableSize;
        SnappedBigTableSizeInBytes =
                    SnappedBigTableSize * sizeof (POOL_TRACKER_BIG_PAGES);

        if (NewTable != NULL) {
            MiFreePoolPages (NewTable);
        }

        //
        // Use MiAllocatePoolPages for the temporary buffer so we won't have
        // to filter it out of the results before handing them back.
        //

        NewTable = MiAllocatePoolPages (NonPagedPool,
                                        SnappedBigTableSizeInBytes);

        if (NewTable == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ExAcquireSpinLock (&ExpTaggedPoolLock, &OldIrql);

        if (SnappedBigTableSize >= PoolBigPageTableSize) {

            //
            // Success - our table is big enough to hold everything.
            //

            break;
        }

        ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

    } while (TRUE);

    RtlCopyMemory (NewTable,
                   PoolBigPageTable,
                   PoolBigPageTableSize * sizeof (POOL_TRACKER_BIG_PAGES));

    SnappedBigTableSize = PoolBigPageTableSize;

    ExReleaseSpinLock (&ExpTaggedPoolLock, OldIrql);

    SystemPoolEntry = NewTable;
    SystemPoolEntryEnd = SystemPoolEntry + SnappedBigTableSize;

    //
    // Wrap the user space accesses with an exception handler so we can
    // free the temp buffer if the user address was bogus.
    //

    try {
        while (SystemPoolEntry < SystemPoolEntryEnd) {

            if (((ULONG_PTR)SystemPoolEntry->Va & POOL_BIG_TABLE_ENTRY_FREE) == 0) {

                //
                // This entry is in use so capture it.
                //

                UserPoolInfo->Count += 1;
                TotalBytes += sizeof (SYSTEM_BIGPOOL_ENTRY);

                if (SystemInformationLength < TotalBytes) {
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                }
                else {
                    UserPoolEntry->VirtualAddress = SystemPoolEntry->Va;
                    
                    if (MmDeterminePoolType (SystemPoolEntry->Va) == NonPagedPool) {
                        UserPoolEntry->NonPaged = 1;
                    }

                    UserPoolEntry->TagUlong = SystemPoolEntry->Key & ~PROTECTED_POOL;
                    UserPoolEntry->SizeInBytes = SystemPoolEntry->NumberOfPages << PAGE_SHIFT;
                    UserPoolEntry += 1;
                }
            }
            SystemPoolEntry += 1;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode ();
    }

    MiFreePoolPages (NewTable);

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = TotalBytes;
    }

    return Status;
}

VOID
ExAllocatePoolSanityChecks (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function performs sanity checks on the caller.

Return Value:

    None.

Environment:

    Only enabled as part of the driver verification package.

--*/

{
    if (NumberOfBytes == 0) {
        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      0x0,
                      KeGetCurrentIrql(),
                      PoolType,
                      NumberOfBytes);
    }

    if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {

        if (KeGetCurrentIrql() > APC_LEVEL) {

            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x1,
                          KeGetCurrentIrql(),
                          PoolType,
                          NumberOfBytes);
        }
    }
    else {
        if (KeGetCurrentIrql() > DISPATCH_LEVEL) {

            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x2,
                          KeGetCurrentIrql(),
                          PoolType,
                          NumberOfBytes);
        }
    }
}

VOID
ExFreePoolSanityChecks (
    IN PVOID P
    )

/*++

Routine Description:

    This function performs sanity checks on the caller.

Return Value:

    None.

Environment:

    Only enabled as part of the driver verification package.

--*/

{
    PPOOL_HEADER Entry;
    POOL_TYPE PoolType;
    PVOID StillQueued;

    if (P <= (PVOID)(MM_HIGHEST_USER_ADDRESS)) {
        KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                      0x10,
                      (ULONG_PTR)P,
                      0,
                      0);
    }

    if ((ExpPoolFlags & EX_SPECIAL_POOL_ENABLED) &&
        (MmIsSpecialPoolAddress (P))) {

        KeCheckForTimer (P, PAGE_SIZE - BYTE_OFFSET (P));

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(P, PAGE_SIZE - BYTE_OFFSET (P));
        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          (ULONG_PTR)-1,
                          (ULONG_PTR)P);
        }

        ExpCheckForWorker (P, PAGE_SIZE - BYTE_OFFSET (P)); // bugchecks inside
        return;
    }

    if (PAGE_ALIGNED(P)) {
        PoolType = MmDeterminePoolType(P);

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            if (KeGetCurrentIrql() > APC_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x11,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }
        else {
            if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x12,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }

        //
        // Just check the first page.
        //

        KeCheckForTimer(P, PAGE_SIZE);

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(P, PAGE_SIZE);

        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          PoolType,
                          (ULONG_PTR)P);
        }
    }
    else {

        if (((ULONG_PTR)P & (POOL_OVERHEAD - 1)) != 0) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x16,
                          __LINE__,
                          (ULONG_PTR)P,
                          0);
        }

        Entry = (PPOOL_HEADER)((PCHAR)P - POOL_OVERHEAD);

        if ((Entry->PoolType & POOL_TYPE_MASK) == 0) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x13,
                          __LINE__,
                          (ULONG_PTR)Entry,
                          Entry->Ulong1);
        }

        PoolType = (Entry->PoolType & POOL_TYPE_MASK) - 1;

        if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
            if (KeGetCurrentIrql() > APC_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x11,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }
        else {
            if (KeGetCurrentIrql() > DISPATCH_LEVEL) {
                KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                              0x12,
                              KeGetCurrentIrql(),
                              PoolType,
                              (ULONG_PTR)P);
            }
        }

        if (!IS_POOL_HEADER_MARKED_ALLOCATED(Entry)) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x14,
                          __LINE__,
                          (ULONG_PTR)Entry,
                          0);
        }

        KeCheckForTimer(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

        //
        // Check if an ERESOURCE is currently active in this memory block.
        //

        StillQueued = ExpCheckForResource(Entry, (ULONG)(Entry->BlockSize << POOL_BLOCK_SHIFT));

        if (StillQueued != NULL) {
            KeBugCheckEx (DRIVER_VERIFIER_DETECTED_VIOLATION,
                          0x17,
                          (ULONG_PTR)StillQueued,
                          PoolType,
                          (ULONG_PTR)P);
        }
    }
}

#if defined (NT_UP)
VOID
ExpBootFinishedDispatch (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called when the system has booted into a shell.

    It's job is to disable various pool optimizations that are enabled to
    speed up booting and reduce the memory footprint on small machines.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Optional deferred context;  not used.

    SystemArgument1 - Optional argument 1;  not used.

    SystemArgument2 - Optional argument 2;  not used.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL since this is called from a timer expiration.

--*/

{
    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (DeferredContext);
    UNREFERENCED_PARAMETER (SystemArgument1);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Pretty much all pages are "hot" after bootup.  Since bootup has finished,
    // use lookaside lists and stop trying to separate regular allocations
    // as well.
    //

    RtlInterlockedAndBitsDiscardReturn (&ExpPoolFlags, (ULONG)~EX_SEPARATE_HOT_PAGES_DURING_BOOT);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\profile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    profile.c

Abstract:

   This module implements the executive profile object. Functions are provided
   to create, start, stop, and query profile objects.

Author:

    Lou Perazzoli (loup) 21-Sep-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Executive profile object.
//

typedef struct _EPROFILE {
    PKPROCESS Process;
    PVOID RangeBase;
    SIZE_T RangeSize;
    PVOID Buffer;
    ULONG BufferSize;
    ULONG BucketSize;
    PKPROFILE ProfileObject;
    PVOID LockedBufferAddress;
    PMDL Mdl;
    ULONG Segment;
    KPROFILE_SOURCE ProfileSource;
    KAFFINITY Affinity;
} EPROFILE, *PEPROFILE;

//
// Address of event object type descriptor.
//

POBJECT_TYPE ExProfileObjectType;

KMUTEX ExpProfileStateMutex;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif

const ULONG ExpCurrentProfileUsage = 0;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpProfileMapping = {
    STANDARD_RIGHTS_READ | PROFILE_CONTROL,
    STANDARD_RIGHTS_WRITE | PROFILE_CONTROL,
    STANDARD_RIGHTS_EXECUTE | PROFILE_CONTROL,
    PROFILE_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#define ACTIVE_PROFILE_LIMIT 8

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpProfileInitialization)
#pragma alloc_text(PAGE, ExpProfileDelete)
#pragma alloc_text(PAGE, NtCreateProfile)
#pragma alloc_text(PAGE, NtStartProfile)
#pragma alloc_text(PAGE, NtStopProfile)
#pragma alloc_text(PAGE, NtSetIntervalProfile)
#pragma alloc_text(PAGE, NtQueryIntervalProfile)
#pragma alloc_text(PAGE, NtQueryPerformanceCounter)
#endif


BOOLEAN
ExpProfileInitialization (
    )

/*++

Routine Description:

    This function creates the profile object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the profile object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize mutex for synchronizing start and stop operations.
    //

    KeInitializeMutex (&ExpProfileStateMutex, MUTEX_LEVEL_EX_PROFILE);

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Profile");

    //
    // Create event object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer,sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(EPROFILE);
    ObjectTypeInitializer.ValidAccessMask = PROFILE_ALL_ACCESS;
    ObjectTypeInitializer.DeleteProcedure = ExpProfileDelete;
    ObjectTypeInitializer.GenericMapping = ExpProfileMapping;

    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExProfileObjectType);

    //
    // If the event object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

VOID
ExpProfileDelete (
    IN PVOID    Object
    )

/*++

Routine Description:


    This routine is called by the object management procedures whenever
    the last reference to a profile object has been removed.  This routine
    stops profiling, returns locked buffers and pages, dereferences the
    specified process and returns.

Arguments:

    Object - a pointer to the body of the profile object.

Return Value:

    None.

--*/

{
    PEPROFILE Profile;
    BOOLEAN   State;
    PEPROCESS ProcessAddress;

    Profile = (PEPROFILE)Object;

    if (Profile->LockedBufferAddress != NULL) {

        //
        // Stop profiling and unlock the buffers and deallocate pool.
        //

        State = KeStopProfile (Profile->ProfileObject);
        ASSERT (State != FALSE);

        MmUnmapLockedPages (Profile->LockedBufferAddress, Profile->Mdl);
        MmUnlockPages (Profile->Mdl);
        ExFreePool (Profile->ProfileObject);
    }

    if (Profile->Process != NULL) {
        ProcessAddress = CONTAINING_RECORD(Profile->Process, EPROCESS, Pcb);
        ObDereferenceObject ((PVOID)ProcessAddress);
    }

    return;
}

NTSTATUS
NtCreateProfile (
    OUT PHANDLE ProfileHandle,
    IN HANDLE Process OPTIONAL,
    IN PVOID RangeBase,
    IN SIZE_T RangeSize,
    IN ULONG BucketSize,
    IN PULONG Buffer,
    IN ULONG BufferSize,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

    This function creates a profile object.

Arguments:

    ProfileHandle - Supplies a pointer to a variable that will receive
                    the profile object handle.

    Process - Optionally, supplies the handle to the process whose
              address space to profile.  If the value is NULL (0), then
              all address spaces are included in the profile.

    RangeBase - Supplies the address of the first byte of the address
                  space for which profiling information is to be collected.


    RangeSize - Supplies the size of the range to profile in the
                address space.  RangeBase and RangeSize are interpreted
                such that RangeBase <= address < RangeBase+RangeSize
                will generate a profile hit.

    BucketSize - Supplies the LOG base 2 of the size of the profiling
                 bucket.  Thus, BucketSize = 2 yields four-byte
                 buckets, BucketSize = 7 yields 128-byte buckets.
                 All profile hits in a given bucket will increment
                 the corresponding counter in Buffer.  Buckets
                 cannot be smaller than a ULONG.  The acceptable range
                 of this value is 2 to 30 inclusive.

    Buffer - Supplies an array of ULONGs.  Each ULONG is a hit counter,
             which records the number of hits of the corresponding
             bucket.

    BufferSize - Size in bytes of Buffer.

    ProfileSource - Supplies the source for the profile interrupt

    Affinity - Supplies the processor set for the profile interrupt

Return Value:

    TBS

--*/

{

    PEPROFILE Profile;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROCESS ProcessAddress;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN HasPrivilege = FALSE;
    ULONG Segment = FALSE;
#ifdef i386
    USHORT PowerOf2;
#endif

    //
    // Verify that the base and size arguments are reasonable.
    //

    if (BufferSize == 0) {
        return STATUS_INVALID_PARAMETER_7;
    }

#ifdef i386
    //
    //        sleazy use of bucket size.  If bucket size is zero, and
    //        RangeBase < 64K, then create a profile object to attach
    //        to a non-flat code segment.  In this case, RangeBase is
    //        the non-flat CS for this profile object.
    //

    if ((BucketSize == 0) && (RangeBase < (PVOID)(64 * 1024))) {

        if (BufferSize < sizeof(ULONG)) {
            return STATUS_INVALID_PARAMETER_7;
        }

        Segment = (ULONG)RangeBase;
        RangeBase = 0;
        BucketSize = RangeSize / (BufferSize / sizeof(ULONG));

        //
        // Convert Bucket size of log2(BucketSize)
        //
        PowerOf2 = 0;
        BucketSize = BucketSize - 1;
        while (BucketSize >>= 1) {
            PowerOf2++;
        }

        BucketSize = PowerOf2 + 1;

        if (BucketSize < 2) {
            BucketSize = 2;
        }
    }
#endif

    if ((BucketSize > 31) || (BucketSize < 2)) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((RangeSize >> (BucketSize - 2)) > BufferSize) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (((ULONG_PTR)RangeBase + RangeSize) < RangeSize) {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a profile object. If the probe fails, then return the
    // exception code as the service status. Otherwise return the status value
    // returned by the object insertion routine.
    //

    try {
        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        PreviousMode = KeGetPreviousMode ();

        if (PreviousMode != KernelMode) {
            ProbeForWriteHandle(ProfileHandle);

            ProbeForWrite(Buffer,
                          BufferSize,
                          sizeof(ULONG));
        }

    //
    // If an exception occurs during the probe of the output handle address,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

//
// TODO post NT5:
//
// Currently, if a process isn't specified, there is no privilege check if
//   RangeBase > MM_HIGHEST_USER_ADDRESS.
// The check for user-space addresses is SeSystemProfilePrivilege.
// Querying a specific process requires only PROCESS_QUERY_INFORMATION.
//
// The spec says:
//
//     Process - If specified, a handle to a process which describes the address space to profile.
//     If not present, then all address spaces are included in the profile.
//     Profiling a process requires PROCESS_QUERY_INFORMATION access to that process and
//     SeProfileSingleProcessPrivilege privilege.
//     Profiling all processes requires SeSystemProfilePrivilege privilege.
//
// So two changes appear needed.
//   A check on SeProfileSingleProcessPrivilege needs to be added to the single process case,
//   and SeSystemProfilePrivilege privilege should be required for both user and system address profiling.
//


    if (!ARGUMENT_PRESENT(Process)) {

        //
        // Don't attach segmented profile objects to all processes
        //

        if (Segment) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Profile all processes. Make sure that the specified
        // address range is in system space, unless SeSystemProfilePrivilege.
        //

        if (RangeBase <= MM_HIGHEST_USER_ADDRESS) {

            //
            // Check for privilege before allowing a user to profile
            // all processes and USER addresses.
            //

            if (PreviousMode != KernelMode) {
                HasPrivilege =  SeSinglePrivilegeCheck(
                                    SeSystemProfilePrivilege,
                                    PreviousMode
                                    );

                if (!HasPrivilege) {
#if DBG
                    DbgPrint("SeSystemProfilePrivilege needed to profile all USER addresses.\n");
#endif //DBG
                    return( STATUS_PRIVILEGE_NOT_HELD );
                }

            }
        }

        ProcessAddress = NULL;


    } else {

        //
        // Reference the specified process.
        //

        Status = ObReferenceObjectByHandle ( Process,
                                             PROCESS_QUERY_INFORMATION,
                                             PsProcessType,
                                             PreviousMode,
                                             (PVOID *)&ProcessAddress,
                                             NULL );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                OBJ_EXCLUSIVE,
                                NULL,
                                NULL );

    Status = ObCreateObject( KernelMode,
                             ExProfileObjectType,
                             &ObjectAttributes,
                             PreviousMode,
                             NULL,
                             sizeof(EPROFILE),
                             0,
                             sizeof(EPROFILE) + sizeof(KPROFILE),
                             (PVOID *)&Profile);

    //
    // If the profile object was successfully allocated, initialize
    // the profile object.
    //
    if (NT_SUCCESS(Status)) {


        if (ProcessAddress != NULL) {
            Profile->Process = &ProcessAddress->Pcb;
        } else {
            Profile->Process = NULL;
        }

        Profile->RangeBase = RangeBase;
        Profile->RangeSize = RangeSize;
        Profile->Buffer = Buffer;
        Profile->BufferSize = BufferSize;
        Profile->BucketSize = BucketSize;
        Profile->LockedBufferAddress = NULL;
        Profile->Segment = Segment;
        Profile->ProfileSource = ProfileSource;
        Profile->Affinity = Affinity;

        Status = ObInsertObject(Profile,
                                NULL,
                                PROFILE_CONTROL,
                                0,
                                (PVOID *)NULL,
                                &Handle);
        //
        // If the profile object was successfully inserted in the current
        // process' handle table, then attempt to write the profile object
        // handle value. If the write attempt fails, then do not report
        // an error. When the caller attempts to access the handle value,
        // an access violation will occur.
        //
        if (NT_SUCCESS(Status)) {
            try {
                *ProfileHandle = Handle;
            } except(EXCEPTION_EXECUTE_HANDLER) {
            }
        }
    } else {
        //
        // We failed, remove our reference to the process object.
        //

        if (ProcessAddress != NULL) {
            ObDereferenceObject (ProcessAddress);
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtStartProfile (
    IN HANDLE ProfileHandle
    )

/*++

Routine Description:

    The NtStartProfile routine starts the collecting data for the
    specified profile object.  This involved allocating nonpaged
    pool to lock the specified buffer in memory, creating a kernel
    profile object and starting collecting on that profile object.

Arguments:

    ProfileHandle - Supplies the profile handle to start profiling on.

Return Value:

    TBS

--*/

{

    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PEPROFILE Profile;
    PKPROFILE ProfileObject;
    PVOID LockedVa;
    BOOLEAN State;
    PMDL Mdl;

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle (ProfileHandle,
                                        PROFILE_CONTROL,
                                        ExProfileObjectType,
                                        PreviousMode,
                                        &Profile,
                                        NULL);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Acquire the profile state mutex so two threads can't
    // operate on the same profile object simultaneously.
    //

    KeWaitForSingleObject (&ExpProfileStateMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PLARGE_INTEGER)NULL);

    //
    // Make sure profiling is not already enabled.
    //

    if (Profile->LockedBufferAddress != NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject (Profile);
        return STATUS_PROFILING_NOT_STOPPED;
    }

    if (ExpCurrentProfileUsage == ACTIVE_PROFILE_LIMIT) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject (Profile);
        return STATUS_PROFILING_AT_LIMIT;
    }

    ProfileObject = ExAllocatePoolWithTag (NonPagedPool,
                                    MmSizeOfMdl(Profile->Buffer,
                                                Profile->BufferSize) +
                                        sizeof(KPROFILE),
                                        'forP');

    if (ProfileObject == NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject (Profile);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Mdl = (PMDL)(ProfileObject + 1);
    Profile->Mdl = Mdl;
    Profile->ProfileObject = ProfileObject;

    //
    // Probe and lock the specified buffer.
    //

    MmInitializeMdl(Mdl, Profile->Buffer, Profile->BufferSize);

    LockedVa = NULL;

    try {

        MmProbeAndLockPages (Mdl,
                             PreviousMode,
                             IoWriteAccess );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ExFreePool (ProfileObject);
        ObDereferenceObject (Profile);
        return GetExceptionCode();
    }

    //
    // Since kernel space is specified below, this call cannot raise
    // an exception.
    //

    LockedVa = MmMapLockedPagesSpecifyCache (Profile->Mdl,
                                             KernelMode,
                                             MmCached,
                                             NULL,
                                             FALSE,
                                             NormalPagePriority);

    if (LockedVa == NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);

        MmUnlockPages (Mdl);
        ExFreePool (ProfileObject);
        ObDereferenceObject (Profile);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the profile object.
    //

    KeInitializeProfile (ProfileObject,
                         Profile->Process,
                         Profile->RangeBase,
                         Profile->RangeSize,
                         Profile->BucketSize,
                         Profile->Segment,
                         Profile->ProfileSource,
                         Profile->Affinity);

    State = KeStartProfile (ProfileObject, LockedVa);
    ASSERT (State != FALSE);

    Profile->LockedBufferAddress = LockedVa;

    KeReleaseMutex (&ExpProfileStateMutex, FALSE);
    ObDereferenceObject (Profile);

    return STATUS_SUCCESS;
}

NTSTATUS
NtStopProfile (
    IN HANDLE ProfileHandle
    )

/*++

Routine Description:

    The NtStopProfile routine stops collecting data for the
    specified profile object.  This involves stopping the data
    collection on the profile object, unlocking the locked buffers,
    and deallocating the pool for the MDL and profile object.

Arguments:

    ProfileHandle - Supplies a the profile handle to stop profiling.

Return Value:

    TBS

--*/

{

    PEPROFILE Profile;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    BOOLEAN State;
    PKPROFILE ProfileObject;
    PMDL Mdl;
    PVOID LockedBufferAddress;

    PreviousMode = KeGetPreviousMode();

    Status = ObReferenceObjectByHandle( ProfileHandle,
                                        PROFILE_CONTROL,
                                        ExProfileObjectType,
                                        PreviousMode,
                                        (PVOID *)&Profile,
                                        NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    KeWaitForSingleObject( &ExpProfileStateMutex,
                           Executive,
                           KernelMode,
                           FALSE,
                           (PLARGE_INTEGER)NULL);

    //
    // Check to see if profiling is not active.
    //

    if (Profile->LockedBufferAddress == NULL) {
        KeReleaseMutex (&ExpProfileStateMutex, FALSE);
        ObDereferenceObject (Profile);
        return STATUS_PROFILING_NOT_STARTED;
    }

    //
    // Stop profiling and unlock the buffer.
    //

    State = KeStopProfile (Profile->ProfileObject);
    ASSERT (State != FALSE);

    LockedBufferAddress = Profile->LockedBufferAddress;
    Profile->LockedBufferAddress = NULL;
    Mdl = Profile->Mdl;
    ProfileObject = Profile->ProfileObject;
    KeReleaseMutex (&ExpProfileStateMutex, FALSE);

    MmUnmapLockedPages (LockedBufferAddress, Mdl);
    MmUnlockPages (Mdl);
    ExFreePool (ProfileObject);
    ObDereferenceObject (Profile);
    return STATUS_SUCCESS;
}

NTSTATUS
NtSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    )

/*++

Routine Description:

    This routine allows the system-wide interval (and thus the profiling
    rate) for profiling to be set.

Arguments:

    Interval - Supplies the sampling interval in 100ns units.

    Source - Specifies the profile source to be set.

Return Value:

    TBS

--*/

{

    KeSetIntervalProfile (Interval, Source);
    return STATUS_SUCCESS;
}

NTSTATUS
NtQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Interval
    )

/*++

Routine Description:

    This routine queries the system-wide interval (and thus the profiling
    rate) for profiling.

Arguments:

    Source - Specifies the profile source to be queried.

    Interval - Returns the sampling interval in 100ns units.

Return Value:

    TBS

--*/

{
    ULONG CapturedInterval;
    KPROCESSOR_MODE PreviousMode;

    PreviousMode = KeGetPreviousMode ();
    if (PreviousMode != KernelMode) {

        //
        // Probe accessibility of user's buffer.
        //

        try {
            ProbeForWriteUlong (Interval);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // If an exception occurs during the probe or capture
            // of the initial values, then handle the exception and
            // return the exception code as the status value.
            //

            return GetExceptionCode();
        }
    }

    CapturedInterval = KeQueryIntervalProfile (ProfileSource);

    if (PreviousMode != KernelMode) {
        try {
            *Interval = CapturedInterval;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }
    }
    else {
        *Interval = CapturedInterval;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NtQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceCounter,
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This function returns current value of performance counter and,
    optionally, the frequency of the performance counter.

    Performance frequency is the frequency of the performance counter
    in Hertz, i.e., counts/second.  Note that this value is implementation
    dependent.  If the implementation does not have hardware to support
    performance timing, the value returned is 0.

Arguments:

    PerformanceCounter - supplies the address of a variable to receive
        the current Performance Counter value.

    PerformanceFrequency - Optionally, supplies the address of a
        variable to receive the performance counter frequency.

Return Value:

    STATUS_ACCESS_VIOLATION or STATUS_SUCCESS.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    LARGE_INTEGER KernelPerformanceFrequency;

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Probe accessibility of user's buffer.
        //

        try {
            ProbeForWriteSmallStructure (PerformanceCounter,
                                         sizeof (LARGE_INTEGER),
                                         sizeof (ULONG));

            if (ARGUMENT_PRESENT(PerformanceFrequency)) {
                ProbeForWriteSmallStructure (PerformanceFrequency,
                                             sizeof (LARGE_INTEGER),
                                             sizeof (ULONG));
            }

            *PerformanceCounter = KeQueryPerformanceCounter (&KernelPerformanceFrequency);

            if (ARGUMENT_PRESENT(PerformanceFrequency)) {
                *PerformanceFrequency = KernelPerformanceFrequency;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // If an exception occurs during the probe or capture
            // of the initial values, then handle the exception and
            // return the exception code as the status value.
            //

            return GetExceptionCode();
        }
    }
    else {
        *PerformanceCounter = KeQueryPerformanceCounter (&KernelPerformanceFrequency);
        if (ARGUMENT_PRESENT(PerformanceFrequency)) {
            *PerformanceFrequency = KernelPerformanceFrequency;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\nbqueue.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nbqueue.c

Abstract:

   This module implements non-blocking fifo queue.

Author:

    David N. Cutler (davec) 24-Apr-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Define queue pointer structure - this is platform target specific.
//

#if defined(_AMD64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 48;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_X86_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG Count;
        LONG Node;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;

#elif defined(_IA64_)

typedef union _NBQUEUE_POINTER {
    struct {
        LONG64 Node : 45;
        LONG64 Region : 3;
        LONG64 Count : 16;
    };

    LONG64 Data;
} NBQUEUE_POINTER, *PNBQUEUE_POINTER;


#else

#error "no target architecture"

#endif

//
// Define queue node struture.
//

typedef struct _NBQUEUE_NODE {
    NBQUEUE_POINTER Next;
    ULONG64 Value;
} NBQUEUE_NODE, *PNBQUEUE_NODE;

//
// Define inline functions to pack and unpack pointers in the platform
// specific non-blocking queue pointer structure.
//

#if defined(_AMD64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)((LONG64)(Entry->Node));
}

#elif defined(_X86_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG)Node;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{
    return (PVOID)(Entry->Node);
}

#elif defined(_IA64_)

__inline
VOID
PackNBQPointer (
    IN PNBQUEUE_POINTER Entry,
    IN PNBQUEUE_NODE Node
    )

{

    Entry->Node = (LONG64)Node;
    Entry->Region = (LONG64)Node >> 61;
    return;
}

__inline
PNBQUEUE_NODE
UnpackNBQPointer (
    IN PNBQUEUE_POINTER Entry
    )

{

    LONG64 Value;

    Value = Entry->Node & 0x1fffffffffffffff;
    Value |= Entry->Region << 61;
    return (PVOID)(Value);
}

#else

#error "no target architecture"

#endif

//
// Define queue descriptor structure.
//

typedef struct _NBQUEUE_HEADER {
    NBQUEUE_POINTER Head;
    NBQUEUE_POINTER Tail;
    PSLIST_HEADER SlistHead;
} NBQUEUE_HEADER, *PNBQUEUE_HEADER;

#pragma alloc_text(PAGE, ExInitializeNBQueueHead)

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    )

/*++

Routine Description:

    This function initializes a non-blocking queue header.

    N.B. It is assumed that the specified SLIST has been populated with
         non-blocking queue nodes prior to calling this routine.

Arguments:

    SlistHead - Supplies a pointer to an SLIST header.

Return Value:

    If the non-blocking queue is successfully initialized, then the
    address of the queue header is returned as the function value.
    Otherwise, NULL is returned as the function value.

--*/

{

    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;

    //
    // Attempt to allocate the queue header. If the allocation fails, then
    // return NULL.
    //

    QueueHead = (PNBQUEUE_HEADER)ExAllocatePoolWithTag(NonPagedPool,
                                                       sizeof(NBQUEUE_HEADER),
                                                       'hqBN');

    if (QueueHead == NULL) {
        return NULL;
    }

    //
    // Attempt to allocate a queue node from the specified SLIST. If a node
    // can be allocated, then initialize the non-blocking queue header and
    // return the address of the queue header. Otherwise, free the queue
    // header and return NULL.
    //

    QueueHead->SlistHead = SlistHead;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);

    if (QueueNode != NULL) {

        //
        // Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = 0;

        //
        // Initialize the head and tail pointers in the queue header.
        //

        PackNBQPointer(&QueueHead->Head, QueueNode);
        QueueHead->Head.Count = 0;
        PackNBQPointer(&QueueHead->Tail, QueueNode);
        QueueHead->Tail.Count = 0;
        return QueueHead;

    } else {
        ExFreePool(QueueHead);
        return NULL;
    }
}

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    )

/*++

Routine Description:

    This function inserts the specific data value at the tail of the
    specified non-blocking queue.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to an opaque data value.

Return Value:

    If the specified opaque data value is successfully inserted at the tail
    of the specified non-blocking queue, then a value of TRUE is returned as
    the function value. Otherwise, a value of FALSE is returned.

    N.B. FALSE is returned if a queue node cannot be allocated from the
         associated SLIST.

--*/

{

    NBQUEUE_POINTER Insert;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    PNBQUEUE_NODE QueueNode;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // Attempt to allocate a queue node from the SLIST associated with
    // the specified non-blocking queue. If a node can be allocated, then
    // the node is inserted at the tail of the specified non-blocking
    // queue, and TRUE is returned as the function value. Otherwise, FALSE
    // is returned.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;
    QueueNode = (PNBQUEUE_NODE)InterlockedPopEntrySList(QueueHead->SlistHead);

    if (QueueNode != NULL) {

        //
        //  Initialize the queue node next pointer and value.
        //

        QueueNode->Next.Data = 0;
        QueueNode->Value = Value;

        //
        // The following loop is executed until the specified entry can
        // be safely inserted at the tail of the specified non-blocking
        // queue.
        //

        do {

            //
            // Read the tail queue pointer and the next queue pointer of
            // the tail queue pointer making sure the two pointers are
            // coherent.
            //

            Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
            TailNode = UnpackNBQPointer(&Tail);
            Next.Data = *((volatile LONG64 *)(&TailNode->Next.Data));
            QueueNode->Next.Count = Tail.Count + 1;
            if (Tail.Data == *((volatile LONG64 *)(&QueueHead->Tail.Data))) {

                //
                // If the tail is pointing to the last node in the list,
                // then attempt to insert the new node at the end of the
                // list. Otherwise, the tail is not pointing to the last
                // node in the list and an attempt is made to move the
                // tail pointer to the next node.
                //

                NextNode = UnpackNBQPointer(&Next);
                if (NextNode == NULL) {
                    PackNBQPointer(&Insert, QueueNode);
                    Insert.Count = Next.Count + 1;
                    if (InterlockedCompareExchange64(&TailNode->Next.Data,
                                                     Insert.Data,
                                                     Next.Data) == Next.Data) {
                        break;
                    }

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                 Insert.Data,
                                                 Tail.Data);
                }
            }

        } while (TRUE);

        //
        // Attempt to move the tail to the new tail node.
        //

        PackNBQPointer(&Insert, QueueNode);
        Insert.Count = Tail.Count + 1;
        InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                     Insert.Data,
                                     Tail.Data);

        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    )

/*++

Routine Description:

    This function removes a queue entry from the head of the specified
    non-blocking queue and returns the associated data value.

Arguments:

    Header - Supplies an opaque pointer to a non-blocking queue header.

    Value - Supplies a pointer to a variable that receives the queue
        element value.

Return Value:

    If an entry is removed from the specified non-blocking queue, then
    TRUE is returned as the function value. Otherwise, FALSE is returned.

--*/

{

    NBQUEUE_POINTER Head;
    PNBQUEUE_NODE HeadNode;
    NBQUEUE_POINTER Insert;
    NBQUEUE_POINTER Next;
    PNBQUEUE_NODE NextNode;
    PNBQUEUE_HEADER QueueHead;
    NBQUEUE_POINTER Tail;
    PNBQUEUE_NODE TailNode;

    //
    // The following loop is executed until an entry can be removed from
    // the specified non-blocking queue or until it can be determined that
    // the queue is empty.
    //

    QueueHead = (PNBQUEUE_HEADER)Header;
    do {

        //
        // Read the head queue pointer, the tail queue pointer, and the
        // next queue pointer of the head queue pointer making sure the
        // three pointers are coherent.
        //

        Head.Data = *((volatile LONG64 *)(&QueueHead->Head.Data));
        Tail.Data = *((volatile LONG64 *)(&QueueHead->Tail.Data));
        HeadNode = UnpackNBQPointer(&Head);
        Next.Data = *((volatile LONG64 *)(&HeadNode->Next.Data));
        if (Head.Data == *((volatile LONG64 *)(&QueueHead->Head.Data))) {

            //
            // If the queue header node is equal to the queue tail node,
            // then either the queue is empty or the tail pointer is falling
            // behind. Otherwise, there is an entry in the queue that can
            // be removed.
            //

            NextNode = UnpackNBQPointer(&Next);
            TailNode = UnpackNBQPointer(&Tail);
            if (HeadNode == TailNode) {

                //
                // If the next node of head pointer is NULL, then the queue
                // is empty. Otherwise, attempt to move the tail forward.
                //

                if (NextNode == NULL) {
                    return FALSE;

                } else {
                    PackNBQPointer(&Insert, NextNode);
                    Insert.Count = Tail.Count + 1;
                    InterlockedCompareExchange64(&QueueHead->Tail.Data,
                                                 Insert.Data,
                                                 Tail.Data);
                }

            } else {

                //
                // There is an entry in the queue that can be removed.
                //

                *Value = NextNode->Value;
                PackNBQPointer(&Insert, NextNode);
                Insert.Count = Head.Count + 1;
                if (InterlockedCompareExchange64(&QueueHead->Head.Data,
                                                 Insert.Data,
                                                 Head.Data) == Head.Data) {

                    break;
                }
            }
        }

    } while (TRUE);

    //
    // Free the node that was removed for the list by inserting the node
    // in the associated SLIST.
    //

    InterlockedPushEntrySList(QueueHead->SlistHead,
                              (PSLIST_ENTRY)HeadNode);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\pushlock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pushlock.c

Abstract:

    This module houses routines that do push locking.

    Push locks are capable of being acquired in both shared and exclusive mode.

    Properties include:

    They can not be acquired recursively.
    They are small (the size of a pointer) and can be used when embeded in pagable data.
    Acquire and release is done lock free. On lock contention the waiters are chained
    through the lock and local stack space.

    This is the structure of a push lock:

    
    E  == Exclusive bit
    W  == Waiters present
    SC == Share count
    P  == Pointer to wait block
    +----------+---+---+
    |    SC    | E | W | E, W are single bits W == 0
    +----------+---+---+

    +--------------+---+
    |      P       | W | W == 1. Pointer is the address of a chain of stack local wait blocks
    +--------------+---+

    The non-contented acquires and releases are trivial. Interlocked operations make the following
    transformations.

    (SC=0,E=0,W=0) === Exclusive acquire ===> (SC=0,E=1,W=0)
    (SC=n,E=0,W=0) === Shared acquire    ===> (SC=n+1,E=0,W=0)

    (SC=0,E=1,W=0) === Exclusive release ===> (SC=0,E=0,W=0)
    (SC=n,E=0,W=0) === Shared release    ===> (SC=n-1,E=0,W=0) n > 0

    Contention causes the acquiring thread to produce a local stack based wait block and to
    enqueue it to the front of the list.

    (SC=n,E=e,W=0) === Exclusive acquire ===> (P=LWB(SSC=n,E=e),W=1) LWB = local wait block,
                                                                     SSC = Saved share count,
                                                                     n > 0 or e == 1.

    (SC=0,E=1,W=0) === Shared acquire    ===> (P=LWB(SSC=0,E=0),W=1) LWB = local wait block,
                                                                     SSC = Saved share count.

    After contention has causes one or more threads to queue up wait blocks releases are more
    complicated. This following rights are granted to a releasing thread (shared or exclusive).

    1) Shared release threads are allowed to search the wait list until they hit a wait block
       with a non-zero share count (this will be a wait block marked exclusive). This thread is
       allowed to use an interlocked operation to decrement this value. If this thread
       transitioned the value to zero then it obtains the rights of an exclusive release thread

    2) Exclusive threads are allowed to search the wait list until they find a continuous chain
       of shared wait blocks or they find the last wait block is an exclusive waiter. This thread
       may then break the chain at this point or update the header to show a single exclusive
       owner or multiple shared owners. Breaking the list can be done with normal assignment
       but updating the header requires interlocked exchange compare.


Author:

    Neill Clift (NeillC) 30-Sep-2000


Revision History:

--*/

#include "exp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ExBlockPushLock)
#pragma alloc_text(PAGE, ExfAcquirePushLockExclusive)
#pragma alloc_text(PAGE, ExfAcquirePushLockShared)
#pragma alloc_text(PAGE, ExfUnblockPushLock)
#pragma alloc_text(PAGE, ExAllocateCacheAwarePushLock)
#pragma alloc_text(PAGE, ExFreeCacheAwarePushLock)
#pragma alloc_text(PAGE, ExAcquireCacheAwarePushLockExclusive)
#pragma alloc_text(PAGE, ExReleaseCacheAwarePushLockExclusive)
#endif


NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;

    OldValue = *PushLock;
    while (1) {
        //
        // If the lock is already held exclusively/shared or there are waiters then
        // we need to wait.
        //
        if (OldValue.Value == 0) {
            NewValue.Value = OldValue.Value + EX_PUSH_LOCK_EXCLUSIVE;
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                break;
            }
        } else {
            KeInitializeEvent (&WaitBlock.WakeEvent, SynchronizationEvent, FALSE);
            WaitBlock.Exclusive = TRUE;
            WaitBlock.Last = NULL;
            WaitBlock.Previous = NULL;
            //
            // Move the sharecount to our wait block if need be.
            //
            if (OldValue.Waiting) {
                WaitBlock.Next = (PEX_PUSH_LOCK_WAIT_BLOCK)
                                     (OldValue.Value - EX_PUSH_LOCK_WAITING);
                WaitBlock.ShareCount = 0;
            } else {
                WaitBlock.Next = NULL;
                WaitBlock.ShareCount = (ULONG) OldValue.Shared;
            }
            NewValue.Ptr = ((PUCHAR) &WaitBlock) + EX_PUSH_LOCK_WAITING;
            ASSERT ((NewValue.Value & EX_PUSH_LOCK_WAITING) != 0);
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                KeWaitForSingleObject (&WaitBlock.WakeEvent,
                                       WrPushLock,
                                       KernelMode,
                                       FALSE,
                                       NULL);
                ASSERT ((WaitBlock.ShareCount == 0) && (WaitBlock.Next == NULL));
                break;
            }

        }
        OldValue = NewValue;
    }
}

NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock shared

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;
    EX_PUSH_LOCK_WAIT_BLOCK WaitBlock;

    OldValue = *PushLock;
    while (1) {
        //
        // If the lock is already held exclusively or there are waiters then we need to wait
        //
        if (OldValue.Exclusive || OldValue.Waiting) {
            KeInitializeEvent (&WaitBlock.WakeEvent, SynchronizationEvent, FALSE);
            WaitBlock.Exclusive = 0;
            WaitBlock.ShareCount = 0;
            WaitBlock.Last = NULL;
            WaitBlock.Previous = NULL;
            //
            // Chain the next block to us if there is one.
            //
            if (OldValue.Waiting) {
                WaitBlock.Next = (PEX_PUSH_LOCK_WAIT_BLOCK)
                                     (OldValue.Value - EX_PUSH_LOCK_WAITING);
            } else {
                WaitBlock.Next = NULL;
            }
            NewValue.Ptr = ((PUCHAR) &WaitBlock) + EX_PUSH_LOCK_WAITING;
            ASSERT ((NewValue.Value & EX_PUSH_LOCK_WAITING) != 0);
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                KeWaitForSingleObject (&WaitBlock.WakeEvent,
                                       WrPushLock,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                ASSERT (WaitBlock.ShareCount == 0);
                break;
            }

        } else {
            //
            // We only have shared accessors at the moment. We can just update the lock to include this thread.
            //
            NewValue.Value = OldValue.Value + EX_PUSH_LOCK_SHARE_INC;
            ASSERT (!(NewValue.Waiting || NewValue.Exclusive));
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                break;
            }
        }
        OldValue = NewValue;
    }
}


NTKERNELAPI
VOID
FASTCALL
ExfReleasePushLock (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired exclusively or shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;
    PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock, NextWaitBlock, ReleaseWaitList, Previous;
    PEX_PUSH_LOCK_WAIT_BLOCK LastWaitBlock, FirstWaitBlock;
    ULONG ShareCount;
    KIRQL OldIrql;

    OldValue = *PushLock;
    while (1) {
        if (!OldValue.Waiting) {
            //
            // Either we hold the lock exclusive or shared but not both.
            //
            ASSERT (OldValue.Exclusive ^ (OldValue.Shared > 0));

            //
            // We must hold the lock exclusive or shared. We make the assuption that
            // the exclusive bit is just below the share count here.
            //
            NewValue.Value = (OldValue.Value - EX_PUSH_LOCK_EXCLUSIVE) &
                             ~EX_PUSH_LOCK_EXCLUSIVE;
            NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                              NewValue.Ptr,
                                                              OldValue.Ptr);
            if (NewValue.Ptr == OldValue.Ptr) {
                break;
            }
            //
            // Either we gained a new waiter or another shared owner arrived or left
            //
            ASSERT (NewValue.Waiting || (NewValue.Shared > 0 && !NewValue.Exclusive));
            OldValue = NewValue;
        } else {
            //
            // There are waiters chained to the lock. We have to release the share count,
            // last exclusive or last chain of shared waiters.
            //
            WaitBlock = (PEX_PUSH_LOCK_WAIT_BLOCK) 
                           (OldValue.Value - EX_PUSH_LOCK_WAITING);

            FirstWaitBlock = WaitBlock;
            ReleaseWaitList = WaitBlock;
            Previous = NULL;
            LastWaitBlock = NULL;
            ShareCount = 0;
            do {

                if (WaitBlock->Last != NULL) {
                    LastWaitBlock = WaitBlock;
                    WaitBlock = WaitBlock->Last;
                    Previous = WaitBlock->Previous;
                    ReleaseWaitList = WaitBlock;
                    ASSERT (WaitBlock->Next == NULL);
                    ASSERT (Previous != NULL);
                    ShareCount = 0;
                }

                if (WaitBlock->Exclusive) {
                    //
                    // This is an exclusive waiter. If this was the first exclusive waited to a shared acquire
                    // then it will have the saved share count. If we acquired the lock shared then the count
                    // must contain a bias for this thread. Release that and if we are not the last shared
                    // accessor then exit. A later shared release thread will wake the exclusive
                    // waiter.
                    //
                    if (WaitBlock->ShareCount != 0) {
                        if (InterlockedDecrement ((PLONG)&WaitBlock->ShareCount) != 0) {
                            return;
                        }
                    }
                    //
                    // Reset count of share acquires waiting.
                    //
                    ShareCount = 0;
                } else {
                    //
                    // This is a shared waiter. Record the number of these to update the head or the
                    // previous exclusive waiter.
                    //
                    ShareCount++;
                }
                NextWaitBlock = WaitBlock->Next;
                if (NextWaitBlock != NULL) {

                    NextWaitBlock->Previous = WaitBlock;

                    if (NextWaitBlock->Exclusive) {
                        //
                        // The next block is exclusive. This may be the entry to free.
                        //
                        Previous = WaitBlock;
                        ReleaseWaitList = NextWaitBlock;
                    } else {
                        //
                        // The next block is shared. If the chain start is exclusive then skip to this one
                        // as the exclusive isn't the thread we will wake up.
                        //
                        if (ReleaseWaitList->Exclusive) {
                            Previous = WaitBlock;
                            ReleaseWaitList = NextWaitBlock;
                        }
                    }
                }

                WaitBlock = NextWaitBlock;
            } while (WaitBlock != NULL);

            //
            // If our release chain is everything then we have to update the header
            //
            if (Previous == NULL) {
                NewValue.Value = 0;
                NewValue.Exclusive = ReleaseWaitList->Exclusive;
                NewValue.Shared = ShareCount;
                ASSERT (((ShareCount > 0) ^ (ReleaseWaitList->Exclusive)) && !NewValue.Waiting);

                NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                                  NewValue.Ptr,
                                                                  OldValue.Ptr);
                if (NewValue.Ptr != OldValue.Ptr) {
                    //
                    // We are releasing so we could have only gained another waiter
                    //
                    ASSERT (NewValue.Waiting);
                    OldValue = NewValue;
                    continue;
                }
            } else {

                if (LastWaitBlock != NULL) {
                    LastWaitBlock->Last = NULL;
                }
                //
                // Truncate the chain at this position and save the share count for all the shared owners to
                // decrement later.
                //
                Previous->Next = NULL;
                ASSERT (Previous->ShareCount == 0);
                Previous->ShareCount = ShareCount;

                //
                // Add a pointer to make future searches faster
                //
                if (Previous->Exclusive && FirstWaitBlock != Previous) {
                    FirstWaitBlock->Last = Previous;
                    ASSERT (Previous->Previous != NULL);
                }
                //
                // We are either releasing multiple share accessors or a single exclusive
                //
                ASSERT ((ShareCount > 0) ^ ReleaseWaitList->Exclusive);
            }

            //
            // If we are waking more than one thread then raise to DPC level to prevent us
            // getting rescheduled part way through the operation
            //

            OldIrql = DISPATCH_LEVEL;
            if (ShareCount > 1) {
                KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
            }

            //
            //
            // Release the chain of threads we located.
            //
            do {
                NextWaitBlock = ReleaseWaitList->Next;
                //
                // All the chain should have the same type (Exclusive/Shared).
                //
                ASSERT (NextWaitBlock == NULL || (ReleaseWaitList->Exclusive == NextWaitBlock->Exclusive));
                ASSERT (!ReleaseWaitList->Exclusive || (ReleaseWaitList->ShareCount == 0));
                KeSetEventBoostPriority (&ReleaseWaitList->WakeEvent, NULL);
                ReleaseWaitList = NextWaitBlock;
            } while (ReleaseWaitList != NULL);

            if (OldIrql != DISPATCH_LEVEL) {
                KeLowerIrql (OldIrql);
            }


            break;
        }
    }
}

NTKERNELAPI
VOID
FASTCALL
ExBlockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock
     )
/*++

Routine Description:

    Block on a push lock

Arguments:

    PushLock  - Push lock to block on
    WaitBlock - Wait block to queue for waiting

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    //
    // Push the wait block on the list. 
    //
    KeInitializeEvent (&WaitBlock->WakeEvent, SynchronizationEvent, FALSE);

    OldValue = *PushLock;
    while (1) {
        //
        // Chain the next block to us if there is one.
        //
        WaitBlock->Next = OldValue.Ptr;
        NewValue.Ptr = InterlockedCompareExchangePointer (&PushLock->Ptr,
                                                          WaitBlock,
                                                          OldValue.Ptr);
        if (NewValue.Ptr == OldValue.Ptr) {
            return;
        }
        OldValue = NewValue;
    }
}

NTKERNELAPI
VOID
FASTCALL
ExfUnblockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock OPTIONAL
     )
/*++

Routine Description:

    Unblock on a push lock

Arguments:

    PushLock  - Push lock to block on
    WaitBlock - Wait block previously queued for waiting or NULL if there wasn't one

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue;
    PEX_PUSH_LOCK_WAIT_BLOCK tWaitBlock;
    BOOLEAN FoundOurBlock=FALSE;

    //
    // Pop the entire chain and wake them all up.
    //
    OldValue.Ptr = InterlockedExchangePointer (&PushLock->Ptr,
                                               NULL);
    while (OldValue.Ptr != NULL) {
        tWaitBlock = OldValue.Ptr;
        OldValue.Ptr = tWaitBlock->Next;
        if (tWaitBlock == WaitBlock) {
            FoundOurBlock = TRUE;
        } else{
            KeSetEvent (&tWaitBlock->WakeEvent, 0, FALSE);
        }
    }
    if (WaitBlock != NULL && !FoundOurBlock) {
        KeWaitForSingleObject (&WaitBlock->WakeEvent,
                               WrPushLock,
                               KernelMode,
                               FALSE,
                               NULL);
    }
}

NTKERNELAPI
PEX_PUSH_LOCK_CACHE_AWARE
ExAllocateCacheAwarePushLock (
     VOID
     )
/*++

Routine Description:

    Allocate a cache aware (cache friendly) push lock

Arguments:

    None

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK_CACHE_AWARE PushLockCacheAware;
    PEX_PUSH_LOCK_CACHE_AWARE_PADDED PaddedPushLock;
    ULONG i, j, MaxLine;

    PushLockCacheAware = ExAllocatePoolWithTag (PagedPool,
                                                sizeof (EX_PUSH_LOCK_CACHE_AWARE),
                                                'pclP');
    if (PushLockCacheAware != NULL) {
        //
        // If we are a non-numa machine then allocate the padded push locks as a single block
        //
        if (KeNumberNodes == 1) {
            PaddedPushLock = ExAllocatePoolWithTag (PagedPool,
                                                    sizeof (EX_PUSH_LOCK_CACHE_AWARE_PADDED)*
                                                       EX_PUSH_LOCK_FANNED_COUNT,
                                                    'lclP');
            if (PaddedPushLock == NULL) {
                ExFreePool (PushLockCacheAware);
                return NULL;
            }
            for (i = 0; i < EX_PUSH_LOCK_FANNED_COUNT; i++) {
                PaddedPushLock->Single = TRUE;
                ExInitializePushLock (&PaddedPushLock->Lock);
                PushLockCacheAware->Locks[i] = &PaddedPushLock->Lock;
                PaddedPushLock++;
            }
        } else {
            //
            // Allocate a different block for each lock and set affinity
            // so the allocation comes from that nodes memory.
            //
            MaxLine = KeNumberProcessors;
            if (MaxLine > EX_PUSH_LOCK_FANNED_COUNT) {
                MaxLine = EX_PUSH_LOCK_FANNED_COUNT;
            }

            for (i = 0; i < MaxLine; i++) {
                KeSetSystemAffinityThread (AFFINITY_MASK (i));
                PaddedPushLock = ExAllocatePoolWithTag (PagedPool,
                                                        sizeof (EX_PUSH_LOCK_CACHE_AWARE_PADDED),
                                                        'lclP');
                if (PaddedPushLock == NULL) {
                    for (j = 0; j < i; j++) {
                        ExFreePool (PushLockCacheAware->Locks[j]);
                    }
                    KeRevertToUserAffinityThread ();

                    ExFreePool (PushLockCacheAware);
                    return NULL;
                }
                PaddedPushLock->Single = FALSE;
                ExInitializePushLock (&PaddedPushLock->Lock);
                PushLockCacheAware->Locks[i] = &PaddedPushLock->Lock;
            }
            KeRevertToUserAffinityThread ();
        }
        
    }
    return PushLockCacheAware;
}

NTKERNELAPI
VOID
ExFreeCacheAwarePushLock (
     PEX_PUSH_LOCK_CACHE_AWARE PushLock     
     )
/*++

Routine Description:

    Frees a cache aware (cache friendly) push lock

Arguments:

    PushLock - Cache aware push lock to be freed

Return Value:

    None

--*/
{
    ULONG i;
    ULONG MaxLine;

    if (!CONTAINING_RECORD (PushLock->Locks[0], EX_PUSH_LOCK_CACHE_AWARE_PADDED, Lock)->Single) {
        MaxLine = KeNumberProcessors;
        if (MaxLine > EX_PUSH_LOCK_FANNED_COUNT) {
            MaxLine = EX_PUSH_LOCK_FANNED_COUNT;
        }

        for (i = 0; i < MaxLine; i++) {
            ExFreePool (PushLock->Locks[i]);
        }
    } else {
        ExFreePool (PushLock->Locks[0]);
    }
    ExFreePool (PushLock);
}


NTKERNELAPI
VOID
ExAcquireCacheAwarePushLockExclusive (
     IN PEX_PUSH_LOCK_CACHE_AWARE PushLock
     )
/*++

Routine Description:

    Acquire a cache aware push lock exclusive.

Arguments:

    PushLock - Cache aware push lock to be acquired

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK *Start, *End;
    ULONG MaxLine;

    //
    // Exclusive acquires must obtain all the slots exclusive.
    // Take the first slot exclusive and then we can take the
    // rest of the slots in any order we want.
    // There is no deadlock here. A->B->C does not deadlock with A->C->B.
    //
    Start = &PushLock->Locks[1];
    MaxLine = KeNumberProcessors;
    if (MaxLine > EX_PUSH_LOCK_FANNED_COUNT) {
        MaxLine = EX_PUSH_LOCK_FANNED_COUNT;
    }
    End   = &PushLock->Locks[MaxLine - 1];

    ExAcquirePushLockExclusive (PushLock->Locks[0]);

    while (Start <= End) {
        if (ExTryAcquirePushLockExclusive (*Start)) {
            Start++;
        } else {
            ExAcquirePushLockExclusive (*End);
            End--;
        }
    }
}

NTKERNELAPI
VOID
ExReleaseCacheAwarePushLockExclusive (
     IN PEX_PUSH_LOCK_CACHE_AWARE PushLock
     )
/*++

Routine Description:

    Release a cache aware push lock exclusive.

Arguments:

    PushLock - Cache aware push lock to be released

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK *Start, *End;
    ULONG MaxLine;

    //
    // Release the locks in order
    //

    MaxLine = KeNumberProcessors;
    if (MaxLine > EX_PUSH_LOCK_FANNED_COUNT) {
        MaxLine = EX_PUSH_LOCK_FANNED_COUNT;
    }
    End   = &PushLock->Locks[MaxLine];
    for (Start = &PushLock->Locks[0];
         Start < End;
         Start++) {
        ExReleasePushLockExclusive (*Start);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\raise.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    raise.c

Abstract:

    This module implements routines to raise datatype misalignment and
    access violation for probe code.

    N.B. These routines are provided as function to save space in the
        probe macros.

    N.B. Since these routines are *only* called from the probe macros,
        it is assumed that the calling code is pageable.

Author:

    David N. Cutler (davec) 29-Apr-1995

Environment:

    Kernel mode.

Revision History:

--*/

#include "exp.h"

//
// Define function sections.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ExRaiseAccessViolation)
#pragma alloc_text(PAGE, ExRaiseDatatypeMisalignment)
#endif

VOID
ExRaiseAccessViolation (
    VOID
    )

/*++

Routine Description:

    This function raises an access violation exception.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ExRaiseStatus(STATUS_ACCESS_VIOLATION);
    return;
}

VOID
ExRaiseDatatypeMisalignment (
    VOID
    )

/*++

Routine Description:

    This function raises a datatype misalignment exception.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ExRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\spintrac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    spinlock.c

Abstract:

   This module implements the executive functions to allocate and free spin
   locks.

Author:

    David N. Cutler (davec) 16-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\regtest.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regtest.c

Abstract:

   Test for quick and dirty registry test (very basic)

Author:

    Bryan M. Willman (bryanwi) 30-Apr-1991

Environment:

    User mode.

Revision History:

--*/

#include "stdio.h"
#include "nt.h"

int strlen(PUCHAR);
void main();

VOID DoTest(HANDLE RootKey);

#define MAX_VALUE   256
UCHAR ValueBuffer[MAX_VALUE];

VOID
main()
{
    DbgPrint("Machine\n");
    DoTest((HANDLE)REG_LOCAL_MACHINE);
    DbgPrint("User\n");
    DoTest((HANDLE)REG_LOCAL_USER);
}
VOID
DoTest(
    HANDLE  RootKey
    )
{
    NTSTATUS rc;
    STRING String1;
    UCHAR Value1[] = "This string is value 1.";
    UCHAR Value2[] = "Value 2 is represented by this string.";
    HANDLE Handle1;
    HANDLE Handle2;
    ULONG ValueLength;
    ULONG Type;
    LARGE_INTEGER Time;

    //
    // Create parent node
    //

    DbgPrint("Part1\n");
    RtlInitString(&String1,  "Test1");
    rc = NtCreateKey(
	RootKey,
	&String1,
	0,
	NULL,
	GENERIC_READ|GENERIC_WRITE,
	&Handle1
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("1:CreateKey failed rc  = %08lx", rc);
	return;
    }

    //
    // Set data into parent
    //

    DbgPrint("Part2\n");
    rc = NtSetValueKey(
	Handle1,
	1,		// type
	Value1,
	strlen(Value1)
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("2:SetValueKey failed rc  = %08lx", rc);
	return;
    }

    //
    // Query and compare data from parent
    //

    DbgPrint("Part2b\n");
    ValueLength = MAX_VALUE;
    rc = NtQueryValueKey(
	Handle1,
	&Type,
	ValueBuffer,
	&ValueLength,
	&Time
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("2b:QueryValueKey failed rc  = %08lx", rc);
	return;
    }

    if (ValueLength != (ULONG)strlen(Value1)) {
	DbgPrint("2b1:Wrong value length\n");
	return;
    } else if (RtlCompareMemory(
		ValueBuffer, Value1, ValueLength) != ValueLength) {
	DbgPrint("2b2:Wrong value\n");
	return;
    } else if (Type != 1) {
	DbgPrint("2b3:Wrong type\n");
	return;
    }


    //
    // Close parent
    //

    DbgPrint("Part3\n");
    NtCloseKey(Handle1);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("3:CloseKey failed rc  = %08lx", rc);
	return;
    }


    //
    // Reopen parent
    //

    DbgPrint("Part4\n");
    rc = NtOpenKey(
	RootKey,
	&String1,
	0,
	GENERIC_READ|GENERIC_WRITE,
	&Handle1
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("4:OpenKey failed rc  = %08lx", rc);
	return;
    }

    //
    // Create child
    //

    DbgPrint("Part5\n");
    RtlInitString(&String1,  "Test2");
    rc = NtCreateKey(
	Handle1,
	&String1,
	0,
	NULL,
	GENERIC_READ|GENERIC_WRITE,
	&Handle2
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("5:CreateKey failed rc  = %08lx", rc);
	return;
    }


    //
    // Set data into child
    //

    DbgPrint("Part6\n");
    rc = NtSetValueKey(
	Handle2,
	2,		// type
	Value2,
	strlen(Value2)
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("6:SetValueKey failed rc  = %08lx", rc);
	return;
    }


    //
    // Query and compare data from child
    //

    DbgPrint("Part7\n");
    ValueLength = MAX_VALUE;
    rc = NtQueryValueKey(
	Handle2,
	&Type,
	ValueBuffer,
	&ValueLength,
	&Time
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("7:QueryValueKey failed rc  = %08lx", rc);
	return;
    }

    if (ValueLength != (ULONG)strlen(Value2)) {
	DbgPrint("7.1:Wrong value length\n");
	return;
    } else if (RtlCompareMemory(
		ValueBuffer, Value2, ValueLength) != ValueLength) {
	DbgPrint("7.2:Wrong value\n");
	return;
    } else if (Type != 2) {
	DbgPrint("7.3:Wrong type\n");
	return;
    }


    //
    // Query and compare data from parent again
    //

    DbgPrint("Part8\n");
    ValueLength = MAX_VALUE;
    rc = NtQueryValueKey(
	Handle1,
	&Type,
	ValueBuffer,
	&ValueLength,
	&Time
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("8:QueryValueKey failed rc  = %08lx", rc);
	return;
    }

    if (ValueLength != (ULONG)strlen(Value1)) {
	DbgPrint("8.1:Wrong value length\n");
	return;
    } else if (RtlCompareMemory(
		ValueBuffer, Value1, ValueLength) != ValueLength) {
	DbgPrint("8.2:Wrong value\n");
	return;
    } else if (Type != 1) {
	DbgPrint("8.3:Wrong type\n");
	return;
    }


    //
    // Reset parent data
    //

    DbgPrint("Part9\n");
    rc = NtSetValueKey(
	Handle1,
	1,		// type
	Value2,
	strlen(Value2)
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("9:SetValueKey failed rc  = %08lx", rc);
	return;
    }


    //
    // Query and compare reset data
    //

    DbgPrint("Part10\n");
    ValueLength = MAX_VALUE;
    rc = NtQueryValueKey(
	Handle1,
	&Type,
	ValueBuffer,
	&ValueLength,
	&Time
	);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("10:QueryValueKey failed rc  = %08lx", rc);
	return;
    }

    if (ValueLength != (ULONG)strlen(Value2)) {
	DbgPrint("10.1:Wrong value length\n");
	return;
    } else if (RtlCompareMemory(
		ValueBuffer, Value2, ValueLength) != ValueLength) {
	DbgPrint("10.2:Wrong value\n");
	return;
    } else if (Type != 1) {
	DbgPrint("10.3:Wrong type\n");
	return;
    }

    //
    // Close off handles and return
    //

    DbgPrint("Part11\n");
    rc = NtCloseKey(Handle1);

    if (!NT_SUCCESS(rc)) {
	DbgPrint("11:CloseKey failed rc  = %08lx", rc);
	return;
    }

    DbgPrint("Part12\n");
    rc = NtCloseKey(Handle2);
    if (!NT_SUCCESS(rc)) {
	DbgPrint("12:CloseKey failed rc  = %08lx", rc);
	return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\rundown.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rundown.c

Abstract:

    This module houses routine that do safe rundown of data stuctures.

    The basic principle of these routines is to allow fast protection of a data structure that is torn down
    by a single thread. Threads wishing to access the data structure attempt to obtain rundown protection via
    calling ExAcquireRundownProtection. If this function returns TRUE then accesses are safe until the protected
    thread calls ExReleaseRundownProtection. The single teardown thread calls ExWaitForRundownProtectionRelease
    to mark the rundown structure as being run down and the call will return once all protected threads have
    released their protection references.

    Rundown protection is not a lock. Multiple threads may gain rundown protection at the same time.

    The rundown structure has the following format:

    Bottom bit set   : This is a pointer to a rundown wait block (aligned on at least a word boundary)
    Bottom bit clear : This is a count of the total number of accessors multiplied by 2 granted rundown protection.

Author:

    Neill Clift (NeillC) 18-Apr-2000


Revision History:

--*/

#include "exp.h"

#pragma hdrstop

#ifdef ALLOC_PRAGMA
//  These routines are now marked as NONPAGED because they are being used
//  in the paging path by file system filters.
//#pragma alloc_text(PAGE, ExfAcquireRundownProtection)
//#pragma alloc_text(PAGE, ExfReleaseRundownProtection)
//#pragma alloc_text(PAGE, ExAcquireRundownProtectionEx)
//#pragma alloc_text(PAGE, ExReleaseRundownProtectionEx)
#pragma alloc_text(PAGE, ExfWaitForRundownProtectionRelease)
#pragma alloc_text(PAGE, ExfReInitializeRundownProtection)
#pragma alloc_text(PAGE, ExfInitializeRundownProtection)
#pragma alloc_text(PAGE, ExfRundownCompleted)
#endif

//
// This is a block held on the local stack of the rundown thread.
//
typedef struct _EX_RUNDOWN_WAIT_BLOCK {
    ULONG Count;
    KEVENT WakeEvent;
} EX_RUNDOWN_WAIT_BLOCK, *PEX_RUNDOWN_WAIT_BLOCK;


NTKERNELAPI
VOID
FASTCALL
ExfInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Initialize rundown protection structure

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    RunRef->Count = 0;
}

NTKERNELAPI
VOID
FASTCALL
ExfReInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Reinitialize rundown protection structure after its been rundown

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    PAGED_CODE ();

    ASSERT ((RunRef->Count&EX_RUNDOWN_ACTIVE) != 0);
    InterlockedExchangePointer (&RunRef->Ptr, NULL);
}

NTKERNELAPI
VOID
FASTCALL
ExfRundownCompleted (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++
Routine Description:

    Mark rundown block has having completed rundown so we can wait again safely.

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None
--*/
{
    PAGED_CODE ();

    ASSERT ((RunRef->Count&EX_RUNDOWN_ACTIVE) != 0);
    InterlockedExchangePointer (&RunRef->Ptr, (PVOID) EX_RUNDOWN_ACTIVE);
}

NTKERNELAPI
BOOLEAN
FASTCALL
ExfAcquireRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Reference a rundown block preventing rundown occuring if it hasn't already started
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    BOOLEAN - TRUE - rundown protection was acquired, FALSE - rundown is active or completed

--*/
{
    ULONG_PTR Value, NewValue;

    Value = RunRef->Count;
    do {
        //
        // If rundown has started return with an error
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            return FALSE;
        }

        //
        // Rundown hasn't started yet so attempt to increment the unsage count.
        //
        NewValue = Value + EX_RUNDOWN_COUNT_INC;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            return TRUE;
        }
        //
        // somebody else changed the variable before we did. Either a protection call came and went or rundown was
        // initiated. We just repeat the whole loop again.
        //
        Value = NewValue;
    } while (TRUE);
}

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionEx (
     IN PEX_RUNDOWN_REF RunRef,
     IN ULONG Count
     )
/*++

Routine Description:

    Reference a rundown block preventing rundown occuring if it hasn't already started
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Rundown block to be referenced
    Count  - Number of references to add

Return Value:

    BOOLEAN - TRUE - rundown protection was acquired, FALSE - rundown is active or completed

--*/
{
    ULONG_PTR Value, NewValue;

    Value = RunRef->Count;
    do {
        //
        // If rundown has started return with an error
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            return FALSE;
        }

        //
        // Rundown hasn't started yet so attempt to increment the unsage count.
        //
        NewValue = Value + EX_RUNDOWN_COUNT_INC * Count;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            return TRUE;
        }
        //
        // somebody else changed the variable before we did. Either a protection call came and went or rundown was
        // initiated. We just repeat the whole loop again.
        //
        Value = NewValue;
    } while (TRUE);
}


NTKERNELAPI
VOID
FASTCALL
ExfReleaseRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Dereference a rundown block and wake the rundown thread if we are the last to exit
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Rundown block to have its reference released

Return Value:

    None

--*/
{
    ULONG_PTR Value, NewValue;

    Value = RunRef->Count;
    do {
        //
        // If the block is already marked for rundown then decrement the wait block count and wake the
        // rundown thread if we are the last
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            PEX_RUNDOWN_WAIT_BLOCK WaitBlock;

            //
            // Rundown is active. since we are one of the threads blocking rundown we have the right to follow
            // the pointer and decrement the active count. If we are the last thread then we have the right to
            // wake up the waiter. After doing this we can't touch the data structures again.
            //
            WaitBlock = (PEX_RUNDOWN_WAIT_BLOCK) (Value & (~EX_RUNDOWN_ACTIVE));

            ASSERT (WaitBlock->Count > 0);

            if (InterlockedDecrement ((PLONG)&WaitBlock->Count) == 0) {
                //
                // We are the last thread out. Wake up the waiter.
                //
                KeSetEvent (&WaitBlock->WakeEvent, 0, FALSE);
            }
            return;
        } else {
            //
            // Rundown isn't active. Just try and decrement the count. Some other protector thread way come and/or
            // go as we do this or rundown might be initiated. We detect this because the exchange will fail and
            // we have to retry
            //
            ASSERT (Value >= EX_RUNDOWN_COUNT_INC);

            NewValue = Value - EX_RUNDOWN_COUNT_INC;

            NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                      (PVOID) NewValue,
                                                                      (PVOID) Value);
            if (NewValue == Value) {
                return;
            }
            Value = NewValue;
        }

    } while (TRUE);
}

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionEx (
     IN PEX_RUNDOWN_REF RunRef,
     IN ULONG Count
     )
/*++

Routine Description:

    Dereference a rundown block and wake the rundown thread if we are the last to exit
    This routine is NON-PAGED because it is being called on the paging path.

Arguments:

    RunRef - Rundown block to have its reference released
    Count  - Number of reference to remove

Return Value:

    None

--*/
{
    ULONG_PTR Value, NewValue;

    Value = RunRef->Count;
    do {
        //
        // If the block is already marked for rundown then decrement the wait block count and wake the
        // rundown thread if we are the last
        //
        if (Value & EX_RUNDOWN_ACTIVE) {
            PEX_RUNDOWN_WAIT_BLOCK WaitBlock;

            //
            // Rundown is active. since we are one of the threads blocking rundown we have the right to follow
            // the pointer and decrement the active count. If we are the last thread then we have the right to
            // wake up the waiter. After doing this we can't touch the data structures again.
            //
            WaitBlock = (PEX_RUNDOWN_WAIT_BLOCK) (Value & (~EX_RUNDOWN_ACTIVE));

            ASSERT (WaitBlock->Count >= Count);

            if (InterlockedExchangeAdd ((PLONG)&WaitBlock->Count, -(LONG)Count) == (LONG) Count) {
                //
                // We are the last thread out. Wake up the waiter.
                //
                KeSetEvent (&WaitBlock->WakeEvent, 0, FALSE);
            }
            return;
        } else {
            //
            // Rundown isn't active. Just try and decrement the count. Some other protector thread way come and/or
            // go as we do this or rundown might be initiated. We detect this because the exchange will fail and
            // we have to retry
            //

            ASSERT (Value >= EX_RUNDOWN_COUNT_INC * Count);

            NewValue = Value - EX_RUNDOWN_COUNT_INC * Count;

            NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                      (PVOID) NewValue,
                                                                      (PVOID) Value);
            if (NewValue == Value) {
                return;
            }
            Value = NewValue;
        }

    } while (TRUE);
}

NTKERNELAPI
VOID
FASTCALL
ExfWaitForRundownProtectionRelease (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Wait till all outstanding rundown protection calls have exited

Arguments:

    RunRef - Pointer to a rundown structure

Return Value:

    None

--*/
{
    EX_RUNDOWN_WAIT_BLOCK WaitBlock;
    PKEVENT Event;
    ULONG_PTR Value, NewValue;
    ULONG WaitCount;

    PAGED_CODE ();

    //
    // Fast path. this should be the normal case. If Value is zero then there are no current accessors and we have
    // marked the rundown structure as rundown. If the value is EX_RUNDOWN_ACTIVE then the structure has already
    // been rundown and ExRundownCompleted. This second case allows for callers that might initiate rundown
    // multiple times (like handle table rundown) to have subsequent rundowns become noops.
    //

    Value = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                           (PVOID) EX_RUNDOWN_ACTIVE,
                                                           (PVOID) 0);
    if (Value == 0 || Value == EX_RUNDOWN_ACTIVE) {
        return;
    }

    //
    // Slow path
    //
    Event = NULL;
    do {

        //
        // Extract total number of waiters. Its biased by 2 so we can hanve the rundown active bit.
        //
        WaitCount = (ULONG) (Value >> EX_RUNDOWN_COUNT_SHIFT);

        //
        // If there are some accessors present then initialize and event (once only).
        //
        if (WaitCount > 0 && Event == NULL) {
            Event = &WaitBlock.WakeEvent;
            KeInitializeEvent (Event, SynchronizationEvent, FALSE);
        }
        //
        // Store the wait count in the wait block. Waiting threads will start to decrement this as they exit
        // if our exchange succeeds. Its possible for accessors to come and go between our initial fetch and
        // the interlocked swap. This doesn't matter so long as there is the same number of outstanding accessors
        // to wait for.
        //
        WaitBlock.Count = WaitCount;

        NewValue = ((ULONG_PTR) &WaitBlock) | EX_RUNDOWN_ACTIVE;

        NewValue = (ULONG_PTR) InterlockedCompareExchangePointer (&RunRef->Ptr,
                                                                  (PVOID) NewValue,
                                                                  (PVOID) Value);
        if (NewValue == Value) {
            if (WaitCount > 0) {
                KeWaitForSingleObject (Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);

                ASSERT (WaitBlock.Count == 0);

            }
            return;
        }
        Value = NewValue;

        ASSERT ((Value&EX_RUNDOWN_ACTIVE) == 0);
    } while (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\semphore.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    semphore.c

Abstract:

   This module implements the executive semaphore object. Functions are
   provided to create, open, release, and query semaphore objects.

Author:

    David N. Cutler (davec) 8-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"

//
// Temporary so boost is patchable
//

ULONG ExpSemaphoreBoost = SEMAPHORE_INCREMENT;

//
// Address of semaphore object type descriptor.
//

POBJECT_TYPE ExSemaphoreObjectType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for semaphore objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING ExpSemaphoreMapping = {
    STANDARD_RIGHTS_READ |
        SEMAPHORE_QUERY_STATE,
    STANDARD_RIGHTS_WRITE |
        SEMAPHORE_MODIFY_STATE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    SEMAPHORE_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpSemaphoreInitialization)
#pragma alloc_text(PAGE, NtCreateSemaphore)
#pragma alloc_text(PAGE, NtOpenSemaphore)
#pragma alloc_text(PAGE, NtQuerySemaphore)
#pragma alloc_text(PAGE, NtReleaseSemaphore)
#endif

BOOLEAN
ExpSemaphoreInitialization (
    )

/*++

Routine Description:

    This function creates the semaphore object type descriptor at system
    initialization and stores the address of the object type descriptor
    in local static storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the semaphore object type descriptor is
    successfully created. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Semaphore");

    //
    // Create semaphore object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.InvalidAttributes = OBJ_OPENLINK;
    ObjectTypeInitializer.GenericMapping = ExpSemaphoreMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(KSEMAPHORE);
    ObjectTypeInitializer.ValidAccessMask = SEMAPHORE_ALL_ACCESS;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                (PSECURITY_DESCRIPTOR)NULL,
                                &ExSemaphoreObjectType);

    //
    // If the semaphore object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

NTSTATUS
NtCreateSemaphore (
    IN PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN LONG InitialCount,
    IN LONG MaximumCount
    )

/*++

Routine Description:

    This function creates a semaphore object, sets its initial count to the
    specified value, sets its maximum count to the specified value, and opens
    a handle to the object with the specified desired access.

Arguments:

    SemaphoreHandle - Supplies a pointer to a variable that will receive the
        semaphore object handle.

    DesiredAccess - Supplies the desired types of access for the semaphore
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    InitialCount - Supplies the initial count of the semaphore object.

    MaximumCount - Supplies the maximum count of the semaphore object.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    PVOID Semaphore;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to create a semaphore object. If the probe fails, then return
    // the exception code as the service status. Otherwise return the status
    // value returned by the object insertion routine.
    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(SemaphoreHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if ((MaximumCount <= 0) || (InitialCount < 0) ||
       (InitialCount > MaximumCount)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate semaphore object.
    //

    Status = ObCreateObject(PreviousMode,
                            ExSemaphoreObjectType,
                            ObjectAttributes,
                            PreviousMode,
                            NULL,
                            sizeof(KSEMAPHORE),
                            0,
                            0,
                            (PVOID *)&Semaphore);

    //
    // If the semaphore object was successfully allocated, then initialize
    // the semaphore object and attempt to insert the semaphore object in
    // the current process' handle table.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeSemaphore((PKSEMAPHORE)Semaphore,
                              InitialCount,
                              MaximumCount);

        Status = ObInsertObject(Semaphore,
                                NULL,
                                DesiredAccess,
                                0,
                                (PVOID *)NULL,
                                &Handle);

        //
        // If the semaphore object was successfully inserted in the current
        // process' handle table, then attempt to write the semaphore handle
        // value. If the write attempt fails, then do not report an error.
        // When the caller attempts to access the handle value, an access
        // violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            if (PreviousMode != KernelMode) {
                try {
                    *SemaphoreHandle = Handle;
                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *SemaphoreHandle = Handle;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtOpenSemaphore (
    OUT PHANDLE SemaphoreHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to a semaphore object with the specified
    desired access.

Arguments:

    SemaphoreHandle - Supplies a pointer to a variable that will receive the
        semaphore object handle.

    DesiredAccess - Supplies the desired types of access for the semaphore
        object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    NTSTATUS.

--*/

{

    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;


    //
    // Establish an exception handler, probe the output handle address, and
    // attempt to open a semaphore object. If the probe fails, then return
    // the exception code as the service status. Otherwise return the status
    // value returned by the object open routine.
    //
    // Get previous processor mode and probe output handle address if
    // necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteHandle(SemaphoreHandle);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Open handle to the semaphore object with the specified desired access.
    //

    Status = ObOpenObjectByName(ObjectAttributes,
                                ExSemaphoreObjectType,
                                PreviousMode,
                                NULL,
                                DesiredAccess,
                                NULL,
                                &Handle);

    //
    // If the open was successful, then attempt to write the semaphore
    // object handle value. If the write attempt fails, then do not report
    // an error. When the caller attempts to access the handle value, an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        if (PreviousMode != KernelMode) {
            try {
                *SemaphoreHandle = Handle;
            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            *SemaphoreHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQuerySemaphore (
    IN HANDLE SemaphoreHandle,
    IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    OUT PVOID SemaphoreInformation,
    IN ULONG SemaphoreInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries the state of a semaphore object and returns the
    requested information in the specified record structure.

Arguments:

    SemaphoreHandle - Supplies a handle to a semaphore object.

    SemaphoreInformationClass - Supplies the class of information being
        requested.

    SemaphoreInformation - Supplies a pointer to a record that is to receive
        the requested information.

    SemaphoreInformationLength - Supplies the length of the record that is
        to receive the requested information.

    ReturnLength - Supplies an optional pointer to a variable that will
        receive the actual length of the information that is returned.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Semaphore;
    LONG Count;
    LONG Maximum;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output arguments, reference
    // the semaphore object, and return the specified information. If the probe
    // fails, then return the exception code as the service status. Otherwise
    // return the status value returned by the reference object by handle
    // routine.
    //
    // Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForWriteSmallStructure (SemaphoreInformation,
                                         sizeof(SEMAPHORE_BASIC_INFORMATION),
                                         sizeof(ULONG));

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if (SemaphoreInformationClass != SemaphoreBasicInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (SemaphoreInformationLength != sizeof(SEMAPHORE_BASIC_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       SEMAPHORE_QUERY_STATE,
                                       ExSemaphoreObjectType,
                                       PreviousMode,
                                       &Semaphore,
                                       NULL);

    //
    // If the reference was successful, then read the current state and
    // maximum count of the semaphore object, dereference semaphore object,
    // fill in the information structure, and return the length of the
    // information structure if specified. If the write of the semaphore
    // information or the return length fails, then do not report an error.
    // When the caller accesses the information structure or length an
    // access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Count = KeReadStateSemaphore((PKSEMAPHORE)Semaphore);
        Maximum = ((PKSEMAPHORE)Semaphore)->Limit;
        ObDereferenceObject(Semaphore);

        if (PreviousMode != KernelMode) {
            try {
                ((PSEMAPHORE_BASIC_INFORMATION)SemaphoreInformation)->CurrentCount = Count;
                ((PSEMAPHORE_BASIC_INFORMATION)SemaphoreInformation)->MaximumCount = Maximum;
                if (ARGUMENT_PRESENT(ReturnLength)) {
                    *ReturnLength = sizeof(SEMAPHORE_BASIC_INFORMATION);
                }
            } except(ExSystemExceptionFilter()) {
                NOTHING;
            }
        }
        else {
            ((PSEMAPHORE_BASIC_INFORMATION)SemaphoreInformation)->CurrentCount = Count;
            ((PSEMAPHORE_BASIC_INFORMATION)SemaphoreInformation)->MaximumCount = Maximum;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(SEMAPHORE_BASIC_INFORMATION);
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtReleaseSemaphore (
    IN HANDLE SemaphoreHandle,
    IN LONG ReleaseCount,
    OUT PLONG PreviousCount OPTIONAL
    )

/*++

Routine Description:

    This function releases a semaphore object by adding the specified release
    count to the current value.

Arguments:

    Semaphore - Supplies a handle to a semaphore object.

    ReleaseCount - Supplies the release count that is to be added to the
        current semaphore count.

    PreviousCount - Supplies an optional pointer to a variable that will
        receive the previous semaphore count.

Return Value:

    NTSTATUS.

--*/

{

    LONG Count;
    PVOID Semaphore;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the previous count address if
    // specified, reference the semaphore object, and release the semaphore
    // object. If the probe fails, then return the exception code as the
    // service status. Otherwise return the status value returned by the
    // reference object by handle routine.
    //
    // Get previous processor mode and probe previous count address
    // if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if ((ARGUMENT_PRESENT(PreviousCount)) && (PreviousMode != KernelMode)) {
        try {
            ProbeForWriteLong(PreviousCount);
        } except(ExSystemExceptionFilter()) {
            return GetExceptionCode();
        }
    }

    //
    // Check argument validity.
    //

    if (ReleaseCount <= 0) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference semaphore object by handle.
    //

    Status = ObReferenceObjectByHandle(SemaphoreHandle,
                                       SEMAPHORE_MODIFY_STATE,
                                       ExSemaphoreObjectType,
                                       PreviousMode,
                                       &Semaphore,
                                       NULL);

    //
    // If the reference was successful, then release the semaphore object.
    // If an exception occurs because the maximum count of the semaphore
    // has been exceeded, then dereference the semaphore object and return
    // the exception code as the service status. Otherwise write the previous
    // count value if specified. If the write of the previous count fails,
    // then do not report an error. When the caller attempts to access the
    // previous count value, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {

        //
        // Initialize Count to keep W4 compiler happy.
        //

        Count = 0;

        try {
            PERFINFO_DECLARE_OBJECT(Semaphore);

            Count = KeReleaseSemaphore((PKSEMAPHORE)Semaphore,
                                       ExpSemaphoreBoost,
                                       ReleaseCount,
                                       FALSE);

        } except(ExSystemExceptionFilter()) {
            Status = GetExceptionCode();
        }

        ObDereferenceObject(Semaphore);

        if (NT_SUCCESS(Status) && ARGUMENT_PRESENT(PreviousCount)) {
            if (PreviousMode != KernelMode) {
                try {
                    *PreviousCount = Count;
                } except(ExSystemExceptionFilter()) {
                    NOTHING;
                }
            }
            else {
                *PreviousCount = Count;
            }
        }
    }

    //
    // Return service status.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\sysenv.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    sysenv.c

Abstract:

    This module implements the NT query and set system environment
    variable services.

Author:

    David N. Cutler (davec) 10-Nov-1991

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include <arccodes.h>

#include <ntdddisk.h>


#if defined(EFI_NVRAM_ENABLED)
#include <efi.h>
#include <efiboot.h>

GUID ExpUnknownDeviceGuid = UNKNOWN_DEVICE_GUID;

#endif

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

//
// this may be a bit confusing.  A value [A, F] will have the high
// bit set and one of the middle bits set.  This basically finds the
// alpha value by first narrowing down to those with the high bit set
// [8, F] and then scraping off [8,9]
//
#define GET_EIGHT_SHIFT(_x, _shift) ((_x << _shift) & 0x88888888)
#define HEX_VALUE_CONTAINS_ALPHA(_x) (GET_EIGHT_SHIFT(_x, 0) & \
                                     ( GET_EIGHT_SHIFT(_x, 1) | GET_EIGHT_SHIFT(_x, 2) ))


//
// Signature type
//
typedef union _DISK_SIGNATURE_NEW {
    GUID Guid;          // GPT disk signature
    ULONG Signature;    // MBR disk signature
} DISK_SIGNATURE_NEW, *PDISK_SIGNATURE_NEW;


//
// Define local subroutines.
//

NTSTATUS
ExpSetBootEntry (
    IN LOGICAL CreateNewEntry,
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    );

NTSTATUS
ExpSetDriverEntry (
    IN LOGICAL CreateNewEntry,
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT PULONG Id OPTIONAL
    );

#if defined(EFI_NVRAM_ENABLED)

ULONG
ExpSafeWcslen (
    IN PWSTR String,
    IN PWSTR Max
    );

NTSTATUS
ExpTranslateArcPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    );

NTSTATUS
ExpTranslateEfiPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    );

NTSTATUS
ExpTranslateNtPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    );

LOGICAL
ExpTranslateBootEntryNameToId (
    IN PWSTR Name,
    OUT PULONG Id
    );

LOGICAL
ExpTranslateDriverEntryNameToId (
    IN PWSTR Name,
    OUT PULONG Id
    );

NTSTATUS
ExpTranslateSymbolicLink (
    IN PWSTR LinkName,
    OUT PUNICODE_STRING ResultName
    );

NTSTATUS
ExpVerifyFilePath (
    PFILE_PATH FilePath,
    PUCHAR Max
    );

LOGICAL
ExpIsDevicePathForRemovableMedia (
    EFI_DEVICE_PATH *DevicePath
    );

NTSTATUS
ExpVerifyWindowsOsOptions (
    PWINDOWS_OS_OPTIONS WindowsOsOptions,
    ULONG Length
    );

NTSTATUS
ExpParseArcPathName (
    IN PWSTR ArcName,
    OUT PWSTR *ppDeviceName,
    OUT PWSTR *ppPathName,
    OUT PULONG pDeviceNameCount,
    OUT PBOOLEAN pSignatureFormat
    );

NTSTATUS
ExpParseSignatureName (
    IN PWSTR deviceName,
    IN ULONG deviceNameCount,
    OUT PDISK_SIGNATURE_NEW diskSignature,
    OUT PULONG partitionNumber,
    OUT PULONGLONG partitionStart,
    OUT PULONGLONG partitionSize,
    OUT PBOOLEAN GPTpartition,
    OUT PBOOLEAN longSignature
    );

NTSTATUS
ExpParseEfiPath (
    IN EFI_DEVICE_PATH *pDevicePath,
    OUT HARDDRIVE_DEVICE_PATH **ppHardDriveDP,
    OUT PWSTR *ppPathName,
    OUT PBOOLEAN GPTpartition
    );

NTSTATUS
ExpConvertArcName (
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PWSTR pDeviceName,
    IN PWSTR pPathName,
    IN ULONG DeviceNameCount
    );

NTSTATUS
ExpConvertSignatureName (
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PWSTR pDeviceName,
    IN PWSTR pPathName,
    IN ULONG DeviceNameCount
    );

NTSTATUS
ExpTranslateHexStringToULONG (
    IN PWSTR Name,
    OUT PULONG Number
    );

NTSTATUS
ExpTranslateHexStringToULONGLONG (
    IN PWSTR Name,
    OUT PULONGLONG Number
    );

NTSTATUS
ExpTranslateHexStringToGUID (
    IN PWSTR Name,
    OUT GUID *pGuid
    );

NTSTATUS
ExpCreateOutputEFI (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PDISK_SIGNATURE_NEW pDiskSignature,
    IN PULONG pPartitionNumber,
    IN PULONGLONG pPartitionStart,
    IN PULONGLONG pPartitionSize,
    IN PWSTR pPathName,
    IN BOOLEAN GPTpartition
    );

NTSTATUS
ExpCreateOutputNT (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PUNICODE_STRING pDeviceNameString,
    IN PWSTR pPathName
    );

NTSTATUS
ExpCreateOutputARC (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PUNICODE_STRING pDeviceNameString,
    IN PWSTR pPathName
    );

NTSTATUS
ExpCreateOutputSIGNATURE (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PDISK_SIGNATURE_NEW pDiskSignature,
    IN PULONG pPartitionNumber,
    IN PULONGLONG pPartitionStart,
    IN PULONGLONG pPartitionSize,
    IN PWSTR pPathName,
    IN BOOLEAN GPTpartition
    );

NTSTATUS
ExpFindArcName (
    IN PUNICODE_STRING pDeviceNameString,
    OUT PWSTR *pArcName
    );

NTSTATUS
ExpFindDiskSignature (
    IN PDISK_SIGNATURE_NEW pSignature,
    IN OUT PULONG pPartitionNumber,
    OUT PULONG pDiskNumber,
    OUT PULONGLONG pPartitionStart,
    OUT PULONGLONG pPartitionSize,
    IN BOOLEAN GPTpartition
    );

NTSTATUS
ExpGetPartitionTableInfo (
    IN PWSTR pDeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION_EX *ppDriveLayout
    );

#endif // defined(EFI_NVRAM_ENABLED)

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtQuerySystemEnvironmentValue)
#pragma alloc_text(PAGE, NtSetSystemEnvironmentValue)
#pragma alloc_text(PAGE, NtQuerySystemEnvironmentValueEx)
#pragma alloc_text(PAGE, NtSetSystemEnvironmentValueEx)
#pragma alloc_text(PAGE, NtEnumerateSystemEnvironmentValuesEx)
#pragma alloc_text(PAGE, NtAddBootEntry)
#pragma alloc_text(PAGE, NtDeleteBootEntry)
#pragma alloc_text(PAGE, NtModifyBootEntry)
#pragma alloc_text(PAGE, NtEnumerateBootEntries)
#pragma alloc_text(PAGE, NtQueryBootEntryOrder)
#pragma alloc_text(PAGE, NtSetBootEntryOrder)
#pragma alloc_text(PAGE, NtQueryBootOptions)
#pragma alloc_text(PAGE, NtSetBootOptions)
#pragma alloc_text(PAGE, NtTranslateFilePath)
#pragma alloc_text(PAGE, NtAddDriverEntry)
#pragma alloc_text(PAGE, NtDeleteDriverEntry)
#pragma alloc_text(PAGE, NtModifyDriverEntry)
#pragma alloc_text(PAGE, NtEnumerateDriverEntries)
#pragma alloc_text(PAGE, NtQueryDriverEntryOrder)
#pragma alloc_text(PAGE, NtSetDriverEntryOrder)
#pragma alloc_text(PAGE, ExpSetBootEntry)
#pragma alloc_text(PAGE, ExpSetDriverEntry)
#if defined(EFI_NVRAM_ENABLED)
#pragma alloc_text(PAGE, ExpSafeWcslen)
#pragma alloc_text(PAGE, ExpTranslateArcPath)
#pragma alloc_text(PAGE, ExpTranslateEfiPath)
#pragma alloc_text(PAGE, ExpTranslateNtPath)
#pragma alloc_text(PAGE, ExpTranslateBootEntryNameToId)
#pragma alloc_text(PAGE, ExpTranslateDriverEntryNameToId)
#pragma alloc_text(PAGE, ExpTranslateSymbolicLink)
#pragma alloc_text(PAGE, ExpVerifyFilePath)
#pragma alloc_text(PAGE, ExpVerifyWindowsOsOptions)
#pragma alloc_text(PAGE, ExpParseArcPathName)
#pragma alloc_text(PAGE, ExpParseSignatureName)
#pragma alloc_text(PAGE, ExpParseEfiPath)
#pragma alloc_text(PAGE, ExpConvertArcName)
#pragma alloc_text(PAGE, ExpConvertSignatureName)
#pragma alloc_text(PAGE, ExpTranslateHexStringToULONG)
#pragma alloc_text(PAGE, ExpTranslateHexStringToULONGLONG)
#pragma alloc_text(PAGE, ExpTranslateHexStringToGUID)
#pragma alloc_text(PAGE, ExpCreateOutputEFI)
#pragma alloc_text(PAGE, ExpCreateOutputNT)
#pragma alloc_text(PAGE, ExpCreateOutputARC)
#pragma alloc_text(PAGE, ExpCreateOutputSIGNATURE)
#pragma alloc_text(PAGE, ExpFindArcName)
#pragma alloc_text(PAGE, ExpFindDiskSignature)
#pragma alloc_text(PAGE, ExpGetPartitionTableInfo)
#endif // defined(EFI_NVRAM_ENABLED)
#endif // defined(ALLOC_PRAGMA)

//
// Define maximum size of environment value.
//

#define MAXIMUM_ENVIRONMENT_VALUE 1024

//
// Define query/set environment variable synchronization fast mutex.
//

FAST_MUTEX ExpEnvironmentLock;

#if defined(EFI_NVRAM_ENABLED)
//
// Define vendor GUID for EFI boot/driver variables.
//

GUID EfiBootVariablesGuid = EFI_GLOBAL_VARIABLE;
GUID EfiDriverVariablesGuid = EFI_GLOBAL_VARIABLE;
#endif


NTSTATUS
NtQuerySystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    OUT PWSTR VariableValue,
    IN USHORT ValueLength,
    OUT PUSHORT ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function locates the specified system environment variable and
    returns its value.

    N.B. This service requires the system environment privilege.

Arguments:

    Variable - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable.

    Value - Supplies a pointer to a buffer that receives the value of the
        specified system environment variable.

    ValueLength - Supplies the length of the value buffer in bytes.

    ReturnLength - Supplies an optional pointer to a variable that receives
        the length of the system environment variable value.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_PRIVILEGE_NOT_HELD is returned if the caller does not have the
        privilege to query a system environment variable.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        system environment value or the return length cannot be written,
        or the descriptor or the name of the system environment variable
        cannot be read.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
        for this request to complete.

    STATUS_UNSUCCESSFUL - The specified environment variable could not
        be located.

--*/

{

    ULONG AnsiLength;
    ANSI_STRING AnsiString;
    ARC_STATUS ArcStatus;
    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING UnicodeString;
    PCHAR ValueBuffer;

    //
    // Clear address of ANSI buffer.
    //

    AnsiString.Buffer = NULL;

    //
    // Establish an exception handler and attempt to probe and read the
    // name of the specified system environment variable, and probe the
    // variable value buffer and return length. If the probe or read
    // attempt fails, then return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the string descriptor for the system
            // environment variable name.
            //

            ProbeForReadSmallStructure((PVOID)VariableName,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString = *VariableName;

            //
            // Probe the system environment variable name.
            //

            if (UnicodeString.Length == 0) {
                return STATUS_ACCESS_VIOLATION;
            }

            ProbeForRead((PVOID)UnicodeString.Buffer,
                         UnicodeString.Length,
                         sizeof(WCHAR));

            //
            // Probe the system environment value buffer.
            //

            ProbeForWrite((PVOID)VariableValue, ValueLength, sizeof(WCHAR));

            //
            // If argument is present, probe the return length value.
            //

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUshort(ReturnLength);
            }

            //
            // Check if the current thread has the privilege to query a system
            // environment variable.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

            if (HasPrivilege == FALSE) {
                return(STATUS_PRIVILEGE_NOT_HELD);
            }

        } else {
            UnicodeString = *VariableName;
        }


        //
        // Compute the size of the ANSI variable name, allocate a nonpaged
        // buffer, and convert the specified UNICODE variable name to ANSI.
        //

        AnsiLength = RtlUnicodeStringToAnsiSize(&UnicodeString);
        AnsiString.Buffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, AnsiLength, 'rvnE');
        if (AnsiString.Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        AnsiString.MaximumLength = (USHORT)AnsiLength;
        NtStatus = RtlUnicodeStringToAnsiString(&AnsiString,
                                                &UnicodeString,
                                                FALSE);

        if (NT_SUCCESS(NtStatus) == FALSE) {
            ExFreePool((PVOID)AnsiString.Buffer);
            return NtStatus;
        }

    //
    // If an exception occurs during the read of the variable descriptor,
    // the read of the variable name, the probe of the variable value, or
    // the probe of the return length, then always handle the exception,
    // free the ANSI string buffer if necessary, and return the exception
    // code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (AnsiString.Buffer != NULL) {
            ExFreePool((PVOID)AnsiString.Buffer);
        }

        return GetExceptionCode();
    }

    //
    // Allocate nonpaged pool to receive variable value.
    //

    ValueBuffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, MAXIMUM_ENVIRONMENT_VALUE, 'rvnE');
    if (ValueBuffer == NULL) {
        ExFreePool((PVOID)AnsiString.Buffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get the system environment variable value.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);
    ArcStatus = HalGetEnvironmentVariable(AnsiString.Buffer,
                                          MAXIMUM_ENVIRONMENT_VALUE,
                                          ValueBuffer);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Free the ANSI string buffer used to hold the variable name.
    //

    ExFreePool((PVOID)AnsiString.Buffer);

    //
    // If the specified environment variable was not found, then free
    // the value buffer and return an unsuccessful status.
    //

    if (ArcStatus != ESUCCESS) {
        ExFreePool((PVOID)ValueBuffer);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Establish an exception handler and attempt to write the value of the
    // specified system environment variable. If the write attempt fails,
    // then return the exception code as the service status.
    //

    try {

        //
        // Initialize an ANSI string descriptor, set the maximum length and
        // buffer address for a UNICODE string descriptor, and convert the
        // ANSI variable value to UNICODE.
        //

        RtlInitString(&AnsiString, ValueBuffer);
        UnicodeString.Buffer = (PWSTR)VariableValue;
        UnicodeString.MaximumLength = ValueLength;
        NtStatus = RtlAnsiStringToUnicodeString(&UnicodeString,
                                                &AnsiString,
                                                FALSE);

        //
        // If argument is present, then write the length of the UNICODE
        // variable value.
        //

        if (ARGUMENT_PRESENT(ReturnLength)) {
            *ReturnLength = UnicodeString.Length;
        }

        //
        // Free the value buffer used to hold the variable value.
        //

        ExFreePool((PVOID)ValueBuffer);
        return NtStatus;

    //
    // If an exception occurs during the write of the variable value, or
    // the write of the return length, then always handle the exception
    // and return the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ExFreePool((PVOID)ValueBuffer);
        return GetExceptionCode();
    }
}

NTSTATUS
NtSetSystemEnvironmentValue (
    IN PUNICODE_STRING VariableName,
    IN PUNICODE_STRING VariableValue
    )

/*++

Routine Description:

    This function sets the specified system environment variable to the
    specified value.

    N.B. This service requires the system environment privilege.

Arguments:

    Variable - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable name.

    Value - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable value.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_PRIVILEGE_NOT_HELD is returned if the caller does not have the
        privilege to set a system environment variable.

    STATUS_ACCESS_VIOLATION is returned if the input parameter for the
        system environment variable or value cannot be read.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
        for this request to complete.

--*/

{

    ULONG AnsiLength1;
    ULONG AnsiLength2;
    ANSI_STRING AnsiString1;
    ANSI_STRING AnsiString2;
    ARC_STATUS ArcStatus;
    BOOLEAN HasPrivilege;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString1;
    UNICODE_STRING UnicodeString2;

    //
    // Clear address of ANSI buffers.
    //

    AnsiString1.Buffer = NULL;
    AnsiString2.Buffer = NULL;

    //
    // Establish an exception handler and attempt to set the value of the
    // specified system environment variable. If the read attempt for the
    // system environment variable or value fails, then return the exception
    // code as the service status. Otherwise, return either success or access
    // denied as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the string descriptor for the system
            // environment variable name.
            //

            ProbeForReadSmallStructure((PVOID)VariableName,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString1 = *VariableName;

            //
            // Handle a zero length string explicitly since probing does not,
            // the error code is unusual, but it's what we would have done with
            // the HAL return code too.
            //

            if (UnicodeString1.Length == 0) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Probe the system environment variable name.
            //

            ProbeForRead((PVOID)UnicodeString1.Buffer,
                         UnicodeString1.Length,
                         sizeof(WCHAR));

            //
            // Probe and capture the string descriptor for the system
            // environment variable value.
            //

            ProbeForReadSmallStructure((PVOID)VariableValue,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString2 = *VariableValue;

            //
            // Handle a zero length string explicitly since probing does not
            // the error code is unusual, but it's what we would have done with
            // the HAL return code too.
            //

            if (UnicodeString2.Length == 0) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Probe the system environment variable value.
            //

            ProbeForRead((PVOID)UnicodeString2.Buffer,
                         UnicodeString2.Length,
                         sizeof(WCHAR));

            //
            // Check if the current thread has the privilege to query a system
            // environment variable.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

            if (HasPrivilege == FALSE) {
                return(STATUS_PRIVILEGE_NOT_HELD);
            }

        } else {
            UnicodeString1 = *VariableName;
            UnicodeString2 = *VariableValue;
        }


        //
        // Compute the size of the ANSI variable name, allocate a nonpaged
        // buffer, and convert the specified UNICODE variable name to ANSI.
        //

        AnsiLength1 = RtlUnicodeStringToAnsiSize(&UnicodeString1);
        AnsiString1.Buffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, AnsiLength1, 'rvnE');
        if (AnsiString1.Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        AnsiString1.MaximumLength = (USHORT)AnsiLength1;
        NtStatus = RtlUnicodeStringToAnsiString(&AnsiString1,
                                                &UnicodeString1,
                                                FALSE);

        if (NT_SUCCESS(NtStatus) == FALSE) {
            ExFreePool((PVOID)AnsiString1.Buffer);
            return NtStatus;
        }

        //
        // Compute the size of the ANSI variable value, allocate a nonpaged
        // buffer, and convert the specified UNICODE variable value to ANSI.
        //

        AnsiLength2 = RtlUnicodeStringToAnsiSize(&UnicodeString2);
        AnsiString2.Buffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, AnsiLength2, 'rvnE');
        if (AnsiString2.Buffer == NULL) {
            ExFreePool((PVOID)AnsiString1.Buffer);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        AnsiString2.MaximumLength = (USHORT)AnsiLength2;
        NtStatus = RtlUnicodeStringToAnsiString(&AnsiString2,
                                                &UnicodeString2,
                                                FALSE);

        if (NT_SUCCESS(NtStatus) == FALSE) {
            ExFreePool((PVOID)AnsiString1.Buffer);
            ExFreePool((PVOID)AnsiString2.Buffer);
            return NtStatus;
        }

    //
    // If an exception occurs during the read of the variable descriptor,
    // the read of the variable name, the read of the value descriptor, or
    // the read of the value, then always handle the exception, free the
    // ANSI string buffers if necessary, and return the exception code as
    // the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (AnsiString1.Buffer != NULL) {
            ExFreePool((PVOID)AnsiString1.Buffer);
        }

        if (AnsiString2.Buffer != NULL) {
            ExFreePool((PVOID)AnsiString2.Buffer);
        }

        return GetExceptionCode();
    }

    //
    // Set the system environment variable value.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);
    ArcStatus = HalSetEnvironmentVariable(AnsiString1.Buffer,
                                          AnsiString2.Buffer);
    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Free the ANSI string buffers used to hold the variable name and value.
    //

    ExFreePool((PVOID)AnsiString1.Buffer);
    ExFreePool((PVOID)AnsiString2.Buffer);

    //
    // If the specified value of the specified environment variable was
    // successfully set, then return a success status. Otherwise, return
    // insufficient resources.
    //

    if (ArcStatus == ESUCCESS) {
        return STATUS_SUCCESS;

    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}

NTSTATUS
NtQuerySystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    )

/*++

Routine Description:

    This function locates the specified system environment variable and
    return its value.

    N.B. This service requires the system environment privilege.

Arguments:

    VariableName - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable.

    VendorGuid - Supplies the GUID for the vendor associated with the variable.
        Variables are grouped into namespaces based on their vendor GUIDs. Some
        platforms may not support vendor GUIDs. On these platforms, all
        variables are in a single namespace, and this routine ignores VendorGuid.

    Value - Supplies a pointer to a buffer that receives the value of the
        specified system environment variable.

    ValueLength - On input, supplies the length in bytes of the Value buffer.
        On output, returns the length in bytes of the variable value. If the
        input buffer is large enough, then ValueLength indicates the amount
        of data copied into Value. If the input buffer is too small, then
        nothing is copied into the buffer, and ValueLength indicates the
        required buffer length.

    Attributes - Supplies an optional pointer to a ULONG to receive the
        attributes of the variable.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INSUFFICIENT_RESOURCES Insufficient system resources exist
                                  for this request to complete.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_VARIABLE_NOT_FOUND   The requested variable does not exist.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(VariableName);
    UNREFERENCED_PARAMETER(VendorGuid);
    UNREFERENCED_PARAMETER(Value);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(Attributes);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING UnicodeString;
    PWSTR LocalUnicodeBuffer = NULL;
    GUID LocalGuid;
    PCHAR LockedValueBuffer;
    ULONG LocalValueLength;
    ULONG LocalAttributes;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe and read the name
    // of the specified system environment variable, probe the variable value
    // buffer, probe and read the length argument, and probe the attributes
    // argument. If the probe attempt fails, then return the exception code
    // as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the string descriptor for the system
            // environment variable name.
            //

            ProbeForReadSmallStructure((PVOID)VariableName,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString = *VariableName;

            //
            // Probe the system environment variable name.
            //

            if (UnicodeString.Length == 0) {
                return STATUS_ACCESS_VIOLATION;
            }

            ProbeForRead((PVOID)UnicodeString.Buffer,
                         UnicodeString.Length,
                         sizeof(WCHAR));

            //
            // Probe the vendor GUID.
            //

            ProbeForReadSmallStructure((PVOID)VendorGuid, sizeof(GUID), sizeof(ULONG));

            //
            // Probe and capture the length value.
            //

            ProbeForWriteUlong(ValueLength);

            LocalValueLength = *ValueLength;

            //
            // Probe the system environment value buffer.
            //

            if (!ARGUMENT_PRESENT(Value)) {
                LocalValueLength = 0;
            }

            if (LocalValueLength != 0) {
                ProbeForWrite((PVOID)Value, LocalValueLength, sizeof(UCHAR));
            }

            //
            // If argument is present, probe the attributes parameter.
            //

            if (ARGUMENT_PRESENT(Attributes)) {
                ProbeForWriteUlong(Attributes);
            }

            //
            // Check if the current thread has the privilege to query a system
            // environment variable.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            UnicodeString = *VariableName;
            LocalValueLength = *ValueLength;
            if (!ARGUMENT_PRESENT(Value)) {
                LocalValueLength = 0;
            }
        }

        //
        // Capture the vendor GUID.
        //

        RtlCopyMemory( &LocalGuid, VendorGuid, sizeof(GUID) );

        //
        // Allocate a nonpaged buffer and copy the specified Unicode variable
        // name into that buffer. We do this for two reasons: 1) we need the
        // string to be in nonpaged pool; and 2) the string needs to be null-
        // terminated, and it might not be already.
        //

        LocalUnicodeBuffer = (PWSTR)ExAllocatePoolWithTag(NonPagedPool,
                                                          UnicodeString.Length + sizeof(WCHAR),
                                                          'rvnE');
        if (LocalUnicodeBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(LocalUnicodeBuffer, UnicodeString.Buffer, UnicodeString.Length);
        LocalUnicodeBuffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

    //
    // If an exception occurs during the read of the variable descriptor,
    // the read of the variable name, the read of the vendor GUID, the probe
    // of the variable value, the read of the input length, or the probe
    // of the attributes parameter, then always handle the exception,
    // free the Unicode string buffer if necessary, and return the exception
    // code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (LocalUnicodeBuffer != NULL) {
            ExFreePool((PVOID)LocalUnicodeBuffer);
        }

        return GetExceptionCode();
    }

    //
    // Lock the caller's return value buffer in memory.
    //

    if (LocalValueLength != 0) {
        NtStatus = ExLockUserBuffer(Value,
                                    LocalValueLength,
                                    PreviousMode, 
                                    IoWriteAccess,
                                    &LockedValueBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            ExFreePool((PVOID)LocalUnicodeBuffer);
            return NtStatus;
        }
    } else {
        LockedValueBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Get the system environment variable value.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalGetEnvironmentVariableEx(LocalUnicodeBuffer,
                                           &LocalGuid,
                                           LockedValueBuffer,
                                           &LocalValueLength,
                                           &LocalAttributes);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Free the Unicode string buffer used to hold the variable name.
    //

    ExFreePool((PVOID)LocalUnicodeBuffer);

    //
    // Unlock the value buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // Establish an exception handler and attempt to write the return
    // length and the attributes. If either of the write attempts fail,
    // then return the exception code as the service status.
    //

    try {

        //
        // Write the length of the variable value.
        //

        *ValueLength = LocalValueLength;

        //
        // If argument is present, then write the variable attributes.
        //

        if (ARGUMENT_PRESENT(Attributes)) {
            *Attributes = LocalAttributes;
        }

        return NtStatus;

    //
    // If an exception occurs during the write of the return length or
    // the write of the attributes, then always handle the exception
    // and return the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtQuerySystemEnvironmentValueEx

NTSTATUS
NtSetSystemEnvironmentValueEx (
    IN PUNICODE_STRING VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    )

/*++

Routine Description:

    This function sets the specified system environment variable to the
    specified value.

    N.B. This service requires the system environment privilege.

Arguments:

    VariableName - Supplies a pointer to a UNICODE descriptor for the specified
        system environment variable.

    VendorGuid - Supplies the GUID for the vendor associated with the variable.
        Variables are grouped into namespaces based on their vendor GUIDs. Some
        platforms may not support vendor GUIDs. On these platforms, all
        variables are in a single namespace, and this routine ignores VendorGuid.

    Value - Supplies a pointer to a buffer that contains the new variable value.

    ValueLength - Supplies the length in bytes of the Value buffer.

    Attributes - Supplies the attributes of the variable. The attribute bit
        VARIABLE_ATTRIBUTE_NON_VOLATILE MUST be set.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INSUFFICIENT_RESOURCES Insufficient system resources exist
                                  for this request to complete.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(VariableName);
    UNREFERENCED_PARAMETER(VendorGuid);
    UNREFERENCED_PARAMETER(Value);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(Attributes);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    UNICODE_STRING UnicodeString;
    PWSTR LocalUnicodeBuffer = NULL;
    GUID LocalGuid;
    PCHAR LockedValueBuffer;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe and read the
    // name of the specified system environment variable, probe and read
    // the vendor GUID, and probe the variable value buffer. If the probe
    // attempt fails, then return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the string descriptor for the system
            // environment variable name.
            //

            ProbeForReadSmallStructure((PVOID)VariableName,
                                       sizeof(UNICODE_STRING),
                                       sizeof(ULONG));

            UnicodeString = *VariableName;

            //
            // Probe the system environment variable name.
            //

            if (UnicodeString.Length == 0) {
                return STATUS_ACCESS_VIOLATION;
            }

            ProbeForRead((PVOID)UnicodeString.Buffer,
                         UnicodeString.Length,
                         sizeof(WCHAR));

            //
            // Probe the vendor GUID.
            //

            ProbeForReadSmallStructure((PVOID)VendorGuid, sizeof(GUID), sizeof(ULONG));

            //
            // Probe the system environment value buffer.
            //

            if (!ARGUMENT_PRESENT(Value)) {
                ValueLength = 0;
            }

            if (ValueLength != 0) {
                ProbeForRead((PVOID)Value, ValueLength, sizeof(UCHAR));
            }

            //
            // Check if the current thread has the privilege to set a system
            // environment variable.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            UnicodeString = *VariableName;
            if (!ARGUMENT_PRESENT(Value)) {
                ValueLength = 0;
            }
        }

        //
        // Capture the vendor GUID.
        //

        RtlCopyMemory( &LocalGuid, VendorGuid, sizeof(GUID) );

        //
        // Allocate a nonpaged buffer and copy the specified Unicode variable
        // name into that buffer. We do this for two reasons: 1) we need the
        // string to be in nonpaged pool; and 2) the string needs to be null-
        // terminated, and it might not be already.
        //

        LocalUnicodeBuffer = (PWSTR)ExAllocatePoolWithTag(NonPagedPool,
                                                          UnicodeString.Length + sizeof(WCHAR),
                                                          'rvnE');
        if (LocalUnicodeBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(LocalUnicodeBuffer, UnicodeString.Buffer, UnicodeString.Length);
        LocalUnicodeBuffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

    //
    // If an exception occurs during the read of the variable descriptor,
    // the read of the variable name, the read of the vendor GUID or the probe
    // of the variable value, then always handle the exception, free the Unicode
    // string buffer if necessary, and return the exception code as the status
    // value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (LocalUnicodeBuffer != NULL) {
            ExFreePool((PVOID)LocalUnicodeBuffer);
        }

        return GetExceptionCode();
    }

    //
    // Lock the caller's input value buffer in memory.
    //

    if (ValueLength != 0) {
        NtStatus = ExLockUserBuffer(Value,
                                    ValueLength,
                                    PreviousMode,
                                    IoReadAccess,
                                    &LockedValueBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            ExFreePool((PVOID)LocalUnicodeBuffer);
            return NtStatus;
        }
    } else {
        LockedValueBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Set the system environment variable value.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalSetEnvironmentVariableEx(LocalUnicodeBuffer,
                                           &LocalGuid,
                                           LockedValueBuffer,
                                           ValueLength,
                                           Attributes);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Free the Unicode string buffer used to hold the variable name.
    //

    ExFreePool((PVOID)LocalUnicodeBuffer);

    //
    // Unlock the value buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtSetSystemEnvironmentValueEx

NTSTATUS
NtEnumerateSystemEnvironmentValuesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    This function returns information about system environment variables.

    N.B. This service requires the system environment privilege.

Arguments:

    InformationClass - Specifies the type of information to return.

    Buffer - Supplies the address of the buffer that is to receive the
        returned data. The format of the returned data depends on
        InformationClass.

    BufferLength - On input, supplies the length in bytes of the buffer.
        On output, returns the length in bytes of the returned data.
        If the input buffer is large enough, then BufferLength indicates
        the amount of data copied into Buffer. If the input buffer is too
        small, then BufferLength indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(InformationClass);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PCHAR LockedBuffer;
    ULONG LocalBufferLength;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(BufferLength);

            LocalBufferLength = *BufferLength;

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)Buffer, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to enumerate
            // system environment variables.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *BufferLength;
            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Lock the caller's return buffer in memory.
    //

    if (LocalBufferLength != 0) {
        NtStatus = ExLockUserBuffer(Buffer,
                                    LocalBufferLength,
                                    PreviousMode,
                                    IoWriteAccess,
                                    &LockedBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    } else {
        LockedBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Enumerate the system environment variables.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalEnumerateEnvironmentVariablesEx(InformationClass,
                                                  LockedBuffer,
                                                  &LocalBufferLength);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // Unlock the return buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // Establish an exception handler and attempt to write the return length.
    // If the write attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Write the length of the returned data.
        //

        *BufferLength = LocalBufferLength;
    
        return NtStatus;

    //
    // If an exception occurs during the write of the return length, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtEnumerateSystemEnvironmentValuesEx

NTSTATUS
NtAddBootEntry (
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    )

/*++

Routine Description:

    This function adds a boot entry to the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    BootEntry - Supplies the address of a BOOT_ENTRY that describes the
        new boot entry.

    Id - Supplies the address of a ULONG that is to receive the identifier
        assigned to the new boot entry.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
    return ExpSetBootEntry(TRUE, BootEntry, Id);

} // NtAddBootEntry

NTSTATUS
NtDeleteBootEntry (
    IN ULONG Id
    )

/*++

Routine Description:

    This function deletes an existing boot entry from the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    Id - Supplies the identifier of the boot entry that is to be deleted.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_VARIABLE_NOT_FOUND   The Id specifies a boot entry that does not exist.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Id);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    WCHAR idString[9];
    ULONG length;

    //
    // Verify that the input identifier is in range.
    //

    if (Id > MAXUSHORT) {
        return STATUS_INVALID_PARAMETER;
    }

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Check if the current thread has the privilege to query the
        // system boot order list.
        //

        HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

        if (HasPrivilege == FALSE) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }
    }

    //
    // Verify that the provided identifier exists.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    swprintf( idString, L"Boot%04x", Id);
    length = 0;
    NtStatus = HalGetEnvironmentVariableEx(idString,
                                           &EfiBootVariablesGuid,
                                           NULL,
                                           &length,
                                           NULL);

    //
    // If we did not find the boot entry and the idString
    // contains an alpha character in the hexadecimal string
    // check with an uppder case alpha character.  Efi
    // is case sensitive with respect to the NVRAM 
    // variables
    //
    if ((NtStatus == STATUS_VARIABLE_NOT_FOUND) && HEX_VALUE_CONTAINS_ALPHA(Id)) {
        swprintf( idString, L"Boot%04X", Id);
        length = 0;
        NtStatus = HalGetEnvironmentVariableEx(idString,
                                               &EfiBootVariablesGuid,
                                               NULL,
                                               &length,
                                               NULL);
    }

    if ((NtStatus == STATUS_SUCCESS) || (NtStatus == STATUS_BUFFER_TOO_SMALL)) {

        //
        // Delete the boot entry environment variable by writing a zero length
        // value.
        //

        NtStatus = HalSetEnvironmentVariableEx(idString,
                                               &EfiBootVariablesGuid,
                                               NULL,
                                               0,
                                               VARIABLE_ATTRIBUTE_NON_VOLATILE);
    }

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtDeleteBootEntry

NTSTATUS
NtModifyBootEntry (
    IN PBOOT_ENTRY BootEntry
    )

/*++

Routine Description:

    This function modifies an existing boot entry in the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    BootEntry - Supplies the address of a BOOT_ENTRY that describes the
        modified boot entry. The Id field of this structure specifies the
        boot entry that is to be modified.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_VARIABLE_NOT_FOUND   The Id specifies a boot entry that does not exist.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
    return ExpSetBootEntry(FALSE, BootEntry, NULL);

} // NtModifyBootEntry

NTSTATUS
NtEnumerateBootEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    This function returns a list of all existing boot entries.

    N.B. This service requires the system environment privilege.

Arguments:

    Buffer - Supplies the address of the buffer that is to receive the
        returned data. The returned data is a sequence of BOOT_ENTRY_LIST
        structures.

    BufferLength - On input, supplies the length in bytes of the buffer.
        On output, returns the length in bytes of the returned data.
        If the input buffer is large enough, then BufferLength indicates
        the amount of data copied into Buffer. If the input buffer
        is too small, then BufferLength indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PCHAR LockedBuffer;
    ULONG LocalBufferLength;
    PVOID LockVariable;
    PVARIABLE_NAME_AND_VALUE variableBuffer = NULL;
    ULONG variableBufferLength;
    PBOOT_ENTRY_LIST currentPtr;
    PBOOT_ENTRY_LIST previousEntry;
    ULONG remainingLength;
    LOGICAL filling;
    NTSTATUS fillStatus;
    PVARIABLE_NAME_AND_VALUE variablePtr;
    PWSTR maxVariablePtr;

    //
    // Verify that the input buffer is properly aligned.
    //

    if ( ALIGN_DOWN_POINTER(Buffer, ULONG) != Buffer ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(BufferLength);

            LocalBufferLength = *BufferLength;

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)Buffer, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot entry list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *BufferLength;
            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Lock the caller's return buffer in memory.
    //

    if (LocalBufferLength != 0) {
        NtStatus = ExLockUserBuffer(Buffer,
                                    LocalBufferLength,
                                    PreviousMode,
                                    IoWriteAccess,
                                    &LockedBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    } else {
        LockedBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Initialize variables for filling the output buffer.
    //

    currentPtr = (PBOOT_ENTRY_LIST)LockedBuffer;
    remainingLength = LocalBufferLength;

    filling = (LOGICAL)(remainingLength != 0);
    fillStatus = STATUS_SUCCESS;
    // jamschw: not too small until there is something to put into buffer
    //if ( !filling ) {
    //    fillStatus = STATUS_BUFFER_TOO_SMALL;
    //}

    previousEntry = NULL;

    //
    // Enumerate all existing environment variables.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    variableBufferLength = 0;
    NtStatus = HalEnumerateEnvironmentVariablesEx(VARIABLE_INFORMATION_VALUES,
                                                  NULL,
                                                  &variableBufferLength);
    if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
        variableBufferLength = 0;
    } else {
        variableBuffer = ExAllocatePoolWithTag(NonPagedPool, variableBufferLength, 'rvnE');
        if (variableBuffer == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            NtStatus = HalEnumerateEnvironmentVariablesEx(VARIABLE_INFORMATION_VALUES,
                                                          variableBuffer,
                                                          &variableBufferLength);
        }
    }

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    if ((NtStatus != STATUS_SUCCESS) || (variableBufferLength == 0)) {
        goto done;
    }

    //
    // Each variable whose name is of the form Boot####, where #### is a
    // four-digit hex number, is assumed to define a boot entry. For
    // each such variable, copy its data into the output buffer.
    //

    variablePtr = variableBuffer;
    maxVariablePtr = (PWSTR)variableBuffer + variableBufferLength;

    while (TRUE) {

        ULONG id;

        if ((memcmp(&variablePtr->VendorGuid, &EfiBootVariablesGuid, sizeof(GUID)) == 0) &&
            ExpTranslateBootEntryNameToId(variablePtr->Name, &id) &&
            (variablePtr->ValueLength >= sizeof(EFI_LOAD_OPTION))) {

            PEFI_LOAD_OPTION efiLoadOption;
            ULONG descriptionLength;
            ULONG filePathLength;
            ULONG minimumLength;

            efiLoadOption = ADD_OFFSET(variablePtr, ValueOffset);
            filePathLength = efiLoadOption->FilePathLength;
            descriptionLength = ExpSafeWcslen(efiLoadOption->Description, maxVariablePtr);
            if ( descriptionLength != 0xffffffff ) {
                descriptionLength = (descriptionLength + 1) * sizeof(WCHAR);
            }
            minimumLength = FIELD_OFFSET(EFI_LOAD_OPTION, Description) +
                            descriptionLength +
                            filePathLength;

            if ((descriptionLength != 0xffffffff) &&
                (filePathLength < variablePtr->ValueLength) &&
                (variablePtr->ValueLength >= minimumLength)) {

                EFI_DEVICE_PATH *dp;
                PUCHAR options;
                ULONG optionsLength;
                ULONG actualLength;
                ULONG requiredLength;
                ULONG friendlyNameOffset;
                ULONG bootFilePathOffset;

                dp = (EFI_DEVICE_PATH *)((PUCHAR)efiLoadOption->Description + descriptionLength);
                options = (PUCHAR)dp + filePathLength;
                optionsLength = variablePtr->ValueLength - minimumLength;

                if (ALIGN_UP_POINTER(currentPtr, ULONG) != currentPtr) {
                    PUCHAR alignedPtr = ALIGN_UP_POINTER( currentPtr, ULONG );
                    ULONG fill = (ULONG)(alignedPtr - (PUCHAR)currentPtr);
                    currentPtr = (PBOOT_ENTRY_LIST)alignedPtr;
                    if (remainingLength < fill) {
                        filling = FALSE;
                        remainingLength = 0;
                        fillStatus = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        remainingLength -= fill;
                    }
                }
        
                requiredLength = FIELD_OFFSET(BOOT_ENTRY, OsOptions);
                requiredLength += optionsLength;
                requiredLength = ALIGN_UP(requiredLength, ULONG);

                friendlyNameOffset = requiredLength;
                requiredLength += descriptionLength;
                requiredLength = ALIGN_UP(requiredLength, ULONG);

                bootFilePathOffset = requiredLength;
                requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
                requiredLength += filePathLength;

                actualLength = requiredLength;
                requiredLength += FIELD_OFFSET(BOOT_ENTRY_LIST, BootEntry);

                if (remainingLength < requiredLength) {
        
                    remainingLength = 0;
                    filling = FALSE;
                    fillStatus = STATUS_BUFFER_TOO_SMALL;
        
                } else {
        
                    remainingLength -= requiredLength;
                }

                if ( filling ) {

                    PWCHAR friendlyName;
                    PFILE_PATH bootFilePath;
                    PBOOT_ENTRY bootEntry = &currentPtr->BootEntry;

                    RtlZeroMemory(currentPtr, requiredLength);

                    bootEntry->Version = BOOT_ENTRY_VERSION;
                    bootEntry->Length = actualLength;
                    bootEntry->Id = id;
                    bootEntry->Attributes = 0;
                    if ((efiLoadOption->Attributes & LOAD_OPTION_ACTIVE) != 0) {
                        bootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE;
                    }
                    bootEntry->FriendlyNameOffset = friendlyNameOffset;
                    bootEntry->BootFilePathOffset = bootFilePathOffset;
                    bootEntry->OsOptionsLength = optionsLength;
                    memcpy(bootEntry->OsOptions, options, optionsLength);
                    if (optionsLength > FIELD_OFFSET(WINDOWS_OS_OPTIONS,OsLoadOptions)) {
                        PWINDOWS_OS_OPTIONS windowsOsOptions;
                        windowsOsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;
                        if ((strcmp((char *)windowsOsOptions->Signature,
                                    WINDOWS_OS_OPTIONS_SIGNATURE) == 0) &&
                            NT_SUCCESS(ExpVerifyWindowsOsOptions(windowsOsOptions,
                                                                 optionsLength))) {
                            bootEntry->Attributes |= BOOT_ENTRY_ATTRIBUTE_WINDOWS;
                        }
                    }
                    friendlyName = (PWCHAR)((PUCHAR)bootEntry + friendlyNameOffset);
                    memcpy(friendlyName, efiLoadOption->Description, descriptionLength);
                    bootFilePath = (PFILE_PATH)((PUCHAR)bootEntry + bootFilePathOffset);
                    bootFilePath->Version = FILE_PATH_VERSION;
                    bootFilePath->Length = FIELD_OFFSET(FILE_PATH, FilePath) + filePathLength;
                    bootFilePath->Type = FILE_PATH_TYPE_EFI;
                    memcpy(bootFilePath->FilePath, dp, filePathLength);
                    if (NT_SUCCESS(ExpVerifyFilePath(bootFilePath,
                                                     ADD_OFFSET(bootFilePath, Length))) &&
                        ExpIsDevicePathForRemovableMedia(dp)) {
                        bootEntry->Attributes |= BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA;
                    }

                    if ( previousEntry != NULL ) {
                        previousEntry->NextEntryOffset =
                                    (ULONG)((PUCHAR)currentPtr - (PUCHAR)previousEntry);
                    }
                    previousEntry = currentPtr;
                }

                currentPtr = (PBOOT_ENTRY_LIST)((PUCHAR)currentPtr + requiredLength);
            }
        }

        if (variablePtr->NextEntryOffset == 0) {
            break;
        }
        variablePtr = ADD_OFFSET(variablePtr, NextEntryOffset);
    }

    if ( previousEntry != NULL ) {
        previousEntry->NextEntryOffset = 0;
    }

done:

    //
    // Free allocated pool.
    //

    if (variableBuffer != NULL) {
        ExFreePool(variableBuffer);
    }

    //
    // Unlock the return buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // If the status of service calls is STATUS_SUCCESS, then return the fill
    // status as the final status.
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = fillStatus;
    }

    //
    // Establish an exception handler and attempt to write the return length.
    // If the write attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Write the length of the returned data.
        //

        *BufferLength = (ULONG)((PUCHAR)currentPtr - (PUCHAR)LockedBuffer);
    
        return NtStatus;

    //
    // If an exception occurs during the write of the return length, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtEnumerateBootEntries

NTSTATUS
NtQueryBootEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    )

/*++

Routine Description:

    This function returns the system boot order list.

    N.B. This service requires the system environment privilege.

Arguments:

    Ids - Supplies the address of the buffer that is to receive the
        returned data. The returned data is an array of ULONG boot
        entry identifiers.

    Count - On input, supplies the length in ULONGs of the buffer.
        On output, returns the length in ULONGs of the returned data.
        If the input buffer is large enough, then Count indicates
        the amount of data copied into Buffer. If the input buffer
        is too small, then Count indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Ids);
    UNREFERENCED_PARAMETER(Count);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PCHAR LockedBuffer;
    ULONG LocalBufferLength;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(Count);

            LocalBufferLength = *Count * sizeof(ULONG);

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(Ids)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)Ids, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *Count * sizeof(ULONG);
            if (!ARGUMENT_PRESENT(Ids)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Lock the caller's return buffer in memory.
    //

    if (LocalBufferLength != 0) {
        NtStatus = ExLockUserBuffer(Ids,
                                    LocalBufferLength,
                                    PreviousMode,
                                    IoWriteAccess,
                                    &LockedBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    } else {
        LockedBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // EFI returns USHORT identifiers, which we will need to translate to
    // ULONGs. Cut the buffer length in half to account for this.
    //

    LocalBufferLength /= 2;

    //
    // Query the BootOrder system environment variable.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalGetEnvironmentVariableEx(L"BootOrder",
                                           &EfiBootVariablesGuid,
                                           LockedBuffer,
                                           &LocalBufferLength,
                                           NULL);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // If the API succeeded, translate the returned USHORTs into ULONGs.
    // Do this by converting each USHORT into a ULONG, starting from the
    // end of the array to avoid stomping on needed data.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG count = LocalBufferLength / sizeof(USHORT);
        PUSHORT sp = &((PUSHORT)LockedBuffer)[count - 1];
        PULONG lp = &((PULONG)LockedBuffer)[count - 1];
        while (count > 0) {
            *lp-- = *sp--;
            count--;
        }

    } else if (NtStatus == STATUS_VARIABLE_NOT_FOUND) {

        //
        // The BootOrder variable doesn't exist. This is unusual,
        // but possible. We'll just return an empty list.
        //

        LocalBufferLength = 0;
        NtStatus = STATUS_SUCCESS;
    }

    LocalBufferLength *= 2;

    //
    // Unlock the buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // Establish an exception handler and attempt to write the return length.
    // If the write attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Write the length of the returned data.
        //

        *Count = LocalBufferLength / sizeof(ULONG);

        return NtStatus;

    //
    // If an exception occurs during the write of the return length, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtQueryBootEntryOrder

NTSTATUS
NtSetBootEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    )

/*++

Routine Description:

    This function modifies the system boot order list.

    N.B. This service requires the system environment privilege.

Arguments:

    Ids - Supplies the address of an array that contains the new boot
        entry order list. The data is an array of ULONG identifiers.

    Count - Supplies the length in ULONGs of the Ids array.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Ids);
    UNREFERENCED_PARAMETER(Count);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalBufferLength;
    PUSHORT shortBuffer = NULL;
    ULONG i;

    //
    // Verify that the input buffer is not empty and is not too large.
    // Calculate the length in bytes of the buffer.
    //

    if (Count > MAXULONG/sizeof(ULONG)) {
        return STATUS_INVALID_PARAMETER;
    }

    //    
    // get previous mode, to check to see if current thread has privilege to
    // modify the system driver order list
    //
    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Check if the current thread has the privilege to modify the
        // system boot order list.
        //

        HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

        if (HasPrivilege == FALSE) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }
    }

    //
    // skip to the end if count == 0
    // then all we have to do is write NULL to the variable
    //
    if (Count != 0) {

        LocalBufferLength = Count * sizeof(ULONG);

        //
        // Allocate a nonpaged buffer to hold the USHORT versions of the IDs.
        //

        shortBuffer = ExAllocatePoolWithTag(NonPagedPool, Count * sizeof(USHORT), 'rvnE');
        if (shortBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // check previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {
                
            //
            // Establish an exception handler and attempt to probe the input buffer.
            // If the probe attempt fails, then return the exception code as the
            // service status.
            //

            try {

                //
                // Probe the input buffer.
                //

                ProbeForRead((PVOID)Ids, LocalBufferLength, sizeof(ULONG));
            
            } 
            //
            // If an exception occurs during the probe of the input buffer, then
            // always handle the exception and return the exception code as the
            // status value.
            //
            except (EXCEPTION_EXECUTE_HANDLER) {
                  ExFreePool(shortBuffer);
                  return GetExceptionCode();
            }
        }

        //
        // Truncate the ULONGs in the input buffer into USHORTs in
        // the local buffer.
        //

        for ( i = 0; i < Count; i++ ) {
            if (Ids[i] > MAXUSHORT) {
                ExFreePool(shortBuffer);
                return STATUS_INVALID_PARAMETER;
            }
            shortBuffer[i] = (USHORT)Ids[i];
        }
    }

    //
    // Set the BootOrder system environment variable.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalSetEnvironmentVariableEx(L"BootOrder",
                                           &EfiBootVariablesGuid,
                                           shortBuffer,
                                           Count * sizeof(USHORT),
                                           VARIABLE_ATTRIBUTE_NON_VOLATILE);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // It is possible for this variable to not exist.  If we have 
    // something to write, then the BootOrder variable will be
    // created.  However, if it has already been deleted and we 
    // attempt to delete it again, the above call will return 
    // STATUS_VARIABLE_NOT_FOUND.  This is still a success since the
    // variable will not exist once the above routine returns.
    //
    if (NtStatus == STATUS_VARIABLE_NOT_FOUND) {
        NtStatus = STATUS_SUCCESS;
    }

    if (shortBuffer) {
        ExFreePool(shortBuffer);
    }

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtSetBootEntryOrder

NTSTATUS
NtQueryBootOptions (
    OUT PBOOT_OPTIONS BootOptions,
    IN OUT PULONG BootOptionsLength
    )

/*++

Routine Description:

    This function returns the system's global boot options.

    N.B. This service requires the system environment privilege.

Arguments:

    BootOptions - Supplies the address of the buffer that is to receive the
        returned data.

    BootOptionsLength - On input, supplies the length in bytes of the buffer.
        On output, returns the length in bytes of the returned data.
        If the input buffer is large enough, then BootOptionsLength indicates
        the amount of data copied into BootOptions. If the input buffer
        is too small, then BootOptionsLength indicates the required buffer
        length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(BootOptions);
    UNREFERENCED_PARAMETER(BootOptionsLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalBufferLength;
    ULONG Timeout = 0;
    ULONG BootCurrent = 0;
    ULONG BootNext = 0;
    ULONG VariableLength;
    ULONG requiredLength;

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(BootOptionsLength);

            LocalBufferLength = *BootOptionsLength;

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(BootOptions)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)BootOptions, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *BootOptionsLength;
            if (!ARGUMENT_PRESENT(BootOptions)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Verify that the input buffer is big enough. IA64 always returns
    // HeadlessRedirection as a null string, so we know the required
    // length up front.
    //

    requiredLength = FIELD_OFFSET(BOOT_OPTIONS,HeadlessRedirection) + sizeof(WCHAR);

    if (LocalBufferLength < requiredLength) {
        NtStatus = STATUS_BUFFER_TOO_SMALL;
        goto done;
    }

    //
    // Query the following system environment variables: Timeout, BootCurrent,
    // and BootNext.
    //
    // NB: Some machines seem to have their Timeout variable set as a ULONG
    // instead of a USHORT. Since we have ULONG buffers for the variables that
    // we're querying, we'll pass in the full length of the buffer, even though
    // we only expect to get back a USHORT. And we'll also be prepared for an
    // even bigger variable to exist. If the variable is bigger, then we'll
    // return a default value for the variable.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    VariableLength = 4;
    NtStatus = HalGetEnvironmentVariableEx(L"Timeout",
                                           &EfiBootVariablesGuid,
                                           &Timeout,
                                           &VariableLength,
                                           NULL);

    switch (NtStatus) {
    
    case STATUS_SUCCESS:
        if (VariableLength > 2) {
            if (Timeout == 0xffffffff) {
                Timeout = 0xffff;
            } else if (Timeout > 0xffff) {
                Timeout = 0xfffe;
            }
        }
        if ( Timeout == 0xffff ) {
            Timeout = 0xffffffff;
        }
        break;

    case STATUS_VARIABLE_NOT_FOUND:
        Timeout = 0xffffffff;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        Timeout = 0xfffffffe;
        break;

    default:
        goto done_unlock;
    }

    VariableLength = 4;
    NtStatus = HalGetEnvironmentVariableEx(L"BootCurrent",
                                           &EfiBootVariablesGuid,
                                           &BootCurrent,
                                           &VariableLength,
                                           NULL);

    switch (NtStatus) {
    
    case STATUS_SUCCESS:
        if (VariableLength > 2) {
            BootCurrent &= 0xffff;
        }
        break;

    case STATUS_VARIABLE_NOT_FOUND:
    case STATUS_BUFFER_TOO_SMALL:
        BootCurrent = 0xfffffffe;
        break;

    default:
        goto done_unlock;
    }

    VariableLength = 2;
    NtStatus = HalGetEnvironmentVariableEx(L"BootNext",
                                           &EfiBootVariablesGuid,
                                           &BootNext,
                                           &VariableLength,
                                           NULL);

    switch (NtStatus) {
    
    case STATUS_SUCCESS:
        if (VariableLength > 2) {
            BootNext &= 0xffff;
        }
        break;

    case STATUS_VARIABLE_NOT_FOUND:
    case STATUS_BUFFER_TOO_SMALL:
        BootNext = 0xfffffffe;
        NtStatus = STATUS_SUCCESS;
        break;

    default:
        goto done_unlock;
    }

done_unlock:

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

done:

    //
    // Establish an exception handler and attempt to write the output buffer
    // and the return length. If the write attempt fails, then return the
    // exception code as the service status.
    //

    try {

        //
        // Write the output buffer.
        //

        if ((NtStatus == STATUS_SUCCESS) && ARGUMENT_PRESENT(BootOptions)) {
            BootOptions->Version = BOOT_OPTIONS_VERSION;
            BootOptions->Length = (FIELD_OFFSET(BOOT_OPTIONS,HeadlessRedirection) + sizeof(WCHAR));
            BootOptions->Timeout = Timeout;
            BootOptions->CurrentBootEntryId = BootCurrent;
            BootOptions->NextBootEntryId = BootNext;
            BootOptions->HeadlessRedirection[0] = 0;
        }

        //
        // Write the return length.
        //

        *BootOptionsLength = requiredLength;

        return NtStatus;

    //
    // If an exception occurs during the write of the return data, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtQueryBootOptions

NTSTATUS
NtSetBootOptions (
    IN PBOOT_OPTIONS BootOptions,
    IN ULONG FieldsToChange
    )

/*++

Routine Description:

    This function modifies the system's global boot options.

    N.B. This service requires the system environment privilege.

Arguments:

    BootOptions - Supplies the address of the buffer that contains the new
        boot options.

    FieldsToChange - Supplies a bit mask indicating with fields in BootOptions
        are to be used to modify global boot options.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(BootOptions);
    UNREFERENCED_PARAMETER(FieldsToChange);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalBufferLength;
    ULONG Timeout = 0;
    ULONG BootNext = 0;

    //
    // Establish an exception handler and attempt to probe and validate the
    // input buffer. If the probe attempt fails, then return the exception
    // code as the service status.
    //

    try {

        //
        // Verify that the input buffer is big enough. It must extend at
        // least to the HeadlessRedirection field.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            LocalBufferLength = ProbeAndReadUlong(&BootOptions->Length);
        } else {
            LocalBufferLength = BootOptions->Length;
        }

        if (LocalBufferLength < FIELD_OFFSET(BOOT_OPTIONS,HeadlessRedirection)) {
            return STATUS_INVALID_PARAMETER;
        }
    
        //
        // Get previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {

            //
            // Probe the input buffer.
            //

            ProbeForRead((PVOID)BootOptions, LocalBufferLength, sizeof(ULONG));

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        //
        // Verify the structure version.
        //

        if ((BootOptions->Version == 0) ||
            (BootOptions->Version > BOOT_OPTIONS_VERSION)) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Capture the Timeout and BootNext fields.
        //

        Timeout = BootOptions->Timeout;
        BootNext = BootOptions->NextBootEntryId;

    //
    // If an exception occurs during the probe and capture of the input buffer,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // If requested, set the Timeout and BootNext system environment variables.
    //

    if ((FieldsToChange & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID) != 0) {
        if (BootNext > MAXUSHORT) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = STATUS_SUCCESS;

    if ((FieldsToChange & BOOT_OPTIONS_FIELD_TIMEOUT) != 0) {

        if (Timeout == 0xffffffff) {
            Timeout = 0xffff;
        } else if (Timeout > 0xfffe) {
            Timeout = 0xfffe;
        }

        NtStatus = HalSetEnvironmentVariableEx(L"Timeout",
                                               &EfiBootVariablesGuid,
                                               &Timeout,
                                               2,
                                               VARIABLE_ATTRIBUTE_NON_VOLATILE);
    }

    if (NT_SUCCESS(NtStatus) &&
        ((FieldsToChange & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID) != 0)) {

        NtStatus = HalSetEnvironmentVariableEx(L"BootNext",
                                               &EfiBootVariablesGuid,
                                               &BootNext,
                                               2,
                                               VARIABLE_ATTRIBUTE_NON_VOLATILE);
    }

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtSetBootOptions

/* The functions below deal with EFI driver options */

NTSTATUS
NtQueryDriverEntryOrder (
    OUT PULONG Ids,
    IN OUT PULONG Count
    )

/*++

Routine Description:

    This function returns the system driver order list.

    N.B. This service requires the system environment privilege.

Arguments:

    Ids - Supplies the address of the buffer that is to receive the
        returned data. The returned data is an array of ULONG driver
        entry identifiers.

    Count - On input, supplies the length in ULONGs of the buffer.
        On output, returns the length in ULONGs of the returned data.
        If the input buffer is large enough, then Count indicates
        the amount of data copied into Buffer. If the input buffer
        is too small, then Count indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Ids);
    UNREFERENCED_PARAMETER(Count);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PCHAR LockedBuffer;
    ULONG LocalBufferLength;
    PVOID LockVariable;

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(Count);

            LocalBufferLength = *Count * sizeof(ULONG);

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(Ids)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)Ids, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system driver order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *Count * sizeof(ULONG);
            if (!ARGUMENT_PRESENT(Ids)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Lock the caller's return buffer in memory.
    //

    if (LocalBufferLength != 0) {
        NtStatus = ExLockUserBuffer(Ids,
                                    LocalBufferLength,
                                    PreviousMode,
                                    IoWriteAccess,
                                    &LockedBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    } else {
        LockedBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // EFI returns USHORT identifiers, which we will need to translate to
    // ULONGs. Cut the buffer length in half to account for this.
    //

    LocalBufferLength /= 2;

    //
    // Query the DriverOrder system environment variable.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalGetEnvironmentVariableEx(L"DriverOrder",
                                           &EfiDriverVariablesGuid,
                                           LockedBuffer,
                                           &LocalBufferLength,
                                           NULL);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();
    
    //
    // If the API succeeded, translate the returned USHORTs into ULONGs.
    // Do this by converting each USHORT into a ULONG, starting from the
    // end of the array to avoid stomping on needed data.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG count = LocalBufferLength / sizeof(USHORT);
        PUSHORT sp = &((PUSHORT)LockedBuffer)[count - 1];
        PULONG lp = &((PULONG)LockedBuffer)[count - 1];
        while (count > 0) {
            *lp-- = *sp--;
            count--;
        }

    } else if (NtStatus == STATUS_VARIABLE_NOT_FOUND) {

        //
        // The DriverOrder variable doesn't exist. This is unusual,
        // but possible. We'll just return an empty list.
        //

        LocalBufferLength = 0;
        NtStatus = STATUS_SUCCESS;
    }

    LocalBufferLength *= 2;

    //
    // Unlock the buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // Establish an exception handler and attempt to write the return length.
    // If the write attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Write the length of the returned data.
        //

        *Count = LocalBufferLength / sizeof(ULONG);

        return NtStatus;

    //
    // If an exception occurs during the write of the return length, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtQueryDriverEntryOrder


NTSTATUS
NtAddDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT PULONG Id OPTIONAL
    )

/*++

Routine Description:

    This function adds a driver entry to the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    DriverEntry - Supplies the address of a DRIVER_ENTRY that describes the
        new driver entry.

    Id - Supplies the address of a ULONG that is to receive the identifier
        assigned to the new driver entry.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
    return ExpSetDriverEntry(TRUE, DriverEntry, Id);

} // NtAddDriverEntry

NTSTATUS
NtDeleteDriverEntry (
    IN ULONG Id
    )

/*++

Routine Description:

    This function deletes an existing driver entry from the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    Id - Supplies the identifier of the driver entry that is to be deleted.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_VARIABLE_NOT_FOUND   The Id specifies a driver entry that does not exist.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Id);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    WCHAR idString[11];
    ULONG length;

    //
    // Verify that the input identifier is in range.
    //

    if (Id > MAXUSHORT) {
        return STATUS_INVALID_PARAMETER;
    }

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {

        //
        // Check if the current thread has the privilege to query the
        // system driver order list.
        //

        HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

        if (HasPrivilege == FALSE) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }
    }

    //
    // Verify that the provided identifier exists.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    swprintf( idString, L"Driver%04x", Id);
    length = 0;
    NtStatus = HalGetEnvironmentVariableEx(idString,
                                           &EfiDriverVariablesGuid,
                                           NULL,
                                           &length,
                                           NULL);

    //
    // If we did not find the driver entry and the idString
    // contains an alpha character in the hexadecimal string
    // check with an uppder case alpha character.  Efi
    // is case sensitive with respect to the NVRAM 
    // variables
    //
    if ((NtStatus == STATUS_VARIABLE_NOT_FOUND) && HEX_VALUE_CONTAINS_ALPHA(Id)) {
        swprintf( idString, L"Driver%04X", Id);
        length = 0;
        NtStatus = HalGetEnvironmentVariableEx(idString,
                                               &EfiDriverVariablesGuid,
                                               NULL,
                                               &length,
                                               NULL);
    }    

    if ((NtStatus == STATUS_SUCCESS) || (NtStatus == STATUS_BUFFER_TOO_SMALL)) {

        //
        // Delete the driver entry environment variable by writing a zero length
        // value.
        //

        NtStatus = HalSetEnvironmentVariableEx(idString,
                                               &EfiDriverVariablesGuid,
                                               NULL,
                                               0,
                                               VARIABLE_ATTRIBUTE_NON_VOLATILE);
    }

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtDeleteDriverEntry

NTSTATUS
NtModifyDriverEntry (
    IN PEFI_DRIVER_ENTRY DriverEntry
    )

/*++

Routine Description:

    This function modifies an existing driver entry in the system environment.

    N.B. This service requires the system environment privilege.

Arguments:

    DriverEntry - Supplies the address of a EFI_DRIVER_ENTRY that describes the
        modified driver entry. The Id field of this structure specifies the
        driver entry that is to be modified.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_VARIABLE_NOT_FOUND   The Id specifies a driver entry that does not exist.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
    return ExpSetDriverEntry(FALSE, DriverEntry, NULL);

} // NtModifyDriverEntry

NTSTATUS
NtEnumerateDriverEntries (
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    This function returns a list of all existing driver entries.

    N.B. This service requires the system environment privilege.

Arguments:

    Buffer - Supplies the address of the buffer that is to receive the
        returned data. The returned data is a sequence of EFI_DRIVER_ENTRY_LIST
        structures.

    BufferLength - On input, supplies the length in bytes of the buffer.
        On output, returns the length in bytes of the returned data.
        If the input buffer is large enough, then BufferLength indicates
        the amount of data copied into Buffer. If the input buffer
        is too small, then BufferLength indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PCHAR LockedBuffer;
    ULONG LocalBufferLength;
    PVOID LockVariable;
    PVARIABLE_NAME_AND_VALUE variableBuffer = NULL;
    ULONG variableBufferLength;
    PEFI_DRIVER_ENTRY_LIST currentPtr;
    PEFI_DRIVER_ENTRY_LIST previousEntry;
    ULONG remainingLength;
    LOGICAL filling;
    NTSTATUS fillStatus;
    PVARIABLE_NAME_AND_VALUE variablePtr;
    PWSTR maxVariablePtr;

    //
    // Verify that the input buffer is properly aligned.
    //

    if ( ALIGN_DOWN_POINTER(Buffer, ULONG) != Buffer ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Establish an exception handler and attempt to probe the return buffer
    // and probe and read the buffer length. If the probe attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe arguments if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            //
            // Probe and capture the input buffer length.
            //

            ProbeForWriteUlong(BufferLength);

            LocalBufferLength = *BufferLength;

            //
            // Probe the return buffer.
            //

            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }

            if (LocalBufferLength != 0) {
                ProbeForWrite((PVOID)Buffer, LocalBufferLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system driver entry list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            LocalBufferLength = *BufferLength;
            if (!ARGUMENT_PRESENT(Buffer)) {
                LocalBufferLength = 0;
            }
        }

    //
    // If an exception occurs during the probe of the return buffer or the
    // read of the input length, then always handle the exception and return
    // the exception code as the status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Lock the caller's return buffer in memory.
    //

    if (LocalBufferLength != 0) {
        NtStatus = ExLockUserBuffer(Buffer,
                                    LocalBufferLength,
                                    PreviousMode,
                                    IoWriteAccess,
                                    &LockedBuffer,
                                    &LockVariable);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    } else {
        LockedBuffer = NULL;
        LockVariable = NULL;
    }

    //
    // Initialize variables for filling the output buffer.
    //

    currentPtr = (PEFI_DRIVER_ENTRY_LIST)LockedBuffer;
    remainingLength = LocalBufferLength;

    fillStatus = STATUS_SUCCESS;
    filling = (LOGICAL)(remainingLength != 0);
    
    // jamschw: not too small until there is something to put into buffer
    //if ( !filling ) {
    //    fillStatus = STATUS_BUFFER_TOO_SMALL;
    //}

    previousEntry = NULL;

    //
    // Enumerate all existing environment variables.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    variableBufferLength = 0;
    NtStatus = HalEnumerateEnvironmentVariablesEx(VARIABLE_INFORMATION_VALUES,
                                                  NULL,
                                                  &variableBufferLength);
    if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
        variableBufferLength = 0;
    } else {
        variableBuffer = ExAllocatePoolWithTag(NonPagedPool, variableBufferLength, 'rvnE');
        if (variableBuffer == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            NtStatus = HalEnumerateEnvironmentVariablesEx(VARIABLE_INFORMATION_VALUES,
                                                          variableBuffer,
                                                          &variableBufferLength);
        }
    }
    

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    if ((NtStatus != STATUS_SUCCESS) || (variableBufferLength == 0)) {
        goto done;
    }

    //
    // Each variable whose name is of the form Driver####, where #### is a
    // four-digit hex number, is assumed to define a driver entry. For
    // each such variable, copy its data into the output buffer.
    //

    variablePtr = variableBuffer;
    maxVariablePtr = (PWSTR)variableBuffer + variableBufferLength;

    while (TRUE) {

        ULONG id;

        if ((memcmp(&variablePtr->VendorGuid, &EfiDriverVariablesGuid, sizeof(GUID)) == 0) &&
            ExpTranslateDriverEntryNameToId(variablePtr->Name, &id) &&
            (variablePtr->ValueLength >= sizeof(EFI_LOAD_OPTION))) {

            PEFI_LOAD_OPTION efiLoadOption;
            ULONG descriptionLength;
            ULONG filePathLength;
            ULONG minimumLength;

            efiLoadOption = ADD_OFFSET(variablePtr, ValueOffset);
            filePathLength = efiLoadOption->FilePathLength;
            descriptionLength = ExpSafeWcslen(efiLoadOption->Description, maxVariablePtr);
            if ( descriptionLength != 0xffffffff ) {
                descriptionLength = (descriptionLength + 1) * sizeof(WCHAR);
            }
            minimumLength = FIELD_OFFSET(EFI_LOAD_OPTION, Description) +
                descriptionLength +
                filePathLength;

            if ((descriptionLength != 0xffffffff) &&
                (filePathLength < variablePtr->ValueLength) &&
                (variablePtr->ValueLength >= minimumLength)) {

                EFI_DEVICE_PATH *dp;
                PUCHAR options;
                ULONG optionsLength;
                ULONG actualLength;
                ULONG requiredLength;
                ULONG friendlyNameOffset;
                ULONG driverFilePathOffset;

                dp = (EFI_DEVICE_PATH *)((PUCHAR)efiLoadOption->Description + descriptionLength);
                options = (PUCHAR)dp + filePathLength;
                optionsLength = variablePtr->ValueLength - minimumLength;

                if (ALIGN_UP_POINTER(currentPtr, ULONG) != currentPtr) {
                    PUCHAR alignedPtr = ALIGN_UP_POINTER( currentPtr, ULONG );
                    ULONG fill = (ULONG)(alignedPtr - (PUCHAR)currentPtr);
                    currentPtr = (PEFI_DRIVER_ENTRY_LIST)alignedPtr;
                    if (remainingLength < fill) {
                        filling = FALSE;
                        remainingLength = 0;
                        fillStatus = STATUS_BUFFER_TOO_SMALL;
                    } else {
                        remainingLength -= fill;
                    }
                }
        
                requiredLength = ALIGN_UP(sizeof(EFI_DRIVER_ENTRY), ULONG);

                friendlyNameOffset = requiredLength;
                requiredLength += descriptionLength;
                requiredLength = ALIGN_UP(requiredLength, ULONG);

                driverFilePathOffset = requiredLength;
                requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
                requiredLength += filePathLength;

                actualLength = requiredLength;
                requiredLength += FIELD_OFFSET(EFI_DRIVER_ENTRY_LIST, DriverEntry);

                if (remainingLength < requiredLength) {
        
                    remainingLength = 0;
                    filling = FALSE;
                    fillStatus = STATUS_BUFFER_TOO_SMALL;
        
                } else {
        
                    remainingLength -= requiredLength;
                }

                if ( filling ) {

                    PWCHAR friendlyName;
                    PFILE_PATH driverFilePath;
                    PEFI_DRIVER_ENTRY driverEntry = &currentPtr->DriverEntry;

                    RtlZeroMemory(currentPtr, requiredLength);

                    driverEntry->Version = EFI_DRIVER_ENTRY_VERSION;
                    driverEntry->Length = actualLength;
                    driverEntry->Id = id;

                    driverEntry->FriendlyNameOffset = friendlyNameOffset;
                    driverEntry->DriverFilePathOffset = driverFilePathOffset;

                    friendlyName = (PWCHAR)((PUCHAR)driverEntry + friendlyNameOffset);
                    memcpy(friendlyName, efiLoadOption->Description, descriptionLength);
                    driverFilePath = (PFILE_PATH)((PUCHAR)driverEntry + driverFilePathOffset);
                    driverFilePath->Version = FILE_PATH_VERSION;
                    driverFilePath->Length = FIELD_OFFSET(FILE_PATH, FilePath) + filePathLength;
                    driverFilePath->Type = FILE_PATH_TYPE_EFI;
                    memcpy(driverFilePath->FilePath, dp, filePathLength);

                    if ( previousEntry != NULL ) {
                        previousEntry->NextEntryOffset =
                                       (ULONG)((PUCHAR)currentPtr - (PUCHAR)previousEntry);
                    }
                    previousEntry = currentPtr;
                }

                currentPtr = (PEFI_DRIVER_ENTRY_LIST)((PUCHAR)currentPtr + requiredLength);
            }
        }

        if (variablePtr->NextEntryOffset == 0) {
            break;
        }
        variablePtr = ADD_OFFSET(variablePtr, NextEntryOffset);
    }

    if ( previousEntry != NULL ) {
        previousEntry->NextEntryOffset = 0;
    }

done:

    //
    // Free allocated pool.
    //

    if (variableBuffer != NULL) {
        ExFreePool(variableBuffer);
    }

    //
    // Unlock the return buffer.
    //

    if (LockVariable != NULL) {
        ExUnlockUserBuffer(LockVariable);
    }

    //
    // If the status of service calls is STATUS_SUCCESS, then return the fill
    // status as the final status.
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = fillStatus;
    }

    //
    // Establish an exception handler and attempt to write the return length.
    // If the write attempt fails, then return the exception code as the
    // service status.
    //

    try {

        //
        // Write the length of the returned data.
        //

        *BufferLength = (ULONG)((PUCHAR)currentPtr - (PUCHAR)LockedBuffer);

        return NtStatus;

    //
    // If an exception occurs during the write of the return length, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtEnumerateDriverEntries


NTSTATUS
NtSetDriverEntryOrder (
    IN PULONG Ids,
    IN ULONG Count
    )

/*++

Routine Description:

    This function modifies the system driver order list.

    N.B. This service requires the system environment privilege.

Arguments:

    Ids - Supplies the address of an array that contains the new driver
        entry order list. The data is an array of ULONG identifiers.

    Count - Supplies the length in ULONGs of the Ids array.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(Ids);
    UNREFERENCED_PARAMETER(Count);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    ULONG LocalBufferLength;
    PUSHORT shortBuffer = NULL;
    ULONG i;

    //
    // Verify that the input buffer is not empty and is not too large.
    // Calculate the length in bytes of the buffer.
    //

    if (Count > MAXULONG/sizeof(ULONG)) {
        return STATUS_INVALID_PARAMETER;
    }

    //    
    // get previous mode, to check to see if current thread has privilege to
    // modify the system driver order list
    //
    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        
        //
        // Check if the current thread has the privilege to modify the
        // system boot order list.
        //
        
        HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                              PreviousMode);

        if (HasPrivilege == FALSE) {
            return STATUS_PRIVILEGE_NOT_HELD;
        }
    }


    //
    // skip to the end if count == 0
    // then all we have to do is write NULL to the variable
    //
    if (Count != 0) {

        LocalBufferLength = Count * sizeof(ULONG);

        //
        // Allocate a nonpaged buffer to hold the USHORT versions of the IDs.
        //

        shortBuffer = ExAllocatePoolWithTag(NonPagedPool, Count * sizeof(USHORT), 'rvnE');
        if (shortBuffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // check previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {

            //
            // Establish an exception handler and attempt to probe the input buffer.
            // If the probe attempt fails, then return the exception code as the
            // service status.
            //

            try {

                //
                // Probe the input buffer.
                //

                ProbeForRead((PVOID)Ids, LocalBufferLength, sizeof(ULONG));

            }
            //
            // If an exception occurs during the probe of the input buffer, then
            // always handle the exception and return the exception code as the
            // status value.
            //
            except (EXCEPTION_EXECUTE_HANDLER) {
                ExFreePool(shortBuffer);
                return GetExceptionCode();
            }

        } 
        
        //
        // Truncate the ULONGs in the input buffer into USHORTs in
        // the local buffer.
        //

        for ( i = 0; i < Count; i++ ) {
            if (Ids[i] > MAXUSHORT) {
                ExFreePool(shortBuffer);
                return STATUS_INVALID_PARAMETER;
            }
            shortBuffer[i] = (USHORT)Ids[i];
        }
    }

    //
    // Set the DriverOrder system environment variable.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    NtStatus = HalSetEnvironmentVariableEx(L"DriverOrder",
                                           &EfiDriverVariablesGuid,
                                           shortBuffer,
                                           Count * sizeof(USHORT),
                                           VARIABLE_ATTRIBUTE_NON_VOLATILE);

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

    //
    // It is possible for this variable to not exist.  If we have 
    // something to write, then the DriverOrder variable will be
    // created.  However, if it has already been deleted and we 
    // attempt to delete it again, the above call will return 
    // STATUS_VARIABLE_NOT_FOUND.  This is still a success since the
    // variable will not exist once the above routine returns.
    //
    if (NtStatus == STATUS_VARIABLE_NOT_FOUND) {
        NtStatus = STATUS_SUCCESS;
    }    
    
    if (shortBuffer) {
        ExFreePool(shortBuffer);
    }

    return NtStatus;

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtSetDriverEntryOrder



NTSTATUS
NtTranslateFilePath (
    IN PFILE_PATH InputFilePath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputFilePath,
    IN OUT PULONG OutputFilePathLength
    )

/*++

Routine Description:

    This function translates a FILE_PATH from one format to another.

Arguments:

    InputFilePath - Supplies the address of the buffer that contains the
        FILE_PATH that is to be translated.

    OutputType - Specifies the desired output file path type. One of
        FILE_PATH_TYPE_ARC, FILE_PATH_TYPE_ARC_SIGNATURE, FILE_PATH_TYPE_NT,
        and FILE_PATH_TYPE_EFI.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(InputFilePath);
    UNREFERENCED_PARAMETER(OutputType);
    UNREFERENCED_PARAMETER(OutputFilePath);
    UNREFERENCED_PARAMETER(OutputFilePathLength);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS status;
    KPROCESSOR_MODE PreviousMode;
    ULONG localInputPathLength;
    ULONG localOutputPathLength;
    PFILE_PATH localInputPath = NULL;
    PFILE_PATH localOutputPath;

    //
    // Verify the output type.
    //

    if ((OutputType < FILE_PATH_TYPE_MIN) ||
        (OutputType > FILE_PATH_TYPE_MAX)) {
        //DbgPrint( "NtTranslateFilePath: OutputType outside range\n" );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Establish an exception handler and attempt to probe and read the
    // input buffer, and probe the output buffer and the output length. If
    // the probe attempt fails, then return the exception code as the service
    // status.
    //

    try {

        //
        // Verify that the input buffer is big enough. It must extend at
        // least to the FilePath field.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            localInputPathLength = ProbeAndReadUlong(&InputFilePath->Length);
        } else {
            localInputPathLength = InputFilePath->Length;
        }

        if (localInputPathLength < FIELD_OFFSET(FILE_PATH,FilePath)) {
            //DbgPrint( "NtTranslateFilePath: input buffer too short\n" );
            return STATUS_INVALID_PARAMETER;
        }
    
        //
        // Get previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {

            //
            // Probe the input buffer.
            //

            ProbeForRead((PVOID)InputFilePath, localInputPathLength, sizeof(ULONG));

            //
            // Probe and capture the output length.
            //

            ProbeForWriteUlong(OutputFilePathLength);

            localOutputPathLength = *OutputFilePathLength;

            //
            // Probe the output buffer.
            //

            if (!ARGUMENT_PRESENT(OutputFilePath)) {
                localOutputPathLength = 0;
            }

            if (localOutputPathLength != 0) {
                ProbeForWrite((PVOID)OutputFilePath, localOutputPathLength, sizeof(ULONG));
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot/driver order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {
            localOutputPathLength = *OutputFilePathLength;
            if (!ARGUMENT_PRESENT(OutputFilePath)) {
                localOutputPathLength = 0;
            }
        }

        //
        // Allocate a nonpaged buffer to hold a copy of the input buffer.
        // Copy the input buffer into the local buffer.
        //
    
        localInputPath = ExAllocatePoolWithTag(NonPagedPool, localInputPathLength, 'rvnE');
        if (localInputPath == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(localInputPath, InputFilePath, localInputPathLength);

        //
        // Allocate a nonpaged buffer into which to build the output path.
        //

        if (localOutputPathLength != 0) {
            localOutputPath = ExAllocatePoolWithTag(NonPagedPool, localOutputPathLength, 'rvnE');
            if (localOutputPath == NULL) {
                ExFreePool(localInputPath);
                localInputPath = NULL;
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            localOutputPath = NULL;
        }

    //
    // If an exception occurs during the probe and capture of the input buffer,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (localInputPath != NULL) {
            ExFreePool(localInputPath);
        }
        return GetExceptionCode();
    }

    //
    // Verify the format of the input file path.
    //

    status = ExpVerifyFilePath(localInputPath, ADD_OFFSET(localInputPath, Length));
    if (NT_SUCCESS(status)) {

        //
        // If the output type is the same as the input type, just copy the input
        // path to the output path.
        //
        if (OutputType == localInputPath->Type) {
    
            if (localOutputPathLength >= localInputPathLength) {
                RtlCopyMemory(localOutputPath, localInputPath, localInputPathLength);
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            localOutputPathLength = localInputPathLength;

        } else {
    
            //
            // Conversion is required.
            //
            switch (localInputPath->Type) {
            
            case FILE_PATH_TYPE_ARC:
            case FILE_PATH_TYPE_ARC_SIGNATURE:
                status = ExpTranslateArcPath(
                            localInputPath,
                            OutputType,
                            
                            localOutputPath,
                            &localOutputPathLength
                            );
                break;
        
            case FILE_PATH_TYPE_NT:
                status = ExpTranslateNtPath(
                            localInputPath,
                            OutputType,
                            localOutputPath,
                            &localOutputPathLength);
                break;
        
            case FILE_PATH_TYPE_EFI:
                status = ExpTranslateEfiPath(
                            localInputPath,
                            OutputType,
                            localOutputPath,
                            &localOutputPathLength);
                break;
        
            default:
                ASSERT(FALSE);
                //DbgPrint( "NtTranslateFilePath: input type outside range\n" );
                status = STATUS_INVALID_PARAMETER;
                break;
            }
        }
    }

    ExFreePool(localInputPath);

    //
    // Establish an exception handler and attempt to copy to the output
    // buffer and write the output length. If the write attempt fails, then
    // return the exception code as the service status.
    //

    try {

        //
        // Copy the output path.
        //

        if (NT_SUCCESS(status) && (localOutputPath != NULL)) {
            RtlCopyMemory(OutputFilePath, localOutputPath, localOutputPathLength);
        }

        if (localOutputPath != NULL) {
            ExFreePool(localOutputPath);
            localOutputPath = NULL;
        }

        //
        // Write the output length.
        //

        if (ARGUMENT_PRESENT(OutputFilePathLength)) {
            *OutputFilePathLength = localOutputPathLength;
        }

        return status;

    //
    // If an exception occurs during the write of the return data, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (localOutputPath != NULL) {
            ExFreePool(localOutputPath);
        }
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // NtTranslateFilePath

NTSTATUS
ExpSetBootEntry (
    IN LOGICAL CreateNewEntry,
    IN PBOOT_ENTRY BootEntry,
    OUT PULONG Id OPTIONAL
    )

/*++

Routine Description:

    This function adds a boot entry to the system environment or modifies
    an existing boot entry. It is a local routine called by NtAddBootEntry
    and NtModifyBootEntry.

    N.B. This function requires the system environment privilege.

Arguments:

    CreateNewEntry - Indicates whether this function is to add a new boot
        entry (TRUE - NtAddBootEntry), or modify an existing boot entry
        (FALSE - NtModifyBootEntry).
    BootEntry - Supplies the address of a BOOT_ENTRY that describes the
        new boot entry.

    Id - Supplies the address of a ULONG that is to receive the identifier
        assigned to the new boot entry.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(CreateNewEntry);
    UNREFERENCED_PARAMETER(BootEntry);
    UNREFERENCED_PARAMETER(Id);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PBOOT_ENTRY localBootEntry = NULL;
    ULONG LocalBufferLength;
    PUCHAR MaxBuffer;
    ULONG id = 0;
    WCHAR idString[9];
    PWCHAR friendlyName;
    ULONG friendlyNameLength;
    PFILE_PATH bootFilePath = NULL;
    PFILE_PATH translatedBootFilePath = NULL;
    LOGICAL isWindowsOs;
    PWINDOWS_OS_OPTIONS windowsOsOptions;
    PFILE_PATH windowsFilePath;
    PEFI_LOAD_OPTION efiLoadOption = NULL;
    PUCHAR efiBootFilePath;
    ULONG efiBootFilePathLength;
    ULONG efiWindowsFilePathLength;
    ULONG osOptionsLength;
    ULONG length;
    ULONG requiredLength;
    PUCHAR efiOsOptions;

    //
    // Establish an exception handler and attempt to probe and read the
    // input buffer, and probe the output identifier parameter. If the probe
    // attempt fails, then return the exception code as the service status.
    //

    try {

        //
        // Verify that the input buffer is big enough. It must extend at
        // least to the OsOptions field.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            LocalBufferLength = ProbeAndReadUlong(&BootEntry->Length);
        } else {
            LocalBufferLength = BootEntry->Length;
        }

        if (LocalBufferLength < FIELD_OFFSET(BOOT_ENTRY,OsOptions)) {
            return STATUS_INVALID_PARAMETER;
        }
    
        //
        // Get previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {

            //
            // Probe the input buffer.
            //

            ProbeForRead((PVOID)BootEntry, LocalBufferLength, sizeof(ULONG));

            //
            // Probe the output identifier.
            //

            if (ARGUMENT_PRESENT(Id)) {
                ProbeForWriteUlong(Id);
            }

            //
            // Check if the current thread has the privilege to query the
            // system boot order list.
            //

            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);

            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        //
        // Allocate a nonpaged buffer to hold a copy of the input buffer.
        // Copy the input buffer into the local buffer.
        //
    
        localBootEntry = ExAllocatePoolWithTag(NonPagedPool, LocalBufferLength, 'rvnE');
        if (localBootEntry == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(localBootEntry, BootEntry, LocalBufferLength);

    //
    // If an exception occurs during the probe and capture of the input buffer,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (localBootEntry != NULL) {
            ExFreePool(localBootEntry);
        }
        return GetExceptionCode();
    }

    //
    // Calculate the address of the byte above the end of the local buffer.
    //

    MaxBuffer = (PUCHAR)localBootEntry + LocalBufferLength;

    //
    // Verify the structure version.
    //

    if ((localBootEntry->Version == 0) ||
        (localBootEntry->Version > BOOT_ENTRY_VERSION)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // If modifying an existing entry, verify that the input identifier is
    // in range.
    //

    if (!CreateNewEntry && (localBootEntry->Id > MAXUSHORT)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Ignore boot entry attributes that can't be set.
    //

    localBootEntry->Attributes &= BOOT_ENTRY_ATTRIBUTE_VALID_BITS;

    //
    // Verify that offsets are aligned correctly.
    //

    if (((localBootEntry->FriendlyNameOffset & (sizeof(WCHAR) - 1)) != 0) ||
        ((localBootEntry->BootFilePathOffset & (sizeof(ULONG) - 1)) != 0)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Verify that OsOptions doesn't extend beyond the end of the buffer.
    //

    if ((localBootEntry->OsOptionsLength > LocalBufferLength) ||
        ((localBootEntry->OsOptions + localBootEntry->OsOptionsLength) >= MaxBuffer)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // If the OsOptions are for a Windows operating system, verify them.
    //

    windowsOsOptions = (PWINDOWS_OS_OPTIONS)localBootEntry->OsOptions;

    if ((localBootEntry->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS,Version)) &&
        (strcmp((char *)windowsOsOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0)) {

        if (localBootEntry->OsOptionsLength <= FIELD_OFFSET(WINDOWS_OS_OPTIONS,OsLoadOptions)) {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto done;
        }

        NtStatus = ExpVerifyWindowsOsOptions(windowsOsOptions,
                                          localBootEntry->OsOptionsLength);
        if (!NT_SUCCESS(NtStatus)) {
            goto done;
        }

        isWindowsOs = TRUE;
        windowsFilePath = ADD_OFFSET(windowsOsOptions, OsLoadPathOffset);

    } else {

        isWindowsOs = FALSE;
        windowsFilePath = NULL; // keep the compiler quiet
    }

    //
    // Verify that FriendlyName doesn't extend beyond the end of the buffer.
    //

    friendlyName = ADD_OFFSET(localBootEntry, FriendlyNameOffset);
    if ((friendlyNameLength = ExpSafeWcslen(friendlyName, (PWSTR)MaxBuffer)) == 0xffffffff) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Convert friendlyNameLength from a character count into a byte count,
    // including the null terminator.
    //

    friendlyNameLength = (friendlyNameLength + 1) * sizeof(WCHAR);

    //
    // Verify that BootFilePath is valid and doesn't extend beyond the end of
    // the buffer.
    //

    bootFilePath = ADD_OFFSET(localBootEntry, BootFilePathOffset);
    NtStatus = ExpVerifyFilePath(bootFilePath, MaxBuffer);
    if (!NT_SUCCESS(NtStatus)) {
        goto done;
    }

    //
    // Verify that OsOptions doesn't encroach into FriendlyName, and that
    // FriendlyName doesn't encroach into BootFilePath.
    //

    if (((localBootEntry->OsOptions + localBootEntry->OsOptionsLength) > (PUCHAR)friendlyName) ||
        (((PUCHAR)friendlyName + friendlyNameLength) > (PUCHAR)bootFilePath)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // The format of the input buffer has been validated. Build the variable value
    // that will be stored in NVRAM. Begin by determining the lengths of the file
    // paths that will be stored. If the caller provided the paths in non-EFI
    // format, they need to be translated.
    //

    if (bootFilePath->Type != FILE_PATH_TYPE_EFI) {
        efiBootFilePathLength = 0;
        NtStatus = ZwTranslateFilePath(bootFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       NULL,
                                       &efiBootFilePathLength);
        if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
            goto done;
        }
        translatedBootFilePath = ExAllocatePoolWithTag(NonPagedPool,
                                                       efiBootFilePathLength,
                                                       'rvnE');
        if (translatedBootFilePath == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }
        RtlZeroMemory(translatedBootFilePath, efiBootFilePathLength);
        length = efiBootFilePathLength;
        NtStatus = ZwTranslateFilePath(bootFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       translatedBootFilePath,
                                       &length);
        if (!NT_SUCCESS(NtStatus)) {
            goto done;
        }
        if (length != efiBootFilePathLength) {
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    } else {
        efiBootFilePathLength = bootFilePath->Length;
        translatedBootFilePath = bootFilePath;
    }

    efiBootFilePathLength = efiBootFilePathLength - FIELD_OFFSET(FILE_PATH, FilePath);

    efiWindowsFilePathLength = 0;
    if (isWindowsOs &&
        (windowsFilePath->Type != FILE_PATH_TYPE_EFI)) {
        NtStatus = ZwTranslateFilePath(windowsFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       NULL,
                                       &efiWindowsFilePathLength);
        if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
            goto done;
        }
        osOptionsLength = localBootEntry->OsOptionsLength -
                            windowsFilePath->Length + efiWindowsFilePathLength;
    } else {
        osOptionsLength = localBootEntry->OsOptionsLength;
    }

    //
    // Calculate the length required for the variable value.
    //

    requiredLength = FIELD_OFFSET(EFI_LOAD_OPTION, Description);
    requiredLength += friendlyNameLength;
    requiredLength += efiBootFilePathLength;
    requiredLength += osOptionsLength;

    //
    // Allocate a buffer to hold the variable value.
    //

    efiLoadOption = ExAllocatePoolWithTag(NonPagedPool, requiredLength, 'rvnE');
    if (efiLoadOption == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }
    RtlZeroMemory(efiLoadOption, requiredLength);

    //
    // Build the variable value.
    //

    efiLoadOption->Attributes = 0;
    if ((localBootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0) {
        efiLoadOption->Attributes = LOAD_OPTION_ACTIVE;
    }

    efiLoadOption->FilePathLength = (USHORT)efiBootFilePathLength;

    memcpy(efiLoadOption->Description, friendlyName, friendlyNameLength);

    efiBootFilePath = (PUCHAR)((PUCHAR)efiLoadOption->Description + friendlyNameLength);
    memcpy(efiBootFilePath, translatedBootFilePath->FilePath, efiBootFilePathLength);

    efiOsOptions = efiBootFilePath + efiBootFilePathLength;
    if (isWindowsOs &&
        (windowsFilePath->Type != FILE_PATH_TYPE_EFI)) {

        PFILE_PATH efiWindowsFilePath;

        memcpy(efiOsOptions, windowsOsOptions, windowsOsOptions->OsLoadPathOffset);
        ((WINDOWS_OS_OPTIONS UNALIGNED *)efiOsOptions)->Length = osOptionsLength;

        efiWindowsFilePath = (PFILE_PATH)(efiOsOptions + windowsOsOptions->OsLoadPathOffset);
        length = efiWindowsFilePathLength;
        NtStatus = ZwTranslateFilePath(windowsFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       efiWindowsFilePath,
                                       &efiWindowsFilePathLength);
        if (NtStatus != STATUS_SUCCESS) {
            goto done;
        }
        if (length != efiWindowsFilePathLength) {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

    } else {

        memcpy(efiOsOptions, localBootEntry->OsOptions, osOptionsLength);
    }

    //
    // If CreateNewEntry is true, then find an unused identifier to assign to
    // this boot entry. If CreateNewEntry is false, then verify that the
    // provided identifier exists.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    if (CreateNewEntry) {

        for ( id = 0; id <= MAXUSHORT; id++ ) {
            
            //
            // If the id string contains an alpha character in the 
            // hexadecimal string we will have to check both the
            // uppercase string and the lowercase string since
            // EFI is case sensitive with regards to NVRAM variables
            //
            // Check the lowercase string *last* to ensure that 
            // we always write the lowercase string to NVRAM
            // since that was the convention we used previously
            //
            swprintf( idString, L"Boot%04X", id);
            length = 0;
            NtStatus = HalGetEnvironmentVariableEx(idString,
                                                   &EfiBootVariablesGuid,
                                                   NULL,
                                                   &length,
                                                   NULL);
            
            if ((NtStatus == STATUS_VARIABLE_NOT_FOUND) && HEX_VALUE_CONTAINS_ALPHA(id)) {
                swprintf( idString, L"Boot%04x", id);
                length = 0;
                NtStatus = HalGetEnvironmentVariableEx(idString,
                                                       &EfiBootVariablesGuid,
                                                       NULL,
                                                       &length,
                                                       NULL);
            }
            
            //
            // If we did not find the variable, we can use this
            // Boot Entry ID.  
            //
            if (NtStatus == STATUS_VARIABLE_NOT_FOUND) {
                break;
            }
            if ((NtStatus != STATUS_SUCCESS) && (NtStatus != STATUS_BUFFER_TOO_SMALL)) {
                goto done_unlock;
            }
        }

        if (id > MAXUSHORT) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto done_unlock;
        }

    } else {

        id = localBootEntry->Id;
        swprintf( idString, L"Boot%04x", localBootEntry->Id);
        length = 0;
        NtStatus = HalGetEnvironmentVariableEx(idString,
                                               &EfiBootVariablesGuid,
                                               NULL,
                                               &length,
                                               NULL);
        
        //
        // If we did not find the boot entry and the idString
        // contains an alpha character in the hexadecimal string
        // check with an uppder case alpha character.  Efi
        // is case sensitive with respect to the NVRAM 
        // variables
        //
        if ((NtStatus == STATUS_VARIABLE_NOT_FOUND) && 
            HEX_VALUE_CONTAINS_ALPHA(localBootEntry->Id)) {

            swprintf( idString, L"Boot%04X", localBootEntry->Id);
            length = 0;
            NtStatus = HalGetEnvironmentVariableEx(idString,
                                                   &EfiBootVariablesGuid,
                                                   NULL,
                                                   &length,
                                                   NULL);
        }
                
        if ((NtStatus != STATUS_SUCCESS) && (NtStatus != STATUS_BUFFER_TOO_SMALL)) {
            goto done_unlock;
        }
    }

    //
    // Set or update the boot entry environment variable.
    //

    NtStatus = HalSetEnvironmentVariableEx(idString,
                                           &EfiBootVariablesGuid,
                                           efiLoadOption,
                                           requiredLength,
                                           VARIABLE_ATTRIBUTE_NON_VOLATILE);

done_unlock:

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

done:

    if (efiLoadOption != NULL) {
        ExFreePool(efiLoadOption);
    }

    if ((translatedBootFilePath != NULL) && (translatedBootFilePath != bootFilePath)) {
        ExFreePool(translatedBootFilePath);
    }

    ExFreePool(localBootEntry);

    //
    // Establish an exception handler and attempt to write the return
    // identifier. If the write attempt fails, then return the exception
    // code as the service status.
    //

    try {

        //
        // Write the return identifier.
        //

        if (CreateNewEntry && ARGUMENT_PRESENT(Id) && NT_SUCCESS(NtStatus)) {
            *Id = id;
        }

        return NtStatus;

    //
    // If an exception occurs during the write of the return data, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // ExpSetBootEntry


NTSTATUS
ExpSetDriverEntry (
    IN LOGICAL CreateNewEntry,
    IN PEFI_DRIVER_ENTRY DriverEntry,
    OUT PULONG Id OPTIONAL
    )

/*++

Routine Description:

    This function adds a driver entry to the system environment or modifies
    an existing driver entry. It is a local routine called by NtAddDriverEntry
    and NtModifyDriverEntry.

    N.B. This function requires the system environment privilege.

Arguments:

    CreateNewEntry - Indicates whether this function is to add a new driver
        entry (TRUE - NtAddDriverEntry), or modify an existing driver entry
        (FALSE - NtModifyDriverEntry).
    DriverEntry - Supplies the address of a EFI_DRIVER_ENTRY that describes the
        new driver entry.

    Id - Supplies the address of a ULONG that is to receive the identifier
        assigned to the new driver entry.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_NOT_IMPLEMENTED      This function is not supported on this platform.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.
    STATUS_PRIVILEGE_NOT_HELD   The caller does not have the required privilege.
    STATUS_ACCESS_VIOLATION     One of the input parameters cannot be read,
                                or one of the output parameters cannot be written.

--*/

{
#if !defined(EFI_NVRAM_ENABLED)
    UNREFERENCED_PARAMETER(CreateNewEntry);
    UNREFERENCED_PARAMETER(DriverEntry);
    UNREFERENCED_PARAMETER(Id);
    return STATUS_NOT_IMPLEMENTED;
#else

    BOOLEAN HasPrivilege;
    NTSTATUS NtStatus;
    KPROCESSOR_MODE PreviousMode;
    PEFI_DRIVER_ENTRY localDriverEntry = NULL;
    ULONG LocalBufferLength;
    PUCHAR MaxBuffer;
    ULONG id = 0;
    WCHAR idString[11];
    PWCHAR friendlyName;
    ULONG friendlyNameLength;
    PFILE_PATH driverFilePath = NULL;
    PFILE_PATH translatedDriverFilePath = NULL;
    PEFI_LOAD_OPTION efiLoadOption = NULL;
    PUCHAR efiDriverFilePath;
    ULONG efiDriverFilePathLength;
    ULONG length;
    ULONG requiredLength;
    
    //
    // Establish an exception handler and attempt to probe and read the
    // input buffer, and probe the output identifier parameter. If the probe
    // attempt fails, then return the exception code as the service status.
    //

    try {

        //
        // Verify that the input buffer is big enough. It must extend at
        // least the size of a EFI_DRIVER_ENTRY
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            LocalBufferLength = ProbeAndReadUlong(&DriverEntry->Length);
        } else {
            LocalBufferLength = DriverEntry->Length;
        }

        if (LocalBufferLength < sizeof(EFI_DRIVER_ENTRY)) {
            return STATUS_INVALID_PARAMETER;
        }
    
        //
        // Get previous processor mode and probe arguments if necessary.
        //

        if (PreviousMode != KernelMode) {

            //
            // Probe the input buffer.
            //
            ProbeForRead((PVOID)DriverEntry, LocalBufferLength, sizeof(ULONG));
            //
            // Probe the output identifier.
            //
            if (ARGUMENT_PRESENT(Id)) {
                ProbeForWriteUlong(Id);
            }
            //
            // Check if the current thread has the privilege to query the
            // system driver order list.
            //
            HasPrivilege = SeSinglePrivilegeCheck(SeSystemEnvironmentPrivilege,
                                                  PreviousMode);
            if (HasPrivilege == FALSE) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        }

        //
        // Allocate a nonpaged buffer to hold a copy of the input buffer.
        // Copy the input buffer into the local buffer.
        //
        localDriverEntry = ExAllocatePoolWithTag(NonPagedPool, LocalBufferLength, 'rvnE');
        if (localDriverEntry == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(localDriverEntry, DriverEntry, LocalBufferLength);

    //
    // If an exception occurs during the probe and capture of the input buffer,
    // then always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (localDriverEntry != NULL) {
            ExFreePool(localDriverEntry);
        }
        return GetExceptionCode();
    }

    //
    // Calculate the address of the byte above the end of the local buffer.
    //
    MaxBuffer = (PUCHAR)localDriverEntry + LocalBufferLength;

    //
    // Verify the structure version.
    //
    if ((localDriverEntry->Version == 0) ||
        (localDriverEntry->Version > EFI_DRIVER_ENTRY_VERSION)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // If modifying an existing entry, verify that the input identifier is
    // in range.
    //
    if (!CreateNewEntry && (localDriverEntry->Id > MAXUSHORT)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Verify that offsets are aligned correctly.
    //
    if (((localDriverEntry->FriendlyNameOffset & (sizeof(WCHAR) - 1)) != 0) ||
        ((localDriverEntry->DriverFilePathOffset & (sizeof(ULONG) - 1)) != 0)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Verify that FriendlyName doesn't extend beyond the end of the buffer.
    //
    friendlyName = ADD_OFFSET(localDriverEntry, FriendlyNameOffset);
    if ((friendlyNameLength = ExpSafeWcslen(friendlyName, (PWSTR)MaxBuffer)) == 0xffffffff) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Convert friendlyNameLength from a character count into a byte count,
    // including the null terminator.
    //

    friendlyNameLength = (friendlyNameLength + 1) * sizeof(WCHAR);

    //
    // Verify that DriverFilePath is valid and doesn't extend beyond the end of
    // the buffer.
    //

    driverFilePath = ADD_OFFSET(localDriverEntry, DriverFilePathOffset);
    NtStatus = ExpVerifyFilePath(driverFilePath, MaxBuffer);
    if (!NT_SUCCESS(NtStatus)) {
        goto done;
    }

    //
    // Verify that FriendlyName doesn't encroach into DriverFilePath.
    //

    if (((PUCHAR)friendlyName + friendlyNameLength) > (PUCHAR)driverFilePath) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // The format of the input buffer has been validated. Build the variable value
    // that will be stored in NVRAM. Begin by determining the lengths of the file
    // paths that will be stored. If the caller provided the paths in non-EFI
    // format, they need to be translated.
    //

    if (driverFilePath->Type != FILE_PATH_TYPE_EFI) {
        efiDriverFilePathLength = 0;
        NtStatus = ZwTranslateFilePath(driverFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       NULL,
                                       &efiDriverFilePathLength);
        if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
            goto done;
        }
        translatedDriverFilePath = ExAllocatePoolWithTag(NonPagedPool,
                                                       efiDriverFilePathLength,
                                                       'rvnE');
        if (translatedDriverFilePath == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto done;
        }
        RtlZeroMemory(translatedDriverFilePath, efiDriverFilePathLength);
        length = efiDriverFilePathLength;
        NtStatus = ZwTranslateFilePath(driverFilePath,
                                       FILE_PATH_TYPE_EFI,
                                       translatedDriverFilePath,
                                       &length);
        if (!NT_SUCCESS(NtStatus)) {
            goto done;
        }
        if (length != efiDriverFilePathLength) {
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    } else {
        efiDriverFilePathLength = driverFilePath->Length;
        translatedDriverFilePath = driverFilePath;
    }

    efiDriverFilePathLength = efiDriverFilePathLength - FIELD_OFFSET(FILE_PATH, FilePath);

    //
    // Calculate the length required for the variable value.
    //

    requiredLength = FIELD_OFFSET(EFI_LOAD_OPTION, Description);
    requiredLength += friendlyNameLength;
    requiredLength += efiDriverFilePathLength;
    
    //
    // Allocate a buffer to hold the variable value.
    //

    efiLoadOption = ExAllocatePoolWithTag(NonPagedPool, requiredLength, 'rvnE');
    if (efiLoadOption == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }
    RtlZeroMemory(efiLoadOption, requiredLength);

    //
    // Build the variable value.
    //

    efiLoadOption->FilePathLength = (USHORT)efiDriverFilePathLength;

    memcpy(efiLoadOption->Description, friendlyName, friendlyNameLength);

    efiDriverFilePath = (PUCHAR)((PUCHAR)efiLoadOption->Description + friendlyNameLength);
    memcpy(efiDriverFilePath, translatedDriverFilePath->FilePath, efiDriverFilePathLength);

    //
    // If CreateNewEntry is true, then find an unused identifier to assign to
    // this driver entry. If CreateNewEntry is false, then verify that the
    // provided identifier exists.
    //

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ExpEnvironmentLock);

    if (CreateNewEntry) {
        
        for ( id = 0; id <= MAXUSHORT; id++ ) {

            //
            // If the id string contains an alpha character in the 
            // hexadecimal string we will have to check both the
            // uppercase string and the lowercase string since
            // EFI is case sensitive with regards to NVRAM variables
            //
            // Check the lowercase string *last* to ensure that 
            // we always write the lowercase string to NVRAM
            // since that was the convention we used previously
            //
            swprintf( idString, L"Driver%04X", id);
            length = 0;
            NtStatus = HalGetEnvironmentVariableEx(idString,
                                                   &EfiDriverVariablesGuid,
                                                   NULL,
                                                   &length,
                                                   NULL);
            
            if ((NtStatus == STATUS_VARIABLE_NOT_FOUND) && HEX_VALUE_CONTAINS_ALPHA(id)) {
                swprintf( idString, L"Driver%04x", id);
                length = 0;
                NtStatus = HalGetEnvironmentVariableEx(idString,
                                                       &EfiDriverVariablesGuid,
                                                       NULL,
                                                       &length,
                                                       NULL);
            }

            //
            // If we did not find the variable, we can use this
            // Driver Entry ID.  
            //
            if (NtStatus == STATUS_VARIABLE_NOT_FOUND) {
                break;
            }
            if ((NtStatus != STATUS_SUCCESS) && (NtStatus != STATUS_BUFFER_TOO_SMALL)) {
                goto done_unlock;
            }
        }

        if (id > MAXUSHORT) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto done_unlock;
        }

    } else {
        id = localDriverEntry->Id;
        swprintf( idString, L"Driver%04x", localDriverEntry->Id);
        length = 0;
        NtStatus = HalGetEnvironmentVariableEx(idString,
                                               &EfiDriverVariablesGuid,
                                               NULL,
                                               &length,
                                               NULL);

        //
        // If we did not find the driver entry and the idString
        // contains an alpha character in the hexadecimal string
        // check with an uppder case alpha character.  Efi
        // is case sensitive with respect to the NVRAM 
        // variables
        //
        if ((NtStatus == STATUS_VARIABLE_NOT_FOUND) && 
            HEX_VALUE_CONTAINS_ALPHA(localDriverEntry->Id)) {

            swprintf( idString, L"Driver%04X", localDriverEntry->Id);
            length = 0;
            NtStatus = HalGetEnvironmentVariableEx(idString,
                                                   &EfiDriverVariablesGuid,
                                                   NULL,
                                                   &length,
                                                   NULL);
        }

        if ((NtStatus != STATUS_SUCCESS) && (NtStatus != STATUS_BUFFER_TOO_SMALL)) {
            goto done_unlock;
        }
    }

    //
    // Set or update the driver entry environment variable.
    //

    NtStatus = HalSetEnvironmentVariableEx(idString,
                                           &EfiDriverVariablesGuid,
                                           efiLoadOption,
                                           requiredLength,
                                           VARIABLE_ATTRIBUTE_NON_VOLATILE);

done_unlock:

    ExReleaseFastMutexUnsafe(&ExpEnvironmentLock);
    KeLeaveCriticalRegion();

done:

    if (efiLoadOption != NULL) {
        ExFreePool(efiLoadOption);
    }

    if ((translatedDriverFilePath != NULL) && (translatedDriverFilePath != driverFilePath)) {
        ExFreePool(translatedDriverFilePath);
    }

    ExFreePool(localDriverEntry);

    //
    // Establish an exception handler and attempt to write the return
    // identifier. If the write attempt fails, then return the exception
    // code as the service status.
    //

    try {

        //
        // Write the return identifier.
        //

        if (CreateNewEntry && ARGUMENT_PRESENT(Id) && NT_SUCCESS(NtStatus)) {
            *Id = id;
        }

        return NtStatus;

    //
    // If an exception occurs during the write of the return data, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
          return GetExceptionCode();
    }

#endif // else !defined(EFI_NVRAM_ENABLED)

} // ExpSetDriverEntry

//
// The remainder of this module is routines that are only compiled when
// EFI_NVRAM_ENABLED is defined.
//

#if defined(EFI_NVRAM_ENABLED)

ULONG
ExpSafeWcslen (
    IN PWSTR String,
    IN PWSTR Max
    )
{
    PWSTR p = String;
    
    while ((p < Max) && (*p != 0)) {
        p++;
    }

    if (p < Max) {
        return (ULONG)(p - String);
    }

    return 0xffffffff;

} // ExpSafeWcslen

NTSTATUS
ExpTranslateArcPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    )
{
#if 0
    UNREFERENCED_PARAMETER(InputPath);
    UNREFERENCED_PARAMETER(OutputType);
    UNREFERENCED_PARAMETER(OutputPath);
    UNREFERENCED_PARAMETER(OutputPathLength);
    return STATUS_NOT_IMPLEMENTED;
#endif

    PWSTR deviceName, pathName;
    ULONG deviceNameCount;
    BOOLEAN signatureFormat;
    NTSTATUS status;

    //
    // Possible Arc Path formats
    // signature(<guid/signature>-<part#>-<start>-<size>)[\filePart]
    // signature(<guid>)[\filePart]
    // multi(0)disk(0)fdisk(0)[\filePart]
    // multi(0)disk(0)rdisk(0)[\filePart]
    // multi(0)disk(0)rdisk(0)partition(0)[\filePart]
    //

    //
    // Determine if ArcName has signature() format
    // Parse out DeviceName & FilePart
    //
    status = ExpParseArcPathName (
                (PWSTR)(InputPath->FilePath),
                &deviceName,
                &pathName,
                &deviceNameCount,
                &signatureFormat
                );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // not signature() format
    //
    if( signatureFormat == FALSE ) {
        if( InputPath->Type != FILE_PATH_TYPE_ARC ) {
            return( STATUS_INVALID_PARAMETER );
        }

        status = ExpConvertArcName(
                    OutputType,
                    OutputPath,
                    OutputPathLength,
                    deviceName,
                    pathName,
                    deviceNameCount
                    );

        return( status );
    }

    //
    // This arc signature() format should be FILE_PATH_TYPE_ARC_SIGNATURE
    //
    if( InputPath->Type != FILE_PATH_TYPE_ARC_SIGNATURE ) {
       return( STATUS_INVALID_PARAMETER );
    }

    status = ExpConvertSignatureName(
                    OutputType,
                    OutputPath,
                    OutputPathLength,
                    deviceName,
                    pathName,
                    deviceNameCount
                    );

    return( status );
} // ExpTranslateArcPath

NTSTATUS
ExpTranslateEfiPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    )
{
    NTSTATUS status;
    HARDDRIVE_DEVICE_PATH *dpHarddrive = NULL;
    ULONG requiredLength;
    UNICODE_STRING guidString;
    UNICODE_STRING deviceNameString;
    PWSTR linkName, pPathName;
    BOOLEAN GPTpartition;
    ULONG partitionNumber, diskNumber;
    ULONGLONG partitionStart, partitionSize;


    //
    // Find the MEDIA/HARDDRIVE and MEDIA/FILEPATH elements in the device
    // path. Note that although EFI allows multiple device paths to appear
    // in a single device path (as in the PATH variable), we only look at
    // the first one.
    //
    status = ExpParseEfiPath(
                (EFI_DEVICE_PATH *)InputPath->FilePath,
                &dpHarddrive,
                &pPathName,
                &GPTpartition
                );
    if( !NT_SUCCESS( status ) ) {
        return( status );
    }
    //
    // If the target type is ARC_SIGNATURE, then we have all of the
    // information we need. Otherwise, we need to find the NT device
    // with the given signature.
    //

    if ( OutputType == FILE_PATH_TYPE_ARC_SIGNATURE ) {
        partitionNumber = dpHarddrive->PartitionNumber;
        partitionStart = dpHarddrive->PartitionStart;
        partitionSize = dpHarddrive->PartitionSize;
        status = ExpCreateOutputSIGNATURE(
                    OutputPath,
                    OutputPathLength,
                    (PDISK_SIGNATURE_NEW)(dpHarddrive->Signature),
                    &(partitionNumber),
                    &(partitionStart),
                    &(partitionSize),
                    pPathName,
                    GPTpartition
                    );
        if( pPathName != NULL ) {
            ExFreePool( pPathName );
        }

        ExFreePool(dpHarddrive);

        return( status );

    }

    //
    // OutputType is ARC or NT. Find the NT device for this device path.
    // For a GPT partition, this is done by translating the symbolic name
    // \??\Volume{<guid>} which will link to \Device\HarddiskVolume<n>.
    //
    status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // Quick path for GPT disk
    // Translate the symbolic link \??\Volume{<guid>}.
    //
    // First, get the GUID in "pretty" format. Then allocate a buffer to hold
    // the full name string and create that string. Then translate the
    // symbolic name.
    //
    // NB: Because the mount manager doesn't create a symbolic link like this
    //     for the EFI system partition, this routine cannot be used to
    //     translate an EFI device path for the system partition to an NT path.
    //
    if( GPTpartition == TRUE ) {
        status = RtlStringFromGUID( (LPGUID)dpHarddrive->Signature, &guidString );
        if ( !NT_SUCCESS(status) ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }

            ExFreePool(dpHarddrive);
            
            return status;
        }

#define LINK_NAME_PREFIX L"\\??\\Volume"

        requiredLength = ((ULONG)wcslen( LINK_NAME_PREFIX ) + 1) * sizeof(WCHAR);
        requiredLength += guidString.Length;
        linkName = ExAllocatePoolWithTag( NonPagedPool, requiredLength, 'rvnE' );
        if ( linkName == NULL ) {
            ExFreePool( guidString.Buffer );
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }

            ExFreePool(dpHarddrive);

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        wcscpy( linkName, LINK_NAME_PREFIX );
        wcscat( linkName, guidString.Buffer );
        ExFreePool( guidString.Buffer );

        status = ExpTranslateSymbolicLink(
            linkName,
            &deviceNameString
            );
        ExFreePool( linkName );
    }

    //
    // check if the quick path was not taken or no object was found
    //
    if ( !NT_SUCCESS(status) ) {

        //
        // long path, opens all disks in search of the signature
        //
        partitionNumber = dpHarddrive->PartitionNumber;
        status = ExpFindDiskSignature(
                    (PDISK_SIGNATURE_NEW)(dpHarddrive->Signature),
                    &partitionNumber,
                    &diskNumber,
                    &partitionStart,
                    &partitionSize,
                    GPTpartition
                    );

        if ( !NT_SUCCESS(status) ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }

            ExFreePool(dpHarddrive);

            return status;
        }

        //
        // The user has provided the partition number, start address,
        // and size; so verify the input with the found results.
        //
        if( (dpHarddrive->PartitionNumber != partitionNumber) ||
            (dpHarddrive->PartitionStart != partitionStart) ||
            (dpHarddrive->PartitionSize != partitionSize) ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }

            ExFreePool(dpHarddrive);

            return( STATUS_INVALID_PARAMETER );
        }

        //
        // create the NT disk Symbolic link name
        // \Device\Harddisk[diskNumber]\Partition[PartitionNumber]
        //
#define NT_DISK_NAME_FORMAT L"\\Device\\Harddisk%lu\\Partition%lu"
#define NT_DISK_NAME_COUNT 47    // 7 + 9 + (10) + 10 + (10) + 1

        linkName = ExAllocatePoolWithTag(
                        NonPagedPool,
                        ( NT_DISK_NAME_COUNT * sizeof( WCHAR ) ),
                        'rvnE'
                        );

        if( linkName == NULL ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }

            ExFreePool(dpHarddrive);

            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        _snwprintf(
            linkName,
            NT_DISK_NAME_COUNT,
            NT_DISK_NAME_FORMAT,
            diskNumber,
            partitionNumber
            );

        status = ExpTranslateSymbolicLink(
            linkName,
            &deviceNameString
            );
        ExFreePool( linkName );
        if( !NT_SUCCESS(status) ) {
            if( pPathName != NULL ) {
                ExFreePool( pPathName );
            }

            ExFreePool(dpHarddrive);

            return( status );
        }
    }

    //
    // We now have the NT name of the device. If the target type is NT, then
    // we have all of the information we need.
    //
    if ( OutputType == FILE_PATH_TYPE_NT ) {
        status = ExpCreateOutputNT(
                    OutputPath,
                    OutputPathLength,
                    &deviceNameString,
                    pPathName
                    );
        ExFreePool( deviceNameString.Buffer );
        if( pPathName != NULL ) {
            ExFreePool( pPathName );
        }

        ExFreePool(dpHarddrive);

        return( status );
    }
    //
    // The output type is ARC.
    //
    status = ExpCreateOutputARC(
                    OutputPath,
                    OutputPathLength,
                    &deviceNameString,
                    pPathName
                    );
    ExFreePool( deviceNameString.Buffer );
    if( pPathName != NULL ) {
        ExFreePool( pPathName );
    }

    ExFreePool(dpHarddrive);

    return( status );

} // ExpTranslateEfiPath

NTSTATUS
ExpTranslateNtPath (
    IN PFILE_PATH InputPath,
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength
    )

{
    NTSTATUS status;
    UNICODE_STRING string, deviceNameString;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    PARTITION_INFORMATION_EX partitionInfo;
    PDRIVE_LAYOUT_INFORMATION_EX driveLayoutInfo = NULL;
    ULONG driveLayoutLength;
    PWSTR deviceName, pathName;
    ULONG pathNameLength;
    ULONG signatureMBR = 0;
    PDISK_SIGNATURE_NEW pDiskSignature;
    BOOLEAN TranslatedSymLink = TRUE;
    BOOLEAN GPTpartition;

    deviceName = (PWSTR)InputPath->FilePath;
    RtlInitUnicodeString( &string, deviceName );
    pathName = (PWSTR)((PUCHAR)deviceName + string.Length + sizeof(WCHAR));
    pathNameLength = (ULONG)wcslen(pathName);
    if (pathNameLength == 0) {
        pathName = NULL;
    }

    //
    // For output type Arc,
    // attempt drill down NT name
    // if NT object exists
    //      match with symlink in \ArcName
    //
    if (OutputType == FILE_PATH_TYPE_ARC) {
        status = ExpTranslateSymbolicLink(
                    deviceName,
                    &deviceNameString
                    );
        if (!NT_SUCCESS(status)) {
            //
            // If non-symlink NT name exists as an object in the NT namespace,
            //    then the return code will be STATUS_OBJECT_TYPE_MISMATCH
            //    else the return code will be STATUS_OBJECT_NAME_NOT_FOUND
            //
            if (status != STATUS_OBJECT_TYPE_MISMATCH) {
                return( status );
            }
            deviceNameString.Buffer = string.Buffer;
            deviceNameString.Length = string.Length;
            deviceNameString.MaximumLength = string.MaximumLength;
            TranslatedSymLink = FALSE;
        }
        status = ExpCreateOutputARC(
                    OutputPath,
                    OutputPathLength,
                    &deviceNameString,
                    pathName
                    );
        if (TranslatedSymLink == TRUE) {
            ExFreePool( deviceNameString.Buffer );
        }
        return( status );
    }

    //
    // Open the target partition and get its partition information.
    //
    InitializeObjectAttributes(
        &obja,
        &string,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
                &handle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE
                );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    status = ZwDeviceIoControlFile(
                handle,
                NULL,
                NULL,
                NULL,
                &iosb,
                IOCTL_DISK_GET_PARTITION_INFO_EX,
                NULL,
                0,
                &partitionInfo,
                sizeof(partitionInfo)
                );

    if (!NT_SUCCESS(status)) {
        ZwClose(handle);
        return status;
    }

    if ((partitionInfo.PartitionStyle != PARTITION_STYLE_MBR) &&
        (partitionInfo.PartitionStyle != PARTITION_STYLE_GPT)) {
        ZwClose(handle);
        return STATUS_UNRECOGNIZED_MEDIA;
    }

    if (partitionInfo.PartitionStyle == PARTITION_STYLE_MBR) {

        driveLayoutLength = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry) +
                                (sizeof(PARTITION_INFORMATION_EX) * 16);

        while (TRUE) {

            driveLayoutInfo = ExAllocatePoolWithTag(NonPagedPool, driveLayoutLength, 'rvnE');
            if (driveLayoutInfo == NULL ) {
                ZwClose(handle);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = ZwDeviceIoControlFile(
                        handle,
                        NULL,
                        NULL,
                        NULL,
                        &iosb,
                        IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                        NULL,
                        0,
                        driveLayoutInfo,
                        driveLayoutLength
                        );
            if (NT_SUCCESS(status)) {
                break;
            }
            ExFreePool(driveLayoutInfo);
            if (status == STATUS_BUFFER_TOO_SMALL) {
                driveLayoutLength *= 2;
                continue;
            }
            ZwClose(handle);
            return status;
        }
        if (NT_SUCCESS(status)) {
            signatureMBR = driveLayoutInfo->Mbr.Signature;
            ExFreePool(driveLayoutInfo);
        }
    }

    ZwClose(handle);

    if (partitionInfo.PartitionStyle == PARTITION_STYLE_GPT) {
        pDiskSignature = (PDISK_SIGNATURE_NEW)(&(partitionInfo.Gpt.PartitionId));
        GPTpartition = TRUE;
    } else {
        pDiskSignature = (PDISK_SIGNATURE_NEW)(&signatureMBR);
        GPTpartition = FALSE;
    }

    if (OutputType == FILE_PATH_TYPE_EFI) {
        status = ExpCreateOutputEFI(
                    OutputPath,
                    OutputPathLength,
                    pDiskSignature,
                    &(partitionInfo.PartitionNumber),
                    (PULONGLONG)(&(partitionInfo.StartingOffset.QuadPart)),
                    (PULONGLONG)(&(partitionInfo.PartitionLength.QuadPart)),
                    pathName,
                    GPTpartition
                    );
        return( status );
    }

    //
    // OutputType is ARC_SIGNATURE
    //
    status = ExpCreateOutputSIGNATURE(
                    OutputPath,
                    OutputPathLength,
                    pDiskSignature,
                    &(partitionInfo.PartitionNumber),
                    (PULONGLONG)(&(partitionInfo.StartingOffset.QuadPart)),
                    (PULONGLONG)(&(partitionInfo.PartitionLength.QuadPart)),
                    pathName,
                    GPTpartition
                    );
    return( status );

} // ExpTranslateNtPath


LOGICAL
ExpTranslateBootEntryNameToId (
    IN PWSTR Name,
    OUT PULONG Id
    )
{
    ULONG number;
    ULONG i;
    WCHAR c;

    if ((towlower(Name[0]) != 'b') ||
        (towlower(Name[1]) != 'o') ||
        (towlower(Name[2]) != 'o') ||
        (towlower(Name[3]) != 't') ) {
        return FALSE;
    }

    number = 0;
    for (i = 4; i < 8; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return FALSE;
        }
    }

    if (Name[8] != 0) {
        return FALSE;
    }

    *Id = number;
    return TRUE;

} // ExpTranslateBootEntryNameToId

LOGICAL
ExpTranslateDriverEntryNameToId (
    IN PWSTR Name,
    OUT PULONG Id
    )
{
    ULONG number;
    ULONG i;
    WCHAR c;

    if ((towlower(Name[0]) != 'd') ||
        (towlower(Name[1]) != 'r') ||
        (towlower(Name[2]) != 'i') ||
        (towlower(Name[3]) != 'v') ||
        (towlower(Name[4]) != 'e') ||
        (towlower(Name[5]) != 'r') ) {
        return FALSE;
    }

    number = 0;
    for (i = 6; i < 10; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return FALSE;
        }
    }

    if (Name[10] != 0) {
        return FALSE;
    }

    *Id = number;
    return TRUE;

} // ExpTranslateDriverEntryNameToId


NTSTATUS
ExpTranslateSymbolicLink (
    IN PWSTR LinkName,
    OUT PUNICODE_STRING ResultName
    )

/*++

Routine Description:

    This routine translates the input symbolic link name by drilling down
    through symbolic links until it finds an object that is not a link.

Arguments:

    LinkName - Supplies the name of the link at which to start translating.

    ResultName - Supplies the address of a UNICODE_STRING descriptor that
        will receive the result name. The storage for the result name is
        allocated from nonpaged pool using ExAllocatePool.

Return Value:

    STATUS_SUCCESS is returned if the input name was a symbolic link and
        all translations completely successfully.
    Failure codes will be returned if the input name was not a link, if
        translations failed, or if allocation of the output buffer failed.

--*/

{
    NTSTATUS status;
    UNICODE_STRING linkString;
    UNICODE_STRING resultString;
    PWSTR resultBuffer;
    ULONG resultBufferLength;
    ULONG requiredLength;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE handle;

    resultBuffer = NULL;
    resultBufferLength = sizeof(WCHAR);

    //
    // Open the input link.
    //

    RtlInitUnicodeString( &linkString, LinkName );

    InitializeObjectAttributes(
        &objectAttributes,
        &linkString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenSymbolicLinkObject(
                &handle,
                (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                &objectAttributes
                );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    while ( TRUE ) {

        while ( TRUE ) {

            //
            // Get the translation for this link, allocating more
            // space as needed.
            //
    
            resultString.Length = 0;
            resultString.MaximumLength = (USHORT)(resultBufferLength - sizeof(WCHAR));
            resultString.Buffer = resultBuffer;
    
            status = ZwQuerySymbolicLinkObject(
                        handle,
                        &resultString,
                        &requiredLength
                        );

            if ( status != STATUS_BUFFER_TOO_SMALL ) {
                break;
            }

            //
            // The buffer was too small. Reallocate it, allowing room for a
            // null terminator, which might not be present in the translation,
            // and try again.
            //

            if ( resultBuffer != NULL ) {
                ExFreePool( resultBuffer );
            }
            resultBufferLength = requiredLength + sizeof(WCHAR);
            resultBuffer = ExAllocatePoolWithTag( NonPagedPool, resultBufferLength, 'rvnE' );
            if ( resultBuffer == NULL ) {
                ZwClose( handle );
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        //
        // Translation done. Close the link. If translation failed, return
        // the failure status.
        //

        ZwClose( handle );

        if (!NT_SUCCESS(status)) {
            if ( resultBuffer != NULL) {
                ExFreePool( resultBuffer );
            }
            return status;
        }

        //
        // Terminate the result string, in case it wasn't already terminated.
        //

        resultBuffer[resultString.Length / sizeof(WCHAR)] = UNICODE_NULL;
        resultString.MaximumLength = (USHORT)(resultBufferLength);

        //
        // See if the result name is also a symbolic name. Try to open it
        // as a link. If this fails, then break out of the loop and return
        // this name as the result.
        //

        RtlInitUnicodeString( &linkString, resultBuffer );

        InitializeObjectAttributes(
            &objectAttributes,
            &linkString,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

        status = ZwOpenSymbolicLinkObject(
                    &handle,
                    (ACCESS_MASK)SYMBOLIC_LINK_QUERY,
                    &objectAttributes
                    );

        if ( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // This name is also a symbolic link. Loop back and translate it.
        //

    }

    //
    // Set up the return string to point to the final result.
    //

    *ResultName = resultString;

    return STATUS_SUCCESS;

} // ExpTranslateSymbolicLink

LOGICAL
ExpIsDevicePathForRemovableMedia (
    EFI_DEVICE_PATH *DevicePath
    )

/*++

Routine Description:

    This routine determines whether an EFI device path represents a non-file
    specific pointer to a removable media device. It make this determination
    based on finding a HARDWARE/VENDOR device path element, and NOT finding
    MEDIA/HARDDRIVE and MEDIA/FILEPATH elements. When the EFI boot manager
    boot such a device path, it looks in a default location for the file to
    be loaded (\EFI\BOOT\BOOT<arch>.EFI).

    We want to identify these removable media device paths because we do not
    want to put our NT boot entries ahead of removable media entries in the
    boot order, if those removable media entries are at the front of the list.
    This allows an x86-like boot order to be set up: floppy first, then CD,
    then NT boot entries.

Arguments:

    DevicePath - Supplies the device path to be checked.

Return Value:

    TRUE is returned if the device path has a HARDWARE/VENDOR element, AND
        that element has the UNKNOWN_DEVICE_GUID, AND the device path does
        NOT have a MEDIA/HARDDRIVE element, AND the device path does NOT
        have a MEDIA/FILEPATH element.

--*/

{
    EFI_DEVICE_PATH *dp = DevicePath;
    VENDOR_DEVICE_PATH UNALIGNED *vdp;
    VENDOR_DEVICE_PATH UNALIGNED *vendorDp = NULL;
    HARDDRIVE_DEVICE_PATH UNALIGNED *harddriveDp = NULL;
    FILEPATH_DEVICE_PATH UNALIGNED *filepathDp = NULL;

    //
    // Walk the device path, looking for elements that we care about.
    //

    while (TRUE) {

        if (IsDevicePathEndType(dp)) {
            break;
        }

        if (DevicePathType(dp) == HARDWARE_DEVICE_PATH) {
            if (DevicePathSubType(dp) == HW_VENDOR_DP) {

                //
                // Found a HARDWARE/VENDOR element. If it has the
                // UNKNOWN_DEVICE_GUID, remember that we found it.
                //

                vdp = (VENDOR_DEVICE_PATH UNALIGNED *)dp;
                if ( memcmp( &vdp->Guid, &ExpUnknownDeviceGuid, 16 ) == 0 ) {
                    vendorDp = vdp;
                }
            }

        } else if (DevicePathType(dp) == MEDIA_DEVICE_PATH) {

            if (DevicePathSubType(dp) == MEDIA_HARDDRIVE_DP) {

                //
                // Found a MEDIA/HARDDRIVE element. Remember it.
                //

                harddriveDp = (HARDDRIVE_DEVICE_PATH *)dp;

            } else if (DevicePathSubType(dp) == MEDIA_FILEPATH_DP) {

                //
                // Found a MEDIA/FILEPATH element. Remember it.
                //

                filepathDp = (FILEPATH_DEVICE_PATH *)dp;
            }
        }

        dp = NextDevicePathNode(dp);
    }

    //
    // If we didn't find a HARDWARE/VENDOR element, or if we did find either
    // a MEDIA/HARDDRIVE element or a MEDIA/FILEPATH element, then this is
    // not a removable media device path.
    //

    if ((vendorDp == NULL) || (harddriveDp != NULL) || (filepathDp != NULL)) {
        return FALSE;
    }

    return TRUE;

} // ExpIsDevicePathForRemovableMedia

NTSTATUS
ExpVerifyFilePath (
    PFILE_PATH FilePath,
    PUCHAR Max
    )
{
    EFI_DEVICE_PATH *dp;
    PUCHAR dpMax;
    ULONG length;
    PWSTR p;

    if (((PUCHAR)FilePath > Max) ||
        (((PUCHAR)FilePath + FIELD_OFFSET(FILE_PATH, FilePath)) > Max) ||
        (FilePath->Length < FIELD_OFFSET(FILE_PATH, FilePath)) ||
        (((PUCHAR)FilePath + FilePath->Length) < (PUCHAR)FilePath) ||
        (((PUCHAR)FilePath + FilePath->Length) > Max) ||
        (FilePath->Version == 0) ||
        (FilePath->Version > FILE_PATH_VERSION) ||
        (FilePath->Type < FILE_PATH_TYPE_MIN) ||
        (FilePath->Type > FILE_PATH_TYPE_MAX)) {
        //DbgPrint( "ExpVerifyFilePath: file path invalid\n" );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Update Max pointer if Max was pointing to an upper bound on the data 
    // structure (ie. if FilePath is part of a struct, Max could point to the end 
    // of the struct, to make sure FilePath does not go past that structure.  
    // We now change Max to the end of the FilePath to make sure its contents do
    // not go past the length specified in FilePath.Length
    //
    if ((PUCHAR)FilePath + FilePath->Length < Max) {
        Max = (PUCHAR)FilePath + FilePath->Length;
    }

    switch (FilePath->Type) {
    
    case FILE_PATH_TYPE_ARC:
    case FILE_PATH_TYPE_ARC_SIGNATURE:
        if (ExpSafeWcslen((PWCHAR)FilePath->FilePath, (PWCHAR)Max) == 0xffffffff) {
            //DbgPrint( "ExpVerifyFilePath: ARC string overruns buffer end\n" );
            return STATUS_INVALID_PARAMETER;
        }
        break;

    case FILE_PATH_TYPE_NT:
        p = (PWSTR)FilePath->FilePath;
        length = ExpSafeWcslen(p, (PWCHAR)Max);
        if (length != 0xffffffff) {
            p = p + length + 1;
            length = ExpSafeWcslen(p, (PWCHAR)Max);
        }
        if (length == 0xffffffff) {
            //DbgPrint( "ExpVerifyFilePath: NT string overruns buffer end\n" );
            return STATUS_INVALID_PARAMETER;
        }
        break;

    case FILE_PATH_TYPE_EFI:
        dp = (EFI_DEVICE_PATH *)FilePath->FilePath;
        while (TRUE) {
            if (((PUCHAR)dp + sizeof(EFI_DEVICE_PATH)) > Max) {
                //DbgPrint( "ExpVerifyFilePath: EFI device path overruns buffer end\n" );
                return STATUS_INVALID_PARAMETER;
            }
            length = DevicePathNodeLength(dp);
            if (((PUCHAR)dp + length) > Max) {
                //DbgPrint( "ExpVerifyFilePath: EFI device path overruns buffer end\n" );
                return STATUS_INVALID_PARAMETER;
            }
            dpMax = (PUCHAR)dp + length;
            if (IsDevicePathEndType(dp)) {
                break;
            }
            if ((DevicePathType(dp) == MEDIA_DEVICE_PATH) &&
                (DevicePathSubType(dp) == MEDIA_FILEPATH_DP)) {
                FILEPATH_DEVICE_PATH *fp = (FILEPATH_DEVICE_PATH *)dp;
                if (ExpSafeWcslen(fp->PathName, (PWCHAR)dpMax) == 0xffffffff) {
                    //DbgPrint( "ExpVerifyFilePath: EFI filepath string overruns buffer end\n" );
                    return STATUS_INVALID_PARAMETER;
                }
            }
            dp = NextDevicePathNode(dp);
        }
        break;

    default:
        ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;

} // ExpVerifyFilePath

NTSTATUS
ExpVerifyWindowsOsOptions (
    PWINDOWS_OS_OPTIONS WindowsOsOptions,
    ULONG Length
    )
{
    PUCHAR Max = (PUCHAR)WindowsOsOptions + Length;
    ULONG loadOptionsLength = ExpSafeWcslen(WindowsOsOptions->OsLoadOptions, (PWSTR)Max);
    PFILE_PATH windowsFilePath;

    if ((WindowsOsOptions->Length < FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) ||
        (WindowsOsOptions->Length > Length) ||
        (WindowsOsOptions->Version == 0) ||
        (WindowsOsOptions->Version > WINDOWS_OS_OPTIONS_VERSION) ||
        ((WindowsOsOptions->OsLoadPathOffset & (sizeof(ULONG) - 1)) != 0) ||
        (WindowsOsOptions->OsLoadPathOffset >= Length) ||
        (loadOptionsLength == 0xffffffff) ||
        ((PUCHAR)(WindowsOsOptions->OsLoadOptions + loadOptionsLength + 1) >
            (PUCHAR)ADD_OFFSET(WindowsOsOptions, OsLoadPathOffset))) {
        return STATUS_INVALID_PARAMETER;
    }

    windowsFilePath = ADD_OFFSET(WindowsOsOptions, OsLoadPathOffset);
    return ExpVerifyFilePath(windowsFilePath, Max);

} // ExpVerifyWindowsOsOptions


NTSTATUS
ExpParseArcPathName (
    IN PWSTR ArcName,
    OUT PWSTR *ppDeviceName,
    OUT PWSTR *ppPathName,
    OUT PULONG pDeviceNameCount,
    OUT PBOOLEAN pSignatureFormat
    )
{
#define SIGNATURE_PREFIX    L"signature("
#define SIGNATURE_PREFIX_COUNT  10
#define BUFFER_COUNT        (SIGNATURE_PREFIX_COUNT + 1)

    PWSTR CurrentName, pathName = NULL;
    WCHAR signaturePrefix[ BUFFER_COUNT ];
    ULONG i;
    BOOLEAN SigFormat = FALSE, PrefixFound = TRUE;

    if( ArcName == NULL ) {
        return( STATUS_INVALID_PARAMETER );
    }

    wcscpy( signaturePrefix, SIGNATURE_PREFIX );

    //
    // check if the ArcName has a signature() format
    //
    for( i = 0; i < SIGNATURE_PREFIX_COUNT; i++ ) {
        if( towlower(ArcName[ i ]) != signaturePrefix[ i ] ) {
            PrefixFound = FALSE;
            break;
        }
    }

    CurrentName = ArcName;
    if( PrefixFound == TRUE ) {
        CurrentName += SIGNATURE_PREFIX_COUNT;
    }

    i = 0;
    while( CurrentName[ i ] != UNICODE_NULL ) {
        //
        // Check if FilePathName has been reached
        //
        if( CurrentName[ i ] == '\\' ) {
            pathName = CurrentName;
            pathName += i;
            break;
        }

        if( (PrefixFound == TRUE) && (CurrentName[ i ] == ')') ) {
            SigFormat = TRUE;
            PrefixFound = FALSE;    // set to FALSE, to stop checking

            //
            // the FilePathName or UNICODE_NULL must follow
            //
            if( (CurrentName[ i + 1 ] != '\\') &&
                (CurrentName[ i + 1 ] != UNICODE_NULL) ) {

                return( STATUS_INVALID_PARAMETER );
            }
        }

        i++;
    }

    //
    // if PrefixFound is still set
    //      the corresponding ')' was not found
    // if i == 0
    //      DeviceName does not exist
    //
    if( (PrefixFound == TRUE) || (i == 0) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    *ppDeviceName = CurrentName;
    *ppPathName = pathName;
    *pDeviceNameCount = i;
    *pSignatureFormat = SigFormat;

    return( STATUS_SUCCESS );

} // ExpParseArcPathName


NTSTATUS
ExpParseSignatureName (
    IN PWSTR deviceName,
    IN ULONG deviceNameCount,
    OUT PDISK_SIGNATURE_NEW diskSignature,
    OUT PULONG partitionNumber,
    OUT PULONGLONG partitionStart,
    OUT PULONGLONG partitionSize,
    OUT PBOOLEAN GPTpartition,
    OUT PBOOLEAN longSignature
    )
{
    UNICODE_STRING bufferString;
    ULONG i, prevI, chCount;
    PWSTR numberString, currentName;
    BOOLEAN foundGUID = FALSE, prettyGUID = FALSE;
    BOOLEAN longSigFound = FALSE;
    NTSTATUS status;

    //
    // Possible formats
    //
    if( deviceName[ 0 ] == '{' ) {
        foundGUID = TRUE;
    }

    //
    // parse the GUID or signature
    //
    i = 0;
    while( i < deviceNameCount ) {
        if( deviceName[ i ] == ')' ) {
            break;
        }
        if( foundGUID == TRUE ) {
            if( deviceName[ i ] == '}' ) {
                prettyGUID = TRUE;
                break;
            }
        }
        else {
            if( deviceName[ i ] == '-' ) {
                break;
            }
        }
        i++;
    }

    //
    // Verify that pretty GUID format has a '}'
    // {33221100-5544-7766-8899-aabbccddeeff}
    //
    if( (foundGUID == TRUE) && (prettyGUID == FALSE) ) {
        return( STATUS_INVALID_PARAMETER );
    }

#define MBR_SIGNATURE_COUNT 8
    if( i > MBR_SIGNATURE_COUNT ) {
        foundGUID = TRUE;
    }

    if( (foundGUID == TRUE) && (prettyGUID == TRUE) ) {
        //
        // pretty GUID format
        // {33221100-5544-7766-8899-aabbccddeeff}
        //

        bufferString.Buffer = deviceName;
        //
        // (+ 1) for the '}' to be included in the string
        //
        i++;
        bufferString.Length = (USHORT)(i * sizeof(WCHAR));
        bufferString.MaximumLength = bufferString.Length;

        status = RtlGUIDFromString(
                    &bufferString,
                    &(diskSignature->Guid)
                    );
        if( !NT_SUCCESS(status) ) {
            return status;
        }
    }
    else {
        numberString = ExAllocatePoolWithTag(
                            NonPagedPool,
                            (i + 1) * sizeof(WCHAR),
                            'rvnE'
                            );

        if ( numberString == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        wcsncpy( numberString, deviceName, i );
        numberString[ i ] = UNICODE_NULL;

        if( foundGUID == FALSE ) {
            //
            // MBR Signature format
            // 8459abcc
            //
            status = ExpTranslateHexStringToULONG(
                        numberString,
                        &(diskSignature->Signature)
                        );
        }
        else {
            //
            // ordinary GUID format
            // 00112233445566778899aabbccddeeff
            //
            status = ExpTranslateHexStringToGUID (
                        numberString,
                        &(diskSignature->Guid)
                        );
        }
        ExFreePool( numberString );
        if( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    //
    // check if there is more information in the signature name
    //
    if( (i < deviceNameCount) && (deviceName[ i ] == '-') ) {
        longSigFound = TRUE;
        i++;
        //
        // need to parse <part#>-<start>-<size>)
        //  <part#> - 8 hex digits representing the ULONG partition number.
        //      (Formatted using %08x.)
        //  <start> - 16 hex digits representing the ULONGLONG starting LBA.
        //      (Formatted using %016I64x.)
        //  <size> - 16 hex digits representing the ULONGLONG partition size.
        //      (Formatted using %016I64x.)
        //
        if( i >= deviceNameCount ) {
            return( STATUS_INVALID_PARAMETER );
        }

#define ULONG_COUNT 8
#define ULONGLONG_COUNT 16
        //
        // Allocate a buffer to hold a ULONGLONG
        //
        numberString = ExAllocatePoolWithTag(
                            NonPagedPool,
                            (ULONGLONG_COUNT + 1) * sizeof(WCHAR),
                            'rvnE'
                            );

        if ( numberString == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        prevI = i;
        currentName = deviceName;
        currentName += i;
        while( i < deviceNameCount ) {
            if( deviceName[ i ] == '-' ) {
                break;
            }
            i++;
        }

        chCount = i - prevI;

        if( (chCount == 0) || (chCount > ULONG_COUNT) ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        wcsncpy( numberString, currentName, chCount );
        numberString[ chCount ] = UNICODE_NULL;

        status = ExpTranslateHexStringToULONG( numberString, partitionNumber );
        if( !NT_SUCCESS(status) ) {
            ExFreePool( numberString );
            return status;
        }

        //
        // get the partition start
        //
        i++;
        if( i >= deviceNameCount ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        prevI = i;
        currentName = deviceName;
        currentName += i;
        while( i < deviceNameCount ) {
            if( deviceName[ i ] == '-' ) {
                break;
            }
            i++;
        }

        chCount = i - prevI;
        if( (chCount == 0) || (chCount > ULONGLONG_COUNT) ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        wcsncpy( numberString, currentName, chCount );
        numberString[ chCount ] = UNICODE_NULL;

        status = ExpTranslateHexStringToULONGLONG( numberString, partitionStart );
        if( !NT_SUCCESS(status) ) {
            ExFreePool( numberString );
            return status;
        }

        //
        // get the partition size
        //
        i++;
        if( i >= deviceNameCount ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        prevI = i;
        currentName = deviceName;
        currentName += i;
        while( i < deviceNameCount ) {
            if( deviceName[ i ] == ')' ) {  // should be a ')' delimiter
                break;
            }
            i++;
        }

        chCount = i - prevI;
        if( (chCount == 0) || (chCount > ULONGLONG_COUNT) ) {
            ExFreePool( numberString );
            return( STATUS_INVALID_PARAMETER );
        }

        wcsncpy( numberString, currentName, chCount );
        numberString[ chCount ] = UNICODE_NULL;

        status = ExpTranslateHexStringToULONGLONG( numberString, partitionSize );
        ExFreePool( numberString );
        if( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    //
    // At this point,
    // current positition should not pass the last char. of the buffer
    // current positition should be a ')'
    // MBR signature must have the long signature() format (need partition number)
    //
    if( (i >= deviceNameCount) ||
        (deviceName[ i ] != ')') ||
        ((foundGUID == FALSE) && (longSigFound == FALSE)) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    *GPTpartition = foundGUID;
    *longSignature = longSigFound;
    return( STATUS_SUCCESS );

} // ExpParseSignatureName


NTSTATUS
ExpParseEfiPath(
    IN EFI_DEVICE_PATH *pDevicePath,
    OUT HARDDRIVE_DEVICE_PATH **ppHardDriveDP,
    OUT PWSTR *ppPathName,
    OUT PBOOLEAN GPTpartition
    )

/*++
Routine Description:

    Parse the EFI_DEVICE_PATH into the HARDDRIVE node and
    entire PathName from the FILEPATH nodes

    Assumptions:
        - Parsing will stop at the first END_DEVICE_PATH node
        - The node graph of the Device path should be
            [~(HARDDRIVE, END_DEVICE_PATH)]* -> [HARDRIVE] -> [FILEPATH]* -> [END_DEVICE_PATH]

Arguments:

    pDevicePath - Receives an EFI_DEVICE_PATH

    ppHardDriveDP - Will receive a pointer to the
        HARDDRIVE_DEVICE_PATH node

    ppPathName - Will receive a pointer to the
        entire PathName from all the FILEPATH_DEVICE_PATH
        NULL - if the FILEPATH_DEVICE_PATH node does not exist

    GPTpartition - Will receive the type of partition
        TRUE  - GPT partition
        FALSE - MBR partition

Return Value:

    An appropriate status value.

--*/

{
    EFI_DEVICE_PATH *pDevPath;
    HARDDRIVE_DEVICE_PATH UNALIGNED *pHD_DP = NULL;
    FILEPATH_DEVICE_PATH *pFP_DP = NULL;
    ULONG fpLength,dpLength;
    PWSTR pFilePathName;
    NTSTATUS Status;

    fpLength = 0;
    dpLength = 0;
    pDevPath = pDevicePath;
    Status = STATUS_INVALID_PARAMETER;

    while( IsDevicePathEndType( pDevPath ) == FALSE ) {

        if( ( DevicePathType( pDevPath ) != MEDIA_DEVICE_PATH ) ||
            ( DevicePathSubType( pDevPath ) != MEDIA_HARDDRIVE_DP ) ) {
            pDevPath = NextDevicePathNode( pDevPath );
        }
        else {
            //
            // return the HardDrive node
            //
            pHD_DP = (HARDDRIVE_DEVICE_PATH UNALIGNED *)pDevPath;

            //
            // Assume successful operations until an error is detected
            //
            Status = STATUS_SUCCESS;
            dpLength += DevicePathNodeLength( pDevPath );
            pDevPath = NextDevicePathNode( pDevPath );

            if( ( DevicePathType( pDevPath ) == MEDIA_DEVICE_PATH ) &&
                ( DevicePathSubType( pDevPath ) == MEDIA_FILEPATH_DP ) ) {

                //
                // return the FilePath node
                //
                pFP_DP = (FILEPATH_DEVICE_PATH *)pDevPath;

                //
                // Sum up the lengths of all PathNames in the
                // FilePath nodes
                //
                do {
                    //
                    // Length of PathName is
                    //   FILEPATH_DEVICE_PATH.Length - (offset to PathName field)
                    //
                    fpLength += (DevicePathNodeLength(pDevPath) -
                                    FIELD_OFFSET(FILEPATH_DEVICE_PATH, PathName));
                    dpLength += DevicePathNodeLength( pDevPath );
                    pDevPath = NextDevicePathNode( pDevPath );

                } while( ( DevicePathType( pDevPath ) == MEDIA_DEVICE_PATH ) &&
                         ( DevicePathSubType( pDevPath ) == MEDIA_FILEPATH_DP ) );
            }

            //
            // At this point, the node must be a END_DEVICE_PATH
            //
            if( IsDevicePathEndType( pDevPath ) == FALSE ) {
                Status = STATUS_INVALID_PARAMETER;
            }

            break;
        }
    }

    //
    // If no MEDIA/HARDDRIVE element was found, we cannot continue. The
    // MEDIA/FILEPATH element is optional.
    //
    if( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    //
    // Check the partition type, must be GPT or MBR
    //
    if( pHD_DP->SignatureType == SIGNATURE_TYPE_GUID ) {
        *GPTpartition = TRUE;
    }
    else {
        if ( pHD_DP->SignatureType == SIGNATURE_TYPE_MBR ) {
            *GPTpartition = FALSE;
        }
        else {
            //DbgPrint( "ExpParseEfiPath: partition signature type unknown\n" );
            return( STATUS_INVALID_PARAMETER );
        }
    }

    if( fpLength != 0 ) {
        fpLength += sizeof(WCHAR);      // add null-terminator
        pFilePathName = ExAllocatePoolWithTag( NonPagedPool, fpLength, 'rvnE' );
        if( pFilePathName == NULL ) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }

        wcscpy( pFilePathName, pFP_DP->PathName );

        pDevPath = (EFI_DEVICE_PATH *)pFP_DP;
        pDevPath = NextDevicePathNode( pDevPath );

        while( IsDevicePathEndType( pDevPath ) == FALSE ) {
            pFP_DP = (FILEPATH_DEVICE_PATH *)pDevPath;
            wcscat( pFilePathName, pFP_DP->PathName );
            pDevPath = NextDevicePathNode( pDevPath );
        }
    }
    else {
        pFilePathName = NULL;
    }

    //
    // almost done.  allocate an aligned buffer for the device path and copy
    // the unaligned contents into this buffer.
    //
    *ppHardDriveDP = ExAllocatePoolWithTag( NonPagedPool, dpLength, 'rvnE' );
    if (*ppHardDriveDP == NULL) {
        if (pFilePathName) {
            ExFreePool(pFilePathName);            
        }
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlCopyMemory( *ppHardDriveDP, pHD_DP, dpLength );
    *ppPathName = pFilePathName;

    return( Status );
} // ExpParseEfiPath


NTSTATUS
ExpConvertArcName(
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PWSTR pDeviceName,
    IN PWSTR pPathName,
    IN ULONG DeviceNameCount
    )
{
    ULONG requiredCount, requiredLength, filePathLength;
    PWSTR linkName;
    UNICODE_STRING deviceNameString;
    PWCHAR p;
    PFILE_PATH filePath;
    NTSTATUS status;

    //
    // Allocate Pool to hold the ArcName's NT Name
    //
#define ARC_DIR_PREFIX  L"\\ArcName\\"
#define ARC_DIR_PREFIX_COUNT    9

    requiredCount = DeviceNameCount + ARC_DIR_PREFIX_COUNT + 1;
    requiredLength = requiredCount * sizeof(WCHAR);
    linkName = ExAllocatePoolWithTag( NonPagedPool, requiredLength, 'rvnE' );
    if ( linkName == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    wcscpy( linkName, ARC_DIR_PREFIX );
    wcsncat( linkName, pDeviceName, DeviceNameCount );
    linkName[ requiredCount - 1 ] = UNICODE_NULL;

    if( OutputType == FILE_PATH_TYPE_NT ) {
        //
        // Open the symbolic link object & drill down to the target
        // return symbolic link target
        //
        status = ExpTranslateSymbolicLink(
                    linkName,
                    &deviceNameString
                    );
        ExFreePool( linkName );
        if ( !NT_SUCCESS(status) ) {
            return( status );
        }

        status = ExpCreateOutputNT(
                    OutputPath,
                    OutputPathLength,
                    &deviceNameString,
                    pPathName
                    );
        ExFreePool( deviceNameString.Buffer );
        return( status );
    }

    //
    // Output type is either FILE_PATH_TYPE_EFI or FILE_PATH_TYPE_ARC_SIGNATURE
    // and we have a NT name, so use ExpTranslateNtPath() for the conversion
    // Create a input FILE_PATH with the NT name
    //
    filePathLength = requiredLength + FIELD_OFFSET(FILE_PATH, FilePath);
    if ( pPathName != NULL ) {
        filePathLength += ((ULONG)(wcslen( pPathName )) * sizeof(WCHAR));
    }

    filePathLength += sizeof(WCHAR);

    filePath = ExAllocatePoolWithTag( NonPagedPool, filePathLength, 'rvnE' );

    if ( filePath == NULL ) {
        ExFreePool( linkName );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the input file path.
    //
    filePath->Version = FILE_PATH_VERSION;
    filePath->Length = filePathLength;
    filePath->Type = FILE_PATH_TYPE_NT;

    p = (PWSTR)filePath->FilePath;
    wcscpy( p, linkName );
    p = (PWSTR)((PUCHAR)p + requiredLength);

    ExFreePool( linkName );

    if ( pPathName != NULL ) {
        wcscpy( p, pPathName );
    }
    else {
        *p = UNICODE_NULL;
    }

    status = ExpTranslateNtPath(
                filePath,
                OutputType,
                OutputPath,
                OutputPathLength
                );

    ExFreePool( filePath );

    return( status );
} // ExpConvertArcName


NTSTATUS
ExpConvertSignatureName(
    IN ULONG OutputType,
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PWSTR pDeviceName,
    IN PWSTR pPathName,
    IN ULONG DeviceNameCount
    )
{
    DISK_SIGNATURE_NEW diskSignature;
    ULONG inputPartitionNumber, outputPartitionNumber;
    ULONG diskNumber;
    ULONGLONG inputPartitionStart, outputPartitionStart;
    ULONGLONG inputPartitionSize, outputPartitionSize;
    BOOLEAN GPTpartition, longSignature;
    PWSTR pDiskName;
    UNICODE_STRING DiskNameString;
    NTSTATUS status;

    //
    // Determine the signature() format
    //
    status = ExpParseSignatureName (
                pDeviceName,
                DeviceNameCount,
                &diskSignature,
                &inputPartitionNumber,
                &inputPartitionStart,
                &inputPartitionSize,
                &GPTpartition,
                &longSignature
                );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // if signature(<guid/signature>-<part#>-<start>-<size>) format &&
    //    ( OutputType == FILE_PATH_TYPE_EFI )
    //        return EFI_DEVICE_PATH format
    //
    if( (longSignature == TRUE) && (OutputType == FILE_PATH_TYPE_EFI) ) {
        status = ExpCreateOutputEFI(
                    OutputPath,
                    OutputPathLength,
                    &diskSignature,
                    &inputPartitionNumber,
                    &inputPartitionStart,
                    &inputPartitionSize,
                    pPathName,
                    GPTpartition
                    );
        return( status );
    }

    //
    // open all disks and search for partition GUID
    //
    if( GPTpartition == FALSE ) {
        outputPartitionNumber = inputPartitionNumber;
    }
    status = ExpFindDiskSignature(
                &diskSignature,
                &outputPartitionNumber,
                &diskNumber,
                &outputPartitionStart,
                &outputPartitionSize,
                GPTpartition
                );

    if ( !NT_SUCCESS(status) ) {
        return status;
    }

    //
    // If the user has provided the partition number, start address,
    // and size; then verify the input with the found results.
    //
    if( (longSignature == TRUE) &&
        ( (inputPartitionNumber != outputPartitionNumber) ||
          (inputPartitionStart != outputPartitionStart) ||
          (inputPartitionSize != outputPartitionSize)
        ) ) {

        return( STATUS_INVALID_PARAMETER );
    }

    if( OutputType == FILE_PATH_TYPE_EFI ) {
        status = ExpCreateOutputEFI(
                    OutputPath,
                    OutputPathLength,
                    &diskSignature,
                    &outputPartitionNumber,
                    &outputPartitionStart,
                    &outputPartitionSize,
                    pPathName,
                    GPTpartition
                    );
        return( status );
    }

    //
    // translate \Device\Harddisk[diskNumber]\Partition[PartitionNumber]
    //
#define DISK_NAME_FORMAT L"\\Device\\Harddisk%lu\\Partition%lu"
#define DISK_NAME_COUNT 47    // 7 + 9 + (10) + 10 + (10) + 1

    pDiskName = ExAllocatePoolWithTag(
                    NonPagedPool,
                    ( DISK_NAME_COUNT * sizeof( WCHAR ) ),
                    'rvnE'
                    );

    if( pDiskName == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    _snwprintf(
        pDiskName,
        DISK_NAME_COUNT,
        DISK_NAME_FORMAT,
        diskNumber,
        outputPartitionNumber
        );

    status = ExpTranslateSymbolicLink(
                pDiskName,
                &DiskNameString
                );
    ExFreePool( pDiskName );
    if ( !NT_SUCCESS(status) ) {
        return( status );
    }

    if( OutputType == FILE_PATH_TYPE_NT ) {
        status = ExpCreateOutputNT(
                    OutputPath,
                    OutputPathLength,
                    &DiskNameString,
                    pPathName
                    );
        ExFreePool( DiskNameString.Buffer );
        return( status );
    }

    if( OutputType == FILE_PATH_TYPE_ARC ) {
        status = ExpCreateOutputARC(
                    OutputPath,
                    OutputPathLength,
                    &DiskNameString,
                    pPathName
                    );
        ExFreePool( DiskNameString.Buffer );
        return( status );
    }

    ExFreePool( DiskNameString.Buffer );
    return( STATUS_INVALID_PARAMETER );
} // ExpConvertSignatureName


NTSTATUS
ExpTranslateHexStringToULONG (
    IN PWSTR Name,
    OUT PULONG Number
    )
{
    ULONG number;
    ULONG i, max;
    WCHAR c;

#define ULONG_HEX_MAX 8

    max = (ULONG)wcslen( Name );

    if( max > ULONG_HEX_MAX ) {
        return( STATUS_INVALID_PARAMETER );
    }

    number = 0;
    for (i = 0; i < max; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return( STATUS_INVALID_PARAMETER );
        }
    }

    *Number = number;
    return( STATUS_SUCCESS );

} // ExpTranslateHexStringToULONG


NTSTATUS
ExpTranslateHexStringToULONGLONG (
    IN PWSTR Name,
    OUT PULONGLONG Number
    )
{
    ULONGLONG number;
    ULONG i, max;
    WCHAR c;

#define ULONGLONG_HEX_MAX 16

    max = (ULONG)wcslen( Name );

    if( max > ULONGLONG_HEX_MAX ) {
        return( STATUS_INVALID_PARAMETER );
    }

    number = 0;
    for (i = 0; i < max; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return( STATUS_INVALID_PARAMETER );
        }
    }

    *Number = number;
    return( STATUS_SUCCESS );

} // ExpTranslateHexStringToULONGLONG


NTSTATUS
ExpTranslateHexStringToGUID (
    IN PWSTR Name,
    OUT GUID *pGuid
    )
{
    GUID resultGuid;
    ULONG i, max, number, result;
    USHORT formatStyle, position;
    WCHAR c;

#define GUID_HEX_MAX 32

    max = (ULONG)wcslen( Name );

    if( max != GUID_HEX_MAX ) {
        return( STATUS_INVALID_PARAMETER );
    }

    number = 0;
    formatStyle = 0;
    position = 0;
    result = 0;
    for (i = 0; i < max; i++) {
        c = towlower(Name[i]);
        if ((c >= L'0') && (c <= L'9')) {
            number = (number * 16) + (c - L'0');
        } else if ((c >= L'a') && (c <= L'f')) {
            number = (number * 16) + (c - L'a' + 10);
        } else {
            return( STATUS_INVALID_PARAMETER );
        }

        if ((i % 2) == 1) {
            switch( formatStyle ) {
            case 0:
                result += (number << (position * 8));
                position++;
                if( position == 4 ) {
                    resultGuid.Data1 = result;
                    formatStyle++;
                    position = 0;
                    result = 0;
                }
                break;
            case 1:
                result += (number << (position * 8));
                position++;
                if( position == 2 ) {
                    resultGuid.Data2 = (USHORT)result;
                    formatStyle++;
                    position = 0;
                    result = 0;
                }
                break;
            case 2:
                result += (number << (position * 8));
                position++;
                if( position == 2 ) {
                    resultGuid.Data3 = (USHORT)result;
                    formatStyle++;
                    position = 0;
                    result = 0;
                }
                break;
            case 3:
                resultGuid.Data4[ position ] = (UCHAR)number;
                position++;
                if( position == 8 ) {
                    formatStyle++;
                }
                break;
            default:
                return( STATUS_INVALID_PARAMETER );
                break;
            }
            number = 0;
        }
    }

    memcpy(pGuid, &(resultGuid), sizeof(GUID));
    return( STATUS_SUCCESS );

} // ExpTranslateHexStringToGUID


NTSTATUS
ExpCreateOutputEFI (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PDISK_SIGNATURE_NEW pDiskSignature,
    IN PULONG pPartitionNumber,
    IN PULONGLONG pPartitionStart,
    IN PULONGLONG pPartitionSize,
    IN PWSTR pPathName,
    IN BOOLEAN GPTpartition
    )
{
    ULONG requiredLength, pathNameLength = 0;
    EFI_DEVICE_PATH *dp;
    HARDDRIVE_DEVICE_PATH UNALIGNED *dpHarddrive = NULL;
    FILEPATH_DEVICE_PATH *dpFilepath = NULL;

    //
    // The output EFI file path consists of two elements. First is a
    // MEDIA/HARDDRIVE element describing the partition. Second is an
    // optional MEDIA/FILEPATH element describing the path to a directory
    // or a file.
    //

    requiredLength = FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += sizeof(HARDDRIVE_DEVICE_PATH);
    if (pPathName != NULL) {
        pathNameLength = (ULONG)wcslen(pPathName);
        pathNameLength = (pathNameLength + 1) * sizeof(WCHAR);
        requiredLength += FIELD_OFFSET(FILEPATH_DEVICE_PATH, PathName);
        requiredLength += pathNameLength;
    }
    requiredLength += sizeof(EFI_DEVICE_PATH);

    //
    // Compare the required length against the output buffer length.
    //

    if ( *OutputPathLength < requiredLength ) {
        *OutputPathLength = requiredLength;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Build the output file path.
    //

    OutputPath->Version = FILE_PATH_VERSION;
    OutputPath->Length = requiredLength;
    OutputPath->Type = FILE_PATH_TYPE_EFI;

    dp = (EFI_DEVICE_PATH *)OutputPath->FilePath;
    dpHarddrive = (HARDDRIVE_DEVICE_PATH UNALIGNED *)dp;
    dp->Type = MEDIA_DEVICE_PATH;
    dp->SubType = MEDIA_HARDDRIVE_DP;
    SetDevicePathNodeLength(dp, sizeof(HARDDRIVE_DEVICE_PATH));
    dpHarddrive->PartitionNumber = *pPartitionNumber;
    dpHarddrive->PartitionStart = *pPartitionStart;
    dpHarddrive->PartitionSize = *pPartitionSize;
    if (GPTpartition == TRUE) {
        memcpy(dpHarddrive->Signature, &(pDiskSignature->Guid), sizeof(GUID));
        dpHarddrive->MBRType = MBR_TYPE_EFI_PARTITION_TABLE_HEADER;
        dpHarddrive->SignatureType = SIGNATURE_TYPE_GUID;
    } else {
        memcpy(dpHarddrive->Signature, &(pDiskSignature->Signature), sizeof(ULONG));
        dpHarddrive->MBRType = MBR_TYPE_PCAT;
        dpHarddrive->SignatureType = SIGNATURE_TYPE_MBR;
    }

    if (pPathName != NULL) {
        dp = NextDevicePathNode(dp);
        dpFilepath = (FILEPATH_DEVICE_PATH *)dp;
        dp->Type = MEDIA_DEVICE_PATH;
        dp->SubType = MEDIA_FILEPATH_DP;
        SetDevicePathNodeLength(dp, FIELD_OFFSET(FILEPATH_DEVICE_PATH, PathName) + pathNameLength);
        wcscpy(dpFilepath->PathName, pPathName);
    }

    dp = NextDevicePathNode(dp);
    SetDevicePathEndNode(dp);

    *OutputPathLength = requiredLength;
    return STATUS_SUCCESS;

} // ExpCreateOutputEFI


NTSTATUS
ExpCreateOutputNT (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PUNICODE_STRING pDeviceNameString,
    IN PWSTR pPathName
    )
{
    ULONG requiredLength;
    PWCHAR p;

    requiredLength = pDeviceNameString->Length + sizeof(WCHAR);

    //
    // If a PathName component is present, then increase the
    // output string length by the length of the path string.
    //

    if ( pPathName != NULL ) {
        requiredLength += ((ULONG)(wcslen( pPathName )) * sizeof(WCHAR));
    }

    //
    // always add a UNICODE_NULL for PathName even if PathName is not present
    //
    requiredLength += sizeof(WCHAR);

    //
    // Add the structure overhead and compare the required length against
    // output buffer length.
    //

    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);

    if ( *OutputPathLength < requiredLength ) {
        *OutputPathLength = requiredLength;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Build the output file path.
    //

    OutputPath->Version = FILE_PATH_VERSION;
    OutputPath->Length = requiredLength;
    OutputPath->Type = FILE_PATH_TYPE_NT;

    p = (PWSTR)OutputPath->FilePath;
    wcscpy( p, pDeviceNameString->Buffer );
    p = (PWSTR)((PUCHAR)p + pDeviceNameString->Length + sizeof(WCHAR));

    if ( pPathName != NULL ) {
        wcscpy( p, pPathName );
    }
    else {
        *p = UNICODE_NULL;
    }

    *OutputPathLength = requiredLength;
    return STATUS_SUCCESS;

} // ExpCreateOutputNT


NTSTATUS
ExpCreateOutputARC (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PUNICODE_STRING pDeviceNameString,
    IN PWSTR pPathName
    )
{
    ULONG requiredLength, ArcNameLength;
    PWCHAR p;
    PWSTR pArcDeviceName;
    NTSTATUS status;

    status = ExpFindArcName(
                pDeviceNameString,
                &pArcDeviceName
                );
    if (!NT_SUCCESS(status)) {
        return( status );
    }

    ArcNameLength = ((ULONG)wcslen(pArcDeviceName)) * sizeof(WCHAR);
    requiredLength = ArcNameLength + sizeof(WCHAR);

    //
    // If a PathName component is present, then increase the
    // output string length by the length of the path string.
    //

    if ( pPathName != NULL ) {
        requiredLength += ((ULONG)(wcslen( pPathName )) * sizeof(WCHAR));
    }

    //
    // Add the structure overhead and compare the required length against
    // output buffer length.
    //

    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);

    if ( *OutputPathLength < requiredLength ) {
        *OutputPathLength = requiredLength;
        ExFreePool( pArcDeviceName );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Build the output file path.
    //

    OutputPath->Version = FILE_PATH_VERSION;
    OutputPath->Length = requiredLength;
    OutputPath->Type = FILE_PATH_TYPE_ARC;

    p = (PWSTR)OutputPath->FilePath;
    wcscpy( p, pArcDeviceName );
    p = (PWSTR)((PUCHAR)p + ArcNameLength);
    ExFreePool( pArcDeviceName );

    if ( pPathName != NULL ) {
        wcscpy( p, pPathName );
    }

    *OutputPathLength = requiredLength;
    return STATUS_SUCCESS;

} // ExpCreateOutputARC


NTSTATUS
ExpCreateOutputSIGNATURE (
    OUT PFILE_PATH OutputPath,
    IN OUT PULONG OutputPathLength,
    IN PDISK_SIGNATURE_NEW pDiskSignature,
    IN PULONG pPartitionNumber,
    IN PULONGLONG pPartitionStart,
    IN PULONGLONG pPartitionSize,
    IN PWSTR pPathName,
    IN BOOLEAN GPTpartition
    )
{
    ULONG requiredLength, pathNameCount;
    PWCHAR p;
    UNICODE_STRING GuidString;
    NTSTATUS status;

    //
    // We will convert the EFI device path into an ARC name with this
    // format:
    //
    //  signature(<guid/signature>-<part#>-<start>-<size>)
    //
    // Where:
    //
    //  <guid/signature> - For a GPT disk, the GPT partition GUID in
    //      "pretty" format ({33221100-5544-7766-8899-aabbccddeeff}).
    //      For an MBR disk, 8 hex digits representing the ULONG MBR
    //      disk signature. (Formatted using %08x.)
    //  <part#> - 8 hex digits representing the ULONG partition number.
    //      (Formatted using %08x.)
    //  <start> - 16 hex digits representing the ULONGLONG starting LBA.
    //      (Formatted using %016I64x.)
    //  <size> - 16 hex digits representing the ULONGLONG partition size.
    //      (Formatted using %016I64x.)
    //
    // For a GPT disk, the output string length is 86 WCHARs. For an
    // MBR disk, the output string length is 62 WCHARs.
    //

    requiredLength = (ULONG)strlen("signature(") +
                     1 +                        // "-"
                     (sizeof(ULONG) * 2) +      // <part#>
                     1 +                        // "-"
                     (sizeof(ULONGLONG) * 2) +  // <start>
                     1 +                        // "-"
                     (sizeof(ULONGLONG) * 2) +  // <size>
                     1 +                        // ")"
                     1;                         // null terminator

    if ( GPTpartition == TRUE ) {
        requiredLength += (sizeof(GUID) * 2);
        requiredLength += 6;    // for the {} & four '-' in the pretty GUID format
    } else {
        requiredLength += sizeof(ULONG) * 2;
    }

    //
    // If a pathName component is present, then increase the
    // output string length by the length of the path string.
    //

    if (pPathName != NULL) {
        pathNameCount = (ULONG)wcslen(pPathName);
        requiredLength += pathNameCount;
    }
    else {
        pathNameCount = 0;
    }

    //
    // Convert the string length to a byte count, add the structure
    // overhead, and compare the required length against output buffer
    // length.
    //

    requiredLength *= sizeof(WCHAR);
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);

    if ( *OutputPathLength < requiredLength ) {
        *OutputPathLength = requiredLength;
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Build the output file path.
    //

    OutputPath->Version = FILE_PATH_VERSION;
    OutputPath->Length = requiredLength;
    OutputPath->Type = FILE_PATH_TYPE_ARC_SIGNATURE;

    p = (PWSTR)OutputPath->FilePath;
    wcscpy( p, L"signature(" );
    p += wcslen( p );

    if ( GPTpartition == TRUE ) {
        status = RtlStringFromGUID(
                    (LPGUID)(&(pDiskSignature->Guid)),
                    &GuidString
                    );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }
        wcscat( p, GuidString.Buffer );
        p = (PWCHAR)((PUCHAR)p + GuidString.Length);
        ExFreePool( GuidString.Buffer );
    } else {
        swprintf( p, L"%08x", pDiskSignature->Signature );
        p += wcslen( p );
    }

    swprintf(
        p,
        L"-%08x-%016I64x-%016I64x)",
        *pPartitionNumber,
        *pPartitionStart,
        *pPartitionSize
        );
    p += wcslen( p );

    if ( pathNameCount != 0 ) {
        wcscpy( p, pPathName );
    }

    *OutputPathLength = requiredLength;
    return STATUS_SUCCESS;

} // ExpCreateOutputSIGNATURE


NTSTATUS
ExpFindArcName (
    IN PUNICODE_STRING pDeviceNameString,
    OUT PWSTR *pArcName
    )
{
    NTSTATUS status;
    UNICODE_STRING ArcString, SymLinkTypeString;
    OBJECT_ATTRIBUTES Attributes;
    PWSTR pArcDirName, pArcLinkName;
    HANDLE hArcDirectory;
    POBJECT_DIRECTORY_INFORMATION pDirInfo;
    ULONG dirInfoLength, neededLength, dirContext;
    ULONG arcNameCount;
    BOOLEAN restartScan, ArcNameFound = FALSE;

    //
    // Open a handle to the directory object for \ArcName
    // Get a kernel handle
    //
#define ARC_DIR_NAME    L"\\ArcName"
#define ARC_DIR_SIZE    (9 * sizeof(WCHAR))
#define ARC_DIR_NAME_PREFIX L"\\ArcName\\"
#define ARC_DIR_SIZE_PREFIX (9 * sizeof(WCHAR))

    pArcDirName = ExAllocatePoolWithTag( NonPagedPool, ARC_DIR_SIZE, 'rvnE' );
    if ( pArcDirName == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    wcscpy( pArcDirName, ARC_DIR_NAME );

    RtlInitUnicodeString( &ArcString, pArcDirName );

    InitializeObjectAttributes(
        &Attributes,
        &ArcString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenDirectoryObject(
                &hArcDirectory,
                DIRECTORY_QUERY,
                &Attributes
                );
    ExFreePool( pArcDirName );
    if (!NT_SUCCESS(status)) {
        return( status );
    }

    pDirInfo = NULL;
    dirInfoLength = 0;
    restartScan = TRUE;
    RtlInitUnicodeString( &SymLinkTypeString, L"SymbolicLink" );
    while (TRUE) {
        status = ZwQueryDirectoryObject(
                    hArcDirectory,
                    pDirInfo,
                    dirInfoLength,
                    TRUE,           // force one at a time
                    restartScan,
                    &dirContext,
                    &neededLength
                    );
        if (status == STATUS_BUFFER_TOO_SMALL) {
            dirInfoLength = neededLength;
            if (pDirInfo != NULL) {
                ExFreePool(pDirInfo);
            }
            pDirInfo = ExAllocatePoolWithTag( NonPagedPool, dirInfoLength, 'rvnE' );
            if (pDirInfo == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            status = ZwQueryDirectoryObject(
                        hArcDirectory,
                        pDirInfo,
                        dirInfoLength,
                        TRUE,       // force one at a time
                        restartScan,
                        &dirContext,
                        &neededLength
                        );
        }
        restartScan = FALSE;

        if (!NT_SUCCESS(status)) {
            if (status == STATUS_NO_MORE_ENTRIES) {
                status = STATUS_SUCCESS;
            }
            break;
        }

        //
        // Check if the element is not a symbolic link
        //
        if (RtlEqualUnicodeString(
                &(pDirInfo->TypeName),
                &SymLinkTypeString,
                FALSE) == FALSE) {
            continue;
        }

        neededLength = ARC_DIR_SIZE_PREFIX + pDirInfo->Name.Length;
        pArcLinkName = ExAllocatePoolWithTag(
                            NonPagedPool,
                            neededLength + sizeof(WCHAR),
                            'rvnE' );
        if ( pArcLinkName == NULL ) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        arcNameCount = pDirInfo->Name.Length/sizeof(WCHAR);
        wcscpy( pArcLinkName, ARC_DIR_NAME_PREFIX );
        wcsncat(
            pArcLinkName,
            pDirInfo->Name.Buffer,
            arcNameCount
            );
        pArcLinkName[ neededLength/sizeof(WCHAR) ] = UNICODE_NULL;

        //
        // Drill down this symbolic link to the device object
        //
        status = ExpTranslateSymbolicLink(
                    pArcLinkName,
                    &ArcString
                    );
        if ( !NT_SUCCESS(status) ) {
            ExFreePool( pArcLinkName );
            break;
        }

        //
        // Check if this Arc Name points the same device object
        //
        ArcNameFound = RtlEqualUnicodeString(
                            &ArcString,
                            pDeviceNameString,
                            TRUE
                            );
        ExFreePool( ArcString.Buffer );

        if (ArcNameFound == TRUE) {
            //
            // copy the arc name without the \ArcName\ prefix
            //
            wcsncpy(
                pArcLinkName,
                pDirInfo->Name.Buffer,
                arcNameCount
                );
            pArcLinkName[ arcNameCount ] = UNICODE_NULL;
            *pArcName = pArcLinkName;
            break;
        }
        ExFreePool( pArcLinkName );
    }

    if( NT_SUCCESS(status) && (ArcNameFound == FALSE ) ) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
    }

    if (pDirInfo != NULL) {
        ExFreePool(pDirInfo);
    }

    ZwClose( hArcDirectory );
    return( status );

} // ExpFindArcName


NTSTATUS
ExpFindDiskSignature (
    IN PDISK_SIGNATURE_NEW pSignature,
    IN OUT PULONG pPartitionNumber,
    OUT PULONG pDiskNumber,
    OUT PULONGLONG pPartitionStart,
    OUT PULONGLONG pPartitionSize,
    IN BOOLEAN GPTpartition
    )
/*++

Routine Description:

    This function searches all the disks on the system for the
    partition corresponding to the paritition GUID or
    (MBR signature, paritition number).

    N.B. for a MBR signature, the partition number must be provided.

Arguments:

    pSignature - Supplies a pointer to a partition GUID (GPT disk) or
        32-bit signature(MBR disk).

    pPartitionNumber - Supplies a pointer to a partition number when
        pSignature is a MBR signature.  For output, receives the
        partition number.

    pDiskNumber - Receives the disk number

    pPartitionStart - Receives the start of the partition

    pPartitionSize - Receives the size of the partition

    GPTpartition - Supplies the type of partition
        TRUE  - GPT disk partition
        FALSE - MBR disk partition

Return Value:

    STATUS_SUCCESS is returned if the partition is successfully found.

    STATUS_OBJECT_PATH_NOT_FOUND is returned if the partition could not
        be found.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
        for this request to complete.

--*/
{
    PDRIVE_LAYOUT_INFORMATION_EX    pDriveLayout = NULL;
    PPARTITION_INFORMATION_EX       pPartitionInfoEx = NULL;
    SYSTEM_DEVICE_INFORMATION       SysDevInfo;
    ULONG               PartitionStyle;
    BOOLEAN             PartitionFound = FALSE;
    ULONG               Index, PartitionIndex;
    PWSTR               pDeviceName;
    NTSTATUS            Status;

    //
    // Find all disks on the system
    //

    Status = ZwQuerySystemInformation(
                SystemDeviceInformation,
                &SysDevInfo,
                sizeof(SYSTEM_DEVICE_INFORMATION),
                NULL
                );

    if( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

#define DEVICE_NAME_FORMAT L"\\Device\\Harddisk%lu\\Partition0"
#define DEVICE_NAME_CHAR_COUNT 38    // 7 + 9 + (10) + 11 + 1
    //
    // Allocate the buffer for the disk names
    //
    pDeviceName = ExAllocatePoolWithTag(
                    NonPagedPool,
                    ( DEVICE_NAME_CHAR_COUNT * sizeof( WCHAR ) ),
                    'rvnE'
                    );

    if( pDeviceName == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    if( GPTpartition == TRUE ) {
        PartitionStyle = PARTITION_STYLE_GPT;
    }
    else {
        PartitionStyle = PARTITION_STYLE_MBR;
    }

    //
    // For each disk,
    // Get the Partition Table
    // Verify the partition style (MBR/GPT)
    //
    // if( Partition style matches )
    //      search for the Partition in the drive layout
    // else
    //      skip the disk
    //
    for( Index = 0; Index < SysDevInfo.NumberOfDisks; Index++ ) {

        //
        // Form the disk name
        // \Device\Harddisk[DiskNumber]\Partition0
        //
        _snwprintf(
                pDeviceName,
                DEVICE_NAME_CHAR_COUNT,
                DEVICE_NAME_FORMAT,
                Index
                );

        Status = ExpGetPartitionTableInfo(
                    pDeviceName,
                    &pDriveLayout
                    );

        if( !NT_SUCCESS( Status ) ) {
            continue;
        }

        if( pDriveLayout->PartitionStyle != PartitionStyle ) {
            ExFreePool( pDriveLayout );
            continue;
        }

        if( (PartitionStyle == PARTITION_STYLE_MBR) &&
            (pDriveLayout->Mbr.Signature != pSignature->Signature) ) {
            ExFreePool( pDriveLayout );
            continue;
        }

        //
        // search partition list
        //
        for( PartitionIndex = 0;
             PartitionIndex < pDriveLayout->PartitionCount;
             PartitionIndex++ ) {

            //
            // Get the partition entry
            //
            pPartitionInfoEx = (&(pDriveLayout->PartitionEntry[PartitionIndex]));

            if( PartitionStyle == PARTITION_STYLE_MBR ) {
                if (pPartitionInfoEx->PartitionNumber == *pPartitionNumber) {
                    PartitionFound = TRUE;
                    break;
                }
            }
            else {
                if (IsEqualGUID( &(pPartitionInfoEx->Gpt.PartitionId),
                                 &(pSignature->Guid) )) {
                    PartitionFound = TRUE;
                    break;
                }
            }
        }

        if( PartitionFound == TRUE ) {
            break;
        }
        ExFreePool( pDriveLayout );
    }


    if( NT_SUCCESS( Status ) && ( PartitionFound == FALSE ) ) {
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
    }

    //
    // Partition Found - copy the needed information
    //
    if( PartitionFound == TRUE ) {
        *pPartitionNumber = pPartitionInfoEx->PartitionNumber;
        *pDiskNumber = Index;
        *pPartitionStart = pPartitionInfoEx->StartingOffset.QuadPart;
        *pPartitionSize = pPartitionInfoEx->PartitionLength.QuadPart;
        ExFreePool( pDriveLayout );
    }

    ExFreePool( pDeviceName );
    return( Status );

} // ExpFindDiskSignature


NTSTATUS
ExpGetPartitionTableInfo (
    IN PWSTR pDeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION_EX *ppDriveLayout
    )
{
    NTSTATUS status;
    UNICODE_STRING string;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    PDRIVE_LAYOUT_INFORMATION_EX driveLayoutInfo = NULL;
    ULONG driveLayoutLength;

    //
    // Open the disk and get its partition table information.
    //

    RtlInitUnicodeString(&string, pDeviceName);

    InitializeObjectAttributes(
        &obja,
        &string,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenFile(
                &handle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE
                );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    driveLayoutLength = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry) +
                            (sizeof(PARTITION_INFORMATION_EX) * 16);

    while (TRUE) {

        driveLayoutInfo = ExAllocatePoolWithTag(NonPagedPool, driveLayoutLength, 'rvnE');
        if (driveLayoutInfo == NULL ) {
            ZwClose(handle);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = ZwDeviceIoControlFile(
                    handle,
                    NULL,
                    NULL,
                    NULL,
                    &iosb,
                    IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                    NULL,
                    0,
                    driveLayoutInfo,
                    driveLayoutLength
                    );
        if (NT_SUCCESS(status)) {
            break;
        }

        ExFreePool(driveLayoutInfo);
        if (status == STATUS_BUFFER_TOO_SMALL) {
            driveLayoutLength *= 2;
            continue;
        }
        ZwClose(handle);
        return status;
    }

    *ppDriveLayout = driveLayoutInfo;
    ZwClose(handle);
    return status;

} // ExpGetPartitionTableInfo

#endif // defined(EFI_NVRAM_ENABLED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=ex

TARGETNAME=ex
TARGETTYPE=LIBRARY
TARGETPATH=obj

BUILD_PRODUCES=ntosex$(NT_UP)

INCLUDES=..;..\..\inc;..\..\ke;..\..\kd64;$(SDKTOOLS_INC_PATH);$(HALKIT_INC_PATH);$(PROJECT_ROOT)\fs\fastfat

MSC_WARNING_LEVEL=/W4 /WX

SOURCES=..\callback.c  \
        ..\callperf.c  \
        ..\dbgctrl.c   \
        ..\delay.c     \
        ..\event.c     \
        ..\eventpr.c   \
        ..\exatom.c    \
        ..\exdata.c    \
        ..\exinfo.c    \
        ..\exinit.c    \
        ..\exdata.c    \
        ..\exhotp.c    \
        ..\fmutexc.c   \
        ..\handle.c    \
        ..\harderr.c   \
        ..\hdlsterm.c  \
        ..\lookasid.c  \
        ..\luid.c      \
        ..\mutant.c    \
        ..\nbqueue.c   \
        ..\pool.c      \
        ..\probe.c     \
        ..\profile.c   \
        ..\raise.c     \
        ..\resource.c  \
        ..\semphore.c  \
        ..\sysenv.c    \
        ..\sysinfo.c   \
        ..\systime.c   \
        ..\timer.c     \
        ..\worker.c    \
        ..\zone.c      \
        ..\uuid.c      \
        ..\win32.c     \
        ..\rundown.c   \
        ..\pushlock.c  \
        ..\xipdisp.c   \
        ..\keyedevent.c

PRECOMPILED_INCLUDE=..\exp.h
PRECOMPILED_PCH=exp.pch
PRECOMPILED_OBJ=exp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\resource.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

Author:

    Gary D. Kimura [GaryKi] 25-Jun-1989

    David N. Cutler (davec) 20-Mar-1994
        Substantially rewritten to make fastlock optimizations portable
        across all platforms and to improve the algorithms used to be
        perfectly synchronized.

Environment:

    Kernel mode only.

Revision History:

--*/

//#define _COLLECT_RESOURCE_DATA_ 1

#include "exp.h"
#pragma hdrstop
#include "nturtl.h"

//
// Define local macros to test resource state.
//

#define IsExclusiveWaiting(a) ((a)->NumberOfExclusiveWaiters != 0)
#define IsSharedWaiting(a) ((a)->NumberOfSharedWaiters != 0)
#define IsOwnedExclusive(a) (((a)->Flag & ResourceOwnedExclusive) != 0)
#define IsBoostAllowed(a) (((a)->Flag & DisablePriorityBoost) == 0)

//
// Define priority boost flags.
//

#define DisablePriorityBoost 0x08

LARGE_INTEGER ExShortTime = {(ULONG)(-10 * 1000 * 10), -1}; // 10 milliseconds

#define EX_RESOURCE_CHECK_FREES   0x1
#define EX_RESOURCE_CHECK_ORPHANS 0x2

ULONG ExResourceCheckFlags = EX_RESOURCE_CHECK_FREES|EX_RESOURCE_CHECK_ORPHANS;


//
// Define resource assertion macro.
//

#if DBG

VOID
ExpAssertResource(
    IN PERESOURCE Resource
    );

#define ASSERT_RESOURCE(_Resource) ExpAssertResource(_Resource)

#else

#define ASSERT_RESOURCE(_Resource)

#endif

//
// Define locking primitives. 
// On UP systems, fastlocks are used.
// On MP systems, a queued spinlock is used.
//

#if defined(NT_UP)
#define EXP_LOCK_HANDLE KIRQL
#define PEXP_LOCK_HANDLE PKIRQL
#define EXP_LOCK_RESOURCE(_resource_, _plockhandle_)  UNREFERENCED_PARAMETER(_plockhandle_); ExAcquireFastLock(&(_resource_)->SpinLock, (_plockhandle_))
#define EXP_UNLOCK_RESOURCE(_resource_, _plockhandle_) ExReleaseFastLock(&(_resource_)->SpinLock, *(_plockhandle_))
#else
#define EXP_LOCK_HANDLE KLOCK_QUEUE_HANDLE
#define PEXP_LOCK_HANDLE PKLOCK_QUEUE_HANDLE
#define EXP_LOCK_RESOURCE(_resource_, _plockhandle_) KeAcquireInStackQueuedSpinLock(&(_resource_)->SpinLock, (_plockhandle_))
#define EXP_UNLOCK_RESOURCE(_resource_, _plockhandle_) KeReleaseInStackQueuedSpinLock(_plockhandle_)
#endif

//
// Define private function prototypes.
//

VOID
FASTCALL
ExpWaitForResource (
    IN PERESOURCE Resource,
    IN PVOID Object
    );

POWNER_ENTRY
FASTCALL
ExpFindCurrentThread(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD CurrentThread,
    IN PEXP_LOCK_HANDLE LockHandle OPTIONAL
    );


//
// Resource wait time out value.
//

LARGE_INTEGER ExpTimeout;

//
// Consecutive time outs before message.  Note this is registry-settable.
//

ULONG ExResourceTimeoutCount = 648000;

//
// Global spinlock to guard access to resource lists.
//

KSPIN_LOCK ExpResourceSpinLock;

//
// Resource list used to record all resources in the system.
//

LIST_ENTRY ExpSystemResourcesList;

//
// Define executive resource performance data.
//

#if defined(_COLLECT_RESOURCE_DATA_)

#define ExpIncrementCounter(Member) ExpResourcePerformanceData.Member += 1

RESOURCE_PERFORMANCE_DATA ExpResourcePerformanceData;

#else

#define ExpIncrementCounter(Member)

#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpResourceInitialization)
#pragma alloc_text(PAGELK, ExQuerySystemLockInformation)
#endif

//
// Resource strict verification (checked builds only)
//
// When acquiring a resource while running in a thread that is not a system
// thread and runs at passive level we need to disable kernel APCs first
// (KeEnterCriticalRegion()). Otherwise any user mode code can call
// NtSuspendThread() which is implemented using kernel APCs and can
// suspend the thread while having a resource acquired.
// This will potentially deadlock the whole system.
//

#if DBG

ULONG ExResourceStrict = 1;

VOID
ExCheckIfKernelApcsShouldBeDisabled (
    IN KIRQL Irql,
    IN PVOID Resource,
    IN PKTHREAD Thread)
{
    if ((ExResourceStrict == 0) ||
        (Irql >= APC_LEVEL) ||
        (IS_SYSTEM_THREAD((PETHREAD)Thread)) ||
        (Thread->CombinedApcDisable != 0)) {

        return;
    }

    DbgPrint ("EX: resource: APCs still enabled before resource %p acquire !!!\n", Resource);
    DbgBreakPoint ();
}

#define EX_ENSURE_APCS_DISABLED(Irql, Resource, Thread) \
            ExCheckIfKernelApcsShouldBeDisabled (Irql, Resource, Thread);

#else

#define EX_ENSURE_APCS_DISABLED(Irql, Resource, Thread)

#endif // DBG


BOOLEAN
ExpResourceInitialization(
    VOID
    )

/*++

Routine Description:

    This function initializes global data during system initialization.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE

--*/

{
#if defined(_COLLECT_RESOURCE_DATA_)
    ULONG Index;
#endif

    //
    // Initialize resource timeout value, the system resource listhead,
    // and the resource spinlock.
    //

    ExpTimeout.QuadPart = Int32x32To64(4 * 1000, -10000);
    InitializeListHead(&ExpSystemResourcesList);
    KeInitializeSpinLock(&ExpResourceSpinLock);

    //
    // Initialize resource performance data.
    //

#if defined(_COLLECT_RESOURCE_DATA_)

    ExpResourcePerformanceData.ActiveResourceCount = 0;
    ExpResourcePerformanceData.TotalResourceCount = 0;
    ExpResourcePerformanceData.ExclusiveAcquire = 0;
    ExpResourcePerformanceData.SharedFirstLevel = 0;
    ExpResourcePerformanceData.SharedSecondLevel = 0;
    ExpResourcePerformanceData.StarveFirstLevel = 0;
    ExpResourcePerformanceData.StarveSecondLevel = 0;
    ExpResourcePerformanceData.WaitForExclusive = 0;
    ExpResourcePerformanceData.OwnerTableExpands = 0;
    ExpResourcePerformanceData.MaximumTableExpand = 0;
    for (Index = 0; Index < RESOURCE_HASH_TABLE_SIZE; Index += 1) {
        InitializeListHead(&ExpResourcePerformanceData.HashTable[Index]);
    }

#endif

    return TRUE;
}

VOID
ExpAllocateExclusiveWaiterEvent (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )

/*++

Routine Description:

    This function allocates and initializes the exclusive waiter event
    for a resource.

    N.B. The resource spin lock is held on entry and exit of this routine.

Arguments:

    Resource - Supplies a pointer to the resource.

    LockHandle - Supplies a pointer to a lock handle.

Return Value:

    None.

--*/

{

    PKEVENT Event;

    //
    // Allocate an exclusive wait event and retry the acquire operation.
    //

    EXP_UNLOCK_RESOURCE(Resource, LockHandle);
    do {
        Event = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(KEVENT),
                                      'vEeR');

        if (Event != NULL) {
            KeInitializeEvent(Event, SynchronizationEvent, FALSE);
            if (InterlockedCompareExchangePointer(&Resource->ExclusiveWaiters,
                                                  Event,
                                                  NULL) != NULL) {

                ExFreePool(Event);
            }

            break;
        }

        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } while (TRUE);

    EXP_LOCK_RESOURCE(Resource, LockHandle);
    return;
}

VOID
ExpAllocateSharedWaiterSemaphore (
    IN PERESOURCE Resource,
    IN PEXP_LOCK_HANDLE LockHandle
    )

/*++

Routine Description:

    This function allocates and initializes the shared waiter semaphore
    for a resource.

    N.B. The resource spin lock is held on entry and exit of this routine.

Arguments:

    Resource - Supplies a pointer to the resource.

    LockHandle - Supplies a pointer to a lock handle.

Return Value:

    None.

--*/

{

    PKSEMAPHORE Semaphore;

    //
    // Allocate and initialize a shared wait semaphore for the specified
    // resource.
    //

    EXP_UNLOCK_RESOURCE(Resource, LockHandle);
    do {
        Semaphore = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(KSEMAPHORE),
                                          'eSeR');

        if (Semaphore != NULL) {
            KeInitializeSemaphore(Semaphore, 0, MAXLONG);
            if (InterlockedCompareExchangePointer(&Resource->SharedWaiters,
                                                  Semaphore,
                                                  NULL) != NULL) {
                ExFreePool(Semaphore);
            }

            break;
        }

        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } while (TRUE);

    EXP_LOCK_RESOURCE(Resource, LockHandle);
    return;
}

NTSTATUS
ExInitializeResourceLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the specified resource.

Arguments:

    Resource - Supplies a pointer to the resource to initialize.

Return Value:

    STATUS_SUCCESS.

--*/

{
#if defined(_COLLECT_RESOURCE_DATA_)
    PVOID CallersCaller;
#endif

    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT(MmDeterminePoolType(Resource) == NonPagedPool);

    //
    // Initialize the specified resource.
    //
    // N.B. All fields are initialized to zero (NULL pointers) except
    //      the list entry and spinlock.
    //

    RtlZeroMemory(Resource, sizeof(ERESOURCE));
    KeInitializeSpinLock(&Resource->SpinLock);

    if (NtGlobalFlag & FLG_KERNEL_STACK_TRACE_DB) {
        Resource->CreatorBackTraceIndex = RtlLogStackBackTrace();
    }else {
        Resource->CreatorBackTraceIndex = 0;
    }

    KeAcquireInStackQueuedSpinLock (&ExpResourceSpinLock, &LockHandle);

    InsertTailList (&ExpSystemResourcesList, &Resource->SystemResourcesList);

    KeReleaseInStackQueuedSpinLock (&LockHandle);


    //
    // Initialize performance data entry for the resource.
    //

#if defined(_COLLECT_RESOURCE_DATA_)

    RtlGetCallersAddress(&Resource->Address, &CallersCaller);
    ExpResourcePerformanceData.TotalResourceCount += 1;
    ExpResourcePerformanceData.ActiveResourceCount += 1;

#endif

    return STATUS_SUCCESS;
}

NTSTATUS
ExReinitializeResourceLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine reinitializes the specified resource.

Arguments:

    Resource - Supplies a pointer to the resource to initialize.

Return Value:

    STATUS_SUCCESS.

--*/

{

    PKEVENT Event;
    ULONG Index;
    POWNER_ENTRY OwnerTable;
    PKSEMAPHORE Semaphore;
    ULONG TableSize;

    ASSERT(MmDeterminePoolType(Resource) == NonPagedPool);

    //
    // If the resource has an owner table, then zero the owner table.
    //

    OwnerTable = Resource->OwnerTable;
    if (OwnerTable != NULL) {
        TableSize = OwnerTable->TableSize;
        for (Index = 1; Index < TableSize; Index += 1) {
            OwnerTable[Index].OwnerThread = 0;
            OwnerTable[Index].OwnerCount = 0;
        }
    }

    //
    // Set the active count and flags to zero.
    //

    Resource->ActiveCount = 0;
    Resource->Flag = 0;

    //
    // If the resource has a shared waiter semaphore, then reinitialize
    // it.
    //

    Semaphore = Resource->SharedWaiters;
    if (Semaphore != NULL) {
        KeInitializeSemaphore(Semaphore, 0, MAXLONG);
    }

    //
    // If the resource has a exclusive waiter event, then reinitialize
    // it.
    //

    Event = Resource->ExclusiveWaiters;
    if (Event != NULL) {
        KeInitializeEvent(Event, SynchronizationEvent, FALSE);
    }

    //
    // Initialize the builtin owner table.
    //

    Resource->OwnerThreads[0].OwnerThread = 0;
    Resource->OwnerThreads[0].OwnerCount = 0;
    Resource->OwnerThreads[1].OwnerThread = 0;
    Resource->OwnerThreads[1].OwnerCount = 0;

    //
    // Set the contention count, number of shared waiters, and number
    // of exclusive waiters to zero.
    //

    Resource->ContentionCount = 0;
    Resource->NumberOfSharedWaiters = 0;
    Resource->NumberOfExclusiveWaiters = 0;

    return STATUS_SUCCESS;
}

VOID
ExDisableResourceBoostLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine disables priority inversion boosting for the specified
    resource.

Arguments:

    Resource - Supplies a pointer to the resource for which priority
        boosting is disabled.

Return Value:

    None.

--*/

{

    EXP_LOCK_HANDLE LockHandle;

    ASSERT_RESOURCE(Resource);

    //
    // Disable priority boosts for the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    Resource->Flag |= DisablePriorityBoost;

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

BOOLEAN
ExAcquireResourceExclusiveLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the specified resource for exclusive access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for exclusive access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    BOOLEAN Result;

    ASSERT((Resource->Flag & ResourceNeverExclusive) == 0);

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    //
    // Resource acquisition must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    ExpIncrementCounter(ExclusiveAcquire);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted. Otherwise, there is either a shared owner or
    // an exclusive owner.
    //

retry:
    if (Resource->ActiveCount != 0) {

        //
        // The resource is either owned exclusive or shared.
        //
        // If the resource is owned exclusive and the current thread is the
        // owner, then increment the recursion count.
        //

        if (IsOwnedExclusive(Resource) &&
            (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            Result = TRUE;

        } else {

            //
            // The resource is either owned exclusive by some other thread,
            // or owned shared.
            //
            // If wait is not specified, then return that the resource was
            // not acquired. Otherwise, wait for exclusive access to the
            // resource to be granted.
            //

            if (Wait == FALSE) {
                Result = FALSE;

            } else {

                //
                // If the exclusive wait event has not yet been allocated,
                // then the long path code must be taken.
                //

                if (Resource->ExclusiveWaiters == NULL) {
                    ExpAllocateExclusiveWaiterEvent(Resource, &LockHandle);
                    goto retry;
                }

                //
                // Wait for exclusive access to the resource to be granted
                // and set the owner thread.
                //

                Resource->NumberOfExclusiveWaiters += 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                ExpWaitForResource(Resource, Resource->ExclusiveWaiters);

                //
                // N.B. It is "safe" to store the owner thread without
                //      obtaining any locks since the thread has already
                //      been granted exclusive ownership.
                //

                Resource->OwnerThreads[0].OwnerThread = (ERESOURCE_THREAD)PsGetCurrentThread();
                return TRUE;
            }
        }

    } else {

        //
        // The resource is not owned.
        //

        Resource->Flag |= ResourceOwnedExclusive;
        Resource->OwnerThreads[0].OwnerThread = CurrentThread;
        Resource->OwnerThreads[0].OwnerCount = 1;
        Resource->ActiveCount = 1;
        Result = TRUE;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return Result;
}

BOOLEAN
ExTryToAcquireResourceExclusiveLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    The routine attempts to acquire the specified resource for exclusive
    access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for exclusive access.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    BOOLEAN Result;

    ASSERT((Resource->Flag & ResourceNeverExclusive) == 0);

    //
    // Attempt to acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted. Otherwise, if the resource is owned exclusive
    // and the current thread is the owner, then access to the resource can
    // be immediately granted. Otherwise, access cannot be granted.
    //

    Result = FALSE;
    if (Resource->ActiveCount == 0) {
        ExpIncrementCounter(ExclusiveAcquire);
        Resource->Flag |= ResourceOwnedExclusive;
        Resource->OwnerThreads[0].OwnerThread = CurrentThread;
        Resource->OwnerThreads[0].OwnerCount = 1;
        Resource->ActiveCount = 1;
        Result = TRUE;

    } else if (IsOwnedExclusive(Resource) &&
        (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
        ExpIncrementCounter(ExclusiveAcquire);
        Resource->OwnerThreads[0].OwnerCount += 1;
        Result = TRUE;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return Result;
}

BOOLEAN
ExAcquireResourceSharedLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the specified resource for shared access.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    //
    // Resource acquisition must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    ExpIncrementCounter(SharedFirstLevel);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, 0, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If the current thread already has acquired the resource for
        // shared access, then increment the recursion count. Otherwise
        // grant shared access if there are no exclusive waiters.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

        if (OwnerEntry->OwnerThread == CurrentThread) {
            OwnerEntry->OwnerCount += 1;

            ASSERT(OwnerEntry->OwnerCount != 0);

            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // If there are no exclusive waiters, then grant shared access
        // to the resource. Otherwise, wait for the resource to become
        // available.
        //

        if (IsExclusiveWaiting(Resource) == FALSE) {
            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            Resource->ActiveCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }
    }

    //
    // The resource is either owned exclusive by some other thread, or
    // owned shared by some other threads, but there is an exclusive
    // waiter and the current thread does not already have shared access
    // to the resource.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then the
    // long path must be taken.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

BOOLEAN
ExAcquireSharedStarveExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    )
/*++

Routine Description:

    This routine acquires the specified resource for shared access and
    does not wait for any pending exclusive owners.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    ExpIncrementCounter(StarveFirstLevel);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, 0, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If the current thread already has acquired the resource for
        // shared access, then increment the recursion count. Otherwise
        // grant shared access to the current thread.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

        if (OwnerEntry->OwnerThread == CurrentThread) {
            OwnerEntry->OwnerCount += 1;

            ASSERT(OwnerEntry->OwnerCount != 0);

            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Grant the current thread shared access to the resource.
        //

        OwnerEntry->OwnerThread = CurrentThread;
        OwnerEntry->OwnerCount = 1;
        Resource->ActiveCount += 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is owned exclusive by some other thread.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then the
    // long path must be taken.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

BOOLEAN
ExAcquireSharedWaitForExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    )
/*++

Routine Description:

    This routine acquires the specified resource for shared access, but
    waits for any pending exclusive owners.

Arguments:

    Resource - Supplies a pointer to the resource that is acquired
        for shared access.

    Wait - A boolean value that specifies whether to wait for the
        resource to become available if access cannot be granted
        immediately.

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry;

    //
    // Acquire exclusive access to the specified resource.
    //

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    ExpIncrementCounter(WaitForExclusive);

    //
    // If the active count of the resource is zero, then there is neither
    // an exclusive owner nor a shared owner and access to the resource can
    // be immediately granted.
    //

retry:
    if (Resource->ActiveCount == 0) {
        Resource->OwnerThreads[1].OwnerThread = CurrentThread;
        Resource->OwnerThreads[1].OwnerCount = 1;
        Resource->ActiveCount = 1;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return TRUE;
    }

    //
    // The resource is either owned exclusive or shared.
    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then treat the shared request as an exclusive request and
    // increment the recursion count. Otherwise, it is owned shared.
    //

    if (IsOwnedExclusive(Resource)) {
        if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            Resource->OwnerThreads[0].OwnerCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }

        //
        // Find an empty entry in the thread array.
        //

        OwnerEntry = ExpFindCurrentThread(Resource, 0, &LockHandle);
        if (OwnerEntry == NULL) {
            goto retry;
        }

    } else {

        //
        // The resource is owned shared.
        //
        // If there is an exclusive waiter, then wait for the exclusive
        // waiter to gain access to the resource, then acquire the resource
        // shared without regard to exclusive waiters. Otherwise, if the
        // current thread already has acquired the resource for shared access,
        // then increment the recursion count. Otherwise grant shared access
        // to the current thread.
        //

        if (IsExclusiveWaiting(Resource)) {

            //
            // The resource is shared, but there is an exclusive waiter.
            //
            // It doesn't matter if this thread is already one of the shared
            // owner(s) - if TRUE is specified, this thread must block - an APC
            // will release the resource to unjam things and callers count on
            // this behavior.
            //

#if 0
            //
            // This code must NOT be enabled as per the comment above.
            //

            OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, NULL);

            if ((OwnerEntry != NULL) &&
                (OwnerEntry->OwnerThread == CurrentThread)) {
                ASSERT(OwnerEntry->OwnerCount != 0);
                OwnerEntry->OwnerCount += 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                return TRUE;
            }
#endif

            //
            // If wait is not specified, then return that the resource was
            // not acquired.
            //

            if (Wait == FALSE) {
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                return FALSE;
            }

            //
            // If the shared wait semaphore has not yet been allocated, then
            // allocate and initialize it.
            //

            if (Resource->SharedWaiters == NULL) {
                ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
                goto retry;
            }

            //
            // Increment the number of shared waiters and wait for shared
            // access to the resource to be granted to some other set of
            // threads, and then acquire the resource shared without regard
            // to exclusive access.
            //
            // N.B. The resource is left in a state such that the calling
            //      thread does not have a reference in the owner table
            //      for the requested access even though the active count
            //      is incremented when control is returned. However, the
            //      resource is owned shared at this point, so an owner
            //      entry can simply be allocated and the owner count set
            //      to one.
            //

            Resource->NumberOfSharedWaiters += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            ExpWaitForResource(Resource, Resource->SharedWaiters);

            //
            // Reacquire the resource spin lock, allocate an owner entry,
            // and initialize the owner count to one. The active count
            // was already incremented when shared access was granted.
            //

            EXP_LOCK_RESOURCE(Resource, &LockHandle);
            do {
            } while ((OwnerEntry = ExpFindCurrentThread(Resource,
                                                        CurrentThread,
                                                        &LockHandle)) == NULL);

            ASSERT(IsOwnedExclusive(Resource) == FALSE);
            ASSERT(Resource->ActiveCount > 0);
            ASSERT(OwnerEntry->OwnerThread != CurrentThread);

            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;

        } else {
            OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, &LockHandle);
            if (OwnerEntry == NULL) {
                goto retry;
            }

            if (OwnerEntry->OwnerThread == CurrentThread) {
                OwnerEntry->OwnerCount += 1;

                ASSERT(OwnerEntry->OwnerCount != 0);

                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                return TRUE;
            }

            //
            // Grant the current thread shared access to the resource.
            //

            OwnerEntry->OwnerThread = CurrentThread;
            OwnerEntry->OwnerCount = 1;
            Resource->ActiveCount += 1;
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return TRUE;
        }
    }

    //
    // The resource is owned exclusive by some other thread.
    //
    // If wait is not specified, then return that the resource was
    // not acquired.
    //

    if (Wait == FALSE) {
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        return FALSE;
    }

    //
    // If the shared wait semaphore has not yet been allocated, then allocate
    // and initialize it.
    //

    if (Resource->SharedWaiters == NULL) {
        ExpAllocateSharedWaiterSemaphore(Resource, &LockHandle);
        goto retry;
    }

    //
    // Wait for shared access to the resource to be granted and increment
    // the recursion count.
    //

    OwnerEntry->OwnerThread = CurrentThread;
    OwnerEntry->OwnerCount = 1;
    Resource->NumberOfSharedWaiters += 1;
    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    ExpWaitForResource(Resource, Resource->SharedWaiters);
    return TRUE;
}

VOID
FASTCALL
ExReleaseResourceLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine releases the specified resource for the current thread
    and decrements the recursion count. If the count reaches zero, then
    the resource may also be released.

Arguments:

    Resource - Supplies a pointer to the resource to release.

Return Value:

    None.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    ULONG Index;
    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, OwnerEnd;

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    ASSERT_RESOURCE(Resource);

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    //
    // Resource release must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    //
    // If the resource is exclusively owned, then release exclusive
    // ownership. Otherwise, release shared ownership.
    //
    // N.B. The two release paths are split since this is such a high
    //      frequency function.
    //

    if (IsOwnedExclusive(Resource)) {

#if DBG
        //
        // This can only be enabled in checked builds because this (unusual)
        // behavior might have worked in earlier releases of NT.  However,
        // in the checked builds, this can be enabled because callers really
        // should convert to using ExReleaseResourceForThreadLite instead.
        //

        if (Resource->OwnerThreads[0].OwnerThread != CurrentThread) {
            KeBugCheckEx(RESOURCE_NOT_OWNED,
                         (ULONG_PTR)Resource,
                         (ULONG_PTR)CurrentThread,
                         (ULONG_PTR)Resource->OwnerTable,
                         0x1);
        }
#endif

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        if (--Resource->OwnerThreads[0].OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        Resource->OwnerThreads[0].OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are shared waiters, then grant shared access to the
            // resource. Otherwise, grant exclusive ownership if there are
            // exclusive waiters.
            //

            if (IsSharedWaiting(Resource)) {
                Resource->Flag &= ~ResourceOwnedExclusive;
                Number = Resource->NumberOfSharedWaiters;
                Resource->ActiveCount =  (SHORT)Number;
                Resource->NumberOfSharedWaiters = 0;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
                return;

            } else if (IsExclusiveWaiting(Resource)) {
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);
                return;
            }

            Resource->Flag &= ~ResourceOwnedExclusive;
        }

    } else {
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[1];

        } else if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[0];

        } else {
            Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;
            OwnerEntry = Resource->OwnerTable;

            if (OwnerEntry == NULL) {
                KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x2);
            }

            //
            // If the resource hint is not within range or the resource
            // table entry does match the current thread, then search
            // the owner table for a match.
            //

            if ((Index >= OwnerEntry->TableSize) ||
                (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                OwnerEnd = &OwnerEntry[OwnerEntry->TableSize];
                while (1) {
                    OwnerEntry += 1;
                    if (OwnerEntry >= OwnerEnd) {
                       KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x3);
                    }
                    if (OwnerEntry->OwnerThread == CurrentThread) {
                        break;
                    }
                }

            } else {
                OwnerEntry = &OwnerEntry[Index];
            }
        }

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(OwnerEntry->OwnerThread == CurrentThread);
        ASSERT(OwnerEntry->OwnerCount > 0);

        if (--OwnerEntry->OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        OwnerEntry->OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are exclusive waiters, then grant exclusive access
            // to the resource.
            //

            if (IsExclusiveWaiting(Resource)) {
                Resource->Flag |= ResourceOwnedExclusive;
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }
        }
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
ExReleaseResourceForThreadLite(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD CurrentThread
    )

/*++

Routine Description:

    This routine release the specified resource for the specified thread
    and decrements the recursion count. If the count reaches zero, then
    the resource may also be released.

Arguments:

    Resource - Supplies a pointer to the resource to release.

    Thread - Supplies the thread that originally acquired the resource.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, OwnerEnd;

    ASSERT(CurrentThread != 0);

    ASSERT_RESOURCE(Resource);

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    //
    // Resource release must be protected from thread suspends.
    //

    EX_ENSURE_APCS_DISABLED (LockHandle.OldIrql,
                             Resource,
                             KeGetCurrentThread());

    //
    // If the resource is exclusively owned, then release exclusive
    // ownership. Otherwise, release shared ownership.
    //
    // N.B. The two release paths are split since this is such a high
    //      frequency function.
    //

    if (IsOwnedExclusive(Resource)) {

        ASSERT(Resource->OwnerThreads[0].OwnerThread == CurrentThread);

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        if (--Resource->OwnerThreads[0].OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        Resource->OwnerThreads[0].OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are shared waiters, then grant shared access to the
            // resource. Otherwise, grant exclusive ownership if there are
            // exclusive waiters.
            //

            if (IsSharedWaiting(Resource)) {
                Resource->Flag &= ~ResourceOwnedExclusive;
                Number = Resource->NumberOfSharedWaiters;
                Resource->ActiveCount =  (SHORT)Number;
                Resource->NumberOfSharedWaiters = 0;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
                return;

            } else if (IsExclusiveWaiting(Resource)) {
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }

            Resource->Flag &= ~ResourceOwnedExclusive;
        }

    } else {
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[1];

        } else if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
            OwnerEntry = &Resource->OwnerThreads[0];

        } else {

            //
            // If the specified current thread is an owner address (low
            // bits are nonzero), then set the hint index to the first
            // entry. Otherwise, set the hint index from the owner thread.
            //

            Index = 1;
            if (((ULONG)CurrentThread & 3) == 0) {
                Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;
            }

            OwnerEntry = Resource->OwnerTable;

            ASSERT(OwnerEntry != NULL);

            //
            // If the resource hint is not within range or the resource
            // table entry does match the current thread, then search
            // the owner table for a match.
            //

            if ((Index >= OwnerEntry->TableSize) ||
                (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                OwnerEnd = &OwnerEntry[OwnerEntry->TableSize];
                while (1) {
                    OwnerEntry += 1;
                    if (OwnerEntry >= OwnerEnd) {
                       KeBugCheckEx(RESOURCE_NOT_OWNED,
                             (ULONG_PTR)Resource,
                             (ULONG_PTR)CurrentThread,
                             (ULONG_PTR)Resource->OwnerTable,
                             0x3);
                    }
                    if (OwnerEntry->OwnerThread == CurrentThread) {
                        break;
                    }
                }

            } else {
                OwnerEntry = &OwnerEntry[Index];
            }
        }

        //
        // Decrement the recursion count and check if ownership can be
        // released.
        //

        ASSERT(OwnerEntry->OwnerThread == CurrentThread);
        ASSERT(OwnerEntry->OwnerCount > 0);

        if (--OwnerEntry->OwnerCount != 0) {
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
            return;
        }

        //
        // Clear the owner thread.
        //

        OwnerEntry->OwnerThread = 0;

        //
        // The thread recursion count reached zero so decrement the resource
        // active count. If the active count reaches zero, then the resource
        // is no longer owned and an attempt should be made to grant access to
        // another thread.
        //

        ASSERT(Resource->ActiveCount > 0);

        if (--Resource->ActiveCount == 0) {

            //
            // If there are exclusive waiters, then grant exclusive access
            // to the resource.
            //

            if (IsExclusiveWaiting(Resource)) {
                Resource->Flag |= ResourceOwnedExclusive;
                Resource->OwnerThreads[0].OwnerThread = 1;
                Resource->OwnerThreads[0].OwnerCount = 1;
                Resource->ActiveCount = 1;
                Resource->NumberOfExclusiveWaiters -= 1;
                EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
                KeSetEventBoostPriority(Resource->ExclusiveWaiters,
                                        (PRKTHREAD *)&Resource->OwnerThreads[0].OwnerThread);

                return;
            }
        }
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
ExSetResourceOwnerPointer(
    IN PERESOURCE Resource,
    IN PVOID OwnerPointer
    )

/*++

Routine Description:

    This routine locates the owner entry for the current thread and stores
    the specified owner address as the owner thread. Subsequent to calling
    this routine, the only routine which may be called for this resource is
    ExReleaseResourceForThreadLite, supplying the owner address as the "thread".

    Owner addresses must obey the following rules:

        They must be a unique pointer to a structure allocated in system space,
        and they must point to a structure which remains allocated until after
        the call to ExReleaseResourceForThreadLite. This is to eliminate aliasing
        with a thread or other owner address.

        The low order two bits of the owner address must be set by the caller,
        so that other routines in the resource package can distinguish owner
        address from thread addresses.

Arguments:

    Resource - Supplies a pointer to the resource to release.

    OwnerPointer - Supplies a pointer to an allocated structure with the low
        order two bits set.

Return Value:

    None.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    EXP_LOCK_HANDLE LockHandle;
    POWNER_ENTRY OwnerEntry, ExistingOwnerEntry;

    ASSERT((OwnerPointer != 0) && (((ULONG_PTR)OwnerPointer & 3) == 3));

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    ASSERT_RESOURCE(Resource);

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);


    //
    // If the resource is exclusively owned, then it is the first owner entry.
    //

    if (IsOwnedExclusive(Resource)) {

        ASSERT(Resource->OwnerThreads[0].OwnerThread == CurrentThread);

        //
        // Set the owner address.
        //

        ASSERT(Resource->OwnerThreads[0].OwnerCount > 0);

        Resource->OwnerThreads[0].OwnerThread = (ULONG_PTR)OwnerPointer;

    //
    //  For shared access we have to search for the current thread to set
    //  the owner address.
    //

    } else {

        ExistingOwnerEntry = ExpFindCurrentThread(Resource, (ERESOURCE_THREAD)OwnerPointer, NULL);

        OwnerEntry = ExpFindCurrentThread(Resource, CurrentThread, NULL);

        if (OwnerEntry == NULL) {
            KeBugCheckEx(RESOURCE_NOT_OWNED,
                         (ULONG_PTR)Resource,
                         (ULONG_PTR)CurrentThread,
                         (ULONG_PTR)Resource->OwnerTable,
                         0x3);
        }

        if (ExistingOwnerEntry != NULL) {
            ExistingOwnerEntry->OwnerCount += OwnerEntry->OwnerCount;
            OwnerEntry->OwnerCount = 0;
            OwnerEntry->OwnerThread = 0;
            ASSERT (Resource->ActiveCount >= 2);
            Resource->ActiveCount -= 1;
        } else {
            OwnerEntry->OwnerThread = (ERESOURCE_THREAD)OwnerPointer;
        }

    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

VOID
ExConvertExclusiveToSharedLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine converts the specified resource from acquired for exclusive
    access to acquired for shared access.

Arguments:

    Resource - Supplies a pointer to the resource to acquire for shared access. it

Return Value:

    None.

--*/

{

    ULONG Number;
    EXP_LOCK_HANDLE LockHandle;

    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    ASSERT(IsOwnedExclusive(Resource));
    ASSERT(Resource->OwnerThreads[0].OwnerThread == (ERESOURCE_THREAD)PsGetCurrentThread());

    //
    // Acquire exclusive access to the specified resource.
    //

    EXP_LOCK_RESOURCE(Resource, &LockHandle);

    //
    // Convert the granted access from exclusive to shared.
    //

    Resource->Flag &= ~ResourceOwnedExclusive;

    //
    // If there are any shared waiters, then grant them shared access.
    //

    if (IsSharedWaiting(Resource)) {
        Number = Resource->NumberOfSharedWaiters;
        Resource->ActiveCount = (SHORT)(Resource->ActiveCount + Number);
        Resource->NumberOfSharedWaiters = 0;
        EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        KeReleaseSemaphore(Resource->SharedWaiters, 0, Number, FALSE);
        return;
    }

    EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
    return;
}

NTSTATUS
ExDeleteResourceLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine deallocates any pool allocated to support the specified
    resource.


Arguments:

    Resource - Supplies a pointer to the resource whose allocated pool
        is freed.

Return Value:

    STATUS_SUCCESS.

--*/

{

#if defined(_COLLECT_RESOURCE_DATA_)

    ULONG Hash;
    PLIST_ENTRY NextEntry;
    PRESOURCE_HASH_ENTRY MatchEntry;
    PRESOURCE_HASH_ENTRY HashEntry;

#endif

    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT(IsSharedWaiting(Resource) == FALSE);
    ASSERT(IsExclusiveWaiting(Resource) == FALSE);
    ASSERT(KeIsExecutingDpc() == FALSE);
    ASSERT_RESOURCE(Resource);

    //
    // Acquire the executive resource spinlock and remove the resource from
    // the system resource list.
    //

    KeAcquireInStackQueuedSpinLock (&ExpResourceSpinLock, &LockHandle);

    RemoveEntryList(&Resource->SystemResourcesList);

#if defined(_COLLECT_RESOURCE_DATA_)

    //
    // Lookup resource initialization address in resource hash table. If
    // the address does not exist in the table, then create a new entry.
    //

    Hash = (ULONG)Resource->Address;
    Hash = ((Hash >> 24) ^ (Hash >> 16) ^ (Hash >> 8) ^ (Hash)) & (RESOURCE_HASH_TABLE_SIZE - 1);
    MatchEntry = NULL;
    NextEntry = ExpResourcePerformanceData.HashTable[Hash].Flink;
    while (NextEntry != &ExpResourcePerformanceData.HashTable[Hash]) {
        HashEntry = CONTAINING_RECORD(NextEntry,
                                      RESOURCE_HASH_ENTRY,
                                      ListEntry);

        if (HashEntry->Address == Resource->Address) {
            MatchEntry = HashEntry;
            break;
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // If a matching initialization address was found, then update the call
    // site statistics. Otherwise, allocate a new hash entry and initialize
    // call site statistics.
    //

    if (MatchEntry != NULL) {
        MatchEntry->ContentionCount += Resource->ContentionCount;
        MatchEntry->Number += 1;

    } else {
        MatchEntry = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(RESOURCE_HASH_ENTRY),
                                          'vEpR');

        if (MatchEntry != NULL) {
            MatchEntry->Address = Resource->Address;
            MatchEntry->ContentionCount = Resource->ContentionCount;
            MatchEntry->Number = 1;
            InsertTailList(&ExpResourcePerformanceData.HashTable[Hash],
                           &MatchEntry->ListEntry);
        }
    }

    ExpResourcePerformanceData.ActiveResourceCount -= 1;

#endif

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    //
    // If an owner table was allocated, then free it to pool.
    //

    if (Resource->OwnerTable != NULL) {
        ExFreePool(Resource->OwnerTable);
    }

    //
    // If a semaphore was allocated, then free it to pool.
    //

    if (Resource->SharedWaiters) {
        ExFreePool(Resource->SharedWaiters);
    }

    //
    // If an event was allocated, then free it to pool.
    //

    if (Resource->ExclusiveWaiters) {
        ExFreePool(Resource->ExclusiveWaiters);
    }

    return STATUS_SUCCESS;
}

ULONG
ExGetExclusiveWaiterCount(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine returns the exclusive waiter count.


Arguments:

    Resource - Supplies a pointer to and executive resource.

Return Value:

    The current number of exclusive waiters is returned as the function
    value.

--*/

{
    return Resource->NumberOfExclusiveWaiters;
}

ULONG
ExGetSharedWaiterCount(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine returns the shared waiter count.


Arguments:

    Resource - Supplies a pointer to and executive resource.

Return Value:

    The current number of shared waiters is returned as the function
    value.

--*/

{
    return Resource->NumberOfSharedWaiters;
}



BOOLEAN
ExIsResourceAcquiredExclusiveLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine determines if a resource is acquired exclusive by the
    calling thread.

Arguments:

    Resource - Supplies a pointer the resource to query.

Return Value:

    If the current thread has acquired the resource exclusive, a value of
    TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    BOOLEAN Result;

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    ASSERT_RESOURCE(Resource);

    //
    // If the resource is owned exclusive and the current thread is the
    // owner, then set the return value of TRUE. Otherwise, set the return
    // value to FALSE.
    //

    Result = FALSE;
    if ((IsOwnedExclusive(Resource)) &&
        (Resource->OwnerThreads[0].OwnerThread == CurrentThread)) {
        Result = TRUE;
    }

    return Result;
}



ULONG
ExIsResourceAcquiredSharedLite(
    IN PERESOURCE Resource
    )

/*++

Routine Description:

    This routine determines if a resource is acquired either shared or
    exclusive by the calling thread.

Arguments:

    Resource - Supplies a pointer to the resource to query.

Return Value:

    If the current thread has not acquired the resource a value of zero
    is returned. Otherwise, the thread's acquire count is returned.

--*/

{

    ERESOURCE_THREAD CurrentThread;
    ULONG Index;
    ULONG Number;
    POWNER_ENTRY OwnerEntry;
    ULONG Result;
    EXP_LOCK_HANDLE LockHandle;

    ASSERT_RESOURCE(Resource);


    //
    // If nobody owns this resource then exit early.
    //
    if (Resource->ActiveCount == 0) {
        return 0;
    }

    CurrentThread = (ERESOURCE_THREAD)PsGetCurrentThread();

    //
    // Find the current thread in the thread array and return the count.
    //
    // N.B. If the thread is not found a value of zero will be returned.
    //


    if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
        Result = Resource->OwnerThreads[0].OwnerCount;

    } else {
        //
        // If we are not in the first slot and the resource is owned exclusive
        // then we can't own it at all
        //
        if (IsOwnedExclusive(Resource)) {
            return 0;
        }

        //
        // Check slot 2 and other slots in the owner table
        //
        if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
            Result = Resource->OwnerThreads[1].OwnerCount;
        } else {

            Result = 0;
            Index = ((PKTHREAD)(CurrentThread))->ResourceIndex;

            EXP_LOCK_RESOURCE(Resource, &LockHandle);

            //
            // If the resource hint is not within range or the resource table
            // entry does not match the current thread, then search the owner
            // table for a match.
            //

            OwnerEntry = Resource->OwnerTable;
            if (OwnerEntry != NULL) {
                Number = OwnerEntry->TableSize;
                if ((Index >= Number) ||
                    (OwnerEntry[Index].OwnerThread != CurrentThread)) {
                    for (Index = 1; Index < Number; Index += 1) {
                        OwnerEntry += 1;
                        if (OwnerEntry->OwnerThread == CurrentThread) {
                            Result = OwnerEntry->OwnerCount;
                            break;
                        }
                    }

                } else {
                    Result = OwnerEntry[Index].OwnerCount;
                }
            }

            //
            // Release exclusive access to the specified resource.
            //

            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
        }
    }

    return Result;
}

NTSTATUS
ExQuerySystemLockInformation(
    OUT PRTL_PROCESS_LOCKS LockInformation,
    IN ULONG LockInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

{

    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG RequiredLength;
    PLIST_ENTRY Head, Next;
    PRTL_PROCESS_LOCK_INFORMATION LockInfo;
    PERESOURCE Resource;
    PETHREAD OwningThread;

    RequiredLength = FIELD_OFFSET(RTL_PROCESS_LOCKS, Locks);
    if (LockInformationLength < RequiredLength) {
        Status = STATUS_INFO_LENGTH_MISMATCH;

    } else {
        Status = STATUS_SUCCESS;

        LockInformation->NumberOfLocks = 0;
        LockInfo = &LockInformation->Locks[0];
        Head = &ExpSystemResourcesList;

        KeAcquireInStackQueuedSpinLock(&ExpResourceSpinLock, &LockHandle);

        Next = Head->Flink;
        while (Next != Head) {
            Resource = CONTAINING_RECORD(Next,
                                         ERESOURCE,
                                         SystemResourcesList);

            LockInformation->NumberOfLocks += 1;
            RequiredLength += sizeof(RTL_PROCESS_LOCK_INFORMATION);

            if (LockInformationLength < RequiredLength) {
                Status = STATUS_INFO_LENGTH_MISMATCH;

            } else {
                LockInfo->Address = Resource;
                LockInfo->Type = RTL_RESOURCE_TYPE;
                LockInfo->CreatorBackTraceIndex = 0;
#if i386 && !FPO
                LockInfo->CreatorBackTraceIndex = (USHORT)Resource->CreatorBackTraceIndex;
#endif // i386 && !FPO

                 if ((Resource->OwnerThreads[0].OwnerThread != 0) &&
                    ((Resource->OwnerThreads[0].OwnerThread & 3) == 0)) {
                    OwningThread = (PETHREAD)(Resource->OwnerThreads[0].OwnerThread);
                    LockInfo->OwningThread = OwningThread->Cid.UniqueThread;

                } else {
                    LockInfo->OwningThread = 0;
                }

                LockInfo->LockCount = Resource->ActiveCount;
                LockInfo->ContentionCount = Resource->ContentionCount;
                LockInfo->NumberOfWaitingShared = Resource->NumberOfSharedWaiters;
                LockInfo->NumberOfWaitingExclusive = Resource->NumberOfExclusiveWaiters;
                LockInfo += 1;
            }
            Next = Next->Flink;
        }

        KeReleaseInStackQueuedSpinLock(&LockHandle);
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }

    return Status;
}

VOID
FASTCALL
ExpBoostOwnerThread (
    IN PKTHREAD CurrentThread,
    IN PKTHREAD OwnerThread
    )
/*++

Routine Description:

    This function boots the priority of the specified owner thread iff
    its priority is less than that of the current thread and is also
    less than fourteen.

    N.B. this function is called with the dispatcher database lock held.

Arguments:

    CurrentThread - Supplies a pointer to the current thread object.

    OwnerThread - Supplies a pointer to the owner thread object.

Return Value:

    None.

--*/

{

    //
    // If the owner thread is lower priority than the current thread, the
    // current thread is running at a priority less than 14, then boost the
    // priority of the owner thread for a quantum.
    //
    // N.B. A thread that has already been boosted may be reboosted to allow
    //      it to execute and release resources. When the boost is removed,
    //      the thread will return to its priority before any boosting.
    //

    if (((ULONG_PTR)OwnerThread & 0x3) == 0) {
        if ((OwnerThread->Priority < CurrentThread->Priority) &&
            (OwnerThread->Priority < 14)) {

            KiAcquireThreadLock(OwnerThread);
            OwnerThread->PriorityDecrement += 14 - OwnerThread->Priority;
            OwnerThread->Quantum = OwnerThread->Process->ThreadQuantum;
            KiSetPriorityThread(OwnerThread, 14);
            KiReleaseThreadLock(OwnerThread);
        }
    }

    return;
}

VOID
FASTCALL
ExpWaitForResource (
    IN PERESOURCE Resource,
    IN PVOID Object
    )
/*++

Routine Description:

    The routine waits for the specified resource object to be set. If the
    wait is too long the priority of the current owners of the resource
    are boosted.

Arguments:

    Resource - Supplies a pointer to the resource to wait for.

    Object - Supplies a pointer to an event (exclusive) or semaphore
       (shared) to wait for.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Limit;
    ULONG Number;
    POWNER_ENTRY OwnerEntry;
    PKTHREAD OwnerThread;
    NTSTATUS Status;
    PKTHREAD CurrentThread;
    LARGE_INTEGER Timeout;
#if DBG
    EXP_LOCK_HANDLE LockHandle;
#endif

    //
    // Increment the contention count for the resource, set the initial
    // timeout value, and wait for the specified object to be signalled
    // or a timeout to occur.
    //

    Limit = 0;
    Resource->ContentionCount += 1;
    Timeout.QuadPart = 500 * -10000;
    do {
        Status = KeWaitForSingleObject (
                        Object,
                        WrResource,
                        KernelMode,
                        FALSE,
                        &Timeout );

        if (Status != STATUS_TIMEOUT) {
            break;
        }

        //
        // The limit has been exceeded, then output status information.
        //

        Limit += 1;
        Timeout = ExpTimeout;
        if (Limit > ExResourceTimeoutCount) {
            Limit = 0;

#if DBG
            //
            // Output information for the specified resource.
            //

            EXP_LOCK_RESOURCE(Resource, &LockHandle);
            DbgPrint("Resource @ %p\n", Resource);
            DbgPrint(" ActiveCount = %04lx  Flags = %s%s%s\n",
                     Resource->ActiveCount,
                     IsOwnedExclusive(Resource) ? "IsOwnedExclusive " : "",
                     IsSharedWaiting(Resource) ? "SharedWaiter "     : "",
                     IsExclusiveWaiting(Resource) ? "ExclusiveWaiter "  : "");

            DbgPrint(" NumberOfExclusiveWaiters = %04lx\n", Resource->NumberOfExclusiveWaiters);

            DbgPrint("  Thread = %p, Count = %02x\n",
                     Resource->OwnerThreads[0].OwnerThread,
                     Resource->OwnerThreads[0].OwnerCount);

            DbgPrint("  Thread = %p, Count = %02x\n",
                     Resource->OwnerThreads[1].OwnerThread,
                     Resource->OwnerThreads[1].OwnerCount);

            OwnerEntry = Resource->OwnerTable;
            if (OwnerEntry != NULL) {
                Number = OwnerEntry->TableSize;
                for(Index = 1; Index < Number; Index += 1) {
                    OwnerEntry += 1;
                    DbgPrint("  Thread = %p, Count = %02x\n",
                             OwnerEntry->OwnerThread,
                             OwnerEntry->OwnerCount);
                }
            }

            DbgBreakPoint();
            DbgPrint("EX - Rewaiting\n");
            EXP_UNLOCK_RESOURCE(Resource, &LockHandle);
#endif
        }

        //
        // If priority boosts are allowed, then attempt to boost the priority
        // of owner threads.
        //

        if (IsBoostAllowed(Resource)) {

            //
            // Get the current thread address, lock the dispatcher database,
            // and set wait next in the current thread so the dispatcher
            // database lock does not need to be released before waiting
            // for the resource.
            //
            // N.B. Since the dispatcher database lock instead of the resource
            //      lock is being used to synchronize access to the resource,
            //      it is possible for the information being read from the
            //      resource to be stale. However, the important thing that
            //      cannot change is a valid thread address. Thus a thread
            //      could possibly get boosted that actually has dropped its
            //      access to the resource, but it guaranteed that the thread
            //      cannot be terminated or otherwise deleted.
            //
            // N.B. The dispatcher lock is released by the wait at the top of
            //      loop.
            //

            CurrentThread = KeGetCurrentThread();

            KiLockDispatcherDatabase(&CurrentThread->WaitIrql);
            CurrentThread->WaitNext = TRUE;

            //
            // Attempt to boost the one owner that can be shared or exclusive.
            //

            OwnerThread = (PKTHREAD)Resource->OwnerThreads[0].OwnerThread;
            if (OwnerThread != NULL) {
                ExpBoostOwnerThread(CurrentThread, OwnerThread);
            }

            //
            // If the specified resource is not owned exclusive, then attempt
            // to boost all the owning shared threads priority.
            //

            if (!IsOwnedExclusive(Resource)) {
                OwnerThread = (PKTHREAD)Resource->OwnerThreads[1].OwnerThread;
                if (OwnerThread != NULL) {
                    ExpBoostOwnerThread(CurrentThread, OwnerThread);
                }

                OwnerEntry = Resource->OwnerTable;
                if (OwnerEntry != NULL) {
                    Number = OwnerEntry->TableSize;
                    for(Index = 1; Index < Number; Index += 1) {
                        OwnerEntry += 1;
                        OwnerThread = (PKTHREAD)OwnerEntry->OwnerThread;
                        if (OwnerThread != NULL) {
                            ExpBoostOwnerThread(CurrentThread, OwnerThread);
                        }
                    }
                }
            }
        }

    } while (TRUE);

    return;
}

POWNER_ENTRY
FASTCALL
ExpFindCurrentThread(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD CurrentThread,
    IN PEXP_LOCK_HANDLE LockHandle OPTIONAL
    )

/*++

Routine Description:

    This function searches for the specified thread in the resource
    thread array. If the thread is located, then a pointer to the
    array entry is returned as the function value. Otherwise, a pointer
    to a free entry is returned.

    N.B. This routine is entered with the resource lock held and returns
         with the resource lock held. If the resource lock is released
         to expand the owner table, then the return value will be NULL.
         This is a signal to the caller that the complete operation must
         be repeated. This is done to avoid holding the resource lock
         while memory is allocated and freed.

Arguments:

    Resource - Supplies a pointer to the resource for which the search
        is performed.

    CurrentThread - Supplies the identification of the thread to search
        for.

    LockHandle - Supplies a pointer to a lock handle.  If NULL, then the
        caller just wants to know if the requested thread is an owner of
        this resource.  No free entry index is returned and no table
        expansion is performed.  Instead NULL is returned if the requested
        thread cannot be found in the table.

Return Value:

    A pointer to an owner entry is returned or NULL if one could not be
    allocated.

--*/

{

    POWNER_ENTRY FreeEntry;
    ULONG NewSize;
    ULONG OldSize;
    POWNER_ENTRY OldTable;
    POWNER_ENTRY OwnerEntry;
    POWNER_ENTRY OwnerBound;
    POWNER_ENTRY OwnerTable;
    KIRQL OldIrql;

    //
    // Search the owner threads for the specified thread and return either
    // a pointer to the found thread or a pointer to a free thread table
    // entry.
    //

    if (Resource->OwnerThreads[0].OwnerThread == CurrentThread) {
        return &Resource->OwnerThreads[0];

    } else if (Resource->OwnerThreads[1].OwnerThread == CurrentThread) {
        return &Resource->OwnerThreads[1];

    } else {
        FreeEntry = NULL;
        if (Resource->OwnerThreads[1].OwnerThread == 0) {
            FreeEntry = &Resource->OwnerThreads[1];
        }

        OwnerEntry = Resource->OwnerTable;
        if (OwnerEntry == NULL) {
            OldSize = 0;

        } else {
            OldSize = OwnerEntry->TableSize;
            OwnerBound = &OwnerEntry[OldSize];
            OwnerEntry += 1;
            do {
                if (OwnerEntry->OwnerThread == CurrentThread) {
                    KeGetCurrentThread()->ResourceIndex = (UCHAR)(OwnerEntry - Resource->OwnerTable);
                    return OwnerEntry;
                }

                if ((FreeEntry == NULL) &&
                    (OwnerEntry->OwnerThread == 0)) {
                    FreeEntry = OwnerEntry;
                }

                OwnerEntry += 1;
            } while (OwnerEntry != OwnerBound);
        }
    }

    if (!ARGUMENT_PRESENT(LockHandle)) {

        //
        // No argument indicates the caller does not want a free entry or
        // automatic table expansion.  The caller just wants to know if the
        // requested thread is a resource owner.  And clearly the answer is
        // NO at this point.
        //

        return NULL;
    }

    //
    // If a free entry was found in the table, then return the address of the
    // free entry. Otherwise, expand the size of the owner thread table.
    //

    if (FreeEntry != NULL) {
        KeGetCurrentThread()->ResourceIndex = (UCHAR)(FreeEntry - Resource->OwnerTable);
        return FreeEntry;
    }

    //
    // Save previous owner table address and allocate an expanded owner table.
    //

    ExpIncrementCounter(OwnerTableExpands);
    OldTable = Resource->OwnerTable;
    EXP_UNLOCK_RESOURCE(Resource, LockHandle);
    if (OldSize == 0 ) {
        NewSize = 3;

    } else {
        NewSize = OldSize + 4;
    }

    OwnerTable = ExAllocatePoolWithTag(NonPagedPool,
                                       NewSize * sizeof(OWNER_ENTRY),
                                       'aTeR');

    if (OwnerTable == NULL) {
        KeDelayExecutionThread(KernelMode, FALSE, &ExShortTime);

    } else {

        //
        // Zero the expansion area of the new owner table.
        //

        RtlZeroMemory(OwnerTable + OldSize,
                      (NewSize - OldSize) * sizeof(OWNER_ENTRY));

        //
        // Acquire the resource lock and determine if the owner table
        // has been expanded by another thread while the new owner table
        // was being allocated. If the owner table has been expanded by
        // another thread, then release the new owner table. Otherwise,
        // copy the owner table to the new owner table and establish the
        // new owner table as the owner table.
        //

        EXP_LOCK_RESOURCE(Resource, LockHandle);
        if ((OldTable != Resource->OwnerTable) ||
            ((OldTable != NULL) && (OldSize != OldTable->TableSize))) {
            EXP_UNLOCK_RESOURCE(Resource, LockHandle);
            ExFreePool(OwnerTable);

        } else {
            RtlCopyMemory(OwnerTable,
                          OldTable,
                          OldSize * sizeof(OWNER_ENTRY));

            //
            // Swapping of the owner table must be done while owning the
            // dispatcher lock to prevent a priority boost scan from occuring
            // while the table is being changed. The priority boost scan is
            // done when a time out occurs on a specific resource.
            //

            KiLockDispatcherDatabase(&OldIrql);
            OwnerTable->TableSize = NewSize;
            Resource->OwnerTable = OwnerTable;
            KiUnlockDispatcherDatabase(OldIrql);

            ASSERT_RESOURCE(Resource);

#if defined(_COLLECT_RESOURCE_DATA_)

            if (NewSize > ExpResourcePerformanceData.MaximumTableExpand) {
                ExpResourcePerformanceData.MaximumTableExpand = NewSize;
            }

#endif

            //
            // Release the resource lock and free the old owner table.
            //

            EXP_UNLOCK_RESOURCE(Resource, LockHandle);
            if (OldTable != NULL) {
                ExFreePool(OldTable);
            }

            if (OldSize == 0) {
                OldSize = 1;
            }
        }
    }

    //
    // Set the hint index, acquire the resource lock, and return NULL
    // as the function value. This will force a reevaluation of the
    // calling resource function.
    //

    KeGetCurrentThread()->ResourceIndex = (CCHAR)OldSize;
    EXP_LOCK_RESOURCE(Resource, LockHandle);
    return NULL;
}

#if DBG

VOID
ExpAssertResource (
    IN PERESOURCE Resource
    )

{
    //
    //  Assert that resource structure is correct.
    //
    // N.B. This routine is called with the resource lock held.
    //

    //
    // Check resource is aligned naturally.
    //

    ASSERT((((ULONG_PTR)Resource) & (sizeof(ULONG_PTR) - 1)) == 0);

    ASSERT(!Resource->SharedWaiters ||
           Resource->SharedWaiters->Header.Type == SemaphoreObject);

    ASSERT(!Resource->SharedWaiters ||
           Resource->SharedWaiters->Header.Size == (sizeof(KSEMAPHORE) / sizeof(ULONG)));

    ASSERT(!Resource->ExclusiveWaiters ||
           Resource->ExclusiveWaiters->Header.Type == SynchronizationEvent);

    ASSERT(!Resource->ExclusiveWaiters ||
           Resource->ExclusiveWaiters->Header.Size == (sizeof(KEVENT) / sizeof(ULONG)));
}

#endif

PVOID
ExpCheckForResource (
    IN PVOID p,
    IN SIZE_T Size
    )

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY Head, Next;
    volatile PLIST_ENTRY Last=NULL, Last1=NULL;
    PERESOURCE Resource;
    PCHAR BeginBlock;
    PCHAR EndBlock;

    //
    // This can cause a deadlock on MP machines.
    //

    if (KeNumberProcessors > 1) {
        return NULL;
    }

    if ((ExResourceCheckFlags&EX_RESOURCE_CHECK_FREES) == 0) {
        return NULL;
    }


    BeginBlock = (PCHAR)p;
    EndBlock = (PCHAR)p + Size;

    Head = &ExpSystemResourcesList;

    KeAcquireInStackQueuedSpinLock (&ExpResourceSpinLock, &LockHandle);
    Next = Head->Flink;
    while (Next != Head) {
        Resource = CONTAINING_RECORD(Next,
                                     ERESOURCE,
                                     SystemResourcesList);

        if ((PCHAR)Resource >= BeginBlock && (PCHAR)Resource < EndBlock) {
            DbgPrint("EX: ExFreePool( %p, %lx ) contains an ERESOURCE structure that has not been ExDeleteResourced\n",
                     p,
                     Size);

            DbgBreakPoint ();

            KeReleaseInStackQueuedSpinLock (&LockHandle);
            return (PVOID)Resource;
        }

        //
        //  Save the last ptr in a volatile variable for debugging when a flink is bad
        //  

        Last1 = Last;
        Last = Next;
        Next = Next->Flink;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return NULL;
}

#if DBG

VOID
ExCheckIfResourceOwned (
    VOID
    )
{
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY Head, Next;
    volatile PLIST_ENTRY Last=NULL, Last1=NULL;
    PERESOURCE Resource;

    if ((ExResourceCheckFlags&EX_RESOURCE_CHECK_ORPHANS) == 0) {
        return;
    }

    Head = &ExpSystemResourcesList;

    KeAcquireInStackQueuedSpinLock (&ExpResourceSpinLock, &LockHandle);

    Next = Head->Flink;
    while (Next != Head) {
        Resource = CONTAINING_RECORD(Next,
                                     ERESOURCE,
                                     SystemResourcesList);

        if (ExIsResourceAcquiredSharedLite (Resource) != 0) {
            DbgPrint("EX: Resource %p held in a position where all resources acquires should have been released\n",
                     Resource);

            DbgBreakPoint ();

            KeReleaseInStackQueuedSpinLock (&LockHandle);
            return;
        }

        //
        //  Save the last ptr in a volatile variable for debugging when a flink is bad
        //  

        Last1 = Last;
        Last = Next;
        Next = Next->Flink;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);
    return;    
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntos\ex\sysinfo.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    sysinfo.c

Abstract:

    This module implements the NT set and query system information services.

Author:

    Steve Wood (stevewo) 21-Aug-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "exp.h"
#pragma hdrstop

#include "stdlib.h"
#include "string.h"
#include "vdmntos.h"
#include <nturtl.h>
#include "pool.h"
#include "stktrace.h"
#include "align.h"

#if defined(_WIN64)
#include <wow64t.h>
#endif

extern ULONG MmAvailablePages;
extern ULONG MmSystemCodePage;
extern ULONG MmSystemCachePage;
extern ULONG MmPagedPoolPage;
extern ULONG MmSystemDriverPage;
extern ULONG MmTotalSystemCodePages;
extern ULONG MmTotalSystemDriverPages;
extern ULONG MmStandbyRePurposed;
extern RTL_TIME_ZONE_INFORMATION ExpTimeZoneInformation;

//
// For SystemDpcBehaviorInformation
//
extern ULONG KiMaximumDpcQueueDepth;
extern ULONG KiMinimumDpcRate;
extern ULONG KiAdjustDpcThreshold;
extern ULONG KiIdealDpcRate;

extern LIST_ENTRY MmLoadedUserImageList;

extern MMSUPPORT MmSystemCacheWs;
extern PFN_NUMBER MmTransitionSharedPages;
extern PFN_NUMBER MmTransitionSharedPagesPeak;

#define ROUND_UP(VALUE,ROUND) ((ULONG)(((ULONG)VALUE + \
                               ((ULONG)ROUND - 1L)) & (~((ULONG)ROUND - 1L))))
                               
//
// For referencing a user-supplied event handle
//
extern POBJECT_TYPE ExEventObjectType;

//
// Watchdog Handler
//

PWD_HANDLER ExpWdHandler = NULL;
PVOID       ExpWdHandlerContext = NULL;


//
// COM+ Package Install Status
//

const static UNICODE_STRING KeyName = RTL_CONSTANT_STRING  (COMPLUS_PACKAGE_KEYPATH);
static UNICODE_STRING KeyValueName = RTL_CONSTANT_STRING  (COMPLUS_PACKAGE_ENABLE64BIT);



NTSTATUS
ExpValidateLocale(
    IN LCID LocaleId
    );

BOOLEAN
ExpIsValidUILanguage(
    IN WCHAR *pLangId
    );

NTSTATUS
ExpGetCurrentUserUILanguage(
    IN WCHAR *ValueName,
    OUT LANGID *CurrentUserUILanguageId,
    IN BOOLEAN bCheckGP
    );

NTSTATUS
ExpSetCurrentUserUILanguage(
    IN WCHAR *ValueName,
    IN LANGID DefaultUILanguageId
    );

NTSTATUS
ExpGetUILanguagePolicy(
    IN HANDLE CurrentUserKey,
    OUT LANGID *PolicyUILanguageId
    );

NTSTATUS
ExpGetProcessInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId OPTIONAL,
    IN BOOLEAN ExtendedInformation
    );

NTSTATUS
ExGetSessionPoolTagInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId
    );

VOID
ExpGetProcessorIdleInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    );

VOID
ExpGetProcessorPowerInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    );

VOID
ExpCopyProcessInfo (
    IN PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    IN PEPROCESS Process,
    IN BOOLEAN ExtendedInformation
    );

VOID
ExpCopyThreadInfo (
    IN PVOID ThreadInfoBuffer,
    IN PETHREAD Thread,
    IN BOOLEAN ExtendedInformation
    );

#if i386
NTSTATUS
ExpGetStackTraceInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );
#endif // i386

NTSTATUS
ExpGetLockInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetLookasideInformation (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetHandleInformation(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetHandleInformationEx(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );

NTSTATUS
ExpGetObjectInformation(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    );


NTSTATUS
ExpGetInstemulInformation(
    OUT PSYSTEM_VDM_INSTEMUL_INFO Info
    );

NTSTATUS
ExGetPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExGetSessionPoolTagInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnedEntries,
    IN OUT PULONG ActualEntries
    );

NTSTATUS
ExGetBigPoolInfo (
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExpQueryModuleInformation(
    IN PLIST_ENTRY LoadOrderListHead,
    IN PLIST_ENTRY UserModeLoadOrderListHead,
    OUT PRTL_PROCESS_MODULES ModuleInformation,
    IN ULONG ModuleInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
ExpQueryLegacyDriverInformation(
    IN PSYSTEM_LEGACY_DRIVER_INFORMATION LegacyInfo,
    IN PULONG Length
    );

NTSTATUS
ExpQueryNumaProcessorMap(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnedLength
    );

NTSTATUS
ExpQueryNumaAvailableMemory(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnedLength
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, NtQueryDefaultLocale)
#pragma alloc_text(PAGE, NtSetDefaultLocale)
#pragma alloc_text(PAGE, NtQueryInstallUILanguage)
#pragma alloc_text(PAGE, NtQueryDefaultUILanguage)
#pragma alloc_text(PAGE, ExpGetCurrentUserUILanguage)
#pragma alloc_text(PAGE, NtSetDefaultUILanguage)
#pragma alloc_text(PAGE, ExpSetCurrentUserUILanguage)
#pragma alloc_text(PAGE, ExpValidateLocale)
#pragma alloc_text(PAGE, ExpGetUILanguagePolicy)
#pragma alloc_text(PAGE, NtQuerySystemInformation)
#pragma alloc_text(PAGE, NtSetSystemInformation)
#pragma alloc_text(PAGE, ExpGetHandleInformation)
#pragma alloc_text(PAGE, ExpGetHandleInformationEx)
#pragma alloc_text(PAGE, ExpGetObjectInformation)
#pragma alloc_text(PAGE, ExpQueryModuleInformation)
#pragma alloc_text(PAGE, ExpCopyProcessInfo)
#pragma alloc_text(PAGE, ExpQueryLegacyDriverInformation)
#pragma alloc_text(PAGE, ExLockUserBuffer)
#pragma alloc_text(PAGE, ExpQueryNumaAvailableMemory)
#pragma alloc_text(PAGE, ExpQueryNumaProcessorMap)
#pragma alloc_text(PAGE, ExpReadComPlusPackage)
#pragma alloc_text(PAGE, ExpUpdateComPlusPackage)
#pragma alloc_text(PAGE, ExGetSessionPoolTagInformation)
#pragma alloc_text(PAGELK, ExpGetLockInformation)
#pragma alloc_text(PAGELK, ExpGetProcessorPowerInformation)
#pragma alloc_text(PAGELK, ExpGetProcessorIdleInformation)
#pragma alloc_text(PAGE, ExpIsValidUILanguage)
#endif

NTSTATUS
ExpReadComPlusPackage(
    VOID
    )

/*++

Routine Description:

    This function reads the status of the 64-bit COM+ package from the registry
    and stick it inside the shared page.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status;
    static OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES (&KeyName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
    CHAR KeyValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    HANDLE Key;


    Status = ZwOpenKey (&Key,
                        GENERIC_READ,
                        &ObjectAttributes);

    if (NT_SUCCESS (Status)) {

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
        Status = ZwQueryValueKey (Key,
                                  &KeyValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof (KeyValueBuffer),
                                  &ResultLength);

        if (NT_SUCCESS (Status)) {

            if ((KeyValueInformation->Type == REG_DWORD) &&
                (KeyValueInformation->DataLength == sizeof(ULONG))) {
                SharedUserData->ComPlusPackage = *(PULONG)KeyValueInformation->Data;
            }
        }

        ZwClose (Key);
    }

    return Status;
}


NTSTATUS
ExpUpdateComPlusPackage(
    IN ULONG ComPlusPackageStatus
    )

/*++

Routine Description:

    This function updates the COM+ runtime package status on the system.
    The package status indicates whether the 64-bit or the 32-bit runtime
    should be used when executing IL_ONLY COM+ images.

Arguments:

    ComPlusPackageStatus - COM+ Runtime package status on the system


Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    static OBJECT_ATTRIBUTES ObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES (&KeyName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK);
    ULONG Disposition;
    HANDLE Key;


    Status = ZwOpenKey (&Key,
                        GENERIC_WRITE,
                        &ObjectAttributes
                        );

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        Status = ZwCreateKey (&Key,
                              GENERIC_WRITE,
                              &ObjectAttributes,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              &Disposition
                            );
    }

    if (NT_SUCCESS (Status)) {

        Status = ZwSetValueKey (Key,
                                &KeyValueName,
                                0,
                                REG_DWORD,
                                &ComPlusPackageStatus,
                                sizeof(ULONG));
        ZwClose (Key);
    }

    return Status;
}

NTSTATUS
NtQueryDefaultLocale (
    IN BOOLEAN UserProfile,
    OUT PLCID DefaultLocaleId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUlong ((PULONG)DefaultLocaleId);
        }

        if (UserProfile) {
            *DefaultLocaleId = MmGetSessionLocaleId ();
        }
        else {
            *DefaultLocaleId = PsDefaultSystemLocaleId;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
NtSetDefaultLocale (
    IN BOOLEAN UserProfile,
    IN LCID DefaultLocaleId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE CurrentUserKey, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    PWSTR s;
    ULONG n, i, Digit;
    WCHAR c;
    ULONG Flags;

    PAGED_CODE();

    if (DefaultLocaleId & 0xFFFF0000) {
        return STATUS_INVALID_PARAMETER;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    if (UserProfile) {
        Status = RtlOpenCurrentUser( KEY_ENUMERATE_SUB_KEYS, &CurrentUserKey );
        if (!NT_SUCCESS( Status )) {
            return Status;
        }

        RtlInitUnicodeString( &KeyValueName, L"Locale" );
        RtlInitUnicodeString( &KeyPath, L"Control Panel\\International" );
        Flags = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK;
    }
    else {
        RtlInitUnicodeString( &KeyValueName, L"Default" );
        RtlInitUnicodeString( &KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Language" );
        CurrentUserKey = NULL;
        Flags = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;
    }

    InitializeObjectAttributes (&ObjectAttributes,
                                &KeyPath,
                                Flags,
                                CurrentUserKey,
                                NULL);

    if (DefaultLocaleId == 0) {

        Status = ZwOpenKey (&Key, GENERIC_READ, &ObjectAttributes);

        if (NT_SUCCESS( Status )) {
            Status = ZwQueryValueKey( Key,
                                      &KeyValueName,
                                      KeyValuePartialInformation,
                                      KeyValueInformation,
                                      sizeof( KeyValueBuffer ),
                                      &ResultLength
                                    );
            if (NT_SUCCESS( Status )) {
                if (KeyValueInformation->Type == REG_SZ) {
                    s = (PWSTR)KeyValueInformation->Data;
                    for (i=0; i<KeyValueInformation->DataLength; i += sizeof( WCHAR )) {
                        c = *s++;
                        if (c >= L'0' && c <= L'9') {
                            Digit = c - L'0';
                        }
                        else if (c >= L'A' && c <= L'F') {
                            Digit = c - L'A' + 10;
                        }
                        else if (c >= L'a' && c <= L'f') {
                            Digit = c - L'a' + 10;
                        }
                        else {
                            break;
                        }

                        if (Digit >= 16) {
                            break;
                        }

                        DefaultLocaleId = (DefaultLocaleId << 4) | Digit;
                    }
                }
                else {
                    if (KeyValueInformation->Type == REG_DWORD &&
                        KeyValueInformation->DataLength == sizeof( ULONG )) {

                        DefaultLocaleId = *(PLCID)KeyValueInformation->Data;
                    }
                    else {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }
            }

            ZwClose( Key );
        }
    }
    else {

        Status = ExpValidateLocale( DefaultLocaleId );

        if (NT_SUCCESS(Status)) {

            Status = ZwOpenKey( &Key,
                                GENERIC_WRITE,
                                &ObjectAttributes
                              );

            if (NT_SUCCESS( Status )) {
                if (UserProfile) {
                    n = 8;
                }
                else {
                    n = 4;
                }

                s = &KeyValueBuffer[ n ];
                *s-- = UNICODE_NULL;
                i = (ULONG)DefaultLocaleId;

                while (s >= KeyValueBuffer) {
                    Digit = i & 0x0000000F;
                    if (Digit <= 9) {
                        *s-- = (WCHAR)(Digit + L'0');
                    }
                    else {
                        *s-- = (WCHAR)((Digit - 10) + L'A');
                    }

                    i = i >> 4;
                }

                Status = ZwSetValueKey( Key,
                                        &KeyValueName,
                                        0,
                                        REG_SZ,
                                        KeyValueBuffer,
                                        (n+1) * sizeof( WCHAR )
                                      );
                ZwClose( Key );
            }
        }
    }

    ZwClose( CurrentUserKey );

    if (NT_SUCCESS( Status )) {
        if (UserProfile) {
            MmSetSessionLocaleId (DefaultLocaleId);
        }
        else {
            PsDefaultSystemLocaleId = DefaultLocaleId;
        }
    }

    return Status;
}

NTSTATUS
NtQueryInstallUILanguage(
    OUT LANGID *InstallUILanguageId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUshort( (USHORT *)InstallUILanguageId );
            }

        *InstallUILanguageId = PsInstallUILanguageId;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}

NTSTATUS
NtQueryDefaultUILanguage(
    OUT LANGID *DefaultUILanguageId
    )
{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForWriteUshort( (USHORT *)DefaultUILanguageId );
            }

        //
        // Read the UI language from the current security context.
        //
        if (!NT_SUCCESS(ExpGetCurrentUserUILanguage( L"MultiUILanguageId",
                                                     DefaultUILanguageId,
                                                     TRUE))) {
            *DefaultUILanguageId = PsInstallUILanguageId;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        }

    return Status;
}



NTSTATUS
ExpGetUILanguagePolicy(
    IN HANDLE CurrentUserKey,
    OUT LANGID *PolicyUILanguageId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    ULONG Language;

    PAGED_CODE();

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    RtlInitUnicodeString( &KeyValueName, L"MultiUILanguageId" );
    RtlInitUnicodeString( &KeyPath, L"Software\\Policies\\Microsoft\\Control Panel\\Desktop" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                CurrentUserKey,
                                NULL
                              );

    //
    // Check if there is a Policy key
    //
    Status = ZwOpenKey( &Key,
                        GENERIC_READ,
                        &ObjectAttributes
                      );

    if (NT_SUCCESS( Status )) {

        Status = ZwQueryValueKey( Key,
                                  &KeyValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( KeyValueBuffer ),
                                  &ResultLength
                                );

        if (NT_SUCCESS( Status )) {
            if ((KeyValueInformation->DataLength > 2) &&
                (KeyValueInformation->Type == REG_SZ) &&
                ExpIsValidUILanguage((PWSTR) KeyValueInformation->Data)) {

                RtlInitUnicodeString( &KeyValueName, (PWSTR) KeyValueInformation->Data );
                Status = RtlUnicodeStringToInteger( &KeyValueName,
                                                    (ULONG)16,
                                                    &Language
                                                  );
                //
                // Final check to make sure this is an MUI system
                //
                if (NT_SUCCESS( Status )) {
                    *PolicyUILanguageId = (LANGID)Language;
                    }
                }
            else {
                Status = STATUS_UNSUCCESSFUL;
                }
            }
            ZwClose( Key );
        }

    return Status;
}



NTSTATUS
ExpSetCurrentUserUILanguage(
    IN WCHAR *ValueName,
    IN LANGID CurrentUserUILanguage
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName;
    HANDLE CurrentUserKey, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    PWSTR s;
    ULONG i, Digit;

    PAGED_CODE();

    if (CurrentUserUILanguage & 0xFFFF0000) {
        return STATUS_INVALID_PARAMETER;
        }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    Status = RtlOpenCurrentUser( KEY_ENUMERATE_SUB_KEYS, &CurrentUserKey );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }

    RtlInitUnicodeString( &KeyValueName, ValueName );
    RtlInitUnicodeString( &KeyPath, L"Control Panel\\Desktop" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK),
                                CurrentUserKey,
                                NULL
                              );


    Status = ExpValidateLocale( MAKELCID( CurrentUserUILanguage, SORT_DEFAULT ) );

    if (NT_SUCCESS(Status)) {

        Status = ZwOpenKey( &Key,
                            GENERIC_WRITE,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {

            s = &KeyValueBuffer[ 8 ];
            *s-- = UNICODE_NULL;
            i = (ULONG)CurrentUserUILanguage;

            while (s >= KeyValueBuffer) {
                Digit = i & 0x0000000F;
                if (Digit <= 9) {
                    *s-- = (WCHAR)(Digit + L'0');
                    }
                else {
                    *s-- = (WCHAR)((Digit - 10) + L'A');
                    }

                i = i >> 4;
                }

            Status = ZwSetValueKey( Key,
                                    &KeyValueName,
                                    0,
                                    REG_SZ,
                                    KeyValueBuffer,
                                    9 * sizeof( WCHAR )
                                  );
            ZwClose( Key );
            }
        }

    ZwClose( CurrentUserKey );

    return Status;
}


NTSTATUS
ExpGetCurrentUserUILanguage(
    IN WCHAR *ValueName,
    OUT LANGID *CurrentUserUILanguageId,
    IN BOOLEAN bCheckGP
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath, KeyValueName, UILanguage;
    HANDLE CurrentUserKey, Key;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength;
    ULONG Digit;

    PAGED_CODE();

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;
    Status = RtlOpenCurrentUser( KEY_ENUMERATE_SUB_KEYS, &CurrentUserKey );
    if (!NT_SUCCESS( Status )) {
        return Status;
        }
    RtlInitUnicodeString( &KeyValueName, ValueName );
    RtlInitUnicodeString( &KeyPath, L"Control Panel\\Desktop" );
    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE | OBJ_FORCE_ACCESS_CHECK),
                                CurrentUserKey,
                                NULL
                              );

    //
    // Let's check if there is a policy installed for the UI language,
    // and if so, let's use it.
    //
    if (!bCheckGP || !NT_SUCCESS( ExpGetUILanguagePolicy( CurrentUserKey, CurrentUserUILanguageId ))) {
        Status = ZwOpenKey( &Key,
                            GENERIC_READ,
                            &ObjectAttributes
                          );
        if (NT_SUCCESS( Status )) {
            Status = ZwQueryValueKey( Key,
                                      &KeyValueName,
                                      KeyValuePartialInformation,
                                      KeyValueInformation,
                                      sizeof( KeyValueBuffer ),
                                      &ResultLength
                                    );
            if (NT_SUCCESS( Status )) {

                if (KeyValueInformation->Type == REG_SZ &&
                    ExpIsValidUILanguage((PWSTR) KeyValueInformation->Data)) {

                    RtlInitUnicodeString( &UILanguage, (PWSTR) KeyValueInformation->Data);
                    Status = RtlUnicodeStringToInteger( &UILanguage,
                                                        (ULONG) 16,
                                                        &Digit
                                                      );
                    if (NT_SUCCESS( Status )) {
                        *CurrentUserUILanguageId = (LANGID) Digit;
                        }
                    }
                else {
                    Status = STATUS_UNSUCCESSFUL;
                    }
                }
                ZwClose( Key );
            }
        }

    ZwClose( CurrentUserKey );

    return Status;
}


NTSTATUS
NtSetDefaultUILanguage(
    IN LANGID DefaultUILanguageId
    )
{
    NTSTATUS Status;
    LANGID LangId;

    //
    //  if this is called during user logon, then we need to update the user's registry.
    //
    if (DefaultUILanguageId == 0) {
          Status = ExpGetCurrentUserUILanguage( L"MUILanguagePending" ,
                                                &LangId,
                                                FALSE
                                                );
          if (NT_SUCCESS( Status )) {
            Status = ExpSetCurrentUserUILanguage( L"MultiUILanguageId" ,
                                                  LangId
                                                );
            }
          return Status;
        }

    return ExpSetCurrentUserUILanguage( L"MUILanguagePending", DefaultUILanguageId );
}

NTSTATUS
ExpValidateLocale(
    IN LCID LocaleId
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER, ReturnStatus;
    UNICODE_STRING LocaleName, KeyValueName;
    UNICODE_STRING NlsLocaleKeyPath, NlsSortKeyPath, NlsLangGroupKeyPath;
    WCHAR LocaleNameBuffer[ 32 ];
    WCHAR KeyValueNameBuffer[ 32 ];
    WCHAR KeyValueBuffer[ 128 ];
    WCHAR *Ptr;
    HANDLE LocaleKey, SortKey, LangGroupKey;
    OBJECT_ATTRIBUTES NlsLocaleObjA, NlsSortObjA, NlsLangGroupObjA;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG i, ResultLength;


    //
    //  Convert the LCID to the form %08x (e.g. 00000409)
    //
    LocaleName.Length = sizeof( LocaleNameBuffer ) / sizeof( WCHAR );
    LocaleName.MaximumLength = LocaleName.Length;
    LocaleName.Buffer = LocaleNameBuffer;

    //
    //  Convert LCID to a string
    //
    ReturnStatus = RtlIntegerToUnicodeString( LocaleId, 16, &LocaleName );
    if (!NT_SUCCESS(ReturnStatus))
        goto Failed1;

    Ptr = KeyValueNameBuffer;
    for (i = ((LocaleName.Length)/sizeof(WCHAR));
         i < 8;
         i++, Ptr++) {
        *Ptr = L'0';
        }
    *Ptr = UNICODE_NULL;

    RtlInitUnicodeString(&KeyValueName, KeyValueNameBuffer);
    KeyValueName.MaximumLength = sizeof( KeyValueNameBuffer ) / sizeof( WCHAR );
    RtlAppendUnicodeToString(&KeyValueName, LocaleName.Buffer);


    //
    // Open Registry Keys : Locale, Sort and LanguageGroup
    //
    RtlInitUnicodeString(&NlsLocaleKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Locale");

    InitializeObjectAttributes( &NlsLocaleObjA,
                                &NlsLocaleKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );

    ReturnStatus = ZwOpenKey( &LocaleKey,
                              GENERIC_READ,
                              &NlsLocaleObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed1;

    RtlInitUnicodeString(&NlsSortKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Locale\\Alternate Sorts");

    InitializeObjectAttributes( &NlsSortObjA,
                                &NlsSortKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );

    ReturnStatus = ZwOpenKey( &SortKey,
                              GENERIC_READ,
                              &NlsSortObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed2;

    RtlInitUnicodeString(&NlsLangGroupKeyPath,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Language Groups");

    InitializeObjectAttributes( &NlsLangGroupObjA,
                                &NlsLangGroupKeyPath,
                                (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                NULL,
                                NULL
                              );


    ReturnStatus = ZwOpenKey( &LangGroupKey,
                              GENERIC_READ,
                              &NlsLangGroupObjA
                            );
    if (!NT_SUCCESS(ReturnStatus))
         goto Failed3;

    //
    // Validate Locale : Lookup the Locale's Language group, and make sure it is there.
    //
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) KeyValueBuffer;
    ReturnStatus = ZwQueryValueKey( LocaleKey,
                                    &KeyValueName,
                                    KeyValuePartialInformation,
                                    KeyValueInformation,
                                    sizeof( KeyValueBuffer ),
                                    &ResultLength
                                  );

    if (!NT_SUCCESS(ReturnStatus)) {
        ReturnStatus = ZwQueryValueKey( SortKey,
                                        &KeyValueName,
                                        KeyValuePartialInformation,
                                        KeyValueInformation,
                                        sizeof( KeyValueBuffer ),
                                        &ResultLength
                                      );
        }

    if ((NT_SUCCESS(ReturnStatus)) &&
        (KeyValueInformation->DataLength > 2)
       ) {

        RtlInitUnicodeString( &KeyValueName, (PWSTR) KeyValueInformation->Data );

        ReturnStatus = ZwQueryValueKey( LangGroupKey,
                                        &KeyValueName,
                                        KeyValuePartialInformation,
                                        KeyValueInformation,
                                        sizeof( KeyValueBuffer ),
                                        &ResultLength
                                      );
        if ((NT_SUCCESS(ReturnStatus)) &&
            (KeyValueInformation->Type == REG_SZ) &&
            (KeyValueInformation->DataLength > 2)
           ) {
            Ptr = (PWSTR) KeyValueInformation->Data;
            if (Ptr[0] == L'1' && Ptr[1] == UNICODE_NULL) {
                Status = STATUS_SUCCESS;
                }
            }
        }

    //
    // Close opened keys
    //

    ZwClose( LangGroupKey );

Failed3:
    ZwClose( SortKey );

Failed2:
    ZwClose( LocaleKey );

Failed1:

    //
    // If an error happens, let's record it.
    //
    if (!NT_SUCCESS(ReturnStatus)) {
        Status = ReturnStatus;
        }

    return Status;
}

NTSTATUS
ExpQueryNumaProcessorMap(
    OUT PVOID  SystemInformation,
    IN  ULONG  SystemInformationLength,
    OUT PULONG ReturnedLength
    )
{
    PSYSTEM_NUMA_INFORMATION Map;
    ULONG Length;
    ULONG ReturnCount;
#if !defined(NT_UP)
    ULONG i;
#endif

    Map = (PSYSTEM_NUMA_INFORMATION)SystemInformation;

    //
    // Must be able to return at least the number of nodes.
    //

    if (SystemInformationLength < sizeof(Map->HighestNodeNumber)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Map->HighestNodeNumber = KeNumberNodes - 1;

    //
    // Return as many node masks as possible in the SystemInformation
    // buffer.
    //

    Length = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                          ActiveProcessorsAffinityMask);

    ReturnCount = (SystemInformationLength - Length) /
                  sizeof(Map->ActiveProcessorsAffinityMask[0]);

    if (ReturnCount > KeNumberNodes) {
        ReturnCount = KeNumberNodes;
    }

    if ((Length > SystemInformationLength) ||
        (ReturnCount == 0)) {
        *ReturnedLength = sizeof(Map->HighestNodeNumber);
        return STATUS_SUCCESS;
    }

    *ReturnedLength = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                                   ActiveProcessorsAffinityMask[ReturnCount]);

#if !defined(NT_UP)

    for (i = 0; i < ReturnCount; i++) {
        Map->ActiveProcessorsAffinityMask[i] = KeNodeBlock[i]->ProcessorMask;
    }

#else

    if (ReturnCount) {
        Map->ActiveProcessorsAffinityMask[0] = 1;
    }

#endif

    return STATUS_SUCCESS;
}

NTSTATUS
ExpQueryNumaAvailableMemory(
    OUT PVOID  SystemInformation,
    IN  ULONG  SystemInformationLength,
    OUT PULONG ReturnedLength
    )
{
    PSYSTEM_NUMA_INFORMATION Map;
    ULONG Length;
    ULONG ReturnCount;

    Map = (PSYSTEM_NUMA_INFORMATION)SystemInformation;

    //
    // Must be able to return at least the number of nodes.
    //

    if (SystemInformationLength < sizeof(Map->HighestNodeNumber)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    Map->HighestNodeNumber = KeNumberNodes - 1;

    //
    // Return as many node masks as possible in the SystemInformation
    // buffer.
    //

    Length = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                          AvailableMemory);

    ReturnCount = (SystemInformationLength - Length) /
                  sizeof(Map->AvailableMemory[0]);

    if (ReturnCount > KeNumberNodes) {
        ReturnCount = KeNumberNodes;
    }

    if ((Length > SystemInformationLength) ||
        (ReturnCount == 0)) {
        *ReturnedLength = sizeof(Map->HighestNodeNumber);
        return STATUS_SUCCESS;
    }

    *ReturnedLength = FIELD_OFFSET(SYSTEM_NUMA_INFORMATION,
                                   AvailableMemory[ReturnCount]);

    //
    // Return the aproximate number of free bytes at this time.
    // (It's aproximate because no lock is taken and with respect
    // to any user mode application its only a sample.
    //

#if !defined(NT_UP)

    if (KeNumberNodes > 1) {

        ULONG i;

        for (i = 0; i < ReturnCount; i++) {
            Map->AvailableMemory[i] =
                ((ULONGLONG)KeNodeBlock[i]->FreeCount[ZeroedPageList] +
                 (ULONGLONG)KeNodeBlock[i]->FreeCount[FreePageList])
                    << PAGE_SHIFT;
        }
    } else

#endif

    if (ReturnCount) {
        Map->AvailableMemory[0] = ((ULONGLONG)MmAvailablePages) << PAGE_SHIFT;
    }


    return STATUS_SUCCESS;
}

NTSTATUS
ExpGetSystemBasicInformation (
    OUT PSYSTEM_BASIC_INFORMATION BasicInfo
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        BasicInfo->NumberOfProcessors = KeNumberProcessors;
        BasicInfo->ActiveProcessorsAffinityMask = (ULONG_PTR)KeActiveProcessors;
        BasicInfo->Reserved = 0;
        BasicInfo->TimerResolution = KeMaximumIncrement;
        BasicInfo->NumberOfPhysicalPages = MmNumberOfPhysicalPages;
        BasicInfo->LowestPhysicalPageNumber = (SYSINF_PAGE_COUNT)MmLowestPhysicalPage;
        BasicInfo->HighestPhysicalPageNumber = (SYSINF_PAGE_COUNT)MmHighestPhysicalPage;
        BasicInfo->PageSize = PAGE_SIZE;
        BasicInfo->AllocationGranularity = MM_ALLOCATION_GRANULARITY;
        BasicInfo->MinimumUserModeAddress = (ULONG_PTR)MM_LOWEST_USER_ADDRESS;
        BasicInfo->MaximumUserModeAddress = (ULONG_PTR)MM_HIGHEST_USER_ADDRESS;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}

NTSTATUS
ExpGetSystemProcessorInformation (
    OUT PSYSTEM_PROCESSOR_INFORMATION ProcessorInformation
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        ProcessorInformation->ProcessorArchitecture = KeProcessorArchitecture;
        ProcessorInformation->ProcessorLevel = KeProcessorLevel;
        ProcessorInformation->ProcessorRevision = KeProcessorRevision;
        ProcessorInformation->Reserved = 0;
        ProcessorInformation->ProcessorFeatureBits = KeFeatureBits;
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}
#if defined(_WIN64)

NTSTATUS
ExpGetSystemEmulationBasicInformation (
    OUT PSYSTEM_BASIC_INFORMATION BasicInfo
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    try {

        BasicInfo->NumberOfProcessors =  min(32, KeNumberProcessors);
        BasicInfo->ActiveProcessorsAffinityMask = (ULONG_PTR)
            ((KeActiveProcessors & 0xFFFFFFFF) | ((KeActiveProcessors & (0xFFFFFFFF << 32) ) >> 32));
        BasicInfo->Reserved = 0;
        BasicInfo->TimerResolution = KeMaximumIncrement;
        BasicInfo->NumberOfPhysicalPages = (MmNumberOfPhysicalPages * (PAGE_SIZE >> PAGE_SHIFT_X86NT));
        BasicInfo->LowestPhysicalPageNumber = (SYSINF_PAGE_COUNT)MmLowestPhysicalPage;
        BasicInfo->HighestPhysicalPageNumber = (SYSINF_PAGE_COUNT)MmHighestPhysicalPage;
        BasicInfo->PageSize = PAGE_SIZE_X86NT;
        BasicInfo->AllocationGranularity = MM_ALLOCATION_GRANULARITY;
        BasicInfo->MinimumUserModeAddress = 0x00000000000010000UI64;
        
        //
        // NOTE: MmGetMaxWowAddress return the highest usermode address boundary,
        // thus we are subtracting one to get the maximum accessible usermode address        
        //

        BasicInfo->MaximumUserModeAddress = ((ULONG_PTR)MmGetMaxWowAddress () - 1);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}
#endif

NTSTATUS
NtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )

/*++

Routine Description:

    This function queries information about the system.

Arguments:

    SystemInformationClass - The system information class about which
        to retrieve information.

    SystemInformation - A pointer to a buffer which receives the specified
        information.  The format and content of the buffer depend on the
        specified system information class.

        SystemInformation Format by Information Class:

        SystemBasicInformation - Data type is SYSTEM_BASIC_INFORMATION

            SYSTEM_BASIC_INFORMATION Structure

                ULONG Reserved - Always zero.

                ULONG TimerResolutionInMicroSeconds - The resolution of
                    the hardware time.  All time values in NT are
                    specified as 64-bit LARGE_INTEGER values in units of
                    100 nanoseconds.  This field allows an application to
                    understand how many of the low order bits of a system
                    time value are insignificant.

                ULONG PageSize - The physical page size for virtual memory
                    objects.  Physical memory is committed in PageSize
                    chunks.

                ULONG AllocationGranularity - The logical page size for
                    virtual memory objects.  Allocating 1 byte of virtual
                    memory will actually allocate AllocationGranularity
                    bytes of virtual memory.  Storing into that byte will
                    commit the first physical page of the virtual memory.

                ULONG MinimumUserModeAddress - The smallest valid user mode
                    address.  The first AllocationGranularity bytes of
                    the virtual address space are reserved.  This forces
                    access violations for code the dereferences a zero
                    pointer.

                ULONG MaximumUserModeAddress -  The largest valid user mode
                    address.  The next AllocationGranularity bytes of
                    the virtual address space are reserved.  This allows
                    system service routines to validate user mode pointer
                    parameters quickly.

                KAFFINITY ActiveProcessorsAffinityMask - The affinity mask
                    for the current hardware configuration.

                CCHAR NumberOfProcessors - The number of processors
                    in the current hardware configuration.

        SystemProcessorInformation - Data type is SYSTEM_PROCESSOR_INFORMATION

            SYSTEM_PROCESSOR_INFORMATION Structure

                USHORT ProcessorArchitecture - The processor architecture:
                    PROCESSOR_ARCHITECTURE_INTEL
                    PROCESSOR_ARCHITECTURE_IA64
                    PROCESSOR_ARCHITECTURE_MIPS
                    PROCESSOR_ARCHITECTURE_ALPHA
                    PROCESSOR_ARCHITECTURE_PPC

                USHORT ProcessorLevel - architecture dependent processor level.
                    This is the least common denominator for an MP system:

                    For PROCESSOR_ARCHITECTURE_INTEL:
                        3 - 386
                        4 - 486
                        5 - 586 or Pentium

                    For PROCESSOR_ARCHITECTURE_IA64:
                        7  - Itanium
                        31 - Itanium 2

                    For PROCESSOR_ARCHITECTURE_MIPS:
                        00xx - where xx is 8-bit implementation number (bits 8-15 of
                            PRId register.
                        0004 - R4000

                    For PROCESSOR_ARCHITECTURE_ALPHA:
                        xxxx - where xxxx is 16-bit processor version number (low
                            order 16 bits of processor version number from firmware)

                        21064 - 21064
                        21066 - 21066
                        21164 - 21164

                    For PROCESSOR_ARCHITECTURE_PPC:
                        xxxx - where xxxx is 16-bit processor version number (high
                            order 16 bits of Processor Version Register).
                        1 - 601
                        3 - 603
                        4 - 604
                        6 - 603+
                        9 - 604+
                        20 - 620

                USHORT ProcessorRevision - architecture dependent processor revision.
                    This is the least common denominator for an MP system:

                    For PROCESSOR_ARCHITECTURE_INTEL:
                        For Old Intel 386 or 486:
                            FFxx - where xx is displayed as a hexadecimal CPU stepping
                            (e.g. FFD0 is D0 stepping)

                        For Intel Pentium or Cyrix/NexGen 486
                            xxyy - where xx is model number and yy is stepping, so
                            0201 is Model 2, Stepping 1

                    For PROCESSOR_ARCHITECTURE_IA64:
                        xxyy - where xx is model number and yy is stepping, so
                            0201 is Model 2, Stepping 1

                    For PROCESSOR_ARCHITECTURE_MIPS:
                        00xx is 8-bit revision number of processor (low order 8 bits
                            of PRId Register

                    For PROCESSOR_ARCHITECTURE_ALPHA:
                        xxyy - where xxyy is 16-bit processor revision number (low
                            order 16 bits of processor revision number from firmware).
                            Displayed as Model 'A'+xx, Pass yy

                    For PROCESSOR_ARCHITECTURE_PPC:
                        xxyy - where xxyy is 16-bit processor revision number (low
                            order 16 bits of Processor Version Register).  Displayed
                            as a fixed point number xx.yy

                USHORT Reserved - Always zero.

                ULONG ProcessorFeatureBits - architecture dependent processor feature bits.
                    This is the least common denominator for an MP system.

        SystemPerformanceInformation - Data type is SYSTEM_PERFORMANCE_INFORMATION

            SYSTEM_PERFORMANCE_INFORMATION Structure

                LARGE_INTEGER IdleProcessTime - Returns the kernel time of the idle
                    process.

            LARGE_INTEGER IoReadTransferCount;
            LARGE_INTEGER IoWriteTransferCount;
            LARGE_INTEGER IoOtherTransferCount;
            LARGE_INTEGER KernelTime;
            LARGE_INTEGER UserTime;
            ULONG IoReadOperationCount;
            ULONG IoWriteOperationCount;
            ULONG IoOtherOperationCount;
            ULONG AvailablePages;
            ULONG CommittedPages;
            ULONG PageFaultCount;
            ULONG CopyOnWriteCount;
            ULONG TransitionCount;
            ULONG CacheTransitionCount;
            ULONG DemandZeroCount;
            ULONG PageReadCount;
            ULONG PageReadIoCount;
            ULONG CacheReadCount;
            ULONG CacheIoCount;
            ULONG DirtyPagesWriteCount;
            ULONG DirtyWriteIoCount;
            ULONG MappedPagesWriteCount;
            ULONG MappedWriteIoCount;
            ULONG PagedPoolPages;
            ULONG NonPagedPoolPages;
            ULONG PagedPoolAllocs;
            ULONG PagedPoolFrees;
            ULONG NonPagedPoolAllocs;
            ULONG NonPagedPoolFrees;
            ULONG LpcThreadsWaitingInReceive;
            ULONG LpcThreadsWaitingForReply;

        SystemProcessInformation - Data type is SYSTEM_PROCESS_INFORMATION

            SYSTEM_PROCESS_INFORMATION Structure

        SystemDockInformation - Data type is SYSTEM_DOCK_INFORMATION

             SYSTEM_DOCK_INFORMATION Structure

                 SYSTEM_DOCKED_STATE DockState - Ordinal specifying the current docking state. Possible values:
                     SystemDockStateUnknown - The docking state of the system could not be determined.
                     SystemUndocked - The system is undocked.
                     SystemDocked - The system is docked.

                 ULONG DockIdLength - Specifies the length in characters of the Dock ID string
                                      (not including terminating NULL).

                 ULONG SerialNumberOffset - Specifies the character offset of the Serial Number within
                                            the DockId buffer.

                 ULONG SerialNumberLength - Specifies the length in characters of the Serial Number
                                            string (not including terminating NULL).

                 WCHAR DockId - Character buffer containing two null-terminated strings.  The first
                                string is a character representation of the dock ID number, starting
                                at the beginning of the buffer.  The second string is a character
                                representation of the machine's serial number, starting at character
                                offset SerialNumberOffset in the buffer.


        SystemPowerSettings - Data type is SYSTEM_POWER_SETTINGS
            SYSTEM_POWER_INFORMATION Structure
                BOOLEAN SystemSuspendSupported - Supplies a BOOLEAN as to
                    whether the system suspend is enabled or not.
                BOOLEAN SystemHibernateSupported - Supplies a BOOLEAN as to
                    whether the system hibernate is enabled or not.
                BOOLEAN ResumeTimerSupportsSuspend - Supplies a BOOLEAN as to
                    whether the resuming from an external programmed timer
                    from within a system suspend is enabled or not.
                BOOLEAN ResumeTimerSupportsHibernate - Supplies a BOOLEAN as to
                    whether or resuming from an external programmed timer
                    from within a system hibernate is enabled or not.
                BOOLEAN LidSupported - Supplies a BOOLEAN as to whether or not
                    the suspending and resuming by Lid are enabled or not.
                BOOLEAN TurboSettingSupported - Supplies a BOOLEAN as to whether
                    or not the system supports a turbo mode setting.
                BOOLEAN TurboMode - Supplies a BOOLEAN as to whether or not
                    the system is in turbo mode.
                BOOLEAN SystemAcOrDc - Supplies a BOOLEAN as to whether or not
                    the system is in AC mode.
                BOOLEAN DisablePowerDown - If TRUE, signifies that all requests to
                    PoRequestPowerChange for a SET_POWER-PowerDown irp are to
                    be ignored.
                LARGE_INTEGER SpindownDrives - If non-zero, signifies to the
                    cache manager (or the IO subsystem) to optimize drive
                    accesses based upon power saves, are that drives are to
                    be spun down as appropriate. The value represents to user's
                    requested disk spin down timeout.

        SystemProcessorSpeedInformation - Data type is SYSTEM_PROCESSOR_SPEED_INFORMATION
            SYSTEM_PROCESSOR_SPEED_INFORMATION Structure (same as HalProcessorSpeedInformation)
                ULONG MaximumProcessorSpeed - The maximum hertz the processor is
                    capable of. This information is used by the UI to draw the
                    appropriate scale. This field is read-only and cannot be
                    set.
                ULONG CurrentAvailableSpeed - The hertz for which the processor
                    runs at when not idle. This field is read-only and cannot
                    be set.
                ULONG ConfiguredSpeedLimit - The hertz for which the processor
                    is limited to due to the current configuration.
                UCHAR PowerState
                    0 - Normal
                    1 - The processor speed is being limited due to available
                    power restrictions. This field id read-only by the system.
                UCHAR ThermalState
                    0 - Normal
                    1 - The processors speed is being limited due to thermal
                    restrictions. This field is read-only by the system.
                UCHAR TurboState
                    0 - Normal
                    1 - The processors speed is being limited by the fact that
                    the system turbo mode is currently disabled which is
                    requested to obtain more processor speed.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    ReturnLength - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the ReturnLength pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{

    KPROCESSOR_MODE PreviousMode;
    SYSTEM_TIMEOFDAY_INFORMATION LocalTimeOfDayInfo;
    SYSTEM_PERFORMANCE_INFORMATION LocalPerformanceInfo;
    PSYSTEM_PERFORMANCE_INFORMATION PerformanceInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorPerformanceInfo;
    PSYSTEM_CALL_COUNT_INFORMATION CallCountInformation;
    PSYSTEM_DEVICE_INFORMATION DeviceInformation;
    PCONFIGURATION_INFORMATION ConfigInfo;
    PSYSTEM_EXCEPTION_INFORMATION ExceptionInformation;
    PSYSTEM_FILECACHE_INFORMATION FileCache;
    PSYSTEM_QUERY_TIME_ADJUST_INFORMATION TimeAdjustmentInformation;
    PSYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInformation;
    PSYSTEM_CONTEXT_SWITCH_INFORMATION ContextSwitchInformation;
    PSYSTEM_INTERRUPT_INFORMATION InterruptInformation;
    PSYSTEM_SESSION_PROCESS_INFORMATION SessionProcessInformation;
    PVOID ProcessInformation;
    ULONG ProcessInformationLength;
    PSYSTEM_SESSION_POOLTAG_INFORMATION SessionPoolTagInformation;
    PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION SessionMappedViewInformation;
    ULONG SessionPoolTagInformationLength;

    NTSTATUS Status;
    PKPRCB Prcb;
    ULONG Length = 0;
    ULONG i;
    ULONG ContextSwitches;
    PULONG TableLimit, TableCounts;
    PKSERVICE_TABLE_DESCRIPTOR Table;
    ULONG SessionId;
    ULONG Alignment;

    PAGED_CODE();

    //
    // Assume successful completion.
    //

    Status = STATUS_SUCCESS;
    try {

        //
        // Get previous processor mode and probe output argument if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {

            Alignment = sizeof(ULONG);

            if (SystemInformationClass == SystemKernelDebuggerInformation) {
                Alignment = sizeof(BOOLEAN);
            } else if (SystemInformationClass == SystemLocksInformation) {
                Alignment = sizeof(PVOID);
            }

            ProbeForWrite(SystemInformation,
                          SystemInformationLength,
                          Alignment);

            if (ARGUMENT_PRESENT(ReturnLength)) {
                ProbeForWriteUlong(ReturnLength);
            }
        }

        if (ARGUMENT_PRESENT(ReturnLength)) {
            *ReturnLength = 0;
        }

        switch (SystemInformationClass) {

        case SystemBasicInformation:

            if (SystemInformationLength != sizeof( SYSTEM_BASIC_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetSystemBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_BASIC_INFORMATION );
            }
            break;

        case SystemEmulationBasicInformation:

            if (SystemInformationLength != sizeof( SYSTEM_BASIC_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if defined(_WIN64)
            Status = ExpGetSystemEmulationBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);
#else
            Status = ExpGetSystemBasicInformation ((PSYSTEM_BASIC_INFORMATION)SystemInformation);
#endif

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_BASIC_INFORMATION );
            }
            break;

        case SystemProcessorInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetSystemProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_PROCESSOR_INFORMATION );
            }

            break;

        case SystemEmulationProcessorInformation:

            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if defined(_WIN64)
            Status = ExpGetSystemEmulationProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);
#else
            Status = ExpGetSystemProcessorInformation ((PSYSTEM_PROCESSOR_INFORMATION)SystemInformation);
#endif

            if (NT_SUCCESS (Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_PROCESSOR_INFORMATION );
            }

            break;

        case SystemPerformanceInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PERFORMANCE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            PerformanceInfo = (PSYSTEM_PERFORMANCE_INFORMATION)SystemInformation;

            //
            // Io information.
            //

            LocalPerformanceInfo.IoReadTransferCount = IoReadTransferCount;
            LocalPerformanceInfo.IoWriteTransferCount = IoWriteTransferCount;
            LocalPerformanceInfo.IoOtherTransferCount = IoOtherTransferCount;
            LocalPerformanceInfo.IoReadOperationCount = IoReadOperationCount;
            LocalPerformanceInfo.IoWriteOperationCount = IoWriteOperationCount;
            LocalPerformanceInfo.IoOtherOperationCount = IoOtherOperationCount;

            //
            // Ke information.
            //
            // These counters are kept on a per processor basis and must
            // be totaled.
            //

            {
                ULONG FirstLevelTbFills = 0;
                ULONG SecondLevelTbFills = 0;
                ULONG SystemCalls = 0;
//                ULONG InterruptCount = 0;

                ContextSwitches = 0;
                for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                    Prcb = KiProcessorBlock[i];
                    if (Prcb != NULL) {
                        ContextSwitches += KeGetContextSwitches(Prcb);
                        FirstLevelTbFills += Prcb->KeFirstLevelTbFills;
//                        InterruptCount += Prcb->KeInterruptCount;
                        SecondLevelTbFills += Prcb->KeSecondLevelTbFills;
                        SystemCalls += Prcb->KeSystemCalls;
                    }
                }

                LocalPerformanceInfo.ContextSwitches = ContextSwitches;
                LocalPerformanceInfo.FirstLevelTbFills = FirstLevelTbFills;
//                LocalPerformanceInfo.InterruptCount = KeInterruptCount;
                LocalPerformanceInfo.SecondLevelTbFills = SecondLevelTbFills;
                LocalPerformanceInfo.SystemCalls = SystemCalls;
            }

            //
            // Mm information.
            //

            LocalPerformanceInfo.AvailablePages = MmAvailablePages;
            LocalPerformanceInfo.CommittedPages = (SYSINF_PAGE_COUNT)MmTotalCommittedPages;
            LocalPerformanceInfo.CommitLimit = (SYSINF_PAGE_COUNT)MmTotalCommitLimit;
            LocalPerformanceInfo.PeakCommitment = (SYSINF_PAGE_COUNT)MmPeakCommitment;
            LocalPerformanceInfo.PageFaultCount = MmInfoCounters.PageFaultCount;
            LocalPerformanceInfo.CopyOnWriteCount = MmInfoCounters.CopyOnWriteCount;
            LocalPerformanceInfo.TransitionCount = MmInfoCounters.TransitionCount;
            LocalPerformanceInfo.CacheTransitionCount = MmInfoCounters.CacheTransitionCount;
            LocalPerformanceInfo.DemandZeroCount = MmInfoCounters.DemandZeroCount;
            LocalPerformanceInfo.PageReadCount = MmInfoCounters.PageReadCount;
            LocalPerformanceInfo.PageReadIoCount = MmInfoCounters.PageReadIoCount;
            LocalPerformanceInfo.CacheReadCount = MmInfoCounters.CacheReadCount;
            LocalPerformanceInfo.CacheIoCount = MmInfoCounters.CacheIoCount;
            LocalPerformanceInfo.DirtyPagesWriteCount = MmInfoCounters.DirtyPagesWriteCount;
            LocalPerformanceInfo.DirtyWriteIoCount = MmInfoCounters.DirtyWriteIoCount;
            LocalPerformanceInfo.MappedPagesWriteCount = MmInfoCounters.MappedPagesWriteCount;
            LocalPerformanceInfo.MappedWriteIoCount = MmInfoCounters.MappedWriteIoCount;
            LocalPerformanceInfo.FreeSystemPtes = MmTotalFreeSystemPtes[0];

            LocalPerformanceInfo.ResidentSystemCodePage = MmSystemCodePage;
            LocalPerformanceInfo.ResidentSystemCachePage = MmSystemCachePage;
            LocalPerformanceInfo.ResidentPagedPoolPage = MmPagedPoolPage;
            LocalPerformanceInfo.ResidentSystemDriverPage = MmSystemDriverPage;
            LocalPerformanceInfo.TotalSystemCodePages = MmTotalSystemCodePages;
            LocalPerformanceInfo.TotalSystemDriverPages = MmTotalSystemDriverPages;
            LocalPerformanceInfo.AvailablePagedPoolPages = (ULONG)MmAvailablePoolInPages (PagedPool);
            //
            // Process information.
            //

            LocalPerformanceInfo.IdleProcessTime.QuadPart =
                                    UInt32x32To64(PsIdleProcess->Pcb.KernelTime,
                                                  KeMaximumIncrement);

            //
            // Pool information.
            //

            LocalPerformanceInfo.PagedPoolPages = 0;
            LocalPerformanceInfo.NonPagedPoolPages = 0;
            LocalPerformanceInfo.PagedPoolAllocs = 0;
            LocalPerformanceInfo.PagedPoolFrees = 0;
            LocalPerformanceInfo.PagedPoolLookasideHits = 0;
            LocalPerformanceInfo.NonPagedPoolAllocs = 0;
            LocalPerformanceInfo.NonPagedPoolFrees = 0;
            LocalPerformanceInfo.NonPagedPoolLookasideHits = 0;
            ExQueryPoolUsage( &LocalPerformanceInfo.PagedPoolPages,
                              &LocalPerformanceInfo.NonPagedPoolPages,
                              &LocalPerformanceInfo.PagedPoolAllocs,
                              &LocalPerformanceInfo.PagedPoolFrees,
                              &LocalPerformanceInfo.PagedPoolLookasideHits,
                              &LocalPerformanceInfo.NonPagedPoolAllocs,
                              &LocalPerformanceInfo.NonPagedPoolFrees,
                              &LocalPerformanceInfo.NonPagedPoolLookasideHits
                            );

            //
            // Cache Manager information.
            //

            LocalPerformanceInfo.CcFastReadNoWait = CcFastReadNoWait;
            LocalPerformanceInfo.CcFastReadWait = CcFastReadWait;
            LocalPerformanceInfo.CcFastReadResourceMiss = CcFastReadResourceMiss;
            LocalPerformanceInfo.CcFastReadNotPossible = CcFastReadNotPossible;
            LocalPerformanceInfo.CcFastMdlReadNoWait = CcFastMdlReadNoWait;
            LocalPerformanceInfo.CcFastMdlReadWait = CcFastMdlReadWait;
            LocalPerformanceInfo.CcFastMdlReadResourceMiss = CcFastMdlReadResourceMiss;
            LocalPerformanceInfo.CcFastMdlReadNotPossible = CcFastMdlReadNotPossible;
            LocalPerformanceInfo.CcMapDataNoWait = CcMapDataNoWait;
            LocalPerformanceInfo.CcMapDataWait = CcMapDataWait;
            LocalPerformanceInfo.CcMapDataNoWaitMiss = CcMapDataNoWaitMiss;
            LocalPerformanceInfo.CcMapDataWaitMiss = CcMapDataWaitMiss;
            LocalPerformanceInfo.CcPinMappedDataCount = CcPinMappedDataCount;
            LocalPerformanceInfo.CcPinReadNoWait = CcPinReadNoWait;
            LocalPerformanceInfo.CcPinReadWait = CcPinReadWait;
            LocalPerformanceInfo.CcPinReadNoWaitMiss = CcPinReadNoWaitMiss;
            LocalPerformanceInfo.CcPinReadWaitMiss = CcPinReadWaitMiss;
            LocalPerformanceInfo.CcCopyReadNoWait = CcCopyReadNoWait;
            LocalPerformanceInfo.CcCopyReadWait = CcCopyReadWait;
            LocalPerformanceInfo.CcCopyReadNoWaitMiss = CcCopyReadNoWaitMiss;
            LocalPerformanceInfo.CcCopyReadWaitMiss = CcCopyReadWaitMiss;
            LocalPerformanceInfo.CcMdlReadNoWait = CcMdlReadNoWait;
            LocalPerformanceInfo.CcMdlReadWait = CcMdlReadWait;
            LocalPerformanceInfo.CcMdlReadNoWaitMiss = CcMdlReadNoWaitMiss;
            LocalPerformanceInfo.CcMdlReadWaitMiss = CcMdlReadWaitMiss;
            LocalPerformanceInfo.CcReadAheadIos = CcReadAheadIos;
            LocalPerformanceInfo.CcLazyWriteIos = CcLazyWriteIos;
            LocalPerformanceInfo.CcLazyWritePages = CcLazyWritePages;
            LocalPerformanceInfo.CcDataFlushes = CcDataFlushes;
            LocalPerformanceInfo.CcDataPages = CcDataPages;

#if !defined(NT_UP)
            //
            // On an MP machines go sum up some other 'hot' cache manager
            // statistics.
            //

            for (i = 0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];

                LocalPerformanceInfo.CcFastReadNoWait += Prcb->CcFastReadNoWait;
                LocalPerformanceInfo.CcFastReadWait += Prcb->CcFastReadWait;
                LocalPerformanceInfo.CcFastReadNotPossible += Prcb->CcFastReadNotPossible;
                LocalPerformanceInfo.CcCopyReadNoWait += Prcb->CcCopyReadNoWait;
                LocalPerformanceInfo.CcCopyReadWait += Prcb->CcCopyReadWait;
                LocalPerformanceInfo.CcCopyReadNoWaitMiss += Prcb->CcCopyReadNoWaitMiss;
            }
#endif
            *PerformanceInfo = LocalPerformanceInfo;
            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(LocalPerformanceInfo);
            }

            break;

        case SystemProcessorPerformanceInformation:
            if (SystemInformationLength <
                sizeof( SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ProcessorPerformanceInfo =
                (PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) SystemInformation;

            Length = 0;
            for (i = 0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];
                if (Prcb != NULL) {
                    if (SystemInformationLength < Length + sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION))
                        break;

                    Length += sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);

                    ProcessorPerformanceInfo->UserTime.QuadPart =
                                                UInt32x32To64(Prcb->UserTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->KernelTime.QuadPart =
                                                UInt32x32To64(Prcb->KernelTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->DpcTime.QuadPart =
                                                UInt32x32To64(Prcb->DpcTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->InterruptTime.QuadPart =
                                                UInt32x32To64(Prcb->InterruptTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->IdleTime.QuadPart =
                                                UInt32x32To64(Prcb->IdleThread->KernelTime,
                                                              KeMaximumIncrement);

                    ProcessorPerformanceInfo->InterruptCount = Prcb->InterruptCount;

                    ProcessorPerformanceInfo++;
                }
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemProcessorPowerInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_POWER_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ExpGetProcessorPowerInformation(
                SystemInformation,
                SystemInformationLength,
                &Length
                );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemProcessorIdleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_PROCESSOR_IDLE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ExpGetProcessorIdleInformation(
                SystemInformation,
                SystemInformationLength,
                &Length
                );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemTimeOfDayInformation:
            if (SystemInformationLength > sizeof (SYSTEM_TIMEOFDAY_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            RtlZeroMemory (&LocalTimeOfDayInfo, sizeof(LocalTimeOfDayInfo));
            KeQuerySystemTime(&LocalTimeOfDayInfo.CurrentTime);
            LocalTimeOfDayInfo.BootTime = KeBootTime;
            LocalTimeOfDayInfo.TimeZoneBias = ExpTimeZoneBias;
            LocalTimeOfDayInfo.TimeZoneId = ExpCurrentTimeZoneId;
            LocalTimeOfDayInfo.BootTimeBias = KeBootTimeBias;
            LocalTimeOfDayInfo.SleepTimeBias = KeInterruptTimeBias;

            try {
                RtlCopyMemory (
                    SystemInformation,
                    &LocalTimeOfDayInfo,
                    SystemInformationLength
                    );

                if (ARGUMENT_PRESENT(ReturnLength) ) {
                    *ReturnLength = SystemInformationLength;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode ();
            }

            break;

            //
            // Query system time adjustment information.
            //

        case SystemTimeAdjustmentInformation:
            if (SystemInformationLength != sizeof( SYSTEM_QUERY_TIME_ADJUST_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            TimeAdjustmentInformation =
                    (PSYSTEM_QUERY_TIME_ADJUST_INFORMATION)SystemInformation;

            TimeAdjustmentInformation->TimeAdjustment = KeTimeAdjustment;
            TimeAdjustmentInformation->TimeIncrement = KeMaximumIncrement;
            TimeAdjustmentInformation->Enable = KeTimeSynchronization;
            break;

        case SystemSummaryMemoryInformation:
        case SystemFullMemoryInformation:

            if (SystemInformationLength < sizeof( SYSTEM_MEMORY_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmMemoryUsage (SystemInformation,
                                    SystemInformationLength,
             (SystemInformationClass == SystemFullMemoryInformation) ? 0 : 1,
                                    &Length);

            if (NT_SUCCESS(Status) && ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemPathInformation:
#if DBG
            DbgPrint( "EX: SystemPathInformation now available via SharedUserData\n" );
            DbgBreakPoint();
#endif
            return STATUS_NOT_IMPLEMENTED;
            break;

        case SystemProcessInformation:
        case SystemExtendedProcessInformation:
            {
                BOOLEAN ExtendedInformation;

                if (SystemInformationClass == SystemProcessInformation ) {
                    ExtendedInformation = FALSE;
                } else {
                    ExtendedInformation = TRUE;
                }

                Status = ExpGetProcessInformation (SystemInformation,
                                               SystemInformationLength,
                                               &Length,
                                               NULL,
                                               ExtendedInformation);

                if (ARGUMENT_PRESENT( ReturnLength )) {
                    *ReturnLength = Length;
                }
            }

            break;

        case SystemSessionProcessInformation:


            SessionProcessInformation =
                        (PSYSTEM_SESSION_PROCESS_INFORMATION)SystemInformation;

            if (SystemInformationLength < sizeof( SYSTEM_SESSION_PROCESS_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }
            //
            // The lower level locks the buffer specified below into memory using MmProbeAndLockPages.
            // We don't need to probe the buffers here.
            //
            SessionId = SessionProcessInformation->SessionId;
            ProcessInformation = SessionProcessInformation->Buffer;
            ProcessInformationLength = SessionProcessInformation->SizeOfBuf;

            if (!POINTER_IS_ALIGNED (ProcessInformation, sizeof (ULONG))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetProcessInformation (ProcessInformation,
                                               ProcessInformationLength,
                                               &Length,
                                               &SessionId,
                                               FALSE);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemCallCountInformation:

            Length = sizeof(SYSTEM_CALL_COUNT_INFORMATION) +
                        (NUMBER_SERVICE_TABLES * sizeof(ULONG));

            Table = KeServiceDescriptorTableShadow;

            for (i = 0; i < NUMBER_SERVICE_TABLES; i += 1) {
                if ((Table->Limit != 0) && (Table->Count != NULL)) {
                    Length += Table->Limit * sizeof(ULONG);
                }
                Table += 1;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            if (SystemInformationLength < Length) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            CallCountInformation = (PSYSTEM_CALL_COUNT_INFORMATION)SystemInformation;
            CallCountInformation->Length = Length;
            CallCountInformation->NumberOfTables = NUMBER_SERVICE_TABLES;

            TableLimit = (PULONG)(CallCountInformation + 1);
            TableCounts = TableLimit + NUMBER_SERVICE_TABLES;

            Table = KeServiceDescriptorTableShadow;

            for (i = 0; i < NUMBER_SERVICE_TABLES; i += 1) {
                if ((Table->Limit == 0) || (Table->Count == NULL)) {
                    *TableLimit++ = 0;
                } else {
                    *TableLimit++ = Table->Limit;
                    RtlCopyMemory((PVOID)TableCounts,
                                  (PVOID)Table->Count,
                                  Table->Limit * sizeof(ULONG));
                    TableCounts += Table->Limit;
                }
                Table += 1;
            }

            break;

        case SystemDeviceInformation:
            if (SystemInformationLength != sizeof( SYSTEM_DEVICE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ConfigInfo = IoGetConfigurationInformation();
            DeviceInformation = (PSYSTEM_DEVICE_INFORMATION)SystemInformation;
            DeviceInformation->NumberOfDisks = ConfigInfo->DiskCount;
            DeviceInformation->NumberOfFloppies = ConfigInfo->FloppyCount;
            DeviceInformation->NumberOfCdRoms = ConfigInfo->CdRomCount;
            DeviceInformation->NumberOfTapes = ConfigInfo->TapeCount;
            DeviceInformation->NumberOfSerialPorts = ConfigInfo->SerialCount;
            DeviceInformation->NumberOfParallelPorts = ConfigInfo->ParallelCount;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_DEVICE_INFORMATION );
            }
            break;

        case SystemFlagsInformation:
            if (SystemInformationLength != sizeof( SYSTEM_FLAGS_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags = NtGlobalFlag;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( SYSTEM_FLAGS_INFORMATION );
            }
            break;

        case SystemCallTimeInformation:
            return STATUS_NOT_IMPLEMENTED;

        case SystemModuleInformation:
            KeEnterCriticalRegion();
            ExAcquireResourceExclusiveLite( &PsLoadedModuleResource, TRUE );
            try {
                Status = ExpQueryModuleInformation( &PsLoadedModuleList,
                                                    &MmLoadedUserImageList,
                                                    (PRTL_PROCESS_MODULES)SystemInformation,
                                                    SystemInformationLength,
                                                    ReturnLength
                                                );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode();
            }
            ExReleaseResourceLite (&PsLoadedModuleResource);
            KeLeaveCriticalRegion();
            break;

        case SystemLocksInformation:
            if (SystemInformationLength < sizeof( RTL_PROCESS_LOCKS )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetLockInformation (SystemInformation,
                                            SystemInformationLength,
                                            &Length);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemStackTraceInformation:
            if (SystemInformationLength < sizeof( RTL_PROCESS_BACKTRACES )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

#if i386
            Status = ExpGetStackTraceInformation (SystemInformation,
                                                  SystemInformationLength,
                                                  &Length);
#else
            Status = STATUS_NOT_IMPLEMENTED;
#endif // i386

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemPagedPoolInformation:

            Status = STATUS_NOT_IMPLEMENTED;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = 0;
            }
            break;

        case SystemNonPagedPoolInformation:

            Status = STATUS_NOT_IMPLEMENTED;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = 0;
            }
            break;

        case SystemHandleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_HANDLE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!POINTER_IS_ALIGNED (SystemInformation, TYPE_ALIGNMENT (SYSTEM_HANDLE_INFORMATION))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetHandleInformation( SystemInformation,
                                              SystemInformationLength,
                                              &Length
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemExtendedHandleInformation:
            if (SystemInformationLength < sizeof( SYSTEM_HANDLE_INFORMATION_EX )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!POINTER_IS_ALIGNED (SystemInformation, TYPE_ALIGNMENT (SYSTEM_HANDLE_INFORMATION_EX))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExpGetHandleInformationEx( SystemInformation,
                                                SystemInformationLength,
                                                &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemObjectInformation:
            if (SystemInformationLength < sizeof( SYSTEM_OBJECTTYPE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetObjectInformation( SystemInformation,
                                              SystemInformationLength,
                                              &Length
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemPageFileInformation:

            if (SystemInformationLength < sizeof( SYSTEM_PAGEFILE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmGetPageFileInformation( SystemInformation,
                                               SystemInformationLength,
                                               &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;


        case SystemFileCacheInformation:

            //
            // This structure was extended in NT 4.0 from 12 bytes.
            // Use the previous size of 12 bytes for versioning info.
            //

            if (SystemInformationLength < 12) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            FileCache = (PSYSTEM_FILECACHE_INFORMATION)SystemInformation;
            FileCache->CurrentSize = ((SIZE_T)MmSystemCacheWs.WorkingSetSize) << PAGE_SHIFT;
            FileCache->PeakSize = ((SIZE_T)MmSystemCacheWs.PeakWorkingSetSize) << PAGE_SHIFT;
            FileCache->PageFaultCount = MmSystemCacheWs.PageFaultCount;

            i = 12;

            if (SystemInformationLength >= sizeof( SYSTEM_FILECACHE_INFORMATION )) {
                i = sizeof (SYSTEM_FILECACHE_INFORMATION);
                FileCache->MinimumWorkingSet =
                                MmSystemCacheWs.MinimumWorkingSetSize;
                FileCache->MaximumWorkingSet =
                                MmSystemCacheWs.MaximumWorkingSetSize;
                FileCache->CurrentSizeIncludingTransitionInPages = MmSystemCacheWs.WorkingSetSize + MmTransitionSharedPages;
                FileCache->PeakSizeIncludingTransitionInPages = MmTransitionSharedPagesPeak;
                FileCache->TransitionRePurposeCount = MmStandbyRePurposed;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = i;
            }
            break;

        case SystemSessionPoolTagInformation:

            SessionProcessInformation =
                        (PSYSTEM_SESSION_PROCESS_INFORMATION)SystemInformation;

            if (SystemInformationLength < sizeof( SYSTEM_SESSION_PROCESS_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // The lower level locks the buffer specified below into
            // memory using MmProbeAndLockPages.
            // We don't need to probe the buffers here.
            //

            SessionId = SessionProcessInformation->SessionId;
            SessionPoolTagInformation = SessionProcessInformation->Buffer;
            SessionPoolTagInformationLength = SessionProcessInformation->SizeOfBuf;

            if (!POINTER_IS_ALIGNED (SessionPoolTagInformation, sizeof (ULONGLONG))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = ExGetSessionPoolTagInformation (
                                            SessionPoolTagInformation,
                                            SessionPoolTagInformationLength,
                                            &Length,
                                            &SessionId);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemPoolTagInformation:

            if (SystemInformationLength < sizeof( SYSTEM_POOLTAG_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExGetPoolTagInfo (SystemInformation,
                                       SystemInformationLength,
                                       ReturnLength);

            break;

        case SystemBigPoolInformation:

            if (SystemInformationLength < sizeof( SYSTEM_BIGPOOL_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExGetBigPoolInfo (SystemInformation,
                                       SystemInformationLength,
                                       ReturnLength);

            break;

        case SystemSessionMappedViewInformation:

            SessionMappedViewInformation =
                        (PSYSTEM_SESSION_MAPPED_VIEW_INFORMATION)SystemInformation;

            if (SystemInformationLength < sizeof( SYSTEM_SESSION_MAPPED_VIEW_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // The lower level locks the buffer specified below into
            // memory using MmProbeAndLockPages.
            // We don't need to probe the buffers here.
            //

            SessionId = SessionMappedViewInformation->SessionId;

            if (!POINTER_IS_ALIGNED (SessionMappedViewInformation, sizeof (ULONGLONG))) {
                return STATUS_DATATYPE_MISALIGNMENT;
            }

            Status = MmGetSessionMappedViewInformation (
                                            SessionMappedViewInformation,
                                            SystemInformationLength,
                                            &Length,
                                            &SessionId);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }

            break;

        case SystemVdmInstemulInformation:
#ifdef i386
            if (SystemInformationLength < sizeof( SYSTEM_VDM_INSTEMUL_INFO )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpGetInstemulInformation(
                                            (PSYSTEM_VDM_INSTEMUL_INFO)SystemInformation
                                            );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_VDM_INSTEMUL_INFO);
            }
#else
            Status = STATUS_NOT_IMPLEMENTED;
#endif
            break;

            //
            // Get system exception information which includes the number
            // of exceptions that have dispatched, the number of alignment
            // fixups, and the number of floating emulations that have been
            // performed.
            //

        case SystemExceptionInformation:
            if (SystemInformationLength < sizeof( SYSTEM_EXCEPTION_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_EXCEPTION_INFORMATION);
            }

            ExceptionInformation = (PSYSTEM_EXCEPTION_INFORMATION)SystemInformation;

            //
            // Ke information.
            //
            // These counters are kept on a per processor basis and must
            // be totaled.
            //

            {
                ULONG AlignmentFixupCount = 0;
                ULONG ExceptionDispatchCount = 0;
                ULONG FloatingEmulationCount = 0;
                ULONG ByteWordEmulationCount = 0;

                for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                    Prcb = KiProcessorBlock[i];
                    if (Prcb != NULL) {
                        AlignmentFixupCount += Prcb->KeAlignmentFixupCount;
                        ExceptionDispatchCount += Prcb->KeExceptionDispatchCount;
                        FloatingEmulationCount += Prcb->KeFloatingEmulationCount;
                    }
                }

                ExceptionInformation->AlignmentFixupCount = AlignmentFixupCount;
                ExceptionInformation->ExceptionDispatchCount = ExceptionDispatchCount;
                ExceptionInformation->FloatingEmulationCount = FloatingEmulationCount;
                ExceptionInformation->ByteWordEmulationCount = ByteWordEmulationCount;
            }

            break;

        case SystemKernelDebuggerInformation:

            if (SystemInformationLength < sizeof( SYSTEM_KERNEL_DEBUGGER_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            KernelDebuggerInformation =
                (PSYSTEM_KERNEL_DEBUGGER_INFORMATION)SystemInformation;
            KernelDebuggerInformation->KernelDebuggerEnabled = KdDebuggerEnabled;
            KernelDebuggerInformation->KernelDebuggerNotPresent = KdDebuggerNotPresent;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION);
            }

            break;

        case SystemContextSwitchInformation:

            if (SystemInformationLength < sizeof( SYSTEM_CONTEXT_SWITCH_INFORMATION)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            ContextSwitchInformation =
                (PSYSTEM_CONTEXT_SWITCH_INFORMATION)SystemInformation;

            //
            // Compute the total number of context switches and fill in the
            // remainder of the context switch information.
            //

            ContextSwitches = 0;
            for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
                Prcb = KiProcessorBlock[i];
                if (Prcb != NULL) {
                    ContextSwitches += KeGetContextSwitches(Prcb);
                }

            }

            ContextSwitchInformation->ContextSwitches = ContextSwitches;
            ContextSwitchInformation->FindAny = KeThreadSwitchCounters.FindAny;
            ContextSwitchInformation->FindLast = KeThreadSwitchCounters.FindLast;
            ContextSwitchInformation->FindIdeal = KeThreadSwitchCounters.FindIdeal;
            ContextSwitchInformation->IdleAny = KeThreadSwitchCounters.IdleAny;
            ContextSwitchInformation->IdleCurrent = KeThreadSwitchCounters.IdleCurrent;
            ContextSwitchInformation->IdleLast = KeThreadSwitchCounters.IdleLast;
            ContextSwitchInformation->IdleIdeal = KeThreadSwitchCounters.IdleIdeal;
            ContextSwitchInformation->PreemptAny = KeThreadSwitchCounters.PreemptAny;
            ContextSwitchInformation->PreemptCurrent = KeThreadSwitchCounters.PreemptCurrent;
            ContextSwitchInformation->PreemptLast = KeThreadSwitchCounters.PreemptLast;
            ContextSwitchInformation->SwitchToIdle = KeThreadSwitchCounters.SwitchToIdle;

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_CONTEXT_SWITCH_INFORMATION);
            }

            break;

        case SystemRegistryQuotaInformation:

            if (SystemInformationLength < sizeof( SYSTEM_REGISTRY_QUOTA_INFORMATION)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }
            CmQueryRegistryQuotaInformation((PSYSTEM_REGISTRY_QUOTA_INFORMATION)SystemInformation);

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof(SYSTEM_REGISTRY_QUOTA_INFORMATION);
            }
            break;

        case SystemDpcBehaviorInformation:
            {
                PSYSTEM_DPC_BEHAVIOR_INFORMATION DpcInfo;
                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //
                if (SystemInformationLength != sizeof(SYSTEM_DPC_BEHAVIOR_INFORMATION)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                DpcInfo = (PSYSTEM_DPC_BEHAVIOR_INFORMATION)SystemInformation;

                //
                // Exception handler for this routine will return the correct
                // error if any of these accesses fail.
                //
                //
                // Return the current DPC behavior variables
                //
                DpcInfo->DpcQueueDepth = KiMaximumDpcQueueDepth;
                DpcInfo->MinimumDpcRate = KiMinimumDpcRate;
                DpcInfo->AdjustDpcThreshold = KiAdjustDpcThreshold;
                DpcInfo->IdealDpcRate = KiIdealDpcRate;
            }
            break;

        case SystemInterruptInformation:

            if (SystemInformationLength < (sizeof(SYSTEM_INTERRUPT_INFORMATION) * KeNumberProcessors)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            InterruptInformation = (PSYSTEM_INTERRUPT_INFORMATION)SystemInformation;
            for (i=0; i < (ULONG)KeNumberProcessors; i++) {
                Prcb = KiProcessorBlock[i];
                InterruptInformation->ContextSwitches = KeGetContextSwitches(Prcb);
                InterruptInformation->DpcCount = Prcb->DpcData[DPC_NORMAL].DpcCount;
                InterruptInformation->DpcRate = Prcb->DpcRequestRate;
                InterruptInformation->TimeIncrement = KeTimeIncrement;
                InterruptInformation->DpcBypassCount = 0;
                InterruptInformation->ApcBypassCount = 0;

                ++InterruptInformation;
            }

            break;

        case SystemCurrentTimeZoneInformation:
            if (SystemInformationLength < sizeof( RTL_TIME_ZONE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            RtlCopyMemory(SystemInformation,&ExpTimeZoneInformation,sizeof(ExpTimeZoneInformation));
            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = sizeof( RTL_TIME_ZONE_INFORMATION );
            }

            Status = STATUS_SUCCESS;
            break;

            //
            // Query pool lookaside list and general lookaside list
            // information.
            //

        case SystemLookasideInformation:
            Status = ExpGetLookasideInformation(SystemInformation,
                                                SystemInformationLength,
                                                &Length);

            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }

            break;

        case SystemRangeStartInformation:

            if ( SystemInformationLength != sizeof(ULONG_PTR) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            *(PULONG_PTR)SystemInformation = (ULONG_PTR)MmSystemRangeStart;

            if (ARGUMENT_PRESENT(ReturnLength) ) {
                *ReturnLength = sizeof(ULONG_PTR);
            }

            break;

        case SystemVerifierInformation:

            if (SystemInformationLength < sizeof( SYSTEM_VERIFIER_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = MmGetVerifierInformation( SystemInformation,
                                               SystemInformationLength,
                                               &Length
                                              );

            if (ARGUMENT_PRESENT( ReturnLength )) {
                *ReturnLength = Length;
            }
            break;

        case SystemLegacyDriverInformation:
            if (SystemInformationLength < sizeof(SYSTEM_LEGACY_DRIVER_INFORMATION)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }
            Length = SystemInformationLength;
            Status = ExpQueryLegacyDriverInformation((PSYSTEM_LEGACY_DRIVER_INFORMATION)SystemInformation, &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemPerformanceTraceInformation:
#ifdef NTPERF
            Status = PerfInfoQueryPerformanceTraceInformation(SystemInformation,
                                                SystemInformationLength,
                                                &Length
                                                );
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
#else
            Status = STATUS_INVALID_INFO_CLASS;
#endif // NTPERF
            break;

        case SystemPrefetcherInformation:

            Status = CcPfQueryPrefetcherInformation(SystemInformationClass,
                                                    SystemInformation,
                                                    SystemInformationLength,
                                                    PreviousMode,
                                                    &Length
                                                    );

            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }

            break;

        case SystemNumaProcessorMap:

            Status = ExpQueryNumaProcessorMap(SystemInformation,
                                              SystemInformationLength,
                                              &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemNumaAvailableMemory:

            Status = ExpQueryNumaAvailableMemory(SystemInformation,
                                                 SystemInformationLength,
                                                 &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        case SystemRecommendedSharedDataAlignment:
            if (SystemInformationLength < sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            //
            // Alignment is guaranteed by the ProbeForWrite above
            // so just store the value as a ULONG.
            //

            *(PULONG)SystemInformation = KeGetRecommendedSharedDataAlignment();
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }
            break;

        case SystemComPlusPackage:
            if (SystemInformationLength != sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            if (SharedUserData->ComPlusPackage == COMPLUS_PACKAGE_INVALID) {

                //
                // The initialization happens one time.
                //
                SharedUserData->ComPlusPackage = 0;

                ExpReadComPlusPackage ();
            }

            *(PULONG)SystemInformation = SharedUserData->ComPlusPackage;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }
            break;

        case SystemLostDelayedWriteInformation:

            if (SystemInformationLength < sizeof(ULONG)) {
                return(STATUS_INFO_LENGTH_MISMATCH);
            }

            *(PULONG)SystemInformation = CcLostDelayedWrites;
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = sizeof(ULONG);
            }
            break;

        case SystemObjectSecurityMode:

            if (SystemInformationLength != sizeof (ULONG)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            *(PULONG)SystemInformation = ObGetSecurityMode ();

            if (ARGUMENT_PRESENT (ReturnLength)) {
                *ReturnLength = sizeof (ULONG);
            }

            break;

        case SystemWatchdogTimerInformation:

            {
                PSYSTEM_WATCHDOG_TIMER_INFORMATION WdTimerInfo = (PSYSTEM_WATCHDOG_TIMER_INFORMATION) SystemInformation;

                //
                // Caller must be kernel mode with the proper parameters
                //

                if (PreviousMode != KernelMode || SystemInformation == NULL || SystemInformationLength != sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION)) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }

                if (ExpWdHandler == NULL) {

                    Status = STATUS_NOT_IMPLEMENTED;

                } else {

                    switch (WdTimerInfo->WdInfoClass) {
                        case WdInfoTimeoutValue:
                            Status = ExpWdHandler( WdActionQueryTimeoutValue, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        case WdInfoTriggerAction:
                            Status = ExpWdHandler( WdActionQueryTriggerAction, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        case WdInfoState:
                            Status = ExpWdHandler( WdActionQueryState, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        default:
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                    }
                }
            }

            break;

        case SystemLogicalProcessorInformation:

            Status = KeQueryLogicalProcessorInformation(
                         SystemInformation,
                         SystemInformationLength,
                         &Length);
            if (ARGUMENT_PRESENT(ReturnLength)) {
                *ReturnLength = Length;
            }
            break;

        default:

            //
            // Invalid argument.
            //

            return STATUS_INVALID_INFO_CLASS;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
NTAPI
NtSetSystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
    )

/*++

Routine Description:

    This function set information about the system.

Arguments:

    SystemInformationClass - The system information class which is to
        be modified.

    SystemInformation - A pointer to a buffer which contains the specified
        information. The format and content of the buffer depend on the
        specified system information class.


    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - Normal, successful completion.

        STATUS_ACCESS_VIOLATION - The specified system information buffer
            is not accessible.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_PRIVILEGE_NOT_HELD is returned if the caller does not have the
            privilege to set the system time.

--*/

{

    BOOLEAN Enable;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG TimeAdjustment;
    PSYSTEM_SET_TIME_ADJUST_INFORMATION TimeAdjustmentInformation;
    HANDLE EventHandle;
    PVOID Event;
    ULONG LoadFlags = MM_LOAD_IMAGE_IN_SESSION;

    PAGED_CODE();

    //
    // Establish an exception handle in case the system information buffer
    // is not accessible.
    //

    Status = STATUS_SUCCESS;

    try {

        //
        // Get the previous processor mode and probe the input buffer for
        // read access if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForRead((PVOID)SystemInformation,
                         SystemInformationLength,
                         sizeof(ULONG));
        }

        //
        // Dispatch on the system information class.
        //

        switch (SystemInformationClass) {
        case SystemFlagsInformation:
            if (SystemInformationLength != sizeof( SYSTEM_FLAGS_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {
                return STATUS_ACCESS_DENIED;
            }
            else {
                ULONG Flags;

                Flags = ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags &
                         ~(FLG_KERNELMODE_VALID_BITS | FLG_BOOTONLY_VALID_BITS);
                Flags |= NtGlobalFlag & (FLG_KERNELMODE_VALID_BITS | FLG_BOOTONLY_VALID_BITS);
                NtGlobalFlag = Flags;
                ((PSYSTEM_FLAGS_INFORMATION)SystemInformation)->Flags = NtGlobalFlag;
            }
            break;

            //
            // Set system time adjustment information.
            //
            // N.B. The caller must have the SeSystemTime privilege.
            //

        case SystemTimeAdjustmentInformation:

            //
            // If the system information buffer is not the correct length,
            // then return an error.
            //

            if (SystemInformationLength != sizeof( SYSTEM_SET_TIME_ADJUST_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to set the
            // time adjustment variables, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeSystemtimePrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            //
            // Set system time adjustment parameters.
            //

            TimeAdjustmentInformation =
                    (PSYSTEM_SET_TIME_ADJUST_INFORMATION)SystemInformation;

            Enable = TimeAdjustmentInformation->Enable;
            TimeAdjustment = TimeAdjustmentInformation->TimeAdjustment;

            if (Enable == TRUE) {
                KeTimeAdjustment = KeMaximumIncrement;
            } else {
                if (TimeAdjustment == 0) {
                    return STATUS_INVALID_PARAMETER_2;
                }
                KeTimeAdjustment = TimeAdjustment;
            }

            KeTimeSynchronization = Enable;
            break;

            //
            // Set an event to signal when the clock interrupt has been
            // masked for too long, causing the time to slip.
            // The event will be referenced to prevent it from being
            // deleted.  If the new event handle is valid or NULL, the
            // old event will be dereferenced and forgotten.  If the
            // event handle is non-NULL but invalid, the old event will
            // be remembered and a failure status will be returned.
            //
            // N.B. The caller must have the SeSystemTime privilege.
            //
        case SystemTimeSlipNotification:

            if (SystemInformationLength != sizeof(HANDLE)) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to set the
            // time adjustment variables, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeSystemtimePrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            EventHandle = *(PHANDLE)SystemInformation;

            if (EventHandle == NULL) {

                //
                // Dereference the old event and don't signal anything
                // for time slips.
                //

                Event = NULL;
                Status = STATUS_SUCCESS;

            } else {

                Status = ObReferenceObjectByHandle(EventHandle,
                                                   EVENT_MODIFY_STATE,
                                                   ExEventObjectType,
                                                   PreviousMode,
                                                   &Event,
                                                   NULL);
            }

            if (NT_SUCCESS(Status)) {
                KdUpdateTimeSlipEvent(Event);
            }

            break;

            //
            // Set registry quota limit.
            //
            // N.B. The caller must have SeIncreaseQuotaPrivilege
            //
        case SystemRegistryQuotaInformation:

            //
            // If the system information buffer is not the correct length,
            // then return an error.
            //

            if (SystemInformationLength != sizeof( SYSTEM_REGISTRY_QUOTA_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            //
            // If the current thread does not have the privilege to create
            // a pagefile, then return an error.
            //

            if ((PreviousMode != KernelMode) &&
                (SeSinglePrivilegeCheck(SeIncreaseQuotaPrivilege, PreviousMode) == FALSE)) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }

            //
            // Set registry quota parameters.
            //
            CmSetRegistryQuotaInformation((PSYSTEM_REGISTRY_QUOTA_INFORMATION)SystemInformation);

            break;

        case SystemPrioritySeperation:
            {
                ULONG PrioritySeparation;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof (ULONG)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (!SeSinglePrivilegeCheck (SeTcbPrivilege, PreviousMode)) {
                    return STATUS_PRIVILEGE_NOT_HELD;
                }

                try {
                    PrioritySeparation = *(PULONG)SystemInformation;
                }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    return GetExceptionCode();
                }

                PsChangeQuantumTable (TRUE, PrioritySeparation);
                Status = STATUS_SUCCESS;
            }
            break;

        case SystemExtendServiceTableInformation:
            {

                UNICODE_STRING Image;
                PWSTR  Buffer;
                PVOID ImageBaseAddress;
                ULONG_PTR EntryPoint;
                PVOID SectionPointer;
                PIMAGE_NT_HEADERS NtHeaders;
                PDRIVER_INITIALIZE InitRoutine;
                DRIVER_OBJECT Win32KDevice;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( UNICODE_STRING ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to ensure
                    // the caller has the privilege to load a driver.
                    //

                    if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    Buffer = NULL;

                    try {
                        Image = *(PUNICODE_STRING)SystemInformation;

                        //
                        // Guard against overflow.
                        //

                        if (Image.Length > Image.MaximumLength) {
                            Image.Length = Image.MaximumLength;
                        }
                        if (Image.Length == 0) {
                            return STATUS_NO_MEMORY;
                        }

                        ProbeForRead(Image.Buffer, Image.Length, sizeof(UCHAR));

                        Buffer = ExAllocatePoolWithTag(PagedPool, Image.Length, 'ofnI');
                        if ( !Buffer ) {
                            return STATUS_NO_MEMORY;
                        }

                        RtlCopyMemory(Buffer, Image.Buffer, Image.Length);
                        Image.Buffer = Buffer;
                        Image.MaximumLength = Image.Length;
                    }
                    except(EXCEPTION_EXECUTE_HANDLER) {
                        if ( Buffer ) {
                            ExFreePool(Buffer);
                        }
                        return GetExceptionCode();
                    }

                    //
                    // Call MmLoadSystemImage with previous mode of kernel.
                    //

                    Status = ZwSetSystemInformation(
                                SystemExtendServiceTableInformation,
                                (PVOID)&Image,
                                sizeof(Image)
                                );

                    ExFreePool(Buffer);

                    return Status;

                }

                Image = *(PUNICODE_STRING)SystemInformation;

                //
                // Now in kernelmode, so load the driver.
                //

                Status = MmLoadSystemImage (&Image,
                                            NULL,
                                            NULL,
                                            MM_LOAD_IMAGE_IN_SESSION,
                                            &SectionPointer,
                                            (PVOID *) &ImageBaseAddress);

                if (!NT_SUCCESS (Status)) {
                    return Status;
                }

                NtHeaders = RtlImageNtHeader( ImageBaseAddress );
                if (! NtHeaders) {
                    MmUnloadSystemImage (SectionPointer);
                    return STATUS_INVALID_IMAGE_FORMAT;
                }
                EntryPoint = NtHeaders->OptionalHeader.AddressOfEntryPoint;
                EntryPoint += (ULONG_PTR) ImageBaseAddress;
                InitRoutine = (PDRIVER_INITIALIZE) EntryPoint;

                RtlZeroMemory (&Win32KDevice, sizeof(Win32KDevice));
                ASSERT (KeGetCurrentIrql() == 0);

                Win32KDevice.DriverStart = (PVOID)ImageBaseAddress;
                Status = (InitRoutine)(&Win32KDevice,NULL);

                ASSERT (KeGetCurrentIrql() == 0);

                if (!NT_SUCCESS (Status)) {
                    MmUnloadSystemImage (SectionPointer);
                }
                else {

                    //
                    // Pass the driver object to memory management so the
                    // session can be unloaded cleanly.
                    //

                    MmSessionSetUnloadAddress (&Win32KDevice);
                }
            }
            break;


        case SystemUnloadGdiDriverInformation:
            {

                if (SystemInformationLength != sizeof( PVOID ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so fail.
                    // Only GDI from the kernel can call this.
                    //

                    return STATUS_PRIVILEGE_NOT_HELD;

                }

                MmUnloadSystemImage( *((PVOID *)SystemInformation) );

                Status = STATUS_SUCCESS;

            }
            break;

        case SystemLoadGdiDriverInSystemSpace:
            {
                LoadFlags &= ~MM_LOAD_IMAGE_IN_SESSION;
                //
                // Fall through
                //
            }

        case SystemLoadGdiDriverInformation:
            {

                UNICODE_STRING Image;
                PVOID ImageBaseAddress;
                ULONG_PTR EntryPoint;
                PVOID SectionPointer;

                PIMAGE_NT_HEADERS NtHeaders;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( SYSTEM_GDI_DRIVER_INFORMATION ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so fail.
                    // Only GDI from the kernel can call this.
                    //

                    return STATUS_PRIVILEGE_NOT_HELD;
                }

                Image = ((PSYSTEM_GDI_DRIVER_INFORMATION)SystemInformation)->DriverName;

                Status = MmLoadSystemImage (&Image,
                                            NULL,
                                            NULL,
                                            LoadFlags,
                                            &SectionPointer,
                                            (PVOID *) &ImageBaseAddress);


                if ((NT_SUCCESS( Status ))) {

                    PSYSTEM_GDI_DRIVER_INFORMATION GdiDriverInfo =
                        (PSYSTEM_GDI_DRIVER_INFORMATION) SystemInformation;

                    ULONG Size;

                    GdiDriverInfo->ExportSectionPointer =
                        RtlImageDirectoryEntryToData(ImageBaseAddress,
                                                     TRUE,
                                                     IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                     &Size);

                    //
                    // Capture the entry point.
                    //

                    NtHeaders = RtlImageNtHeader( ImageBaseAddress );
                    EntryPoint = NtHeaders->OptionalHeader.AddressOfEntryPoint;
                    EntryPoint += (ULONG_PTR) ImageBaseAddress;

                    GdiDriverInfo->ImageAddress = (PVOID) ImageBaseAddress;
                    GdiDriverInfo->SectionPointer = SectionPointer;
                    GdiDriverInfo->EntryPoint = (PVOID) EntryPoint;
                    GdiDriverInfo->ImageLength = NtHeaders->OptionalHeader.SizeOfImage;
                }
            }
            break;


        case SystemFileCacheInformation:

            if (SystemInformationLength < sizeof( SYSTEM_FILECACHE_INFORMATION )) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            if (!SeSinglePrivilegeCheck( SeIncreaseQuotaPrivilege, PreviousMode )) {
                return STATUS_ACCESS_DENIED;
            }

            return MmAdjustWorkingSetSize (
                        ((PSYSTEM_FILECACHE_INFORMATION)SystemInformation)->MinimumWorkingSet,
                        ((PSYSTEM_FILECACHE_INFORMATION)SystemInformation)->MaximumWorkingSet,
                        TRUE,
                        TRUE);

            break;

        case SystemDpcBehaviorInformation:
            {
                SYSTEM_DPC_BEHAVIOR_INFORMATION DpcInfo;
                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //
                if (SystemInformationLength != sizeof(SYSTEM_DPC_BEHAVIOR_INFORMATION)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {
                    //
                    // The caller's access mode is not kernel so check to ensure that
                    // the caller has the privilege to load a driver.
                    //

                    if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }
                }

                //
                // Exception handler for this routine will return the correct
                // error if this access fails.
                //
                DpcInfo = *(PSYSTEM_DPC_BEHAVIOR_INFORMATION)SystemInformation;

                //
                // Set the new DPC behavior variables
                //
                KiMaximumDpcQueueDepth = DpcInfo.DpcQueueDepth;
                KiMinimumDpcRate = DpcInfo.MinimumDpcRate;
                KiAdjustDpcThreshold = DpcInfo.AdjustDpcThreshold;
                KiIdealDpcRate = DpcInfo.IdealDpcRate;
            }
            break;

        case SystemSessionCreate:
            {

                //
                // Creation of a session space.
                //

                ULONG SessionId;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof(ULONG)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to
                    // ensure that the caller has the privilege to load
                    // a driver.
                    //

                    if (!SeSinglePrivilegeCheck (SeLoadDriverPrivilege, PreviousMode)) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        ProbeForWriteUlong((PULONG)SystemInformation);
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        return GetExceptionCode();
                    }
                }

                //
                // Create a session space in the current process.
                //

                Status = MmSessionCreate (&SessionId);

                if (NT_SUCCESS(Status)) {
                    if (PreviousMode != KernelMode) {
                        try {
                            *(PULONG)SystemInformation = SessionId;
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            return GetExceptionCode();
                        }
                    }
                    else {
                        *(PULONG)SystemInformation = SessionId;
                    }
                }

                return Status;
            }
            break;

        case SystemSessionDetach:
            {
                ULONG SessionId;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof(ULONG)) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to
                    // ensure that the caller has the privilege to load
                    // a driver.
                    //

                    if (!SeSinglePrivilegeCheck( SeLoadDriverPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        ProbeForRead ((PVOID)SystemInformation,
                                      sizeof(ULONG),
                                      sizeof(ULONG));

                        SessionId = *(PULONG)SystemInformation;
                    }
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        return GetExceptionCode();
                    }
                }
                else {
                    SessionId = *(PULONG)SystemInformation;
                }

                //
                // Detach the current process from a session space
                // if it has one.
                //

                Status = MmSessionDelete (SessionId);

                return Status;
            }
            break;

        case SystemCrashDumpStateInformation:

            //
            // All this system information does when you set it is trigger a
            // reconfigurating of the current crashdump state based on the
            // registry.
            //
            Status = IoConfigureCrashDump(CrashDumpReconfigure);

            break;

        case SystemPerformanceTraceInformation:
#ifdef NTPERF
            Status = PerfInfoSetPerformanceTraceInformation(SystemInformation,
                                                 SystemInformationLength
                                                 );
#else
            Status = STATUS_INVALID_INFO_CLASS;
#endif // NTPERF
            break;

        case SystemVerifierThunkExtend:

            if (PreviousMode != KernelMode) {

                //
                // The caller's access mode is not kernel so fail.
                // Only device drivers can call this.
                //

                return STATUS_PRIVILEGE_NOT_HELD;
            }

            Status = MmAddVerifierThunks (SystemInformation,
                                          SystemInformationLength);

            break;

        case SystemVerifierInformation:

            if (!SeSinglePrivilegeCheck (SeDebugPrivilege, PreviousMode)) {
                return STATUS_ACCESS_DENIED;
            }

            Status = MmSetVerifierInformation (SystemInformation,
                                               SystemInformationLength);

            break;

        case SystemVerifierAddDriverInformation:
        case SystemVerifierRemoveDriverInformation:

            {
                UNICODE_STRING Image;
                PUNICODE_STRING ImagePointer;
                PWSTR Buffer;

                //
                // If the system information buffer is not the correct length,
                // then return an error.
                //

                if (SystemInformationLength != sizeof( UNICODE_STRING ) ) {
                    return STATUS_INFO_LENGTH_MISMATCH;
                }

                Buffer = NULL;

                if (PreviousMode != KernelMode) {

                    //
                    // The caller's access mode is not kernel so check to ensure
                    // the caller has the privilege to add a verifier entry.
                    //

                    if (!SeSinglePrivilegeCheck( SeDebugPrivilege, PreviousMode )) {
                        return STATUS_PRIVILEGE_NOT_HELD;
                    }

                    try {
                        Image = *(PUNICODE_STRING)SystemInformation;

                        //
                        // Guard against overflow.
                        //

                        if (Image.Length > Image.MaximumLength) {
                            Image.Length = Image.MaximumLength;
                        }
                        if (Image.Length == 0) {
                            return STATUS_NO_MEMORY;
                        }

                        ProbeForRead(Image.Buffer, Image.Length, sizeof(UCHAR));

                        Buffer = ExAllocatePoolWithTag(PagedPool, Image.Length, 'ofnI');
                        if ( !Buffer ) {
                            return STATUS_NO_MEMORY;
                        }

                        RtlCopyMemory(Buffer, Image.Buffer, Image.Length);
                        Image.Buffer = Buffer;
                        Image.MaximumLength = Image.Length;
                    }
                    except(EXCEPTION_EXECUTE_HANDLER) {
                        if ( Buffer ) {
                            ExFreePool(Buffer);
                        }
                        return GetExceptionCode();
                    }
                    ImagePointer = &Image;
                }
                else {
                    ImagePointer = (PUNICODE_STRING)SystemInformation;
                }

                switch (SystemInformationClass) {
                    case SystemVerifierAddDriverInformation:
                        Status = MmAddVerifierEntry (ImagePointer);
                        break;
                    case SystemVerifierRemoveDriverInformation:
                        Status = MmRemoveVerifierEntry (ImagePointer);
                        break;
                    default:
                        Status = STATUS_INVALID_INFO_CLASS;
                        break;
                }

                if (Buffer) {
                    ExFreePool(Buffer);
                }
            }

            break;

        case SystemMirrorMemoryInformation:
            Status = MmCreateMirror ();
            break;

        case SystemPrefetcherInformation:

            Status = CcPfSetPrefetcherInformation(SystemInformationClass,
                                                  SystemInformation,
                                                  SystemInformationLength,
                                                  PreviousMode
                                                  );
            break;

        case SystemComPlusPackage:

            if (SystemInformationLength != sizeof( ULONG ) ) {
                return STATUS_INFO_LENGTH_MISMATCH;
            }

            Status = ExpUpdateComPlusPackage (*(PULONG)SystemInformation);
            if (NT_SUCCESS (Status)) {
                SharedUserData->ComPlusPackage = *(PULONG)SystemInformation;
            }

            break;

       case SystemHotpatchInformation:

#if defined(_X86_)

            Status = ExApplyCodePatch( SystemInformation,
                                       SystemInformationLength
                                       );
#else
            //
            //  The platforms which no not support hotpatching yet
            //  simple return the appropriate status
            //

            Status = STATUS_NOT_IMPLEMENTED;
#endif
            break;

        case SystemWatchdogTimerHandler:

            {
                PSYSTEM_WATCHDOG_HANDLER_INFORMATION WdHandlerInfo = (PSYSTEM_WATCHDOG_HANDLER_INFORMATION) SystemInformation;

                //
                // Caller must be kernel mode with the proper parameters
                //

                if (PreviousMode != KernelMode || SystemInformation == NULL || SystemInformationLength != sizeof(SYSTEM_WATCHDOG_HANDLER_INFORMATION)) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }

                ExpWdHandler = WdHandlerInfo->WdHandler;
                ExpWdHandlerContext = WdHandlerInfo->Context;
            }

            break;

        case SystemWatchdogTimerInformation:

            {
                PSYSTEM_WATCHDOG_TIMER_INFORMATION WdTimerInfo = (PSYSTEM_WATCHDOG_TIMER_INFORMATION) SystemInformation;

                //
                // Caller must be kernel mode with the proper parameters
                //

                if (PreviousMode != KernelMode || SystemInformation == NULL || SystemInformationLength != sizeof(SYSTEM_WATCHDOG_TIMER_INFORMATION)) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }

                if (ExpWdHandler == NULL) {

                    Status = STATUS_NOT_IMPLEMENTED;

                } else {

                    switch (WdTimerInfo->WdInfoClass) {
                        case WdInfoTimeoutValue:
                            Status = ExpWdHandler( WdActionSetTimeoutValue, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        case WdInfoResetTimer:
                            Status = ExpWdHandler( WdActionResetTimer, ExpWdHandlerContext, NULL, FALSE );
                            break;

                        case WdInfoStopTimer:
                            Status = ExpWdHandler( WdActionStopTimer, ExpWdHandlerContext, NULL, FALSE );
                            break;

                        case WdInfoStartTimer:
                            Status = ExpWdHandler( WdActionStartTimer, ExpWdHandlerContext, NULL, FALSE );
                            break;

                        case WdInfoTriggerAction:
                            Status = ExpWdHandler( WdActionSetTriggerAction, ExpWdHandlerContext, &WdTimerInfo->DataValue, FALSE );
                            break;

                        default:
                            Status = STATUS_INVALID_PARAMETER;
                            break;
                    }
                }
            }

            break;

        default:
            //KeBugCheckEx(SystemInformationClass,KdPitchDebugger,0,0,0);
            Status = STATUS_INVALID_INFO_CLASS;
            break;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}

NTSTATUS
ExLockUserBuffer (
    IN PVOID Buffer,
    IN ULONG Length,
    IN KPROCESSOR_MODE ProbeMode,
    IN LOCK_OPERATION LockMode,
    OUT PVOID *LockedBuffer,
    OUT PVOID *LockVariable
    )
/*++

Routine Description:

    Wrapper for MmProbeAndLockPages.  Creates an MDL and locks the
    specified buffer with that MDL.        

Arguments:

    Buffer - pointer to the buffer to be locked.
    Length - size of the buffer to be locked.
    ProbeMode - processor mode for doing the probe in MmProbeAndLockPages.
    LockMode - the mode the pages should be locked for.
    LockedBuffer - returns a pointer to the locked buffer for use by the 
                   caller.
    LockVariable - returns a context pointer.  This must be passed into
                   ExUnlockUserBuffer when complete so the MDL can be freed.                   

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - Normal, successful completion.

        STATUS_ACCESS_VIOLATION - The buffer is not accessible with the 
                 specified LockMode.
                 
        STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate the MDL.                                           
                 

--*/
{
    PMDL Mdl;
    SIZE_T MdlSize;

    //
    // It is the caller's responsibility to ensure zero cannot be passed in.
    //

    ASSERT (Length != 0);

    *LockedBuffer = NULL;
    *LockVariable = NULL;

    //
    // Allocate an MDL to map the request.
    //

    MdlSize = MmSizeOfMdl( Buffer, Length );
    Mdl = ExAllocatePoolWithQuotaTag (NonPagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                      MdlSize,
                                      'ofnI');
    if (Mdl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize MDL for request.
    //

    MmInitializeMdl(Mdl, Buffer, Length);

    try {

        MmProbeAndLockPages (Mdl, ProbeMode, LockMode);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        ExFreePool (Mdl);

        return GetExceptionCode();
    }

    Mdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    *LockedBuffer = MmGetSystemAddressForMdl (Mdl);
    if (*LockedBuffer == NULL) {
        ExUnlockUserBuffer (Mdl);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *LockVariable = Mdl;
    return STATUS_SUCCESS;
}


VOID
ExUnlockUserBuffer(
    IN PVOID LockVariable
    )

{
    MmUnlockPages ((PMDL)LockVariable);
    ExFreePool ((PMDL)LockVariable);
    return;
}

NTSTATUS
ExpGetProcessInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId OPTIONAL,
    IN BOOLEAN ExtendedInformation
    )
/*++

Routine Description:

    This function returns information about all the processes and
    threads in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.

    SessionId - Session Id.

    ExtendedInformation - TRUE if extended information (e.g., Process PDE) is needed.

Environment:

    Kernel mode.

    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    KLOCK_QUEUE_HANDLE LockHandle;
    PEPROCESS Process = NULL;
    PETHREAD Thread;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PVOID ThreadInfo;
    ULONG ThreadInfoSize;
    PLIST_ENTRY NextThread;
    PVOID MappedAddress;
    PVOID LockVariable;
    ULONG ProcessSessionId;
    ULONG TotalSize = 0;
    ULONG NextEntryOffset = 0;
    PUCHAR Src;
    PWCHAR SrcW;
    PWSTR Dst;
    ULONG n, nc;
    NTSTATUS status = STATUS_SUCCESS, status1;
    PUNICODE_STRING pImageFileName;

    *Length = 0;
    if (SystemInformationLength > 0) {
        status1 = ExLockUserBuffer (SystemInformation,
                                    SystemInformationLength,
                                    KeGetPreviousMode(),
                                    IoWriteAccess,
                                    &MappedAddress,
                                    &LockVariable);

        if (!NT_SUCCESS(status1)) {
            return status1;
        }

    } else {

        //
        // This indicates the caller just wants to know the size of the
        // buffer to allocate but is not prepared to accept any data content
        // in this instance.
        //

        MappedAddress = NULL;
        LockVariable = NULL;
    }

    if (ExtendedInformation) {
        ThreadInfoSize = sizeof(SYSTEM_EXTENDED_THREAD_INFORMATION);

    } else {
        ThreadInfoSize = sizeof(SYSTEM_THREAD_INFORMATION);
    }

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) MappedAddress;

    try {

        //
        // Do the idle process first then all the other processes.
        //

        for  (Process = PsIdleProcess;
              Process != NULL;
              Process = PsGetNextProcess ((Process == PsIdleProcess) ? NULL : Process)) {

            //
            // Skip terminating processes
            //

            if (Process->Flags&PS_PROCESS_FLAGS_PROCESS_EXITING) {
                continue;
            }

            if (ARGUMENT_PRESENT(SessionId) && Process == PsIdleProcess) {
                continue;
            }

            ProcessSessionId = MmGetSessionId (Process);
            if ((ARGUMENT_PRESENT(SessionId)) &&
                (ProcessSessionId != *SessionId)) {
                continue;
            }

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                            ((PUCHAR)MappedAddress + TotalSize);

            NextEntryOffset = sizeof(SYSTEM_PROCESS_INFORMATION);
            TotalSize += sizeof(SYSTEM_PROCESS_INFORMATION);
            if (TotalSize > SystemInformationLength) {
                status = STATUS_INFO_LENGTH_MISMATCH;

            } else {

                //
                // Get information for each process.
                //

                ExpCopyProcessInfo (ProcessInfo, Process, ExtendedInformation);
                ProcessInfo->NumberOfThreads = 0;

                //
                // Store the Remote Terminal SessionId
                //

                ProcessInfo->SessionId = ProcessSessionId;
                ProcessInfo->ImageName.Buffer = NULL;
                ProcessInfo->ImageName.Length = 0;
                ProcessInfo->ImageName.MaximumLength = 0;
                if (Process == PsIdleProcess) {

                    //
                    // Since Idle process and system process share the same
                    // object table, zero out idle processes handle count to
                    // reduce confusion
                    //
                    // Idle Process always has SessionId 0
                    //

                    ProcessInfo->HandleCount = 0;
                    ProcessInfo->SessionId = 0;
                }
            }

            //
            // Raise IRQL to SYNCH_LEVEL, acquire the kernel process lock, and
            // get information for each thread.
            //

            ThreadInfo = (PVOID)(ProcessInfo + 1);
            KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->Pcb.ProcessLock,
                                                       &LockHandle);

            NextThread = Process->Pcb.ThreadListHead.Flink;
            while (NextThread != &Process->Pcb.ThreadListHead) {
                NextEntryOffset += ThreadInfoSize;
                TotalSize += ThreadInfoSize;

                if (TotalSize > SystemInformationLength) {
                    status = STATUS_INFO_LENGTH_MISMATCH;

                } else {
                    Thread = (PETHREAD)(CONTAINING_RECORD(NextThread,
                                                          KTHREAD,
                                                          ThreadListEntry));

                    //
                    // Lock dispatcher database to get atomic view of thread
                    // attributes.
                    //

                    KiLockDispatcherDatabaseAtSynchLevel();
                    ExpCopyThreadInfo (ThreadInfo, Thread, ExtendedInformation);
                    KiUnlockDispatcherDatabaseFromSynchLevel();
                    ProcessInfo->NumberOfThreads += 1;
                    ThreadInfo = (PCHAR) ThreadInfo + ThreadInfoSize;
                }

                NextThread = NextThread->Flink;
            }

            //
            // Unlock kernel process lock and lower IRQL to its previous value.
            //

            KeReleaseInStackQueuedSpinLock(&LockHandle);

            //
            // Get the image name.
            //

            if (Process != PsIdleProcess) {

                //
                // Try to use the real image name if we can that not limited to 16 characters
                //

                Dst = (PWSTR)(ThreadInfo);
                status1 = SeLocateProcessImageName (Process, &pImageFileName);
                if (NT_SUCCESS (status1)) {
                    n = pImageFileName->Length;
                    if (n == 0) {
                        ExFreePool (pImageFileName);
                    }

                } else {
                    n = 0;
                }

                if (n) {
                    SrcW = pImageFileName->Buffer + n / sizeof (WCHAR);
                    while (SrcW != pImageFileName->Buffer) {
                        if (*--SrcW == L'\\') {
                            SrcW = SrcW + 1;
                            break;
                        }
                    }

                    nc = n - (ULONG)(SrcW -  pImageFileName->Buffer) * sizeof (WCHAR);
                    n = ROUND_UP (nc + 1, sizeof(LARGE_INTEGER));
                    TotalSize += n;
                    NextEntryOffset += n;
                    if (TotalSize > SystemInformationLength) {
                        status = STATUS_INFO_LENGTH_MISMATCH;

                    } else {
                        RtlCopyMemory (Dst, SrcW, nc);
                        Dst += nc / sizeof (WCHAR);
                        *Dst++ = L'\0';
                    }

                    ExFreePool (pImageFileName);

                } else {
                    Src = Process->ImageFileName;
                    n = (ULONG) strlen ((PCHAR)Src);
                    if (n != 0) {
                        n = ROUND_UP( ((n + 1) * sizeof( WCHAR )), sizeof(LARGE_INTEGER) );
                        TotalSize += n;
                        NextEntryOffset += n;
                        if (TotalSize > SystemInformationLength) {
                            status = STATUS_INFO_LENGTH_MISMATCH;

                        } else {
                            WCHAR c;

                            while (1) {
                                c = (WCHAR)*Src++;
                                *Dst++ =  c;
                                if (c == L'\0') {
                                    break;
                                }
                            }
                        }
                    }
                }

                if (NT_SUCCESS (status)) {
                    ProcessInfo->ImageName.Length = (USHORT)((PCHAR)Dst -
                                                             (PCHAR)ThreadInfo - sizeof( UNICODE_NULL ));

                    ProcessInfo->ImageName.MaximumLength = (USHORT)n;

                    //
                    // Set the image name to point into the user's memory.
                    //

                    ProcessInfo->ImageName.Buffer = (PWSTR)
                                ((PCHAR)SystemInformation +
                                 ((PCHAR)(ThreadInfo) - (PCHAR)MappedAddress));
                }
            }

            //
            // Point to next process.
            //

            if (NT_SUCCESS (status)) {
                ProcessInfo->NextEntryOffset = NextEntryOffset;
            }
        }

        if (NT_SUCCESS (status)) {
            ProcessInfo->NextEntryOffset = 0;
        }

        *Length = TotalSize;

    } finally {

        if (MappedAddress != NULL) {
            ExUnlockUserBuffer (LockVariable);
        }
    }

    return status;
}

NTSTATUS
ExGetSessionPoolTagInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length,
    IN PULONG SessionId OPTIONAL
    )
/*++

Routine Description:

    This function returns information about all the per-session pool tag
    information in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
                        information.

    SystemInformationLength - Specifies the length in bytes of the system
                              information buffer.

    Length - Receives the number of bytes placed (or would have been placed)
             in the system information buffer.

    SessionId - Session Id (-1 indicates enumerate all sessions).

Environment:

    Kernel mode.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    KAPC_STATE ApcState;
    PVOID MappedAddress;
    PVOID OpaqueSession;
    PVOID LockVariable;
    ULONG TotalSize;
    ULONG NextEntryOffset;
    ULONG CurrentSessionId;
    ULONG Count;
    ULONG AbsoluteCount;
    NTSTATUS status;
    NTSTATUS status1;
    PSYSTEM_SESSION_POOLTAG_INFORMATION SessionPoolTagInfo;

    *Length = 0;
    TotalSize = 0;
    NextEntryOffset = 0;
    status = STATUS_SUCCESS;
    SessionPoolTagInfo = NULL;

    if (SystemInformationLength > 0) {

        status1 = ExLockUserBuffer (SystemInformation,
                                    SystemInformationLength,
                                    KeGetPreviousMode(),
                                    IoWriteAccess,
                                    &MappedAddress,
                                    &LockVariable);

        if (!NT_SUCCESS(status1)) {
            return status1;
        }

    }
    else {

        //
        // This indicates the caller just wants to know the size of the
        // buffer to allocate but is not prepared to accept any data content
        // in this instance.
        //

        MappedAddress = NULL;
        LockVariable = NULL;
    }

    for (OpaqueSession = MmGetNextSession (NULL);
         OpaqueSession != NULL;
         OpaqueSession = MmGetNextSession (OpaqueSession)) {

        SessionPoolTagInfo = (PSYSTEM_SESSION_POOLTAG_INFORMATION)
                                ((PUCHAR)MappedAddress + TotalSize);

        //
        // If a specific session was requested, only extract that one.
        //

        CurrentSessionId = MmGetSessionId (OpaqueSession);

        if ((*SessionId == 0xFFFFFFFF) || (CurrentSessionId == *SessionId)) {

            //
            // Attach to session now to perform operations...
            //

            if (NT_SUCCESS (MmAttachSession (OpaqueSession, &ApcState))) {

                //
                // Session is still alive so include it.
                //

                NextEntryOffset = sizeof (SYSTEM_SESSION_POOLTAG_INFORMATION);
                TotalSize += sizeof (SYSTEM_SESSION_POOLTAG_INFORMATION);

                if (TotalSize > SystemInformationLength) {

                    status = STATUS_INFO_LENGTH_MISMATCH;

                    //
                    // Get absolute size for this session, ignore status as
                    // we must return the one above.
                    //

                    ExGetSessionPoolTagInfo (NULL,
                                             0,
                                             &Count,
                                             &AbsoluteCount);
                }
                else {

                    //
                    // Get pool tagging information for each session.
                    //

                    status = ExGetSessionPoolTagInfo (
                                    SessionPoolTagInfo->TagInfo,
                                    SystemInformationLength - TotalSize + sizeof (SYSTEM_POOLTAG),
                                    &Count,
                                    &AbsoluteCount);

                    SessionPoolTagInfo->SessionId = CurrentSessionId;
                    SessionPoolTagInfo->Count = Count;

                    //
                    // Point to next session.
                    //

                    if (NT_SUCCESS (status)) {
                        NextEntryOffset += ((Count - 1) * sizeof (SYSTEM_POOLTAG));
                        SessionPoolTagInfo->NextEntryOffset = NextEntryOffset;
                    }
                }

                TotalSize += ((AbsoluteCount - 1) * sizeof (SYSTEM_POOLTAG));

                //
                // Detach from session.
                //

                MmDetachSession (OpaqueSession, &ApcState);
            }

            //
            // Bail if only this session was of interest.
            //

            if (*SessionId != 0xFFFFFFFF) {
                MmQuitNextSession (OpaqueSession);
                break;
            }
        }
    }

    if ((NT_SUCCESS (status)) && (SessionPoolTagInfo != NULL)) {
        SessionPoolTagInfo->NextEntryOffset = 0;
    }

    if (MappedAddress != NULL) {
        ExUnlockUserBuffer (LockVariable);
    }

    *Length = TotalSize;

    return status;
}

VOID
ExpGetProcessorPowerInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    )
{
    KAFFINITY                           currentAffinity;
    KAFFINITY                           processors;
    KIRQL                               oldIrql;
    PKPRCB                              Prcb;
    PPROCESSOR_POWER_STATE              PState;
    PPROCESSOR_PERF_STATE               PerfStates;
    PSYSTEM_PROCESSOR_POWER_INFORMATION CallerPowerInfo;
    SYSTEM_PROCESSOR_POWER_INFORMATION  ProcessorPowerInfo;

    //
    // We will walk this pointer to store the user data...
    //
    CallerPowerInfo = (PSYSTEM_PROCESSOR_POWER_INFORMATION) SystemInformation;
    *Length = 0;

    //
    // Lock everything down
    //
    MmLockPagableSectionByHandle (ExPageLockHandle);

    //
    // Walk the list of processors
    //
    processors = KeActiveProcessors;
    currentAffinity = 1;
    while (processors) {

        if (!(processors & currentAffinity)) {

            currentAffinity <<= 1;

        }

        //
        // Check to see if we have the space for this
        //
        if (SystemInformationLength < *Length + sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION)) {

            break;

        }

        processors &= ~currentAffinity;
        KeSetSystemAffinityThread(currentAffinity);
        currentAffinity <<= 1;

        //
        // Raise to DPC level to synchronize access to the data structures
        //
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql );

        //
        // Get the PRCB and PowerState information
        //
        Prcb = KeGetCurrentPrcb();
        PState = &(Prcb->PowerState);
        PerfStates = PState->PerfStates;

        //
        // Grab the data that we care about
        //
        ProcessorPowerInfo.CurrentFrequency            = PState->CurrentThrottle;
        ProcessorPowerInfo.LastBusyFrequency           = PState->LastBusyPercentage;
        ProcessorPowerInfo.LastAdjustedBusyFrequency   = PState->LastAdjustedBusyPercentage;
        ProcessorPowerInfo.LastC3Frequency             = PState->LastC3Percentage;
        ProcessorPowerInfo.ProcessorMinThrottle        = PState->ProcessorMinThrottle;
        ProcessorPowerInfo.ProcessorMaxThrottle        = PState->ProcessorMaxThrottle;
        ProcessorPowerInfo.ErrorCount                  = PState->ErrorCount;
        ProcessorPowerInfo.RetryCount                  = PState->RetryCount;

        //
        // Do we have any kind of PerfStates?
        //
        if (PerfStates) {

            ProcessorPowerInfo.ThermalLimitFrequency       = PerfStates[PState->ThermalThrottleIndex].PercentFrequency;
            ProcessorPowerInfo.ConstantThrottleFrequency   = PerfStates[PState->KneeThrottleIndex].PercentFrequency;
            ProcessorPowerInfo.DegradedThrottleFrequency   = PerfStates[PState->ThrottleLimitIndex].PercentFrequency;

        } else {

            ProcessorPowerInfo.ThermalLimitFrequency       = 0;
            ProcessorPowerInfo.ConstantThrottleFrequency   = 0;
            ProcessorPowerInfo.DegradedThrottleFrequency   = 0;

        }

        ProcessorPowerInfo.CurrentFrequencyTime        =
            UInt32x32To64(
                (Prcb->KernelTime + Prcb->UserTime - PState->PerfTickCount),
                KeMaximumIncrement
                );
        ProcessorPowerInfo.CurrentProcessorTime        =
            UInt32x32To64(
                Prcb->KernelTime + Prcb->UserTime,
                KeMaximumIncrement
                );
        ProcessorPowerInfo.CurrentProcessorIdleTime    =
            UInt32x32To64( Prcb->IdleThread->KernelTime, KeMaximumIncrement );
        ProcessorPowerInfo.LastProcessorTime           =
            UInt32x32To64( PState->PerfSystemTime, KeMaximumIncrement );
        ProcessorPowerInfo.LastProcessorIdleTime       =
            UInt32x32To64( PState->PerfIdleTime, KeMaximumIncrement );

        ProcessorPowerInfo.PromotionCount              = PState->PromotionCount;
        ProcessorPowerInfo.DemotionCount               = PState->DemotionCount;
        ProcessorPowerInfo.NumberOfFrequencies         = PState->PerfStatesCount;

        //
        // Return to the original level (should be IRQL 0)
        //
        KeLowerIrql( oldIrql );

        //
        // Copy the data to the correct place
        //
        try {
            RtlCopyMemory(
                CallerPowerInfo,
                &ProcessorPowerInfo,
                sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION)
                );
        } except (EXCEPTION_EXECUTE_HANDLER) {
            MmUnlockPagableImageSection(ExPageLockHandle);
            ExRaiseStatus (GetExceptionCode ());
        }

        //
        // Point to the next structure element
        //
        CallerPowerInfo++;
        *Length += sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION);

    }

    //
    // Revert to the original affinity
    //
    KeRevertToUserAffinityThread();

    //
    // Unlock everything
    MmUnlockPagableImageSection(ExPageLockHandle);
}

VOID
ExpGetProcessorIdleInformation (
    OUT PVOID   SystemInformation,
    IN  ULONG   SystemInformationLength,
    OUT PULONG  Length
    )
{
    KAFFINITY                           currentAffinity;
    KAFFINITY                           processors;
    KIRQL                               oldIrql;
    LARGE_INTEGER                       PerfFrequency;
    PKPRCB                              Prcb;
    PPROCESSOR_POWER_STATE              PState;
    PSYSTEM_PROCESSOR_IDLE_INFORMATION  CallerIdleInfo;
    SYSTEM_PROCESSOR_IDLE_INFORMATION   ProcessorIdleInfo;

    //
    // We will walk this pointer to store the user data...
    //
    CallerIdleInfo = (PSYSTEM_PROCESSOR_IDLE_INFORMATION) SystemInformation;
    *Length = 0;

    //
    // We need to know what frequency the perf counters are running at
    //
    KeQueryPerformanceCounter(&PerfFrequency);

    //
    // Lock everything down
    //
    MmLockPagableSectionByHandle (ExPageLockHandle);

    //
    // Walk the list of processors
    //
    processors = KeActiveProcessors;
    currentAffinity = 1;
    while (processors) {

        if (!(processors & currentAffinity)) {

            currentAffinity <<= 1;

        }

        //
        // Check to see if we have the space for this
        //
        if (SystemInformationLength < *Length + sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION)) {

            break;

        }

        processors &= ~currentAffinity;
        KeSetSystemAffinityThread(currentAffinity);
        currentAffinity <<= 1;

        //
        // Raise to DPC level to synchronize access to the data structures
        //
        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql );

        //
        // Get the PRCB and PowerState information
        //
        Prcb = KeGetCurrentPrcb();
        PState = &(Prcb->PowerState);

        //
        // Grab the data that we care about
        //
        ProcessorIdleInfo.IdleTime = UInt32x32To64(Prcb->IdleThread->KernelTime,KeMaximumIncrement);

        //
        // The Cx times are kept in units of the same frequency as KeQueryPerformanceCounter
        // This needs to be converted to standard 100ns units.
        //
        ProcessorIdleInfo.C1Time =  (PState->TotalIdleStateTime[0]*1000)/(PerfFrequency.QuadPart/10000);
        ProcessorIdleInfo.C2Time =  (PState->TotalIdleStateTime[1]*1000)/(PerfFrequency.QuadPart/10000);
        ProcessorIdleInfo.C3Time =  (PState->TotalIdleStateTime[2]*1000)/(PerfFrequency.QuadPart/10000);

        ProcessorIdleInfo.C1Transitions = PState->TotalIdleTransitions[0];
        ProcessorIdleInfo.C2Transitions = PState->TotalIdleTransitions[1];
        ProcessorIdleInfo.C3Transitions = PState->TotalIdleTransitions[2];

        //
        // Return to the original level (should be IRQL 0)
        //
        KeLowerIrql( oldIrql );

        //
        // Copy the data to the correct place
        //
        try {
            RtlCopyMemory(
                CallerIdleInfo,
                &ProcessorIdleInfo,
                sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION)
                );
        } except (EXCEPTION_EXECUTE_HANDLER) {
            MmUnlockPagableImageSection (ExPageLockHandle);
            ExRaiseStatus (GetExceptionCode ());
        }

        //
        // Point to the next structure element
        //
        CallerIdleInfo++;
        *Length += sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION);

    }

    //
    // Revert to the original affinity
    //
    KeRevertToUserAffinityThread();

    //
    // Unlock everything
    //
    MmUnlockPagableImageSection(ExPageLockHandle);
}

VOID
ExpCopyProcessInfo (
    IN PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    IN PEPROCESS Process,
    IN BOOLEAN ExtendedInformation
    )

{
    PAGED_CODE();

    ProcessInfo->HandleCount = ObGetProcessHandleCount (Process);

    ProcessInfo->CreateTime = Process->CreateTime;
    ProcessInfo->UserTime.QuadPart = UInt32x32To64(Process->Pcb.UserTime,
                                                   KeMaximumIncrement);

    ProcessInfo->KernelTime.QuadPart = UInt32x32To64(Process->Pcb.KernelTime,
                                                     KeMaximumIncrement);

    ProcessInfo->BasePriority = Process->Pcb.BasePriority;
    ProcessInfo->UniqueProcessId = Process->UniqueProcessId;
    ProcessInfo->InheritedFromUniqueProcessId = Process->InheritedFromUniqueProcessId;
    ProcessInfo->PeakVirtualSize = Process->PeakVirtualSize;
    ProcessInfo->VirtualSize = Process->VirtualSize;
    ProcessInfo->PageFaultCount = Process->Vm.PageFaultCount;
    ProcessInfo->PeakWorkingSetSize = ((SIZE_T)Process->Vm.PeakWorkingSetSize) << PAGE_SHIFT;
    ProcessInfo->WorkingSetSize = ((SIZE_T)Process->Vm.WorkingSetSize) << PAGE_SHIFT;
    ProcessInfo->QuotaPeakPagedPoolUsage =
                            Process->QuotaPeak[PsPagedPool];
    ProcessInfo->QuotaPagedPoolUsage = Process->QuotaUsage[PsPagedPool];
    ProcessInfo->QuotaPeakNonPagedPoolUsage =
                            Process->QuotaPeak[PsNonPagedPool];
    ProcessInfo->QuotaNonPagedPoolUsage =
                            Process->QuotaUsage[PsNonPagedPool];
    ProcessInfo->PagefileUsage = Process->QuotaUsage[PsPageFile] << PAGE_SHIFT;
    ProcessInfo->PeakPagefileUsage = Process->QuotaPeak[PsPageFile] << PAGE_SHIFT;
    ProcessInfo->PrivatePageCount = Process->CommitCharge << PAGE_SHIFT;

    ProcessInfo->ReadOperationCount = Process->ReadOperationCount;
    ProcessInfo->WriteOperationCount = Process->WriteOperationCount;
    ProcessInfo->OtherOperationCount = Process->OtherOperationCount;
    ProcessInfo->ReadTransferCount = Process->ReadTransferCount;
    ProcessInfo->WriteTransferCount = Process->WriteTransferCount;
    ProcessInfo->OtherTransferCount = Process->OtherTransferCount;

    if (ExtendedInformation) {
        ProcessInfo->PageDirectoryBase = MmGetDirectoryFrameFromProcess(Process);
    }
}

VOID
ExpCopyThreadInfo (
    IN PVOID ThreadInfoBuffer,
    IN PETHREAD Thread,
    IN BOOLEAN ExtendedInformation
    )

/*++

Routine Description:

    This function returns information about the specified thread.

Arguments:

    ThreadInfoBuffer - A pointer to a buffer which receives the specified
        information.

    Thread - Supplies a pointer to the desired thread.

    ExtendedInformation - TRUE if extended thread information is needed.

Environment:

    Kernel mode.  The dispatcher lock is held.

    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    None.

--*/

{
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    ThreadInfo = (PSYSTEM_THREAD_INFORMATION) ThreadInfoBuffer;

    ThreadInfo->KernelTime.QuadPart = UInt32x32To64(Thread->Tcb.KernelTime,
                                                    KeMaximumIncrement);

    ThreadInfo->UserTime.QuadPart = UInt32x32To64(Thread->Tcb.UserTime,
                                                  KeMaximumIncrement);

    ThreadInfo->CreateTime.QuadPart = PS_GET_THREAD_CREATE_TIME (Thread);
    ThreadInfo->WaitTime = Thread->Tcb.WaitTime;
    ThreadInfo->ClientId = Thread->Cid;
    ThreadInfo->ThreadState = Thread->Tcb.State;
    ThreadInfo->WaitReason = Thread->Tcb.WaitReason;
    ThreadInfo->Priority = Thread->Tcb.Priority;
    ThreadInfo->BasePriority = Thread->Tcb.BasePriority;
    ThreadInfo->ContextSwitches = Thread->Tcb.ContextSwitches;
    ThreadInfo->StartAddress = Thread->StartAddress;

    if (ExtendedInformation) {
        PSYSTEM_EXTENDED_THREAD_INFORMATION ExtendedThreadInfo;

        ExtendedThreadInfo = (PSYSTEM_EXTENDED_THREAD_INFORMATION) ThreadInfo;

        ExtendedThreadInfo->StackBase = Thread->Tcb.StackBase;
        ExtendedThreadInfo->StackLimit = Thread->Tcb.StackLimit;
        if (Thread->LpcReceivedMsgIdValid) {
            ExtendedThreadInfo->Win32StartAddress = 0;
        } else {
            ExtendedThreadInfo->Win32StartAddress = Thread->Win32StartAddress;
        }
        ExtendedThreadInfo->Reserved1 = 0;
        ExtendedThreadInfo->Reserved2 = 0;
        ExtendedThreadInfo->Reserved3 = 0;
        ExtendedThreadInfo->Reserved4 = 0;
    }

}

#if defined(_X86_)
extern ULONG ExVdmOpcodeDispatchCounts[256];
extern ULONG VdmBopCount;
extern ULONG ExVdmSegmentNotPresent;

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, ExpGetInstemulInformation)
#endif


NTSTATUS
ExpGetInstemulInformation(
    OUT PSYSTEM_VDM_INSTEMUL_INFO Info
    )
{
    SYSTEM_VDM_INSTEMUL_INFO LocalInfo;

    LocalInfo.VdmOpcode0F       = ExVdmOpcodeDispatchCounts[VDM_INDEX_0F];
    LocalInfo.OpcodeESPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_ESPrefix];
    LocalInfo.OpcodeCSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_CSPrefix];
    LocalInfo.OpcodeSSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_SSPrefix];
    LocalInfo.OpcodeDSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_DSPrefix];
    LocalInfo.OpcodeFSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_FSPrefix];
    LocalInfo.OpcodeGSPrefix    = ExVdmOpcodeDispatchCounts[VDM_INDEX_GSPrefix];
    LocalInfo.OpcodeOPER32Prefix= ExVdmOpcodeDispatchCounts[VDM_INDEX_OPER32Prefix];
    LocalInfo.OpcodeADDR32Prefix= ExVdmOpcodeDispatchCounts[VDM_INDEX_ADDR32Prefix];
    LocalInfo.OpcodeINSB        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INSB];
    LocalInfo.OpcodeINSW        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INSW];
    LocalInfo.OpcodeOUTSB       = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTSB];
    LocalInfo.OpcodeOUTSW       = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTSW];
    LocalInfo.OpcodePUSHF       = ExVdmOpcodeDispatchCounts[VDM_INDEX_PUSHF];
    LocalInfo.OpcodePOPF        = ExVdmOpcodeDispatchCounts[VDM_INDEX_POPF];
    LocalInfo.OpcodeINTnn       = ExVdmOpcodeDispatchCounts[VDM_INDEX_INTnn];
    LocalInfo.OpcodeINTO        = ExVdmOpcodeDispatchCounts[VDM_INDEX_INTO];
    LocalInfo.OpcodeIRET        = ExVdmOpcodeDispatchCounts[VDM_INDEX_IRET];
    LocalInfo.OpcodeINBimm      = ExVdmOpcodeDispatchCounts[VDM_INDEX_INBimm];
    LocalInfo.OpcodeINWimm      = ExVdmOpcodeDispatchCounts[VDM_INDEX_INWimm];
    LocalInfo.OpcodeOUTBimm     = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTBimm];
    LocalInfo.OpcodeOUTWimm     = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTWimm];
    LocalInfo.OpcodeINB         = ExVdmOpcodeDispatchCounts[VDM_INDEX_INB];
    LocalInfo.OpcodeINW         = ExVdmOpcodeDispatchCounts[VDM_INDEX_INW];
    LocalInfo.OpcodeOUTB        = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTB];
    LocalInfo.OpcodeOUTW        = ExVdmOpcodeDispatchCounts[VDM_INDEX_OUTW];
    LocalInfo.OpcodeLOCKPrefix  = ExVdmOpcodeDispatchCounts[VDM_INDEX_LOCKPrefix];
    LocalInfo.OpcodeREPNEPrefix = ExVdmOpcodeDispatchCounts[VDM_INDEX_REPNEPrefix];
    LocalInfo.OpcodeREPPrefix   = ExVdmOpcodeDispatchCounts[VDM_INDEX_REPPrefix];
    LocalInfo.OpcodeHLT         = ExVdmOpcodeDispatchCounts[VDM_INDEX_HLT];
    LocalInfo.OpcodeCLI         = ExVdmOpcodeDispatchCounts[VDM_INDEX_CLI];
    LocalInfo.OpcodeSTI         = ExVdmOpcodeDispatchCounts[VDM_INDEX_STI];
    LocalInfo.BopCount          = VdmBopCount;
    LocalInfo.SegmentNotPresent = ExVdmSegmentNotPresent;

    RtlCopyMemory(Info,&LocalInfo,sizeof(LocalInfo));

    return STATUS_SUCCESS;
}
#endif

#if i386
NTSTATUS
ExpGetStackTraceInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;
    PRTL_PROCESS_BACKTRACES BackTraceInformation;
    PRTL_PROCESS_BACKTRACE_INFORMATION BackTraceInfo;
    PSTACK_TRACE_DATABASE DataBase;
    PRTL_STACK_TRACE_ENTRY p, *pp;
    ULONG RequiredLength, n;

    DataBase = RtlpAcquireStackTraceDataBase();

    if (DataBase == NULL) {
        return STATUS_UNSUCCESSFUL;
    }
    DataBase->DumpInProgress = TRUE;

    RtlpReleaseStackTraceDataBase();

    n = 0;
    RequiredLength = 0;
    Status = STATUS_INFO_LENGTH_MISMATCH;
    BackTraceInformation = (PRTL_PROCESS_BACKTRACES) SystemInformation;

    RequiredLength = FIELD_OFFSET( RTL_PROCESS_BACKTRACES, BackTraces );

    try {
        if (SystemInformationLength >= RequiredLength) {
            BackTraceInformation->CommittedMemory =
                (ULONG)DataBase->CurrentUpperCommitLimit - (ULONG)DataBase->CommitBase;
            BackTraceInformation->ReservedMemory =
                (ULONG)DataBase->EntryIndexArray - (ULONG)DataBase->CommitBase;
            BackTraceInformation->NumberOfBackTraceLookups = DataBase->NumberOfEntriesLookedUp;
            n = DataBase->NumberOfEntriesAdded;
            BackTraceInformation->NumberOfBackTraces = n;
        }

        RequiredLength += (sizeof( *BackTraceInfo ) * n);
        if (SystemInformationLength >= RequiredLength) {
            Status = STATUS_SUCCESS;
            BackTraceInfo = &BackTraceInformation->BackTraces[ 0 ];
            pp = DataBase->EntryIndexArray;
            while (n--) {
                p = *--pp;
                BackTraceInfo->SymbolicBackTrace = NULL;
                BackTraceInfo->TraceCount = p->TraceCount;
                BackTraceInfo->Index = p->Index;
                BackTraceInfo->Depth = p->Depth;
                RtlCopyMemory( BackTraceInfo->BackTrace,
                               p->BackTrace,
                               p->Depth * sizeof( PVOID )
                             );
                BackTraceInfo += 1;
            }
        }
    }
    finally {
        DataBase->DumpInProgress = FALSE;
    }

    if (ARGUMENT_PRESENT(ReturnLength)) {
        *ReturnLength = RequiredLength;
    }
    return Status;
}
#endif // i386

NTSTATUS
ExpGetLockInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )
/*++

Routine Description:

    This function returns information about all the ERESOURCE locks
    in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PRTL_PROCESS_LOCKS LockInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               KeGetPreviousMode(),
                               IoWriteAccess,
                               &LockInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    Status = STATUS_SUCCESS;

    MmLockPagableSectionByHandle (ExPageLockHandle);
    try {

        Status = ExQuerySystemLockInformation( LockInfo,
                                               SystemInformationLength,
                                               Length
                                             );
    }
    finally {
        ExUnlockUserBuffer( LockVariable );
        MmUnlockPagableImageSection(ExPageLockHandle);
    }

    return Status;
}

NTSTATUS
ExpGetLookasideInformation (
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG Length
    )

/*++

Routine Description:

    This function returns pool lookaside list and general lookaside
    list information.

Arguments:

    Buffer - Supplies a pointer to the buffer which receives the lookaside
        list information.

    BufferLength - Supplies the length of the information buffer in bytes.

    Length - Supplies a pointer to a variable that receives the length of
        lookaside information returned.

Environment:

    Kernel mode.

    This routine could be made PAGELK but it is a high frequency routine
    so it is actually better to keep it nonpaged to avoid bringing in the
    entire PAGELK section.

Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - Normal, successful completion.

        STATUS_ACCESS_VIOLATION - The buffer could not be locked in memory.

--*/

{

    PVOID BufferLock;
    PLIST_ENTRY Entry;
    KIRQL OldIrql;
    ULONG Limit;
    PSYSTEM_LOOKASIDE_INFORMATION Lookaside;
    ULONG Number;
    PNPAGED_LOOKASIDE_LIST NPagedLookaside;
    PPAGED_LOOKASIDE_LIST PagedLookaside;
    PGENERAL_LOOKASIDE PoolLookaside;
    PGENERAL_LOOKASIDE SystemLookaside;
    PKSPIN_LOCK SpinLock;
    NTSTATUS Status;

    //
    // Compute the number of lookaside entries and set the return status to
    // success.
    //

    Limit = BufferLength / sizeof(SYSTEM_LOOKASIDE_INFORMATION);
    Number = 0;
    Status = STATUS_SUCCESS;

    //
    // If the number of lookaside entries to return is not zero, then collect
    // the lookaside information.
    //

    if (Limit != 0) {
        Status = ExLockUserBuffer(Buffer,
                                  BufferLength,
                                  KeGetPreviousMode(),
                                  IoWriteAccess,
                                  &Lookaside,
                                  &BufferLock);
        if (NT_SUCCESS(Status)) {

            Status = STATUS_SUCCESS;

            //
            // Copy nonpaged and paged pool lookaside information to
            // information buffer.
            //

            Entry = ExPoolLookasideListHead.Flink;
            while (Entry != &ExPoolLookasideListHead) {
                PoolLookaside = CONTAINING_RECORD(Entry,
                                                  GENERAL_LOOKASIDE,
                                                  ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&PoolLookaside->ListHead);
                Lookaside->MaximumDepth = PoolLookaside->Depth;
                Lookaside->TotalAllocates = PoolLookaside->TotalAllocates;
                Lookaside->AllocateMisses =
                        PoolLookaside->TotalAllocates - PoolLookaside->AllocateHits;

                Lookaside->TotalFrees = PoolLookaside->TotalFrees;
                Lookaside->FreeMisses =
                        PoolLookaside->TotalFrees - PoolLookaside->FreeHits;

                Lookaside->Type = PoolLookaside->Type;
                Lookaside->Tag = PoolLookaside->Tag;
                Lookaside->Size = PoolLookaside->Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish2;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            //
            // Copy nonpaged and paged system lookaside information to
            // information buffer.
            //

            Entry = ExSystemLookasideListHead.Flink;
            while (Entry != &ExSystemLookasideListHead) {
                SystemLookaside = CONTAINING_RECORD(Entry,
                                                    GENERAL_LOOKASIDE,
                                                    ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&SystemLookaside->ListHead);
                Lookaside->MaximumDepth = SystemLookaside->Depth;
                Lookaside->TotalAllocates = SystemLookaside->TotalAllocates;
                Lookaside->AllocateMisses = SystemLookaside->AllocateMisses;
                Lookaside->TotalFrees = SystemLookaside->TotalFrees;
                Lookaside->FreeMisses = SystemLookaside->FreeMisses;
                Lookaside->Type = SystemLookaside->Type;
                Lookaside->Tag = SystemLookaside->Tag;
                Lookaside->Size = SystemLookaside->Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish2;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            //
            // Copy nonpaged general lookaside information to buffer.
            //

            SpinLock = &ExNPagedLookasideLock;
            ExAcquireSpinLock(SpinLock, &OldIrql);
            Entry = ExNPagedLookasideListHead.Flink;
            while (Entry != &ExNPagedLookasideListHead) {
                NPagedLookaside = CONTAINING_RECORD(Entry,
                                                    NPAGED_LOOKASIDE_LIST,
                                                    L.ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&NPagedLookaside->L.ListHead);
                Lookaside->MaximumDepth = NPagedLookaside->L.Depth;
                Lookaside->TotalAllocates = NPagedLookaside->L.TotalAllocates;
                Lookaside->AllocateMisses = NPagedLookaside->L.AllocateMisses;
                Lookaside->TotalFrees = NPagedLookaside->L.TotalFrees;
                Lookaside->FreeMisses = NPagedLookaside->L.FreeMisses;
                Lookaside->Type = 0;
                Lookaside->Tag = NPagedLookaside->L.Tag;
                Lookaside->Size = NPagedLookaside->L.Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish1;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

            ExReleaseSpinLock(SpinLock, OldIrql);

            //
            // Copy paged general lookaside information to buffer.
            //

            SpinLock = &ExPagedLookasideLock;
            ExAcquireSpinLock(SpinLock, &OldIrql);
            Entry = ExPagedLookasideListHead.Flink;
            while (Entry != &ExPagedLookasideListHead) {
                PagedLookaside = CONTAINING_RECORD(Entry,
                                                   PAGED_LOOKASIDE_LIST,
                                                   L.ListEntry);

                Lookaside->CurrentDepth = ExQueryDepthSList(&PagedLookaside->L.ListHead);
                Lookaside->MaximumDepth = PagedLookaside->L.Depth;
                Lookaside->TotalAllocates = PagedLookaside->L.TotalAllocates;
                Lookaside->AllocateMisses = PagedLookaside->L.AllocateMisses;
                Lookaside->TotalFrees = PagedLookaside->L.TotalFrees;
                Lookaside->FreeMisses = PagedLookaside->L.FreeMisses;
                Lookaside->Type = 1;
                Lookaside->Tag = PagedLookaside->L.Tag;
                Lookaside->Size = PagedLookaside->L.Size;
                Number += 1;
                if (Number == Limit) {
                    goto Finish1;
                }

                Entry = Entry->Flink;
                Lookaside += 1;
            }

Finish1:
            ExReleaseSpinLock(SpinLock, OldIrql);

Finish2:
            //
            // Unlock user buffer.
            //

            ExUnlockUserBuffer(BufferLock);
        }
    }

    *Length = Number * sizeof(SYSTEM_LOOKASIDE_INFORMATION);
    return Status;
}

NTSTATUS
ExpGetHandleInformation(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )
/*++

Routine Description:

    This function returns information about the open handles in the system.

Arguments:

    SystemInformation - A pointer to a buffer which receives the specified
        information.

    SystemInformationLength - Specifies the length in bytes of the system
        information buffer.

    Length - An optional pointer which, if specified, receives the
        number of bytes placed in the system information buffer.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_INFO_CLASS - The SystemInformationClass parameter
            did not specify a valid value.

        STATUS_INFO_LENGTH_MISMATCH - The value of the SystemInformationLength
            parameter did not match the length required for the information
            class requested by the SystemInformationClass parameter.

        STATUS_ACCESS_VIOLATION - Either the SystemInformation buffer pointer
            or the Length pointer value specified an invalid address.

        STATUS_WORKING_SET_QUOTA - The process does not have sufficient
            working set to lock the specified output structure in memory.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/

{
    PSYSTEM_HANDLE_INFORMATION HandleInfo;
    PVOID LockVariable;
    NTSTATUS Status;

    PAGED_CODE();

    *Length = 0;

    Status = ExLockUserBuffer( SystemInformation,
                               SystemInformationLength,
                               KeGetPreviousMode(),
                               IoWriteAccess,
                               &HandleInfo,
                               &LockVariable
                               );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {
        Status = ObGetHandleInformation( HandleInfo,
                                         SystemInformationLength,
                                         Length
                                       );

    }
    finally {
        ExUnlockUserBuffer( LockVariable );
    }

    return Status;
}

NTSTATUS
ExpGetHandleInformationEx(
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG Length
    )
/*++

Routine Description:

    This function returns information about the open handles in the syst