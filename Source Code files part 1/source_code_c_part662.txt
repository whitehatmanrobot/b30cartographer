 PsReqBuffer->BytesReadOrWritten = BytesReadOrWritten;
    PsReqBuffer->BytesNeeded = BytesNeeded;
    PsReqBuffer->LocalCompletionFunc = CompletionFunc;

    InterlockedIncrement(&Adapter->OutstandingNdisRequests);

    if(!PsReqBuffer->LocalRequest && Adapter->PTDeviceState != NdisDeviceStateD0)
    {
        // It's not a local request, and the device is off. So, we pend this request.

        PsAssert(!VcHandle);

        PsAssert(Adapter->PendedNdisRequest == 0);

        Adapter->PendedNdisRequest = PsReqBuffer;

        return NDIS_STATUS_PENDING;
    }

    if(VcHandle) 
    {
        Status = NdisCoRequest(
                    Adapter->LowerMpHandle,
                    NULL,
                    VcHandle,
                    NULL,
                    (PNDIS_REQUEST) PsReqBuffer);

        if(Status != NDIS_STATUS_PENDING) {

            WanCoRequestComplete(Status, Adapter, NULL, NULL, (PNDIS_REQUEST)PsReqBuffer);

        }
    }
    else 
    {
        NdisRequest(&Status, Adapter->LowerMpHandle, (PNDIS_REQUEST)PsReqBuffer);


        if(Status != NDIS_STATUS_PENDING){
    
            ClRequestComplete((NDIS_HANDLE)Adapter, 
                              (PNDIS_REQUEST)PsReqBuffer, 
                              Status);
    
        }
    }

    return NDIS_STATUS_PENDING;
} // MakeNdisRequest


VOID
ClRequestComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_REQUEST   NdisRequest,
    IN  NDIS_STATUS     Status
    )

/*++

Routine Description:

    Completion routine for NdisRequest. Stuff our block back on the lookaside
    list and call the appropriate completion routine

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;
    PPS_NDIS_REQUEST PsReqBuffer;
    NDIS_OID Oid;
    ULONG SpaceAvailable;
    PUCHAR DataStart;
    ULONG Len;
    ULONG i;
    PVOID Data;
    NDIS_STATUS OriStatus = Status;

    PsReqBuffer = CONTAINING_RECORD( NdisRequest, PS_NDIS_REQUEST, ReqBuffer );

    PsStructAssert(Adapter);

    switch(NdisRequest->RequestType)
    {
      case NdisRequestQueryInformation:
          *PsReqBuffer->BytesReadOrWritten = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.BytesWritten;
          *PsReqBuffer->BytesNeeded = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.BytesNeeded;
          Oid = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.Oid;
          Len = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBufferLength;
          Data = PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer;

          //
          // Process the Query only OIDs here
          //
          switch(Oid)
          {
            case OID_GEN_MAXIMUM_SEND_PACKETS:
                
                //
                // see if the underlying MP supports NdisSendPackets. 
                // if not, fake it by saying we support one.
                //
          
                if(Status != NDIS_STATUS_SUCCESS)
                {
                    if(Status == NDIS_STATUS_BUFFER_TOO_SHORT ||
                       Status == NDIS_STATUS_INVALID_LENGTH) 
                    {
                        // 
                        // The underlying MP has indicated that the buffer
                        // is too short. We can assume that it supports this
                        // OID.
                    }
                    else 
                    {
                        if(Len >= 1) 
                        {
                            //
                            // The underlying MP does not support NdisSendPackets
                            // We fake it here.
                            //
                            
                            *((PULONG)PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer)= 1;
                            *PsReqBuffer->BytesNeeded = 0;
                            *PsReqBuffer->BytesReadOrWritten = 1;
                            
                            Status = NDIS_STATUS_SUCCESS;
                        }
                        else 
                        {
                            //
                            // Buffer too short even to fake!
                            //
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                            *PsReqBuffer->BytesNeeded = 1;
                            *PsReqBuffer->BytesReadOrWritten = 0;
                        }
                    }
                }
                break;

            case OID_GEN_MAC_OPTIONS:
          
                //
                // if querying mac options, add full dux option.
                //
                if(Status == NDIS_STATUS_SUCCESS)
                {
                    *((PULONG)PsReqBuffer->
                      ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer) |=
                        NDIS_MAC_OPTION_FULL_DUPLEX;

                    //
                    // Remove the no-loopback bit from mac-options. In essence we are telling NDIS that we can handle loopback.
                    // We don't, but the interface below us does. If we do not do this, then the loopback processing happens below
                    // us and above us. This is wasteful at best and if netmon is running multiple packets are seen below us.
                    //
                    *(PULONG)Data &= ~NDIS_MAC_OPTION_NO_LOOPBACK;
                }
                break;
                
            case OID_GEN_CO_VENDOR_DESCRIPTION:
                
                //
                // We append some keyword to the end of the Driver
                // Description to indicate that packet scheduler is 
                // installed on this interface.
                //
                // Assume that the Data is a string followed by a 0
                // character, and the 0 is accounted for in the 
                // len.
                //
                
                if(Status == NDIS_STATUS_BUFFER_TOO_SHORT ||
                   Status == NDIS_STATUS_INVALID_LENGTH) 
                {
                    *PsReqBuffer->BytesReadOrWritten = 0;
                    *PsReqBuffer->BytesNeeded += 
                        sizeof(gDriverDescription);
                }
                else 
                {
                    if(Status == NDIS_STATUS_SUCCESS)
                    {
                        //
                        // Setup the data pointer and length to copy the 
                        // descrption into the information buffer 
                        // passed to us.
                        //
                        if(Len >= 
                         NdisRequest->DATA.QUERY_INFORMATION.BytesWritten +
                           sizeof(gDriverDescription))
                        {
                            PCHAR DescStr;
                            LONG Written = (LONG) 
                                NdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
                            int i;
                            
                            
                            //
                            // Copy the original string, excluding the '0' 
                            // character
                            //
                            for(i=0, DescStr = (PCHAR) Data; 
                                (*DescStr != 0) && (i < Written); DescStr++, i++)
                                ;
                            *PsReqBuffer->BytesReadOrWritten = i;
                            
                            //
                            // Append the new string
                            //
                          for(i=0; i < sizeof(gDriverDescription); i++) 
                          {
                              *DescStr++ = gDriverDescription[i];
                          }
                          *PsReqBuffer->BytesReadOrWritten += 
                              sizeof(gDriverDescription);
                          
                          *PsReqBuffer->BytesNeeded = 0;
                        }
                        else
                        {
                            *PsReqBuffer->BytesNeeded =
                                NdisRequest->DATA.QUERY_INFORMATION.BytesWritten +
                                sizeof(gDriverDescription);
                            *PsReqBuffer->BytesReadOrWritten = 0;
                            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                        }
                    }
                    else {
                        //
                        // Upper layer failed for some reason.
                        // We can still proceed to write the data
                        //
                        if(Len >= sizeof(gDriverDescription))
                        {
                            PCHAR DescStr = (PCHAR) Data;
                            int i;
                            for(i=0; i < sizeof(gDriverDescription); i++) 
                            {
                                *DescStr++ = gDriverDescription[i];
                            }
                            
                            *PsReqBuffer->BytesReadOrWritten =
                                sizeof(gDriverDescription);
                            
                            *PsReqBuffer->BytesNeeded = 0;
                            
                            Status = NDIS_STATUS_SUCCESS;
                        }
                        else {
                            *PsReqBuffer->BytesNeeded = 
                                sizeof(gDriverDescription);
                            *PsReqBuffer->BytesReadOrWritten = 0;
                          Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                        }
                    }
                }
                break;

            case OID_PNP_CAPABILITIES:
                if(Status == NDIS_STATUS_SUCCESS) 
                {
                    MpQueryPnPCapabilities(PsReqBuffer, Adapter, &Status);
                }
                break;
                
            case OID_PNP_QUERY_POWER:
                PsAssert(0);
                break;
                
                
            default:
                break;
          }
          break;

      case NdisRequestSetInformation:
          
          *PsReqBuffer->BytesReadOrWritten = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.BytesRead;
          *PsReqBuffer->BytesNeeded = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.BytesNeeded;
          Oid = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.Oid;
          Len = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.InformationBufferLength;
          Data = PsReqBuffer->ReqBuffer.DATA.SET_INFORMATION.InformationBuffer;
          
          //
          // Process the "Set Only" OIDs here
          //
          switch(Oid) 
          {
            case OID_WAN_PROTOCOL_TYPE:
            {
                if(Adapter->MediaType == NdisMediumWan)
                {
                    if (Len > 5) 
                    {
                        Adapter->ProtocolType =
                            (((PUCHAR)Data)[4] << 8) |
                            ((PUCHAR)Data)[5];
                        
                    } 
                }

                break;
            }

            case OID_GEN_TRANSPORT_HEADER_OFFSET:
            {    
                if(Len >= sizeof(TRANSPORT_HEADER_OFFSET) )
                {
                    PTRANSPORT_HEADER_OFFSET pTh = (PTRANSPORT_HEADER_OFFSET) Data;
                
                    if(pTh->ProtocolType == NDIS_PROTOCOL_ID_TCP_IP) 
                    { 
                        Adapter->IPHeaderOffset = pTh->HeaderOffset;
                    }
                }
                else
                {
                    Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                    *PsReqBuffer->BytesReadOrWritten = 0;
                    *PsReqBuffer->BytesNeeded = sizeof(TRANSPORT_HEADER_OFFSET);
                }
                
                break;
            }
            
              

            case OID_GEN_NETWORK_LAYER_ADDRESSES:
                
                //
                // Updated network addresses from a transport. 
                //
                Status = RecordNetworkAddressList(Adapter, PsReqBuffer);

                //
                // Queue a work item to update the Interface ID
                //

                PsScheduleInterfaceIdWorkItem(Adapter, 0);
                
                //
                // Do a status indication to show that the list has
                // changed.
                //
                
                TcIndicateInterfaceChange(Adapter, 0, NDIS_STATUS_INTERFACE_CHANGE);
                
                break;
                
            case OID_PNP_SET_POWER:
                PsAssert(0);
                break;
                
            default:
                break;
          }
          break;

      case NdisRequestLocalQueryInfo:
          break;

      default:

          PsAssert(0);
          break;
    }

#if DBG
    switch(Oid)
    {
      case OID_GEN_MEDIA_CONNECT_STATUS:
          
          PsDbgOid(DBG_TRACE, 
                   DBG_ROUTINEOIDS, 
                   (PsReqBuffer->ReqBuffer.RequestType == NdisRequestSetInformation) 
                   ? TRACE_OID_SET_REQUEST_COMPLETE: TRACE_OID_QUERY_REQUEST_COMPLETE,
                   PsReqBuffer->LocalRequest ? 1:0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   OriStatus);
          break;
          
      default:
          PsDbgOid(DBG_TRACE, 
                   DBG_PROTOCOL, 
                   (PsReqBuffer->ReqBuffer.RequestType == NdisRequestSetInformation) 
                   ? TRACE_OID_SET_REQUEST_COMPLETE: TRACE_OID_QUERY_REQUEST_COMPLETE,
                   PsReqBuffer->LocalRequest ? 1:0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   OriStatus);
          break;
    }
#endif

    //
    // if the caller specified a local completion function, then call it now.
    // this function is responsible for completing the original request
    //
    
    if(PsReqBuffer->LocalCompletionFunc){

        (*PsReqBuffer->LocalCompletionFunc)(Adapter, Status);
        PsFreePool(PsReqBuffer->BytesReadOrWritten);
        PsFreePool(PsReqBuffer->BytesNeeded);
    } 
    else{
        
        //
        // if this was a PS originated request and no local completion 
        // function was specified, then set the event to indicate that 
        // the request completed. Note that the event can only be used 
        // at lowered IRQL.
        //
        if(PsReqBuffer->LocalRequest)
        {
            Adapter->FinalStatus = Status;
            NdisSetEvent( &Adapter->LocalRequestEvent);
            PsFreePool(PsReqBuffer->BytesReadOrWritten);
            PsFreePool(PsReqBuffer->BytesNeeded);
        } 
        else{

            Adapter->PendedNdisRequest = 0;

            //
            // if this is not a local request, call the 
            // appropriate NDIS completion routine
            //
            if(NdisRequest->RequestType == NdisRequestSetInformation)
            {
                NdisMSetInformationComplete(Adapter->PsNdisHandle, Status); 
            }
            else 
            {
                NdisMQueryInformationComplete(Adapter->PsNdisHandle, Status);
            }
        }
    }

    InterlockedDecrement(&Adapter->OutstandingNdisRequests);

    //
    // give back our ndis request buffer
    //

    PsFreeToLL(PsReqBuffer, &NdisRequestLL, NdisRequest);

    
} // ClRequestComplete



NDIS_STATUS
MakeLocalNdisRequest(
    PADAPTER Adapter,
    NDIS_HANDLE VcHandle,
    NDIS_REQUEST_TYPE RequestType,
    NDIS_OID Oid,
    PVOID Buffer,
    ULONG BufferSize,
    LOCAL_NDISREQUEST_COMPLETION_FUNCTION CompletionFunc OPTIONAL
    )

/*++

Routine Description:

    Make an NdisRequest to the underlying adapter on behalf of the packet scheduler

Arguments:

    Adapter and Oid should be obvious

    Buffer, BufferSize - pointer to and size of location that receives the info

    CompletionFunc - if non-null, then don't wait on the adapter's event. Used when we're
        running at dispatch level

Return Value:

    Standard NDIS_STATUS from an NdisRequest

--*/

{
    NDIS_STATUS Status;
    PULONG BytesRead, BytesNeeded;

    
    PsAssert(RequestType == NdisRequestLocalQueryInfo || RequestType == NdisRequestLocalSetInfo);

    //
    // Need to allocate space for BytesWritten & BytesNeeded because 
    // we wait only for requests that do not have a Completion Function
    // Hence the Completion function could be writing to a stale stack
    // variable
    //

    PsAllocatePool(BytesNeeded, sizeof(ULONG), PsMiscTag);

    if(!BytesNeeded) 
    {
        return NDIS_STATUS_RESOURCES;
    }

    PsAllocatePool(BytesRead,   sizeof(ULONG), PsMiscTag);

    if(!BytesRead)
    {
        PsFreePool(BytesNeeded);

        return NDIS_STATUS_RESOURCES;
    }

    Status = MakeNdisRequest(Adapter,
                             VcHandle,
                             RequestType,
                             Oid,
                             Buffer,
                             BufferSize,
                             BytesRead,
                             BytesNeeded,
                             CompletionFunc);

    //
    // only wait if no completion function has been specified
    //

    if ( !ARGUMENT_PRESENT( CompletionFunc ) && 
         Status == NDIS_STATUS_PENDING ) {

        NdisWaitEvent( &Adapter->LocalRequestEvent, 0 );
        NdisResetEvent( &Adapter->LocalRequestEvent );
        Status = Adapter->FinalStatus;
    }

    return Status;

} // MakeLocalNdisRequest


NDIS_STATUS
MpQueryInformation(
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesWritten,
    OUT PULONG      BytesNeeded
)
{

    PADAPTER Adapter = (PADAPTER) MiniportAdapterContext;
    PVOID    Data    = InformationBuffer;
    ULONG    Len     = InformationBufferLength;

    PsStructAssert(Adapter);

    PsAssert(Adapter->PsMpState != AdapterStateWaiting);

#if DBG
    switch(Oid)
    {
      case OID_GEN_MEDIA_CONNECT_STATUS:
          
          PsDbgOid(DBG_TRACE, 
                   DBG_ROUTINEOIDS, 
                   TRACE_OID_MP_QUERYINFORMATION,
                   0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   0);
          break;
          
      default:
          PsDbgOid(DBG_TRACE, 
                   DBG_MINIPORT, 
                   TRACE_OID_MP_QUERYINFORMATION,
                   0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   0);
          break;
    }
#endif

    if(Oid == OID_PNP_QUERY_POWER)
    {
        return NDIS_STATUS_SUCCESS;
    }

    if (Oid == OID_GEN_SUPPORTED_GUIDS)
    {
        //
        //  Do not forward this OID, otherwise we will end up with multiple
        //  WMI instances of private GUIDs that the underlying miniport
        //  supports.
        //
        return NDIS_STATUS_NOT_SUPPORTED;
    }

    if(Adapter->StandingBy == TRUE                    || 
       Adapter->PsMpState != AdapterStateRunning      ||
       Adapter->MPDeviceState != NdisDeviceStateD0)
    {
        return NDIS_STATUS_FAILURE;
    }

    switch(Oid)
    {
      case OID_GEN_CO_DRIVER_VERSION:
          //
          // The NDIS version in use by the NIC driver. The high byte is
          // the major version number and the low byte is the minor
          // version number. We don't need to pass this down - 
          // Irrespective of what version the driver below  uses, we 
          // need to return the version that we support.
          //
          
          if(Len < sizeof(USHORT)) 
          {
              *BytesNeeded = sizeof(USHORT);
              
              return NDIS_STATUS_BUFFER_TOO_SHORT;
              
          }
          else 
          {
              PUSHORT pData = (PUSHORT) Data;
              
              *pData = 0x0500;
              
              *BytesWritten = sizeof(USHORT);
              
              return NDIS_STATUS_SUCCESS;
          }

          break;
/*
      case OID_GEN_MAC_OPTIONS:
          //
	  // This is to indicate to NDIS that PSched always indicates recv-up in the same context
	  // of its recv-from or at DPC
          //
          
          if(Len < sizeof(ULONG)) 
          {
              *BytesNeeded = sizeof(ULONG);
              
              return NDIS_STATUS_BUFFER_TOO_SHORT;
              
          }
          else 
          {
              PULONG pData = (PULONG) Data;
              
              *pData |=  NDIS_MAC_OPTION_RECEIVE_AT_DPC;
              
              *BytesWritten = sizeof(ULONG);
              
              return NDIS_STATUS_SUCCESS;
          }

          break;

      case OID_GEN_PROTOCOL_OPTIONS:
          //
	  // This is to indicate to NDIS that PSched always sends-down packets in the same context as the
	  // send-from-above came from or at IRQL = DPC
          //
          
          if(Len < sizeof(ULONG)) 
          {
              *BytesNeeded = sizeof(ULONG);
              
              return NDIS_STATUS_BUFFER_TOO_SHORT;
              
          }
          else 
          {
              PULONG pData = (PULONG) Data;
              
              *pData |= NDIS_PROT_OPTION_SEND_RESTRICTED;
              
              *BytesWritten = sizeof(ULONG);
              
              return NDIS_STATUS_SUCCESS;
          }

          break;
*/
    }

    //
    // By default, send other requests down.
    //

    return  MakeNdisRequest(Adapter,
                            NULL,
                            NdisRequestQueryInformation,
                            Oid,
                            Data,
                            Len,
                            BytesWritten,
                            BytesNeeded,
                            NULL);
}
   

NDIS_STATUS
MpSetInformation( 
    IN  NDIS_HANDLE MiniportAdapterContext,
    IN  NDIS_OID    Oid,
    IN  PVOID       InformationBuffer,
    IN  ULONG       InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
)
{
    PADAPTER    Adapter = (PADAPTER) MiniportAdapterContext;
    NDIS_STATUS Status;

    PsStructAssert(Adapter);
    PsAssert(Adapter->PsMpState != AdapterStateWaiting);

#if DBG
    switch(Oid)
    {
      case OID_GEN_MEDIA_CONNECT_STATUS:
          
          PsDbgOid(DBG_TRACE, 
                   DBG_ROUTINEOIDS, 
                   TRACE_OID_MP_SETINFORMATION,
                   0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   0);
          break;
          
      default:
          PsDbgOid(DBG_TRACE, 
                   DBG_MINIPORT, 
                   TRACE_OID_MP_SETINFORMATION,
                   0,
                   Adapter->PTDeviceState,
                   Adapter->MPDeviceState,
                   Adapter,
                   Oid,
                   0);
          break;
    }
#endif

    switch(Oid) 
    {
      case OID_PNP_SET_POWER:
          
          //
          // This is not transparent to us - We cannot send it down. 
          // Just succeed it!
          //
          if(InformationBufferLength >= sizeof(NDIS_DEVICE_POWER_STATE))
          {
              NDIS_DEVICE_POWER_STATE NewDeviceState = 
                  (*(PNDIS_DEVICE_POWER_STATE) InformationBuffer);
             
              //
              // If the miniport is transitioning from a low power state to ON (D0), then clear the StandingBy flag
              // All incoming requests will be pended until the physical miniport turns ON.
              //
 
              if(Adapter->MPDeviceState > NdisDeviceStateD0 && NewDeviceState == NdisDeviceStateD0)
              {
                  Adapter->StandingBy = FALSE;
              }

              //
              // Is the miniport transitioning from an On (D0) state to an Low Power State (>D0)
              // If so, then set the StandingBy Flag - (Block all incoming requests)
              //
    
              if(Adapter->MPDeviceState == NdisDeviceStateD0 && NewDeviceState > NdisDeviceStateD0)
              {
                  Adapter->StandingBy = TRUE;
              }

              // update the new device state.
              
              Adapter->MPDeviceState = NewDeviceState;
              Status                 = NDIS_STATUS_SUCCESS;
              *BytesRead             = sizeof(NDIS_DEVICE_POWER_STATE);
              *BytesNeeded           = 0;

              if(IsDeviceStateOn(Adapter) == TRUE)
              {
                  PsGetLinkSpeed(Adapter);
              }
          }
          else
          {
              Status       = NDIS_STATUS_INVALID_LENGTH;
              *BytesRead   = 0;
              *BytesNeeded = sizeof(NDIS_DEVICE_POWER_STATE);
          }
          
          return Status;
    }

    if(Adapter->StandingBy == TRUE                    || 
       Adapter->PsMpState != AdapterStateRunning      ||
       Adapter->MPDeviceState != NdisDeviceStateD0)
    {
        return NDIS_STATUS_FAILURE;
    }

    Status = MakeNdisRequest(Adapter,
                             NULL,
                             NdisRequestSetInformation,
                             Oid,
                             InformationBuffer,
                             InformationBufferLength,
                             BytesRead,
                             BytesNeeded,
                             NULL);

    return Status;
}


NDIS_STATUS
CollectNetworkAddresses(
    IN PADAPTER Adapter,
    IN OUT ULONG    *Len,
    IN PVOID    Data
    )
{
    ULONG                                 RequiredBufferSize = 0;
    ULONG                                 RequiredIpBufferSize;
    ULONG                                 RequiredIpxBufferSize;
    NETWORK_ADDRESS_LIST       UNALIGNED *NetworkAddressList;
    PTC_SUPPORTED_INFO_BUFFER             TcQueryBuffer;
    PADDRESS_LIST_DESCRIPTOR              AddressDescriptorList;
    PUCHAR                                AddressListIndex;
    NDIS_STATUS                           Status;
    NDIS_STRING                           Prefix = NDIS_STRING_CONST("\\Device\\");

    //
    // Ip address list
    //    

    PS_LOCK(&Adapter->Lock);

    if(Adapter->IpNetAddressList){

        RequiredIpBufferSize = GetSizeAddrList(Adapter->IpNetAddressList);

        //
        // Returned buffer size actually includes extra bytes for
        // address count and type. But - when we merge the lists,
        // we'll replace the separate fields. So - subtract them out.
        //

        RequiredIpBufferSize -= FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);
    }
    else{
    
        RequiredIpBufferSize = 0;
    }

    RequiredBufferSize += RequiredIpBufferSize;

    //
    // Add space for the Ipx address list
    //

    if(Adapter->IpxNetAddressList){
     
        RequiredIpxBufferSize = GetSizeAddrList(Adapter->IpxNetAddressList);

        //
        // Returned buffer size actually includes extra bytes for
        // address count and type. But - when we merge the lists,
        // we'll replace the separate fields. So - subtract them out.
        //

        RequiredIpxBufferSize -= FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);
    }
    else{

        RequiredIpxBufferSize = 0;
    }

    RequiredBufferSize += RequiredIpxBufferSize;

    //
    // Add space for the address list fields
    //

    RequiredBufferSize += FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);

    //
    // Add space for TC_SUPPORTED_INFO_BUFFER
    //
    RequiredBufferSize = RequiredBufferSize + 
        FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc) +
        FIELD_OFFSET(ADDRESS_LIST_DESCRIPTOR, AddressList);

    if(*Len > 0){

        NdisZeroMemory(Data, *Len);
    }

    if(*Len >= RequiredBufferSize){

        TcQueryBuffer = (PTC_SUPPORTED_INFO_BUFFER) Data;

        //
        // Fill in the upper binding, after striping the device 
        //
        NdisMoveMemory(TcQueryBuffer->InstanceID,
                       (PUCHAR) Adapter->MpDeviceName.Buffer + 
                       Prefix.Length,
                       Adapter->MpDeviceName.Length - Prefix.Length);
       
        TcQueryBuffer->InstanceIDLength = Adapter->MpDeviceName.Length - Prefix.Length;


        //
        // Fill in the AddressListDescriptor
        //
        AddressDescriptorList = &TcQueryBuffer->AddrListDesc;

        AddressDescriptorList->MediaType = Adapter->MediaType;

        NetworkAddressList = (NETWORK_ADDRESS_LIST UNALIGNED *)
            &AddressDescriptorList->AddressList;

        AddressListIndex = (PUCHAR)&NetworkAddressList->Address;

        if(RequiredIpBufferSize){

            NdisMoveMemory(
                AddressListIndex,
                (PUCHAR)(&Adapter->IpNetAddressList->Address),
                RequiredIpBufferSize
                );

        }

        AddressListIndex += RequiredIpBufferSize;

        if(RequiredIpxBufferSize){

            NdisMoveMemory(
                AddressListIndex,
                (PUCHAR)(&Adapter->IpxNetAddressList->Address),
                RequiredIpxBufferSize
                );
        }

        AddressListIndex += RequiredIpxBufferSize;

        if(RequiredIpBufferSize){

            NetworkAddressList->AddressCount = 
                Adapter->IpNetAddressList->AddressCount;
        }

        if(RequiredIpxBufferSize){

            NetworkAddressList->AddressCount +=
                Adapter->IpxNetAddressList->AddressCount;
        }

        NetworkAddressList->AddressType = 0;

        *Len = RequiredBufferSize;

        Status = NDIS_STATUS_SUCCESS;
    }
    else{

        *Len = RequiredBufferSize;

        Status = NDIS_STATUS_BUFFER_TOO_SHORT;
    }

    PS_UNLOCK(&Adapter->Lock);

    return(Status);
}

NDIS_STATUS
CollectWanNetworkAddresses(
    IN PADAPTER Adapter,
    IN PPS_WAN_LINK WanLink,
    IN OUT ULONG *Len,
    IN PVOID Data
    )
{
    ULONG                                RequiredBufferSize = 0;
    NETWORK_ADDRESS_LIST      UNALIGNED *NetworkAddressList;
    NETWORK_ADDRESS           UNALIGNED *NetworkAddress;
    PTC_SUPPORTED_INFO_BUFFER            TcQueryBuffer;
    PADDRESS_LIST_DESCRIPTOR             AddressDescriptorList;
    NETWORK_ADDRESS_IP        UNALIGNED *pIp;
    NDIS_STATUS                          Status;
    NDIS_STRING                          Prefix = NDIS_STRING_CONST("\\Device\\");

    PsAssert(Adapter->MediaType == NdisMediumWan);

    //
    // Ip address list
    //    

    switch(WanLink->ProtocolType)
    {

      case PROTOCOL_IP:

          if(WanLink->DialUsage == DU_CALLOUT) {

              RequiredBufferSize = FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
                  (FIELD_OFFSET(NETWORK_ADDRESS, Address) + NETWORK_ADDRESS_LENGTH_IP);
          }
          else {

              //
              // Include room for a pair of addresses (one local, one remote). Only for Dial in
              // or router-router links.
              //

              RequiredBufferSize = FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
                  2 * (FIELD_OFFSET(NETWORK_ADDRESS, Address) + 
                       NETWORK_ADDRESS_LENGTH_IP);
          }

          break;

      case PROTOCOL_IPX:
          
          //
          // Not yet supported.
          //

      default:
          
        RequiredBufferSize = 0;
    }    
    
    //
    // Add space for TC_SUPPORTED_INFO_BUFFER
    //

    RequiredBufferSize = RequiredBufferSize + 
        FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc) +
        FIELD_OFFSET(ADDRESS_LIST_DESCRIPTOR, AddressList);

    if(*Len >= RequiredBufferSize) 
    {
        TcQueryBuffer = (PTC_SUPPORTED_INFO_BUFFER) Data;

        //
        // Fill in the device name 
        //
        if(WanLink->MpDeviceName.Length > Prefix.Length)
        {
            NdisMoveMemory(TcQueryBuffer->InstanceID,
                           (PUCHAR) WanLink->MpDeviceName.Buffer + Prefix.Length,
                           WanLink->MpDeviceName.MaximumLength - Prefix.Length);
       
            TcQueryBuffer->InstanceIDLength = WanLink->MpDeviceName.Length - Prefix.Length;
        }
        else
        {
            //
            // We have got a MpDevice name that is less than \Device. What is the point in
            // stripping the \Device from this ??
            //

            PsDbgOut(DBG_FAILURE,
                     DBG_WAN,
                     ("[CollectWanNetworkAddresses]: WanLink %08X, MpDeviceName is too small to strip \\Device \n", 
                      WanLink));

            NdisMoveMemory(TcQueryBuffer->InstanceID,
                           WanLink->MpDeviceName.Buffer,
                           WanLink->MpDeviceName.MaximumLength);

            TcQueryBuffer->InstanceIDLength = WanLink->MpDeviceName.Length;

        }

        //
        // Fill in the AddressListDescriptor
        //
        AddressDescriptorList = &TcQueryBuffer->AddrListDesc;

        AddressDescriptorList->MediaType = NdisMediumWan;

        NetworkAddressList = (NETWORK_ADDRESS_LIST UNALIGNED *)
            &AddressDescriptorList->AddressList;

        NetworkAddress = (NETWORK_ADDRESS UNALIGNED *)&NetworkAddressList->Address;

        switch(WanLink->ProtocolType){

        case PROTOCOL_IP:

            NetworkAddressList->AddressType = NDIS_PROTOCOL_ID_TCP_IP;

            //
            // Fill in the local address
            //
            NetworkAddressList->AddressCount = 1;
            NetworkAddress->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
            NetworkAddress->AddressLength = NETWORK_ADDRESS_LENGTH_IP;
            pIp = (NETWORK_ADDRESS_IP UNALIGNED *)NetworkAddress->Address;
            pIp->in_addr = WanLink->LocalIpAddress;
           
            //
            // Fill in the remote address only for non callout 
            //

            if(WanLink->DialUsage != DU_CALLOUT) {

                NetworkAddressList->AddressCount ++;

                NetworkAddress = (NETWORK_ADDRESS UNALIGNED *)
                    ((PCHAR)NetworkAddress + 
                     (FIELD_OFFSET(NETWORK_ADDRESS,Address)+ NETWORK_ADDRESS_LENGTH_IP));

                NetworkAddress->AddressLength = NETWORK_ADDRESS_LENGTH_IP;
                NetworkAddress->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
                pIp = (NETWORK_ADDRESS_IP UNALIGNED *)NetworkAddress->Address;
                pIp->in_addr = WanLink->RemoteIpAddress;
            }

            break;

        case PROTOCOL_IPX:
        default:

            //
            // Not supported, return zero addresses.
            //

            NetworkAddressList->AddressCount = 0;
        }

        *Len = RequiredBufferSize;

        Status = NDIS_STATUS_SUCCESS;
    }
    else{

        *Len = RequiredBufferSize;

        Status = NDIS_STATUS_BUFFER_TOO_SHORT;
    }

    return(Status);
}

NDIS_STATUS
RecordNetworkAddressList(
    IN PADAPTER Adapter,
    IN PPS_NDIS_REQUEST PsReqBuffer
    )
{
    NETWORK_ADDRESS_LIST  UNALIGNED *AddressList, **pListDestination;
    ULONG NewListSize;
    ULONG OldListSize;

    PS_LOCK(&Adapter->Lock);

    AddressList = (NETWORK_ADDRESS_LIST UNALIGNED *)(PsReqBuffer->ReqBuffer.
                                DATA.SET_INFORMATION.InformationBuffer);

    //
    // Handle special case of a zero count address list. This means
    // that the protocol is clearing the address list.
    //

    if(!AddressList->AddressCount){

        //
        // In this case, we use the top level AddressType to
        // indicate the protocol.
        //

        switch(AddressList->AddressType){

        case NDIS_PROTOCOL_ID_TCP_IP:

            pListDestination = &Adapter->IpNetAddressList;
            break;

        case NDIS_PROTOCOL_ID_IPX:

            pListDestination = &Adapter->IpxNetAddressList;
            break;

        default:

            //
            // Only maintain IP and IPX addresses for now
            //
            PS_UNLOCK(&Adapter->Lock);

            return NDIS_STATUS_NOT_SUPPORTED;
        }

        (*pListDestination)->AddressType = AddressList->AddressType;
        (*pListDestination)->AddressCount = 0;

        PS_UNLOCK(&Adapter->Lock);

        return(NDIS_STATUS_SUCCESS);
    }

    //
    // We can tell from the first address type ifdentifier, whether
    // this buffer carries addresses from the IP transport or the
    // IPX transport.
    //

    switch(AddressList->Address[0].AddressType){

    case NDIS_PROTOCOL_ID_TCP_IP:

        pListDestination = &Adapter->IpNetAddressList;
        break;

    case NDIS_PROTOCOL_ID_IPX:

        pListDestination = &Adapter->IpxNetAddressList;
        break;

    default:

        //
        // Only maintain IP and IPX addresses for now
        //

        PS_UNLOCK(&Adapter->Lock);
        return NDIS_STATUS_NOT_SUPPORTED;
    }

    NewListSize = GetSizeAddrList(AddressList);
    OldListSize = GetSizeAddrList(*pListDestination);

    if(NewListSize > OldListSize){

        // 
        // Then we need a new buffer. Free the old one.
        //
        
        PsFreePool(*pListDestination);

        PsAllocatePool(*pListDestination,
                       NewListSize,
                       PsMiscTag);

        if(0 == *pListDestination)
        {
            PsDbgOut(DBG_CRITICAL_ERROR,
                     DBG_PROTOCOL,
                     ("[RecordNetworkAddressList]: Adapter %08X, "
                      "No room for Network addresses list, failed to allocate %d bytes \n",
                      Adapter, NewListSize));

            PS_UNLOCK(&Adapter->Lock);
            PsAdapterWriteEventLog(
                (ULONG)EVENT_PS_NETWORK_ADDRESS_FAIL,
                0,
                &Adapter->MpDeviceName,
                0,
                NULL);

            return NDIS_STATUS_RESOURCES;
        }
    }

    NdisMoveMemory(*pListDestination,
                   AddressList,
                   NewListSize);

    PS_UNLOCK(&Adapter->Lock);

    return NDIS_STATUS_SUCCESS;
}

ULONG
GetSizeAddrList(
    IN NETWORK_ADDRESS_LIST UNALIGNED *AddrList
    )
{
    NETWORK_ADDRESS UNALIGNED *NextAddress;
    LONG i;
    ULONG ListSize = 0;
    ULONG ElementSize = 0;

    if(!AddrList->AddressCount){

        return(FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address));
    }

    NextAddress = &(AddrList->Address[0]);

    for(i = 0;i < AddrList->AddressCount; i++){

        // 
        // Each address element is the number of bytes
        // indicated by AddressLength plus the size of
        // a NETWORK_ADDRESS structure, minus the one 
        // byte used for the adress array (see struct).
        //

        ElementSize = FIELD_OFFSET(NETWORK_ADDRESS, Address);
        ElementSize += NextAddress->AddressLength;

        ListSize += ElementSize;

        NextAddress = (NETWORK_ADDRESS UNALIGNED *)
                    ((PUCHAR)NextAddress + ElementSize);

        ElementSize = 0;
    }

    //
    // Add the AddressCount size
    //

    ListSize += FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address);

    return(ListSize);
}

VOID
TcIndicateInterfaceChange(
    IN PADAPTER Adapter,
    IN PPS_WAN_LINK WanLink,
    IN NDIS_STATUS Status
    )
{
    ULONG                       AddrLen = 0;
    ULONG                       DataLen;
    PTC_INDICATION_BUFFER       Data;

    PsAssert((Status == NDIS_STATUS_INTERFACE_UP) || (Status == NDIS_STATUS_INTERFACE_DOWN) ||
             (Status == NDIS_STATUS_INTERFACE_CHANGE));

    if(Adapter->MediaType == NdisMediumWan) 
    {

        if(WanLink) {

            CollectWanNetworkAddresses(Adapter, WanLink, &AddrLen, NULL);

            DataLen = AddrLen + FIELD_OFFSET(TC_INDICATION_BUFFER, InfoBuffer);
        
            PsAllocatePool(Data, DataLen, PsMiscTag);
            
            if(Data){
                
                Data->SubCode = 0;
                
                CollectWanNetworkAddresses(Adapter, WanLink, &AddrLen, &Data->InfoBuffer);
            
                PsTcNotify(Adapter, WanLink, Status, Data, DataLen);

                PsFreePool(Data);
            }
        }
        
    }
    else {
        
        
        CollectNetworkAddresses(Adapter, &AddrLen, NULL);
        
        DataLen = AddrLen + FIELD_OFFSET(TC_INDICATION_BUFFER, InfoBuffer);
        
        PsAllocatePool(Data, DataLen, PsMiscTag);
        
        if(Data){
            
            Data->SubCode = 0;
            
            CollectNetworkAddresses(Adapter, &AddrLen, &Data->InfoBuffer);
        
            PsTcNotify(Adapter, 0, Status, Data, DataLen);

            PsFreePool(Data);
        }
    }

    return;
}

VOID
MpQueryPnPCapabilities( 
    IN OUT PPS_NDIS_REQUEST PsReqBuffer,
    IN OUT PADAPTER         pAdapt, 
    OUT PNDIS_STATUS        pStatus
    )

/*++

Routine Description:

        Miniport QueryInfo OID_PNP_CAPAIBILITIES:
        If the Oid == Oid_PNP_CAPABILITIES, InformationBuffer is returned with all the fields
        assigned NdisDeviceStateUnspecified in the NDIS_PM_WAKE_UP_CAPABILITIES structure

        OID_QUERY_POWER_STATE is returned with NDIS_STATUS_SUCCESS and should never be passed below.

Arguments:

        MiniportAdapterContext  Pointer to the adapter structure
        Oid                                             Oid for this query
        InformationBuffer               Buffer for information
        InformationBufferLength Size of this buffer
        BytesWritten                    Specifies how much info is written
        BytesNeeded                             In case the buffer is smaller than what we need, tell them how much is needed

Return Value:

        Return code from the NdisRequest below.

--*/

{

    PNDIS_PNP_CAPABILITIES         pPNPCapabilities;  
    PNDIS_PM_WAKE_UP_CAPABILITIES  pPMstruct;
    
    if (PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBufferLength 
        >= sizeof(NDIS_PNP_CAPABILITIES) )
    {
        
        pPNPCapabilities  = (PNDIS_PNP_CAPABILITIES)
            (PsReqBuffer->ReqBuffer.DATA.QUERY_INFORMATION.InformationBuffer );
        
        //
        // Setting up the buffer to be returned to the Protocol above the SampleIM
        //
        pPMstruct= &pPNPCapabilities->WakeUpCapabilities;
        
        pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
        pPMstruct->MinPatternWakeUp     = NdisDeviceStateUnspecified;
        pPMstruct->MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;
        
        *PsReqBuffer->BytesReadOrWritten = sizeof(NDIS_PNP_CAPABILITIES );
        *PsReqBuffer->BytesNeeded        = 0;
        
        
        //
        // Setting our internal flags
        // Default, device is  ON
        //
        
        pAdapt->PTDeviceState = NdisDeviceStateD0;      
        pAdapt->MPDeviceState = NdisDeviceStateD0;      
        
        *pStatus           = NDIS_STATUS_SUCCESS; 

        //
        // We could have received some status indications when we were in DeviceState > D0. 
        // Now is the time to look at them again. 
        //
        PsGetLinkSpeed(pAdapt);
    }
    else 
    {
        *PsReqBuffer->BytesNeeded = sizeof(NDIS_PNP_CAPABILITIES);
        
        *pStatus = NDIS_STATUS_RESOURCES;
    }
    
}


#if DBG
VOID
IndicateLogThreshold(
    IN PVOID Context 
    )
{
    PADAPTER Adapter = (PADAPTER)Context;

    ULONG BytesUnread = SchedtGetBytesUnread();

    NdisMCoIndicateStatus(Adapter->PsNdisHandle,
                          NULL,
                          QOS_STATUS_LOG_THRESHOLD,
                          &BytesUnread,
                          sizeof(ULONG));
}
#endif
/* end ndisreq.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\psstub.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    PsStub.c

Abstract:

    Scheduler stub.  This module is the terminating module in the
    scheduling component stack.  It just forwards packets on to the
    lower MP.

Author:


Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

// The stub's pipe information

typedef struct _PSSTUB_PIPE 
{
    // ContextInfo -    Generic context info
    // Adapter -        Pointer to adapter struct

    PS_PIPE_CONTEXT         ContextInfo;
    PADAPTER                Adapter;
    PSU_SEND_COMPLETE       SendComplete;
    PPS_PIPE_CONTEXT        SendCompletePipeContext;
    

} PSSTUB_PIPE, *PPSSTUB_PIPE;

// The stub's flow information

typedef struct _PSSTUB_FLOW {

    // ContextInfo -            Generic context info
    // AdapterVc -              Pointer to adapter VC struct

    PS_FLOW_CONTEXT ContextInfo;
    PGPC_CLIENT_VC AdapterVc;
} PSSTUB_FLOW, *PPSSTUB_FLOW;


/* External */

/* Static */

/* Forward */

NDIS_STATUS
PsStubInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    );

NDIS_STATUS
PsStubModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

VOID
PsStubDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    );

NDIS_STATUS
PsStubCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

NDIS_STATUS
PsStubModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
PsStubDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

VOID
PsStubEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );    

NDIS_STATUS 
PsStubCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext);

NDIS_STATUS 
PsStubDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext);

BOOLEAN
PsStubSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK Packet
    );

VOID
PsStubSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data);

VOID
PsStubQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);

/* End Forward */


VOID
InitializeSchedulerStub(
    PPSI_INFO Info)

/*++

Routine Description:

    Initialization routine for the stub.  This routine just
    fills in the PSI_INFO struct and returns.

Arguments:

    Info - Pointer to component interface info struct

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    Info->PipeContextLength     = sizeof(PSSTUB_PIPE);
    Info->FlowContextLength     = sizeof(PSSTUB_FLOW);
    Info->ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
    Info->InitializePipe        = PsStubInitializePipe;
    Info->ModifyPipe            = PsStubModifyPipe;
    Info->DeletePipe            = PsStubDeletePipe;
    Info->CreateFlow            = PsStubCreateFlow;
    Info->ModifyFlow            = PsStubModifyFlow;
    Info->DeleteFlow            = PsStubDeleteFlow;
    Info->EmptyFlow             = PsStubEmptyFlow;
    Info->CreateClassMap        = PsStubCreateClassMap;
    Info->DeleteClassMap        = PsStubDeleteClassMap;
    Info->SubmitPacket          = PsStubSubmitPacket;
    Info->ReceivePacket         = NULL;
    Info->ReceiveIndication     = NULL;
    Info->SetInformation        = PsStubSetInformation;
    Info->QueryInformation      = PsStubQueryInformation;

} // InitializeSchedulerStub



// 
//  Unload routine: currently do nothing
//
void
UnloadPsStub()
{

}



VOID
CleanupSchedulerStub(
    VOID)

/*++

Routine Description:

    Cleanup routine for stub.

Arguments:

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
} // CleanupSchedulerStub



NDIS_STATUS
PsStubInitializePipe (
    IN HANDLE              PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT    ComponentPipeContext,
    IN PPS_PROCS           PsProcs,
    IN PPS_UPCALLS         Upcalls
    )

/*++

Routine Description:

    Pipe initialization routine for stub.

Arguments:

    PsPipeContext -         PS pipe context value
    PipeParameters -        Pointer to pipe parameters
    ComponentPipeContext -  Pointer to this component's context area
    PsProcs -               PS's support routines
    Upcalls -               Previous component's upcall table

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    PPSSTUB_PIPE Pipe = (PPSSTUB_PIPE)ComponentPipeContext;

    Pipe->Adapter = (PADAPTER)PsPipeContext;

    if (Upcalls != NULL) {
        Pipe->SendComplete = Upcalls->SendComplete;
        Pipe->SendCompletePipeContext = Upcalls->PipeContext;
    }
    else {
        Pipe->SendComplete = NULL;
    }

    return NDIS_STATUS_SUCCESS;

} // PsStubInitializePipe



NDIS_STATUS
PsStubModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )

/*++

Routine Description:

    Pipe parameter modification routine for stub.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    PipeParameters -    Pointer to pipe parameters

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    PPSSTUB_PIPE Pipe = (PPSSTUB_PIPE)PipeContext;

    return NDIS_STATUS_SUCCESS;

} // PsStubModifyPipe



VOID
PsStubDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )

/*++

Routine Description:

    Pipe removal routine for stub.

Arguments:

    PipeContext -   Pointer to this component's pipe context area

Return Values:

--*/
{

} // PsStubDeletePipe



NDIS_STATUS
PsStubCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )

/*++

Routine Description:

    Flow creation routine for stub.

Arguments:

    PipeContext -           Pointer to this component's pipe context area
    PsFlowContext -         PS flow context value
    CallParameters -        Pointer to call parameters for flow
    ComponentFlowContext -  Pointer to this component's flow context area

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    PPSSTUB_PIPE Pipe = (PPSSTUB_PIPE)PipeContext;
    PPSSTUB_FLOW Flow = (PPSSTUB_FLOW)ComponentFlowContext;

    Flow->AdapterVc = (PGPC_CLIENT_VC)PsFlowContext;

    Flow->AdapterVc->SendComplete            = Pipe->SendComplete;
    Flow->AdapterVc->SendCompletePipeContext = Pipe->SendCompletePipeContext;

    return NDIS_STATUS_SUCCESS;

} // PsStubCreateFlow



NDIS_STATUS
PsStubModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )

/*++

Routine Description:

    Flow modification routine for stub.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area
    CallParameters -    Pointer to call parameters for flow

Return Values:

    NDIS_STATUS_SUCCESS

--*/
{
    return NDIS_STATUS_SUCCESS;

} // PsStubModifyFlow



VOID
PsStubDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )

/*++

Routine Description:

    Flow removal routine for token bucket conformer.

Arguments:

    PipeContext -       Pointer to this component's pipe context area
    FlowContext -       Pointer to this component's flow context area

Return Values:

--*/
{

} // PsStubDeleteFlow


VOID
PsStubEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )
{

}


NDIS_STATUS 
PsStubCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS 
PsStubDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext)
{
    return NDIS_STATUS_SUCCESS;
}


BOOLEAN
PsStubSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )

/*++

Routine Description:

    Packet submission routine for stub.

Arguments:

    PipeContext -   Pointer to this component's pipe context area
    FlowContext -   Pointer to this component's flow context area
    Packet -        Pointer to packet

Return Values:

    NDIS_ATATUS_SUCCESS

--*/
{
    PPSSTUB_FLOW             Flow = (PPSSTUB_FLOW)FlowContext;
    PGPC_CLIENT_VC           AdapterVc = Flow->AdapterVc;
    PADAPTER                 Adapter = AdapterVc->Adapter;
    PPS_SEND_PACKET_CONTEXT  PktContext;
    LARGE_INTEGER            PacketLength;
    PNDIS_PACKET             Packet = PacketInfo->NdisPacket;

    PktContext            = CONTAINING_RECORD(PacketInfo, PS_SEND_PACKET_CONTEXT, Info);
    PacketLength.QuadPart = (LONGLONG)PktContext->Info.PacketLength;

    //
    // update flow stats
    //

    AdapterVc->Stats.BytesTransmitted.QuadPart += PacketLength.QuadPart;
    
    AdapterVc->Stats.PacketsTransmitted ++;


    if(Adapter->MediaType != NdisMediumWan)
    {
        NdisSendPackets(Adapter->LowerMpHandle, &Packet, 1);
    }
    else{
        
        //
        // If it didn't have a VC, we wouldn't have called
        // through the PS.
        //

        if(AdapterVc->NdisWanVcHandle)
        {
            NdisCoSendPackets(AdapterVc->NdisWanVcHandle,
                              &Packet,
                              1);
        }
        else 
        {
            NdisSendPackets(Adapter->LowerMpHandle,
                            &Packet,
                            1);
        }
    }

    return TRUE;

} // PsStubSubmitPacket


VOID
PsStubSetInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data)
{
}


VOID
PsStubQueryInformation (
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_FLOW_CONTEXT ComponentFlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    *Status = NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\pstub.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    pstub.h

Abstract:

    defines for protocol stub routines

Author:

    Charlie Wickham (charlwi) 22-Apr-1996

Revision History:

--*/

#ifndef _PSTUB_
#define _PSTUB_

/* Prototypes */ /* Generated by Emacs 19.17.0 on Wed May 08 10:48:08 1996 */

/*++

Routine Description:

    Completion routine for NdisReset
Arguments:

    See the DDK...

Return Values:

    None

--*/

NDIS_STATUS
ClPnPEventHandler(
    IN NDIS_HANDLE Handle,
    IN PNET_PNP_EVENT NetPnPEvent
    );

VOID
ClResetComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
ClCoStatus(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext OPTIONAL,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID StatusBuffer,
    IN  UINT StatusBufferSize
    );

VOID
ClCoAfRegisterNotifyHandler(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY		AddressFamily);

/* End Prototypes */

#endif /* _PSTUB_ */

/* end pstub.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\recv.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    recv.c

Abstract:

    routines to handle receiving data

Author:

    Charlie Wickham (charlwi)  08-May-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.17.0 on Thu May 09 10:34:39 1996 */

INT
ClReceivePacket(
        IN      NDIS_HANDLE                             ProtocolBindingContext,
        IN      PNDIS_PACKET                    Packet
        );

VOID
MpReturnPacket(
        IN      NDIS_HANDLE                             MiniportAdapterContext,
        IN      PNDIS_PACKET                    Packet
        );

VOID
ClReceiveComplete(
        IN      NDIS_HANDLE                             ProtocolBindingContext
        );

NDIS_STATUS
MpTransferData(
        OUT PNDIS_PACKET                        Packet,
        OUT PUINT                                       BytesTransferred,
        IN      NDIS_HANDLE                             MiniportAdapterContext,
        IN      NDIS_HANDLE                             MiniportReceiveContext,
        IN      UINT                                    ByteOffset,
        IN      UINT                                    BytesToTransfer
        );

VOID
ClTransferDataComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_PACKET    pNdisPacket,
    IN  NDIS_STATUS     Status,
    IN  UINT            BytesTransferred
    );

/* End Forward */

VOID
PsAllocateRecvPacket(PNDIS_STATUS  Status,
                     PPNDIS_PACKET Packet,
                     PADAPTER      Adapter)
{

    if(!Adapter->RecvPacketPool)
    {
        PS_LOCK_DPC(&Adapter->Lock);

        if(!Adapter->RecvPacketPool)
        {
            NDIS_HANDLE PoolHandle = (void *) NDIS_PACKET_POOL_TAG_FOR_PSCHED;

            NdisAllocatePacketPoolEx(Status,
                                     &PoolHandle,
                                     MIN_PACKET_POOL_SIZE,
                                     MAX_PACKET_POOL_SIZE,
                                     sizeof(PS_RECV_PACKET_CONTEXT));

            if(*Status != NDIS_STATUS_SUCCESS)
            {
                Adapter->Stats.OutOfPackets ++;
                PS_UNLOCK_DPC(&Adapter->Lock);

                return;
            }

            // 
            // We successfully allocated a packet pool. We can now free the Fixed Size Block pool for the packet-stack API
            //
            Adapter->RecvPacketPool = PoolHandle;

        }

        PS_UNLOCK_DPC(&Adapter->Lock);
    }

    NdisDprAllocatePacket(Status,
                          Packet,
                          Adapter->RecvPacketPool);
    
}


INT
ClReceivePacket(
        IN      NDIS_HANDLE ProtocolBindingContext,
        IN      PNDIS_PACKET MpPacket
        )

/*++

Routine Description:

    Called by the NIC to indicate a data as an NDIS_PACKET. Make a copy of the
    packet struct, switch to miniport mode and continue the packet along its way

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                   Adapter = (PADAPTER)ProtocolBindingContext;
    NDIS_STATUS                Status;
    PPS_RECV_PACKET_CONTEXT    ContextArea;
    PNDIS_PACKET               OurPacket;
    BOOLEAN                    Remaining;

    PsStructAssert( Adapter );

    if(!Adapter->PsNdisHandle)
    {
        return 0;
    }

    if(Adapter->MediaType == NdisMediumWan && 
       Adapter->ProtocolType == ARP_ETYPE_IP)
    {
        //
        // Munge s-mac and d-mac so that wanarp is happy.
        //
        PNDIS_BUFFER pNdisBuf;
        UINT         Len;
        PETH_HEADER  pAddr;
        PUSHORT      id;
        PPS_WAN_LINK WanLink;
        
        pNdisBuf = MpPacket->Private.Head;
        NdisQueryBuffer(pNdisBuf, &pAddr, &Len);
        
        if(Len < sizeof(ETH_HEADER))
        {
            return NDIS_STATUS_FAILURE;
        }

        id = (PUSHORT)&pAddr->DestAddr[0];

        PS_LOCK(&Adapter->Lock);

        if((WanLink = (PPS_WAN_LINK)g_WanLinkTable[*id]) == 0)
        {
            PS_UNLOCK(&Adapter->Lock);
            return NDIS_STATUS_FAILURE;
        }

        if(WanLink->State != WanStateOpen)
        {
            PS_UNLOCK(&Adapter->Lock);
            return NDIS_STATUS_FAILURE;
        }

        NdisMoveMemory(pAddr, 
                       &WanLink->RecvHeader, 
                       FIELD_OFFSET(ETH_HEADER, Type));

        PS_UNLOCK(&Adapter->Lock);
    }

    NdisIMGetCurrentPacketStack(MpPacket, &Remaining);

    if(Remaining != 0)
    {
        Status = NDIS_GET_PACKET_STATUS(MpPacket);

        if (TimeStmpRecvPacket) {
            
            if (!(TimeStmpRecvPacket)(
                                      NULL,
                                      NULL,
                                      NULL,
                                      MpPacket,
                                      Adapter->MediaType
                                      )) {
                
                PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_PACKET, OURS, Adapter, MpPacket, 0);
            }
            
        }
        
		NdisMIndicateReceivePacket(Adapter->PsNdisHandle, &MpPacket, 1);

		return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
    }
    else 
    {

        PsAllocateRecvPacket(&Status, &OurPacket, Adapter);

        if(Status == NDIS_STATUS_SUCCESS)
        {
            PsDbgRecv(DBG_INFO, DBG_RECEIVE, CL_RECV_PACKET, ENTER, Adapter, OurPacket, MpPacket);
            
            //
            // Save Original Packet
            //
            ContextArea = PS_RECV_PACKET_CONTEXT_FROM_PACKET(OurPacket);
            ContextArea->OriginalPacket = MpPacket;
            
    
            OurPacket->Private.Head       = MpPacket->Private.Head;
            OurPacket->Private.Tail       = MpPacket->Private.Tail;
            
            //
            // Get the original packet (it could be the same packet as one received or a different one
            // based on # of layered MPs) and set it on the indicated packet so the OOB stuff is visible
            // correctly at the top.
            //
            NDIS_SET_ORIGINAL_PACKET(OurPacket, NDIS_GET_ORIGINAL_PACKET(MpPacket));
    
            NDIS_SET_PACKET_HEADER_SIZE(OurPacket, NDIS_GET_PACKET_HEADER_SIZE(MpPacket));
            
            //
            // Set Packet Flags
            //
            NdisGetPacketFlags(OurPacket) = NdisGetPacketFlags(MpPacket);
            
            Status = NDIS_GET_PACKET_STATUS(MpPacket);
            
            NDIS_SET_PACKET_STATUS(OurPacket, Status);
            
            if (TimeStmpRecvPacket) {
                
                if (!(TimeStmpRecvPacket)(
                                          NULL,
                                          NULL,
                                          NULL,
                                          OurPacket,
                                          Adapter->MediaType
                                          )) {
                        
                    PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_PACKET, OURS, Adapter, OurPacket, OurPacket);
                }
                    
            }

            NdisMIndicateReceivePacket(Adapter->PsNdisHandle, &OurPacket, 1);

            if (Status == NDIS_STATUS_RESOURCES)
            {
                NdisDprFreePacket(OurPacket);
            }
            
            return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
        }
        else
        {
            
            //
            // out of resources. indicate that we're not hanging onto the packet
            //
            PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_PACKET, NO_RESOURCES,
                      Adapter, 0, MpPacket);
            
            Adapter->Stats.OutOfPackets ++;
            return 0;
        }
    }

} // ClReceivePacket


VOID
MpReturnPacket(
        IN      NDIS_HANDLE                             MiniportAdapterContext,
        IN      PNDIS_PACKET                    Packet
        )

/*++

Routine Description:

     Potentially return a packet we indicated previously to the
     underlying miniport. It might be one of ours from a ProtocolReceive
     indication, so we disassemble it and return the packet and its
     buffers to their respective S Lists

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                Adapter = (PADAPTER)MiniportAdapterContext;
    PPS_RECV_PACKET_CONTEXT PktContext;
    PNDIS_PACKET            MyPacket;
    BOOLEAN                 Remaining;

    PsStructAssert(Adapter);

    NdisIMGetCurrentPacketStack(Packet, &Remaining);

    if(Remaining != 0)
    {
        NdisReturnPackets(&Packet, 1);
    }
    else 
    {

        //
        // see if the OriginalPacket field indicates that this belongs
        // to someone below us and return it now
        //

        PktContext = PS_RECV_PACKET_CONTEXT_FROM_PACKET(Packet);

        MyPacket = PktContext->OriginalPacket;

        PsDbgRecv(DBG_INFO, DBG_RECEIVE, MP_RETURN_PACKET, RETURNING, Adapter, Packet, MyPacket);

        NdisDprFreePacket(Packet);

        NdisReturnPackets(&MyPacket, 1);
    }


} // MpReturnPacket


NDIS_STATUS
ClReceiveIndication(
        IN      NDIS_HANDLE                             ProtocolBindingContext,
        IN      NDIS_HANDLE                             MacReceiveContext,
        IN      PVOID                                   HeaderBuffer,
        IN      UINT                                    HeaderBufferSize,
        IN      PVOID                                   LookAheadBuffer,
        IN      UINT                                    LookAheadBufferSize,
        IN      UINT                                    PacketSize
        )

/*++

 Routine Description:

    Called by NIC to notify protocol of incoming data. Copy the data
    into a cached packet we set up during initialization and indicate
    that packet to the higher layer.

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER     Adapter = (PADAPTER)ProtocolBindingContext;
    PNDIS_PACKET MyPacket, Packet;
    NDIS_STATUS  Status  = NDIS_STATUS_SUCCESS;

    PsStructAssert(Adapter);

    if(!Adapter->PsNdisHandle)
    {
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        do
        {
            //
            // If this was indicated by the miniport below as a packet, then get that packet
            // pointer and indicate it as a packet as well (with appropriate status).
            // This way the OOB stuff is accessible to the transport above us.
            //

            Packet = NdisGetReceivedPacket(Adapter->LowerMpHandle, MacReceiveContext);

            if (Packet != NULL)
            {
                BOOLEAN Remaining;

                //
                // Check if there are any more packet stacks left. If there is need to keep per packet information,
                // then the packet stack (which is returned by the api) can be used to store that
                //
                NdisIMGetCurrentPacketStack(Packet, &Remaining);
                if (Remaining != 0)
                {
                    NDIS_STATUS OldPacketStatus;
                    
                    if (TimeStmpRecvPacket) {

                        if (!(TimeStmpRecvPacket)(
                                              NULL,
                                              NULL,
                                              NULL,
                                              Packet,
                                              Adapter->MediaType
                                              )) {

                            PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_IND, OURS, Adapter, Packet, Packet);
                        }

                    }

                    // 
                    // Save the old status, and set packet status to NDIS_STATUS_RESOURCES
                    // because we can't have the protocol above us retain the packet -- it
                    // can go away as soon as we return from this function.
                    //
    
                    OldPacketStatus = NDIS_GET_PACKET_STATUS(Packet);
                    NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_RESOURCES);

                    NdisMIndicateReceivePacket(Adapter->PsNdisHandle, &Packet, 1);

                    // 
                    // Restore the old Status
                    //
                    NDIS_SET_PACKET_STATUS(Packet, OldPacketStatus);

                    // Since we had set the packet status to NDIS_STATUS_RESOURCES, our
                    // ReturnPacket handler won't be called for this packet.

                    break;
                }

                //
                // Get a packet off the pool and indicate that up
                //
                PsAllocateRecvPacket(&Status,
                                     &MyPacket,
                                     Adapter);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    MyPacket->Private.Head = Packet->Private.Head;
                    MyPacket->Private.Tail = Packet->Private.Tail;
				
                    //
                    // Get the original packet (it could be the same packet as one received or
                    // a different one based on # of layered MPs) and set it on the indicated
                    // packet so the OOB stuff is visible  correctly at the top.
                    //
                    NDIS_SET_ORIGINAL_PACKET(MyPacket, NDIS_GET_ORIGINAL_PACKET(Packet));

                    NDIS_SET_PACKET_HEADER_SIZE(MyPacket, HeaderBufferSize);
		
                    //
                    // Set Packet Flags
                    //
                    NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);
				
                    //
                    // Make sure the status is set to NDIS_STATUS_RESOURCES.
                    //
                    NDIS_SET_PACKET_STATUS(MyPacket, NDIS_STATUS_RESOURCES);

                    if (TimeStmpRecvPacket) {

                        if (!(TimeStmpRecvPacket)(
                                              NULL,
                                              NULL,
                                              NULL,
                                              MyPacket,
                                              Adapter->MediaType
                                              )) {

                            PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_IND, OURS, Adapter, MyPacket, MyPacket);
                        }

                    }

                    NdisMIndicateReceivePacket(Adapter->PsNdisHandle, &MyPacket, 1);
		
                    PsAssert (NDIS_GET_PACKET_STATUS(MyPacket) == NDIS_STATUS_RESOURCES);

                    NdisDprFreePacket(MyPacket);

                    break;
                }
            }

            //
            // Fall through if the miniport below us has either not indicated a packet or we
            // could not  allocate one
            //
            Adapter->IndicateRcvComplete = TRUE;

            //
            // If the timestamp driver is present.
            //
            //
            if (TimeStmpRecvIndication) {

                if (!(TimeStmpRecvIndication)(
                                              NULL,
                                              NULL,
                                              NULL,
                                              HeaderBuffer,
                                              HeaderBufferSize,
                                              LookAheadBuffer,
                                              LookAheadBufferSize,
                                              PacketSize,
                                              Adapter->IPHeaderOffset
                                              )) {

                    PsDbgRecv(DBG_FAILURE, DBG_RECEIVE, CL_RECV_IND, OURS, Adapter, (PNDIS_PACKET) LookAheadBuffer, NULL);
                }

            }

            switch (Adapter->MediaType)
            {
              case NdisMedium802_3:
            case NdisMediumWan:


                  NdisMEthIndicateReceive(Adapter->PsNdisHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookAheadBuffer,
                                          LookAheadBufferSize,
                                          PacketSize);
                  break;

              case NdisMedium802_5:
                  NdisMTrIndicateReceive(Adapter->PsNdisHandle,
                                         MacReceiveContext,
                                         HeaderBuffer,
                                         HeaderBufferSize,
                                         LookAheadBuffer,
                                         LookAheadBufferSize,
                                         PacketSize);
                  break;

              case NdisMediumFddi:
                  NdisMFddiIndicateReceive(Adapter->PsNdisHandle,
                                           MacReceiveContext,
                                           HeaderBuffer,
                                           HeaderBufferSize,
                                           LookAheadBuffer,
                                           LookAheadBufferSize,
                                           PacketSize);
                  break;

              default:
                  PsAssert (0);
                  Status = NDIS_STATUS_FAILURE;
                  break;
            }

        } while (FALSE);
    }

    return Status;

} // ClReceiveIndication


VOID
ClReceiveComplete(
        IN      NDIS_HANDLE                             ProtocolBindingContext
        )

/*++

Routine Description:

    Called by NIC via NdisIndicateReceiveComplete. Continue this indication
    up to the higher layer

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsStructAssert(Adapter);

    PsDbgRecv(DBG_INFO, DBG_RECEIVE, CL_RECV_COMPL, ENTER, Adapter, 0, 0);

    if((Adapter->PsNdisHandle != NULL) && Adapter->IndicateRcvComplete) {

        switch(Adapter->MediaType){

          case NdisMediumWan:
          case NdisMedium802_3:

              NdisMEthIndicateReceiveComplete(Adapter->PsNdisHandle);
              break;

          case NdisMedium802_5:

              NdisMTrIndicateReceiveComplete(Adapter->PsNdisHandle);
              break;

          case NdisMediumFddi:

              NdisMFddiIndicateReceiveComplete(Adapter->PsNdisHandle);
              break;

        default:

            PsAssert(FALSE);
        }
    }
    Adapter->IndicateRcvComplete = FALSE;

}  // ClReceiveComplete


NDIS_STATUS
MpTransferData(
        OUT PNDIS_PACKET Packet,
        OUT PUINT        BytesTransferred,
        IN  NDIS_HANDLE  MiniportAdapterContext,
        IN  NDIS_HANDLE  MiniportReceiveContext,
        IN  UINT         ByteOffset,
        IN  UINT         BytesToTransfer
        )

/*++

Routine Description:



Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)MiniportAdapterContext;
    NDIS_STATUS Status;

    PsStructAssert(Adapter);

    PsDbgRecv(DBG_INFO, DBG_RECEIVE, MP_XFER_DATA, ENTER, Adapter, 0, 0);

    if(IsDeviceStateOn(Adapter) == FALSE)
    {
        return NDIS_STATUS_FAILURE;
    }

    NdisTransferData(
                &Status,
                Adapter->LowerMpHandle,
                MiniportReceiveContext,
                ByteOffset,
                BytesToTransfer,
                Packet,
                BytesTransferred);

    return Status;

} // MpTransferData


VOID
ClTransferDataComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_PACKET    Packet,
    IN  NDIS_STATUS     Status,
    IN  UINT            BytesTransferred
    )

/*++

Routine Description:

    Completion routine for NdisTransferData

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                Adapter = (PADAPTER)ProtocolBindingContext;
    PPS_RECV_PACKET_CONTEXT PktContext;

    PsStructAssert(Adapter);

    PsDbgRecv(DBG_INFO, DBG_RECEIVE, CL_XFER_COMPL, ENTER, Adapter, Packet, 0);

    if(Adapter->PsNdisHandle)
    {
        NdisMTransferDataComplete(
                        Adapter->PsNdisHandle,
                        Packet,
                        Status,
                        BytesTransferred);
    }

} // ClTransferDataComplete

UINT
ClCoReceivePacket(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    )
{
    //
    // We don't do anything special in the coreceive path. Just call ClReceivePacket.
    //

    return ClReceivePacket(ProtocolBindingContext, Packet);

} // ClCoReceivePacket

/* end recv.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\recv.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    recv.h

Abstract:

    defines for packet receive routines

Author:

    Charlie Wickham (charlwi) 08-May-1996

Revision History:

--*/

#ifndef _RECV_
#define _RECV_

/* Prototypes */ /* Generated by Emacs 19.17.0 on Thu May 09 10:34:42 1996 */

/*++

Routine Description:

    Called by the NIC to indicate a data as an NDIS_PACKET. Switch to miniport mode
    and continue the packet along its way

Arguments:

    See the DDK...

Return Values:

    None

--*/

INT
ClReceivePacket(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet
	);

/*++

Routine Description:



Arguments:

    See the DDK...

Return Values:

    None

--*/

VOID
MpReturnPacket(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet
	);

/*++

Routine Description:

    Called by NIC to notify protocol of incoming data

Arguments:

    See the DDK...

Return Values:

    None

--*/

NDIS_STATUS
ClReceiveIndication(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				MacReceiveContext,
	IN	PVOID					HeaderBuffer,
	IN	UINT					HeaderBufferSize,
	IN	PVOID					LookAheadBuffer,
	IN	UINT					LookaheadBufferSize,
	IN	UINT					PacketSize
	);

/*++

Routine Description:

    Called by NIC via NdisIndicateReceiveComplete

Arguments:

    See the DDK...

Return Values:

    None

--*/

VOID
ClReceiveComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	);

/*++

Routine Description:



Arguments:

    See the DDK...

Return Values:

    None

--*/

NDIS_STATUS
MpTransferData(
	OUT PNDIS_PACKET			Packet,
	OUT PUINT					BytesTransferred,
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_HANDLE				MiniportReceiveContext,
	IN	UINT					ByteOffset,
	IN	UINT					BytesToTransfer
	);

/*++

Routine Description:

    Completion routine for NdisTransferData
Arguments:

    See the DDK...

Return Values:

    None

--*/

VOID
ClTransferDataComplete(
    IN  NDIS_HANDLE     ProtocolBindingContext,
    IN  PNDIS_PACKET    pNdisPacket,
    IN  NDIS_STATUS     Status,
    IN  UINT            BytesTransferred
    );

UINT
ClCoReceivePacket(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );

/* End Prototypes */

#endif /* _RECV_ */

/* end recv.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\refcnt.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    refcnt.c

Abstract:

    This module exports Reference Counting support functions. By 
    including a Reference Count Control Block (REF_CNT) in a
    dynamic type, and using this API, a Reference scheme can be
    implemented for that type.

Author:

    Edward Buchwalter (v-edbuc)    14-Aug-1996

Revision History:

    Shreedhar Madhavapeddi (ShreeM)   16-April-1999 Adapted for NT and GPC by ShreeM\MBert.
    Rajesh Sundaram        (rajeshsu) 05-Aug-1999   Adapted for psched. 
    
--*/

//
// Include Files
//

#include "psched.h"
#pragma hdrstop

#define EXPAND_TAG(t)   ((CHAR *)(&Tag))[0],((CHAR *)(&Tag))[1],((CHAR *)(&Tag))[2],((CHAR *)(&Tag))[3]
VOID
ReferenceInit 
(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)( PVOID , BOOLEAN)
)

/*++

Routine Description:

    ReferenceInit initializes and adds one reference to the
    supplied Reference Control Block. If provided, an instance
    handle and delete handler are saved for use by the ReferenceRemove 
    function when all references to the instance are removed.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    InstanceHandle - handle to the managed instance.
    DeleteHandler - pointer to delete function, NULL is OK.

Return Value:

    The function's value is VOID.

--*/

{
    ASSERT( pRefCnt );

    // Set the reference to 1 and save the instance 
    // handle and the delete handler.

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;
    
#if DBG
    pRefCnt->Sig = REF_SIG;

    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);
    
    pRefCnt->Tags[0].Tag = 'LTOT';
    
    CTEInitLock(&pRefCnt->Lock);
    
#endif
        
}


#if DBG

VOID
ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    
    ASSERT(pRefCnt->Sig == REF_SIG);
    
    CTEGetLock(&pRefCnt->Lock, &hLock);
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }
    
    ASSERT(i < TAG_CNT);
    
    InterlockedIncrement(&pRefCnt->Tags[0].Count);
    
    InterlockedIncrement(&pRefCnt->Count);
    
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);

    // sanity check
/*    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
    

*/    
    CTEFreeLock(&pRefCnt->Lock, hLock);
}

VOID
ReferenceRemoveDbg(PREF_CNT pRefCnt, BOOLEAN LockHeld, ULONG Tag)
{
    int             i;
    CTELockHandle   hLock;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    ASSERT(pRefCnt->Sig == REF_SIG);

    CTEGetLock(&pRefCnt->Lock, &hLock);
        
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            ASSERT(pRefCnt->Tags[i].Count > 0);
            
            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
                pRefCnt->Tags[i].Tag = Tag; 
            break;
        }
    }

    ASSERT(FoundIt);
  
    ASSERT(pRefCnt->Tags[0].Count > 0);
        
    ASSERT(pRefCnt->Tags[0].Count == pRefCnt->Count);
      
    InterlockedDecrement(&pRefCnt->Tags[0].Count);
    
    if (InterlockedDecrement(&pRefCnt->Count) > 0 )
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);
    } 
    else if (pRefCnt->DeleteHandler)
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);

        (pRefCnt->DeleteHandler)( pRefCnt->Instance, LockHeld );
    }
    else
    {
        CTEFreeLock(&pRefCnt->Lock, hLock);   
    }
        
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\refcnt.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    refcnt.h

Abstract:


Author:

    Edward Buchwalter (v-edbuc)    15-Aug-1996

Revision History:

    Shreedhar Madhavapeddi (ShreeM)   16-April-1999 Adapted for GPC.
    Rajesh Sundaram        (rajeshsu) 05-Aug-1999 Adapted for psched.
    
--*/

#ifndef REFCNT_H
#define REFCNT_H

//
// Reference Count Control Block
//
//  Elements:
//
//  - Count:            number of outstanding references
//  - Instance:      user supplied context 
//  - UserDeleteFunc:   user supplied delete function
//

#define TAG_CNT 10
#define REF_SIG 0x7841eeee

typedef struct
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    

typedef struct  reference_count_control
{
    LONG       	  Count;
    PVOID         Instance;
    VOID          (*DeleteHandler)( PVOID, BOOLEAN );
#if DBG    
    int           Sig;
    REF_TAG       Tags[TAG_CNT];
    CTELock       Lock;
#endif     
} REF_CNT, *PREF_CNT;


VOID    
ReferenceInit 
( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)( PVOID , BOOLEAN) 
);

#define REFINIT(Rc, I, h) ReferenceInit(Rc, I, h)

#if DBG

VOID ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceRemoveDbg(PREF_CNT pRefCnt, BOOLEAN Locked, ULONG Tag);

#define REFADD(Rc, Tag)               ReferenceAddDbg(Rc, Tag);
#define REFDEL(Rc, LockHeld, Tag)     ReferenceRemoveDbg(Rc, LockHeld, Tag)

#else

#define REFADD(Rc, Tag)  InterlockedIncrement(&(Rc)->Count);
#define REFDEL(Rc, LockHeld, Tag)                             \
   if (InterlockedDecrement(&(Rc)->Count) == 0 )              \
        ((Rc)->DeleteHandler)( (Rc)->Instance , (LockHeld));

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\send.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    send.h

Abstract:

    defines for packet sending routines

Author:

    Charlie Wickham (charlwi) 07-May-1996

Revision History:

--*/

#ifndef _SEND_
#define _SEND_

/* Prototypes */ /* Generated by Emacs 19.17.0 on Tue May 07 11:47:57 1996 */

NDIS_STATUS
DupPacket(
    PADAPTER Adapter,
    PNDIS_PACKET Packet,
    PNDIS_PACKET *DupedPacket,
    PPS_SEND_PACKET_CONTEXT *PktContext
    );

NTSTATUS
MpSend(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet,
	IN	UINT					Flags
	);

VOID
ClSendComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet,
	IN	NDIS_STATUS				Status
	);

VOID
ClCoSendComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );

VOID
CmCoSendComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );

VOID
PcCoSendComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    );

VOID
DropPacket(
    IN HANDLE PipeContext,
    IN HANDLE FlowContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    );

PGPC_CLIENT_VC FASTCALL
GetVcByClassifyingPacket(
    PADAPTER Adapter,
    PTC_INTERFACE_ID pInterfaceID,
    PNDIS_PACKET OurPacket
    );

/* End Prototypes */

#endif /* _SEND_ */

/* end send.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\send.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    send.c

Abstract:

    routines for sending packets

Author:

    Charlie Wickham (charlwi)  07-May-1996
    Yoram Bernet    (yoramb)
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop

/* External */

/* Static */

/* Forwad */

#define SEND_PACKET_VIA_SCHEDULER(_pktcontext, _vc, _adapter, _ourpacket)     \
{                                                                             \
    PsAssert((_pktcontext)->Vc != 0);                                         \
    (_vc)->Stats.PacketsScheduled++;                                          \
    (_vc)->Stats.BytesScheduled.QuadPart += (_pktcontext)->Info.PacketLength; \
    if(!(*(_vc)->PsComponent->SubmitPacket)(                                  \
              (_vc)->PsPipeContext,                                           \
              (_vc)->PsFlowContext,                                           \
              (_pktcontext)->Info.ClassMapContext,                            \
              &(_pktcontext)->Info)) {                                        \
                                                                              \
          DropPacket((_adapter), (_vc), (_ourpacket), NDIS_STATUS_FAILURE);   \
    }                                                                         \
    return NDIS_STATUS_PENDING;                                               \
}


#define FILL_PKT_FOR_NIC(OPacket, UserC)                                      \
{                                                                             \
    NDIS_PACKET_8021Q_INFO    VlanPriInfo;                                    \
                                                                              \
    VlanPriInfo.Value = NDIS_PER_PACKET_INFO_FROM_PACKET(OPacket, Ieee8021QInfo);\
    VlanPriInfo.TagHeader.UserPriority = (UserC);                             \
    NDIS_PER_PACKET_INFO_FROM_PACKET(OPacket, Ieee8021QInfo) = VlanPriInfo.Value;\
}

#define FILL_PKT_FOR_SCHED(Adapter, PktContext, Vc, OPacket, TOSNC, UserC, UserNC,                   \
                           _IPHdr)                                                                   \
{                                                                                                    \
   ULONG _PacketLength;                                                                              \
   FILL_PKT_FOR_NIC(OPacket, UserC);                                                                 \
   NdisQueryPacket((OPacket), NULL, NULL, NULL, &(_PacketLength));                                   \
   (PktContext)->Info.PacketLength = (_PacketLength) - (Adapter)->HeaderSize;                        \
   (PktContext)->Info.ConformanceTime.QuadPart = 0;                                                  \
   (PktContext)->Info.ClassMapContext = 0;                                                           \
   (PktContext)->Info.UserPriorityNonConforming = (UserNC);                                          \
   (PktContext)->Info.TOSNonConforming          = (TOSNC);                                           \
   (PktContext)->Info.IPHdr                     = (_IPHdr);                                          \
   (PktContext)->Info.IPHeaderOffset            = (Adapter)->IPHeaderOffset;                         \
   (PktContext)->Vc                             = (Vc);                                              \
}

#define SEND_PACKET_OVER_NIC(Adapter, Packet, UserC, Status)                                              \
{                                                                                                         \
   PPS_SEND_PACKET_CONTEXT _PktContext;                                                                   \
   PNDIS_PACKET            _OurPacket;                                                                    \
   if((Status = PsDupPacketNoContext(Adapter, Packet, &_OurPacket, &_PktContext)) == NDIS_STATUS_SUCCESS) \
   {                                                                                                      \
      FILL_PKT_FOR_NIC(_OurPacket, UserC);                                                                \
      NdisSend(&Status, Adapter->LowerMpHandle, _OurPacket);                                              \
      if(Status != NDIS_STATUS_PENDING) {                                                                 \
         if(_PktContext) {                                                                                \
            PsAssert((_PktContext)->Vc == 0);                                                             \
            NdisIMCopySendCompletePerPacketInfo(_PktContext->OriginalPacket, _OurPacket);                 \
            NdisFreePacket(_OurPacket);                                                                   \
         }                                                                                                \
      }                                                                                                   \
   }                                                                                                      \
   return Status;                                                                                         \
}

NDIS_STATUS
PsAllocateAndCopyPacket(
    PADAPTER Adapter,
    PNDIS_PACKET Packet,
    PPNDIS_PACKET OurPacket,
    PPS_SEND_PACKET_CONTEXT *PktContext)
{                             
    PNDIS_PACKET_OOB_DATA        OurOOBData;
    PNDIS_PACKET_OOB_DATA        XportOOBData;
    PMEDIA_SPECIFIC_INFORMATION  OurMediaArea;
    PVOID                        MediaSpecificInfo = NULL;
    UINT                         MediaSpecificInfoSize = 0;
    NDIS_STATUS                  Status;

    //
    // At this point, we know that there are no packet stacks remaining in the packet.
    // we proceed to allocate an NDIS packet using NdisAllocatePacket. Note that here
    // we do not have to allocate our per-packet area, since NdisAllocatePacket already 
    // did this for us.
    //

    if(!Adapter->SendPacketPool)
    {
        PS_LOCK(&Adapter->Lock);

        if(!Adapter->SendPacketPool)
        {
            NDIS_HANDLE PoolHandle = (void *) NDIS_PACKET_POOL_TAG_FOR_PSCHED;

            NdisAllocatePacketPoolEx(&Status,
                                     &PoolHandle,
                                     MIN_PACKET_POOL_SIZE,
                                     MAX_PACKET_POOL_SIZE,
                                     Adapter->PacketContextLength);

            if(Status != NDIS_STATUS_SUCCESS)
            {
                Adapter->Stats.OutOfPackets ++;
                PS_UNLOCK(&Adapter->Lock);

                return Status;
            }

            // 
            // We successfully allocated a packet pool. We can now free the Fixed Size Block pool for the packet-stack API
            //
            Adapter->SendPacketPool = PoolHandle;
        }
        
        PS_UNLOCK(&Adapter->Lock);

    }

    NdisAllocatePacket(&Status,
                       OurPacket,
                       Adapter->SendPacketPool);
    
    
    if(Status != NDIS_STATUS_SUCCESS)
    {
        //
        // mark as out of resources. Ndis will resubmit.
        //
        
        Adapter->Stats.OutOfPackets ++;
        return(NDIS_STATUS_RESOURCES);
    }
    
#if DBG
    PsAssert((*OurPacket)->Private.Head == NULL);

    if(Packet->Private.TotalLength){
        
        PsAssert(Packet->Private.Head);
    }
#endif // DBG

    //
    // chain the buffers from the upper layer packet to the newly allocated packet.
    //
    
    (*OurPacket)->Private.Head = Packet->Private.Head;
    (*OurPacket)->Private.Tail = Packet->Private.Tail;
    
    //
    // Copy the Packet Flags from the Packet to OldPacket. Since we handle loopback in the 
    // QueryInformation handlers, we don't set the NDIS_FLAGS_DONT_LOOPBACK
    //
    
    NdisGetPacketFlags(*OurPacket) = NdisGetPacketFlags(Packet);
    
    //
    // Copy the OOB Offset from the original packet to the new packet.
    //
    XportOOBData = NDIS_OOB_DATA_FROM_PACKET(Packet);
    OurOOBData = NDIS_OOB_DATA_FROM_PACKET(*OurPacket);
    NdisMoveMemory(OurOOBData,
                   XportOOBData,
                   sizeof(NDIS_PACKET_OOB_DATA));
    
    //
    // Copy the per packet info into the new packet
    //
    NdisIMCopySendPerPacketInfo(*OurPacket, Packet);
    
    //
    // Copy the Media specific information
    //
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(Packet,
                                        &MediaSpecificInfo,
                                        &MediaSpecificInfoSize);
    if(MediaSpecificInfo || MediaSpecificInfoSize){
        
        NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(*OurPacket,
                                            MediaSpecificInfo,
                                            MediaSpecificInfoSize);
    }
    
    //
    // Remember the original packet so that we can complete it properly.
    //
    *PktContext = PS_SEND_PACKET_CONTEXT_FROM_PACKET(*OurPacket);
    (*PktContext)->OriginalPacket = Packet;
    (*PktContext)->Vc = 0;
    (*PktContext)->Info.NdisPacket = *OurPacket;

    return Status;
}
       
NDIS_STATUS
PsDupPacketNoContext(
    PADAPTER Adapter,
    PNDIS_PACKET Packet,
    PPNDIS_PACKET OurPacket,
    PPS_SEND_PACKET_CONTEXT *PktContext)
{                             
    NDIS_STATUS                  Status = NDIS_STATUS_SUCCESS;
    BOOLEAN                      Remaining;
    PNDIS_PACKET_STACK           PacketStack;

    //
    // NDIS provides 2 ways for IMs to indicate packets. If the IM can allocate a packet stack, it should use it as
    // it is the optimal approach. In this case, we do not have to do any per-packet copying since we don't allocate
    // a new packet.
    //

    PacketStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

    if(Remaining != 0)
    {
       //
       // The packet stack has space only for 2 DWORDs. Since we are using more than 2, we need to allocate our own 
       // memory for the per-packet block. Note that we *DONT* do this when we use the NdisAllocatePacket APIs, because
       // we initialized the packet pool to already include the space for the per-packet region.
       //

       *OurPacket = Packet;
       *PktContext = 0;
       PacketStack->IMReserved[0] = 0;

    }
    else 
    {
        Status = PsAllocateAndCopyPacket(Adapter,
                                         Packet,
                                         OurPacket,
                                         PktContext);
        
    }

    return Status;
}

NDIS_STATUS
PsDupPacketContext(
    PADAPTER Adapter,
    PNDIS_PACKET Packet,
    PPNDIS_PACKET OurPacket,
    PPS_SEND_PACKET_CONTEXT *PktContext)
{                             
    NDIS_STATUS                  Status;
    BOOLEAN                      Remaining;
    PNDIS_PACKET_STACK           PacketStack;

    //
    // NDIS provides 2 ways for IMs to indicate packets. If the IM can allocate a packet stack, it should use it as
    // it is the optimal approach. In this case, we do not have to do any per-packet copying since we don't allocate
    // a new packet.
    //

    PacketStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

    if(Remaining != 0)
    {
       //
       // The packet stack has space only for 2 DWORDs. Since we are using more than 2, we need to allocate our own 
       // memory for the per-packet block. Note that we *DONT* do this when we use the NdisAllocatePacket APIs, because
       // we initialized the packet pool to already include the space for the per-packet region.
       //

       *OurPacket = Packet;

       *PktContext = (PPS_SEND_PACKET_CONTEXT) (ULONG_PTR)NdisAllocateFromBlockPool(Adapter->SendBlockPool);
       PacketStack->IMReserved[0] = (ULONG_PTR)*PktContext;

       if(!*PktContext)
       {
          Adapter->Stats.OutOfPackets ++;
          return NDIS_STATUS_RESOURCES;
       }
       else {
           (*PktContext)->Info.NdisPacket = Packet;
           (*PktContext)->OriginalPacket = 0;
           return NDIS_STATUS_SUCCESS;
       }
    }
    else 
    {
        Status = PsAllocateAndCopyPacket(Adapter,
                                         Packet,
                                         OurPacket,
                                         PktContext);
    }

    return Status;
}



//
//  Tries to classify this packet based on the port numbers. If not found, will add it to one of the flows (in Round
//  Robin fashion) and returns a pointer to that Vc
//
PGPC_CLIENT_VC
GetVcForPacket( PPS_WAN_LINK    WanLink,
                USHORT          SrcPort,
                USHORT          DstPort)
{
    PGPC_CLIENT_VC  pVc, pVc1;
    int             i, j;


    for( j = 0; j < BEVC_LIST_LEN; j++)
    {
        
        pVc = &WanLink->BeVcList[j];

        //  Let's look at the 2 VCs we have now:
        for( i = 0; i < PORT_LIST_LEN; i++)
        {
            if( (pVc->SrcPort[i] == SrcPort) && (pVc->DstPort[i] == DstPort))
                return pVc;
        }
    }

    //  Did not find in any of the VCs. Need to choose the Next VC for insertion and insert these valuse..
    pVc = &WanLink->BeVcList[WanLink->NextVc];
    WanLink->NextVc = ((WanLink->NextVc + 1) % BEVC_LIST_LEN);

    pVc->SrcPort[pVc->NextSlot] = SrcPort;
    pVc->DstPort[pVc->NextSlot] = DstPort;
    pVc->NextSlot = ((pVc->NextSlot + 1)% PORT_LIST_LEN );
    return pVc;
}



//
//  This routine returns the Src and Dst Port numbers   
BOOLEAN
GetPortNos(
    IN      PNDIS_PACKET        Packet ,
    IN      ULONG               TransportHeaderOffset,
    IN OUT  PUSHORT             pSrcPort,
    IN OUT  PUSHORT             pDstPort
    )
{
    PNDIS_BUFFER    ArpBuf , IpBuf , TcpBuf, UdpBuf, DataBuf;
    ULONG           ArpLen , IpLen , IpHdrLen , TcpLen , UdpLen, DataLen , TotalLen , TcpHeaderOffset;
    
    VOID                *ArpH;
    IPHeader UNALIGNED  *IPH;
    TCPHeader UNALIGNED *TCPH;
    UDPHeader UNALIGNED *UDPH;

    IPAddr              Src, Dst;
    BOOLEAN             bFragment;
    USHORT              SrcPort , DstPort , IPID, FragOffset ,Size;
    PVOID               GeneralVA , Data;
    ULONG               i, Ret;


    IpBuf = NULL;

    // Steps  
    // Parse the IP Packet. 
    // Look for the appropriate ports.
    // Look for the data portion and put in the Time & length there.

    if(1)
    {
        PVOID           pAddr;
    	PNDIS_BUFFER    pNdisBuf1, pNdisBuf2;
    	UINT            Len;

        NdisGetFirstBufferFromPacket(   Packet,
                                        &ArpBuf,
                                        &ArpH,
                                        &ArpLen,
                                        &TotalLen
                                    );

    	pNdisBuf1 = Packet->Private.Head;
    	NdisQueryBuffer(pNdisBuf1, &pAddr, &Len);

    	while(Len <= TransportHeaderOffset) 
	    {

        	TransportHeaderOffset -= Len;
        	NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        	
		    NdisQueryBuffer(pNdisBuf2, &pAddr, &Len);
        	pNdisBuf1 = pNdisBuf2;
    	}

	    /* Buffer Descriptor corresponding to Ip Packet */
	    IpBuf = pNdisBuf1;

        /* Length of this Buffer (IP buffer) */
	    IpLen = Len - TransportHeaderOffset;	

	    /* Starting Virtual Address for this buffer */
	    GeneralVA = pAddr;
	    
	    /* Virtual Address of the IP Header */
	    IPH = (IPHeader *)(((PUCHAR)pAddr) + TransportHeaderOffset);
   }

    if(!IpBuf)
         return FALSE;

    IpHdrLen = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);
    
    FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
    FragOffset = net_short(FragOffset) * 8;

    bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);

    // Don't want to deal with Fragmented packets right now..//
    if ( bFragment ) 
        return FALSE;


    switch (IPH->iph_protocol) 
    {
        case IPPROTO_TCP :

            if ((USHORT)IpLen > IpHdrLen) 
            {
                // We have more than the IP Header in this MDL //
                TCPH = (TCPHeader *) ((PUCHAR)IPH + IpHdrLen);
                TcpLen = IpLen - IpHdrLen;
                TcpBuf = IpBuf;

            } 
            else 
            {
                return FALSE;
            }

            /* At this point, TcpBuf, TCPH and TcpLen contain the proper values */

            // Get the port numbers out.
            SrcPort = net_short(TCPH->tcp_src);
            DstPort = net_short(TCPH->tcp_dest);

            *pSrcPort = SrcPort;
            *pDstPort = DstPort;

            // If the packet is here, it means: The link on which it is being sent is <= MAX_LINK_SPEED_FOR_DRR.
            // So, it is OK to adjust the Window size if we are on an ICS box.

            // Note that, we only do this on WAN adapters, which do not have the checksum offload
            // capability. So, we are fine with changing the checksum.

            if(gEnableWindowAdjustment)
            {
                USHORT _old, _new;
                ULONG _sum;

                _old = (TCPH)->tcp_window;
                _new =  1460*6;

                if( net_short( _old) < _new)
                    return TRUE;

                _new = net_short( _new );
                (TCPH)->tcp_window = _new;
                
                _sum = ((~(TCPH)->tcp_xsum) & 0xffff) + ((~_old) & 0xffff) + _new;
                _sum = (_sum & 0xffff) + (_sum >> 16);
                _sum += (_sum >> 16);
                (TCPH)->tcp_xsum = (ushort) ((~_sum) & 0xffff);
            }
            
            return TRUE;

        case IPPROTO_UDP:
        
            if (IpLen > IpHdrLen)
            {
                // We have more than the IP Header in this MDL //
                UDPH = (UDPHeader *) ((PUCHAR)IPH + IpHdrLen);
                UdpLen = IpLen - IpHdrLen;
                UdpBuf = IpBuf;
            } 
            else 
            {
                return FALSE;
            }

             /* At this point, UdpBuf, UDPH and UdpLen contain the proper values */

            SrcPort = net_short(UDPH->uh_src);
            DstPort = net_short(UDPH->uh_dest);

            *pSrcPort = SrcPort;
            *pDstPort = DstPort;

            return TRUE;

        default:
                ;
        
    }

    return FALSE;    
}    
        

//
//  This where we get called for each Send
//


NTSTATUS
MpSend(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PNDIS_PACKET            TheirPacket,
    IN  UINT                    Flags
    )

/*++

Routine Description:

    Received a xmit request from a legacy transport. 

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER                 Adapter = (PADAPTER)MiniportAdapterContext;
    NDIS_STATUS              Status;
    PNDIS_PACKET             OurPacket;
    PPS_SEND_PACKET_CONTEXT  PktContext;
    PGPC_CLIENT_VC           BeVc, Vc = NULL;
    PETH_HEADER              pAddr;
    PNDIS_BUFFER             pNdisBuf1;
    UINT                     Len;
    PUSHORT                  id;
    PPS_WAN_LINK             WanLink;

    PsStructAssert(Adapter);

    //
    // If the device is shutting down, we cannot accept any more sends.
    //

    if(IsDeviceStateOn(Adapter) == FALSE)
    {
        return NDIS_STATUS_FAILURE;
    }

    if(Adapter->MediaType == NdisMediumWan)
    {
        if(Adapter->ProtocolType == ARP_ETYPE_IP)
        {
            //
            // We should not be getting non-ip packets in the NDISWAN-IP binding.
            //
            
            PsAssert(NDIS_GET_PACKET_PROTOCOL_TYPE(TheirPacket) == NDIS_PROTOCOL_ID_TCP_IP);

            pNdisBuf1 = TheirPacket->Private.Head;

            NdisQueryBuffer(pNdisBuf1, &pAddr, &Len);

            if(Len < sizeof(ETH_HEADER))
            {
                //
                // Packet is too small. we have to fail this bogus packet.
                //

                return NDIS_STATUS_FAILURE;
            }

            //
            // Get to the wanlink using the remote address from the packet.
            //

            id = (PUSHORT) &pAddr->DestAddr[0];

            PS_LOCK(&Adapter->Lock);

            WanLink = (PPS_WAN_LINK)(g_WanLinkTable[*id]);

            if(WanLink == 0)
            {
                //
                // We received a packet for a wanlink that has already gone down.
                //

                PS_UNLOCK(&Adapter->Lock);

                return NDIS_STATUS_FAILURE;
            }

            if(WanLink->State != WanStateOpen)
            {
                //
                // We received a packet for a wanlink that has already gone down.
                //

                PS_UNLOCK(&Adapter->Lock);

                return NDIS_STATUS_FAILURE;
            }

            //
            // When we get a StatusIndication for a new WAN link, NDISWAN puts context in the remote address
            // When psched intercepts the LineUp, it overwrites NDISWAN's context with its own context. Psched
            // uses this context to get to the WanLink from the packet. (see above)
            //
            // But, when it passes the packet down to NDISWAN, it needs to plumb NDISWAN's context into the packet,
            // so that NDISWAN can see the context that it sent to us, as opposed to the context that we sent up to 
            // wanarp.
            //

            NdisMoveMemory(pAddr, 
                           &WanLink->SendHeader,
                           FIELD_OFFSET(ETH_HEADER, Type));

            //
            // We optimize psched to bypass the scheduling components when there are no flows. There are a set of 
            // scheduling components per WanLink, so to be truly optimal, we need to check the FLowCount on a specific
            // WanLink.
            //

            if( (WanLink->LinkSpeed > MAX_LINK_SPEED_FOR_DRR) && (!WanLink->CfInfosInstalled) )
            {
                // Bypass scheduling components, since there are no flows created on this
                // wanlink. Note that the UserPriority is never used over wanlinks, so we can set it to 0.
               
                PS_UNLOCK(&Adapter->Lock);

                SEND_PACKET_OVER_NIC(Adapter, 
                                    TheirPacket, 
                                    0,
                                    Status);
            }
            //
            //  Now, we are going to do either (1) DiffServ Or (2) IntServ. If the packet does not belong to either 
            //  of these categories, we will just hash it into one of the BeVcs we have and do simple DRR.
            //
            else 
            {
                //
                // There is at least one flow. we need to classify this packet. Since the flow is going 
                // via the scheduling components, we have to allocate memory for the per-packet info 
                // (if the packet-stack APIs are used) or a new packet descriptor, which will include the 
                // per-packet info (if the old NDIS APIs are used) The packet that has been passed to us is 
                // 'TheirPacket'. If the packet-stack APIs are used, then TheirPacket == OurPacket 
                // if the non packet-stack APIs are used, then OurPacket == Newly Allocated Packet. 
                // 
                // In both cases, the code after this point will just use 'OurPacket' and the right thing will happen.
                //

                if((Status = PsDupPacketContext(Adapter, TheirPacket, &OurPacket, &PktContext)) != NDIS_STATUS_SUCCESS)
                {
                    PS_UNLOCK(&Adapter->Lock);
                    
                    return Status;
                }

                if (1)
                {
                    USHORT  SrcPort=0, DstPort=0;
                    //
                    // We are in RSVP mode, and we need to go to the GPC to classify the packet. 
                    // We already have a pointer to our WanLink. But, the wanlink could go away 
                    // when we release the lock and try to classify the packet. So, we take
                    // a ref on the BestEffortVc for the WanLink.
                    //


                    if( (WanLink->LinkSpeed <= MAX_LINK_SPEED_FOR_DRR)   &&
                        (GetPortNos( TheirPacket, Adapter->IPHeaderOffset, &SrcPort, &DstPort)))                    
                        BeVc = GetVcForPacket( WanLink, SrcPort, DstPort);
                    else
                        BeVc = &WanLink->BestEffortVc;
                    
                    InterlockedIncrement(&BeVc->RefCount);

                    PS_UNLOCK(&Adapter->Lock);

                    if( WanLink->CfInfosInstalled )
                        Vc = GetVcByClassifyingPacket(Adapter,  &WanLink->InterfaceID, OurPacket);

                    if(!Vc)
                    {
                        Vc = BeVc;
                    }
                    else 
                    {
                        DerefClVc(BeVc);
                    }

                    FILL_PKT_FOR_SCHED(Adapter,
                                       PktContext,
                                       Vc,
                                       OurPacket,
                                       Vc->IPPrecedenceNonConforming,
                                       Vc->UserPriorityConforming,
                                       Vc->UserPriorityNonConforming,
                                       NULL);
                }

                //
                // There is at least one flow - We need to send this packet via the scheduling
                // components. 
                //

                if((Vc->ClVcState == CL_CALL_COMPLETE) 	||
                   (Vc->ClVcState == CL_MODIFY_PENDING)	||
                   (Vc->ClVcState == CL_INTERNAL_CALL_COMPLETE)) 
                {
                    SEND_PACKET_VIA_SCHEDULER(PktContext, Vc, Adapter, OurPacket);
                }
                else
                {
                    //
                    // Deref the ref that was added by the GPC.
                    //
                    
                    DerefClVc(Vc);
                    
                    PsDbgSend(DBG_FAILURE, DBG_SEND, MP_SEND, NOT_READY, Adapter, Vc, TheirPacket, OurPacket);
                    
                    if(PktContext->OriginalPacket)
                    {
                        NdisFreePacket(OurPacket);
                    }
                    else 
                    {
                        NdisFreeToBlockPool((PUCHAR)PktContext);
                    }
                    
                    return(NDIS_STATUS_FAILURE);
                }
            }
        }
        //
        // Forget about it. It's a Non-IP packet
        //
        else 
        {
            //
            // For non IP adapters, we just send over the NIC. Note that we don't create a best effort
            // Vc for such adapters. The only thing that we lose here is the ability to mark 802.1p on
            // such packets (we don't have a Vc, so we cannot supply a UserPriority value to the below
            // macro. But that is okay, since 802.1p is meaningful only in non LAN adapters.
            //

            SEND_PACKET_OVER_NIC(Adapter, 
                                 TheirPacket, 
                                 0, 
                                 Status);
        }
    }
    else 
    {
        //
        // We have received a send at our non WAN binding.
        //

        if(!Adapter->CfInfosInstalled                   &&
           Adapter->BestEffortLimit == UNSPECIFIED_RATE )
        {
            // There is no point in trying to classify if there are no flows installed 

            Vc = &Adapter->BestEffortVc;
            
            PsAssert(Vc->ClVcState == CL_CALL_COMPLETE);

            //
            // Bypass scheduling components.
            //
            SEND_PACKET_OVER_NIC(Adapter, 
                                 TheirPacket, 
                                 Vc->UserPriorityConforming, 
                                 Status);
        }
        else 
        {
            //
            // There is at least one flow, or we are in LimitedBestEffort mode. Let's try to classify the Vc.
            // In this case, the packet will have to go via the scheduling components.
            //
            //
            // Since the flow is going via the scheduling components, we have to allocate the per-packet info.
            // (if the new NDIS APIs are used) or a new packet descriptor, which will include the per-packet info
            // (if the old NDIS APIs are used)
            //

            if(1)
            {
                // We are in RSVP mode. Let's classify with the GPC.

                Vc = GetVcByClassifyingPacket(Adapter, &Adapter->InterfaceID, TheirPacket);

                if( !Vc) 
                {
                    if( Adapter->MaxOutstandingSends == 0xffffffff)
                    {
                        Vc = &Adapter->BestEffortVc;
                
                        PsAssert(Vc->ClVcState == CL_CALL_COMPLETE);

                        //
                        // Bypass scheduling components.
                        //
                        SEND_PACKET_OVER_NIC(Adapter, 
                                             TheirPacket, 
                                             Vc->UserPriorityConforming, 
                                             Status);
                    }

                    // We will be doing DRR on this adapter; so send pkt on BeVc 
                    Vc = &Adapter->BestEffortVc;

                    InterlockedIncrement(&Vc->RefCount);
                }

                if((Status = PsDupPacketContext(Adapter, TheirPacket, &OurPacket, &PktContext)) != NDIS_STATUS_SUCCESS)
                {
                    return Status;
                }

                FILL_PKT_FOR_SCHED(Adapter,
                                   PktContext,
                                   Vc,
                                   OurPacket,
                                   Vc->IPPrecedenceNonConforming,
                                   Vc->UserPriorityConforming,
                                   Vc->UserPriorityNonConforming,
                                   NULL);

            }

            if((Vc->ClVcState == CL_CALL_COMPLETE) 	||
               (Vc->ClVcState == CL_MODIFY_PENDING)	||
               (Vc->ClVcState == CL_INTERNAL_CALL_COMPLETE)) 
            {
                SEND_PACKET_VIA_SCHEDULER(PktContext, Vc, Adapter, OurPacket);
            }
            else
            {
                //
                // Deref the ref that was added by the GPC.
                //
                
                DerefClVc(Vc);
                
                PsDbgSend(DBG_FAILURE, DBG_SEND, MP_SEND, NOT_READY, Adapter, Vc, TheirPacket, OurPacket);
                
                if(PktContext->OriginalPacket)
                {
                    NdisFreePacket(OurPacket);
                }
                else 
                {
                    NdisFreeToBlockPool((PUCHAR)PktContext);
                }
                
                
                return(NDIS_STATUS_FAILURE);
            }
        }
    } 
}


VOID
ClSendComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )

/*++

Routine Description:

    Completion routine for NdisSendPackets. 
    Does most of the work for cleaning up after a send.

    If necessary, call the PSA's send packet complete function

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PGPC_CLIENT_VC          Vc;
    PADAPTER                Adapter = (PADAPTER)ProtocolBindingContext;
    PPS_SEND_PACKET_CONTEXT PktContext;
    PNDIS_PACKET            XportPacket;
    HANDLE                  PoolHandle;

    //
    // Determine if the packet we are completing is the one we allocated. If so, get
    // the original packet from the reserved area and free the allocated packet. If this
    // is the packet that was sent down to us then just complete the packet.
    //

    PoolHandle = NdisGetPoolFromPacket(Packet);

    if(PoolHandle != Adapter->SendPacketPool)
    {
        PNDIS_PACKET_STACK PacketStack;
        BOOLEAN            Remaining;

        PacketStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

        PsAssert(Remaining != 0);

        PktContext = (PPS_SEND_PACKET_CONTEXT) PacketStack->IMReserved[0];

        if(PktContext != 0)
        {
            //
            // This packet went via the scheduling components.
            //

            PsAssert(PktContext->Vc);
            Vc = PktContext->Vc;
            PsDbgSend(DBG_INFO, DBG_SEND, CL_SEND_COMPLETE, ENTER, Adapter, Vc, Packet, 0);
            PsAssert(Vc->Adapter == Adapter);
            if(Vc->SendComplete)
                (*Vc->SendComplete)(Vc->SendCompletePipeContext, Packet);
            DerefClVc(Vc);
            NdisFreeToBlockPool((PUCHAR)PktContext);
        }

        NdisMSendComplete(Adapter->PsNdisHandle,
                          Packet,
                          Status);
    }
    else 
    {
        //
        // get the pointer to the upper layer's packet. Reinit the packet struct and
        // push it back on the adapter's packet SList. Remove the reference incurred
        // when the packet was handled by MpSend
        //

        PktContext = PS_SEND_PACKET_CONTEXT_FROM_PACKET(Packet);


        //
        // Call the scheduler if necessary
        //
        
        if(PktContext->Vc)
        {
            
            // 
            // Some packets never went through the scheduler.
            //
            Vc = PktContext->Vc;
            
            PsDbgSend(DBG_INFO, DBG_SEND, CL_SEND_COMPLETE, ENTER, Adapter, Vc, Packet, 0);
            
            PsAssert(Vc->Adapter == Adapter);
            
            if(Vc->SendComplete)
            {
                (*Vc->SendComplete)(Vc->SendCompletePipeContext, Packet);
            }
            
            //
            // We have taken a ref on the VCs when we sent the packets
            // through the scheduling components. Now is the time to 
            // Deref them
            //

            DerefClVc(Vc);
        }
        else
        {
            PsDbgSend(DBG_INFO, DBG_SEND, CL_SEND_COMPLETE, ENTER, Adapter, 0, Packet, 0);
        }
        
        XportPacket = PktContext->OriginalPacket;
        
        NdisIMCopySendCompletePerPacketInfo(XportPacket, Packet);
        
        NdisFreePacket(Packet);
        
        NdisMSendComplete(Adapter->PsNdisHandle, 
                          XportPacket,
                          Status);
    }
        
} // ClSendComplete


VOID
DropPacket(
    IN HANDLE PipeContext,
    IN HANDLE FlowContext,
    IN PNDIS_PACKET Packet,
    IN NDIS_STATUS Status
    )

/*++

Routine Description:

    Drop a packet after it was queued by the scheduler.

Arguments:

    PipeContext -       Pipe context (adapter)
    FlowContext -       Flow context (adapter VC)
    Packet -            Packet to drop
    Status -            Return code to return to NDIS
                        
Return Values:          

    None

--*/

{
    PGPC_CLIENT_VC          Vc = (PGPC_CLIENT_VC)FlowContext;
    PADAPTER                Adapter = (PADAPTER)PipeContext;
    PPS_SEND_PACKET_CONTEXT PktContext;
    PNDIS_PACKET            XportPacket;
    HANDLE                  PoolHandle;

    //
    // Determine if the packet we are completing is the one we allocated. If so, get
    // the original packet from the reserved area and free the allocated packet. If this
    // is the packet that was sent down to us then just complete the packet.
    //

    PoolHandle = NdisGetPoolFromPacket(Packet);

    if(PoolHandle != Adapter->SendPacketPool)
    {
        PNDIS_PACKET_STACK PacketStack;
        BOOLEAN            Remaining;

        PacketStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);

        PsAssert(Remaining != 0);

        PktContext = (PPS_SEND_PACKET_CONTEXT) PacketStack->IMReserved[0];

        PsAssert(PktContext != 0);
        PsAssert(Vc == PktContext->Vc);
        PsAssert(Adapter == Vc->Adapter);
        NdisFreeToBlockPool((PUCHAR)PktContext);

        NdisMSendComplete(Adapter->PsNdisHandle,
                          Packet,
                          Status);

    }
    else 
    {    
        PktContext = PS_SEND_PACKET_CONTEXT_FROM_PACKET(Packet);

        PsAssert(PktContext != 0);
        PsAssert(Vc == PktContext->Vc);
        PsAssert(Adapter == Vc->Adapter);

        XportPacket = PktContext->OriginalPacket;

        NdisFreePacket(Packet);

        NdisMSendComplete(Adapter->PsNdisHandle,
                          XportPacket,
                          Status);
    }

    Vc->Stats.DroppedPackets ++;

    PsDbgSend(DBG_INFO, DBG_SEND, DROP_PACKET, ENTER, Adapter, Vc, Packet, 0);

    DerefClVc(Vc);

} // DropPacket


char*
ReturnByteAtOffset( PNDIS_PACKET    pNdisPacket, ULONG  Offset)
{
    PVOID         VA;
    PNDIS_BUFFER  pNdisBuf1, pNdisBuf2;
    UINT          Len;

    pNdisBuf1 = pNdisPacket->Private.Head;
    NdisQueryBuffer(pNdisBuf1, &VA, &Len);

    while(Len <= Offset) 
    {
        Offset -= Len;
        NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        NdisQueryBuffer(pNdisBuf2, &VA, &Len);
        pNdisBuf1 = pNdisBuf2;
    }

    return (char*)(((char*)VA) + Offset);
}


PGPC_CLIENT_VC FASTCALL
GetVcByClassifyingPacket(
    PADAPTER Adapter,
    PTC_INTERFACE_ID pInterfaceID,
    PNDIS_PACKET OurPacket
    )
/*+++


---*/
{
    CLASSIFICATION_HANDLE  ClassificationHandle;
    PGPC_CLIENT_VC         Vc = NULL;
    NDIS_STATUS            Status;
    ULONG                  ProtocolType;

    //
    // Let's act based on the ClassificationType we read from the registry key.
    // This is specific to debug version only.
    // case 0: (default): Use preclassification information, classify otherwise
    // case 1: Use prelcassification information ONLY
    // case 2: Use classification information ONLY
    //
  
    ClassificationHandle = (CLASSIFICATION_HANDLE)
        PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(OurPacket, ClassificationHandlePacketInfo));

#if DBG
    if (ClassificationType == 2) {
        ClassificationHandle = 0;
    }
#endif


    if (ClassificationHandle)
    {

        PsAssert(GpcEntries.GpcGetCfInfoClientContextHandler);
    
        Vc =  GpcEntries.GpcGetCfInfoClientContextWithRefHandler(GpcQosClientHandle, 
                                                                 ClassificationHandle,
                                                                 FIELD_OFFSET(GPC_CLIENT_VC, RefCount));

        //
        // If we got a Vc that was not destined for this adapter, we have to reject it.
        //

        if(Vc)
        {
            if(Vc->Adapter != Adapter)
            {
                DerefClVc(Vc);
            }
            else
                return Vc;
        }
    }

#if DBG
    if (ClassificationType == 1) {
        return NULL;
    }
#endif
    

    //        
    // Let's classify this packet since we did not get a Classification ID or a proper Vc.
    //
                                  
    PsAssert(GpcEntries.GpcClassifyPacketHandler);

    switch(NDIS_GET_PACKET_PROTOCOL_TYPE(OurPacket))
    {
        case NDIS_PROTOCOL_ID_TCP_IP:
            ProtocolType = GPC_PROTOCOL_TEMPLATE_IP;
            break;
        case NDIS_PROTOCOL_ID_IPX:
            ProtocolType = GPC_PROTOCOL_TEMPLATE_IPX;
            break;
        default:
            ProtocolType = GPC_PROTOCOL_TEMPLATE_NOT_SPECIFIED;
            break;
    }

    //
    //  If the adapter type is 802.5 (Token Ring), then the MAC header can be of variable size.
    //  The format of the MAC header is as follows:
    //  +---------------------+-------------+----------+-----------
    //  | 2 + 6 (DA) + 6 (SA) | Optional RI | 8 (SNAP) |    IP
    //  +---------------------+-------------+----------+-----------
    //  Optional RI is present if and only if RI bit as part of SA is set.
    //  When RI is present, its length is give by the lower 5 bits of the 15th byte.

    //  1. Get the VA for the 9th and the 15th bytes.
    //  2. If RI if not present, Offset = 14 + 6.
    //  3. If present, Offset = 14 + 6 + RI-Size.

    if(Adapter->MediaType == NdisMedium802_5)
    {
	    PNDIS_BUFFER			pTempNdisBuffer;
	    PUCHAR					pHeaderBuffer;
        ULONG					BufferLength;
	    ULONG					TotalLength;
	    ULONG                   IpOffset;

	    NdisGetFirstBufferFromPacket(   OurPacket, 
                        				&pTempNdisBuffer, 
                        				&pHeaderBuffer,
                        				&BufferLength,
                        				&TotalLength);

        ASSERT( BufferLength >= 15);                        				    

        if( (*(ReturnByteAtOffset(OurPacket, 8)) & 0x80) == 0)
            IpOffset = 14 + 8;
        else
            IpOffset = 14 + 8 + (*(ReturnByteAtOffset(OurPacket, 14)) & 0x1f);

        Status = GpcEntries.GpcClassifyPacketHandler(
                   GpcQosClientHandle,
                   ProtocolType,
                   OurPacket,
                   IpOffset,
                   pInterfaceID,
                   (PGPC_CLIENT_HANDLE)&Vc,
                   &ClassificationHandle);

    }
    else
    {
        PNDIS_BUFFER	  pTempNdisBuffer;
        PUCHAR			  pHeaderBuffer;
        ULONG		        BufferLength;
	    ULONG                 TotalLength;
	    ULONG                 IpOffset;
        PVOID         VA;
        PNDIS_BUFFER  pNdisBuf1, pNdisBuf2;
        UINT          Len;
        ENetHeader UNALIGNED * EHdr;

        pNdisBuf1 = OurPacket->Private.Head;
        NdisQueryBuffer(pNdisBuf1, &VA, &Len);

        EHdr = (ENetHeader UNALIGNED *)VA;

        if (EHdr == NULL)
            return NULL;

        // We don't want to do any fancy parsing other than this. If the frame
        // is not of standard ethernet type, bail out.
        if ((Adapter->MediaType == NdisMedium802_3) && (net_short(EHdr->eh_type) >= MIN_ETYPE))
        {
            ULONG FrameOffset;

            // The conditional is basically to cover up a bug in wandrv.sys, which gives 
            // bogus frame header sizes. We look at the IP Header offset supplied 
            // by the protocol above for IP packets only, as we are saving only 
            // those for the time being.

            if ((NDIS_GET_PACKET_PROTOCOL_TYPE(OurPacket) == NDIS_PROTOCOL_ID_TCP_IP) && 
                (Adapter->IPHeaderOffset)) {
                FrameOffset = Adapter->IPHeaderOffset;
            } else {
                FrameOffset = Adapter->HeaderSize;
            }

            Status = GpcEntries.GpcClassifyPacketHandler(
                        GpcQosClientHandle,
                        ProtocolType,
                        OurPacket,
                        FrameOffset,
                        pInterfaceID,
                        (PGPC_CLIENT_HANDLE)&Vc,
                        &ClassificationHandle);
        } else {
            return NULL;
        }

    }                           

    if(Status == GPC_STATUS_SUCCESS)
    {
        //
        // If we have succeeded, we must get a Classification Handle
        //
        PsAssert(ClassificationHandle != 0);

        //
        // The Classification succeeded. If we found a ClassificationHandle
        // then we must write it in the packet so that anyone below us can use
        // it. The very fact that we are here indicates that we did not start
        // with a Classification handle or we got a bad one. So, we need not 
        // worry about over writing the classification handle in the packet.
        //

        NDIS_PER_PACKET_INFO_FROM_PACKET(OurPacket, ClassificationHandlePacketInfo) = 
                                            UlongToPtr(ClassificationHandle);
        
        Vc =  GpcEntries.GpcGetCfInfoClientContextWithRefHandler(
                    GpcQosClientHandle, 
                    ClassificationHandle,
                    FIELD_OFFSET(GPC_CLIENT_VC, RefCount));
    }

    if(Vc && Vc->Adapter != Adapter)
    {
        //
        // We have used the GPC APIs that return a Vc with a ref. We have to 
        // deref here, because we got a wrong Vc for this adapter.
        //
        
        DerefClVc(Vc);

        return NULL;
    }

    return Vc;
}

VOID
ClCoSendComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PNDIS_PACKET Packet
    )
{
    PGPC_CLIENT_VC          Vc = (PGPC_CLIENT_VC) ProtocolVcContext;

    ClSendComplete(Vc->Adapter,
                   Packet,
                   Status);
} // ClCoSendComplete

/* end send.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\schedt.c ===
/*++
Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    schedt.c

Abstract:
    Psched Tracing support

Author:
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/
#include "psched.h"
#pragma hdrstop

//
// Globals
//

NDIS_SPIN_LOCK         GlobalLoggingLock;
ULONG                  SchedTraceIndex;
ULONG                  SchedBufferSize;
ULONG                  SchedTraced;
UCHAR                  *SchedTraceBuffer;
ULONG                  SchedBufferStart;
ULONG                  SchedTraceBytesUnread;
ULONG                  SchedTraceThreshold;
PVOID                  SchedTraceThreshContext;
SCHEDTRACE_THRESH_PROC SchedTraceThreshProc;
BOOLEAN                TraceBufferAllocated;

VOID
SchedInitialize(
    ULONG BufferSize)
{

    SchedBufferSize = BufferSize;

    TraceBufferAllocated = FALSE;

    PsAllocatePool(SchedTraceBuffer, SchedBufferSize, PsMiscTag);

    if(SchedTraceBuffer){

        TraceBufferAllocated = TRUE;
        NdisAllocateSpinLock(&GlobalLoggingLock);
    }
    else {
    
        TraceBufferAllocated = FALSE;
    }
}

VOID
SchedDeInitialize(
)
{
    if(TraceBufferAllocated) 
    {
        PsFreePool(SchedTraceBuffer);
        
        TraceBufferAllocated = FALSE;
    }
        
    NdisFreeSpinLock(&GlobalLoggingLock);
}


VOID
DbugTraceSetThreshold(
    ULONG       Threshold,
    PVOID       Context,
    SCHEDTRACE_THRESH_PROC ThreshProc)
{
    ULONG bytesToCopyAtEnd;
    ULONG bytesToCopyAtStart;

    NdisAcquireSpinLock(&GlobalLoggingLock);

    SchedTraceThreshProc = ThreshProc;
    SchedTraceThreshold = (Threshold <= SchedBufferSize) ? Threshold : SchedBufferSize;
    SchedTraceThreshContext = Context;

    if ((SchedTraceThreshContext != NULL) && (SchedTraceBytesUnread >= SchedTraceThreshold)) {
        SchedTraceThreshContext = NULL;
        NdisReleaseSpinLock(&GlobalLoggingLock);
        (*ThreshProc)(Context);
    }
    else {
        NdisReleaseSpinLock(&GlobalLoggingLock);
    }
} 


VOID
DbugReadTraceBuffer(
    PUCHAR      Buffer,
    ULONG       BytesToRead,
    PULONG      BytesRead
    )
{
    ULONG bytesToCopyAtEnd;
    ULONG bytesToCopyAtStart;
    ULONG bytesToCopy;
    ULONG startIndex;

    // Copy the most recently added bytes to the user buffer.  If BytesToRead is less than
    // the number of unread bytes in the trace buffer, the older bytes are lost.  This
    // ensures that the last record in the user buffer is complete (as long as the user
    // buffer is big enough to accommodate at least that one record).

    NdisAcquireSpinLock(&GlobalLoggingLock);

    bytesToCopy = (SchedTraceBytesUnread <= BytesToRead) ? SchedTraceBytesUnread : BytesToRead;
    startIndex = (bytesToCopy  > SchedTraceIndex) ?
            SchedTraceIndex + SchedBufferSize - bytesToCopy :
            SchedTraceIndex - bytesToCopy;

    if ((startIndex + bytesToCopy) > SchedBufferSize) {
        bytesToCopyAtEnd = SchedBufferSize - startIndex;
        bytesToCopyAtStart = bytesToCopy - bytesToCopyAtEnd;
        RtlCopyMemory(Buffer, &SchedTraceBuffer[startIndex], bytesToCopyAtEnd);
        RtlCopyMemory(Buffer + bytesToCopyAtEnd, &SchedTraceBuffer[0], bytesToCopyAtStart); 
    }
    else {
        bytesToCopyAtEnd = bytesToCopy;
        RtlCopyMemory(Buffer, &SchedTraceBuffer[startIndex], bytesToCopy);
    }

    SchedTraceBytesUnread = 0;
    *BytesRead = bytesToCopy;
    NdisReleaseSpinLock(&GlobalLoggingLock);

} 


NTSTATUS
WriteRecord(
    UCHAR * Record,
    ULONG   Bytes
    )
{
    ULONG bytesToCopyAtEnd;
    ULONG bytesToCopyAtStart;
    SCHEDTRACE_THRESH_PROC ThreshProc;
    PVOID Context;

    if(!TraceBufferAllocated){

        return(STATUS_UNSUCCESSFUL);
    }

    NdisAcquireSpinLock(&GlobalLoggingLock);

    if((SchedTraceIndex + Bytes) > SchedBufferSize){
        bytesToCopyAtEnd = SchedBufferSize - SchedTraceIndex;
        bytesToCopyAtStart = Bytes - bytesToCopyAtEnd;
        RtlCopyMemory(&SchedTraceBuffer[SchedTraceIndex], Record, bytesToCopyAtEnd);
        RtlCopyMemory(&SchedTraceBuffer[0], (UCHAR *)Record + bytesToCopyAtEnd, bytesToCopyAtStart); 
        SchedTraceIndex = bytesToCopyAtStart;
        SchedTraced += Bytes;
    }
    else{
        bytesToCopyAtEnd = Bytes;
        RtlCopyMemory(&SchedTraceBuffer[SchedTraceIndex], Record, Bytes);
        SchedTraceIndex += Bytes;
        SchedTraced += Bytes;
    }

    SchedTraceBytesUnread += Bytes;
    if (SchedTraceBytesUnread > SchedBufferSize) {
        SchedTraceBytesUnread = SchedBufferSize;
    }

    if ((SchedTraceThreshContext != NULL) && (SchedTraceBytesUnread >= SchedTraceThreshold)) {
        ThreshProc = SchedTraceThreshProc;
        Context = SchedTraceThreshContext;
        SchedTraceThreshContext = NULL;
        NdisReleaseSpinLock(&GlobalLoggingLock);
        (*ThreshProc)(Context);
    }
    else {
        NdisReleaseSpinLock(&GlobalLoggingLock);
    }
    return(STATUS_SUCCESS);
}

#define ClearRecord(x, y) \
            RtlFillMemory(x, y, 0)

VOID
DbugSchedString(char *format, ...)
{
    TRACE_RECORD_STRING record;
    CHAR buffer[TRACE_STRING_LENGTH];
    va_list va;

    va_start(va, format);
    _vsnprintf(buffer, TRACE_STRING_LENGTH-1, format, va);
    va_end(va);

    ClearRecord(&record, sizeof(TRACE_RECORD_STRING));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_TSTRING;
    PsGetCurrentTime(&record.Now);
    strncpy(record.StringStart, buffer, TRACE_STRING_LENGTH);

    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_STRING));
    return;
}

VOID
DbugRecv(
    ULONG Event,
    ULONG Action,
    PVOID Adapter,
    PNDIS_PACKET Packet1,
    PNDIS_PACKET Packet2
    )
{
    TRACE_RECORD_RECV record;

    ClearRecord(&record, sizeof(TRACE_RECORD_RECV));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_RECV;
    PsGetCurrentTime(&record.Now);
    record.Event = Event;
    record.Action = Action;
    record.Adapter = Adapter;
    record.Packet1 = Packet1;
    record.Packet2 = Packet2;

    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_RECV));
}

VOID
DbugSend(
    ULONG Event,
    ULONG Action,
    PVOID Adapter,
    PVOID Vc,
    PNDIS_PACKET Packet1,
    PNDIS_PACKET Packet2
    )
{
    TRACE_RECORD_SEND record;

    ClearRecord(&record, sizeof(TRACE_RECORD_SEND));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_SEND;
    PsGetCurrentTime(&record.Now);
    record.Event = Event;
    record.Action = Action;
    record.Adapter = Adapter;
    record.Vc = Vc;
    record.Packet1 = Packet1;
    record.Packet2 = Packet2;

    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_SEND));
}

VOID DbugOid(
    ULONG Action,
    ULONG Local,
    ULONG PTState,
    ULONG MPState,
    PVOID Adapter,
    ULONG Oid,
    ULONG Status
    )
{
    TRACE_RECORD_OID record;

    ClearRecord(&record, sizeof(TRACE_RECORD_OID));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_OID;
    PsGetCurrentTime(&record.Now);
    record.Action = Action;
    record.Local = Local;
    record.Oid = Oid;
    record.PTState = PTState;
    record.MPState = MPState;
    record.Adapter = Adapter;
    record.Status = Status;

    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_OID));
}

VOID
DbugSchedPkts(
    ULONG CallingFunction,
    PVOID VC,
    PNDIS_PACKET Packet,
    ULONG Action,
    ULONG PacketLength)
{
    TRACE_RECORD_PKT record;

    ClearRecord(&record, sizeof(TRACE_RECORD_PKT));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_PKT;
    record.CallingFunction = CallingFunction;
    PsGetCurrentTime(&record.Now);
    record.VC = VC;
    record.Packet = Packet;
    record.Action = Action;
    record.PacketLength = PacketLength;
    
    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_PKT));
}

VOID
DbugSched(
    ULONG SchedulerComponent,
    ULONG Action,
    PVOID VC,
    PNDIS_PACKET Packet,
    ULONG PacketLength,
    ULONG Priority,
    LONGLONG ArrivalTime,
    LONGLONG ConformanceTime,
    ULONG PacketsInComponent,
    ULONG BytesInComponent
    )
{
    TRACE_RECORD_SCHED record;

    ClearRecord(&record, sizeof(TRACE_RECORD_SCHED));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_SCHED;
    record.SchedulerComponent = SchedulerComponent;
    PsGetCurrentTime(&record.Now);
    record.Action = Action;
    record.VC = VC;
    record.Packet = Packet;
    record.PacketLength = PacketLength;
    record.Priority = Priority;
    record.ArrivalTime = ArrivalTime,
    record.ConformanceTime = ConformanceTime;
    record.PacketsInComponent = PacketsInComponent;
    record.BytesInComponent = BytesInComponent;
    
    WriteRecord((UCHAR *)&record, sizeof(TRACE_RECORD_SCHED));
}

VOID
DbugComponentSpecificRec(
    ULONG Component,
    PVOID Data,
    ULONG Length)
{
    TRACE_RECORD_COMPONENT_SPECIFIC record;

    ClearRecord(&record, sizeof(TRACE_RECORD_COMPONENT_SPECIFIC));

    record.Preamble = TRACE_PREAMBLE;
    record.RecordType = RECORD_COMPONENT_SPECIFIC;
    record.SchedulerComponent = Component;
    PsGetCurrentTime(&record.Now);
    record.Length = (Length > MAX_RECORD_DATA) ? MAX_RECORD_DATA : Length;
    RtlCopyMemory(record.Data, Data, record.Length);
    
    WriteRecord((UCHAR *)&record, record.Length + FIELD_OFFSET(TRACE_RECORD_COMPONENT_SPECIFIC, Data));
}

ULONG
SchedtGetBufferSize()
{
    return SchedBufferSize;
}

ULONG
SchedtGetBytesUnread() 
{
    return SchedTraceBytesUnread;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\schedt.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    schedt.h

Abstract:

    defines for psched's tracing support

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/

#ifndef _SCHEDTRACE_
#define _SCHEDTRACE_


typedef VOID (*SCHEDTRACE_THRESH_PROC)( PVOID Context);

#define TRACE_BUFFER_SIZE 1000 * 1024
#define TRACE_STRING_LENGTH 127
#define MAX_RECORD_DATA 200
#define TRACE_PREAMBLE 0xdeadbeef

// Record types

#define RECORD_TSTRING             1
#define RECORD_RECV                2
#define RECORD_PKT                 3
#define RECORD_SCHED               4
#define RECORD_COMPONENT_SPECIFIC  5
#define RECORD_SEND                6
#define RECORD_OID                 7


// Receive actions (must be kept in sync with kdps)

#define ENTER           (ULONG)1
#define NO_RESOURCES    (ULONG)2
#define LOW_RESOURCES   (ULONG)3
#define INDICATING      (ULONG)4
#define RETURNED        (ULONG)5
#define NOT_OURS        (ULONG)6
#define OURS            (ULONG)7
#define RETURNING       (ULONG)8
#define TRANSFERRING    (ULONG)9
#define NOT_READY       (ULONG)10

// Receive events (must be kept in sync with kdps)

#define CL_RECV_PACKET  (ULONG)1
#define MP_RETURN_PACKET (ULONG)2
#define CL_RECV_IND     (ULONG)3
#define CL_RECV_COMPL   (ULONG)4
#define MP_XFER_DATA    (ULONG)5
#define CL_XFER_COMPL   (ULONG)6

// Send actions 
#define MP_SEND    (ULONG) 1
#define MP_CO_SEND (ULONG) 2
#define DUP_PACKET (ULONG) 3
#define DROP_PACKET (ULONG) 4
#define CL_SEND_COMPLETE (ULONG) 5

// Packet actions (must be kept in sync with kdps)

#define SUBMIT          (ULONG)1
#define SEND            (ULONG)2
#define SEND_COMPLETE   (ULONG)3
#define DROP            (ULONG)4
#define CO_SEND         (ULONG)5

// Scheduler actions (must be kept in sync with kdps)

#define PKT_ENQUEUE     (ULONG)1
#define PKT_DEQUEUE     (ULONG)2
#define PKT_CONFORMANCE (ULONG)3
#define PKT_DISCARD     (ULONG)4

// ID for Scheduler modules
// Note! LAST_LOG_ID should be at the very 
// end. The add-in components use IDs that
// begin from LAST_LOG_ID
#define TBC_CONFORMER   (ULONG)1
#define SHAPER          (ULONG)2
#define DRR_SEQUENCER   (ULONG)3
#define LAST_LOG_ID     (ULONG)4

typedef struct _TraceRecordString {
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    UCHAR           StringStart[TRACE_STRING_LENGTH];
} TRACE_RECORD_STRING;

#define TRACE_OID_MP_SETINFORMATION       1
#define TRACE_OID_MP_QUERYINFORMATION     2
#define TRACE_OID_SET_REQUEST_COMPLETE    3
#define TRACE_OID_QUERY_REQUEST_COMPLETE  4

typedef struct _TraceRecordOid {
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           Oid;
    ULONG           Local; 
    ULONG           Action; 
    ULONG           PTState; 
    ULONG           MPState; 
    PVOID           Adapter;
    ULONG           Status;
} TRACE_RECORD_OID;

typedef struct _TraceRecordRecv{
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           Event;
    ULONG           Action;
    PVOID           Adapter;
    PNDIS_PACKET    Packet1;
    PNDIS_PACKET    Packet2;
} TRACE_RECORD_RECV;

typedef struct _TraceRecordSend {
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           Event;
    ULONG           Action;
    PVOID           Adapter;
    PNDIS_PACKET    Packet1;
    PNDIS_PACKET    Packet2;
    PVOID           Vc;
} TRACE_RECORD_SEND;

typedef struct _TraceRecordPkts{
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           CallingFunction;
    PVOID           VC;
    PNDIS_PACKET    Packet;
    ULONG           PacketLength;
    ULONG           Action;
    LONGLONG        AbsoluteTime;
} TRACE_RECORD_PKT;

typedef struct _TraceRecordSched{
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           SchedulerComponent;
    ULONG           Action;
    PVOID           VC;
    PNDIS_PACKET    Packet;
    ULONG           PacketLength;
    ULONG           Priority;
    LONGLONG        ArrivalTime;
    LONGLONG        ConformanceTime;
    ULONG           PacketsInComponent;
    ULONG           BytesInComponent;
} TRACE_RECORD_SCHED;
    

typedef struct _TraceRecordComponentSpecific{
    LONG            Preamble;
    SHORT           RecordType;
    LARGE_INTEGER   Now;
    ULONG           SchedulerComponent;
    ULONG           Length;
    UCHAR           Data[MAX_RECORD_DATA];
} TRACE_RECORD_COMPONENT_SPECIFIC;


VOID DbugOid(
    ULONG Action,
    ULONG Local,
    ULONG PTState,
    ULONG MPState,
    PVOID Adapter,
    ULONG Oid,
    ULONG Status
    );

VOID
DbugSchedString(char *format, ...);

VOID
DbugRecv(
    ULONG Event,
    ULONG Action,
    PVOID Adapter,
    PNDIS_PACKET Packet1,
    PNDIS_PACKET Packet2
    );

VOID
DbugSend(
    ULONG Event,
    ULONG Action,
    PVOID Adapter,
    PVOID Vc,
    PNDIS_PACKET Packet1,
    PNDIS_PACKET Packet2
    );

VOID
DbugSchedPkts(
    ULONG CallingFunction,
    PVOID VC,
    PNDIS_PACKET Packet, 
    ULONG Action,
    ULONG PacketLength
    );

VOID
DbugSched(
    ULONG SchedulerComponent,
    ULONG Action,
    PVOID VC,
    PNDIS_PACKET Packet,
    ULONG PacketLength,
    ULONG Priority,
    LONGLONG ArrivalTime,
    LONGLONG ConformanceTime,
    ULONG PacketsInComponent,
    ULONG BytesInComponent
    );

VOID
DbugComponentSpecificRec(
    ULONG SchedulerComponent,
    PVOID Data,
    ULONG Length
    );

VOID
DbugTraceSetThreshold(
    ULONG       Threshold,
    PVOID       Context,
    SCHEDTRACE_THRESH_PROC ThreshProc
    );

VOID
DbugReadTraceBuffer(
    PUCHAR      Buffer,
    ULONG       BytesToRead,
    PULONG      BytesRead
    );

NTSTATUS
WriteRecord(
    UCHAR * Record,
    ULONG   Bytes
    );

VOID
SchedInitialize(ULONG BufferSize);

VOID SchedDeInitialize();

ULONG
SchedtGetBufferSize();

ULONG
SchedtGetBytesUnread();

#endif _SCHEDTRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\stats.h ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    stats.h

Abstract:

    Defintions for getting statistics from driver

Author:

    Charlie Wickham (charlwi) 09-Mar-1995

Revision History:

--*/

#ifndef _STATS_
#define _STATS_

/* Prototypes */ /* Generated by Emacs 19.17.0 on Tue Apr 04 14:03:00 1995 */

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

NTSTATUS
GetStats(
    PVOID ioBuffer,
    ULONG inputBufferLength,
    PULONG outputBufferLength
    );

ULONG
RunningAverage(
    IN  PRUNNING_AVERAGE RunningAverage,
    IN  ULONG NewValue
    );

NDIS_STATUS
CreateAveragingArray(
    OUT PRUNNING_AVERAGE *RunningAverage,
    IN  ULONG ArraySize
    );

VOID
DeleteAveragingArray(
    PRUNNING_AVERAGE RunningAverage
    );

/* End Prototypes */

#endif /* _STATS_ */

/* end stats.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\stats.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    stats.c

Abstract:

    routines for PS statistics

Author:

    Yoram Bernet    (yoramb)    23-May-1998
    Rajesh Sundaram (rajeshsu)  01-Aug-1998

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

/* End Forward */

NDIS_STATUS
CreateAveragingArray(
    OUT PRUNNING_AVERAGE *RunningAverage,
    IN  ULONG ArraySize
    )
{
    PRUNNING_AVERAGE runningAverage;
    ULONG i;

    PsAllocatePool(runningAverage, 
                   sizeof(RUNNING_AVERAGE), 
                   PsMiscTag); 

    if(!runningAverage)
    {
        *RunningAverage = NULL;
        return(NDIS_STATUS_RESOURCES);
    }

    PsAllocatePool(runningAverage->Elements, 
                   ArraySize * sizeof(ULONG),
                   PsMiscTag);

    if(!runningAverage->Elements)
    {
        PsFreePool(runningAverage);

        *RunningAverage = NULL;

        return(NDIS_STATUS_RESOURCES);
    }

    for(i=0; i < ArraySize; i++){

        runningAverage->Elements[i] = 0;
    }

    runningAverage->Index = 0;
    runningAverage->Sum = 0;
    runningAverage->Size = ArraySize;

    *RunningAverage = runningAverage;
    return(NDIS_STATUS_SUCCESS);
}

ULONG
RunningAverage(
    IN  PRUNNING_AVERAGE RunningAverage,
    IN  ULONG NewValue
    )
{
    ULONG i;

    i = RunningAverage->Index;

    RunningAverage->Sum -= RunningAverage->Elements[i];
    RunningAverage->Sum += NewValue;
    RunningAverage->Elements[i] = NewValue;

    if(++i == RunningAverage->Size){

        i = 0;
    }

    RunningAverage->Index = i;

    return((RunningAverage->Sum)/(RunningAverage->Size));
}

VOID
DeleteAveragingArray(
    PRUNNING_AVERAGE RunningAverage
    )
{
    PsFreePool(RunningAverage->Elements);
    PsFreePool(RunningAverage);
}



/* End stats.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\status.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    status.c

Abstract:

    status indications handled in here....

Author:

    Charlie Wickham (charlwi)  20-Jun-1996
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */

VOID
ClStatusIndication(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
ClStatusIndicationComplete(
    IN  NDIS_HANDLE BindingContext
    );

/* End Forward */


VOID
ClStatusIndication(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    )

/*++

Routine Description:

    Called by the NIC via NdisIndicateStatus

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;
    NDIS_STATUS Status;
    ULONG ErrorLogData[2];
    PVOID Context;

    PsDbgOut(DBG_TRACE, 
             DBG_PROTOCOL, 
             ("(%08X) ClStatusIndication: Status %08X\n", 
             Adapter, 
             GeneralStatus));

    // General rule:
    // If our device is not ready, we cannot forward the status indication. 
    // Yes - we care about the Media connect and link speed oids. We will 
    // query for these OIDs when we get to D0.
    //

    // (i) Special case for media_status. <need to pass it up>
    // Condition is that: 
    //	(Adapter state is OFF, so we can't process it ourselves)	AND
    //	(Status indication is about 'connect' or 'disconnect')		AND
    //	(Adapter state is 'running')							AND
    //	(Adapter has a binding handle for the protocol above)	
    // We will process fix our internal state when we wake up and go back to D0.
    if( 	(IsDeviceStateOn(Adapter) == FALSE)		&& 
    		((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT))	&&
    		(Adapter->PsMpState == AdapterStateRunning )	&&
    		(Adapter->PsNdisHandle != NULL) )
	{
        NdisMIndicateStatus(Adapter->PsNdisHandle, 
                        GeneralStatus, 
                        StatusBuffer, 
                        StatusBufferSize );

        return;
    	}        
    
    // (ii) Special case for wan-line-down: <need to process it>
    // This is a special case for wan_line_down. Need to forward it even if the adapter is not in D0.
    if( (IsDeviceStateOn(Adapter) == FALSE)	&& (GeneralStatus != NDIS_STATUS_WAN_LINE_DOWN) )
    {
        return;
    }

    //
    // we cannot forward status indications until we have been called in our
    // MpInitialize handler. But we need to look at certain events even if we
    // are not called in the MpInitialize handler. Otherwise, we could lose these
    // indications.
    //

    switch(GeneralStatus)
    {
      case NDIS_STATUS_MEDIA_CONNECT:
      case NDIS_STATUS_LINK_SPEED_CHANGE:

          PsGetLinkSpeed(Adapter);
          
          break;
          
      case NDIS_STATUS_MEDIA_DISCONNECT:
          
          //
          // reset the link speed so definite rate flows can be 
          // admitted.
          //
          
          Adapter->RawLinkSpeed = (ULONG)UNSPECIFIED_RATE;
          UpdateAdapterBandwidthParameters(Adapter);
          
          break;

      default:
          break;
    }
          
    //   
    // Our virtual adapter has not been initialized. We cannot forward this indication.
    //

    if(Adapter->PsMpState != AdapterStateRunning || Adapter->PsNdisHandle == NULL) 
    {
        return;
    }

    //
    // For these WAN related indications, we have to send them to wanarp 
    //  So, there is no point in looking at these if our virtual adapter has not been initialized.
    //

    switch(GeneralStatus) 
    {
      case NDIS_STATUS_WAN_LINE_UP:
      {
          if(Adapter->ProtocolType == ARP_ETYPE_IP)
          {
              
              //
              // This will call NdisMIndicateStatus, so we have to return
              // directly.
              //

              Status = CreateInterfaceForNdisWan(Adapter,
                                                 StatusBuffer, 
                                                 StatusBufferSize);
              return;
          }

          break;
      }
          
      case NDIS_STATUS_WAN_LINE_DOWN:
          
          //
          // NDISWAN link has been torn down.
          //
          if(Adapter->ProtocolType == ARP_ETYPE_IP)
          {
              DeleteInterfaceForNdisWan(Adapter,
                                        StatusBuffer, 
                                        StatusBufferSize);
              return;
          }
          
          break;
          
      default:
          
          break;
          
    }

    //
    // now indicate the status to the upper layer. 
    //

    NdisMIndicateStatus(Adapter->PsNdisHandle, 
                        GeneralStatus, 
                        StatusBuffer, 
                        StatusBufferSize );

} // ClStatusIndication



VOID
ClStatusIndicationComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    )

/*++

Routine Description:

    Called by the NIC via NdisIndicateStatusComplete

Arguments:

    See the DDK...

Return Values:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PsDbgOut(DBG_TRACE, DBG_PROTOCOL, ("(%08X) ClStatusIndicationComplete\n", Adapter));

    if ( Adapter->PsNdisHandle != NULL) { 

        NdisMIndicateStatusComplete( Adapter->PsNdisHandle );
    }

} // ClStatusIndication

/* end status.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\status.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    status.h

Abstract:

    defines for status handlers

Author:

    Charlie Wickham (charlwi) 20-Jun-1996

Revision History:

--*/

#ifndef _STATUS_
#define _STATUS_

/* Prototypes */

VOID
ClStatusIndication(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
ClStatusIndicationComplete(
    IN  NDIS_HANDLE BindingContext
    );

/* End Prototypes */

#endif /* _STATUS_ */

/* end status.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\wmi.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    wmi.h

Abstract:

    defines for psched's WMI support

Author:

    Rajesh Sundaram (rajeshsu)

Revision History:

--*/

NTSTATUS
PsTcNotify(IN PADAPTER Adapter, 
           IN PPS_WAN_LINK WanLink,
           IN NDIS_OID Oid,
           IN PVOID    StatusBuffer,
           IN ULONG    StatusBufferSize);

NTSTATUS
WMIDispatch(
	IN	PDEVICE_OBJECT	pdo,
	IN	PIRP			pirp
	);

NTSTATUS
GenerateInstanceName(
    IN PNDIS_STRING     Prefix,
    IN PADAPTER         Adapter,
    IN PLARGE_INTEGER   Index,
    OUT PNDIS_STRING    pInstanceName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\timestmp.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:
    TimeStmp.c

Abstract:
    TimeStamp module

Author:
    Shreem, Sanjayka

Environment:
    Kernel Mode

Revision History:

--*/

#include "psched.h"

#pragma hdrstop


// The pipe information
typedef struct _TS_PIPE
{
    // ContextInfo -    Generic context info
    PS_PIPE_CONTEXT         ContextInfo;
} TS_PIPE, *PTS_PIPE;


// The flow information
typedef struct _TS_FLOW 
{
    // ContextInfo -            Generic context info
    PS_FLOW_CONTEXT ContextInfo;
} TS_FLOW, *PTS_FLOW;


/* Global variables */
LIST_ENTRY      TsList;
NDIS_SPIN_LOCK  TsSpinLock;
ULONG           TsCount;


/* Static */

/* Forward */

NDIS_STATUS
TimeStmpInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    );

NDIS_STATUS
TimeStmpModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    );

VOID
TimeStmpDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    );

NDIS_STATUS
TimeStmpCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    );

NDIS_STATUS
TimeStmpModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    );

VOID
TimeStmpDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );

VOID
TimeStmpEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    );    

VOID
TimeStmpSetInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN void *Data);

VOID
TimeStmpQueryInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status);


NDIS_STATUS 
TimeStmpCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

NDIS_STATUS 
TimeStmpDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    );

BOOLEAN
TimeStmpSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK Packet
    );

BOOLEAN
TimeStmpReceivePacket (
    IN PPS_PIPE_CONTEXT         PipeContext,
    IN PPS_FLOW_CONTEXT         FlowContext,
    IN PPS_CLASS_MAP_CONTEXT    ClassMapContext,
    IN PNDIS_PACKET             Packet,
    IN NDIS_MEDIUM              Medium
    );

BOOLEAN
TimeStmpReceiveIndication(
                          IN PPS_PIPE_CONTEXT PipeContext,
                          IN PPS_FLOW_CONTEXT FlowContext,
                          IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
                          IN PVOID    HeaderBuffer,
                          IN UINT     HeaderBufferSize,
                          IN PVOID    LookAheadBuffer,
                          IN UINT     LookAheadBufferSize,
                          IN UINT     PacketSize,
                          IN UINT     TransportHeaderOffset
                          );


/* End Forward */


VOID
InitializeTimeStmp( PPSI_INFO Info )
{
    Info->PipeContextLength = ((sizeof(TS_PIPE)+7) & ~7);
    Info->FlowContextLength = ((sizeof(TS_FLOW)+7) & ~7);
    Info->ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
    Info->InitializePipe = TimeStmpInitializePipe;
    Info->ModifyPipe = TimeStmpModifyPipe;
    Info->DeletePipe = TimeStmpDeletePipe;
    Info->CreateFlow = TimeStmpCreateFlow;
    Info->ModifyFlow = TimeStmpModifyFlow;
    Info->DeleteFlow = TimeStmpDeleteFlow;
    Info->EmptyFlow =  TimeStmpEmptyFlow;
    Info->CreateClassMap = TimeStmpCreateClassMap;
    Info->DeleteClassMap = TimeStmpDeleteClassMap;
    Info->SubmitPacket = TimeStmpSubmitPacket;
    Info->ReceivePacket = NULL;
    Info->ReceiveIndication = NULL;
    Info->SetInformation = TimeStmpSetInformation;
    Info->QueryInformation = TimeStmpQueryInformation;

    NdisAllocateSpinLock(&TsSpinLock);
    InitializeListHead( &TsList );

    TsCount = 0;
} 


NDIS_STATUS
TimeStmpInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    )
{
    PPS_PIPE_CONTEXT Pipe = ComponentPipeContext;

    return (*Pipe->NextComponent->InitializePipe)(
        PsPipeContext,
        PipeParameters,
        Pipe->NextComponentContext,
        PsProcs,
        Upcalls);
}



NDIS_STATUS
TimeStmpModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    return (*Pipe->NextComponent->ModifyPipe)(
        Pipe->NextComponentContext, PipeParameters);
}



VOID
TimeStmpDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

     (*Pipe->NextComponent->DeletePipe)(Pipe->NextComponentContext);
}


NDIS_STATUS
TimeStmpCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    return (*Pipe->NextComponent->CreateFlow)(
                Pipe->NextComponentContext,
                PsFlowContext,
                CallParameters,
                ComponentFlowContext->NextComponentContext);
}


NDIS_STATUS
TimeStmpModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    return (*Pipe->NextComponent->ModifyFlow)(
                Pipe->NextComponentContext,
                FlowContext->NextComponentContext,
                CallParameters);
    
}


VOID
TimeStmpDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    (*Pipe->NextComponent->DeleteFlow)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext);
}


VOID
TimeStmpEmptyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    (*Pipe->NextComponent->EmptyFlow)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext);
}



VOID
TimeStmpSetInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN void *Data)
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    PPS_FLOW_CONTEXT Flow = FlowContext;

    (*Pipe->NextComponent->SetInformation)(
        Pipe->NextComponentContext,
        (Flow)?Flow->NextComponentContext:0,
        Oid,
        Len,
        Data);
}



VOID
TimeStmpQueryInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    PPS_FLOW_CONTEXT Flow = FlowContext;

    (*Pipe->NextComponent->QueryInformation)(
        Pipe->NextComponentContext,
        (Flow)?Flow->NextComponentContext:0,
        Oid,
        Len,
        Data,
        BytesWritten,
        BytesNeeded,
        Status);
}


NDIS_STATUS 
TimeStmpCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    )
{
    return (*PipeContext->NextComponent->CreateClassMap)(
        PipeContext->NextComponentContext,
        PsClassMapContext,
        ClassMap,
        ComponentClassMapContext->NextComponentContext);
}

NDIS_STATUS 
TimeStmpDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    )
{
    return (*PipeContext->NextComponent->DeleteClassMap)(
        PipeContext->NextComponentContext,
        ComponentClassMapContext->NextComponentContext);
}



/*  Routine Description:
        Checks to see if there is any application requesting time-stamping for these end-points

    Return Value:
        MARK_NONE, MARK_IN_PKT, MARK_IN_BUF
*/        

int
CheckForMatch(  ULONG   SrcIp, 
                ULONG   DstIp, 
                USHORT  SrcPort, 
                USHORT  DstPort,
                USHORT  Proto,
                USHORT  IpId,
                USHORT  Size,
                USHORT  Direction)
{
	PLIST_ENTRY		ListEntry;
	PTS_ENTRY		pEntry;
	int             Status = MARK_NONE;

    NdisAcquireSpinLock(&TsSpinLock);
 
	ListEntry = TsList.Flink;
	
	while (ListEntry != &TsList) 
	{
        pEntry = CONTAINING_RECORD(ListEntry, TS_ENTRY, Linkage);

        if( ((pEntry->SrcIp == UL_ANY)      || (pEntry->SrcIp == SrcIp))            &&
		    ((pEntry->SrcPort== US_ANY)     || (pEntry->SrcPort == SrcPort))        &&
		    ((pEntry->DstIp == UL_ANY)      || (pEntry->DstIp == DstIp))            &&
		    ((pEntry->DstPort  == US_ANY)   || (pEntry->DstPort == DstPort))        &&
		    ((pEntry->Direction == US_ANY)  || (pEntry->Direction == Direction))    &&
            ((pEntry->Proto == US_ANY)      || (pEntry->Proto == Proto)))
        {
    		if(pEntry->Type == MARK_IN_BUF)
    		{
    		    LARGE_INTEGER           PerfFrequency, CurrentTime;
                UINT64                  RecdTime, Freq;
    		    MARK_IN_BUF_RECORD	    Record, *pRecord;

                Status = MARK_IN_BUF;

                if((int)( (char*)pEntry->pPacketStore - (char*)pEntry->pPacketStoreHead 
                            + sizeof(MARK_IN_BUF_RECORD) ) < PACKET_STORE_SIZE )
                {
                    pEntry->pPacketStore->IpId = IpId;
    			    pEntry->pPacketStore->Size = Size;

                    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                    // Convert the perffrequency into 100ns interval. //
                    Freq = 0;
                    Freq |= PerfFrequency.HighPart;
                    Freq = Freq << 32;
                    Freq |= PerfFrequency.LowPart;

                    pEntry->pPacketStore->TimeValue = 0;
                    pEntry->pPacketStore->TimeValue  |= CurrentTime.HighPart;
                    pEntry->pPacketStore->TimeValue  = pEntry->pPacketStore->TimeValue  << 32;
                    pEntry->pPacketStore->TimeValue  |= CurrentTime.LowPart;
    		
    		        // Normalize cycles with the frequency //
                    pEntry->pPacketStore->TimeValue  *= 10000000;
                    pEntry->pPacketStore->TimeValue  /= Freq;

                    pEntry->pPacketStore = (PMARK_IN_BUF_RECORD)((char*)pEntry->pPacketStore + sizeof(MARK_IN_BUF_RECORD));
                }                
                else
    		    {
    			    pEntry->pPacketStore = pEntry->pPacketStoreHead;
    		    }


                NdisReleaseSpinLock(&TsSpinLock);
    			return Status;
    		} 
    		else if(pEntry->Type == MARK_IN_PKT)
    		{
    		    Status = MARK_IN_PKT;
    		    NdisReleaseSpinLock(&TsSpinLock);
    			return Status;
    		}
        }
		else 
		{
			ListEntry = ListEntry->Flink;
		}
	}

    NdisReleaseSpinLock(&TsSpinLock);
	return Status;
}


/*  Routine Description:
        Adds an end-point to the list of monitoring end-points 
        
    Return Value:
        TRUE, FALSE
*/  
BOOL
AddRequest(  PFILE_OBJECT FileObject, 
             ULONG  SrcIp, 
             USHORT SrcPort,
             ULONG  DstIp, 
             USHORT DstPort,
             USHORT Proto,
             USHORT Type,
             USHORT Direction)
{
    PTS_ENTRY   pEntry = NULL;

    PsAllocatePool(pEntry, sizeof(TS_ENTRY), TsTag);

    if( !pEntry )
        return FALSE;
                        
    InitializeListHead(&pEntry->Linkage);

    pEntry->SrcIp   = SrcIp;
    pEntry->SrcPort = SrcPort;
    pEntry->DstIp   = DstIp;
    pEntry->DstPort = DstPort;
    pEntry->Proto   = Proto;
    pEntry->Type    = Type;
    pEntry->Direction = Direction;

    pEntry->FileObject = FileObject;
    pEntry->pPacketStore = NULL;
    pEntry->pPacketStoreHead = NULL;

    if(Type == MARK_IN_BUF)
    {   
        PsAllocatePool( pEntry->pPacketStoreHead, PACKET_STORE_SIZE, TsTag );

        if( !pEntry->pPacketStoreHead)
        {
            PsFreePool( pEntry );
            return FALSE;
        }

        pEntry->pPacketStore = pEntry->pPacketStoreHead;
    }

    NdisAcquireSpinLock(&TsSpinLock);

    /* Need to check for duplication ..*/
    InsertHeadList(&TsList, &pEntry->Linkage);

    InterlockedIncrement( &TsCount );

    NdisReleaseSpinLock(&TsSpinLock);

    return TRUE;
}


/*  Routine Description:
        Removes an end-point to the list of monitoring end-points 
        
    Return Value:
        None
        
    Note:
        Here, 0xffffffff means, wild card => Don't have to match on that field */
void
RemoveRequest(  PFILE_OBJECT FileObject, 
                ULONG  SrcIp, 
                USHORT SrcPort,
                ULONG  DstIp, 
                USHORT DstPort,
                USHORT Proto)
{
    PLIST_ENTRY		ListEntry;
    PTS_ENTRY       pEntry;

    NdisAcquireSpinLock(&TsSpinLock);

	ListEntry = TsList.Flink;

	while (ListEntry != &TsList) 
	{

		pEntry = CONTAINING_RECORD(ListEntry, TS_ENTRY, Linkage);								

		if( ((FileObject == ULongToPtr(UL_ANY)) || (pEntry->FileObject == FileObject))  &&
		    ((SrcIp == UL_ANY)                  || (pEntry->SrcIp == SrcIp))            &&
		    ((SrcPort == US_ANY)                || (pEntry->SrcPort == SrcPort))        &&
		    ((DstIp == UL_ANY)                  || (pEntry->DstIp == DstIp))            &&
		    ((DstPort == US_ANY)                || (pEntry->DstPort == SrcPort))        &&
            ((Proto== US_ANY)                   || (pEntry->Proto == Proto)))
        {		    
		    RemoveEntryList(&pEntry->Linkage);

		    if( pEntry->pPacketStoreHead)
		        PsFreePool( pEntry->pPacketStoreHead );
		        
		    PsFreePool( pEntry );

		    InterlockedDecrement( &TsCount );

		    /* Need to go back to the beginning of the list againg.. */
		    ListEntry = TsList.Flink;
		}
		else
		{
		    ListEntry = ListEntry->Flink;
		}
	}

    NdisReleaseSpinLock(&TsSpinLock);
}


int
CopyTimeStmps( PFILE_OBJECT FileObject, PVOID buf, ULONG    Len)
{
    PLIST_ENTRY		ListEntry;
    PTS_ENTRY       pEntry;
    ULONG           DataLen;
    LARGE_INTEGER   LargeLen;

    if( Len < PACKET_STORE_SIZE )
        return 0;

    NdisAcquireSpinLock(&TsSpinLock);

	ListEntry = TsList.Flink;

	while (ListEntry != &TsList) 
	{

		pEntry = CONTAINING_RECORD(ListEntry, TS_ENTRY, Linkage);								

		if( pEntry->FileObject == FileObject)
		{		    
		    // Copy the data across and rest the pointers.. //

		    LargeLen.QuadPart = ((char*)pEntry->pPacketStore) - ((char*)pEntry->pPacketStoreHead);

            DataLen = LargeLen.LowPart;
            
            NdisMoveMemory( buf, pEntry->pPacketStoreHead, DataLen);
            pEntry->pPacketStore = pEntry->pPacketStoreHead;	

            NdisReleaseSpinLock(&TsSpinLock);
            return DataLen;
		}
		else
		{
		    ListEntry = ListEntry->Flink;
		}
	}

    NdisReleaseSpinLock(&TsSpinLock);
    return 0;
}



VOID
UnloadTimeStmp( )
{
    // Clear all the Requests //
    RemoveRequest(  ULongToPtr(UL_ANY), 
                    UL_ANY, 
                    US_ANY,
                    UL_ANY,
                    US_ANY,
                    US_ANY);

    // Free the spin lock //
    NdisFreeSpinLock(&TsSpinLock);
} 




BOOLEAN
TimeStmpSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )
{
    PTS_PIPE        Pipe = (PTS_PIPE)PipeContext;
    PTS_FLOW        Flow = (PTS_FLOW)FlowContext;
    PNDIS_PACKET    Packet = PacketInfo->NdisPacket;

    PNDIS_BUFFER    ArpBuf , IpBuf , TcpBuf, UdpBuf, DataBuf;
    ULONG           ArpLen , IpLen , IpHdrLen , TcpLen , UdpLen, DataLen , TotalLen , TcpHeaderOffset;
    
    VOID                *ArpH;
    IPHeader UNALIGNED  *IPH;
    TCPHeader UNALIGNED *TCPH;
    UDPHeader UNALIGNED *UDPH;

    IPAddr              Src, Dst;
    BOOLEAN             bFragment;
    USHORT              SrcPort , DstPort , IPID, FragOffset ,Size;
    PVOID               GeneralVA , Data;
    ULONG               i, Ret;


    if( (TsCount == 0)  ||
        (NDIS_GET_PACKET_PROTOCOL_TYPE(Packet) != NDIS_PROTOCOL_ID_TCP_IP))
    {
        goto SUBMIT_NEXT;
    }        

    IpBuf = NULL;

    // Steps  
    // Parse the IP Packet. 
    // Look for the appropriate ports.
    // Look for the data portion and put in the Time & length there.

    if(1)
    {
        PVOID           pAddr;
    	PNDIS_BUFFER    pNdisBuf1, pNdisBuf2;
    	UINT            Len;
        ULONG	        TransportHeaderOffset = 0;

    	TransportHeaderOffset = PacketInfo->IPHeaderOffset;

        NdisGetFirstBufferFromPacket(   Packet,
                                        &ArpBuf,
                                        &ArpH,
                                        &ArpLen,
                                        &TotalLen
                                    );

    	pNdisBuf1 = Packet->Private.Head;
    	NdisQueryBuffer(pNdisBuf1, &pAddr, &Len);

    	while(Len <= TransportHeaderOffset) 
	    {

        	TransportHeaderOffset -= Len;
        	NdisGetNextBuffer(pNdisBuf1, &pNdisBuf2);
        	
		    NdisQueryBuffer(pNdisBuf2, &pAddr, &Len);
        	pNdisBuf1 = pNdisBuf2;
    	}

	    /* Buffer Descriptor corresponding to Ip Packet */
	    IpBuf = pNdisBuf1;

        /* Length of this Buffer (IP buffer) */
	    IpLen = Len - TransportHeaderOffset;	

	    /* Starting Virtual Address for this buffer */
	    GeneralVA = pAddr;
	    
	    /* Virtual Address of the IP Header */
	    IPH = (IPHeader *)(((PUCHAR)pAddr) + TransportHeaderOffset);
   }

    if(!IpBuf)
         goto SUBMIT_NEXT;

    /* Let's try to parse the packet */
    Src = IPH->iph_src;
    Dst = IPH->iph_dest;
    IPID = net_short(IPH->iph_id);
    Size = net_short(IPH->iph_length);
    IpHdrLen = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);
    
    FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
    FragOffset = net_short(FragOffset) * 8;

    bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);

    // Don't want to deal with Fragmented packets right now..//
    if ( bFragment ) 
        goto SUBMIT_NEXT;


    switch (IPH->iph_protocol) 
    {
        case IPPROTO_TCP :

            if (IPH && ((USHORT)IpLen > IpHdrLen)) 
            {
                // We have more than the IP Header in this MDL //
                TCPH = (TCPHeader *) ((PUCHAR)IPH + IpHdrLen);
                TcpLen = IpLen - IpHdrLen;
                TcpBuf = IpBuf;

            } 
            else 
            {
                // TCP Header is in the next MDL //                
                NdisGetNextBuffer(IpBuf, &TcpBuf);

                if(!TcpBuf) 
                    goto SUBMIT_NEXT;

                GeneralVA = NULL;
                NdisQueryBuffer(TcpBuf,
                                &GeneralVA,
                                &TcpLen
                                );
            
                TCPH = (TCPHeader *) GeneralVA;
            }

            /* At this point, TcpBuf, TCPH and TcpLen contain the proper values */

            // Get the port numbers out.
            SrcPort = net_short(TCPH->tcp_src);
            DstPort = net_short(TCPH->tcp_dest);

            // We have the TCP Buffer now. Get to the DATA //
            TcpHeaderOffset = TCP_HDR_SIZE(TCPH);

            if (TcpLen > TcpHeaderOffset) 
            {
                // We have the DATA right here! //
                Data = (PUCHAR)TCPH + TcpHeaderOffset;
                DataLen = TcpLen - TcpHeaderOffset;

            } 
            else 
            {
                NdisGetNextBuffer(TcpBuf, &DataBuf);

                if(!DataBuf) 
                    goto SUBMIT_NEXT;

                GeneralVA = NULL;

                NdisQueryBuffer(DataBuf,
                                &Data,
                                &DataLen
                                );
            }

            /* At this point, DataBuf, Data and DataLen contain the proper values */
            goto TimeStamp;
            break;

        case IPPROTO_UDP:
        
            if (IpLen > IpHdrLen)
            {
                // We have more than the IP Header in this MDL //
                UDPH = (UDPHeader *) ((PUCHAR)IPH + IpHdrLen);
                UdpLen = IpLen - IpHdrLen;
                UdpBuf = IpBuf;
            } 
            else 
            {
                // UDP Header is in the next MDL //
                NdisGetNextBuffer(IpBuf, &UdpBuf);

                if(!UdpBuf)
                    goto SUBMIT_NEXT;

                GeneralVA = NULL;
                NdisQueryBuffer(UdpBuf,
                                &GeneralVA,
                                &UdpLen
                                );

                UDPH = (UDPHeader *) GeneralVA;
            }

             /* At this point, UdpBuf, UDPH and UdpLen contain the proper values */

            SrcPort = net_short(UDPH->uh_src);
            DstPort = net_short(UDPH->uh_dest);

            // Get to the data. //
            if (UdpLen > sizeof (UDPHeader)) 
            {
                // We have the DATA right here! //
                Data = (PUCHAR) UDPH + sizeof (UDPHeader);
                DataLen = UdpLen - sizeof (UDPHeader);
            } 
            else 
            {
                NdisGetNextBuffer(UdpBuf, &DataBuf);

                if(!DataBuf) 
                    goto SUBMIT_NEXT;

                GeneralVA = NULL;
                NdisQueryBuffer(DataBuf,
                                &Data,
                                &DataLen
                                );
            }

            /* At this point, DataBuf, Data and DataLen contain the proper values */
            goto TimeStamp;
            break;

        default:
            goto SUBMIT_NEXT;
    }


TimeStamp:

    Ret = CheckForMatch( Src, Dst, SrcPort, DstPort, IPH->iph_protocol, IPID, Size, DIR_SEND);
    
    if( Ret == MARK_IN_PKT)
    {
       if (DataLen >= sizeof(MARK_IN_PKT_RECORD))
       {
            LARGE_INTEGER           PerfFrequency, CurrentTime;
            UINT64                  RecdTime, Freq;
            PMARK_IN_PKT_RECORD     pRecord;

            pRecord     = (PMARK_IN_PKT_RECORD) Data;
            CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

            pRecord->BufferSize = DataLen;

            // Convert the perffrequency into 100ns interval //

            Freq = 0;
            Freq |= PerfFrequency.HighPart;
            Freq = Freq << 32;
            Freq |= PerfFrequency.LowPart;

            // convert to uint64 //

            pRecord->TimeSentWire = 0;
            pRecord->TimeSentWire |= CurrentTime.HighPart;
            pRecord->TimeSentWire = pRecord->TimeSentWire << 32;
            pRecord->TimeSentWire |= CurrentTime.LowPart;

            // Normalize cycles with the frequency.
            pRecord->TimeSentWire *= 10000000;
            pRecord->TimeSentWire /= Freq;

            if(IPH->iph_protocol == IPPROTO_UDP)
                UDPH->uh_xsum = 0;
        }    
    }
    else if( Ret == MARK_IN_BUF)
    {
        //  Nothing more to be done..
    }
    
SUBMIT_NEXT: 
    return (*Pipe->ContextInfo.NextComponent->SubmitPacket)(
                    Pipe->ContextInfo.NextComponentContext,
                    Flow->ContextInfo.NextComponentContext,
                    (ClassMapContext != NULL) ? ClassMapContext->NextComponentContext : NULL,
                    PacketInfo);
}




BOOLEAN
TimeStmpReceivePacket (
    IN PPS_PIPE_CONTEXT         PipeContext,
    IN PPS_FLOW_CONTEXT         FlowContext,
    IN PPS_CLASS_MAP_CONTEXT    ClassMapContext,
    IN PNDIS_PACKET             Packet,
    IN NDIS_MEDIUM              Medium
    )
{
    PPS_PIPE_CONTEXT    Pipe;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH;
    TCPHeader UNALIGNED *TCPH;
    UDPHeader UNALIGNED *UDPH;
    IPAddr              Src, Dst;
    PUCHAR              headerBuffer, pData;
    PNDIS_BUFFER        pFirstBuffer;
    ULONG               firstbufferLength, bufferLength, HeaderLength;
    ULONG               TotalIpLen, IPDataLength, IpHdrLen;
    ULONG               TotalTcpLen, TcpDataLen, TotalLen, TcpHeaderOffset, i;
    int                 TotalUdpLen, UdpDataLen, UdpHdrLen, DataLen, Ret;
    USHORT              SrcPort, DstPort, IPID, FragOffset, Size;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;


    /* This will give the size of the "media-specific" header. So, this will be the offset to IP packet */
    UINT                HeaderBufferSize ;

    ushort          type;                       // Protocol type
    uint            ProtOffset;                 // Offset in Data to non-media info.

    if( ( TsCount == 0) ||
        (NDIS_GET_PACKET_PROTOCOL_TYPE(Packet) == NDIS_PROTOCOL_ID_TCP_IP))
    {        
        return TRUE;
    }        

    Pipe = PipeContext;
    HeaderBufferSize = NDIS_GET_PACKET_HEADER_SIZE(Packet);

    NdisGetFirstBufferFromPacket(Packet,                // packet
                                 &pFirstBuffer,         // first buffer descriptor
                                 &headerBuffer,         // VA of the first buffer
                                 &firstbufferLength,    // length of the header+lookahead
                                 &bufferLength);        // length of the bytes in the buffers

    IPH = (IPHeader *) ((PUCHAR)headerBuffer + HeaderBufferSize);
    
    // Check the header length and the version //
    HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);

    // If the HeaderLength seems to be incorrect, let's not try to parse //
    if( (HeaderLength < sizeof(IPHeader))   ||
        (HeaderLength > bufferLength) )
        return TRUE;        

    // Get past the IP Header and get the rest of the stuff out //
    TotalIpLen = (uint)net_short(IPH->iph_length);

    // Make sure the version and IpData Len are correct //
    if( ((IPH->iph_verlen & IP_VER_FLAG) != IP_VERSION )    ||
        ( TotalIpLen < HeaderLength )                       ||
        ( TotalIpLen > bufferLength ))
        return TRUE;
    
    // Let's try to parse the packet //
    Src = IPH->iph_src;
    Dst = IPH->iph_dest;
    IPID = net_short(IPH->iph_id);
    Size = net_short(IPH->iph_length);

    FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
    FragOffset = net_short(FragOffset) * 8;

    bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
    bFirstFragment = bFragment && (FragOffset == 0);
    bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

    // If this is a fragment and NOT the first one, just put the Timestamp in here.
    // Otherwise, let it get to the protocols for processing.
    if (bFragment ) 
        return TRUE;

    // Do the protocol specific stuff //
    switch (IPH->iph_protocol) 
    {
        case IPPROTO_TCP:

            TotalTcpLen = TotalIpLen - HeaderLength;
            TCPH = (TCPHeader *) (((PUCHAR)IPH) + HeaderLength);

            // For TCP, the data offset is part of the TCP Header */
            TcpHeaderOffset = TCP_HDR_SIZE(TCPH);
            DataLen = TotalTcpLen - TcpHeaderOffset;
            pData = (PUCHAR) TCPH + TcpHeaderOffset;

            SrcPort = net_short(TCPH->tcp_src);
            DstPort = net_short(TCPH->tcp_dest);

            goto TimeStmp;
            break;

        case IPPROTO_UDP:
        
            TotalUdpLen = TotalIpLen - HeaderLength;
            UDPH = (UDPHeader *) (((PUCHAR)IPH) + HeaderLength);

            // For UDP, the header size is fixed //
            DataLen = TotalUdpLen - sizeof(UDPHeader);
            pData = ((PUCHAR) UDPH) + sizeof (UDPHeader);

            SrcPort = net_short(UDPH->uh_src);
            DstPort = net_short(UDPH->uh_dest);

            goto TimeStmp;
            break;

        default:
            break;
    }

    return TRUE;


TimeStmp:

    Ret = CheckForMatch( Src, Dst, SrcPort, DstPort, IPH->iph_protocol, IPID, Size, DIR_RECV);
    
    if( Ret == MARK_IN_PKT)
    {
       if (DataLen >= sizeof(MARK_IN_PKT_RECORD))
       {
            LARGE_INTEGER           PerfFrequency, CurrentTime;
            UINT64                  RecdTime, Freq;
            PMARK_IN_PKT_RECORD     pRecord;

            pRecord     = (PMARK_IN_PKT_RECORD) pData;
            CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

            // Convert the perffrequency into 100ns interval //
            Freq = 0;
            Freq |= PerfFrequency.HighPart;
            Freq = Freq << 32;
            Freq |= PerfFrequency.LowPart;

            //convert from large_integer to uint64

            pRecord->TimeReceivedWire = 0;
            pRecord->TimeReceivedWire |= CurrentTime.HighPart;
            pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
            pRecord->TimeReceivedWire |= CurrentTime.LowPart;

            // Normalize cycles with the frequency.
            pRecord->TimeReceivedWire *= 10000000;
            pRecord->TimeReceivedWire /= Freq;

            if(IPH->iph_protocol == IPPROTO_UDP)
                UDPH->uh_xsum = 0;
        }    
    }
    else if( Ret == MARK_IN_BUF)
    {
    
    }      

    return TRUE;
}



#ifdef NEVER


//
// This function receives a buffer from NDIS which is indicated to the transport.
// We use this function and work past the headers (tcp, ip) and get to the data.
// Then, we timestamp and reset the checksum flags.
// We make the assumption that the lookahead is atleast 128. 
// mac header ~ 8+8, ip header ~20, tcp/udp ~ 20+options, LOG_RECORD ~ 44
// they all add up to less than 128. If this is not a good assumption, We will need
// to get into MiniportTransferData and such.
//
BOOLEAN
TimeStmpReceiveIndication(
                          IN PPS_PIPE_CONTEXT PipeContext,
                          IN PPS_FLOW_CONTEXT FlowContext,
                          IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
                          IN PVOID    HeaderBuffer,
                          IN UINT     HeaderBufferSize,
                          IN PVOID    LookAheadBuffer,
                          IN UINT     LookAheadBufferSize,
                          IN UINT     PacketSize,
                          IN UINT     TransportHeaderOffset
                          )
{
    PPS_PIPE_CONTEXT    Pipe = PipeContext;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH    = NULL;
    TCPHeader UNALIGNED *TCPH   = NULL;
    UDPHeader UNALIGNED *UDPH   = NULL;
    IPAddr              Src, Dst;
    PUCHAR              headerBuffer = NULL, pData = NULL;
    PNDIS_BUFFER        pFirstBuffer = NULL;
    ULONG               firstbufferLength = 0, bufferLength = 0, HeaderLength = 0;
    ULONG               TotalIpLen = 0, IPDataLength = 0, IpHdrLen = 0;
    ULONG               TotalTcpLen = 0, TcpDataLen = 0, TotalLen = 0, TcpHeaderOffset = 0;
    ULONG               TotalUdpLen = 0, UdpDataLen = 0, UdpHdrLen = 0;
    USHORT              SrcPort = 0, DstPort = 0, IPID = 0, FragOffset = 0, Size = 0;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;
    ULONG               i = 0;
    ushort              type;                       // Protocol type
    uint                ProtOffset;                 // Offset in Data to non-media info.
    UINT                MoreHeaderInLookAhead = 0;

    // Don't know anything about the MAC headers, piggy back from PSCHED...
    // Calculate if the header is more than the standard HeaderBufferSize (i.e. SNAP header, etc.)
    //
    MoreHeaderInLookAhead = TransportHeaderOffset - HeaderBufferSize;

    if (MoreHeaderInLookAhead) 
    {
        // Just munge these, so that we can actually get down to business //
        ((PUCHAR) LookAheadBuffer) += MoreHeaderInLookAhead;
        LookAheadBufferSize -= MoreHeaderInLookAhead;
    }

    if (LookAheadBufferSize > sizeof(IPHeader)) 
    {
        IPH = (IPHeader *) (PUCHAR)LookAheadBuffer;
    
        // Check the header length and the version. If any of these
        // checks fail silently discard the packet.
        HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);

        if (HeaderLength >= sizeof(IPHeader) && HeaderLength <= LookAheadBufferSize) 
        {
            // Get past the IP Header and get the rest of the stuff out//
            TotalIpLen = (uint)net_short(IPH->iph_length);

            if ((IPH->iph_verlen & IP_VER_FLAG) == IP_VERSION &&
                TotalIpLen >= HeaderLength  && TotalIpLen <= LookAheadBufferSize) 
            {
                Src = IPH->iph_src;
                Dst = IPH->iph_dest;
                IPID = net_short(IPH->iph_id);
		        Size = net_short(IPH->iph_length );

                FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
                FragOffset = net_short(FragOffset) * 8;

                bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
                bFirstFragment = bFragment && (FragOffset == 0);
                bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

                // If this is a fragment and NOT the first one, just put the Timestamp in here.
                // Otherwise, let it get to the protocols for processing.
                if (bFragment ) 
			        return TRUE;

                // Do the protocol specific stuff.//

                switch (IPH->iph_protocol) 
                {
                case IPPROTO_TCP:
            
                    TotalTcpLen = TotalIpLen - HeaderLength;
                    TCPH = (TCPHeader *) (((PUCHAR)IPH) + HeaderLength);

                    SrcPort = net_short(TCPH->tcp_src);
                    DstPort = net_short(TCPH->tcp_dest);


                    TcpHeaderOffset = TCP_HDR_SIZE(TCPH);
                    pData = (PUCHAR) TCPH + TcpHeaderOffset;
                    TcpDataLen = TotalTcpLen - TcpHeaderOffset;

                    goto TimeStmp;
                    break;

                case IPPROTO_UDP:
            
                    TotalUdpLen = TotalIpLen - HeaderLength;
                    UDPH = (UDPHeader *) (((PUCHAR)IPH) + HeaderLength);
                
                    UdpDataLen = TotalUdpLen - sizeof(UDPHeader);
                    pData = ((PUCHAR) UDPH) + sizeof (UDPHeader);

                    SrcPort = net_short(UDPH->uh_src);
                    DstPort = net_short(UDPH->uh_dest);

                    if (UdpDataLen < sizeof(UDPHeader)) 
                        return TRUE;

                    goto TimeStmp;                        
                    break;

                default:
                    break;
                }
            }
        }
    }
TimeStmp:

    CheckForMatch( Src, Dst, SrcPort, DstPort,0, IPID, Size, DIR_RECV);
/*
    if (CheckInPortAndIpList(Src, DstPort))  
    {                    
                    LARGE_INTEGER   PerfFrequency;
                    UINT64          RecdTime, Freq;
		    LOG_RECORD	    Record;


			pRecord = &Record;			
                        CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                        //
                        // Convert the perffrequency into 100ns interval.
                        //
                        Freq = 0;
                        Freq |= PerfFrequency.HighPart;
                        Freq = Freq << 32;
                        Freq |= PerfFrequency.LowPart;

                        pRecord->TimeReceivedWire = 0;
                        pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                        pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                        pRecord->TimeReceivedWire |= CurrentTime.LowPart;

                        // Normalize cycles with the frequency.
                        pRecord->TimeReceivedWire *= 10000000;
                        pRecord->TimeReceivedWire /= Freq;

			if(  (int)( (char*)pPacketStore - (char*)pPacketStoreHead + sizeof(PACKET_RECORD) ) < PACKET_STORE_SIZE )	
			{
				pPacketStore->IpId = IPID;
				pPacketStore->cSeperator1='y';
				pPacketStore->TimeValue = pRecord->TimeReceivedWire;
				pPacketStore->cSeperator2 = 'm';
				pPacketStore->Size = Size;
				pPacketStore->cSeperator3 = 'z';
				pPacketStore->cSeperator4 = 'z';
				

				pPacketStore = (PPACKET_RECORD)((char*)pPacketStore + sizeof(PACKET_RECORD));
			}
			else
			{
				pPacketStore = pPacketStoreHead;
			}
			
        }
*/     

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\zaw\zaw.c ===
#include <stdarg.h>
#include <stdio.h>
//#include <windows.h>
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
#include<stdarg.h>
#include<tchar.h>
#include<windows.h>
#include <wmium.h>
#include <tcguid.h>
#include <netevent.h>
VOID
SendPschedIoctl(
    )

/*++

Routine Description:

    Does device i/o control with the driver for IOCTL_PSCHED_ZAW_EVENT. This kicks psched to read the registry.

Arguments:

    None.

Return Value:

    None.

 --*/
{

    HANDLE   PschedDriverHandle;
    ULONG    BytesReturned;
    BOOL     IOStatus;

    #define DriverName              TEXT("\\\\.\\PSCHED")

    #define IOCTL_PSCHED_ZAW_EVENT  CTL_CODE( \
                                        FILE_DEVICE_NETWORK, \
                                        20, \
                                        METHOD_BUFFERED, \
                                        FILE_ANY_ACCESS \
                                        )

    PschedDriverHandle = CreateFile(
                             DriverName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             NULL
                             );

    if (PschedDriverHandle != INVALID_HANDLE_VALUE) {

        IOStatus = DeviceIoControl(
                       PschedDriverHandle,
                       IOCTL_PSCHED_ZAW_EVENT,
                       NULL,
                       0,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL
                       );

        printf("Configured psched with status %x \n", IOStatus);

        CloseHandle(PschedDriverHandle);
    }
}

int _cdecl main()
{
    SendPschedIoctl();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\wansup.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    wansup.h

Abstract:

    defines for WAN support functions

Author:

    Yoram Bernet (yoramb) 31-Oct-1997

Revision History:

--*/

#ifndef _WANSUP_
#define _WANSUP_

/* Prototypes */

NDIS_STATUS
DeleteInterfaceForNdisWan(
    IN PADAPTER Adapter,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

NDIS_STATUS
CreateInterfaceForNdisWan(
    IN PADAPTER Adapter,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    );

NDIS_STATUS
OpenWanAddressFamily(
    IN  PADAPTER                Adapter,
    IN  PCO_ADDRESS_FAMILY      WanAddressFamily
    );

VOID
WanOpenAddressFamilyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE NdisAfHandle
    );

VOID
WanMakeCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE NdisPartyHandle,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanModifyCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

NDIS_STATUS
WanModifyCall(
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanCloseAddressFamilyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolBindingContext
    );

NDIS_STATUS
WanCreateVc(
    IN NDIS_HANDLE  ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    );

NDIS_STATUS
WanDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    );

VOID
WanRegisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  PCO_SAP Sap,
    IN  NDIS_HANDLE NdisSapHandle
    );

VOID
WanDeregisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext
    );

NDIS_STATUS
WanIncomingCall(
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanAddPartyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolPartyContext,
    IN  NDIS_HANDLE NdisPartyHandle,
    IN  PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanDropPartyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolPartyContext
    );


NDIS_STATUS
WanMakeCall(
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanCloseCallComplete(
    NDIS_STATUS Status,
    NDIS_HANDLE ProtocolVcContext,
    PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanCloseCall(
    IN PGPC_CLIENT_VC Vc
    );

VOID
WanIncomingCallQoSChange(
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS CallParameters
    );

VOID
WanIncomingCloseCall(
    IN NDIS_STATUS CloseStatus,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PVOID CloseData          OPTIONAL,
    IN UINT Size                OPTIONAL
    );

VOID
WanIncomingDropParty(
    IN NDIS_STATUS DropStatus,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PVOID CloseData          OPTIONAL,
    IN UINT Size                OPTIONAL
    );

VOID
WanCallConnected(
    IN  NDIS_HANDLE ProtocolPartyContext
    );

NDIS_STATUS
WanCoRequest(
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST NdisRequest
    );

VOID
WanCoRequestComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST NdisRequest
    );

NDIS_STATUS
UpdateWanLinkBandwidthParameters(PPS_WAN_LINK WanLink);
    

VOID 
AskWanLinksToClose(PADAPTER Adapter);

/* End Prototypes */

#define PROTOCOL_IP          0x0800
#define PROTOCOL_IPX         0x8137

#endif /* _WANSUP_ */

/* end wansup.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\wansup.c ===
/*++


Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    wansup.c

Abstract:

    support for ndiswan

Author:

    Yoram Bernet    (yoramb)    29-Oct-1997
    Rajesh Sundaram (rajeshsu)  01-Aug-1998

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop

/* External */

/* Static */

//
// Should be defined in ndis.h. Put it here for now.
//

#define UNKNOWN_PROTOCOL_TYPE (USHORT) -1

NDIS_STATUS
CleanWanLink(PADAPTER Adapter, 
             PPS_WAN_LINK WanLink);

NDIS_STATUS
WanHandleISSLOW(
    IN PGPC_CLIENT_VC Vc,
    IN PCO_CALL_PARAMETERS CallParameters);

VOID
PsWanMungeAddress(PUSHORT id, USHORT Index)
{
    *id = Index;
}

NDIS_STATUS
DeleteInterfaceForNdisWan(
    IN PADAPTER Adapter,
    IN PVOID StatusBuffer,
    IN UINT StatusBufferSize
    )
{
    PNDIS_WAN_LINE_DOWN LineDownBuff;
    PLIST_ENTRY         NextWanLink;
    PPS_WAN_LINK        WanLink;
    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;

    LineDownBuff = (PNDIS_WAN_LINE_DOWN)StatusBuffer;

    PsDbgOut(DBG_TRACE, DBG_WAN,
             ("[DeleteInterfaceForNdisWan]: Linedown for remote address %02X:%02X:%02X:%02X:%02X:%02X \n",
              LineDownBuff->RemoteAddress[0],
              LineDownBuff->RemoteAddress[1],
              LineDownBuff->RemoteAddress[2],
              LineDownBuff->RemoteAddress[3],
              LineDownBuff->RemoteAddress[4],
              LineDownBuff->RemoteAddress[5]));


    //
    // Walk the List & remove the WanLink
    //
    PS_LOCK(&Adapter->Lock);

    NextWanLink = Adapter->WanLinkList.Flink;

    while(NextWanLink != &Adapter->WanLinkList) {

        WanLink = CONTAINING_RECORD(NextWanLink, PS_WAN_LINK, Linkage);

        //
        // We cannot compare the LocalAddress, because NDISWAN initially
        // passes us 0 for the LocalAddress in the LINE_UP
        // The LocalAddress is for Wanarp to store its context which it
        // sends down to NDISWAN. NDISWAN then sends this context back
        // to us as LocalAddress in LINE_DOWN. So, we have to ignore
        // the LocalAddress in the LINE_DOWN.
        //

        if(NdisEqualMemory(WanLink->OriginalRemoteMacAddress,
                           LineDownBuff->RemoteAddress,
                           sizeof(LineDownBuff->RemoteAddress)))
        {
            //
            // Get rid of the wanlink from the list.
            //
            g_WanLinkTable[WanLink->UniqueIndex] = 0;

            PS_UNLOCK(&Adapter->Lock);

            //
            // Munge the s-mac and r-mac so that wanarp can clean correctly.
            //
            PsWanMungeAddress((PUSHORT)&LineDownBuff->RemoteAddress[0], 
                              WanLink->UniqueIndex);

            PsWanMungeAddress((PUSHORT)&LineDownBuff->LocalAddress[0], 
                              (USHORT)(*(PUSHORT)&WanLink->OriginalLocalMacAddress[0]));

            Status = CleanWanLink(Adapter, WanLink);

            NdisMIndicateStatus(Adapter->PsNdisHandle,
                                NDIS_STATUS_WAN_LINE_DOWN,
                                StatusBuffer,
                                StatusBufferSize);

            return NDIS_STATUS_SUCCESS;
        }

        NextWanLink = NextWanLink->Flink;
    }

    PS_UNLOCK(&Adapter->Lock);

    PsDbgOut(DBG_CRITICAL_ERROR, DBG_WAN,
             ("[DeleteInterfaceForNdisWan]: Could not find wanlink for Remote Mac: (%02X:%02X:%02X:%02X:%02X:%02X) \n",
              LineDownBuff->RemoteAddress[0],
              LineDownBuff->RemoteAddress[1],
              LineDownBuff->RemoteAddress[2],
              LineDownBuff->RemoteAddress[3],
              LineDownBuff->RemoteAddress[4],
              LineDownBuff->RemoteAddress[5]));
    
    return Status;
}

NDIS_STATUS
PsWanGenerateUniqueIndex(
    PPS_WAN_LINK WanLink
)
{
    PADAPTER    Adapter = WanLink->Adapter;
    NDIS_STATUS Status  = NDIS_STATUS_FAILURE;
    USHORT      size, Index, i, j;
    PULONG_PTR  NewTable;

    PS_LOCK(&Adapter->Lock);

    for(i=0, Index = g_NextWanIndex;
        i < g_WanTableSize;
        i++)
    {
        if(g_WanLinkTable[Index] == 0)
        {
            //
            // We got a free slot.
            //

            g_WanLinkTable[Index]    = (ULONG_PTR)WanLink;
            WanLink->UniqueIndex     = Index;

            //
            // Assume that the next one is free.
            //
            g_NextWanIndex ++;
            g_NextWanIndex = g_NextWanIndex % g_WanTableSize;

            PS_UNLOCK(&Adapter->Lock);

            return NDIS_STATUS_SUCCESS;
        }

        Index ++;

        Index = Index % g_WanTableSize;
    } 

    //
    // We could not find a slot to insert the wanlink. Grow the table
    // and copy the existing table.
    //

    size = (g_WanTableSize + WAN_TABLE_INCREMENT) * sizeof(ULONG_PTR);

    PsAllocatePool(NewTable, size, WanTableTag);

    if(!NewTable)
    {
        PS_UNLOCK(&Adapter->Lock);

        return NDIS_STATUS_FAILURE;
    }

    NdisZeroMemory(NewTable, size);

    NdisMoveMemory(NewTable, g_WanLinkTable, g_WanTableSize * sizeof(ULONG_PTR));

    PsFreePool(g_WanLinkTable);

    g_WanLinkTable = NewTable;

    //
    //
    //
    g_WanLinkTable[g_WanTableSize] = (ULONG_PTR)WanLink;

    WanLink->UniqueIndex = g_WanTableSize;

    g_NextWanIndex = g_WanTableSize + 1;

    g_WanTableSize += WAN_TABLE_INCREMENT;

    PS_UNLOCK(&Adapter->Lock);

    return NDIS_STATUS_SUCCESS;
}

VOID
DeleteWanLink(
    PVOID   Instance,
    BOOLEAN AdapterLocked)
{
    PPS_WAN_LINK WanLink = (PPS_WAN_LINK)Instance;
        if(WanLink->pDiffServMapping)
        {
            PsFreePool(WanLink->pDiffServMapping);
        }

        if(WanLink->ShutdownMask & SHUTDOWN_DELETE_PIPE)
        {
            (*WanLink->PsComponent->DeletePipe)(WanLink->PsPipeContext);
        }

        if(WanLink->ShutdownMask & SHUTDOWN_FREE_PS_CONTEXT)
        {
            PsFreePool(WanLink->PsPipeContext);
        }

        if(WanLink->InstanceName.Buffer) {

            PsFreePool(WanLink->InstanceName.Buffer);
        }

        if(WanLink->MpDeviceName.Buffer){

           PsFreePool(WanLink->MpDeviceName.Buffer);
        }

        if(AdapterLocked)
        {
            RemoveEntryList(&WanLink->Linkage);
        }
        else
        {
            PS_LOCK(&WanLink->Adapter->Lock);

            RemoveEntryList(&WanLink->Linkage);

            PS_UNLOCK(&WanLink->Adapter->Lock);
        }

        NdisFreeSpinLock(&WanLink->Lock);

        PsFreePool(WanLink);

}

NDIS_STATUS
CreateInterfaceForNdisWan(
    IN PADAPTER Adapter,
    IN PVOID    StatusBuffer,
    IN UINT     StatusBufferSize
    )
/*++

Routine Description:

    Creates a TC interface to represent an underlying WAN link.

Arguments:

    Adapter - the adapter on which the link is being created.
    StatusBuffer - the buffer from NDISWAN.
    StatusBufferSize - the length of the buffer.

Return Values:

    None

--*/

{
    PNDIS_WAN_LINE_UP      LineUpBuff;
    PPS_WAN_LINK           WanLink;
    PLIST_ENTRY            NextWanLink;
    NDIS_STATUS            Status;
    PIP_WAN_LINKUP_INFO    RouterInfo;
    NTSTATUS               NtStatus;
    LARGE_INTEGER          Increment = {0, 1};
    LARGE_INTEGER          Index;
    PGPC_CLIENT_VC         Vc;
    UCHAR                  ZeroAddress[] = {0, 0, 0, 0, 0, 0};
    NDIS_HANDLE            LineUpHandle;
    int                    i,j;

    LineUpBuff = (PNDIS_WAN_LINE_UP)StatusBuffer;

    //
    // Check for MultiLink:
    //
    // The first link up will have a ZeroLocal Address, in this case, we create a new QoS interface. 
    // All subsequent lineups will have a non-zero LocalAddress. If the link is being updated, we 
    // only need to update the linkspeed on the existing interface.
    //

    if(!(NdisEqualMemory(LineUpBuff->LocalAddress, ZeroAddress, 6)))
    {
        //
        // Get the exisiting WanLink
        //
        PS_LOCK(&Adapter->Lock);

        NextWanLink = Adapter->WanLinkList.Flink;

        while(NextWanLink != &Adapter->WanLinkList) {

            WanLink = CONTAINING_RECORD(NextWanLink, PS_WAN_LINK, Linkage);

            if(NdisEqualMemory(WanLink->OriginalRemoteMacAddress,
                               LineUpBuff->RemoteAddress,
                               sizeof(LineUpBuff->RemoteAddress))) 
            {
                REFADD(&Adapter->RefCount, 'WANU');

                PS_UNLOCK(&Adapter->Lock);

                PsDbgOut(DBG_TRACE, DBG_WAN,
                         ("[CreateInterfaceForNdisWan]: Link speed of WanLink 0x%x has changed "
                          "from %d to %d \n", WanLink, WanLink->LinkSpeed, LineUpBuff->LinkSpeed));

                WanLink->LinkSpeed = LineUpBuff->LinkSpeed;

                UpdateWanLinkBandwidthParameters(WanLink);

                TcIndicateInterfaceChange(Adapter, WanLink, NDIS_STATUS_INTERFACE_CHANGE);

                //
                // Munge s-mac and d-mac and send to wanarp.
                //
                PsWanMungeAddress((PUSHORT)&LineUpBuff->RemoteAddress[0], 
                                  WanLink->UniqueIndex);

                PsWanMungeAddress((PUSHORT)&LineUpBuff->LocalAddress[0], 
                                  (USHORT)(*(PUSHORT)&WanLink->OriginalLocalMacAddress[0]));

                NdisMIndicateStatus(Adapter->PsNdisHandle,
                                    NDIS_STATUS_WAN_LINE_UP,
                                    StatusBuffer,
                                    StatusBufferSize);

                REFDEL(&Adapter->RefCount, FALSE, 'WANU');

                return NDIS_STATUS_SUCCESS;
            }

            NextWanLink = NextWanLink->Flink;
        }

        PS_UNLOCK(&Adapter->Lock);

        PsDbgOut(DBG_FAILURE, DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Got a change notification, but could not find wanlink "
                  "Remote Mac: (%02X:%02X:%02X:%02X:%02X:%02X) \n",
                  LineUpBuff->RemoteAddress[0],
                  LineUpBuff->RemoteAddress[1],
                  LineUpBuff->RemoteAddress[2],
                  LineUpBuff->RemoteAddress[3],
                  LineUpBuff->RemoteAddress[4],
                  LineUpBuff->RemoteAddress[5]));


        return NDIS_STATUS_FAILURE;
    }

    //
    // Create an internal representation of the link.
    //

    PsAllocatePool(WanLink,
                   sizeof(PS_WAN_LINK),
                   WanLinkTag);

    if(WanLink == NULL)
    {

        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, couldn't create WanLink\n",
                  Adapter));

        return NDIS_STATUS_RESOURCES;
    }

    //
    // Initialize the wanlink.
    //

    NdisZeroMemory(WanLink, sizeof(PS_WAN_LINK));
    WanLink->Adapter  = Adapter;

    REFINIT(&WanLink->RefCount, WanLink, DeleteWanLink);
    REFADD(&WanLink->RefCount, 'WANU');
    PS_INIT_SPIN_LOCK(&WanLink->Lock);

    //
    // Link the SausageLink on the link list.
    //

    NdisInterlockedIncrement(&Adapter->WanLinkCount);

    NdisInterlockedInsertHeadList(&Adapter->WanLinkList,
                                  &WanLink->Linkage,
                                  &Adapter->Lock.Lock);

    //
    // Update the LinkSpeed and create a pipe off the wanlink.
    //
    WanLink->RawLinkSpeed = LineUpBuff->LinkSpeed;
    WanLink->LinkSpeed    = ( WanLink->RawLinkSpeed / 8 ) * 100;


    Status = UpdateWanLinkBandwidthParameters(WanLink);

    if(!NT_SUCCESS(Status))
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, UpdateWanLinkBandwidthParameters failed with %08X",
                  Adapter, Status));

        REFDEL(&WanLink->RefCount, FALSE, 'WANU');

        return Status;
    }
        
    //
    // Extract the network addresses from the protocol part
    // of the status buffer. Update the network layer address list
    // which is held on the adapter.
    //

    switch(LineUpBuff->ProtocolType)
    {

      case PROTOCOL_IP:
          
          RouterInfo = (PIP_WAN_LINKUP_INFO) LineUpBuff->ProtocolBuffer;
          
          WanLink->DialUsage = RouterInfo->duUsage;
          WanLink->ProtocolType = LineUpBuff->ProtocolType;
          WanLink->LocalIpAddress = RouterInfo->dwLocalAddr;
          WanLink->RemoteIpAddress = RouterInfo->dwRemoteAddr;
          WanLink->LocalIpxAddress = 0;
          WanLink->RemoteIpxAddress = 0;
          break;

      default:
          
          //
          // Unknown address type. We'll create a manageable
          // entity, but - we don't know how to represent its
          // addresses. Therefore, we also don't know how to
          // format traffic control filters for it. So - it
          // probably won't be particualrly useful. At least it
          // lets the user see that there is an interface.
          //
          
          WanLink->ProtocolType = UNKNOWN_PROTOCOL_TYPE;
          WanLink->LocalIpAddress = 0;
          WanLink->RemoteIpAddress = 0;
          WanLink->LocalIpxAddress = 0;
          WanLink->RemoteIpxAddress = 0;
    }

    PsAllocatePool(WanLink->InstanceName.Buffer,
                   Adapter->WMIInstanceName.Length + WanPrefix.Length + INSTANCE_ID_SIZE,
                   PsMiscTag);

    if(!WanLink->InstanceName.Buffer)
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, could not allocate memory for instance name \n",
                  Adapter));

        REFDEL(&WanLink->RefCount, FALSE, 'WANU');
        return NDIS_STATUS_RESOURCES;
    }

    if((Status = PsWanGenerateUniqueIndex(WanLink)) != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, PsWanGenerateUniqueIndex failed with Status %08X \n",
                  Adapter, Status));

        REFDEL(&WanLink->RefCount, FALSE, 'WANU');
        return Status;
    }

    Index.QuadPart = WanLink->UniqueIndex;
    NtStatus = GenerateInstanceName(&WanPrefix,
                                    Adapter,
                                    &Index,
                                    &WanLink->InstanceName);


    //
    // Copy the DeviceName
    //
    WanLink->MpDeviceName.MaximumLength   = LineUpBuff->DeviceName.MaximumLength;

    PsAllocatePool(WanLink->MpDeviceName.Buffer,
                   WanLink->MpDeviceName.MaximumLength,
                   PsMiscTag);

    if(!WanLink->MpDeviceName.Buffer) 
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, could not allocate memory for device name \n",
                  Adapter));

        PS_LOCK(&Adapter->Lock);

        g_WanLinkTable[WanLink->UniqueIndex] = 0;

        REFDEL(&WanLink->RefCount, TRUE, 'WANU');

        PS_UNLOCK(&Adapter->Lock);
        
        return NDIS_STATUS_RESOURCES;
    }


    NdisZeroMemory(WanLink->MpDeviceName.Buffer, WanLink->MpDeviceName.MaximumLength);


    Status = CreateBestEffortVc(Adapter, 
                                &WanLink->BestEffortVc, 
                                WanLink);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        PsDbgOut(DBG_FAILURE,
                 DBG_WAN,
                 ("[CreateInterfaceForNdisWan]: Adapter %08X, could not create BestEffort Vc, status %08X",
                  Adapter, Status));

        PS_LOCK(&Adapter->Lock);

        g_WanLinkTable[WanLink->UniqueIndex] = 0;

        REFDEL(&WanLink->RefCount, TRUE, 'WANU');

        PS_UNLOCK(&Adapter->Lock);

        return Status;
    }            

    //
    //  Create 2 BEVCS and make the NextVc as the first one.
    WanLink->NextVc = 0;

    for( i = 0; i < BEVC_LIST_LEN; i++)
    {
        
        Status = CreateBestEffortVc(Adapter, 
                                    &WanLink->BeVcList[i], 
                                    WanLink);

        if(Status != NDIS_STATUS_SUCCESS)
        {
            PsDbgOut(DBG_FAILURE,
                     DBG_WAN,
                     ("[CreateInterfaceForNdisWan]: Adapter %08X, could not create BestEffort Vc, status %08X",
                      Adapter, Status));

            PS_LOCK(&Adapter->Lock);

            g_WanLinkTable[WanLink->UniqueIndex] = 0;
                
            for( j = 0; j < i; j++ )
            {
                PS_LOCK_DPC(&WanLink->BeVcList[j].Lock);
 
                InternalCloseCall(&WanLink->BeVcList[j]);

                PS_LOCK(&Adapter->Lock);
            }

            PS_LOCK_DPC(&WanLink->BestEffortVc.Lock);

            InternalCloseCall(&WanLink->BestEffortVc);

            REFDEL(&WanLink->RefCount, TRUE, 'WANU');

            return Status;
        }
    }



    //
    // Copy the original Remote Addresses and munge it.
    //

    NdisMoveMemory(&WanLink->OriginalRemoteMacAddress,
                   &LineUpBuff->RemoteAddress,
                   6);

    PsWanMungeAddress((PUSHORT) &LineUpBuff->RemoteAddress[0], WanLink->UniqueIndex);

    NdisMIndicateStatus(Adapter->PsNdisHandle,
                        NDIS_STATUS_WAN_LINE_UP,
                        StatusBuffer,
                        StatusBufferSize);

    //
    // Fail if wanarp has failed the line up
    //
    
    *((ULONG UNALIGNED *)(&LineUpHandle)) =
        *((ULONG UNALIGNED *)(&LineUpBuff->LocalAddress[2]));
    
    if (LineUpHandle == NULL) 
    {
        PsDbgOut(DBG_FAILURE, DBG_WAN, 
                 ("[ClStatusIndication]: wanarp has failed the lineup. "
                  "Remote Address (%02X:%02X:%02X:%02X:%02X:%02X) \n", 
                  LineUpBuff->RemoteAddress[0],
                  LineUpBuff->RemoteAddress[1],
                  LineUpBuff->RemoteAddress[2],
                  LineUpBuff->RemoteAddress[3],
                  LineUpBuff->RemoteAddress[4],
                  LineUpBuff->RemoteAddress[5]));
   
        PS_LOCK(&Adapter->Lock);

        g_WanLinkTable[WanLink->UniqueIndex] = 0;

        for( j = 0; j < BEVC_LIST_LEN; j++ )
        {
            PS_LOCK_DPC(&WanLink->BeVcList[j].Lock);
 
            InternalCloseCall(&WanLink->BeVcList[j]);

            PS_LOCK(&Adapter->Lock);
        }   

        PS_LOCK_DPC(&WanLink->BestEffortVc.Lock);

        InternalCloseCall(&WanLink->BestEffortVc);
            
        REFDEL(&WanLink->RefCount, FALSE, 'WANU');

        return NDIS_STATUS_FAILURE;
    }
    else
    {
        //
        // If wanarp has succeeded the lineup, we cannot get a zero local mac address.
        //
        PsAssert(!(NdisEqualMemory(LineUpBuff->LocalAddress, ZeroAddress, 6)));
    }

    //
    // Copy the device name that wanarp has filled in.
    //

    WanLink->MpDeviceName.Length = LineUpBuff->DeviceName.Length;
    NdisMoveMemory(WanLink->MpDeviceName.Buffer,
                   LineUpBuff->DeviceName.Buffer,
                   LineUpBuff->DeviceName.Length);

    //
    // Munge the smac address. Remember the original one that wanarp gave us.
    //

    NdisMoveMemory(&WanLink->OriginalLocalMacAddress,
                   &LineUpBuff->LocalAddress,
                   6);

    PsWanMungeAddress((PUSHORT)&LineUpBuff->LocalAddress[0], WanLink->UniqueIndex);

    //
    // Create the headers that have to be slapped on the send/recv path.
    //
    NdisMoveMemory(&WanLink->SendHeader.DestAddr[0], 
                   WanLink->OriginalRemoteMacAddress, 
                   ARP_802_ADDR_LENGTH);

    NdisMoveMemory(&WanLink->SendHeader.SrcAddr[0] , 
                   LineUpBuff->LocalAddress,
                   ARP_802_ADDR_LENGTH);

    NdisMoveMemory(&WanLink->RecvHeader.DestAddr[0],
                   WanLink->OriginalLocalMacAddress,
                   ARP_802_ADDR_LENGTH);

    NdisMoveMemory(&WanLink->RecvHeader.SrcAddr[0],
                   LineUpBuff->RemoteAddress,
                   ARP_802_ADDR_LENGTH);

    //
    // Unmunge the remote address in the lineup buff now.
    //
    PsWanMungeAddress((PUSHORT)&LineUpBuff->RemoteAddress[0], 
                      (USHORT)(*(PUSHORT)WanLink->OriginalRemoteMacAddress));


    // 
    // We are ready to recv and send packets.
    //

    PS_LOCK(&WanLink->Lock);

    WanLink->State = WanStateOpen;

    PS_UNLOCK(&WanLink->Lock);

    PsScheduleInterfaceIdWorkItem(Adapter, WanLink);

    //
    // Indicate the new interface up to the TCI. We indicate both the
    // addition of a new interface and the addresses available on it.
    // The address descriptors indicated for WAN interfaces differ from
    // those indicated for LAN interfaces. WAN interfaces include a
    // destination network layer address, as well as a source address.
    //

    TcIndicateInterfaceChange(Adapter, WanLink, NDIS_STATUS_INTERFACE_UP);


    PsDbgOut(DBG_TRACE, DBG_WAN,
             ("[CreateInterfaceForNdisWan]: Created WanLink 0x%x, Remote Address (%02X:%02X:%02X:%02X:%02X:%02X) \n",
              WanLink,
              LineUpBuff->RemoteAddress[0],
              LineUpBuff->RemoteAddress[1],
              LineUpBuff->RemoteAddress[2],
              LineUpBuff->RemoteAddress[3],
              LineUpBuff->RemoteAddress[4],
              LineUpBuff->RemoteAddress[5]));

    return(NDIS_STATUS_SUCCESS);

}

NDIS_STATUS
OpenWanAddressFamily(
    IN  PADAPTER                Adapter,
    IN  PCO_ADDRESS_FAMILY      WanAddressFamily
    )

/*++

Routine Description:

    Establish the binding between the PS miniport, NDISWAN and the
    NDISWAN call manager.

Arguments:

    Adapter - pointer to adapter

Return Value:

    None

--*/

{
    NDIS_CLIENT_CHARACTERISTICS WanClCharacteristics;
    NDIS_STATUS Status;

    WanClCharacteristics.MajorVersion = 5;
    WanClCharacteristics.MinorVersion = 0;
    WanClCharacteristics.Reserved     = 0;

    WanClCharacteristics.ClCreateVcHandler              = WanCreateVc;
    WanClCharacteristics.ClDeleteVcHandler              = WanDeleteVc;
    WanClCharacteristics.ClOpenAfCompleteHandler        = WanOpenAddressFamilyComplete;
    WanClCharacteristics.ClCloseAfCompleteHandler       = WanCloseAddressFamilyComplete;
    WanClCharacteristics.ClRegisterSapCompleteHandler   = WanRegisterSapComplete;
    WanClCharacteristics.ClDeregisterSapCompleteHandler = WanDeregisterSapComplete;
    WanClCharacteristics.ClMakeCallCompleteHandler      = WanMakeCallComplete;
    WanClCharacteristics.ClModifyCallQoSCompleteHandler = WanModifyCallComplete;
    WanClCharacteristics.ClCloseCallCompleteHandler     = WanCloseCallComplete;
    WanClCharacteristics.ClAddPartyCompleteHandler      = WanAddPartyComplete;
    WanClCharacteristics.ClDropPartyCompleteHandler     = WanDropPartyComplete;
    WanClCharacteristics.ClIncomingCallHandler          = WanIncomingCall;
    WanClCharacteristics.ClIncomingCallQoSChangeHandler = WanIncomingCallQoSChange;
    WanClCharacteristics.ClIncomingCloseCallHandler     = WanIncomingCloseCall;
    WanClCharacteristics.ClIncomingDropPartyHandler     = WanIncomingDropParty;
    WanClCharacteristics.ClCallConnectedHandler         = WanCallConnected;
    WanClCharacteristics.ClRequestHandler               = WanCoRequest;
    WanClCharacteristics.ClRequestCompleteHandler       = WanCoRequestComplete;

    PsDbgOut(DBG_TRACE,
             DBG_WAN | DBG_INIT,
             ("[OpenWanAddressFamily]: Adapter %08X \n", Adapter));

    Status = NdisClOpenAddressFamily(Adapter->LowerMpHandle,
                                     WanAddressFamily,
                                     Adapter,
                                     &WanClCharacteristics,
                                     sizeof(WanClCharacteristics),
                                     &Adapter->WanCmHandle);

    if(Status != NDIS_STATUS_PENDING)
    {
        WanOpenAddressFamilyComplete(Status,
                                     Adapter,
                                     Adapter->WanCmHandle);
    }

    return Status;

} // OpenWanAddressFamily


VOID
WanOpenAddressFamilyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE NdisAfHandle
    )

/*++

Routine Description:

    Complete a call to NdisClOpenAddressFamily.

Arguments:

    see the DDK

Return Value:

    None

--*/

{
    PADAPTER Adapter = (PADAPTER)ProtocolAfContext;


    if(Status != NDIS_STATUS_SUCCESS){

        PsDbgOut(DBG_CRITICAL_ERROR,
                 DBG_WAN,
                 ("[WanOpenAddressFamilyComplete]: Adapter %08X, open failed %08X\n",
                 Adapter, Status));

        PsAdapterWriteEventLog(
            EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED,
            0,
            &Adapter->MpDeviceName,
            sizeof(Status),
            &Status);

        return;
    }
    else{

        PS_LOCK(&Adapter->Lock);

        Adapter->WanBindingState |= WAN_ADDR_FAMILY_OPEN;

        Adapter->ShutdownMask |= SHUTDOWN_CLOSE_WAN_ADDR_FAMILY;

        Adapter->WanCmHandle = NdisAfHandle;

        Adapter->FinalStatus = Status;

        PS_UNLOCK(&Adapter->Lock);

        PsDbgOut(DBG_TRACE,
                DBG_WAN | DBG_INIT,
                ("[WanOpenAddressFamilyComplete]: Adapter %08X, Status = %x\n",
                Adapter,
                Status));
    }

} // WanOpenAddressFamilyComplete

VOID
WanMakeCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN NDIS_HANDLE NdisPartyHandle,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    PGPC_CLIENT_VC       Vc      = (PGPC_CLIENT_VC) ProtocolVcContext;
    PADAPTER             Adapter = Vc->Adapter;

    PsStructAssert(Adapter);

    //
    // Common code to complete both synchronous and asynchronous
    // returns from WanMakeCall. Note that, unless there is a WAN
    // adapter, CmMakeCall will always complete synchronously.
    //

    if(Status != NDIS_STATUS_SUCCESS){

        //
        // We probably at least succeeeded in creating a VC in NDISWAN.
        // If we did, we should delete it here. We may have failed however,
        // because we could not create the VC, in which case, we have
        // nothing to delete.
        //

        if(Vc->NdisWanVcHandle){

            NdisCoDeleteVc(Vc->NdisWanVcHandle);

            Vc->NdisWanVcHandle = NULL;
        }
    }

    CompleteMakeCall(Vc,
                     CallParameters,
                     Status);
}

VOID
WanModifyCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC)ProtocolVcContext;
    PADAPTER Adapter = Vc->Adapter;

    PsStructAssert(Adapter);

    //
    // Common code to complete both synchronous and asynchronous
    // returns from WanModifyCall.
    //

    if(Status != NDIS_STATUS_SUCCESS) {

        //
        // We changed some of the ISSLOW stuff - Time to revert back
        //

        WanHandleISSLOW(Vc, Vc->CallParameters);
    }

    ModifyCallComplete(Vc, CallParameters, Status);
}


VOID
WanCloseAddressFamilyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolBindingContext
    )
{
    PADAPTER Adapter = (PADAPTER)ProtocolBindingContext;

    PS_LOCK(&Adapter->Lock);
    Adapter->WanBindingState &= ~WAN_ADDR_FAMILY_OPEN;
    PS_UNLOCK(&Adapter->Lock);
}

NDIS_STATUS
WanCreateVc(
    IN NDIS_HANDLE  ProtocolAfContext,
    IN  NDIS_HANDLE             NdisVcHandle,
    OUT PNDIS_HANDLE            ProtocolVcContext
    )
{
    DEBUGCHK;
    return NDIS_STATUS_FAILURE;
}

NDIS_STATUS
WanDeleteVc(
    IN  NDIS_HANDLE             ProtocolVcContext
    )
{
    DEBUGCHK;
    return NDIS_STATUS_FAILURE;
}

VOID
WanRegisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  PCO_SAP Sap,
    IN  NDIS_HANDLE NdisSapHandle
    )
{
    DEBUGCHK;
}

VOID
WanDeregisterSapComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolSapContext
    )
{
    DEBUGCHK;
}

NDIS_STATUS
WanIncomingCall(
    IN  NDIS_HANDLE ProtocolSapContext,
    IN  NDIS_HANDLE ProtocolVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    DEBUGCHK;
    return NDIS_STATUS_FAILURE;
}

VOID
WanAddPartyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolPartyContext,
    IN  NDIS_HANDLE NdisPartyHandle,
    IN  PCO_CALL_PARAMETERS CallParameters
    )
{
    DEBUGCHK;
}

VOID
WanDropPartyComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolPartyContext
    )
{
    DEBUGCHK;
}


NDIS_STATUS
WanHandleISSLOW(
    IN PGPC_CLIENT_VC Vc,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    LONG                        ParamsLength;
    LPQOS_OBJECT_HDR            QoSObject;
    PADAPTER                    Adapter = Vc->Adapter;
    PCO_MEDIA_PARAMETERS        CallMgrParams = CallParameters->MediaParameters;
    ULONGLONG                   i,j,k;

    //
    // See if this is an ISSLOW flow.
    //
    ParamsLength = (LONG)CallMgrParams->MediaSpecific.Length;
    QoSObject = (LPQOS_OBJECT_HDR)CallMgrParams->MediaSpecific.Parameters;

    //
    // By default, this is not an ISSLOW flow.
    //

    Vc->Flags &= ~GPC_ISSLOW_FLOW;

    while(ParamsLength > 0){

        if(QoSObject->ObjectType == QOS_OBJECT_WAN_MEDIA)
        {
            LPQOS_WAN_MEDIA WanMedia = (LPQOS_WAN_MEDIA)QoSObject;

            WanMedia->ISSLOW = FALSE;

            //
            // See if the flow is an ISSLOW flow. If the TokenRate of the flow
            // is under ISSLOW TokenRate and the PacketSize is under MaxPacketSize
            // Then we qualify this as ISSLOW flows.
            //
            // If a wanlink's linkspeed is greater than a certain amount, we don't run issow over it.
            //

            if((Vc->WanLink->LinkSpeed <= Adapter->ISSLOWLinkSpeed) && 
                (CallParameters->CallMgrParameters->Transmit.ServiceType != SERVICETYPE_BESTEFFORT))
            {
                i = (ULONG) Adapter->ISSLOWTokenRate * (ULONG) CallParameters->CallMgrParameters->Transmit.MaxSduSize;
                j = (ULONG) Adapter->ISSLOWPacketSize * (ULONG) CallParameters->CallMgrParameters->Transmit.TokenRate;
                k = (ULONG) Adapter->ISSLOWTokenRate * (ULONG)Adapter->ISSLOWPacketSize;

                if((i+j)<k)
                {
                    WanMedia->ISSLOW = TRUE;

                    PsDbgOut(DBG_TRACE, DBG_WAN,
                             ("[WanHandleISSLOW]: Vc %08X is an ISSLOW VC (TokenRate = %d, PacketSize = %d \n",
                              Vc, CallParameters->CallMgrParameters->Transmit.TokenRate,
                              CallParameters->CallMgrParameters->Transmit.MaxSduSize));

                    //
                    // The MaxSDUSize is normally a measure of the latency requirements of -that- flow
                    // For audio codes, MaxSDUSize = f(Latency requirements, unit size);
                    //
                    // But, we don't want to chop these into very small fragments. Therefore, we have
                    // an upper bound and pick the maximum.
                    //

                    if(CallParameters->CallMgrParameters->Transmit.MaxSduSize > Adapter->ISSLOWFragmentSize)
                    {
                        Vc->ISSLOWFragmentSize = CallParameters->CallMgrParameters->Transmit.MaxSduSize;
                    }
                    else
                    {
                        Vc->ISSLOWFragmentSize = Adapter->ISSLOWFragmentSize;
                    }

                    Vc->Flags |= GPC_ISSLOW_FLOW;

                    PsDbgOut(DBG_TRACE, DBG_WAN,
                             ("[WanHandleISSLOW]: Adapter %08X, ISSLOW Vc %08X, FragmentSize = %d bytes \n",
                              Adapter, Vc, Vc->ISSLOWFragmentSize));

                }
                else 
                {
                    PsDbgOut(DBG_TRACE, DBG_WAN,
                             ("[WanHandleISSLOW]: Non ISSLOW Vc %08X. ISSLOW TokenRate %d, "
                              "ISSLOW Packet Size %d, VC TokenRate %d, VC Packet Size %d \n", 
                              Vc, Adapter->ISSLOWTokenRate,
                              Adapter->ISSLOWPacketSize, 
                              CallParameters->CallMgrParameters->Transmit.TokenRate,
                              CallParameters->CallMgrParameters->Transmit.MaxSduSize));
                }
            }
            else 
            {
                PsDbgOut(DBG_TRACE, DBG_WAN,
                         ("[WanHandleISSLOW]: Non ISSLOW Vc %08X. (servicetype == B/E "
                          " or WAN LinkSpeed %d < ISSLOW LinkSpeed %d \n",
                          Vc, Vc->WanLink->LinkSpeed, Adapter->ISSLOWLinkSpeed));
            }

            return NDIS_STATUS_SUCCESS;
        }
        else {

            if(
                ((LONG)QoSObject->ObjectLength <= 0) ||
                ((LONG)QoSObject->ObjectLength > ParamsLength)
                ){

                return(QOS_STATUS_TC_OBJECT_LENGTH_INVALID);
            }

            ParamsLength -= QoSObject->ObjectLength;
            QoSObject = (LPQOS_OBJECT_HDR)((UINT_PTR)QoSObject +
                                           QoSObject->ObjectLength);

        }
    }

    return NDIS_STATUS_FAILURE;
}

NDIS_STATUS
WanMakeCall(
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    NDIS_STATUS Status;
    PADAPTER Adapter;

    Adapter = Vc->Adapter;
    PsStructAssert(Adapter);

    //
    // Handle ISSLOW
    //
    WanHandleISSLOW(Vc, CallParameters);

    //
    // Create a VC in the Wan adapter.
    //
    Vc->NdisWanVcHandle = NULL;

    Status = NdisCoCreateVc(Adapter->LowerMpHandle,
                            Adapter->WanCmHandle,
                            Vc,
                            &Vc->NdisWanVcHandle);
        
    PsAssert(Status != NDIS_STATUS_PENDING);
    
    if(Status != NDIS_STATUS_SUCCESS)
    {
        Vc->NdisWanVcHandle = 0;

        PsDbgOut(DBG_FAILURE, DBG_WAN,
                 ("[WanMakeCall]: cannot create VC.  Status = %d\n", Status));
        
        WanMakeCallComplete(Status, Vc, NULL, CallParameters);
    }
    else 
    {
        Status = NdisClMakeCall(Vc->NdisWanVcHandle, CallParameters, NULL, NULL);
        
        if(Status != NDIS_STATUS_PENDING){
            
            WanMakeCallComplete(Status, Vc, NULL, CallParameters);
        }
    }

    return (NDIS_STATUS_PENDING);
}

VOID
WanCloseCall(
    IN PGPC_CLIENT_VC Vc
    )
{
    NDIS_STATUS Status;

    //
    // Issue a CloseCall to the WAN call manager. 
    //

    PsAssert(Vc->NdisWanVcHandle);

    Status = NdisClCloseCall(Vc->NdisWanVcHandle,
                             NULL,
                             NULL,
                             0);

    if(Status != NDIS_STATUS_PENDING)
    {
        WanCloseCallComplete(Status,
                             Vc,
                             Vc->CallParameters);
    }
}
    
VOID
WanCloseCallComplete(
        NDIS_STATUS Status,
        NDIS_HANDLE ProtocolVcContext,
        PCO_CALL_PARAMETERS CallParameters
        )
{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC) ProtocolVcContext;

    Status = NdisCoDeleteVc(Vc->NdisWanVcHandle);

    PsAssert(Status != NDIS_STATUS_PENDING);
    
    Vc->NdisWanVcHandle = 0;

    CmDeleteVc(Vc);

}

NDIS_STATUS
WanModifyCall(
    IN PGPC_CLIENT_VC Vc,
    IN OUT PCO_CALL_PARAMETERS CallParameters
    )
{
    NDIS_STATUS Status;

    WanHandleISSLOW(Vc, CallParameters);

    PsAssert(Vc->NdisWanVcHandle);

    Status = NdisClModifyCallQoS(Vc->NdisWanVcHandle, CallParameters);

    if(Status != NDIS_STATUS_PENDING)
    {
        WanModifyCallComplete(Status, Vc, CallParameters);
    }

    return NDIS_STATUS_PENDING;
}

VOID
AskWanLinksToClose(PADAPTER Adapter)
{

    PLIST_ENTRY NextWanLink;
    PPS_WAN_LINK WanLink;

    PsDbgOut(DBG_TRACE, DBG_WAN, 
             ("[AskWanLinksToClose]: Adapter %08X - All wanlinks are closing \n", Adapter));

    //
    // Walk the List & remove the WanLink
    //
    PS_LOCK(&Adapter->Lock);

    while(!IsListEmpty(&Adapter->WanLinkList)) {

        NextWanLink = RemoveHeadList(&Adapter->WanLinkList);

        WanLink = CONTAINING_RECORD(NextWanLink, PS_WAN_LINK, Linkage);

        //
        // Get rid of the wanlink from the list.
        //
        g_WanLinkTable[WanLink->UniqueIndex] = 0;

        PS_UNLOCK(&Adapter->Lock);

        CleanWanLink(Adapter, WanLink);

        PS_LOCK(&Adapter->Lock);

    }

    PS_UNLOCK(&Adapter->Lock);

    return;
}

NDIS_STATUS
CleanWanLink(PADAPTER Adapter, 
             PPS_WAN_LINK WanLink)
{
    PLIST_ENTRY      NextVc;
    PGPC_CLIENT_VC   Vc;
    PUSHORT          id;
    int              j;

    PsDbgOut(DBG_TRACE, DBG_WAN, ("[CleanWanLink]: WanLink 0x%x is going down \n", WanLink));

    TcIndicateInterfaceChange(Adapter, WanLink, NDIS_STATUS_INTERFACE_DOWN);

    PS_LOCK(&WanLink->Lock);

    WanLink->State = WanStateClosing;

    PS_UNLOCK(&WanLink->Lock);

    PS_LOCK(&Adapter->Lock);

    //
    //  Make sure to delete Be Vc1 also..

    for( j = 0; j < BEVC_LIST_LEN; j++ )
    {
        PS_LOCK_DPC(&WanLink->BeVcList[j].Lock);
 
        InternalCloseCall(&WanLink->BeVcList[j]);

        PS_LOCK(&Adapter->Lock);
    } 

    PS_LOCK_DPC(&WanLink->BestEffortVc.Lock);

    InternalCloseCall(&WanLink->BestEffortVc);

    NdisInterlockedDecrement(&Adapter->WanLinkCount);

    PS_LOCK(&Adapter->Lock);

    //
    // Clean up all the GPC VCs on the WanLink;
    //

    NextVc = Adapter->GpcClientVcList.Flink;

    while(NextVc != &Adapter->GpcClientVcList)
    {

        Vc = CONTAINING_RECORD(NextVc, GPC_CLIENT_VC, Linkage);

        NextVc = NextVc->Flink;

        PsAssert(Vc);

        if(Vc->WanLink == WanLink)
        {

            PS_LOCK_DPC(&Vc->Lock);

            if(Vc->ClVcState == CL_INTERNAL_CLOSE_PENDING || Vc->Flags & INTERNAL_CLOSE_REQUESTED)
            {
                // We have already closed this Vc. Let's move on.

                PS_UNLOCK_DPC(&Vc->Lock);
            }
            else 
            {

                InternalCloseCall(Vc);
    
                PS_LOCK(&Adapter->Lock);

                //
                // Sigh. We can't really get hold to the NextVc in a reliable manner. When we call 
                // InternalCloseCall on the Vc, it releases the Adapter Lock (since it might have to
                // make calls into NDIS). Now, in this window, the next Vc could go away, and we 
                // could point to a stale Vc. So, we start at the head of the list. 
                // Note that this can never lead to a infinite loop, since we don't process the 
                // internal close'd VCs repeatedly.
                //
    
                NextVc = Adapter->GpcClientVcList.Flink;
            }
        }
    }

    PS_UNLOCK(&Adapter->Lock);

    REFDEL(&WanLink->RefCount, FALSE, 'WANU');

    return NDIS_STATUS_SUCCESS;
}

VOID
WanIncomingCallQoSChange(
    IN  NDIS_HANDLE ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS CallParameters
    )
{
    DEBUGCHK;
}

VOID
WanIncomingCloseCall(
    IN NDIS_STATUS CloseStatus,
    IN NDIS_HANDLE ProtocolVcContext,
    IN PVOID CloseData          OPTIONAL,
    IN UINT Size                OPTIONAL
    )
{
    PGPC_CLIENT_VC Vc = (PGPC_CLIENT_VC) ProtocolVcContext;

    PsAssert(Vc);

    CheckLLTag(Vc, GpcClientVc);

    PS_LOCK(&Vc->Adapter->Lock);

    PS_LOCK_DPC(&Vc->Lock);

    InternalCloseCall(Vc);

    return;
}

VOID
WanIncomingDropParty(
    IN NDIS_STATUS DropStatus,
    IN NDIS_HANDLE ProtocolPartyContext,
    IN PVOID CloseData          OPTIONAL,
    IN UINT Size                OPTIONAL
    )
{
    DEBUGCHK;
}

VOID
WanCallConnected(
    IN  NDIS_HANDLE ProtocolPartyContext
    )
{
    DEBUGCHK;
}

NDIS_STATUS
WanCoRequest(
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST NdisRequest
    )
{
    DEBUGCHK;
    return NDIS_STATUS_INVALID_OID;
}

VOID
WanCoRequestComplete(
    IN  NDIS_STATUS Status,
    IN  NDIS_HANDLE ProtocolAfContext,
    IN  NDIS_HANDLE ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST NdisRequest
    )
{
    ClRequestComplete(ProtocolAfContext,
                      NdisRequest,
                      Status);
}

NDIS_STATUS
UpdateWanLinkBandwidthParameters(PPS_WAN_LINK WanLink)
{
    //
    // Called any time the link speed is updated. This
    // function generates the adapter link speed and the
    // and non-best-effort rate limits, both in bytes per second.
    //

    PsUpdateLinkSpeed(WanLink->Adapter,
                      WanLink->RawLinkSpeed,
                      &WanLink->RemainingBandWidth,
                      &WanLink->LinkSpeed,
                      &WanLink->NonBestEffortLimit,
                      &WanLink->Lock);

    return UpdateWanSchedulingPipe(WanLink);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\timestmp.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  EXTERNAL (SHARED) DEFINITIONS                                           //
//                                                                                                          //
// ( Any user mode app which wants to use this functionality should copy this section of the header file)   //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//  WildCard definitions for Ip Address, Port and Protocol                                          //

#define UL_ANY  0xffffffff
#define US_ANY  0xffff

//  Definitions for Direction (Send/Recv)                                                           //

#define DIR_SEND    1
#define DIR_RECV    2

//  Common InBuf structure: This is same for either type of request                                 //
//  For wildcarding, use UL_ANY for ULONGs and US_ANY for USHORTs                                   //
//                                                                                                  //
//  This will be layed out in the buffer in this fashion:                                           //
//          +---------------------------------------------+                                         //
//  0x00    |       SrcIp (4)    | SrcPort(2)  Padding(2) |                                         //
//          +---------------------------------------------+                                         //
//  0x08    |       DstIp (4)    | DstPort(2)  Padding(2) |                                         //
//          +---------------------------------------------+                                         //
//  0x10    | Proto(2)| Dir'n(2) |                                                                  //
//          +---------+----------+                                                                  //

typedef struct _TIMESTMP_REQ
{
    ULONG   SrcIp;
    USHORT  SrcPort;
    ULONG   DstIp;
    USHORT  DstPort;
    USHORT  Proto;
    USHORT  Direction;
} TIMESTMP_REQ, *PTIMESTMP_REQ;


//  1. MARK_IN_BUF_RECORD: THIS WILL MARK THE TIMESTAMPS IN A BUFFER WITH IP-ID'S AND PACKET-SIZES  //
//                                                                                                  //
//  This will be laid out in the buffer in this fashion:                                            //
//          +---------------------------------------------+                                         //
//  0x00    |IpId(2) Size(2)    |   Padding(4)            |                                         //
//          +---------------------------------------------+                                         //
//  0x08    |           TimeValue (8)                     |                                         //
//          +---------------------------------------------+                                         //

#define IOCTL_TIMESTMP_REGISTER_IN_BUF      CTL_CODE(   FILE_DEVICE_NETWORK, 23, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_DEREGISTER_IN_BUF    CTL_CODE(   FILE_DEVICE_NETWORK, 24, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_FINISH_BUFFERING     CTL_CODE(   FILE_DEVICE_NETWORK, 25, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct _MARK_IN_BUF_RECORD
{
	USHORT	IpId;   
	USHORT	Size;
	UINT64	TimeValue;
} MARK_IN_BUF_RECORD, *PMARK_IN_BUF_RECORD;

//  This is the MINIMUM size of the buffer that should be passed in with every request to copy      //
//  timestamps colleced in the drivers internal buffer. Application should call this frequently     //
//  to prevent driver buffer re-use                                                                 //
#define	PACKET_STORE_SIZE	(sizeof(MARK_IN_BUF_RECORD)*5000)



//  2. MARK_IN_PKT_RECORD: THIS WILL MARK THE TIMESTAMPS IN THE PACKET ITSELF                       //
//                                                                                                  //
//  This will be laid out in the packet in this fashion:                                            //
//          +---------------------------------------------+                                         //
//  0x00    |           Time Sent - App (8)               |                                         //
//          +---------------------------------------------+                                         //
//  0x08    |           Time Rcvd - App (8)               |                                         //
//          +---------------------------------------------+                                         //
//  0x10    |           Time Sent - OS (8)                |                                         //
//          +---------------------------------------------+                                         //
//  0x18    |           Time Rcvd - OS (8)                |                                         //
//          +---------------------------------------------+                                         //
//  0x20    |           Latency - App (8)                 |                                         //
//          +---------------------------------------------+                                         //
//  0x28    | BufferSize - App(4) | Seq No - App (4)      |                                         //
//          +---------------------------------------------+                                         //
//                                                                                                  //

#define IOCTL_TIMESTMP_REGISTER_IN_PKT            CTL_CODE(   FILE_DEVICE_NETWORK, 21, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_DEREGISTER_IN_PKT           CTL_CODE(   FILE_DEVICE_NETWORK, 22, METHOD_BUFFERED, FILE_WRITE_ACCESS)

typedef struct _MARK_IN_PKT_RECORD
{
    UINT64  TimeSent;
    UINT64  TimeReceived;
    UINT64  TimeSentWire;         
    UINT64  TimeReceivedWire;     
    UINT64  Latency;
    INT     BufferSize;
    INT     SequenceNumber;
} MARK_IN_PKT_RECORD, *PMARK_IN_PKT_RECORD;



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  INTERNAL TIMESTMP DEFINITIONS                                           //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define IOCTL_PSCHED_ZAW_EVENT                  CTL_CODE(   FILE_DEVICE_NETWORK, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define     MARK_NONE   0
#define     MARK_IN_PKT 1
#define     MARK_IN_BUF 2


typedef struct _TS_ENTRY {
    LIST_ENTRY              Linkage;

    ULONG	                SrcIp;
    USHORT                  SrcPort;
    ULONG	                DstIp;
    USHORT                  DstPort;
    USHORT                  Proto;
    USHORT                  Type;
    USHORT                  Direction;
    
    PFILE_OBJECT            FileObject;    
    PMARK_IN_BUF_RECORD	    pPacketStore;
    PMARK_IN_BUF_RECORD	    pPacketStoreHead;
} TS_ENTRY, *PTS_ENTRY;


extern LIST_ENTRY       TsList;
extern NDIS_SPIN_LOCK   TsSpinLock;
extern ULONG            TsCount;

VOID
InitializeTimeStmp( PPSI_INFO Info );


BOOL
AddRequest(  PFILE_OBJECT FileObject, 
             ULONG  SrcIp, 
             USHORT SrcPort,
             ULONG  DstIp, 
             USHORT DstPort,
             USHORT Proto,
             USHORT Type,
             USHORT Direction);


void
RemoveRequest(  PFILE_OBJECT FileObject, 
                ULONG  SrcIp, 
                USHORT SrcPort,
                ULONG  DstIp, 
                USHORT DstPort,
                USHORT Proto);

int
CopyTimeStmps( PFILE_OBJECT FileObject, PVOID buf, ULONG    Len);

VOID
UnloadTimeStmp();


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  COPIED TRANSPORT DEFINITIONS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define IPPROTO_TCP                     6               
#define IPPROTO_UDP                     17  
#define IP_MF_FLAG                      0x0020              
#define IP_VERSION                      0x40
#define IP_VER_FLAG                     0xF0
#define TCP_OFFSET_MASK                 0xf0
#define TCP_HDR_SIZE(t)                 (uint)(((*(uchar *)&(t)->tcp_flags) & TCP_OFFSET_MASK) >> 2)
#define IP_OFFSET_MASK                  ~0x00E0         
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define net_short(_x) _byteswap_ushort((USHORT)(_x))
#else
#define net_short(x)                    ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))
#endif

typedef int                             SeqNum;                         // A sequence number.

struct TCPHeader {
        ushort                          tcp_src;                        // Source port.
        ushort                          tcp_dest;                       // Destination port.
        SeqNum                          tcp_seq;                        // Sequence number.
        SeqNum                          tcp_ack;                        // Ack number.
        ushort                          tcp_flags;                      // Flags and data offset.
        ushort                          tcp_window;                     // Window offered.
        ushort                          tcp_xsum;                       // Checksum.
        ushort                          tcp_urgent;                     // Urgent pointer.
};

typedef struct TCPHeader TCPHeader;

struct UDPHeader {
        ushort          uh_src;                         // Source port.
        ushort          uh_dest;                        // Destination port.
        ushort          uh_length;                      // Length
        ushort          uh_xsum;                        // Checksum.
}; /* UDPHeader */

#define MIN_ETYPE           0x600           // Minimum valid Ethertype

//* Structure of an Ethernet header.
typedef struct ENetHeader {
    uchar       eh_daddr[ARP_802_ADDR_LENGTH];
    uchar       eh_saddr[ARP_802_ADDR_LENGTH];
    ushort      eh_type;
} ENetHeader;


typedef struct UDPHeader UDPHeader;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\psched\sys\wmi.c ===
/*++
Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    wmi.c

Abstract:
    Psched's WMI support.

Author:
    Rajesh Sundaram (rajeshsu) 01-Aug-1998.

Environment:

    Kernel Mode

Revision History:

--*/

#include "psched.h"
#pragma hdrstop


//
// Forward declaration for using in #pragma.
//

NTSTATUS
PsQueryGuidDataSize(
    PADAPTER Adapter, 
    PPS_WAN_LINK WanLink,
    PGPC_CLIENT_VC Vc,
    NDIS_OID Oid,
    PULONG BytesNeeded);


#pragma alloc_text(PAGE, PsQueryGuidDataSize)

#define ALIGN(x) (((x) + 7) & ~7)

NDIS_STRING DefaultProfile = NDIS_STRING_CONST("Default Profile");

#define fPS_GUID_TO_OID           0x00000001   // Normal GUID to OID mapping
#define fPS_GUID_TO_STATUS        0x00000002   // GUID to status mapping
#define fPS_GUID_ANSI_STRING      0x00000004   // ANSI string
#define fPS_GUID_UNICODE_STRING   0x00000008   // Unicode String
#define fPS_GUID_ARRAY            0x00000010   // Array
#define fPS_GUID_EVENT_ENABLED    0x00000020   // Event is enabled
#define fPS_GUID_NOT_SETTABLE     0x00000040   // GUID is read only
#define fPS_GUID_EVENT_PERMANENT  0x00000080

#define PS_GUID_SET_FLAG(m, f)          ((m)->Flags |= (f))
#define PS_GUID_CLEAR_FLAG(m, f)                ((m)->Flags &= ~(f))
#define PS_GUID_TEST_FLAG(m, f)         (((m)->Flags & (f)) != 0)
#define MOF_RESOURCE_NAME       L"PschedMofResource"

#if DBG
#define NUMBER_QOS_GUIDS 30
#else
#define NUMBER_QOS_GUIDS 24
#endif



NDIS_GUID   gPschedSupportedGuids[NUMBER_QOS_GUIDS] =
{
#if DBG
    //
    // GUID_QOS_LOG_LEVEL
    //
    {{0x9dd7f3aeL,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b},
     OID_QOS_LOG_LEVEL,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_LOG_MASK
    //
    {{0x9e696320L,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b},
     OID_QOS_LOG_MASK,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_STATUS_LOG_THRESHOLD
    //
    {{0x357b74d2L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37},
     QOS_STATUS_LOG_THRESHOLD,
     4,
     fPS_GUID_TO_STATUS
    },

    //
    // GUID_QOS_LOG_BUFFER_SIZE
    //
    {{0x357b74d3L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37},
     OID_QOS_LOG_BUFFER_SIZE,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_LOG_THRESHOLD
    //
    {{0x357b74d0L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37},
     OID_QOS_LOG_THRESHOLD,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_LOG_DATA
    //
    {{0x357b74d1L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37},
     OID_QOS_LOG_DATA,
     (ULONG)-1,
     fPS_GUID_TO_OID 
    },
#endif

    //
    // GUID_QOS_TC_SUPPORTED
    //
    {{0xe40056dcL,0x40c8,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x59,0x15},
     OID_QOS_TC_SUPPORTED,
     -1,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_REMAINING_BANDWIDTH
    //
    {{0xc4c51720L,0x40ec,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_REMAINING_BANDWIDTH,
     4,
     fPS_GUID_TO_OID | fPS_GUID_TO_STATUS | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_BESTEFFORT_BANDWIDTH
    //
    {{0xed885290L,0x40ec,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_BESTEFFORT_BANDWIDTH,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_HIERARCHY_CLASS
    //
    {{0xf2cc20c0,0x70c7,0x11d1,0xab,0x5c,0x0,0xa0,0xc9,0x24,0x88,0x37},
     OID_QOS_HIERARCHY_CLASS,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_LATENCY
    //
    {{0xfc408ef0L,0x40ec,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_LATENCY,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_COUNT
    //
    {{0x1147f880L,0x40ed,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_FLOW_COUNT,
     4,
     fPS_GUID_TO_OID | fPS_GUID_TO_STATUS | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_NON_BESTEFFORT_LIMIT
    //
    {{0x185c44e0L,0x40ed,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_NON_BESTEFFORT_LIMIT,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_SCHEDULING_PROFILES_SUPPORTED
    //
    {{0x1ff890f0L,0x40ed,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_SCHEDULING_PROFILES_SUPPORTED,
     8,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_CURRENT_SCHEDULING_PROFILE
    //
    {{0x2966ed30L,0x40ed,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_CURRENT_SCHEDULING_PROFILE,
     -1,
     fPS_GUID_TO_OID | fPS_GUID_UNICODE_STRING | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_MAX_OUTSTANDING_SENDS
    //
    {{0x161ffa86L,0x6120,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_MAX_OUTSTANDING_SENDS,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_DISABLE_DRR
    //
    {{0x1fa6dc7aL,0x6120,0x11d1,0x2c,0x91,0x00,0xaa,0x00,0x57,0x49,0x15},
     OID_QOS_DISABLE_DRR,
     4,
     fPS_GUID_TO_OID 
    },

    //
    // GUID_QOS_STATISTICS_BUFFER
    //
    {{0xbb2c0980L,0xe900,0x11d1,0xb0,0x7e,0x00,0x80,0xc7,0x13,0x82,0xbf},
     OID_QOS_STATISTICS_BUFFER,
     -1,
     fPS_GUID_TO_OID 
    },

    //
    // GUID_QOS_TC_INTERFACE_UP_INDICATION
    //
    {{0x0ca13af0L,0x46c4,0x11d1,0x78,0xac,0x00,0x80,0x5f,0x68,0x35,0x1e},
     NDIS_STATUS_INTERFACE_UP,
     8,
     fPS_GUID_TO_STATUS | fPS_GUID_EVENT_ENABLED | fPS_GUID_EVENT_PERMANENT
    },

    //
    // GUID_QOS_TC_INTERFACE_DOWN_INDICATION
    //
    {{0xaf5315e4L,0xce61,0x11d1,0x7c,0x8a,0x00,0xc0,0x4f,0xc9,0xb5,0x7c},
     NDIS_STATUS_INTERFACE_DOWN,
     8,
     fPS_GUID_TO_STATUS | fPS_GUID_EVENT_ENABLED | fPS_GUID_EVENT_PERMANENT
    },

    //
    // GUID_QOS_TC_INTERFACE_CHANGE_INDICATION
    //
    {{0xda76a254L,0xce61,0x11d1,0x7c,0x8a,0x00,0xc0,0x4f,0xc9,0xb5,0x7c},
     NDIS_STATUS_INTERFACE_CHANGE,
     8,
     fPS_GUID_TO_STATUS | fPS_GUID_EVENT_ENABLED | fPS_GUID_EVENT_PERMANENT
    },

    //
    // GUID_QOS_FLOW_MODE
    //
    {{0x5c82290aL,0x515a,0x11d2,0x8e,0x58,0x00,0xc0,0x4f,0xc9,0xbf,0xcb},
     OID_QOS_FLOW_MODE,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_ISSLOW_FLOW
    //
    {{0xabf273a4,0xee07,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b},
     OID_QOS_ISSLOW_FLOW,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_TIMER_RESOLUTION
    //
    {{0xba10cc88,0xf13e,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b},
     OID_QOS_TIMER_RESOLUTION,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_IP_CONFORMING
    //
    {{0x07f99a8b, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b},
     OID_QOS_FLOW_IP_CONFORMING,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_IP_NONCONFORMING
    //
    {{0x087a5987, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b},
     OID_QOS_FLOW_IP_NONCONFORMING,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_8021P_CONFORMING
    //
    {{0x08c1e013, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b},
     OID_QOS_FLOW_8021P_CONFORMING,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_FLOW_8021P_NONCONFORMING
    //
    {{0x09023f91, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b},
     OID_QOS_FLOW_8021P_NONCONFORMING,
     4,
     fPS_GUID_TO_OID | fPS_GUID_NOT_SETTABLE
    },

    //
    // GUID_QOS_ENABLE_AVG_STATS
    //
    {{0xbafb6d11, 0x27c4, 0x4801, 0xa4, 0x6f, 0xef, 0x80, 0x80, 0xc1, 0x88, 0xc8},
     OID_QOS_ENABLE_AVG_STATS,
     4,
     fPS_GUID_TO_OID
    },

    //
    // GUID_QOS_ENABLE_WINDOW_ADJUSTMENT
    //
    {{0xaa966725, 0xd3e9, 0x4c55, 0xb3, 0x35, 0x2a, 0x0, 0x27, 0x9a, 0x1e, 0x64},
     OID_QOS_ENABLE_WINDOW_ADJUSTMENT,
     4,
     fPS_GUID_TO_OID
    }
};

NTSTATUS
PsWmiGetGuid(
        OUT     PNDIS_GUID                              *ppNdisGuid,
        IN      LPGUID                                  guid,
        IN      NDIS_OID                                Oid
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UINT            c;
    PNDIS_GUID      pNdisGuid;
    NDIS_STATUS     RetStatus = STATUS_UNSUCCESSFUL;
    
    //
    //      Search the custom GUIDs
    //
    for (c = 0, pNdisGuid = gPschedSupportedGuids;
         (c < NUMBER_QOS_GUIDS);
         c++, pNdisGuid++)
    {
        //
        //      Make sure that we have a supported GUID and the GUID maps
        //      to an OID.
        //
        if (NULL != guid)
        {
            //
            //  We are to look for a guid to oid mapping.
            //
            if (NdisEqualMemory(&pNdisGuid->Guid, guid, sizeof(GUID)))
            {
                //
                //      We found the GUID, save the OID that we will need to
                //      send to the miniport.
                //
                RetStatus = STATUS_SUCCESS;
                *ppNdisGuid = pNdisGuid;
                
                break;
            }
        }
        else
        {
            //
            //  We need to find the quid for the status indication
            //
            if (PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_TO_STATUS) &&
                (pNdisGuid->Oid == Oid))
            {
                RetStatus = STATUS_SUCCESS;
                *ppNdisGuid = pNdisGuid;
                
                break;
            }
        }
    }
    
    return(RetStatus);
}

NTSTATUS
PsWmiRegister(
        IN      ULONG_PTR                               RegistrationType,
        IN      PWMIREGINFO                             wmiRegInfo,
        IN      ULONG                                   wmiRegInfoSize,
        IN      PULONG                                  pReturnSize
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PWMIREGINFO             pwri;
    ULONG                   SizeNeeded = 0;
    PNDIS_GUID              pguid;
    PWMIREGGUID             pwrg;
    PUCHAR                  ptmp;
    NTSTATUS                Status;
    UINT                    c;
    
    //
    //      Initialize the return size.
    //
    *pReturnSize = 0;
    
    //
    //  Is this a register request?
    //
    if (WMIREGISTER == RegistrationType)
    {
        
        //
        // Determine the amount of space needed for the GUIDs, the MOF and the
        // registry path
        //
        SizeNeeded = sizeof(WMIREGINFO) + 
            (NUMBER_QOS_GUIDS * sizeof(WMIREGGUID)) +
            //(sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR) + sizeof(USHORT)) +
            (PsMpName.Length + sizeof(USHORT));
        
        
        //
        //      We need to give this above information back to WMI.
        //
        if (wmiRegInfoSize < SizeNeeded) 
        {
            PsAssert(wmiRegInfoSize >= 4);
            
            *((PULONG)wmiRegInfo) = SizeNeeded ;

            *pReturnSize = sizeof(ULONG);
            
            Status = STATUS_SUCCESS;
                
            PsDbgOut(DBG_TRACE, DBG_WMI,
                     ("[PsWmiRegister]: Insufficient buffer space for WMI registration information.\n"));
            
            return Status;
        }
        
        //
        //      Get a pointer to the buffer passed in.
        //
        pwri = wmiRegInfo;
        
        *pReturnSize = SizeNeeded;
        
        NdisZeroMemory(pwri, SizeNeeded);
        
        pwri->BufferSize     = SizeNeeded;

        //
        // Copy the GUIDs
        //

        pwri->GuidCount      = NUMBER_QOS_GUIDS;
        for(c = 0, pwrg = pwri->WmiRegGuid, pguid = gPschedSupportedGuids; 
            c < NUMBER_QOS_GUIDS; 
            c++, pguid++, pwrg++)
        {
            RtlCopyMemory(&pwrg->Guid, &pguid->Guid, sizeof(GUID));
        }
        
        //
        // Fill in the registry path
        //
        ptmp = (PUCHAR)pwrg;
        pwri->RegistryPath = (ULONG)((ULONG_PTR)ptmp - (ULONG_PTR)pwri);
        *((PUSHORT)ptmp) = PsMpName.Length;
        ptmp += sizeof(USHORT);
        RtlCopyMemory(ptmp, PsMpName.Buffer, PsMpName.Length);
        
        

	    /*
        //
        //      Get a pointer to the destination for the MOF name.
        //
        ptmp += PsMpName.Length;
        
        //
        //      Save the offset to the mof resource.
        //
        /*
        pwri->MofResourceName = (ULONG)((ULONG_PTR)ptmp - (ULONG_PTR)pwri);
        *((PUSHORT)ptmp) = sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR);
        ptmp += sizeof(USHORT);
        
        //
        //      Copy the mof name into the wri buffer.
        //
        RtlCopyMemory(ptmp, MOF_RESOURCE_NAME, sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR));
        */
        Status = STATUS_SUCCESS;
    }
    else
    {
        PsDbgOut(DBG_FAILURE, DBG_WMI,
                 ("[PsWmiRegister]: Unsupported registration type\n"));
        
        Status = STATUS_INVALID_PARAMETER;
    }

    return(Status);
}

NTSTATUS
PsTcNotify(IN PADAPTER     Adapter, 
           IN PPS_WAN_LINK WanLink,
           IN NDIS_OID     Oid,
           IN PVOID        StatusBuffer,
           IN ULONG        StatusBufferSize)
{
    KIRQL      OldIrql;
    NTSTATUS   NtStatus = STATUS_SUCCESS;
    
    do
    {
        PWCHAR                  pInstanceName;
        USHORT                  cbInstanceName;
        PWNODE_SINGLE_INSTANCE  wnode;
        ULONG                   wnodeSize;
        ULONG                   DataBlockSize   = 0;
        ULONG                   InstanceNameSize   = 0;
        ULONG                   BufSize;
        PUCHAR                  ptmp;
        PNDIS_GUID              pNdisGuid;
       
        REFADD(&Adapter->RefCount, 'WMIN'); 
        
        if(Adapter->MediaType == NdisMediumWan) {
            
            if(!WanLink) {
                
                REFDEL(&Adapter->RefCount, FALSE, 'WMIN'); 
                
                return STATUS_UNSUCCESSFUL;
            }
            
            PS_LOCK(&WanLink->Lock);
            
            if(WanLink->State != WanStateOpen) {
                
                PS_UNLOCK(&WanLink->Lock);
                
                REFDEL(&Adapter->RefCount, FALSE, 'WMIN'); 
                
                return STATUS_UNSUCCESSFUL;
            }
            else {
                REFADD(&WanLink->RefCount, 'WMIN'); 

                PS_UNLOCK(&WanLink->Lock);
            }
            
            pInstanceName  = WanLink->InstanceName.Buffer;
            cbInstanceName = WanLink->InstanceName.Length;
        }
        else {
            
            //
            // Get nice pointers to the instance names.
            //
            
            pInstanceName  = Adapter->WMIInstanceName.Buffer;
            cbInstanceName = Adapter->WMIInstanceName.Length;
        }
        
        //
        // If there is no instance name then we can't indicate an event.
        //
        if (NULL == pInstanceName)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
        
        //
        // Check to see if the status is enabled for WMI event indication.
        //
        NtStatus = PsWmiGetGuid(&pNdisGuid, NULL, Oid);
        if ((!NT_SUCCESS(NtStatus)) ||
            !PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_EVENT_ENABLED))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
        
        //
        // Determine the amount of wnode information we need.
        //
        wnodeSize = ALIGN(sizeof(WNODE_SINGLE_INSTANCE));

        //
        // If the data item is an array then we need to add in the number of
        // elements.
        //
        if (PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_ARRAY))
        {
            DataBlockSize = StatusBufferSize + sizeof(ULONG);
        }
        else
        {
            DataBlockSize = StatusBufferSize;
        }
        
        //
        // We have a guid registered and active.
        //
   
        // 
        // The data has to start at a word boundary, so need to align everything before it (the wnode and the
        // instance name)
        //
        InstanceNameSize = ALIGN(cbInstanceName + sizeof(USHORT));
        BufSize = wnodeSize + InstanceNameSize + DataBlockSize;
        
        wnode = ExAllocatePoolWithTag(NonPagedPool, BufSize, WMITag);
        
        if (NULL == wnode)
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
        
        NdisZeroMemory(wnode, BufSize);
        wnode->WnodeHeader.BufferSize = BufSize;
        wnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(PsDeviceObject);
        wnode->WnodeHeader.Version = 1;
        KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
        
        RtlCopyMemory(&wnode->WnodeHeader.Guid, &pNdisGuid->Guid, sizeof(GUID));
        wnode->WnodeHeader.Flags = WNODE_FLAG_EVENT_ITEM |
            WNODE_FLAG_SINGLE_INSTANCE;
        
        wnode->OffsetInstanceName = wnodeSize;
       
        wnode->DataBlockOffset = wnodeSize + InstanceNameSize;

        wnode->SizeDataBlock = DataBlockSize;
        
        //
        // Get a pointer to the start of the data block.
        //
        ptmp = (PUCHAR)wnode + wnodeSize;
        
        //
        // Copy in the instance name. wnodesize is already aligned to 8 byte boundary, so the instance
        // name will begin at a 8 byte boundary.
        //
        *((PUSHORT)ptmp) = cbInstanceName;
        NdisMoveMemory(ptmp + sizeof(USHORT), pInstanceName, cbInstanceName);
        
        //
        // Increment ptmp to the start of the data block.
        //
        ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;
        
        //
        // Copy in the data.
        //
        if (PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_ARRAY))
        {
            //
            // If the status is an array but there is no data then complete it with no
            // data and a 0 length
            //
            if ((NULL == StatusBuffer) || (0 == StatusBufferSize))
            {
                *((PULONG)ptmp) = 0;
            }
            else
            {
                //
                // Save the number of elements in the first ULONG.
                //
                *((PULONG)ptmp) = StatusBufferSize / pNdisGuid->Size;
                
                //
                // Copy the data after the number of elements.
                //
                NdisMoveMemory(ptmp + sizeof(ULONG), StatusBuffer, StatusBufferSize);
            }
        }
        else
        {
            PsAssert(StatusBuffer != NULL);
            
            //
            // Do we indicate any data up?
            //
            if (0 != DataBlockSize)
            {
                //
                // Copy the data into the buffer.
                //
                NdisMoveMemory(ptmp, StatusBuffer, DataBlockSize);
            }
        }
        
        //
        // Indicate the event to WMI. WMI will take care of freeing
        // the WMI struct back to pool.
        //
        NtStatus = IoWMIWriteEvent(wnode);
        if (!NT_SUCCESS(NtStatus))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsTcNotify]: Adapter %08X, Unable to indicate the WMI event.\n", Adapter));
            
            ExFreePool(wnode);
        }
    } while (FALSE);
    
    REFDEL(&Adapter->RefCount, FALSE, 'WMIN'); 
    
    if(WanLink) {
       
        REFDEL(&WanLink->RefCount, FALSE, 'WMIN'); 
    }
    
    return NtStatus;
    
}


NTSTATUS
FASTCALL
PsWmiEnableEvents(
    IN      LPGUID                                      Guid
    )
/*++
  
  Routine Description:
  
  Arguments:
  
  Return Value:
  
  --*/
{
    NTSTATUS        Status;
    PNDIS_GUID      pNdisGuid;
    
    do
    {
        //
        //      Get a pointer to the Guid/Status to enable.
        //
        Status = PsWmiGetGuid(&pNdisGuid, Guid, 0);
        
        if (!NT_SUCCESS(Status))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiEnableEvents]: Cannot find the guid to enable an event\n"));
            
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        //
        //      Is this GUID an event indication?
        //
        if (!PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_TO_STATUS))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiEnableEvents]: Guid is not an event request \n"));
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        
        //
        //      Mark the guid as enabled
        //
        PS_GUID_SET_FLAG(pNdisGuid, fPS_GUID_EVENT_ENABLED);
        Status = STATUS_SUCCESS;
        
    } while (FALSE);
    
    return(Status);
}

NTSTATUS
FASTCALL
PsWmiDisableEvents(
        IN      LPGUID                                      Guid
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS        Status;
    PNDIS_GUID      pNdisGuid;
    
    do
    {
        //
        //      Get a pointer to the Guid/Status to enable.
        //
        Status = PsWmiGetGuid(&pNdisGuid, Guid, 0);
        if (!NT_SUCCESS(Status))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiDisableEvents]: Cannot find the guid to disable an event\n"));
            
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        //
        //      Is this GUID an event indication?
        //
        if (!PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_TO_STATUS))
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiDisableEvents]: Guid is not an event request \n"));
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
        
        if(!PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_EVENT_PERMANENT)) {
            //
            //  Mark the guid as disabled
            //
            PS_GUID_CLEAR_FLAG(pNdisGuid, fPS_GUID_EVENT_ENABLED);
        }
        
        Status = STATUS_SUCCESS;
        
    } while (FALSE);
    
    return(Status);
}

#define WMI_BUFFER_TOO_SMALL(_BufferSize, _Wnode, _WnodeSize, _pStatus, _pRSize)        \
{                                                                                       \
        if ((_BufferSize) < sizeof(WNODE_TOO_SMALL))                                    \
        {                                                                               \
                *(_pStatus) = STATUS_BUFFER_TOO_SMALL;                                  \
        }                                                                               \
        else                                                                            \
        {                                                                               \
                (_Wnode)->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);             \
                (_Wnode)->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;                    \
                ((PWNODE_TOO_SMALL)(_Wnode))->SizeNeeded = (_WnodeSize);                \
                *(_pRSize) = sizeof(WNODE_TOO_SMALL);                                   \
                *(_pStatus) = STATUS_SUCCESS;                                           \
        }                                                                               \
}

NTSTATUS
PsQueryGuidDataSize(
    PADAPTER Adapter, 
    PPS_WAN_LINK WanLink,
    PGPC_CLIENT_VC Vc,
    NDIS_OID Oid,
    PULONG BytesNeeded)
{
    ULONG Len;
    ULONG BytesWritten;
    NDIS_STATUS Status;

    PAGED_CODE();


    if(Vc) 
    {
        switch(Oid) 
        {
          case OID_QOS_STATISTICS_BUFFER:
              
              // If the query comes for a VC, then we return per flow stats
              // else we return per adapter stats. The query is also sent through
              // the scheduling components, so that they can fill in the per flow
              // or per query stats.
              //
              
              
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
              
              (*Vc->PsComponent->QueryInformation)
                  (Vc->PsPipeContext,
                   Vc->PsFlowContext,
                   Oid,
                   Len,
                   NULL,
                   &BytesWritten, 
                   BytesNeeded,
                   &Status);
              
              *BytesNeeded += sizeof(PS_FLOW_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              return STATUS_SUCCESS;

          case OID_QOS_ISSLOW_FLOW:
          case OID_QOS_FLOW_IP_CONFORMING:
          case OID_QOS_FLOW_IP_NONCONFORMING:
          case OID_QOS_FLOW_8021P_CONFORMING:
          case OID_QOS_FLOW_8021P_NONCONFORMING:
              *BytesNeeded = sizeof(ULONG);
              return STATUS_SUCCESS;
              
          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    //
    // The following OIDs are similar for both WAN and Adapters
    //
    switch(Oid) 
    {
        //
        // (12636): The following will be enabled when we do admission control over WAN. 
        // case OID_QOS_REMAINING_BANDWIDTH:
        // case OID_QOS_NON_BESTEFFORT_LIMIT:
        //

      case OID_QOS_BESTEFFORT_BANDWIDTH:
      case OID_QOS_LATENCY:
      case OID_QOS_FLOW_COUNT:
      case OID_QOS_FLOW_MODE:
      case OID_QOS_MAX_OUTSTANDING_SENDS:
      case OID_QOS_DISABLE_DRR:
      case OID_QOS_TIMER_RESOLUTION:
      case OID_QOS_ENABLE_AVG_STATS:
      case OID_QOS_ENABLE_WINDOW_ADJUSTMENT:
#if DBG
      case OID_QOS_LOG_BUFFER_SIZE:
      case OID_QOS_LOG_THRESHOLD:
      case OID_QOS_LOG_LEVEL:
      case OID_QOS_LOG_MASK:
#endif

          *BytesNeeded = sizeof(ULONG);
          
          return STATUS_SUCCESS;
          
#if DBG
      case OID_QOS_LOG_DATA:
            
          *BytesNeeded = SchedtGetBytesUnread();
          
          return STATUS_SUCCESS;
          
#endif
          
      case OID_QOS_CURRENT_SCHEDULING_PROFILE:
          
          if(!Adapter->ProfileName.Buffer) {
              
              *BytesNeeded = sizeof(DefaultProfile);
          }
          else {
              
              *BytesNeeded = Adapter->ProfileName.Length;
          }
          
          return STATUS_SUCCESS;
    }
    
    //
    // OIDs that are WAN link specific
    //
    
    if(WanLink) 
    {
        switch(Oid) 
        {
          case OID_QOS_HIERARCHY_CLASS:
          {
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
              
              (*WanLink->PsComponent->QueryInformation)
                  (WanLink->PsPipeContext,
                   0,
                   Oid, 
                   Len, 
                   NULL,
                   &BytesWritten,
                   BytesNeeded,
                   &Status);
         
              return STATUS_SUCCESS;
          }
          case OID_QOS_STATISTICS_BUFFER:
          {
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
          
              (*WanLink->PsComponent->QueryInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid,
                   Len,
                   NULL,
                   &BytesWritten, 
                   BytesNeeded,
                   &Status);
          
              *BytesNeeded += sizeof(PS_ADAPTER_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              return STATUS_SUCCESS;
          }
          
          case OID_QOS_TC_SUPPORTED:
              
              *BytesNeeded = 0;
              
              CollectWanNetworkAddresses(Adapter, WanLink, BytesNeeded, NULL);
              
              return STATUS_SUCCESS;

          default:

              return STATUS_WMI_NOT_SUPPORTED;
        }
    }
    
    if(Adapter->MediaType != NdisMediumWan) 
    {

        switch(Oid) 
        {
          case OID_QOS_TC_SUPPORTED:
              
              *BytesNeeded = 0;
              
              CollectNetworkAddresses(Adapter, BytesNeeded, NULL);
              
              return STATUS_SUCCESS;
          
          //
          // (12636): Take the next 2 case statements away when we turn on admission control over WAN links.
          // 
          
          case OID_QOS_REMAINING_BANDWIDTH:
          case OID_QOS_NON_BESTEFFORT_LIMIT:

              *BytesNeeded = sizeof(ULONG);
              
              return STATUS_SUCCESS;

          case OID_QOS_HIERARCHY_CLASS:
          {
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
              
              (*Adapter->PsComponent->QueryInformation)
                  (Adapter->PsPipeContext,
                   0,
                   Oid, 
                   Len, 
                   NULL,
                   &BytesWritten,
                   BytesNeeded,
                   &Status);
         
              return STATUS_SUCCESS;
          }

          case OID_QOS_STATISTICS_BUFFER:
          {
              Len = 0;
              BytesWritten = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              *BytesNeeded = 0;
              
              (*Adapter->PsComponent->QueryInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid,
                   Len,
                   NULL,
                   &BytesWritten, 
                   BytesNeeded,
                   &Status);
              
              *BytesNeeded += sizeof(PS_ADAPTER_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              return STATUS_SUCCESS;
          }
          
          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    return STATUS_WMI_NOT_SUPPORTED;
}

NTSTATUS
PsQueryGuidData(
    PADAPTER Adapter,
    PPS_WAN_LINK WanLink,
    PGPC_CLIENT_VC Vc,
    NDIS_OID Oid,
    PVOID Buffer,
    ULONG BufferSize)
{

    UNALIGNED PULONG pData = (UNALIGNED PULONG) Buffer;
    ULONG Len;
    ULONG BytesNeeded;
    ULONG BytesWritten;
    PUCHAR Data;
    NDIS_STATUS Status;
    PPS_COMPONENT_STATS  Cstats;

    PsAssert(((ULONGLONG)pData % sizeof(PULONG)) == 0);

    if(Vc) 
    {
        switch(Oid) 
        {
          case OID_QOS_FLOW_IP_CONFORMING:
              *pData = (((PCF_INFO_QOS)(Vc->CfInfoQoS))->ToSValue) >> 2;
              return STATUS_SUCCESS;

          case OID_QOS_FLOW_IP_NONCONFORMING:
              *pData = (Vc->IPPrecedenceNonConforming >> 2);
              return STATUS_SUCCESS;

          case OID_QOS_FLOW_8021P_CONFORMING:
              *pData = Vc->UserPriorityConforming;
              return STATUS_SUCCESS;

          case OID_QOS_FLOW_8021P_NONCONFORMING:
              *pData = Vc->UserPriorityNonConforming;
              return STATUS_SUCCESS;
            
          case OID_QOS_ISSLOW_FLOW:

              *pData = (Vc->Flags & GPC_ISSLOW_FLOW)?TRUE:FALSE;

              return STATUS_SUCCESS;

          case OID_QOS_STATISTICS_BUFFER:
              
              // If the query comes for a VC, then we return per flow stats
              // else we return per adapter stats. The query is also sent through
              // the scheduling components, so that they can fill in the per flow
              // or per query stats.
              //
              
              
              Len = BufferSize;
              BytesNeeded = 0;
              BytesWritten;

              BytesWritten = sizeof(PS_FLOW_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);

              Cstats = (PPS_COMPONENT_STATS) Buffer;

              Cstats->Type = PS_COMPONENT_FLOW;

              Cstats->Length = sizeof(PS_FLOW_STATS);

              NdisMoveMemory(&Cstats->Stats,
                             &Vc->Stats,
                             sizeof(PS_FLOW_STATS));
                          
              Status = NDIS_STATUS_SUCCESS;
                          
              Data = (PVOID)( (PUCHAR) Buffer + BytesWritten);

              (*Vc->PsComponent->QueryInformation)
                  (Vc->PsPipeContext,
                   Vc->PsFlowContext,
                   Oid,
                   Len,
                   Data,
                   &BytesWritten, 
                   &BytesNeeded,
                   &Status);
              
              return Status;
          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    //
    // The Following OIDs are similar for both WAN and Adapters
    //
    switch(Oid) 
    {
      case OID_QOS_CURRENT_SCHEDULING_PROFILE:
          
          if(!Adapter->ProfileName.Buffer)
          {
              NdisMoveMemory(Buffer,
                             &DefaultProfile,
                             sizeof(DefaultProfile));
              
          }
          else {
              
              NdisMoveMemory(Buffer,
                             &Adapter->ProfileName.Buffer,
                             Adapter->ProfileName.Length);
          }
          
          return STATUS_SUCCESS;

      case OID_QOS_DISABLE_DRR:
              
          *pData = (Adapter->PipeFlags & PS_DISABLE_DRR)?1:0;
                  
           return STATUS_SUCCESS;

      case OID_QOS_MAX_OUTSTANDING_SENDS:
              
          *pData = Adapter->MaxOutstandingSends;
              
          return STATUS_SUCCESS;
              

      case OID_QOS_BESTEFFORT_BANDWIDTH:
          
          PS_LOCK(&Adapter->Lock);
          
          *pData = Adapter->BestEffortLimit;
          
          PS_UNLOCK(&Adapter->Lock);
          
          return STATUS_SUCCESS;
             
      case OID_QOS_TIMER_RESOLUTION:

          *pData = gTimerResolutionActualTime/10;

          return STATUS_SUCCESS;

      case OID_QOS_LATENCY:
          
          //
          // Don't have a valid measure of latency right now.
          //
          
          *pData = -1;
          
          return STATUS_SUCCESS;

      case OID_QOS_ENABLE_AVG_STATS:

          *pData = gEnableAvgStats;
          
          return STATUS_SUCCESS;

      case OID_QOS_ENABLE_WINDOW_ADJUSTMENT:

          *pData = gEnableWindowAdjustment;
          
          return STATUS_SUCCESS;

#if DBG
      case OID_QOS_LOG_BUFFER_SIZE:
          
          *pData = SchedtGetBufferSize();
          
          
          return STATUS_SUCCESS;
          
          // The following is temporary until the status reporting works...
          // for a query on log threshold we return the current size of the
          // log rather than the threshold value... this is just an easy
          // way to allow the app to poll the log size without defining a
          // new GUID that would be temporary anyway.
          
      case OID_QOS_LOG_THRESHOLD:
          
          *pData = SchedtGetBytesUnread();
          
          return STATUS_SUCCESS;

      case OID_QOS_LOG_MASK:
          *pData = LogTraceMask;
          return STATUS_SUCCESS;

      case OID_QOS_LOG_LEVEL:
          *pData = LogTraceLevel;
          return STATUS_SUCCESS;
          
              
      case OID_QOS_LOG_DATA:
      {
          ULONG BytesRead;
          DbugReadTraceBuffer(Buffer, BufferSize, &BytesRead);
          
          return STATUS_SUCCESS;
      }
      
#endif
    }
              

    if(WanLink)
    {
        switch(Oid) 
        {

          case OID_QOS_FLOW_MODE:
          {
              *pData = WanLink->AdapterMode;

              return STATUS_SUCCESS;
          }

            //
            // (12636): This has to be uncommented when we do admission control over WAN links.
            //
#if 0
          case OID_QOS_REMAINING_BANDWIDTH:
              
              PS_LOCK(&WanLink->Lock);
                  
              *pData = WanLink->RemainingBandWidth;
                  
              PS_UNLOCK(&WanLink->Lock);
                  
              return STATUS_SUCCESS;

          case OID_QOS_NON_BESTEFFORT_LIMIT:
              
              PS_LOCK(&WanLink->Lock);
                  
              *pData = WanLink->NonBestEffortLimit;
                  
              PS_UNLOCK(&WanLink->Lock);
              
              return STATUS_SUCCESS;
#endif
          case OID_QOS_HIERARCHY_CLASS:
          {
              BytesWritten = 0;
              BytesNeeded = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              
              (*WanLink->PsComponent->QueryInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid, 
                   BufferSize, 
                   Buffer,
                   &BytesWritten,
                   &BufferSize,
                   &Status);
              
              return STATUS_SUCCESS;
          }

          case OID_QOS_STATISTICS_BUFFER:
              
              // If the query comes for a VC, then we return per flow stats
              // else we return per adapter stats. The query is also sent through
              // the scheduling components, so that they can fill in the per flow
              // or per query stats.
              //
              
              
              Len = BufferSize;
              BytesNeeded = 0;
              BytesWritten;
              
              BytesWritten = sizeof(PS_ADAPTER_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              Cstats = (PPS_COMPONENT_STATS) Buffer;
              
              Cstats->Type = PS_COMPONENT_ADAPTER;
              
              Cstats->Length = sizeof(PS_ADAPTER_STATS);
              
              NdisMoveMemory(&Cstats->Stats,
                             &WanLink->Stats,
                             sizeof(PS_ADAPTER_STATS));
              
              Status = NDIS_STATUS_SUCCESS;
              
              Data = (PVOID)( (PUCHAR) Buffer + BytesWritten);
             
              (*WanLink->PsComponent->QueryInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid,
                   Len,
                   Data,
                   &BytesWritten, 
                   &BytesNeeded,
                   &Status);
              
              return Status;
              
          case OID_QOS_TC_SUPPORTED:

              CollectWanNetworkAddresses(Adapter, WanLink, &BufferSize, Buffer);

              return STATUS_SUCCESS;

          case OID_QOS_FLOW_COUNT:

              PS_LOCK(&WanLink->Lock);

              *pData = WanLink->FlowsInstalled;

              PS_UNLOCK(&WanLink->Lock);

              PsAssert((LONG)*pData >= 0);

              return STATUS_SUCCESS;

          default:
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    if(Adapter->MediaType != NdisMediumWan)
    {

        switch(Oid) 
        {
          case OID_QOS_FLOW_MODE:
          {
              *pData = Adapter->AdapterMode;
              return STATUS_SUCCESS;
          }

          case OID_QOS_HIERARCHY_CLASS:
          {
              BytesWritten = 0;
              BytesNeeded = 0;
              Status = NDIS_STATUS_BUFFER_TOO_SHORT;
              
              (*Adapter->PsComponent->QueryInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid, 
                   BufferSize, 
                   Buffer,
                   &BytesWritten,
                   &BufferSize,
                   &Status);
              
              return STATUS_SUCCESS;
          }

          case OID_QOS_STATISTICS_BUFFER:
              
              // If the query comes for a VC, then we return per flow stats
              // else we return per adapter stats. The query is also sent through
              // the scheduling components, so that they can fill in the per flow
              // or per query stats.
              //
              
              
              Len = BufferSize;
              BytesNeeded = 0;
              BytesWritten;
              
              BytesWritten = sizeof(PS_ADAPTER_STATS) + FIELD_OFFSET(PS_COMPONENT_STATS, Stats);
              
              Cstats = (PPS_COMPONENT_STATS) Buffer;
              
              Cstats->Type = PS_COMPONENT_ADAPTER;
          
              Cstats->Length = sizeof(PS_ADAPTER_STATS);
              
              NdisMoveMemory(&Cstats->Stats,
                             &Adapter->Stats,
                             sizeof(PS_ADAPTER_STATS));
              
              Status = NDIS_STATUS_SUCCESS;
              
              Data = (PVOID)( (PUCHAR) Buffer + BytesWritten);
              
              (*Adapter->PsComponent->QueryInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid,
                   Len,
                   Data,
                   &BytesWritten, 
                   &BytesNeeded,
                   &Status);
              
              return Status;

          case OID_QOS_TC_SUPPORTED:
              
              CollectNetworkAddresses(Adapter, &BufferSize, Buffer);

              return STATUS_SUCCESS;

          case OID_QOS_REMAINING_BANDWIDTH:
              
              PS_LOCK(&Adapter->Lock);
                  
              *pData = Adapter->RemainingBandWidth;
                  
              PS_UNLOCK(&Adapter->Lock);
                  
              return STATUS_SUCCESS;
              
          case OID_QOS_FLOW_COUNT:
              
              PS_LOCK(&Adapter->Lock);

              *pData = Adapter->FlowsInstalled;

              PS_UNLOCK(&Adapter->Lock);
              
              PsAssert((LONG)*pData >= 0);
              
              return STATUS_SUCCESS;
              
          case OID_QOS_NON_BESTEFFORT_LIMIT:
              
              PS_LOCK(&Adapter->Lock);
                  
              *pData = Adapter->NonBestEffortLimit;
                  
              PS_UNLOCK(&Adapter->Lock);
              
              return STATUS_SUCCESS;
              
              
          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    return STATUS_WMI_NOT_SUPPORTED;
}

NTSTATUS
PsWmiQueryAllData(
        IN      LPGUID          guid,
        IN      PWNODE_ALL_DATA wnode,
        IN      ULONG           BufferSize,
        OUT     PULONG          pReturnSize
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                      NtStatus;
    NDIS_STATUS                   Status;
    ULONG                         wnodeSize = ALIGN(sizeof(WNODE_ALL_DATA));
    ULONG                         wnodeTotalSize;
    PNDIS_GUID                    pNdisGuid;
    ULONG                         BytesNeeded;
    UINT                          cRoughInstanceCount;
    UINT                          cInstanceCount = 0;
    PUCHAR                        pBuffer;
    ULONG                         OffsetToInstanceNames;
    PLIST_ENTRY                   Link;
    PPS_WAN_LINK                  WanLink = NULL;
    POFFSETINSTANCEDATAANDLENGTH  poidl;
    PULONG                        pInstanceNameOffsets;
    ULONG                         OffsetToInstanceInfo;
    BOOLEAN                       OutOfSpace = FALSE;
    PADAPTER                      Adapter;
    PLIST_ENTRY                   NextAdapter;
    ULONG                         InstanceNameSize;

    do
    {
        *pReturnSize = 0;
        
        if (BufferSize < sizeof(WNODE_TOO_SMALL))
        {
            
            // 
            // Too small even to hold a WNODE_TOO_SMALL !
            //
            
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            
            break;
        }
       
        //
        // We can maintain a global count when adapters and wanlinks go up and down rather 
        // than counting it here. However, QueryAllData is not a very frequently used operation to 
        // justify this extra code. 
        //

        cRoughInstanceCount = 0;

        PS_LOCK(&AdapterListLock);

        NextAdapter = AdapterList.Flink;
          
        while(NextAdapter != &AdapterList) 
        {
            Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);
            
            NextAdapter = NextAdapter->Flink;
        
            if(Adapter->MediaType == NdisMediumWan) 
            {
                PS_LOCK_DPC(&Adapter->Lock);
            
                cRoughInstanceCount += Adapter->WanLinkCount;
            
                PS_UNLOCK_DPC(&Adapter->Lock);
            }
            else 
            {
                cRoughInstanceCount += 1;
            }
        }

        PS_UNLOCK(&AdapterListLock);
        
        //
        // Get the OID and see if we support it.
        //
        
        NtStatus = PsWmiGetGuid(&pNdisGuid, guid, 0);
        
        if(!NT_SUCCESS(NtStatus)) 
        {
            PsDbgOut(DBG_FAILURE, DBG_WMI,
                     ("[PsWmiQueryAllData]: Unsupported guid \n"));
            break;
        }
        
        //
        // Initialize common wnode information.
        //
        
        KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
            
        //
        // Setup the OFFSETINSTANCEDATAANDLENGTH array.
        //
        poidl = wnode->OffsetInstanceDataAndLength;
        wnode->OffsetInstanceNameOffsets = wnodeSize + (sizeof(OFFSETINSTANCEDATAANDLENGTH) * cRoughInstanceCount);

        //
        // Get a pointer to the array of offsets to the instance names.
        //
        pInstanceNameOffsets = (PULONG)((PUCHAR)wnode + wnode->OffsetInstanceNameOffsets);

        //
        // Get the offset from the wnode where will will start copying the instance
        // data into.
        //
        OffsetToInstanceInfo = ALIGN(wnode->OffsetInstanceNameOffsets + (sizeof(ULONG) * cRoughInstanceCount));

        //
        // Get a pointer to start placing the data.
        //
        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;

        //
        // Check to make sure we have at least this much buffer space in the wnode.
        //
        wnodeTotalSize = OffsetToInstanceInfo;

        PS_LOCK(&AdapterListLock);

        NextAdapter = AdapterList.Flink;
          
        while(NextAdapter != &AdapterList) 
        {
            Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);

            PS_LOCK_DPC(&Adapter->Lock);

            if(Adapter->PsMpState != AdapterStateRunning) 
            {
                PS_UNLOCK_DPC(&Adapter->Lock);

                NextAdapter = NextAdapter->Flink;

                continue;
            }

            REFADD(&Adapter->RefCount, 'WMIQ');

            PS_UNLOCK_DPC(&Adapter->Lock);
            
            PS_UNLOCK(&AdapterListLock);
            
            if(Adapter->MediaType != NdisMediumWan) 
            {
                
                NtStatus = PsQueryGuidDataSize(Adapter, NULL, NULL, pNdisGuid->Oid, &BytesNeeded);
            
                if(NT_SUCCESS(NtStatus)) 
                {
                    
                    // Make sure we have enough buffer space for the instance name and
                    // the data. If not we still continue since we need to find the total
                    // size
                   
                    InstanceNameSize   = ALIGN(Adapter->WMIInstanceName.Length + sizeof(WCHAR));
                    wnodeTotalSize  += InstanceNameSize + ALIGN(BytesNeeded);
                    
                    if (BufferSize < wnodeTotalSize)
                    {
                        WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeTotalSize, &NtStatus, pReturnSize);

                        OutOfSpace = TRUE;

                        PS_LOCK(&AdapterListLock);

                        NextAdapter = NextAdapter->Flink;

                        REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');

                        continue;
                    }

                    //
                    // We only have room for so many Instances.
                    //
                    if(cInstanceCount >= cRoughInstanceCount)
                    {
                        PsDbgOut(DBG_FAILURE, DBG_WMI,
                                 ("[PsWmiQueryAllData]: Adapter %08X, Received more wanlinks (%d) than we counted "
                                  "initially (%d)\n", Adapter, cInstanceCount, cRoughInstanceCount));

                        PS_LOCK(&AdapterListLock);

                        REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');
                        
                        break;
                    }

                    //
                    //  Add the offset to the instance name to the table.
                    //
                    pInstanceNameOffsets[cInstanceCount] = OffsetToInstanceInfo;
                        
                    //
                    //  Copy the instance name into the wnode buffer.
                    //
                    *((PUSHORT)pBuffer) = Adapter->WMIInstanceName.Length;
                        
                    NdisMoveMemory(pBuffer + sizeof(USHORT),
                                   Adapter->WMIInstanceName.Buffer,
                                   Adapter->WMIInstanceName.Length);
                        
                    //
                    //  Keep track of true instance counts.
                    //
                    OffsetToInstanceInfo += InstanceNameSize;
                    pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
                        
                    //
                    // Query the data 
                    //
                    NtStatus = PsQueryGuidData(Adapter, NULL, NULL, pNdisGuid->Oid, pBuffer, BytesNeeded);
                        
                    if(!NT_SUCCESS(NtStatus)) 
                    {
                        PsDbgOut(DBG_FAILURE, DBG_WMI,
                                 ("[PsWmiQueryAllData]: Adapter %08X, Failed to query OID %08X \n", Adapter,
                                  pNdisGuid->Oid));

                        PS_LOCK(&AdapterListLock);

                        REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');

                        break;
                    }
                        
                        
                    //
                    //  Save the length of the data item for this instance.
                    //
                    poidl[cInstanceCount].OffsetInstanceData = OffsetToInstanceInfo;
                    poidl[cInstanceCount].LengthInstanceData = BytesNeeded;
                    
                    //
                    // Keep track of true instance count.
                    //
                    OffsetToInstanceInfo += ALIGN(BytesNeeded);
                    pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;

                    cInstanceCount ++;
                        
                }

            }
            else 
            {
                //
                // Search the Wan Links     
                //

                PS_LOCK(&Adapter->Lock);
                  
                Link = Adapter->WanLinkList.Flink;
            
                for(Link = Adapter->WanLinkList.Flink;
                    Link != &Adapter->WanLinkList;
                    )
                    
                {
            
                    //
                    // We only have room for so many Instances.
                    //
                    if(cInstanceCount >= cRoughInstanceCount)
                    {
                        PsDbgOut(DBG_FAILURE, DBG_WMI,
                                 ("[PsWmiQueryAllData]: Adapter %08X, Received more wanlinks (%d) than we counted "
                                  "initially (%d)\n", Adapter, cInstanceCount, cRoughInstanceCount));
                        break;
                    }

                    //
                    // Get a pointer to the WanLink.
                    //
                    
                    WanLink = CONTAINING_RECORD(Link, PS_WAN_LINK, Linkage);
                    
                    PS_LOCK_DPC(&WanLink->Lock);
                    
                    //
                    // Check to see if the WanLink is cleaning up.
                    //
                    
                    if(WanLink->State != WanStateOpen) {
                        
                        PS_UNLOCK_DPC(&WanLink->Lock);

                        PsDbgOut(DBG_FAILURE, DBG_WMI,
                                 ("[PsWmiQueryAllData]: Adapter %08X, WanLink %08X: Link not ready \n", Adapter, WanLink));

                        Link = Link->Flink;
                        
                        continue;
                    }
                   
                    REFADD(&WanLink->RefCount, 'WMIQ'); 
                    
                    PS_UNLOCK_DPC(&WanLink->Lock);

                    PS_UNLOCK(&Adapter->Lock);

                    //
                    // If there is an instance name associated with the VC then we need to query it.
                    //
                    PsAssert(WanLink->InstanceName.Buffer);
                    
                    NtStatus = PsQueryGuidDataSize(Adapter, WanLink, NULL, pNdisGuid->Oid, &BytesNeeded);
                    
                    if(NT_SUCCESS(NtStatus)) 
                    {
                        //
                        //  Make sure we have enough buffer space for the instance name and
                        //  the data.
                        //
                        InstanceNameSize   = ALIGN(WanLink->InstanceName.Length + sizeof(USHORT));
                        wnodeTotalSize += InstanceNameSize + ALIGN(BytesNeeded);
                        
                        if (BufferSize < wnodeTotalSize)
                        {
                            WMI_BUFFER_TOO_SMALL(BufferSize, wnode,
                                                 wnodeTotalSize,
                                                 &NtStatus, pReturnSize);
                            
                            OutOfSpace = TRUE;
                            
                            PS_LOCK(&Adapter->Lock);

                            Link = Link->Flink;
                
                            REFDEL(&WanLink->RefCount, TRUE, 'WMIQ');
                            
                            continue;
                        }
                    
                        //
                        //  The instance info contains the instance name followed by the
                        //  data for the item.
                        //
                        
                        //
                        //  Add the offset to the instance name to the table.
                        //
                        pInstanceNameOffsets[cInstanceCount] = OffsetToInstanceInfo;
                        
                        //
                        //  Copy the instance name into the wnode buffer.
                        //
                        *((PUSHORT)pBuffer) = WanLink->InstanceName.Length;
                        
                        NdisMoveMemory(pBuffer + sizeof(USHORT),
                                       WanLink->InstanceName.Buffer,
                                       WanLink->InstanceName.Length);
                        
                        //
                        //  Keep track of true instance counts.
                        //
                        OffsetToInstanceInfo += InstanceNameSize;
                        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
                        
                        
                        //
                        // 
                        // 
                        NtStatus = PsQueryGuidData(Adapter, WanLink, NULL, pNdisGuid->Oid, pBuffer, BytesNeeded);
                        
                        if (!NT_SUCCESS(NtStatus))
                        {
                            PsDbgOut(DBG_FAILURE, DBG_WMI,
                                     ("[PsWmiQueryAllData]: Adapter %08X, Failed to query GUID data\n", Adapter));

                            PS_LOCK(&Adapter->Lock);

                            REFDEL(&WanLink->RefCount, TRUE, 'WMIQ'); 
                            
                            break;
                        }
                        
                        //
                        //  Save the length of the data item for this instance.
                        //
                        poidl[cInstanceCount].OffsetInstanceData = OffsetToInstanceInfo;
                        poidl[cInstanceCount].LengthInstanceData = BytesNeeded;
                        
                        //
                        //  Keep track of true instance counts.
                        //
                        OffsetToInstanceInfo += ALIGN(BytesNeeded);
                        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
                        
                        //
                        //  Increment the current instance count.
                        //
                        cInstanceCount++;
                    }

                    PS_LOCK(&Adapter->Lock);

                    Link = Link->Flink;

                    REFDEL(&WanLink->RefCount, TRUE, 'WMIQ'); 
                    
                }
                
                PS_UNLOCK(&Adapter->Lock);
            }

            PS_LOCK(&AdapterListLock);
            
            NextAdapter = NextAdapter->Flink;
            
            REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');
            
        }

        PS_UNLOCK(&AdapterListLock);

        if (!OutOfSpace)
        {
            wnode->WnodeHeader.BufferSize = wnodeTotalSize;
            wnode->InstanceCount = cInstanceCount;
            
            //
            // Set the status to success.
            //
            NtStatus = STATUS_SUCCESS;
            *pReturnSize = wnode->WnodeHeader.BufferSize;
        }

    } while (FALSE);

    return(NtStatus);
}

NTSTATUS
PsWmiFindInstanceName(
    IN      PPS_WAN_LINK            *pWanLink,
    IN      PGPC_CLIENT_VC          *pVc,
    IN      PADAPTER                Adapter, 
    IN      PWSTR                   pInstanceName,
    IN      USHORT                  cbInstanceName
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PVOID                   ptmp1;
    PVOID                   ptmp2;
    PLIST_ENTRY             Link;
    UINT                    cListCount;
    PLIST_ENTRY             pListHead;
    PPS_WAN_LINK            WanLink;
    PGPC_CLIENT_VC          Vc;
    NDIS_STRING             usTemp;
    
    *pWanLink = NULL;
    *pVc = NULL;
    
    
    if ( NdisEqualMemory(pInstanceName,
                         WanPrefix.Buffer,
                         WanPrefix.Length)) 
    {
        
        //
        //  The name belongs to a miniport, check to see if it is for this one.
        //
        usTemp.Buffer = (PWCHAR)((PCHAR)pInstanceName + WanPrefix.Length + INSTANCE_ID_SIZE);
        usTemp.Length = usTemp.MaximumLength = cbInstanceName - WanPrefix.Length - INSTANCE_ID_SIZE;
        
        //
        // Get a ULONGLONG pointer to the wnode's instance name.
        //
        ptmp1 = (PVOID)&pInstanceName[1];

        //
        // No point in searching wanlinks on the non wan adapters.
        //

        if(Adapter->MediaType == NdisMediumWan && RtlEqualUnicodeString(&Adapter->WMIInstanceName, &usTemp, TRUE)) 
        {
        
            //
            // The request is for some WAN Link. Go through the Miniport's list of WMI enabled VCs.
            //
            PS_LOCK(&Adapter->Lock);
            
            for(Link = Adapter->WanLinkList.Flink;
                Link != &Adapter->WanLinkList;
                Link = Link->Flink)
            {
                //
                // Get a pointer to the VC.
                //
                WanLink = CONTAINING_RECORD(Link, PS_WAN_LINK, Linkage);
                
                PS_LOCK_DPC(&WanLink->Lock);
                
                if(WanLink->State == WanStateOpen) 
                {
                    
                    //
                    // Check the name with the one in the wnode.
                    //
                    ptmp2 = (PVOID)&WanLink->InstanceName.Buffer[1];
                    if (RtlCompareMemory( ptmp1, ptmp2, 48) == 48)
                    {
                        //
                        //  This is our baby. Slap a reference on it and get out.
                        //  
                        
                        *pWanLink = WanLink;
                        
                        REFADD(&WanLink->RefCount, 'WMII'); 
                        
                        PS_UNLOCK_DPC(&WanLink->Lock);
                        
                        break;
                    }
                }
                    
                PS_UNLOCK_DPC(&WanLink->Lock);
                
            }
            
            PS_UNLOCK(&Adapter->Lock);
        
            //
            // If we didn't find the WanLink then return FAILURE.
            //
            if (!*pWanLink)
            {
                PsDbgOut(DBG_FAILURE, DBG_WMI,
                         ("[PsWmiFindInstanceName: Adapter %08X, Could not verify the instance name passed in\n"));
                
                Status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }
        else 
        {
            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        }
            
    }
    else {
        
        if ( NdisEqualMemory(pInstanceName,
                             VcPrefix.Buffer,
                             VcPrefix.Length)) 
        {
            //
            //  The name belongs to a miniport, check to see if it is for this one.
            //
            usTemp.Buffer = (PWCHAR)((PCHAR)pInstanceName + VcPrefix.Length + INSTANCE_ID_SIZE);
            usTemp.Length = usTemp.MaximumLength = cbInstanceName - VcPrefix.Length - INSTANCE_ID_SIZE;

            //
            // Make sure that the VC is searched on the correct adapter. Otherwise, we could land up
            // searching all the VCs on all the adapters.
            //
            if (!RtlEqualUnicodeString(&Adapter->WMIInstanceName, &usTemp, TRUE))
            {
                Status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
            else 
            {
            
                //
                //  Get a ULONGLONG pointer to the wnode's instance name.
                //
                ptmp1 = (PVOID)&pInstanceName[1];
                
                //
                //  The request is for some Vc. Go through the Miniport's list of WMI enabled VCs.
                //
                
                PS_LOCK(&Adapter->Lock);
                
                for(Link = Adapter->GpcClientVcList.Flink; 
                    Link != &Adapter->GpcClientVcList;
                    Link = Link->Flink)
                {
                    //
                    // Get a pointer to the VC.
                    //
                    Vc = CONTAINING_RECORD(Link, GPC_CLIENT_VC, Linkage);
                    
                    PS_LOCK_DPC(&Vc->Lock);
                    
                    if(	(Vc->ClVcState == CL_CALL_COMPLETE)			||
                    	(Vc->ClVcState == CL_INTERNAL_CALL_COMPLETE)	||
                    	(Vc->ClVcState == CL_MODIFY_PENDING) )
                    	{
                        
                        //
                        // Check the name with the one in the wnode. All we need to do is compare the 
                        // number in the name.
                        //
                        ptmp2 = (PVOID)&Vc->InstanceName.Buffer[1];
                        if(RtlCompareMemory(ptmp1, ptmp2, 48) == 48) 
                        {
                            //
                            // This is our baby. Slap a reference on it and get out.
                            //      
                            
                            *pVc = Vc;
                            
                            InterlockedIncrement(&Vc->RefCount);
                            
                            PS_UNLOCK_DPC(&Vc->Lock);
                            
                            break;
                            
                        }
                    }
                
                    PS_UNLOCK_DPC(&Vc->Lock);
                
                }
            
                PS_UNLOCK(&Adapter->Lock);
            
                //
                //  If we didn't find the VC then return FAILURE.
                //
                if (!*pVc)
                {
                    PsDbgOut(DBG_FAILURE, DBG_WMI,
                             ("[PsWmiFindInstanceName: Adapter %08X, Could not verify the instance name passed in\n"));
                    
                    Status = STATUS_WMI_INSTANCE_NOT_FOUND;
                }
            }
                
        }
        else 
        {
            //
            //  The name belongs to a miniport, check to see if it is for this one.
            //
            usTemp.Buffer = pInstanceName;
            usTemp.Length = usTemp.MaximumLength = cbInstanceName;

            
            if (!RtlEqualUnicodeString(&Adapter->WMIInstanceName, &usTemp, TRUE))
            {
                PsDbgOut(DBG_FAILURE, DBG_WMI,
                         ("[PsWmiFindInstanceName]: Adapter %08X, Invalid instance name \n", Adapter));
                
                Status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }
    }
    
    return(Status);
}

NTSTATUS
PsQuerySetMiniport(PADAPTER        Adapter,
                   PPS_WAN_LINK    WanLink,
                   PGPC_CLIENT_VC  Vc,
                   NDIS_OID        Oid,
                   PVOID           Data,
                   ULONG           DataSize) 
{

    //
    // Fail these no matter what 
    //
    switch(Oid) 
    {
        
      case OID_QOS_TC_SUPPORTED:
      case OID_QOS_REMAINING_BANDWIDTH:
      case OID_QOS_LATENCY:
      case OID_QOS_FLOW_COUNT:
      case OID_QOS_NON_BESTEFFORT_LIMIT:
      case OID_QOS_SCHEDULING_PROFILES_SUPPORTED:
      case OID_QOS_CURRENT_SCHEDULING_PROFILE:
      case OID_QOS_DISABLE_DRR:
      case OID_QOS_MAX_OUTSTANDING_SENDS:
      case OID_QOS_TIMER_RESOLUTION:
          
          return STATUS_WMI_NOT_SUPPORTED;
    }

    if(Vc) 
    {
        switch(Oid) 
        {
          case OID_QOS_STATISTICS_BUFFER:
              
              NdisZeroMemory(&Vc->Stats, sizeof(PS_FLOW_STATS));

              //
              // Send the request down, so that the scheduling components
              // can also reset their stats.
              //

              (*Vc->PsComponent->SetInformation)
                  (Vc->PsPipeContext,
                   Vc->PsFlowContext,
                   Oid, 
                   DataSize, 
                   Data);
                                  
              return STATUS_SUCCESS;

          default:
              
              return STATUS_WMI_NOT_SUPPORTED;
        }
    }

    //
    // These work for Wan and LAN
    //
    switch(Oid) {

      case OID_QOS_ENABLE_AVG_STATS:

          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }

          gEnableAvgStats = *(UNALIGNED PULONG)Data;
          return STATUS_SUCCESS;


      case OID_QOS_ENABLE_WINDOW_ADJUSTMENT:

          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }

          gEnableWindowAdjustment = *(UNALIGNED PULONG)Data;
          return STATUS_SUCCESS;


#if DBG          
      case OID_QOS_LOG_THRESHOLD:

          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }
          
          DbugTraceSetThreshold(*(PULONG)Data, Adapter, IndicateLogThreshold);
          return STATUS_SUCCESS;

      case OID_QOS_LOG_MASK:
          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }
          LogTraceMask = *(PULONG)Data;
          return STATUS_SUCCESS;

      case OID_QOS_LOG_LEVEL:
          if(DataSize != sizeof(ULONG)) {
              
              return STATUS_BUFFER_TOO_SMALL;
          }
          LogTraceLevel = *(PULONG)Data;
          return STATUS_SUCCESS;

#endif
    }

    if(WanLink)
    {
        switch(Oid)
        {
          case OID_QOS_STATISTICS_BUFFER:

              NdisZeroMemory(&WanLink->Stats, sizeof(PS_ADAPTER_STATS));
                          
              //
              // Send it to the scheduling components so that 
              // they can reset the per pipe stats
              //
          
              (*WanLink->PsComponent->SetInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid, 
                   DataSize, 
                   Data);
              
              
              return STATUS_SUCCESS;

      case OID_QOS_FLOW_MODE:

          if(DataSize != sizeof(ULONG)) {
              return STATUS_BUFFER_TOO_SMALL;
          } else {
              return STATUS_INVALID_PARAMETER;
          }
              
          case OID_QOS_HIERARCHY_CLASS:
              
              (*WanLink->PsComponent->SetInformation)
                  (WanLink->PsPipeContext,
                   NULL,
                   Oid, 
                   DataSize, 
                   Data);
              
              return STATUS_SUCCESS;
        }
    }


    if(Adapter->MediaType != NdisMediumWan)
    {
       
        switch(Oid)
        {
          case OID_QOS_STATISTICS_BUFFER:
                 

              NdisZeroMemory(&Adapter->Stats, sizeof(PS_ADAPTER_STATS));
                          
              //
              // Send it to the scheduling components so that 
              // they can reset the per pipe stats
              //
          
              (*Adapter->PsComponent->SetInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid, 
                   DataSize, 
                   Data);
              
              
              return STATUS_SUCCESS;

      case OID_QOS_FLOW_MODE:

          if(DataSize != sizeof(ULONG)) {
              return STATUS_BUFFER_TOO_SMALL;
          } else {
              return STATUS_INVALID_PARAMETER;
          }

      case OID_QOS_HIERARCHY_CLASS:
              
              (*Adapter->PsComponent->SetInformation)
                  (Adapter->PsPipeContext,
                   NULL,
                   Oid, 
                   DataSize, 
                   Data);
              
              return STATUS_SUCCESS;

          case OID_QOS_BESTEFFORT_BANDWIDTH: 
          
              if(DataSize != sizeof(ULONG)) 
              {
                  return STATUS_BUFFER_TOO_SMALL;
              }
              else 
              {
                  return ModifyBestEffortBandwidth(Adapter, *(UNALIGNED PULONG)Data);
              }
        }
    }

    return STATUS_WMI_NOT_SUPPORTED;
    
}

NTSTATUS 
PsWmiHandleSingleInstance(ULONG                  MinorFunction, 
                          PWNODE_SINGLE_INSTANCE wnode, 
                          PNDIS_GUID             pNdisGuid,
                          ULONG                  BufferSize,
                          PULONG                 pReturnSize)
{
    PPS_WAN_LINK            WanLink;
    PGPC_CLIENT_VC          Vc;
    USHORT                  cbInstanceName;
    PWSTR                   pInstanceName;
    PLIST_ENTRY             NextAdapter;
    PADAPTER                Adapter;
    NTSTATUS                Status = STATUS_WMI_INSTANCE_NOT_FOUND;

    //
    // Send this to all the adapter instances.
    //

    *pReturnSize = 0;

   //
   // First, we need to check if this is the window size adjustment guid..
   //
 
   if( pNdisGuid->Oid == OID_QOS_ENABLE_WINDOW_ADJUSTMENT)
   {
	if( MinorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE)
	{
	   PUCHAR pGuidData;
           ULONG  GuidDataSize;
	
	   pGuidData    = (PUCHAR)wnode + wnode->DataBlockOffset;
           GuidDataSize = wnode->SizeDataBlock;

	   //
           // Attempt to set the miniport with the information.
           //

	   Status = PsQuerySetMiniport(NULL,
                                       NULL,
                                       NULL,
                                       pNdisGuid->Oid,
                                       pGuidData,
                                       GuidDataSize);
	   return Status;
	}
	else if( MinorFunction == IRP_MN_QUERY_SINGLE_INSTANCE )
	{		
	   ULONG BytesNeeded;
           ULONG wnodeSize;
                  
           //
           //  Determine the buffer size needed for the GUID data.
           //
           Status = PsQueryGuidDataSize(NULL,
                                        NULL,
                                        NULL,
                                        pNdisGuid->Oid,
                                        &BytesNeeded);

	   if (!NT_SUCCESS(Status))
	   {
		return Status;	
	   }
        
           //
           //      Determine the size of the wnode.
           //
           wnodeSize = wnode->DataBlockOffset + BytesNeeded;
           if (BufferSize < wnodeSize)
           {
		WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeSize, &Status, pReturnSize);
                return Status;
	   }
        
	   //
           //      Initialize the wnode.
           //
           KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
           wnode->WnodeHeader.BufferSize = wnodeSize;
           wnode->SizeDataBlock = BytesNeeded;
                  
           //
           //      Validate the guid and get the data for it.
           //
           Status = PsQueryGuidData(NULL,
                                    NULL,
                                    NULL,
                                    pNdisGuid->Oid,
                                    (PUCHAR)wnode + wnode->DataBlockOffset,
                                    BytesNeeded);
                  
	   if (!NT_SUCCESS(Status))
           {
		return Status;
	   }
           else 
           {
		*pReturnSize = wnodeSize;
	   }	
	}
    }

    //
    // If we are here, then it is a "per adapter" guid/oid
    //
          
    PS_LOCK(&AdapterListLock);

    NextAdapter = AdapterList.Flink;
          
    while(NextAdapter != &AdapterList) 
    {
        Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);
        
        PS_LOCK_DPC(&Adapter->Lock);
        
        if(Adapter->PsMpState != AdapterStateRunning) 
        {
            PS_UNLOCK_DPC(&Adapter->Lock);
        
            NextAdapter = NextAdapter->Flink;
            
            continue;
        }

        REFADD(&Adapter->RefCount, 'WMIQ');

        PS_UNLOCK_DPC(&Adapter->Lock);

        PS_UNLOCK(&AdapterListLock);

        //
        // We first see if this instance name is meaningful for this adapter.
        //
        
        cbInstanceName = *(PUSHORT)((PUCHAR)wnode + wnode->OffsetInstanceName);
        pInstanceName  = (PWSTR)((PUCHAR)wnode + wnode->OffsetInstanceName + sizeof(USHORT));
              
        //
        // This routine will determine if the wnode's instance name is a miniport or VC.
        // If it's a VC then it will find which one.
        //      
        Vc = 0;
        
        WanLink = 0;
        
        Status = PsWmiFindInstanceName(&WanLink, &Vc, Adapter, pInstanceName, cbInstanceName);
        
        if(!NT_SUCCESS(Status)) 
        {
            PS_LOCK(&AdapterListLock);

            NextAdapter = NextAdapter->Flink;

            REFDEL(&Adapter->RefCount, TRUE, 'WMIQ');
            
            continue;
        }
        else 
        {
            //
            // Found the adapter or the Vc or the WanLink. If this fails from this point, we can just return.
            //
           
            switch(MinorFunction) 
            {
              case IRP_MN_QUERY_SINGLE_INSTANCE:
              {
                  ULONG BytesNeeded;
                  ULONG wnodeSize;
                  //
                  //  Determine the buffer size needed for the GUID data.
                  //
                  Status = PsQueryGuidDataSize(Adapter,
                                               WanLink,
                                               Vc,
                                               pNdisGuid->Oid,
                                               &BytesNeeded);
                  if (!NT_SUCCESS(Status))
                  {
                      PsDbgOut(DBG_FAILURE, DBG_WMI,
                               ("[PsWmiQuerySingleInstance]: Adpater %08X, Unable to determine OID data size for OID %0x\n", 
                                Adapter, pNdisGuid->Oid));
                      break;
                  }
        
                  //
                  //      Determine the size of the wnode.
                  //
                  wnodeSize = wnode->DataBlockOffset + BytesNeeded;
                  if (BufferSize < wnodeSize)
                  {
                      WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeSize, &Status, pReturnSize);
                      break;
                  }
        
                  //
                  //      Initialize the wnode.
                  //
                  KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                  wnode->WnodeHeader.BufferSize = wnodeSize;
                  wnode->SizeDataBlock = BytesNeeded;
                  
                  //
                  //      Validate the guid and get the data for it.
                  //
                  Status = PsQueryGuidData(Adapter,
                                           WanLink,
                                           Vc,
                                           pNdisGuid->Oid,
                                           (PUCHAR)wnode + wnode->DataBlockOffset,
                                           BytesNeeded);
                  
                  if (!NT_SUCCESS(Status))
                  {
                      PsDbgOut(DBG_FAILURE, DBG_WMI,
                               ("PsWmiQuerySingleInstance: Adapter %08X, Failed to get the OID data for OID %08X.\n", 
                                Adapter, pNdisGuid->Oid));
                  }
                  else 
                  {
                      *pReturnSize = wnodeSize;
                  }
                  
                  break;
              }

              case IRP_MN_CHANGE_SINGLE_INSTANCE:
              {
                  PUCHAR pGuidData;
                  ULONG  GuidDataSize;

                  pGuidData    = (PUCHAR)wnode + wnode->DataBlockOffset;
                  GuidDataSize = wnode->SizeDataBlock;

                  //
                  // Attempt to set the miniport with the information.
                  //
                  
                  Status = PsQuerySetMiniport(Adapter,
                                              WanLink,
                                              Vc,
                                              pNdisGuid->Oid,
                                              pGuidData,
                                              GuidDataSize);
                  break;
              }

              default:
                  PsAssert(0);
            }

            //
            // If this was a VC then we need to dereference it.
            //
            if (NULL != WanLink)
            {
                REFDEL(&WanLink->RefCount, FALSE, 'WMII');
            }
            
            if (NULL != Vc)
            {
                DerefClVc(Vc);
            }
            
            REFDEL(&Adapter->RefCount, FALSE, 'WMIQ');

            return Status;
            
        }
    }

    PS_UNLOCK(&AdapterListLock);

    return Status;
}

NTSTATUS
WMIDispatch(
        IN      PDEVICE_OBJECT  pdo,
        IN      PIRP            pirp
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION      pirpSp = IoGetCurrentIrpStackLocation(pirp);
    ULONG_PTR               ProviderId = pirpSp->Parameters.WMI.ProviderId;
    PVOID                   DataPath = pirpSp->Parameters.WMI.DataPath;
    ULONG                   BufferSize = pirpSp->Parameters.WMI.BufferSize;
    PVOID                   Buffer = pirpSp->Parameters.WMI.Buffer;
    NTSTATUS                Status;
    ULONG                   ReturnSize = 0;
    KIRQL                   OldIrql;
    ULONG                   MinorFunction;

    PsDbgOut(DBG_TRACE, DBG_WMI,
             ("[WMIDispatch]: Device Object %08X, IRP Device Object %08X, "
              "Minor function %d \n", pdo, pirpSp->Parameters.WMI.ProviderId,
              pirpSp->MinorFunction));

#if DBG
    OldIrql = KeGetCurrentIrql();
#endif

    //
    // Fail the irp if we don't find an adapter. We also fail the irp if the provider ID is not 
    // us.
    //
    // If the ProviderID is not us, then ideally we need to pass it down the irp stack.
    //
    // (By calling IoSkipCurrentIrpStackLocation(pirp) & 
    //             IocallDriver(Adapter->NextDeviceObject, pirp);
    //
    // In this case, we are not attached to anything, so we can just fail the request.
    //

    if((pirpSp->Parameters.WMI.ProviderId != (ULONG_PTR)pdo)) {

        PsDbgOut(DBG_FAILURE, DBG_WMI,
                 ("[WMIDispatch]: Could not find the adapter for pdo 0x%x \n", pdo));

        pirp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        
        pirp->IoStatus.Information = 0;
        
        IoCompleteRequest(pirp, IO_NO_INCREMENT);

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    MinorFunction = pirpSp->MinorFunction;

    switch (pirpSp->MinorFunction)
    {
      case IRP_MN_REGINFO:
          
          Status = PsWmiRegister((ULONG_PTR)DataPath,
                                 Buffer,
                                 BufferSize,
                                 &ReturnSize);
          break;
          
      case IRP_MN_QUERY_ALL_DATA:
          
          Status = PsWmiQueryAllData((LPGUID)DataPath,
                                     (PWNODE_ALL_DATA)Buffer,
                                     BufferSize,
                                     &ReturnSize);
          break;
         
      case IRP_MN_CHANGE_SINGLE_INSTANCE:
      {
          PWNODE_SINGLE_INSTANCE  wnode = (PWNODE_SINGLE_INSTANCE) Buffer;
          PPS_WAN_LINK            WanLink;
          PGPC_CLIENT_VC          Vc;
          USHORT                  cbInstanceName;
          PWSTR                   pInstanceName;
          PNDIS_GUID              pNdisGuid;
          PUCHAR                  pGuidData;
          ULONG                   GuidDataSize;

          //
          // See if the GUID is ours
          //
          Status = PsWmiGetGuid(&pNdisGuid, &wnode->WnodeHeader.Guid, 0);
          
          if(!NT_SUCCESS(Status)) 
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI, ("[WmiDispatch]: Invalid GUID \n"));
              
              Status = STATUS_INVALID_PARAMETER;
              
              break;
          }

          //
          // Is this guid settable?
          //
        
          if (PS_GUID_TEST_FLAG(pNdisGuid, fPS_GUID_NOT_SETTABLE))
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI, ("[WmiDispatch]: Guid is not settable!\n"));
              
              Status = STATUS_WMI_NOT_SUPPORTED;
              
              break;
          }
          
          //
          //  Get a pointer to the GUID data and size.
          //
          GuidDataSize = wnode->SizeDataBlock;
          
          pGuidData = (PUCHAR)wnode + wnode->DataBlockOffset;
          
          if (GuidDataSize == 0)
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI,
                       ("[PsWmiHandleSingleInstance]: Guid has not data to set!\n"));
              
              Status = STATUS_INVALID_PARAMETER;

              break;
          }
          
          //
          //  Make sure it's not a stauts indication.
          //
          if (!PS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_OID))
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI,
                       ("[PsWmiHandleSingleInstance]: Guid does not translate to an OID\n"));
              
              Status = STATUS_INVALID_DEVICE_REQUEST;
              break;
          }

          Status = PsWmiHandleSingleInstance(IRP_MN_CHANGE_SINGLE_INSTANCE, wnode, pNdisGuid, BufferSize, &ReturnSize);

          break;
      }
          
      case IRP_MN_QUERY_SINGLE_INSTANCE:
      {
          PWNODE_SINGLE_INSTANCE  wnode = (PWNODE_SINGLE_INSTANCE) Buffer;
          PNDIS_GUID              pNdisGuid;

          //
          // See if the GUID is ours
          //
          Status = PsWmiGetGuid(&pNdisGuid, &wnode->WnodeHeader.Guid, 0);
          
          if(!NT_SUCCESS(Status)) 
          {
              PsDbgOut(DBG_FAILURE, DBG_WMI, ("[WmiDispatch]: Invalid GUID \n"));
              
              Status = STATUS_INVALID_PARAMETER;
          }
          else 
          {
              Status = PsWmiHandleSingleInstance(IRP_MN_QUERY_SINGLE_INSTANCE, wnode, pNdisGuid, BufferSize, &ReturnSize);
          }

          break;
      }
          
      case IRP_MN_ENABLE_EVENTS:
          
          Status = PsWmiEnableEvents((LPGUID)DataPath);  
          break;
          
      case IRP_MN_DISABLE_EVENTS:
          
          Status = PsWmiDisableEvents((LPGUID)DataPath); 
          break;
          
      case IRP_MN_ENABLE_COLLECTION:
      case IRP_MN_DISABLE_COLLECTION:
      case IRP_MN_CHANGE_SINGLE_ITEM:

          Status = STATUS_NOT_SUPPORTED;
          
          PsDbgOut(DBG_TRACE, DBG_WMI,
                   ("[WMIDispatch]: Unsupported minor function (0x%x) \n",
                    pirpSp->MinorFunction));
          
          break;
          
      default:
          
          PsDbgOut(DBG_FAILURE, DBG_WMI,
                   ("[WMIDispatch]: Invalid minor function (0x%x) \n",
                    pirpSp->MinorFunction));
          
          Status = STATUS_INVALID_DEVICE_REQUEST;
          break;
    }
    
    PsAssert(KeGetCurrentIrql() == OldIrql);

    pirp->IoStatus.Status = Status;
    PsAssert(ReturnSize <= BufferSize);
    
    pirp->IoStatus.Information = NT_SUCCESS(Status) ? ReturnSize : 0;
    
    IoCompleteRequest(pirp, IO_NO_INCREMENT);

    //
    // Allow IFC_UP notifications.
    //

    if(MinorFunction == IRP_MN_REGINFO)
    {
        //
        // Need to walk all the adapters and send notifications.
        //
        PLIST_ENTRY NextAdapter;
        PADAPTER    Adapter;

        PS_LOCK(&AdapterListLock);

        WMIInitialized = TRUE;

        NextAdapter = AdapterList.Flink;
          
        while(NextAdapter != &AdapterList) 
        {
            Adapter = CONTAINING_RECORD(NextAdapter, ADAPTER, Linkage);
            
            PS_LOCK_DPC(&Adapter->Lock);

            if(Adapter->PsMpState == AdapterStateRunning && !Adapter->IfcNotification)
            {

                Adapter->IfcNotification = TRUE;

                REFADD(&Adapter->RefCount, 'WMIN');

                PS_UNLOCK_DPC(&Adapter->Lock);

                PS_UNLOCK(&AdapterListLock);

                TcIndicateInterfaceChange(Adapter, 0, NDIS_STATUS_INTERFACE_UP);

                PS_LOCK(&AdapterListLock);

                NextAdapter = NextAdapter->Flink;

                REFDEL(&Adapter->RefCount, TRUE, 'WMIN');
            }
            else 
            {
                //
                // This adapter is not yet ready. The interface will be indicated 
                // in the mpinitialize handler, when the adapter gets ready.
                //

                PS_UNLOCK_DPC(&Adapter->Lock);

                NextAdapter = NextAdapter->Flink;
            }
        }

        PS_UNLOCK(&AdapterListLock);
    }
    
    PsDbgOut(DBG_TRACE, DBG_WMI, ("[WMIDispatch] : completing with Status %X \n", Status));
    return(Status);
}

NTSTATUS
GenerateInstanceName(
    IN PNDIS_STRING     Prefix,
    IN PADAPTER         Adapter,
    IN PLARGE_INTEGER   Index,
    IN PNDIS_STRING     pInstanceName)
{
#define CONVERT_MASK                    0x000000000000000F

    NTSTATUS        Status = STATUS_SUCCESS;
    USHORT          cbSize;
    PUNICODE_STRING uBaseInstanceName = (PUNICODE_STRING)&Adapter->WMIInstanceName;
    UINT            Value;
    WCHAR           wcLookUp[] = {L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'A', L'B', L'C', L'D', L'E', L'F'};
    WCHAR           tmpBuffer[18] = {0};
    UINT            c;
    ULONGLONG       tmpIndex;
    KIRQL           OldIrql;

    do
    {
        //
        //      Is there already a name associated with this VC?
        //
        
        //
        //      The instance name will be of the format:
        //              <Prefix>: [YYYYYYYYYYYYYYYY] Base Name
        //
        
        cbSize = INSTANCE_ID_SIZE + Prefix->Length;
        
        if (NULL != uBaseInstanceName)
        {
            cbSize += uBaseInstanceName->Length;
        }


        //
        //      Initialize a temporary UNICODE_STRING to build the name.
        //
        NdisZeroMemory(pInstanceName->Buffer, cbSize);
        pInstanceName->Length = 0;
        pInstanceName->MaximumLength = cbSize;

        //
        // Add the prefix
        //
        RtlCopyUnicodeString(pInstanceName, Prefix);

        //
        //      Add the separator.
        //      
        RtlAppendUnicodeToString(pInstanceName, L" [");

        //
        //      Add the VC index.
        //
        //tmpIndex = (ULONGLONG)(Index->HighPart << 32) | (ULONGLONG)Index->LowPart;
        tmpIndex = Index->QuadPart;

        for (c = 16; c > 0; c--)
        {
            //
            //  Get the nibble to convert.
            //
            Value = (UINT)(tmpIndex & CONVERT_MASK);

            tmpBuffer[c - 1] = wcLookUp[Value];

            //
            //  Shift the tmpIndex by a nibble.
            //
            tmpIndex >>= 4;
        }

        RtlAppendUnicodeToString(pInstanceName, tmpBuffer);

        //
        //      Add closing bracket.
        //
        RtlAppendUnicodeToString(pInstanceName, L"]");


        if (NULL != uBaseInstanceName)
        {
            RtlAppendUnicodeToString(pInstanceName, L" ");

            //
            //  Append the base instance name passed into us to the end.
            //
            RtlAppendUnicodeToString(pInstanceName, uBaseInstanceName->Buffer);
        }

    } while (FALSE);
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\api.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    api.c

Abstract:

    This module contains the traffic control apis.

Author:

    Jim Stewart ( jstew )    July 28, 1996

Revision History:

    Ofer Bar ( oferbar )    Oct 1, 1997 - Rev 2
    Shreedhar Madhavapeddi (ShreeM) March 10, 1999 Rev 3

--*/

/*
*********************************************************************
Revision 3 => Changes [ShreeM]

1. Build concrete state machines for Interface, Flow and Filter structures.
2. Define Locks for each of these structures.
3. Use above Locks for recording every state transistion.
4. Use debug logs to record transitions.
5. The Global lock is always taken before any of the Flow, Filter or Interface locks.
*/

#include "precomp.h"
//#pragma hdrstop
//#include "oscode.h"

/*
************************************************************************

Description:

    This will create a new client handle and will also associate 
    it with a client's handler list. It also checks for the version number.

Arguments:

    TciVersion            - The client expected version
    ClientHandlerList    - The client's handler list
    pClientHandle        - output client handle

Return Value:

    NO_ERROR    
    ERROR_NOT_ENOUGH_MEMORY            out of memory
    ERROR_INVALID_PARAMETER            one of the parameters is NULL
    ERROR_INCOMPATIBLE_TC_VERSION    wrong version
    ERROR_NO_SYSTEM_RESOURCES        not enough resources (handles)


************************************************************************
*/
DWORD
APIENTRY
TcRegisterClient(
    IN        ULONG                   TciVersion,
    IN        HANDLE                  ClRegCtx,
    IN        PTCI_CLIENT_FUNC_LIST   ClientHandlerList,
    OUT       PHANDLE                 pClientHandle
    )
{
    DWORD           Status;
    PCLIENT_STRUC   pClient;
    BOOL            RegisterWithGpc = FALSE;


    VERIFY_INITIALIZATION_STATUS;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcRegisterClient: Called: Ver= %d, Ctx=%x\n", 
                 TciVersion, ClRegCtx));
    }

    if (IsBadWritePtr(pClientHandle,sizeof(HANDLE))) {
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    //
    // Set a default pClientHandle as early as possible
    //
    __try {
    
        *pClientHandle = TC_INVALID_HANDLE;
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
        }
        
        return Status;
    }
      

    if (TciVersion != CURRENT_TCI_VERSION) {

        Status = ERROR_INCOMPATIBLE_TCI_VERSION;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    if (IsBadReadPtr(ClientHandlerList,sizeof(TCI_CLIENT_FUNC_LIST))) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    
    if (IsBadCodePtr((FARPROC) ClientHandlerList->ClNotifyHandler)) {
        
        //
        // a client must support a notification handler
        //
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    // Prevent another thread from doing TcRegisterClient and TcDeregisterClient
    GetLock( ClientRegDeregLock );
    
    //
    // finish initialization (if needed)
    //
    
    InitializeWmi();

    Status = EnumAllInterfaces();

    if (ERROR_FAILED(Status)) {

        FreeLock( ClientRegDeregLock );
        return Status;
    }

    Status = OpenGpcClients(GPC_CF_QOS);
    if (ERROR_FAILED(Status)) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }

        FreeLock( ClientRegDeregLock );
        return Status;
    }
    

    //
    // allocate a new client structure and link it on the global list
    //

    Status = CreateClientStruc(0,            // This will be the client reg ctx
                               &pClient
                               );
    
    if (ERROR_FAILED(Status)) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Error = 0x%X\n", Status ));
        }
        
        FreeLock( ClientRegDeregLock );
        return Status;

    }

    //
    // copy the handler list privately
    //

    __try {

        RtlCopyMemory(&pClient->ClHandlers, 
                      ClientHandlerList, 
                      sizeof(TCI_CLIENT_FUNC_LIST));

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
        }
        
        FreeLock( ClientRegDeregLock );
        return Status;
    }

    pClient->ClRegCtx = ClRegCtx;

    //
    // Update linked lists, add the client to the global linked list of
    // clients.
    // 
    // NOTE! NOTE! NOTE! NOTE! NOTE! NOTE! NOTE! NOTE! NOTE! NOTE!
    //
    // Once we add the client to the list, it can get notified by an
    // incoming event, for example: TC_NOTIFY_IFC_CHANGE,
    // so everything should be in place by the time we release the lock!
    //
    
    GetLock(pClient->Lock);
    SET_STATE(pClient->State, OPEN);
    FreeLock(pClient->Lock);

    GetLock( pGlobals->Lock );

    // If this is the first client then register for GPC notifications
    if ( IsListEmpty( &pGlobals->ClientList ) )
        RegisterWithGpc = TRUE;
        
    InsertTailList( &pGlobals->ClientList, &pClient->Linkage );
    FreeLock( pGlobals->Lock );
    
    //
    // so far so good, set the returned handle
    //

    __try {
    
        *pClientHandle = (HANDLE)pClient->ClHandle;
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
        }

        // We couldn't return the handle so we do our best effort to undo 
        // the client registration
        TcDeregisterClient((HANDLE)pClient->ClHandle);
        
        FreeLock( ClientRegDeregLock );
        return Status;
    }

    if ( RegisterWithGpc ) 
    {
        Status = StartGpcNotifyThread();
        
        if ( Status )
        {
            // We couldn't return the handle so we do our best effort to undo 
            // the client registration
            TcDeregisterClient((HANDLE)pClient->ClHandle);
            
            FreeLock( ClientRegDeregLock );
            return Status;
        }
    }

    
    // Finally allow other TcRegisterClient and TcDeregisterClient to go through
    FreeLock( ClientRegDeregLock );
        
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcRegisterClient: ClHandle=%d Status=%X\n", 
                 pClient->ClHandle, Status));
    }

    return Status;
}



/*
************************************************************************

Description:

    The will call the system to enumerate all the TC aware interfaces.
    For each interface, it will return the interface instance name and
    a list of supported network addresses. This list can also be empty
    if the interface currently does not have an address associated with.
    On return, *pBufferSize is set to the actual number of bytes filled
    in Buffer. If the buffer is too small to hold all the interfaces
    data, it will return ERROR_INSUFFICIENT_BUFFER.

Arguments:

    ClientHandle    - the client handle from TcRegisterClient
    pBufferSize        - in: allocate buffer size, out: returned byte count
    InterfaceBuffer - the buffer

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        invalid client handle
    ERROR_INVALID_PARAMETER        one of the parameters is NULL
    ERROR_INSUFFICIENT_BUFFER    buffer too small to enumerate all interfaces
    ERROR_NOT_ENOUGH_MEMORY        system out of memory

************************************************************************
*/
DWORD
APIENTRY
TcEnumerateInterfaces(    
    IN          HANDLE              ClientHandle,
    IN OUT      PULONG              pBufferSize,
    OUT         PTC_IFC_DESCRIPTOR  InterfaceBuffer 
    )
{
    PCLIENT_STRUC   pClient;
    DWORD           Status = NO_ERROR;
    ULONG           MyBufferSize = 2 KiloBytes; // is this enough?!?
    ULONG           Offset2IfcName;
    ULONG           Offset2IfcID;
    INT             t, InputBufSize, CurrentLength = 0;
    PLIST_ENTRY     pHead, pEntry;
    PTC_IFC         pTcIfc;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcEnumerateInterfaces: Called: ClientHandle= %d", 
                 ClientHandle  ));
    }
    
    VERIFY_INITIALIZATION_STATUS;


    if (    IsBadWritePtr(pBufferSize, sizeof(ULONG)) 
        ||  IsBadWritePtr(InterfaceBuffer, *pBufferSize) ) {
               
        return ERROR_INVALID_PARAMETER;
    }

    __try {
    
        InputBufSize = *pBufferSize;
        *pBufferSize = 0; // reset it in case of an error
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();              
        
        return Status;
    }
      
    pClient = (PCLIENT_STRUC)GetHandleObjectWithRef(ClientHandle, ENUM_CLIENT_TYPE, 'TCEI');

    if (pClient == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }

    ASSERT((HANDLE)pClient->ClHandle == ClientHandle);

    GetLock(pGlobals->Lock);

    //
    // walk the list of TC interfaces
    //

    pHead = &pGlobals->TcIfcList;
    pEntry = pHead->Flink;

    while (pEntry != pHead) {


        pTcIfc = (PTC_IFC)CONTAINING_RECORD(pEntry,
                                            TC_IFC,
                                            Linkage 
                                            );
        
        //
        // 273978 - if the interface is down - dont show it.
        //
        GetLock(pTcIfc->Lock);
        
        if (QUERY_STATE(pTcIfc->State) != OPEN) {
            
            FreeLock(pTcIfc->Lock);
            pEntry = pEntry->Flink;
            continue;
        }
        
        FreeLock(pTcIfc->Lock);

        //
        // calculate the offset to the interface name buffer data
        //

        Offset2IfcName = FIELD_OFFSET(TC_IFC_DESCRIPTOR, AddressListDesc) + 
            pTcIfc->AddrListBytesCount;

        //
        // calculate the offset to the interface ID buffer data
        //

        Offset2IfcID = Offset2IfcName + 
            pTcIfc->InstanceNameLength + sizeof(WCHAR);

        //
        // total descriptor length
        //

        t = Offset2IfcID
            + pTcIfc->InstanceIDLength + sizeof(WCHAR);  // ID

        t = MULTIPLE_OF_EIGHT(t);
        
        if (t <= InputBufSize - CurrentLength) {

            __try {
                //
                // enough space in the buffer
                //

                InterfaceBuffer->Length = t;

                //
                // update the interface name pointer, place it right after
                // the address desc. buffer
                //

                InterfaceBuffer->pInterfaceName = 
                    (LPWSTR)((PUCHAR)InterfaceBuffer + Offset2IfcName);

                //
                // update the interface ID ID pointer, place it right after
                // the Interface Name string
                //

                InterfaceBuffer->pInterfaceID = 
                    (LPWSTR)((PUCHAR)InterfaceBuffer + Offset2IfcID);

                //
                // copy the address list
                //          

                RtlCopyMemory(&InterfaceBuffer->AddressListDesc,
                              pTcIfc->pAddressListDesc,
                              pTcIfc->AddrListBytesCount
                              );
   
                //
                // copy the interface name
                //

                RtlCopyMemory(InterfaceBuffer->pInterfaceName,
                              &pTcIfc->InstanceName[0],
                              pTcIfc->InstanceNameLength + sizeof(WCHAR)
                              );

                //
                // copy the interface ID
                //

                RtlCopyMemory(InterfaceBuffer->pInterfaceID,
                              &pTcIfc->InstanceID[0],
                              pTcIfc->InstanceIDLength + sizeof(WCHAR)
                              );
            

                //
                // update the output buffer size
                //
                
                CurrentLength += t;

                //
                // advance the interface buffer to the next free space
                //

                InterfaceBuffer = 
                    (PTC_IFC_DESCRIPTOR)((PUCHAR)InterfaceBuffer + t);
                
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = GetExceptionCode();
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcEnumerateInterfaces: Exception Error: = 0x%X\n", 
                             Status ));
                }               
                
                break;
            }

            
            //
            // get next entry in the linked list
            //

            pEntry = pEntry->Flink;

        } else {

            //
            // buffer too small to contain data
            // so lets just 
            //
            CurrentLength += t;

            //
            // get next entry in the linked list
            //

            pEntry = pEntry->Flink;

            Status = ERROR_INSUFFICIENT_BUFFER;
        }

    }





    FreeLock(pGlobals->Lock);
    
    REFDEL(&pClient->RefCount, 'TCEI');


    __try {
        
        *pBufferSize = CurrentLength; 
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();              

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcEnumerateInterfaces: Exception Error: = 0x%X\n", 
                      Status ));
        }      
    }
     
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcEnumerateInterfaces: Returned= 0x%X\n", Status ));
    }
    
    return Status;
}
                


/*
************************************************************************

Description:

    This routine will open an interface for the client.
    It needs to know the interface name, as it was returned from
    TcEnumerateInterfaces. The client is also expected to give a context
    that will be passed to the client upon certains notifications.
    

Arguments:

    InterfaceName    - the intefrace name
    ClientHandle    - as returned from TcRegisterClient
    ClIfcCtx        - a client context for this specific interface
    pIfcHandle        - returned interface handle

Return Value:

    NO_ERROR
    ERROR_INVALID_PARAMETER    one of the parameters is NULL
    ERROR_NOT_ENOUGH_MEMORY    system out of memory
    ERROR_NOT_FOUND            failed to find an interface with the name provided


************************************************************************
*/
DWORD
APIENTRY
TcOpenInterfaceW(
    IN      LPWSTR      pInterfaceName,
    IN      HANDLE      ClientHandle,
    IN      HANDLE      ClIfcCtx,
    OUT     PHANDLE     pIfcHandle
    )
{
    DWORD                Status;
    ULONG                Instance;
    PINTERFACE_STRUC    pClInterface;
    PCLIENT_STRUC        pClient;
    HANDLE                 Handle;
    PTC_IFC                pTcIfc;

    VERIFY_INITIALIZATION_STATUS;

    //
    // Validate the pifcHandle
    //
    if (IsBadWritePtr(pIfcHandle, sizeof(HANDLE))) {
        
        return ERROR_INVALID_PARAMETER;
    }

    // Set a return value early
    __try {
        
        *pIfcHandle = TC_INVALID_HANDLE;
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();              

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcOpenInterfaces: Exception Error: = 0x%X\n", 
                      Status ));
        }      

        return Status;
    }

    //
    // Validate the pInterfaceName
    //
    
    if (IsBadStringPtrW(pInterfaceName,MAX_STRING_LENGTH)) {
        
        return ERROR_INVALID_PARAMETER;
    }

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcOpenInterface: Called: ClientHandle= %d, Name=%S\n", 
                 ClientHandle, pInterfaceName));
    }


    pClient = (PCLIENT_STRUC)GetHandleObjectWithRef(ClientHandle, ENUM_CLIENT_TYPE, 'TCOI');

    if (pClient == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }

    ASSERT((HANDLE)pClient->ClHandle == ClientHandle);

    //
    // verify that the interface name exist
    //

    pTcIfc = GetTcIfcWithRef(pInterfaceName, 'TCOI');

    if (pTcIfc == NULL) {

        REFDEL(&pClient->RefCount, 'TCOI');
        return ERROR_NOT_FOUND;
    
    } 
    
    //
    //  create a client interface structure
    //

    Status = CreateClInterfaceStruc(ClIfcCtx, &pClInterface);

    if (ERROR_FAILED(Status)) {

        REFDEL(&pClient->RefCount, 'TCOI');
        REFDEL(&pTcIfc->RefCount, 'TCOI');

        return Status;
    
    } else {

        REFADD(&pClInterface->RefCount, 'TCOI');
    
    }

    //
    // set up the client interface structure and link it to the client data
    //

    pClInterface->pTcIfc = pTcIfc;
    pClInterface->pClient = pClient;

    GetLock(pClInterface->Lock);
    SET_STATE(pClInterface->State, OPEN);
    FreeLock(pClInterface->Lock);

    GetLock(pGlobals->Lock);
    //
    // add the interface on the client's list
    //
    GetLock(pClient->Lock);
    GetLock(pTcIfc->Lock);

    if (    (QUERY_STATE(pClient->State) != OPEN) 
        ||  (QUERY_STATE(pTcIfc->State) != OPEN) ) 
    {

        FreeLock(pTcIfc->Lock);
        FreeLock(pClient->Lock);
        FreeLock(pGlobals->Lock);

        IF_DEBUG(CALLS) {
            WSPRINT(("<==TcOpenInterface: IfcHandle=%d Status=%X\n", 
                     pClInterface->ClHandle, Status));
        }

        //
        // Ideally we need to dereference the Interface, we really
        // need only a subset of the functions.
        //
        FreeHandle(pClInterface->ClHandle);
        CloseHandle(pClInterface->IfcEvent);
        FreeMem(pClInterface);

        REFDEL(&pClient->RefCount, 'TCOI');
        REFDEL(&pTcIfc->RefCount, 'TCOI');
        
        return ERROR_NOT_FOUND;

    }

    __try {

        // the handle is all the client wants.
        *pIfcHandle = (HANDLE)pClInterface->ClHandle;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcOpenInterfaceW: Exception Error: = 0x%X\n", 
                       Status ));
          }

          FreeLock(pTcIfc->Lock);
          FreeLock(pClient->Lock);
          FreeLock(pGlobals->Lock);

          REFDEL(&pClient->RefCount, 'TCOI');
          REFDEL(&pTcIfc->RefCount, 'TCOI');
          REFDEL(&pClInterface->RefCount, 'TCOI');
        
          return Status;
    }

    InsertTailList( &pClient->InterfaceList, &pClInterface->Linkage );
    
    //
    // for every interface add one ref count
    //
    
    REFADD(&pClient->RefCount, 'CIFC');
    REFADD(&pTcIfc->RefCount, 'CIFC');
        
    pClient->InterfaceCount++;
    
    //
    // add the interface on the TC interface list for back reference
    //
    
    InsertTailList( &pTcIfc->ClIfcList, &pClInterface->NextIfc );
    
    FreeLock(pTcIfc->Lock);
    FreeLock(pClient->Lock);
    FreeLock(pGlobals->Lock);
    

    REFDEL(&pClient->RefCount, 'TCOI');
    REFDEL(&pTcIfc->RefCount, 'TCOI');
    REFDEL(&pClInterface->RefCount, 'TCOI');
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcOpenInterface: IfcHandle=%d Status=%X\n", 
                 pClInterface->ClHandle, Status));
    }

    return Status;
    
}


/*
************************************************************************

Description:

    The ANSI version of TcOpenInterfaceW    

Arguments:

    See TcOpenInterfaceW

Return Value:

    See TcOpenInterfaceW

************************************************************************
*/
DWORD
APIENTRY
TcOpenInterfaceA(
    IN      LPSTR       pInterfaceName,
    IN      HANDLE      ClientHandle,
    IN      HANDLE      ClIfcCtx,
    OUT     PHANDLE     pIfcHandle
    )
{
    LPWSTR    pWstr;
    int     l;
    DWORD    Status;


    if (IsBadWritePtr(pIfcHandle,sizeof(HANDLE))) {

        return ERROR_INVALID_PARAMETER;
            
    }

    __try {
        
        *pIfcHandle = TC_INVALID_HANDLE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcOpenInterfaceA: Exception Error: = 0x%X\n", 
                       Status ));
          }
  
          return Status;
    }


    if (IsBadStringPtrA(pInterfaceName,MAX_STRING_LENGTH)) {
        
        return ERROR_INVALID_PARAMETER;
    }


    __try {
        
        l = strlen(pInterfaceName) + 1;

        AllocMem(&pWstr, l*sizeof(WCHAR));

        if (pWstr == NULL) {

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( -1 == mbstowcs(pWstr, pInterfaceName, l)) {

            FreeMem(pWstr);
            return ERROR_NO_UNICODE_TRANSLATION;

        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcOpenInterfaceA: Exception Error: = 0x%X\n", 
                       Status ));
          }
  
          return Status;
    }
    
    Status =  TcOpenInterfaceW(pWstr,
                               ClientHandle,
                               ClIfcCtx,
                               pIfcHandle
                               );
    FreeMem(pWstr);

    return Status;
}



/*
************************************************************************

Description:

    This will close the interface previously open witt TcOpenInterface.
    All flows should be deleted before calling it, o/w an error will be 
    returned. All notificaitons will stop being reported on this interface.

Arguments:

    InterfaceHandle - the interface handle

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE                bad interface handle
    ERROR_TC_SUPPORTED_OBJECTS_EXIST    not all flows have been deleted for 
                                        this interface
    
************************************************************************
*/
DWORD
APIENTRY
TcCloseInterface(
    IN HANDLE       InterfaceHandle
    )
{

    DWORD               Status = NO_ERROR;
    PINTERFACE_STRUC    pInterface;
    HANDLE              hWaitEvent;
    PFLOW_STRUC         pFlow;
    PLIST_ENTRY         pEntry;

    VERIFY_INITIALIZATION_STATUS;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcCloseInterface: Called: IfcHandle= %d\n", 
                 InterfaceHandle));
    }

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(InterfaceHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TCCI');

    if (pInterface == NULL) {
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("==>TcCloseInterface: ERROR_INVALID_HANDLE\n"));
        }

        //
        // If the Interface State is FORCED_KERNELCLOSE, it means we need
        // to hang out here until the callback (in cbinterfacenotifyclient is done).
        // 
        GetLock( pGlobals->Lock );
        
        pInterface = (PINTERFACE_STRUC)GetHandleObject(InterfaceHandle, 
                                                       ENUM_INTERFACE_TYPE);

        if (pInterface) {

            if (pInterface->CallbackThreadId == GetCurrentThreadId()) {
                // same thread - bail!
                FreeLock(pGlobals->Lock);                

            } else {

                GetLock(pInterface->Lock);
            
                // This is the state before the callback, so we shall wait here.
                if (QUERY_STATE(pInterface->State) == FORCED_KERNELCLOSE) {
                
                    REFADD(&pInterface->RefCount, 'TCCW');
                
                    pInterface->Flags |= TC_FLAGS_WAITING;
                    FreeLock(pInterface->Lock);
                    hWaitEvent = pInterface->IfcEvent;

                    IF_DEBUG(INTERFACES) {
                        WSPRINT(("<==TcCloseInterface: Premature Forced Kernel Close, waiting for the callbacks to complete\n"));
                    }

                    FreeLock(pGlobals->Lock);
                    REFDEL(&pInterface->RefCount, 'TCCW');
                    WaitForSingleObject(hWaitEvent, INFINITE);
                    CloseHandle(hWaitEvent);
                
                } else {

                    FreeLock(pInterface->Lock);
                    FreeLock(pGlobals->Lock);

                }

            }

        } else {

            FreeLock(pGlobals->Lock);

        }

        return ERROR_INVALID_HANDLE;
    }

    ASSERT((HANDLE)pInterface->ClHandle == InterfaceHandle);

    //
    // release the ref count we added when we opened the interface
    //

    GetLock( pGlobals->Lock );

    if (pInterface->FlowCount > 0) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("<==TcCloseInterface: ERROR: there are still open flows on this interface!\n"));
        }
#if DBG
        pEntry = pInterface->FlowList.Flink;
        while (pEntry != &pInterface->FlowList) {

            pFlow = CONTAINING_RECORD(pEntry, FLOW_STRUC, Linkage);
            IF_DEBUG(ERRORS) {
                WSPRINT(("<==TcCloseInterface: Flow %x (handle %x) is open with RefCount:%d\n", pFlow, pFlow->ClHandle, pFlow->RefCount));
            }

            pEntry = pEntry->Flink;
        }
#endif 
        


        FreeLock(pGlobals->Lock);
        REFDEL(&pInterface->RefCount, 'TCCI');
        Status = ERROR_TC_SUPPORTED_OBJECTS_EXIST;
        return Status;

    }
        
    //
    // OK, so we are taking it out for sure now.
    //
    GetLock(pInterface->Lock);

    if (QUERY_STATE(pInterface->State) == OPEN) {
        
        SET_STATE(pInterface->State, USERCLOSED_KERNELCLOSEPENDING);
        FreeLock(pInterface->Lock);

    } else if (QUERY_STATE(pInterface->State) == FORCED_KERNELCLOSE) {

        //
        // if the interface is going down, we are going to notify the 
        // client, make sure we wait here till the callbacks are done.
        // 
        FreeLock(pInterface->Lock);

        pInterface->Flags |= TC_FLAGS_WAITING;
        hWaitEvent = pInterface->IfcEvent;

        IF_DEBUG(INTERFACES) {
            WSPRINT(("<==TcCloseInterface: Forced Kernel Close, waiting for the callbacks to complete\n"));
        }

        FreeLock(pGlobals->Lock);

        REFDEL(&pInterface->RefCount, 'TCCI');
        WaitForSingleObject(hWaitEvent, INFINITE);
        
        CloseHandle(hWaitEvent);
        return ERROR_INVALID_HANDLE;

    } else {

        //
        // Is someone else (wmi) already taking it out.
        //
        FreeLock(pInterface->Lock);
        FreeLock( pGlobals->Lock );
        REFDEL(&pInterface->RefCount, 'TCCI');

        return ERROR_INVALID_HANDLE;

    }


    FreeLock(pGlobals->Lock);

    Status = CloseInterface(pInterface, FALSE);

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcCloseInterface: Status=%X\n", 
                 Status));
    }

    //
    // Shall we wait until the last interface goes away? (292120 D)
    //
    GetLock( pGlobals->Lock );

    if (pInterface->CallbackThreadId != 0 ) {
        //
        // We are doing a notification, don't block (343058)
        //
  
        FreeLock(pGlobals->Lock);
        REFDEL(&pInterface->RefCount, 'TCCI'); 

    } else {
        pInterface->Flags |= TC_FLAGS_WAITING;
        hWaitEvent = pInterface->IfcEvent;

        IF_DEBUG(INTERFACES) {

            WSPRINT(("<==TcCloseInterface: Waiting for event to get set when we are ready to delete!!\n"));

        }

        FreeLock(pGlobals->Lock);
        REFDEL(&pInterface->RefCount, 'TCCI');
        WaitForSingleObject(hWaitEvent, INFINITE);
        CloseHandle(hWaitEvent);
    } 

    return Status;
}



/*
************************************************************************

Description:

    This call will add a new flow on the interface.
    
Arguments:

    IfcHandle        - the interface handle to add the flow on
    ClFlowCtx        - a client given flow context
    AddressType        - determines what protocol template to use with the GPC
    Flags            - reserved, will be used to indicate a persistent flow
    pGenericFlow    - flow parameters
    pFlowHandle        - returned flow handle in case of success

Return Value:

    NO_ERROR
    ERROR_SIGNAL_PENDING

    General error codes:

    ERROR_INVALID_HANDLE        bad handle.
    ERROR_NOT_ENOUGH_MEMORY        system out of memory
    ERROR_INVALID_PARAMETER        a general parameter is invalid

    TC specific error codes:

    ERROR_INVALID_SERVICE_TYPE    unspecified or bad intserv service type
    ERROR_INVALID_TOKEN_RATE    unspecified or bad TokenRate
    ERROR_INVALID_PEAK_RATE        bad PeakBandwidth
    ERROR_INVALID_SD_MODE        invalid ShapeDiscardMode
    ERROR_INVALID_PRIORITY        invalid priority value
    ERROR_INVALID_TRAFFIC_CLASS invalid traffic class value
    ERROR_ADDRESS_TYPE_NOT_SUPPORTED     the address type is not supported for 
                                this interface
    ERROR_NO_SYSTEM_RESOURCES    not enough resources to accommodate flows

************************************************************************
*/ 
DWORD
APIENTRY
TcAddFlow(
    IN      HANDLE          IfcHandle,
    IN      HANDLE          ClFlowCtx,
    IN      ULONG           Flags,
    IN      PTC_GEN_FLOW    pGenericFlow,
    OUT     PHANDLE         pFlowHandle
    )
{
    DWORD               Status, Status2 = NO_ERROR;
    PFLOW_STRUC         pFlow;
    PINTERFACE_STRUC    pInterface;
    PCLIENT_STRUC       pClient;
    PGPC_CLIENT         pGpcClient;
    ULONG               l;
    HANDLE              hFlowTemp;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcAddFlow: Called: IfcHandle= %d, ClFlowCtx=%d\n", 
                 IfcHandle, ClFlowCtx ));
    }
    
    VERIFY_INITIALIZATION_STATUS;
    
    if (IsBadWritePtr(pFlowHandle,sizeof(HANDLE))) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    __try {
        
        *pFlowHandle = TC_INVALID_HANDLE;

        if (IsBadReadPtr(pGenericFlow, sizeof(TC_GEN_FLOW))) {
        
            Status = ERROR_INVALID_PARAMETER;

            IF_DEBUG(ERRORS) {
                WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
            }

            return Status;
        }

        l = FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + pGenericFlow->TcObjectsLength;
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcAddFlow: Exception Error: = 0x%X\n", Status ));
          }
  
          return Status;
    }

    if (IsBadReadPtr(pGenericFlow, l)) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TCAF');

    if (pInterface == NULL) {

        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    ASSERT((HANDLE)pInterface->ClHandle == IfcHandle);

    //
    // search for an open GPC client that supports this address type
    //

    pGpcClient = FindGpcClient(GPC_CF_QOS);

    if (pGpcClient == NULL) {

        //
        // not found!
        //

        Status = ERROR_ADDRESS_TYPE_NOT_SUPPORTED;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }

        REFDEL(&pInterface->RefCount, 'TCAF');
        return Status;
    }
    

    //
    // create a new flow structure
    //
    Status = CreateFlowStruc(ClFlowCtx, pGenericFlow, &pFlow);

    if (ERROR_FAILED(Status)) {

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFlow: Error = 0x%X\n", Status ));
        }
        
        REFDEL(&pInterface->RefCount, 'TCAF');
        return Status;
    }

    pClient = pInterface->pClient;

    //
    // initialize the flow structure and add it on the intefrace list
    //

    pFlow->pInterface = pInterface;
    pFlow->UserFlags = Flags;
    
    pFlow->pGpcClient = pGpcClient;
    
    //
    // call to actually add the flow
    //

    Status = IoAddFlow( pFlow, TRUE );

    if (!ERROR_FAILED(Status)) {
        
        __try {
            
            *pFlowHandle = (HANDLE)pFlow->ClHandle;
            
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status2 = GetExceptionCode();
        
            IF_DEBUG(ERRORS) {
              WSPRINT(("TcAddFlow: Exception Error: = 0x%X\n", Status2 ));
            }
            
            hFlowTemp = (HANDLE)pFlow->ClHandle;    
        } 
    } 
    
    if (!ERROR_PENDING(Status)) {

        //
        // call completed, either success or failure...
        //
        CompleteAddFlow(pFlow, Status);
    }

    //
    // !!! don't reference pFlow after this since it may be gone!!!
    //

    if (Status2 != NO_ERROR) {
        
        // We won't be able to return the flow, so we need to try to delete it
        // and return the error

        TcDeleteFlow(hFlowTemp);
        return (Status2);
        
    }
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcAddFlow: Returned= 0x%X\n", Status ));
    }

    return Status;
}




/*
************************************************************************

Description:

    This call will modify the flow.

Arguments:

    FlowHandle        - flow handle to modify
    pGenericFlow    - new flow parameters

Return Value:

    See TcAddFlow

************************************************************************
*/
DWORD
APIENTRY
TcModifyFlow(
    IN      HANDLE          FlowHandle,
    IN      PTC_GEN_FLOW    pGenericFlow
    )
{
    DWORD                Status;
    PFLOW_STRUC            pFlow;
    ULONG                l;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcModifyFlow: Called: FlowHandle= %d\n", 
                 FlowHandle ));
    }

    VERIFY_INITIALIZATION_STATUS;

    if (IsBadReadPtr(pGenericFlow,sizeof(TC_GEN_FLOW))) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    // 
    // Figure out the full length for immediate verification and also for later usage
    //

    __try {

        l = FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + pGenericFlow->TcObjectsLength;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcModifyFlow: Exception Error: = 0x%X\n", 
                       Status ));
          }
        
          return Status;
    }

    if (IsBadReadPtr(pGenericFlow,l)) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    

    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, ENUM_GEN_FLOW_TYPE, 'TCMF');

    if (pFlow == NULL) {
        
        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    
    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    GetLock(pFlow->Lock);
    
    if (IS_MODIFYING(pFlow->Flags)) {
        
        FreeLock(pFlow->Lock);
        
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("0 DEREF FLOW %X (%X) - ref (%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }
        
        REFDEL(&pFlow->RefCount, 'TCMF');

        return ERROR_NOT_READY;

    }

    AllocMem(&pFlow->pGenFlow1, l);

    if (pFlow->pGenFlow1 == NULL) {

        Status = ERROR_NOT_ENOUGH_MEMORY;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Error = 0x%X\n", Status ));
        }

        FreeLock(pFlow->Lock);
        
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("1 DEREF FLOW %X (%X) - ref (%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }

        REFDEL(&pFlow->RefCount, 'TCMF');
        
        return Status;
    }

    __try {

        RtlCopyMemory(pFlow->pGenFlow1, pGenericFlow, l);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Exception Error: = 0x%X\n", 
                     Status ));
        }
        
        FreeLock(pFlow->Lock);
        //IF_DEBUG(REFCOUNTS) { WSPRINT(("2\n"));
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("2 DEREF FLOW %X (%X) ref (%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }

        REFDEL(&pFlow->RefCount, 'TCMF');

        return Status;
    }

    pFlow->Flags |= TC_FLAGS_MODIFYING;
    pFlow->GenFlowLen1 = l;

    FreeLock(pFlow->Lock);

    //
    // call to actually modify the flow
    //

    Status = IoModifyFlow( pFlow, TRUE );

    if (!ERROR_PENDING(Status)) {

        //
        // call completed, either success or failure...
        //

        CompleteModifyFlow(pFlow, Status);
    }

    //
    // !!! don't reference pFlow after this since it may be gone!!!
    //
    //IF_DEBUG(REFCOUNTS) { WSPRINT(("3\n"));
    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("3 DEREF FLOW %X (%X), ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcModifyFlow: Returned= 0x%X\n", Status ));
    }

    return Status;
}




/*
************************************************************************

Description:

    This will delete the flow. All the filters must have been deleted
    by now, o/w an error code will be returned. Also the handle is
    invalidated. No TC_NOTIFY_FLOW_CLOSE will be reported for this flow.

Arguments:

    FlowHandle - handle of the flow to delete

Return Value:

    NO_ERROR
    ERROR_SIGNAL_PENDING
    ERROR_INVALID_HANDLE                invalid or NULL handle
    ERROR_TC_SUPPORTED_OBJECTS_EXIST    not all the filters have been deleted


************************************************************************
*/
DWORD
APIENTRY
TcDeleteFlow(
    IN HANDLE  FlowHandle
    )
{
    DWORD                Status;
    PFLOW_STRUC            pFlow;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcDeleteFlow: Called: FlowHandle= %d\n", 
                 FlowHandle ));
    }

    VERIFY_INITIALIZATION_STATUS;

    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, ENUM_GEN_FLOW_TYPE, 'TCDF');
    
    if (pFlow == NULL) {
        
        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcDeleteFlow: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcDeleteFlow: Error = 0x%X\n", Status ));
        }

        return ERROR_NOT_READY;
    }

    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    //
    // Set the state and call to actually delete the flow
    //
    GetLock(pFlow->Lock);

    if (QUERY_STATE(pFlow->State) == OPEN) {
        
        if (IS_MODIFYING(pFlow->Flags)) 
        {
            //
            // Someone else is taking this out.
            //
            FreeLock(pFlow->Lock);
            REFDEL(&pFlow->RefCount, 'TCDF');
            
            return ERROR_NOT_READY;
        }
    
        SET_STATE(pFlow->State, USERCLOSED_KERNELCLOSEPENDING);
        FreeLock(pFlow->Lock);

    } else {

        //
        // Someone else is taking this out.
        //
        FreeLock(pFlow->Lock);
        REFDEL(&pFlow->RefCount, 'TCDF');
        
        return ERROR_INVALID_HANDLE;

    }

    Status = DeleteFlow(pFlow, FALSE);

    if (ERROR_FAILED(Status)) {

        GetLock(pFlow->Lock);
        SET_STATE(pFlow->State, OPEN);
        FreeLock(pFlow->Lock);

    }

    //
    // !!! don't reference pFlow after this since it may be gone!!!
    //
    //IF_DEBUG(REFCOUNTS) { WSPRINT(("4\n"));
    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("4 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }

    REFDEL(&pFlow->RefCount, 'TCDF');

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcDeleteFlow: Returned= 0x%X\n", Status ));
    }

    return Status;
}




/*
************************************************************************

Description:

    Will add a filter and attach it to the flow.

Arguments:

    FlowHandle        - handle of the flow to add the filter on
    pGenericFilter    - the filter characteristics
    pFilterHandle    - the returned filter handle after success

Return Value:

    NO_ERROR

    General error codes:
    
    ERROR_INVALID_HANDLE        bad handle.
    ERROR_NOT_ENOUGH_MEMORY        system out of memory
    ERROR_INVALID_PARAMETER        a general parameter is invalid

    TC specific error codes:

    ERROR_INVALID_ADDRESS_TYPE    invalid address type
    ERROR_DUPLICATE_FILTER        attempt to install identical filters on 
                                different flows
    ERROR_FILTER_CONFLICT        attempt to install conflicting filter

************************************************************************
*/
DWORD
APIENTRY
TcAddFilter(
    IN      HANDLE          FlowHandle,
    IN      PTC_GEN_FILTER  pGenericFilter,
    OUT     PHANDLE         pFilterHandle
    )
{
    DWORD           Status;
    PFLOW_STRUC     pFlow;
    PFILTER_STRUC   pFilter;
    ULONG           PatternSize;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcAddFilter: Called: FlowHandle=%d\n", FlowHandle ));
    }

    VERIFY_INITIALIZATION_STATUS;

    if (IsBadWritePtr(pFilterHandle,sizeof(HANDLE))) {
        
        Status = ERROR_INVALID_PARAMETER;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    __try {
        
        *pFilterHandle = TC_INVALID_HANDLE;
   
        if (    IsBadReadPtr(pGenericFilter,sizeof(TC_GEN_FILTER))
            ||  IsBadReadPtr(pGenericFilter->Pattern,pGenericFilter->PatternSize) 
            ||  IsBadReadPtr(pGenericFilter->Mask,pGenericFilter->PatternSize)) {

            Status = ERROR_INVALID_PARAMETER;

            IF_DEBUG(ERRORS) {
                WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
            }

            return Status;

        }   
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Exception Error: = 0x%X\n", Status ));
        }
        
        return Status;
    }

    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, 
                                         ENUM_GEN_FLOW_TYPE, 'TAFL');

    if (pFlow == NULL) {
        
        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
        }

        return Status;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
        }

        return Status;
    }


    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    //
    // create a new filter structure
    //

    Status = CreateFilterStruc(pGenericFilter, pFlow, &pFilter);

    if ( Status != NO_ERROR ) {

        if ( ERROR_PENDING(Status) )
            Status = ERROR_NOT_READY;
            
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcAddFilter: Error = 0x%X\n", Status ));
        }
        //IF_DEBUG(REFCOUNTS) { WSPRINT(("5\n"));
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("5 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }

        REFDEL(&pFlow->RefCount, 'TAFL');
        return Status;
    }

    //
    // initialize the filter structure and add it on the flow list
    //

    pFilter->pFlow = pFlow;
    //
    // call to actually add the filter
    //

    Status = IoAddFilter( pFilter );

    if (!ERROR_FAILED(Status)) {

        __try {
            
            *pFilterHandle = (HANDLE)pFilter->ClHandle;
            
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status = GetExceptionCode();
        
            IF_DEBUG(ERRORS) {
                WSPRINT(("TcAddFilter: Exception Error: = 0x%X\n", Status ));
            }
        
        }

        GetLock(pGlobals->Lock);
        GetLock(pFlow->Lock);
        
        if (QUERY_STATE(pFlow->State) == OPEN) {

            SET_STATE(pFilter->State, OPEN);
            InsertTailList(&pFlow->FilterList, &pFilter->Linkage);
            REFADD(&pFlow->RefCount, 'FILT');
            
            FreeLock(pFlow->Lock);
        
        } 
        else {

            IF_DEBUG(WARNINGS) { 
                WSPRINT(("Flow %X (handle %X) is not OPEN! \n", pFlow, pFlow->ClHandle)); 
            }

            FreeLock(pFlow->Lock);
            DeleteFilter(pFilter);
            Status = ERROR_INVALID_HANDLE;
        }

        FreeLock(pGlobals->Lock);

    } else {

        //
        // failed, release the filter resources
        //
        REFDEL(&pFilter->RefCount, 'FILT');

    }
    //IF_DEBUG(REFCOUNTS) { WSPRINT(("6\n"));
    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("6 DEREF FLOW %X (%X) (%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }

    REFDEL(&pFlow->RefCount, 'TAFL');

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcAddFilter: Returned= 0x%X\n", Status ));
    }

    return Status;
}


/*
************************************************************************

Description:

    Deletes the filter and invalidates the handle.

Arguments:

    FilterHandle - handle of the filter to be deleted

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        invalid or NULL handle

************************************************************************
*/
DWORD
APIENTRY
TcDeleteFilter(
    IN         HANDLE          FilterHandle
    )
{
    DWORD                Status;
    PFILTER_STRUC        pFilter;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcDeleteFilter: Called: FilterHandle=%d\n", 
                 FilterHandle ));
    }

    VERIFY_INITIALIZATION_STATUS;

    pFilter = (PFILTER_STRUC)GetHandleObjectWithRef(FilterHandle, 
                                             ENUM_FILTER_TYPE, 'TDFL');

    if (pFilter == NULL) {

        Status = ERROR_INVALID_HANDLE;

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcDeleteFilter: Error = 0x%X\n", Status ));
        }

        return Status;
    }

    ASSERT((HANDLE)pFilter->ClHandle == FilterHandle);

    GetLock(pFilter->Lock);

    if (QUERY_STATE(pFilter->State) == OPEN) {
        
        SET_STATE(pFilter->State, USERCLOSED_KERNELCLOSEPENDING);
        FreeLock(pFilter->Lock);

    } else {

        //
        // Someone else is taking this out.
        //
        FreeLock(pFilter->Lock);
        REFDEL(&pFilter->RefCount, 'TDFL');

        return ERROR_INVALID_HANDLE;

    }



    Status = DeleteFilter(pFilter);

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcDeleteFilter: Returned= 0x%X\n", Status ));
    }

    REFDEL(&pFilter->RefCount, 'TDFL');
    
    return Status;
}




/*
************************************************************************

Description:

    This will deregister the client and release all associated resources.
    TC_NOTIFY_IFC_CHANGE notifications will no longer be reported to
    this client. All interface must have being close prior to calling
    this API, o/w an error will be returned.

Arguments:

    ClientHandle - handle of the client to be deregistered

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE                invalid or NULL handle
    ERROR_TC_SUPPORTED_OBJECTS_EXIST    not all the interfaces have been 
                                        closed for this client

************************************************************************
*/
DWORD
TcDeregisterClient(
    IN        HANDLE        ClientHandle
    )
{
    DWORD               Status;
    ULONG               Instance;
    PINTERFACE_STRUC    pClInterface;
    PCLIENT_STRUC       pClient;
    PLIST_ENTRY         pEntry;
    BOOLEAN             fOpenInterfacesFound;
    BOOLEAN             fDeRegisterWithGpc = FALSE;

    VERIFY_INITIALIZATION_STATUS;
    Status = NO_ERROR;
    fOpenInterfacesFound = FALSE;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcDeregisterClient: ClientHandle=%d\n", 
                 ClientHandle));
    }

    pClient = (PCLIENT_STRUC)GetHandleObject(ClientHandle, ENUM_CLIENT_TYPE);

    if (pClient == NULL) {
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("<==TcDeregisterClient: ERROR_INVALID_HANDLE\n"));
        }

        return ERROR_INVALID_HANDLE;
    }

    ASSERT((HANDLE)pClient->ClHandle == ClientHandle);

    // Prevent another thread from doing TcRegisterClient and TcDeregisterClient
    GetLock( ClientRegDeregLock );
    
    GetLock( pGlobals->Lock );
    
    // Go through the interface list and check if any interfaces are open.
    // for a checked build, lets dump out the interfaces and the refcounts on these
    // interfaces too. [ShreeM]

    pEntry = pClient->InterfaceList.Flink;
    while (pEntry != &pClient->InterfaceList) {

        pClInterface = CONTAINING_RECORD(pEntry, INTERFACE_STRUC, Linkage);

        GetLock(pClInterface->Lock);

        if ((QUERY_STATE(pClInterface->State) == FORCED_KERNELCLOSE) ||
            (QUERY_STATE(pClInterface->State) == KERNELCLOSED_USERCLEANUP)) {

#if DBG
            IF_DEBUG(WARNINGS) {
                WSPRINT(("<==TcDeregisterClient: Interface %x (H%x) is FORCED_KERNELCLOSE with RefCount:%d\n", 
                         pClInterface, pClInterface->ClHandle, pClInterface->RefCount));
            }
#endif 
        
        } else {

            fOpenInterfacesFound = TRUE;

#if DBG
            IF_DEBUG(ERRORS) {
                WSPRINT(("<==TcDeregisterClient: Interface %x (H%x) is open with RefCount:%d\n", pClInterface, pClInterface->ClHandle, pClInterface->RefCount));
            }
#endif 
        
        }

        pEntry = pEntry->Flink;
        FreeLock(pClInterface->Lock);



        if (fOpenInterfacesFound) {
            
            IF_DEBUG(ERRORS) {
                WSPRINT(("<==TcDeregisterClient: ERROR_TC_SUPPORTED_OBJECTS_EXIST (%d Interfaces)\n", pClient->InterfaceCount));
            }
            
            FreeLock( ClientRegDeregLock );
            FreeLock( pGlobals->Lock );
            return ERROR_TC_SUPPORTED_OBJECTS_EXIST;

        }

    }

    //
    // Lets mark it as deleting.
    //
    GetLock(pClient->Lock);
    SET_STATE(pClient->State, USERCLOSED_KERNELCLOSEPENDING);
    FreeLock(pClient->Lock);

    IF_DEBUG(HANDLES) {
        WSPRINT(("<==TcDeregisterClient: client (%x), RefCount:%d\n", pClient->ClHandle, pClient->RefCount));
    }

    REFDEL(&pClient->RefCount, 'CLNT');

    if ( IsListEmpty( &pGlobals->ClientList ) )
        fDeRegisterWithGpc = TRUE;
        
    FreeLock( pGlobals->Lock );
    
    if ( fDeRegisterWithGpc ) 
    {
        // When there are no clients left stop listening to
        // GPC notifications.
        Status = StopGpcNotifyThread();
    }
    
    FreeLock( ClientRegDeregLock );
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcDeregisterClient: NO_ERROR\n" ));
    }

    return NO_ERROR;
}





/*
************************************************************************

Description:

    Sends a WMI query on the guid with the instance name.
    Also sets the notification state to TRUE (=notify) or FALSE (dont notify).
    
Arguments:

    IfcHandle        - interface to send the query to 
    pGuidParam        - GUID of the queried property
    NotifyChange    - set the notification state for this property
    BufferSize        - size of allocated buffer
    Buffer             - the buffer for returned result

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        bad interface handle
    ERROR_INVALID_PARAMETER        bad parameter 
    ERROR_INSUFFICIENT_BUFFER    buffer too small for result
    ERROR_NOT_SUPPORTED            unsupported GUID

************************************************************************
*/
DWORD
APIENTRY
TcQueryInterface(    
    IN      HANDLE      IfcHandle,
    IN      LPGUID      pGuidParam,
    IN      BOOLEAN     NotifyChange,
    IN OUT  PULONG      pBufferSize,
    OUT     PVOID       Buffer 
    )
{
    DWORD                   Status;
    PINTERFACE_STRUC        pInterface;
    WMIHANDLE               hWmiHandle;
    TCHAR                   cstr[MAX_STRING_LENGTH];
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   cBufSize;
    ULONG                   InputBufferSize;
    

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcQueryInterface: Called: Name=%d\n", 
                 IfcHandle));
    }
    
    VERIFY_INITIALIZATION_STATUS;
        
    if (IsBadWritePtr(pBufferSize, sizeof(ULONG))) {
        
        return ERROR_INVALID_PARAMETER;
        
    }

    __try {
        
        InputBufferSize = *pBufferSize;
        *pBufferSize = 0;
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        Status = GetExceptionCode();
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcModifyFlow: Exception Error: = 0x%X\n", 
                       Status ));
        }      

        return Status;
    }

    if (IsBadReadPtr(pGuidParam,sizeof(GUID))) {
        
        return ERROR_INVALID_PARAMETER;
    }

    if (    (InputBufferSize != 0) 
        &&  (IsBadWritePtr(Buffer,InputBufferSize)) ) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                          ENUM_INTERFACE_TYPE, 'TCQI');

    if (pInterface == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }
    

    Status = WmiOpenBlock( pGuidParam,    // object
                           0,            // access
                           &hWmiHandle
                           );
    
    if (ERROR_FAILED(Status)) {

        TC_TRACE(ERRORS, ("[TcQueryInterface]: WmiOpenBlock failed with %x \n", Status));
        REFDEL(&pInterface->RefCount, 'TCQI');
        
        return Status;
    }

    //
    // allocate memory for the output wnode
    //
    
    cBufSize =    sizeof(WNODE_SINGLE_INSTANCE) 
                + InputBufferSize 
                + MAX_STRING_LENGTH * sizeof(TCHAR);
    
    AllocMem(&pWnode, cBufSize);
    
    if (pWnode == NULL) {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

    } else {
        
        //
        // query for the single instance
        //

#ifndef UNICODE
            
        if (-1 == wcstombs(cstr, 
                           pInterface->pTcIfc->InstanceName, 
                           pInterface->pTcIfc->InstanceNameLength
                           )) 
        {
            Status = ERROR_NO_UNICODE_TRANSLATION;
        }
        else 
        {

            Status = WmiQuerySingleInstance( hWmiHandle,
                                             cstr,
                                             &cBufSize,
                                             pWnode
                                             );
        }
#else

        Status = WmiQuerySingleInstance( hWmiHandle,
                                         pInterface->pTcIfc->InstanceName,
                                         &cBufSize,
                                         pWnode
                                         );
#endif


        if (!ERROR_FAILED(Status)) 
        {
            Status = WmiNotificationRegistration(pGuidParam,
                                                 NotifyChange,
                                                 CbWmiParamNotification,
                                                 PtrToUlong(IfcHandle),
                                                 NOTIFICATION_CALLBACK_DIRECT
                                                 );

            if (Status == ERROR_WMI_ALREADY_DISABLED ||
                Status == ERROR_WMI_ALREADY_ENABLED) {
                
                //
                // ignore these errors, we assumed it's okay
                //
                
                Status = NO_ERROR;
            }

            //
            // Now that we are registered with WMI - add it OR delete it from our list. (258218)
            //
            
            if (NotifyChange) {
                
                if (!TcipAddToNotificationList(
                                               pGuidParam,
                                               pInterface,
                                               0
                                               )) {
                    //
                    // Failed to put it on the list for some reason..
                    //
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: Could not add the GUID/IFC to private list \n"));
                    
                }
            } else {
                    
                if (!TcipDeleteFromNotificationList(
                                                    pGuidParam,
                                                    pInterface,
                                                    0
                                                    )) {
                    //
                    // Failed to remove it from the list for some reason..
                    //
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: Could not remove the GUID/IFC from private list \n"));

                }

            }
                
        }

        if (!ERROR_FAILED(Status)) {

            //
            // parse the wnode
            //

            //
            // check to see if the user allocated enough space for the 
            // returned buffer
            //

            if (pWnode->SizeDataBlock <= InputBufferSize) {
                
                __try {

                    RtlCopyMemory(Buffer,
                                  (PBYTE)OffsetToPtr(pWnode, pWnode->DataBlockOffset),
                                  pWnode->SizeDataBlock
                                  );

                    *pBufferSize = pWnode->SizeDataBlock;

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();
                    
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: Exception 0x%x while copying data \n", Status));
                }

            } else {

                //
                // output buffer too small
                //

                Status = ERROR_INSUFFICIENT_BUFFER;
                
                __try {
                
                    *pBufferSize = pWnode->SizeDataBlock;
                    
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();
                   
               }
            }
        }
    }
    
    WmiCloseBlock(hWmiHandle);

    if (pWnode)
        FreeMem(pWnode);

    REFDEL(&pInterface->RefCount, 'TCQI');

    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcQueryInterface: Returned= 0x%X\n", Status ));
    }

    return Status;
}

/*
************************************************************************

Description:

    Sends a WMI set on the GUID with the instance name.
    Not all propertied are writeable.

Arguments:
    IfcHandle    - interface handle to set the property on
    pGuidParam    - GUID of the property
    BufferSize    - allocate buffer size
    Buffer        - buffer that contains the data to be set

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        bad interface handle
    ERROR_INVALID_PARAMETER        bad parameter 
    ERROR_NOT_SUPPORTED            unsupported GUID
    ERROR_WRITE_PROTECT            GUID is read-only

************************************************************************
*/
DWORD
APIENTRY
TcSetInterface(    
    IN         HANDLE         IfcHandle,
    IN        LPGUID        pGuidParam,
    IN         ULONG        BufferSize,
    IN        PVOID        Buffer
    )
{
    DWORD                    Status;
    PINTERFACE_STRUC        pInterface;
    WMIHANDLE                hWmiHandle;
    TCHAR                    cstr[MAX_STRING_LENGTH];
    PWNODE_SINGLE_INSTANCE    pWnode;
    ULONG                    cBufSize;

    VERIFY_INITIALIZATION_STATUS;


    if (    IsBadReadPtr(pGuidParam,sizeof(GUID)) 
        ||  (BufferSize == 0) 
        ||  IsBadReadPtr(Buffer,BufferSize)) {

        return ERROR_INVALID_PARAMETER;
    }

    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TCSI');

    if (pInterface == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }

    __try {
        
        Status = WmiOpenBlock( pGuidParam,    // object
                           0,            // access
                           &hWmiHandle
                           );
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcSetInterface: Exception Error: = 0x%X\n", 
                       Status ));
          }

          REFDEL(&pInterface->RefCount, 'TCSI'); 
          return Status;
    }


    if (ERROR_FAILED(Status)) {
        
        TC_TRACE(ERRORS, ("[TcSetInterface]: WmiOpenBlock failed with error 0x%x \n", Status));
        REFDEL(&pInterface->RefCount, 'TCSI');

        return Status;
    }

    //
    // allocate memory for the output wnode
    //
    
    cBufSize = sizeof(WNODE_SINGLE_INSTANCE) 
        + BufferSize 
        + MAX_STRING_LENGTH * sizeof(TCHAR);
    
    AllocMem(&pWnode, cBufSize);
    
    if (pWnode == NULL) {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        //
        // set the single instance
        //

        __try {
        
#ifndef UNICODE

            if (-1 == wcstombs(cstr, 
                           pInterface->pTcIfc->InstanceName, 
                           pInterface->pTcIfc->InstanceNameLength
                           )) {
            
                Status = ERROR_NO_UNICODE_TRANSLATION;
            
            }
            else {

            
                Status = WmiSetSingleInstance( hWmiHandle,
                                           cstr,
                                           1,
                                           BufferSize,
                                           Buffer
                                           );
            }
#else
            Status = WmiSetSingleInstance( hWmiHandle,
                                       pInterface->pTcIfc->InstanceName,
                                       1,
                                       BufferSize,
                                       Buffer
                                       );
            
#endif
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status = GetExceptionCode();
        
            IF_DEBUG(ERRORS) {
                WSPRINT(("TcSetInterface: Exception Error: = 0x%X\n", 
                       Status ));
            }           
        }
    }

    WmiCloseBlock(hWmiHandle);

    if (pWnode)
        FreeMem(pWnode);

    REFDEL(&pInterface->RefCount, 'TCSI');

    return Status;
}




/*
************************************************************************

Description:

    Will issue a WMI query on the specific flow instance name.

Arguments:

    pFlowName    - flow instance name
    pGuidParam    - GUID of the queried property
    BufferSize    - size of allocated buffer
    Buffer         - the buffer for returned result

Return Value:

    NO_ERROR
    ERROR_INVALID_PARAMETER        bad parameter 
    ERROR_INSUFFICIENT_BUFFER    buffer too small for result
    ERROR_NOT_SUPPORTED            unsupported GUID
    ERROR_WMI_GUID_NOT_FOUND    
    ERROR_WMI_INSTANCE_NOT_FOUND

************************************************************************
*/
DWORD
APIENTRY
TcQueryFlowW(
    IN      LPWSTR      pFlowName,
    IN      LPGUID      pGuidParam,
    IN OUT  PULONG      pBufferSize,
    OUT     PVOID       Buffer 
    )
{
    DWORD                   Status;
    HANDLE                  hWmiHandle;
    TCHAR                   cstr[MAX_STRING_LENGTH];
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   cBufSize;
    ULONG                   InputBufferSize;
    
   
    if (IsBadWritePtr(pBufferSize, sizeof(ULONG)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try {

        InputBufferSize = *pBufferSize;
        *pBufferSize = 0;
        
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
          Status = GetExceptionCode();
        
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcSetFlowW: Exception Error: = 0x%X\n", 
                       Status ));
          }
  
          return Status;
    }
   
    if (    IsBadReadPtr(pGuidParam, sizeof(GUID))
        ||  IsBadStringPtr(pFlowName, MAX_STRING_LENGTH)
        ||  IsBadWritePtr(Buffer,InputBufferSize) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = WmiOpenBlock(pGuidParam,    // object
                          0,            // access
                          &hWmiHandle);

    if (ERROR_FAILED(Status)) {

        TC_TRACE(ERRORS, ("[TcQueryInterface]: WmiOpenBlock Error: = 0x%X\n", Status ));
        return Status;
    }

    //
    // allocate memory for the output wnode
    //
    
    cBufSize = sizeof(WNODE_SINGLE_INSTANCE) 
        + InputBufferSize
        + MAX_STRING_LENGTH * sizeof(TCHAR);
    
    AllocMem(&pWnode, cBufSize);
    
    if (pWnode == NULL) {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    } 
    else 
    {

        //
        // query for the single instance
        //


#ifndef UNICODE

        if (-1 == wcstombs(cstr,
                           pFlowName,
                           wcslen(pFlowName)
                           )) 
        {
            Status = ERROR_NO_UNICODE_TRANSLATION;
        } 
        else 
        {

            Status = WmiQuerySingleInstance( hWmiHandle,
                                             cstr,
                                             &cBufSize,
                                             pWnode
                                             );
        }
#else

        Status = WmiQuerySingleInstance( hWmiHandle,
                                         pFlowName,
                                         &cBufSize,
                                         pWnode
                                         );
#endif

        if (!ERROR_FAILED(Status)) {

            //
            // parse the wnode
            //


            //
            // check to see if the user allocated enough space for the 
            // returned buffer
            //

            if (pWnode->SizeDataBlock <= InputBufferSize) {

                __try {

                    RtlCopyMemory(Buffer,
                                  (PBYTE)OffsetToPtr(pWnode, pWnode->DataBlockOffset),
                                  pWnode->SizeDataBlock
                                  );

                    *pBufferSize = pWnode->SizeDataBlock;

                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();
                    
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: RtlCopyMemory Exception Error: = 0x%X\n", Status ));
                }

            } else {

                //
                // output buffer too small
                //
                __try {
                    *pBufferSize = pWnode->SizeDataBlock;
                 
                    Status = ERROR_INSUFFICIENT_BUFFER;
                    
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    
                    Status = GetExceptionCode();
                    
                    TC_TRACE(ERRORS, ("[TcQueryInterface]: RtlCopyMemory Exception Error: = 0x%X\n", Status ));
                }
            }
        }
    }

    WmiCloseBlock(hWmiHandle);

    if(pWnode)
        FreeMem(pWnode);

    return Status;
}


/*
************************************************************************

Description:

    The ANSI version of TcQueryFlowW

Arguments:

    See TcQueryFlowW

Return Value:

    See TcQueryFlowW

************************************************************************
*/
DWORD
APIENTRY
TcQueryFlowA(
    IN         LPSTR        pFlowName,
    IN        LPGUID        pGuidParam,
    IN OUT    PULONG        pBufferSize,
    OUT        PVOID        Buffer 
    )
{
    LPWSTR    pWstr = NULL;
    int     l;
    DWORD    Status;

    if (IsBadStringPtrA(pFlowName,MAX_STRING_LENGTH)) {
        
        return ERROR_INVALID_PARAMETER;
    }


    l = strlen(pFlowName) + 1;

    AllocMem(&pWstr, l*sizeof(WCHAR));

    if (pWstr == NULL) {

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (-1 == mbstowcs(pWstr, pFlowName, l)) {
            
        FreeMem(pWstr);
        return ERROR_NO_UNICODE_TRANSLATION;

    }


    Status = TcQueryFlowW(pWstr,
                          pGuidParam,
                          pBufferSize,
                          Buffer
                          );

    FreeMem(pWstr);

    return Status;
}



/*
************************************************************************

Description:

    Will issue a WMI set on the specific flow instance name.

Arguments:

    pFlowName    - flow instance name
    pGuidParam    - GUID of the queried property
    BufferSize    - size of allocated buffer
    Buffer         - the buffer to set

Return Value:

    NO_ERROR
    ERROR_INVALID_PARAMETER        bad parameter 
    ERROR_INSUFFICIENT_BUFFER    buffer too small for result
    ERROR_NOT_SUPPORTED            unsupported GUID
    ERROR_WMI_GUID_NOT_FOUND    
    ERROR_WMI_INSTANCE_NOT_FOUND

************************************************************************
*/
DWORD
APIENTRY
TcSetFlowW(
    IN      LPWSTR      pFlowName,
    IN      LPGUID      pGuidParam,
    IN      ULONG       BufferSize,
    IN      PVOID       Buffer 
    )
{
    DWORD                   Status;
    HANDLE                  hWmiHandle;
    TCHAR                   cstr[MAX_STRING_LENGTH];
    PWNODE_SINGLE_INSTANCE  pWnode;
    ULONG                   cBufSize;

    if (    IsBadStringPtr(pFlowName,MAX_STRING_LENGTH) 
        ||  IsBadReadPtr(pGuidParam,sizeof(GUID)) 
        ||  (BufferSize == 0)
        ||  IsBadReadPtr(Buffer,BufferSize)) {

        return ERROR_INVALID_PARAMETER;
    
    }

    Status = WmiOpenBlock( pGuidParam,    // object
                           0,            // access
                           &hWmiHandle
                           );
       
    if (ERROR_FAILED(Status)) {

        TC_TRACE(ERRORS, ("[TcSetFlow]: WmiOpenBlock failed with 0x%x \n", Status));
        return Status;
    }

    //
    // allocate memory for the output wnode
    //
    
    cBufSize = sizeof(WNODE_SINGLE_INSTANCE) 
        + BufferSize 
        + MAX_STRING_LENGTH * sizeof(TCHAR);

     
    AllocMem(&pWnode, cBufSize);
    
    if (pWnode == NULL) {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

    } else {

        //
        // set the single instance
        //

        __try {
#ifndef UNICODE

            if (-1 == wcstombs(cstr,
                           pFlowName,
                           wcslen(pFlowName)
                           )) {

                Status = ERROR_NO_UNICODE_TRANSLATION;
            
            } else {            

                Status = WmiQuerySingleInstance( hWmiHandle,
                                             cstr,
                                             &cBufSize,
                                             pWnode
                                             );
            }
#else
            Status = WmiSetSingleInstance( hWmiHandle,
                                       pFlowName,
                                       1,
                                       BufferSize,
                                       Buffer
                                       );
#endif
        } __except (EXCEPTION_EXECUTE_HANDLER) {
        
            Status = GetExceptionCode();
        
            IF_DEBUG(ERRORS) {
                WSPRINT(("TcSetFlowW: Exception Error: = 0x%X\n", 
                       Status ));
            }
  
        }

    }

    WmiCloseBlock(hWmiHandle);

    if (pWnode)
        FreeMem(pWnode);

    return Status;
}




/*
************************************************************************

Description:

    The ANSI version of TcSetFlowW

Arguments:

    See TcSetFlowW

Return Value:

    See TcSetFlowW

************************************************************************
*/ 
DWORD
APIENTRY
TcSetFlowA(
    IN      LPSTR       pFlowName,
    IN      LPGUID      pGuidParam,
    IN      ULONG       BufferSize,
    IN      PVOID       Buffer 
    )
{
    LPWSTR  pWstr;
    int     l;
    DWORD   Status;

    if (IsBadStringPtrA(pFlowName,MAX_STRING_LENGTH)) {
        
        return ERROR_INVALID_PARAMETER;
    }

    l = strlen(pFlowName) + 1;

    AllocMem(&pWstr, l*sizeof(WCHAR));

    if (pWstr == NULL) {

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if(-1 == mbstowcs(pWstr, pFlowName, l)) {
        // couldn't convert some multibyte characters - bail with error.
        
        FreeMem(pWstr);
        return ERROR_NO_UNICODE_TRANSLATION;
    }
     

    Status = TcSetFlowW(pWstr,
                        pGuidParam,
                        BufferSize,
                        Buffer
                        );

    FreeMem(pWstr);

    return Status;
}



/*
************************************************************************

Description:

    Will return the flow inatsnace name associated with the flow handle.

Arguments:

    FlowHandle  - the flow handle
    StrSize        - how many TCHAR can fit in the string buffer
    pFlowName    - a pointer to a string buffer

Return Value:

    See TcGetFlowNameW

************************************************************************
*/
DWORD
APIENTRY
TcGetFlowNameW(
    IN        HANDLE            FlowHandle,
    IN        ULONG            StrSize,
    OUT        LPWSTR            pFlowName
    )
{
    PFLOW_STRUC        pFlow;
    DWORD           Status;

    VERIFY_INITIALIZATION_STATUS;

    if (IsBadWritePtr(pFlowName,StrSize*sizeof(WCHAR))) {
    
        return ERROR_INVALID_PARAMETER;
    }
    
    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, ENUM_GEN_FLOW_TYPE, 'TGFW');

    if (pFlow == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcGetFlowNameW: Error = 0x%X\n", Status ));
        }

        return ERROR_NOT_READY;
    }

    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    if (pFlow->InstanceNameLength+sizeof(WCHAR) > (USHORT)StrSize) {

        //IF_DEBUG(REFCOUNTS) { WSPRINT(("8\n"));
        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("8 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }
        REFDEL(&pFlow->RefCount, 'TGFW');

        return ERROR_INSUFFICIENT_BUFFER;
    }

    __try {

        wcscpy(pFlowName, pFlow->InstanceName);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

          Status = GetExceptionCode();
          
          IF_DEBUG(ERRORS) {
              WSPRINT(("TcGetFlowName: Exception Error: = 0x%X\n", Status ));
          }
      
          REFDEL(&pFlow->RefCount, 'TGFW');
      
          return Status;
    }


    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("9 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }

    REFDEL(&pFlow->RefCount, 'TGFW');
    
    return NO_ERROR;
}




/*
************************************************************************

Description:

    The ANSI version of TcGetFlowNameW

Arguments:

    See TcGetFlowNameW

Return Value:

    See TcGetFlowNameW

************************************************************************
*/
DWORD
APIENTRY
TcGetFlowNameA(
    IN        HANDLE            FlowHandle,
    IN        ULONG            StrSize,
    OUT        LPSTR            pFlowName
    )
{
    PFLOW_STRUC        pFlow;
    DWORD           Status = NO_ERROR;

    VERIFY_INITIALIZATION_STATUS;

    if (IsBadWritePtr(pFlowName,StrSize * sizeof(CHAR))) {

        return ERROR_INVALID_PARAMETER;
    }
    
    pFlow = (PFLOW_STRUC)GetHandleObjectWithRef(FlowHandle, ENUM_GEN_FLOW_TYPE, 'TGFA');

    if (pFlow == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }
    else if (pFlow == INVALID_HANDLE_VALUE ) 
    {
    
        Status = ERROR_NOT_READY;
        
        IF_DEBUG(ERRORS) {
            WSPRINT(("TcGetFlowNameA: Error = 0x%X\n", Status ));
        }

        return ERROR_NOT_READY;
    }

    ASSERT((HANDLE)pFlow->ClHandle == FlowHandle);

    if (pFlow->InstanceNameLength+sizeof(CHAR) > (USHORT)StrSize) {

        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("11 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
        }
        REFDEL(&pFlow->RefCount, 'TGFA');

        return ERROR_INSUFFICIENT_BUFFER;
    }

    __try {

        if (-1 == wcstombs(
                           pFlowName, 
                           pFlow->InstanceName, 
                           pFlow->InstanceNameLength)) {

            Status = ERROR_NO_UNICODE_TRANSLATION;

        }


    } __except (EXCEPTION_EXECUTE_HANDLER) {

          Status = GetExceptionCode();

          IF_DEBUG(ERRORS) {
              WSPRINT(("TcGetFlowName: Exception Error: = 0x%X\n", Status ));
          }
          
          REFDEL(&pFlow->RefCount, 'TGFA');
          
          return Status;
    }



    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("12 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }
    
    REFDEL(&pFlow->RefCount, 'TGFA');

    return Status;
}




/*
************************************************************************

Description:

    This will return a specified number of flows with their respective
    filter, given the buffer is big enough. The user allocates the buffer,
    and passes a pointer to an enumeration token. This will be used
    by the GPC to keep track what was the last enumerated flow and will 
    initially be point to a NULL value (reset by TC_RESET_ENUM_TOKEN).
    The user will also pass the number of requested flow and will get back 
    the actual number of flows that have been placed in the buffer.
    If the buffer is too small, an error code will be returned. If there are
    no more flows to enumerate, NO_ERROR will be returned and pFlowCount
    will be set to zero. It is invalid to request zero flows

Arguments:

    IfcHandle    - the interface to enumerate flows on
    pEnumToken    - enumeration handles pointer, 
                  user must not change after the first call
    pFlowCount    - in: # of requested flows; out: actual # of flows returned
    pBufSize    - in: allocated bytes; out: filled bytes
    Buffer        - formatted data

Return Value:

    NO_ERROR
    ERROR_INVALID_HANDLE        bad interface handle
    ERROR_INVALID_PARAMETER        one of the pointers is null or either
                                pFlowCount or pBufSize are set to zero
    ERROR_INSUFFICIENT_BUFFER    indicates that the provided buffer is too 
                                small to return even the information for a 
                                single flow and the attached filters.
    ERROR_NOT_ENOUGH_MEMORY        out of memory
    ERROR_INVALID_DATA            enumeration handle no longer valid

************************************************************************
*/
DWORD
APIENTRY
TcEnumerateFlows(    
    IN      HANDLE              IfcHandle,
    IN OUT  PHANDLE             pEnumHandle,
    IN OUT  PULONG              pFlowCount,
    IN OUT  PULONG              pBufSize,
    OUT     PENUMERATION_BUFFER Buffer
    )
{
    DWORD                   Status;
    PINTERFACE_STRUC        pInterface;
    PGPC_ENUM_CFINFO_RES    OutBuffer;
    ULONG                   cFlows;
    ULONG                   BufSize;
    ULONG                   TotalFlows;
    ULONG                   TotalBytes;
    PFLOW_STRUC             pFlow;
    PGPC_CLIENT             pGpcClient;
    PLIST_ENTRY             pHead, pEntry;
    GPC_HANDLE              GpcFlowHandle;
    PGPC_ENUM_CFINFO_BUFFER pGpcEnumBuf;
    PCF_INFO_QOS            pCfInfo;
    ULONG                   Len, i, j;
    ULONG                   GenFlowSize;
    PCHAR                   p;
    BOOLEAN                 bMore;
    PTC_GEN_FILTER          pFilter;
    PGPC_GEN_PATTERN        pPattern;

    ULONG                   InputBufSize;
    ULONG                   InputFlowCount;

    VERIFY_INITIALIZATION_STATUS;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>TcEnumerateFlows: Called: IfcHandle= %d", 
                 IfcHandle  ));
    }


    if (    IsBadWritePtr(pBufSize, sizeof(ULONG))
        ||  IsBadWritePtr(pFlowCount, sizeof(ULONG))
        ||  IsBadWritePtr(pEnumHandle,sizeof(HANDLE)) ) {

        return ERROR_INVALID_PARAMETER;

    }

    __try {
    
        InputBufSize    = *pBufSize;
       // *pBufSize      = 0; // reset it in case of an error
        InputFlowCount  = *pFlowCount;
        GpcFlowHandle   = *pEnumHandle;
                    
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();              
        
        return Status;
    }

    if (    IsBadWritePtr(Buffer, InputBufSize)
        ||  (InputFlowCount == 0) ) {

	return ERROR_INVALID_PARAMETER;

    }

    if (InputBufSize == 0) {

        return ERROR_INSUFFICIENT_BUFFER;

    }
    
    pInterface = (PINTERFACE_STRUC)GetHandleObjectWithRef(IfcHandle, 
                                                   ENUM_INTERFACE_TYPE, 'TCEF');

    if (pInterface == NULL) {
        
        return ERROR_INVALID_HANDLE;
    }

   
    pGpcClient = FindGpcClient(GPC_CF_QOS);

    if (pGpcClient == NULL) {
        
        REFDEL(&pInterface->RefCount, 'TCEF');

        return ERROR_DEV_NOT_EXIST;
    }

    //
    // We are enumerating flows on the interface. we cant afford to have the
    // flows deleted from teh list, therefore we shall take the global lock here.
    //
    GetLock(pGlobals->Lock);

    // back to regularly scheduled programming

    TotalFlows = 0;
    TotalBytes = 0;

    bMore = TRUE;

    while (bMore) {

        BufSize = InputBufSize - TotalBytes;
        cFlows = InputFlowCount - TotalFlows;
        
        Status = IoEnumerateFlows(pGpcClient,
                                  &GpcFlowHandle,
                                  &cFlows,
                                  &BufSize,
                                  &OutBuffer
                                  );
    
        if (!ERROR_FAILED(Status)) {

            //
            // parse the output buffer and return only the flows that have the 
            // interface name in them
            //

            pGpcEnumBuf = &OutBuffer->EnumBuffer[0];
            
            for (i = 0; i < cFlows; i++) {

                //
                // get the CfInfo
                //
                
                pCfInfo = (PCF_INFO_QOS)((PCHAR)pGpcEnumBuf + 
                                         pGpcEnumBuf->CfInfoOffset);

                //
                // check if this flow belongs to this interface
                //

                if (wcscmp(pCfInfo->InstanceName,
                           pInterface->pTcIfc->InstanceName) == 0) {

                    //
                    // the flow is installed on this instance
                    //

                    GenFlowSize = FIELD_OFFSET(TC_GEN_FLOW, TcObjects)
                        + pCfInfo->GenFlow.TcObjectsLength;

                    //
                    // The GPC used GPC_GEN_PATTERN when it computed 
                    // PatternMaskLen. But, we are using TC_GEN_FILTER
                    // to display the patterns. So, we need to account 
                    // for the difference in GPC_GEN_PATTERN and 
                    // TC_GEN_FILTER.
                    //
                    // No, this cannot be made cleaner by getting the GPC
                    // to use TC_GEN_FILTER. The GPC is a generic packet 
                    // classifier and hence shouldn't know about TC_GEN_FILTER.
                    //

                    Len = FIELD_OFFSET(ENUMERATION_BUFFER, GenericFilter)
                        + GenFlowSize
                        + pGpcEnumBuf->PatternMaskLen
                        - pGpcEnumBuf->PatternCount * sizeof(GPC_GEN_PATTERN) 
                        + pGpcEnumBuf->PatternCount * sizeof(TC_GEN_FILTER);

                    Len = ((Len + (sizeof(PVOID)-1)) & ~(sizeof(PVOID)-1));

                    if (TotalBytes + Len > InputBufSize) {
                        
                        //
                        // not enough buffer output space
                        //
                        
                        if (TotalFlows == 0) 
                            Status = ERROR_INSUFFICIENT_BUFFER;
                        
                        bMore = FALSE;
                        break;
                    }
                    
                    //
                    // fill the output buffer
                    //

                    __try {
                    
                        Buffer->Length = Len;
                        Buffer->OwnerProcessId = PtrToUlong(pGpcEnumBuf->OwnerClientCtx);
                        Buffer->FlowNameLength = pGpcEnumBuf->InstanceNameLength;
                        wcscpy(Buffer->FlowName, pGpcEnumBuf->InstanceName);
                        Buffer->NumberOfFilters = pGpcEnumBuf->PatternCount;
                        pFilter = (PTC_GEN_FILTER)
                            ((PCHAR)Buffer
                             + FIELD_OFFSET(ENUMERATION_BUFFER, GenericFilter));
                        
                    } __except (EXCEPTION_EXECUTE_HANDLER) {

                        Status = GetExceptionCode();              
        
                        break;
                    }

                    pPattern = &pGpcEnumBuf->GenericPattern[0];

                    //
                    // fill the filters
                    //

                    for (j = 0; j < pGpcEnumBuf->PatternCount; j++) {

                        switch(pPattern->ProtocolId) {

                        case GPC_PROTOCOL_TEMPLATE_IP:
                            
                            pFilter->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
                            ASSERT(pPattern->PatternSize 
                                   == sizeof(IP_PATTERN));
                            break;

                        case GPC_PROTOCOL_TEMPLATE_IPX:
                            
                            pFilter->AddressType = NDIS_PROTOCOL_ID_IPX;
                            ASSERT(pPattern->PatternSize 
                                   == sizeof(IPX_PATTERN));
                            break;

                        default:
                            ASSERT(0);
                        }

                        pFilter->PatternSize = pPattern->PatternSize ;
                        pFilter->Pattern = (PVOID)((PCHAR)pFilter 
                                                   + sizeof(TC_GEN_FILTER));
                        pFilter->Mask = (PVOID)((PCHAR)pFilter->Pattern
                                                + pPattern->PatternSize);

                        //
                        // copy the pattern
                        //

                        p = ((PUCHAR)pPattern) + pPattern->PatternOffset;

                        RtlCopyMemory(pFilter->Pattern, 
                                      p, 
                                      pPattern->PatternSize);

                        //
                        // copy the mask
                        //

                        p = ((PUCHAR)pPattern) + pPattern->MaskOffset;

                        RtlCopyMemory(pFilter->Mask, 
                                      p, 
                                      pPattern->PatternSize);

                        //
                        // advance the filter pointer to the next item
                        //

                        pFilter = (PTC_GEN_FILTER)
                            ((PCHAR)pFilter
                             + sizeof(TC_GEN_FILTER)
                             + pPattern->PatternSize * 2);

                        pPattern = (PGPC_GEN_PATTERN)(p + pPattern->PatternSize);

                    } // for (...)

                    //
                    // fill the flow
                    //

                    __try {
                    
                        Buffer->pFlow = (PTC_GEN_FLOW)pFilter;
                        RtlCopyMemory(pFilter, 
                                      &pCfInfo->GenFlow,
                                      GenFlowSize
                                      );

                        //
                        // advance to the next available slot in
                        // the output buffer
                        //

                        Buffer = (PENUMERATION_BUFFER)((PCHAR)Buffer + Len);

                    } __except (EXCEPTION_EXECUTE_HANDLER) {

                        Status = GetExceptionCode();              
        
                        break;
                    }

                    
                    //
                    // update total counts
                    //

                    TotalBytes += Len;
                    TotalFlows++;
                }
                
                //
                // advance to the next entry in the GPC returned buffer
                //

                pGpcEnumBuf = (PGPC_ENUM_CFINFO_BUFFER)((PCHAR)pGpcEnumBuf
                                                        + pGpcEnumBuf->Length);
            }

            //
            // release the buffer 
            //

            FreeMem(OutBuffer);

            //
            // check to see if we still have room for more flows
            // and adjust the call parameters
            //

            if (TotalFlows == InputFlowCount ||
                TotalBytes + sizeof(ENUMERATION_BUFFER) > InputBufSize ) {

                //
                // that's it, stop enumerating here
                //

                break;
            }

            //
            // check the GpcFlowHandle and quit if needed
            //

            if (GpcFlowHandle == NULL) {

                break;
            }

        } else {
            
            //
            // there was some error returned,
            // we still have to check if that's the first call
            // 
            //

            if (Status == ERROR_INVALID_DATA) {
                __try {
                    
                    *pEnumHandle = NULL;
                    
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                    Status = GetExceptionCode();              
       
                }

            } else if (TotalFlows > 0) {

                Status = NO_ERROR;

            }

            break;
        }
    } // while

    if (!ERROR_FAILED(Status)) {

        __try {

            *pEnumHandle = GpcFlowHandle;
            *pFlowCount = TotalFlows;
            *pBufSize = TotalBytes;
            
        } __except (EXCEPTION_EXECUTE_HANDLER) {
                
            Status = GetExceptionCode();              

        }        

    } 
    
    //
    // Free all the flow refs taken at the start.
    //
    FreeLock(pGlobals->Lock);

    REFDEL(&pInterface->RefCount, 'TCEF');
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==TcEnumerateFlows: Returned= 0x%X\n", Status ));
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\apiutil.c ===
/*++                                   

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    apiutil.c

Abstract:

    This module contains the traffic control api utils

Author:

    Jim Stewart ( jstew )    August 22, 1996

Revision History:

        Ofer Bar (oferbar)              Oct 1, 1997
--*/

#include "precomp.h"
#pragma hdrstop

#include <initguid.h>
#define INITGUID
#include "ntddtc.h"


static BOOLEAN _init = FALSE;

#if 0
// Name of the DLL to load
const CHAR  IpHlpApiDllName[] = "iphlpapi";

// Names of the functions called in IPHLPAPI
const CHAR GET_IF_ENTRY[] =         "GetIfEntry";
const CHAR GET_IP_ADDR_TABLE[] =    "GetIpAddrTable";
const CHAR GET_BEST_ROUTE[] =       "GetBestRoute";


 
IPROUTE_IF      IpRouteTab;
#endif

TCHAR   SzBuf[MAX_PATH];

//
VOID
MarkAllNodesForClosing(
                           PINTERFACE_STRUC pInterface,
			   STATE stateToMark
                           )
/*++

Description:
    This routine will mark all flows and filters on a INTERFACE_STRUC (a client's interface struct)
    as close FORCED_KERNELCLOSE or EXIT_CLEANUP. Please note that it is already called with the global lock held.

Arguments:

    pInterface - ptr to the interface
    stateToMark - the state to mark the nodes (FORCED_KERNELCLOSE or EXIT_CLEANUP)

Return Value:

    nothing

--*/

{
    PLIST_ENTRY     pEntry, pFilterEntry;
    PFLOW_STRUC     pFlow;
    PFILTER_STRUC   pFilter;

    ASSERT((stateToMark == FORCED_KERNELCLOSE) || (stateToMark == EXIT_CLEANUP));

    pEntry = pInterface->FlowList.Flink;

    while (pEntry != &pInterface->FlowList) {
        
        pFlow = CONTAINING_RECORD(pEntry, FLOW_STRUC, Linkage);

        //
        // For each flow and filter, first check if the user is trying to close it
        // if that is the case, do nothing, otherwise, mark it 
        GetLock(pFlow->Lock);

        if (QUERY_STATE(pFlow->State) == OPEN) {

            // Cleanup from under teh user...
            SET_STATE(pFlow->State, stateToMark);
            

        } else {

            ASSERT(IsListEmpty(&pFlow->FilterList));
            // There's nothing to be done here.
            IF_DEBUG(WARNINGS) {
                WSPRINT(("Against a forced close - Flow is removed by the user\n", pFlow));

            }
        }

        pFilterEntry = pFlow->FilterList.Flink;

        while (pFilterEntry != &pFlow->FilterList) {

            pFilter = CONTAINING_RECORD(pFilterEntry, FILTER_STRUC, Linkage);

            GetLock(pFilter->Lock);

            if (QUERY_STATE(pFilter->State) == OPEN) {
    
                // Cleanup from under teh user...
                SET_STATE(pFilter->State, stateToMark);                
    
            } else {
    
                // There's nothing to be done here.
                IF_DEBUG(WARNINGS) {
                    WSPRINT(("Against a forced close - Filter is removed by the user\n", pFilter));
    
                }
            }
            
            pFilterEntry = pFilterEntry->Flink;
            FreeLock(pFilter->Lock);

        }

        pEntry = pEntry->Flink;
        FreeLock(pFlow->Lock);
    }

}



VOID
CloseOpenFlows(
    IN PINTERFACE_STRUC   pInterface
    )

/*++

Description:
    This routine closes any flows that are open on an interface.

Arguments:

    pInterface - ptr to the interface

Return Value:

    nothing

--*/
{
    DWORD           Status = NO_ERROR;
    PLIST_ENTRY     pEntry;
    PFLOW_STRUC     pFlow;

    GetLock( pGlobals->Lock );
    
    pEntry = pInterface->FlowList.Flink;

    while (pEntry != &pInterface->FlowList) {
    
        pFlow = CONTAINING_RECORD( pEntry, FLOW_STRUC, Linkage );

        GetLock(pFlow->Lock);

        if ((QUERY_STATE(pFlow->State) == FORCED_KERNELCLOSE) ||
            (QUERY_STATE(pFlow->State) == EXIT_CLEANUP)) {

            pEntry = pEntry->Flink;
            FreeLock(pFlow->Lock);

            IF_DEBUG(SHUTDOWN) {
                WSPRINT(( "Closing Flow: 0x%X\n", pFlow));
            }

            Status = DeleteFlow( pFlow, TRUE );

            IF_DEBUG(SHUTDOWN) {
                WSPRINT(("CloseOpenFlows: DeleteFlow returned=0x%X\n", 
                         Status));
            }

        } else {

            pEntry = pEntry->Flink;
            FreeLock(pFlow->Lock);

        }

    }
    
    FreeLock( pGlobals->Lock );

}



VOID
CloseOpenFilters(
    IN PFLOW_STRUC   pFlow
    )

/*++

Description:
    This routine closes any filters that are open on a flow.

Arguments:

    pFlow - ptr to the flow

Return Value:

    nothing

--*/
{
    DWORD           Status = NO_ERROR;
    PLIST_ENTRY     pEntry;
    PFILTER_STRUC   pFilter;

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "CloseOpenFilters: Closing all Open Filters\n" ));
    }

    GetLock( pGlobals->Lock );
    
    pEntry = pFlow->FilterList.Flink;

    while (pEntry != &pFlow->FilterList) {
    
        pFilter = CONTAINING_RECORD( pEntry, FILTER_STRUC, Linkage );

        GetLock(pFilter->Lock);

        if ((QUERY_STATE(pFilter->State) == FORCED_KERNELCLOSE) ||
            (QUERY_STATE(pFilter->State) == EXIT_CLEANUP)) {
        
            // we can take a ref here, but we own it anyways!
            pEntry = pEntry->Flink;
            FreeLock(pFilter->Lock);

            Status = DeleteFilter( pFilter );

            IF_DEBUG(SHUTDOWN) {
                WSPRINT(( "CloseOpenFilters: DeleteFilter returned=0x%X\n",
                          Status));
            }
            //ASSERT(Status == NO_ERROR);

        } else {

            pEntry = pEntry->Flink;
            FreeLock(pFilter->Lock);

            IF_DEBUG(SHUTDOWN) {
                WSPRINT(( "CloseOpenFilters: DeleteFilter (%x) was skipped because its state (%d)\n",
                          pFilter, pFilter->State));
            }

        }
                
    }
        
    FreeLock( pGlobals->Lock );

}



VOID
DeleteFlowStruc(
    IN PFLOW_STRUC  pFlow 
    )

/*++

Description:

    This routine frees the handle and memory associated
    with the structure.

Arguments:

    pFlow      - ptr to the flow

Return Value:

    nothing

--*/
{
    if(pFlow->PendingEvent)
        CloseHandle(pFlow->PendingEvent);    

    DeleteLock(pFlow->Lock);

    if (pFlow->pGenFlow) {
        FreeMem(pFlow->pGenFlow);
        pFlow->GenFlowLen = 0;
    }

    if (pFlow->pGenFlow1) {
        FreeMem(pFlow->pGenFlow1);
        pFlow->GenFlowLen1 = 0;
    }

    if (pFlow->pClassMapFlow)
        FreeMem(pFlow->pClassMapFlow);

    if (pFlow->pClassMapFlow1)
        FreeMem(pFlow->pClassMapFlow1);

    FreeMem(pFlow);
}



VOID
DeleteFilterStruc(
    IN PFILTER_STRUC  pFilter
    )

/*++

Description:

    This routine frees the handle and memory associated
    with the structure.

Arguments:

    pFIlter

Return Value:

    nothing

--*/
{

    if (pFilter->pGpcFilter)
        FreeMem(pFilter->pGpcFilter);

    DeleteLock(pFilter->Lock);

    FreeMem(pFilter);

}




PTC_IFC
GetTcIfc(
        IN LPWSTR       pInterfaceName
    )
{
    PTC_IFC             pIfc = NULL;
    PLIST_ENTRY pHead, pEntry;
    DWORD       Status = NO_ERROR;

    GetLock(pGlobals->Lock);

    pHead = &pGlobals->TcIfcList;

    pEntry = pHead->Flink;

    while (pEntry != pHead && pIfc == NULL) {

        pIfc = CONTAINING_RECORD(pEntry, TC_IFC, Linkage);

        __try {
            
            if (wcsncmp(pInterfaceName,
                        pIfc->InstanceName,
                        wcslen(pIfc->InstanceName)) != 0) {
            
                //
                // not found
                //
                pIfc = NULL;

            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
      
              Status = GetExceptionCode();

              IF_DEBUG(ERRORS) {
                  WSPRINT(("GetTcIfc: Invalid pInterfaceName(%x) Exception: = 0x%X\n", 
                           pInterfaceName, Status ));
              }
              
              FreeLock(pGlobals->Lock);
              return NULL;
        }

        pEntry = pEntry->Flink;
    }

    FreeLock(pGlobals->Lock);

    return pIfc;
}



PTC_IFC
GetTcIfcWithRef(
        IN LPWSTR       pInterfaceName,
        IN ULONG        RefType
    )
{
    PTC_IFC             pIfc = NULL;
    PLIST_ENTRY pHead, pEntry;
    DWORD       Status = NO_ERROR;

    GetLock(pGlobals->Lock);

    pHead = &pGlobals->TcIfcList;

    pEntry = pHead->Flink;

    while (pEntry != pHead && pIfc == NULL) {

        pIfc = CONTAINING_RECORD(pEntry, TC_IFC, Linkage);

        __try {
            
            if (wcsncmp(pInterfaceName,
                        pIfc->InstanceName,
                        wcslen(pIfc->InstanceName)) != 0) {
            
                //
                // not found
                //
                pIfc = NULL;

            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
      
              Status = GetExceptionCode();

              IF_DEBUG(ERRORS) {
                  WSPRINT(("GetTcIfc: Invalid pInterfaceName(%x) Exception: = 0x%X\n", 
                           pInterfaceName, Status ));
              }
              
              FreeLock(pGlobals->Lock);
              return NULL;
        }

        pEntry = pEntry->Flink;

    }


    
    if (pIfc) {

        GetLock(pIfc->Lock);

        if (QUERY_STATE(pIfc->State)== OPEN) {

            FreeLock(pIfc->Lock);
            REFADD(&pIfc->RefCount, RefType);
            FreeLock(pGlobals->Lock);
            return pIfc;

        } else {

            FreeLock(pIfc->Lock);
            FreeLock(pGlobals->Lock);
            return NULL;

        }

    } else {
        
        FreeLock(pGlobals->Lock);
        return NULL;

    }

}


DWORD
UpdateTcIfcList(
        IN      LPWSTR                                  InstanceName,
        IN  ULONG                                   IndicationBufferSize,
        IN  PTC_INDICATION_BUFFER   IndicationBuffer,
        IN  DWORD                                   IndicationCode
        )
{
    DWORD                       Status = NO_ERROR;
    PTC_IFC                     pTcIfc;
    ULONG                       l;
    PADDRESS_LIST_DESCRIPTOR    pAddrListDesc;

    switch (IndicationCode) {

    case TC_NOTIFY_IFC_UP:

        //
        // Allocate a new interface descriptor structure
        //
        
        l = IndicationBufferSize 
            - FIELD_OFFSET(TC_INDICATION_BUFFER,InfoBuffer) - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);


        CreateKernelInterfaceStruc(&pTcIfc, l);

        if (pTcIfc) {
            
            //
            // copy the instance name string data
            //
                
            wcscpy(pTcIfc->InstanceName, InstanceName);
    
            pTcIfc->InstanceNameLength = wcslen(InstanceName) * sizeof(WCHAR);
    
            //
            // copy the instance ID string data
            //
                
            pTcIfc->InstanceIDLength = IndicationBuffer->InfoBuffer.InstanceIDLength;
    
            memcpy((PVOID)pTcIfc->InstanceID, 
                   (PVOID)IndicationBuffer->InfoBuffer.InstanceID,
                   pTcIfc->InstanceIDLength);
    
            pTcIfc->InstanceID[pTcIfc->InstanceIDLength/sizeof(WCHAR)] = L'\0';
    
            //
            // copy the instance data
            // in this case - the network address
            //
                
            pTcIfc->AddrListBytesCount = l;
    
            RtlCopyMemory( pTcIfc->pAddressListDesc,
                           &IndicationBuffer->InfoBuffer.AddrListDesc, 
                           l );
    
            if (NO_ERROR != GetInterfaceIndex(pTcIfc->pAddressListDesc,
                                              &pTcIfc->InterfaceIndex,
                                              &pTcIfc->SpecificLinkCtx)) {
                pTcIfc->InterfaceIndex  = IF_UNKNOWN;
                pTcIfc->SpecificLinkCtx = IF_UNKNOWN;

            }

            //
            //
            // Add the structure to the global linked list
            //
            GetLock(pTcIfc->Lock);
            SET_STATE(pTcIfc->State, OPEN);
            FreeLock(pTcIfc->Lock);

            GetLock( pGlobals->Lock );
            InsertTailList(&pGlobals->TcIfcList, &pTcIfc->Linkage );
            FreeLock( pGlobals->Lock );

#if 0            
            //
            // there's a new TC inetrface, check the GPC client list
            //
    
            OpenGpcClients(pTcIfc);
#endif
                


        } else {

            Status = ERROR_NOT_ENOUGH_MEMORY;

        }

        break;

    case TC_NOTIFY_IFC_CLOSE:

        pTcIfc = GetTcIfc(InstanceName);
        REFDEL(&pTcIfc->RefCount, 'KIFC');

        break;

    case TC_NOTIFY_IFC_CHANGE:
        
        pTcIfc = GetTcIfc(InstanceName);

        if (pTcIfc == NULL) {

            return Status;
        }

        //
        // copy the instance ID string data
        //
        
        pTcIfc->InstanceIDLength = IndicationBuffer->InfoBuffer.InstanceIDLength;
        
        memcpy(pTcIfc->InstanceID, 
               IndicationBuffer->InfoBuffer.InstanceID,
               pTcIfc->InstanceIDLength);
        
        pTcIfc->InstanceID[pTcIfc->InstanceIDLength/sizeof(WCHAR)] = L'\0';

        l = IndicationBufferSize 
            - FIELD_OFFSET(TC_INDICATION_BUFFER,InfoBuffer) - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

        AllocMem(&pAddrListDesc, l);

        if (pAddrListDesc) {

            //
            // copy the instance data
            // in this case - the network address
            //
            
            RtlCopyMemory( pAddrListDesc,
                           &IndicationBuffer->InfoBuffer.AddrListDesc,
                           l );

            GetLock( pGlobals->Lock );

            FreeMem(pTcIfc->pAddressListDesc);

            pTcIfc->AddrListBytesCount = l;
            pTcIfc->pAddressListDesc = pAddrListDesc;


            if (NO_ERROR != GetInterfaceIndex(pTcIfc->pAddressListDesc,
                                              &pTcIfc->InterfaceIndex,
                                              &pTcIfc->SpecificLinkCtx)) {
                pTcIfc->InterfaceIndex  = IF_UNKNOWN;
                pTcIfc->SpecificLinkCtx = IF_UNKNOWN;

            }

            FreeLock( pGlobals->Lock );

#if 0            
            //
            // there's a new addr list, check the GPC client list
            //

            OpenGpcClients(pTcIfc);
#endif

        } else {

            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        ASSERT(0);
    }

    return Status;
}





DWORD
CreateClientStruc(
        IN  HANDLE                      ClRegCtx,
    OUT PCLIENT_STRUC   *ppClient
    )
{
    PCLIENT_STRUC       pClient;
    DWORD                       Status = NO_ERROR;

    AllocMem(&pClient, sizeof(CLIENT_STRUC));

    if (pClient != NULL) {

        RtlZeroMemory(pClient, sizeof(CLIENT_STRUC));

        //
        // acquire a new handle for the client
        //

        pClient->ClHandle = AllocateHandle((PVOID)pClient);

        if (!pClient->ClHandle) {
            FreeMem(pClient);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // set the other parameters in the client interface
        //
        
        pClient->ObjectType = ENUM_CLIENT_TYPE;
        pClient->ClRegCtx = ClRegCtx;
        InitializeListHead(&pClient->InterfaceList);
        ReferenceInit(&pClient->RefCount, pClient, DereferenceClient);
        REFADD(&pClient->RefCount, 'CLNT');

        __try {

            InitLock(pClient->Lock);
                                                                     
        } __except (EXCEPTION_EXECUTE_HANDLER) {                            
                                                                                 
            Status = GetExceptionCode();                                    
                                                                    
            IF_DEBUG(ERRORS) {                                              
                WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));  
            }                                                               
            
            FreeHandle(pClient->ClHandle);
            FreeMem(pClient);
                                                                     
            return Status; 

        }

        SET_STATE(pClient->State, INSTALLING);

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppClient = pClient;

    return Status;
}



DWORD
CreateClInterfaceStruc(
        IN  HANDLE                              ClIfcCtx,
    OUT PINTERFACE_STRUC        *ppClIfc
    )
{
    PINTERFACE_STRUC    pClIfc;
    DWORD                               Status = NO_ERROR;

    AllocMem(&pClIfc, sizeof(INTERFACE_STRUC));

    if (pClIfc != NULL) {

        RtlZeroMemory(pClIfc, sizeof(INTERFACE_STRUC));

        //
        // acquire a new handle for the client
        //

        GetLock(pGlobals->Lock);
        pClIfc->ClHandle = AllocateHandle((PVOID)pClIfc);
        FreeLock(pGlobals->Lock);

        if (!pClIfc->ClHandle) {
            FreeMem(pClIfc);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ((pClIfc->IfcEvent = CreateEvent(  NULL,  // pointer to security attributes
                                              TRUE,  // flag for manual-reset event
                                              FALSE, // flag for initial state
                                              NULL   // pointer to event-object name);
                                              )) == NULL) {
            Status = GetLastError();

            IF_DEBUG(ERRORS) {
                WSPRINT(( "Error Creating Event for Interface: 0x%X:%d\n", pClIfc, Status));
            }
    
            FreeHandle(pClIfc->ClHandle);
            FreeMem(pClIfc);
            return Status;

        } 

        //
        // set the other parameters in the client interface
        //
        
        pClIfc->ObjectType = ENUM_INTERFACE_TYPE;
        pClIfc->ClIfcCtx = ClIfcCtx;
        pClIfc->CallbackThreadId = 0;

        ReferenceInit(&pClIfc->RefCount, pClIfc, DereferenceInterface);
        REFADD(&pClIfc->RefCount, 'CIFC');
        
        InitializeListHead(&pClIfc->FlowList);
    
        __try {

            InitLock(pClIfc->Lock);

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IF_DEBUG(ERRORS) {
                WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
            }

            CloseHandle(pClIfc->IfcEvent);
            FreeHandle(pClIfc->ClHandle);
            FreeMem(pClIfc);

            return Status;

        }

        SET_STATE(pClIfc->State, INSTALLING);
        pClIfc->Flags = 0; // reset flags

    } else {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

    }

    *ppClIfc = pClIfc;

    return Status;
}


DWORD
CreateKernelInterfaceStruc(
                           OUT PTC_IFC        *ppTcIfc,
                           IN  DWORD          AddressLength
                           )
{
    PTC_IFC         pTcIfc;
    DWORD           Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==> CreateKernelInterfaceStruc: AddressLength %d\n", AddressLength));
    }

    *ppTcIfc = NULL;

    AllocMem(&pTcIfc, sizeof(TC_IFC));

    if (pTcIfc) {
    
        RtlZeroMemory(pTcIfc, sizeof(TC_IFC));

        AllocMem(&pTcIfc->pAddressListDesc, AddressLength);

        if (pTcIfc->pAddressListDesc) {
        
            RtlZeroMemory(pTcIfc->pAddressListDesc, AddressLength);

            //
            // initialize the new structure
            //
            ReferenceInit(&pTcIfc->RefCount, pTcIfc, DereferenceKernelInterface);
            REFADD(&pTcIfc->RefCount, 'KIFC');
            SET_STATE(pTcIfc->State, INSTALLING);
        
            __try {

                InitLock(pTcIfc->Lock);

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
                }

                FreeMem(pTcIfc->pAddressListDesc);
                FreeMem(pTcIfc);

                return Status;

            }

            InitializeListHead(&pTcIfc->ClIfcList);
        
        } else {

            FreeMem(pTcIfc);
            Status = ERROR_NOT_ENOUGH_MEMORY;
            return Status;

        }
    
    } else {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;
        return Status;

    }

    *ppTcIfc = pTcIfc;

    IF_DEBUG(CALLS) {
        WSPRINT(("==> CreateKernelInterfaceStruc: Status%d\n", Status));
    }

    return Status;
}


DWORD
DereferenceKernelInterface(
                           PTC_IFC        pTcIfc
                           )
{
    DWORD           Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==> DereferenceKernelInterfaceStruc: %X\n", pTcIfc));
    }

    ASSERT(pTcIfc);

    ASSERT( IsListEmpty( &pTcIfc->ClIfcList ) );

    GetLock( pGlobals->Lock );
    RemoveEntryList(&pTcIfc->Linkage);
    FreeLock( pGlobals->Lock );

    DeleteLock(pTcIfc->Lock);
    FreeMem(pTcIfc->pAddressListDesc);
    FreeMem(pTcIfc);
    
    IF_DEBUG(CALLS) {
        WSPRINT(("==> DereferenceKernelInterfaceStruc: %d\n", Status));
    }

    return Status;
}


DWORD
CreateFlowStruc(
        IN  HANDLE                      ClFlowCtx,
    IN  PTC_GEN_FLOW    pGenFlow,
    OUT PFLOW_STRUC     *ppFlow
    )
{
    PFLOW_STRUC         pFlow;
    DWORD               Status = NO_ERROR;
    ULONG               l;
    PUCHAR              pCurrentObject;
    LONG                BufRemaining;

    *ppFlow = NULL;

    __try {
      
        pCurrentObject = (PUCHAR) pGenFlow->TcObjects;
        BufRemaining = pGenFlow->TcObjectsLength;

        while ((BufRemaining > 0) && (((QOS_OBJECT_HDR*)pCurrentObject)->ObjectType != QOS_OBJECT_END_OF_LIST))

        {
            BufRemaining -= ((QOS_OBJECT_HDR*)pCurrentObject)->ObjectLength;
            pCurrentObject = pCurrentObject + ((QOS_OBJECT_HDR*)pCurrentObject)->ObjectLength;
        }

        if (BufRemaining < 0)
            return (ERROR_TC_OBJECT_LENGTH_INVALID);

        l = FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + pGenFlow->TcObjectsLength;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
      
        Status = GetExceptionCode();

        IF_DEBUG(ERRORS) {
        WSPRINT(("CreateFlowStruc: Invalid pGenFlow: = 0x%X\n", 
                Status ));
        }

        return Status;
    }

    AllocMem(&pFlow, sizeof(FLOW_STRUC));

    if (pFlow != NULL) {

        RtlZeroMemory(pFlow, sizeof(FLOW_STRUC));

        //
        // acquire a new handle for the flow
        //
            
        pFlow->ClHandle = AllocateHandle((PVOID)pFlow);
        
        if (!pFlow->ClHandle) {
            FreeMem(pFlow);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Allocate memory and save the generic flow structure
        //

        AllocMem(&pFlow->pGenFlow, l);

        if (pFlow->pGenFlow == NULL) {

            FreeHandle(pFlow->ClHandle);
            FreeMem(pFlow);
            
            pFlow = NULL;

            Status = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // copy the generic flow into the new allocation
            //

            __try {

                RtlCopyMemory(pFlow->pGenFlow, pGenFlow, l);

            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = GetExceptionCode();
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateFlowStruc: Exception Error: = 0x%X\n", 
                             Status ));
                }
                
                FreeMem(pFlow->pGenFlow);
                FreeHandle(pFlow->ClHandle);
                FreeMem(pFlow);
                return Status;
            }

            //
            // set the other parameters in the flow
            //
            
            pFlow->GenFlowLen = l;
            pFlow->ObjectType = ENUM_GEN_FLOW_TYPE;
            pFlow->ClFlowCtx = ClFlowCtx;
            pFlow->Flags = 0;
            pFlow->InstanceNameLength = 0;
            ReferenceInit(&pFlow->RefCount, pFlow, DereferenceFlow);
            REFADD(&pFlow->RefCount, 'FLOW');
            pFlow->FilterCount = 0;
            InitializeListHead(&pFlow->FilterList);
            
            __try {

                InitLock(pFlow->Lock);

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
                }


                FreeHandle(pFlow->ClHandle);
                FreeMem(pFlow->pGenFlow);
                FreeMem(pFlow);

                return Status;

            }

            SET_STATE(pFlow->State, INSTALLING);
            
            //
            // Next create the event
            //

            pFlow->PendingEvent = CreateEvent(NULL,     // default attr
                                              FALSE,    // auto reset
                                              FALSE,    // init = not signaled
                                              NULL              // no name
                                              );

            if (!pFlow->PendingEvent)
            {
                // Failed to create event, get the error and free flow
                Status = GetLastError();
                
                DeleteFlowStruc(
                    pFlow );

                return Status;
            }
        }
        
    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppFlow = pFlow;

    return Status;
}



DWORD
CreateFilterStruc(
        IN      PTC_GEN_FILTER  pGenFilter,
    IN  PFLOW_STRUC             pFlow,
    OUT PFILTER_STRUC   *ppFilter
    )
{
    PFILTER_STRUC                       pFilter;
    DWORD                                       Status = NO_ERROR;
    ULONG                                       GenFilterSize;
    PTC_GEN_FILTER                      pGpcFilter;
    PUCHAR                                      p;
    ULONG                                       ProtocolId;
    ULONG                                       PatternSize;
    PIP_PATTERN                         pIpPattern;
    PTC_IFC                             pTcIfc;
    int                                         i,n;

    *ppFilter = NULL;
    pTcIfc = pFlow->pInterface->pTcIfc;

    ASSERT(pTcIfc);

    __try {

        switch (pGenFilter->AddressType) {

        case NDIS_PROTOCOL_ID_TCP_IP:
            ProtocolId = GPC_PROTOCOL_TEMPLATE_IP;
            PatternSize = sizeof(IP_PATTERN);
            break;

        default:
            return ERROR_INVALID_ADDRESS_TYPE;
        }

        if (PatternSize != pGenFilter->PatternSize ||
            pGenFilter->Pattern == NULL ||
            pGenFilter->Mask == NULL) {

            return ERROR_INVALID_PARAMETER;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
                
          Status = ERROR_INVALID_PARAMETER;
                
          IF_DEBUG(ERRORS) {
              WSPRINT(("CreateFilterStruc: Exception Error: = 0x%X\n", 
                       Status ));
          }
                
          return Status;
    }

    AllocMem(&pFilter, sizeof(FILTER_STRUC));

    if (pFilter != NULL) {

        RtlZeroMemory(pFilter, sizeof(FILTER_STRUC));

        //
        // Allocate memory and save the generic filter structure
        //

        GenFilterSize = sizeof(TC_GEN_FILTER) + 2*pGenFilter->PatternSize;
        AllocMem(&pGpcFilter, GenFilterSize);

        if (pGpcFilter == NULL) {

            FreeMem(pFilter);
            
            pFilter = NULL;

            Status = ERROR_NOT_ENOUGH_MEMORY;
            
        } else {

            //
            // copy the generic filter to local storage
            //

            pGpcFilter->AddressType = pGenFilter->AddressType;
            pGpcFilter->PatternSize = PatternSize;

            p = (PUCHAR)pGpcFilter + sizeof(TC_GEN_FILTER);

            __try {

                RtlCopyMemory(p, pGenFilter->Pattern, pGenFilter->PatternSize);

                if (pGenFilter->AddressType == NDIS_PROTOCOL_ID_TCP_IP) {
                
                    if(pTcIfc->InterfaceIndex == IF_UNKNOWN) {
                    
                        if (NO_ERROR != (Status = GetInterfaceIndex(pTcIfc->pAddressListDesc,
                                                                      &pTcIfc->InterfaceIndex,
                                                                      &pTcIfc->SpecificLinkCtx))) {
                            FreeMem(pFilter);
                            FreeMem(pGpcFilter);
                            return Status;
                        }
                    }

                    //
                    // IP pattern, set reserved fields
                    //

                    pIpPattern = (PIP_PATTERN)p;
                    pIpPattern->Reserved1 = pFlow->pInterface->pTcIfc->InterfaceIndex;
                    pIpPattern->Reserved2 = pFlow->pInterface->pTcIfc->SpecificLinkCtx;
                    pIpPattern->Reserved3[0] = pIpPattern->Reserved3[1] = pIpPattern->Reserved3[2] = 0;
                    
                }
                
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = ERROR_INVALID_PARAMETER;
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateFilterStruc: Exception Error: = 0x%X\n", 
                             Status ));
                }
                
                FreeMem(pGpcFilter);
                FreeMem(pFilter);
                
                return Status;
            }
            
            pGpcFilter->Pattern = (PVOID)p;
            
            p += pGenFilter->PatternSize;
            
            __try {
                
                RtlCopyMemory(p, pGenFilter->Mask, pGenFilter->PatternSize);
                
                if (pGenFilter->AddressType == NDIS_PROTOCOL_ID_TCP_IP) {
                    
                    //
                    // IP pattern, set reserved fields
                    //
                    
                    pIpPattern = (PIP_PATTERN)p;
                    pIpPattern->Reserved1 = pIpPattern->Reserved2 = 0xffffffff;
                    pIpPattern->Reserved3[0] = pIpPattern->Reserved3[1] = pIpPattern->Reserved3[2] = 0xff;
                    
                }
                
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                
                Status = ERROR_INVALID_PARAMETER;
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateFilterStruc: Exception Error: = 0x%X\n", 
                             Status ));
                }
                
                FreeMem(pGpcFilter);
                FreeMem(pFilter);
                
                return Status;
            }

            pGpcFilter->Mask = (PVOID)p;
            
            pFilter->pGpcFilter = pGpcFilter;

            //
            // acquire a new handle for the Filter
            //
            
            pFilter->ClHandle = AllocateHandle((PVOID)pFilter);

            // what if we're out of memory?
            if (!pFilter->ClHandle) {
                
                IF_DEBUG(ERRORS) {
                    WSPRINT(("CreateFilterStruc: Cant allocate Handle\n"));
                }

                FreeMem(pGpcFilter);
                FreeMem(pFilter);
                return ERROR_NOT_ENOUGH_MEMORY;
                
            }
            
            //
            // set the other parameters in the Filter
            //
            
            pFilter->ObjectType = ENUM_FILTER_TYPE;
            pFilter->Flags = 0;

            ReferenceInit(&pFilter->RefCount, pFilter, DereferenceFilter);
            REFADD(&pFilter->RefCount, 'FILT');

            __try {

                InitLock(pFilter->Lock);

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();

                IF_DEBUG(ERRORS) {
                    WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
                }

                FreeHandle(pFilter->ClHandle);
                FreeMem(pFilter);
                FreeMem(pGpcFilter);

                return Status;

            }

            SET_STATE(pFilter->State, INSTALLING);

            //
            // set the Gpc protocol template from the address type
            //
            
            pFilter->GpcProtocolTemplate = ProtocolId;

        }
        
    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppFilter = pFilter;

    return Status;
}



DWORD
EnumAllInterfaces(VOID)
{
    PCLIENT_STRUC                       pClient;
    DWORD                                       Status;
    WMIHANDLE                           WmiHandle;
    ULONG                                       MyBufferSize = 2 KiloBytes; // is this enough?!?
    PWNODE_ALL_DATA                     pWnode;
    PWNODE_ALL_DATA                     pWnodeBuffer;
    PTC_IFC                                     pTcIfc;

    if (_init)
        return NO_ERROR;

    //
    // get a WMI block handle to the GUID_QOS_SUPPORTED
    //

    Status = WmiOpenBlock((GUID *)&GUID_QOS_TC_SUPPORTED, 0, &WmiHandle);

    if (ERROR_FAILED(Status)) {

        if (Status == ERROR_WMI_GUID_NOT_FOUND) {

            //
            // this means there is no TC data provider
            //

            Status = NO_ERROR; //ERROR_TC_NOT_SUPPORTED
        }

        return Status;
    }

    do {

        //
        // allocate a private buffer to retrieve all wnodes
        //
        
        AllocMem(&pWnodeBuffer, MyBufferSize);
        
        if (pWnodeBuffer == NULL) {
            
            WmiCloseBlock(WmiHandle);
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        __try {

            Status = WmiQueryAllData(WmiHandle, &MyBufferSize, pWnodeBuffer);

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IF_DEBUG(ERRORS) {
                WSPRINT(("EnumAllInterfaces: Exception Error: = %X\n", 
                         Status ));
            }

        }

        if (Status == ERROR_INSUFFICIENT_BUFFER) {

            //
            // failed since the buffer was too small
            // release the buffer and double the size
            //

            MyBufferSize *= 2;
            FreeMem(pWnodeBuffer);
            pWnodeBuffer = NULL;
        }

    } while (Status == ERROR_INSUFFICIENT_BUFFER);

    if (!ERROR_FAILED(Status)) {

        ULONG   dwInstanceNum;
        ULONG   InstanceSize;
        PULONG  lpdwNameOffsets;
        BOOL    bFixedSize = FALSE;
        USHORT  usNameLength;
        ULONG   DescSize;
        PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer;

        pWnode = pWnodeBuffer;
        
        ASSERT(pWnode->WnodeHeader.Flags & WNODE_FLAG_ALL_DATA);
                
        do {

            //
            // Check for fixed instance size
            //

            if (pWnode->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE) {

                InstanceSize = pWnode->FixedInstanceSize;
                bFixedSize = TRUE;
                pTcInfoBuffer = 
                    (PTC_SUPPORTED_INFO_BUFFER)OffsetToPtr(pWnode, 
                                                           pWnode->DataBlockOffset);
            }

            //
            //  Get a pointer to the array of offsets to the instance names
            //
            
            lpdwNameOffsets = (PULONG) OffsetToPtr(pWnode, 
                                                   pWnode->OffsetInstanceNameOffsets);
            
            for ( dwInstanceNum = 0; 
                  dwInstanceNum < pWnode->InstanceCount; 
                  dwInstanceNum++) {

                usNameLength = 
                    *(USHORT *)OffsetToPtr(pWnode, 
                                           lpdwNameOffsets[dwInstanceNum]);
                    
                //
                //  Length and offset for variable data
                //
                
                if ( !bFixedSize ) {
                    
                    InstanceSize = 
                        pWnode->OffsetInstanceDataAndLength[dwInstanceNum].LengthInstanceData;
                    
                    pTcInfoBuffer = 
                        (PTC_SUPPORTED_INFO_BUFFER)OffsetToPtr(
                                           (PBYTE)pWnode,
                                           pWnode->OffsetInstanceDataAndLength[dwInstanceNum].OffsetInstanceData);
                }
                
                //
                // we have all that is needed. we need to figure if 
                // there is enough buffer space to put the data as well
                //
                
                ASSERT(usNameLength < MAX_STRING_LENGTH);

                DescSize = InstanceSize - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

                //
                // Allocate a new interface descriptor structure
                //
                
                CreateKernelInterfaceStruc(&pTcIfc, DescSize);

                if (pTcIfc != NULL) {
                     
                    //
                    // copy the instance name string data
                    //

                    RtlCopyMemory(pTcIfc->InstanceName,
                                  OffsetToPtr(pWnode,
                                              lpdwNameOffsets[dwInstanceNum]+2),
                                  usNameLength );
                    pTcIfc->InstanceNameLength = usNameLength;
                    pTcIfc->InstanceName[usNameLength/sizeof(WCHAR)] = 
                        (WCHAR)0;

                    //
                    // copy the instance ID string data
                    //

                    RtlCopyMemory(pTcIfc->InstanceID,
                                  &pTcInfoBuffer->InstanceID[0],
                                  pTcInfoBuffer->InstanceIDLength );
                    pTcIfc->InstanceIDLength = pTcInfoBuffer->InstanceIDLength;
                    pTcIfc->InstanceID[pTcInfoBuffer->InstanceIDLength/sizeof(WCHAR)] = 
                        (WCHAR)0;

                    //
                    // copy the instance data
                    // in this case - the network address
                    //
                    
                    pTcIfc->AddrListBytesCount = DescSize;

                    //
                    // a sizeof(ULONG) since the structure is defined as ARRAY
                    // and the first ULONG is the number of elements
                    //

                    RtlCopyMemory( pTcIfc->pAddressListDesc,
                                   &pTcInfoBuffer->AddrListDesc,
                                   DescSize );

                    if (NO_ERROR != GetInterfaceIndex(pTcIfc->pAddressListDesc,
                                                      &pTcIfc->InterfaceIndex,
                                                      &pTcIfc->SpecificLinkCtx)) {
                        pTcIfc->InterfaceIndex  = IF_UNKNOWN;
                        pTcIfc->SpecificLinkCtx = IF_UNKNOWN;

                    }

                    // set the state to open
                    GetLock(pTcIfc->Lock);
                    SET_STATE(pTcIfc->State, OPEN);
                    FreeLock(pTcIfc->Lock);

                    //
                    // Add the structure to the global linked list
                    //

                    GetLock( pGlobals->Lock );
                    InsertTailList(&pGlobals->TcIfcList, &pTcIfc->Linkage );
                    FreeLock( pGlobals->Lock );

#if 0
                    //
                    // make sure we have one gpc client per address type
                    //
                    
                    Status = OpenGpcClients(pTcIfc);
                    
                    if (ERROR_FAILED(Status)) {

                        break;
                    }
#endif

                } else {

                    //
                    // no more memory, quit here
                    //
                
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                
            }
            
            //
            //  Update Wnode to point to next node
            //

            if ( pWnode->WnodeHeader.Linkage != 0) {

                pWnode = (PWNODE_ALL_DATA) OffsetToPtr( pWnode, 
                                                        pWnode->WnodeHeader.Linkage);
            } else {
                
                pWnode = NULL;
            }

        } while (pWnode != NULL && !ERROR_FAILED(Status));

    }

    //
    // release resources and close WMI handle
    //

    WmiCloseBlock(WmiHandle);

    if (pWnodeBuffer)
        FreeMem(pWnodeBuffer);

    if (Status == NO_ERROR) {

        _init = TRUE;
    }

    return Status;
}



DWORD
CloseInterface(
    IN PINTERFACE_STRUC pInterface,
    BOOLEAN             RemoveFlows
    )
{
    IF_DEBUG(CALLS) {
        WSPRINT(("==>CloseInterface: pInterface=%X\n",
                 pInterface));
    }

    if (RemoveFlows) {

        CloseOpenFlows(pInterface);
    }

    REFDEL(&pInterface->RefCount, 'CIFC');

    IF_DEBUG(CALLS) {
        WSPRINT(("==>CloseInterface: NO_ERROR\n"));
    }

    return NO_ERROR;
}




DWORD
DeleteFlow(
    IN PFLOW_STRUC      pFlow,
    IN BOOLEAN          RemoveFilters
    )
{
    DWORD               Status;
    PLIST_ENTRY         pEntry;
    PFILTER_STRUC       pFilter;

    IF_DEBUG(CALLS) {
        WSPRINT(("DeleteFlow: attempting to delete flow=0x%X\n", 
                 PtrToUlong(pFlow)));
    }

    if (RemoveFilters) {

        CloseOpenFilters(pFlow);
        
    } else {

        if (/*pFlow->FilterCount > 0*/ !IsListEmpty(&pFlow->FilterList)) {
            

            IF_DEBUG(ERRORS) {
                WSPRINT(("DeleteFlow: filter list NOT empty\n"));
            }

#if DBG
        pEntry = pFlow->FilterList.Flink;
        while (pEntry != &pFlow->FilterList) {

            pFilter = CONTAINING_RECORD(pEntry, FILTER_STRUC, Linkage);
            IF_DEBUG(ERRORS) {
                WSPRINT(("<==TcDeleteFlow: Filter %x (handle %x) is open with RefCount:%d\n", pFilter, pFilter->ClHandle, pFilter->RefCount));
            }

            pEntry = pEntry->Flink;
        }
#endif 


            return ERROR_TC_SUPPORTED_OBJECTS_EXIST;
        }
    }

    //
    // can remove the flow now
    //

    Status = IoDeleteFlow( pFlow, (BOOLEAN)!RemoveFilters );

    IF_DEBUG(CALLS) {
        WSPRINT(("DeleteFlow: IoDeleteFlow returned=0x%X\n",
                 Status));
    }

    if (!ERROR_PENDING(Status)) {

        //
        // call completed, either success or failure...
        //

        CompleteDeleteFlow(pFlow, Status);
    }

    return Status;
}



DWORD
DeleteFilter(
    IN PFILTER_STRUC    pFilter
    )
{
    DWORD               Status;

    IF_DEBUG(CALLS) {
        WSPRINT(( "DeleteFilter: attempting to delete=0x%X\n",
                  PtrToUlong(pFilter)));
    }
    //
    // call to actually delete the filter
    //

    Status = IoDeleteFilter( pFilter );

    IF_DEBUG(CALLS) {
        WSPRINT(( "DeleteFilter: IoDeleteFilter returned=0x%X\n",
                  Status));
    }

    //ASSERT(Status == NO_ERROR);

    REFDEL(&pFilter->RefCount, 'FILT');

    return Status;
}



PGPC_CLIENT
FindGpcClient(
        IN  ULONG       CfInfoType
    )
{
    PGPC_CLIENT         pGpcClient = NULL;
    PLIST_ENTRY         pHead, pEntry;

    GetLock( pGlobals->Lock );

    pHead = &pGlobals->GpcClientList;
    pEntry = pHead->Flink;

    while (pHead != pEntry && pGpcClient == NULL) {

        pGpcClient = CONTAINING_RECORD(pEntry, GPC_CLIENT, Linkage);
        
        if (CfInfoType != pGpcClient->CfInfoType) {

            //
            // address type doesn't match!
            //

            pGpcClient = NULL;
        }
        
        pEntry = pEntry->Flink;
    }

    FreeLock( pGlobals->Lock );

    return pGpcClient;
}




VOID
CompleteAddFlow(
        IN      PFLOW_STRUC             pFlow,
    IN  DWORD                   Status
    )
{
    PINTERFACE_STRUC    pInterface;

    ASSERT(pFlow);
    ASSERT(!ERROR_PENDING(Status));

    IF_DEBUG(CALLS) {
        WSPRINT(("CompleteAddFlow: pFlow=0x%X Status=0x%X\n", 
                 PtrToUlong(pFlow), Status));
    }

    if(pFlow->CompletionBuffer) {

        FreeMem(pFlow->CompletionBuffer);
        pFlow->CompletionBuffer = NULL;

    }

    //
    // Check if the interface is still around.
    //
    GetLock(pFlow->Lock);
    pInterface = pFlow->pInterface;
    FreeLock(pFlow->Lock);

    if (ERROR_FAILED(Status)) {
    
        //
        // failed, release resources
        //
        CompleteDeleteFlow(pFlow, Status);
    
    } else {
    
        GetLock(pGlobals->Lock);
        GetLock(pInterface->Lock);

        if (QUERY_STATE(pInterface->State) != OPEN) {
    
            FreeLock(pInterface->Lock);
            FreeLock(pGlobals->Lock);

            IF_DEBUG(ERRORS) {
                WSPRINT(("CompleteAddFlow: Interface (%X) is NOT open pFlow=0x%X Status=0x%X\n", pInterface->ClHandle,
                         PtrToUlong(pFlow), Status));
            }

            //
            // Delete the only ref we have on this flow and get out.
            //
            REFDEL(&pFlow->RefCount, 'FLOW');

        } else {

            FreeLock(pInterface->Lock);    

            //
            // The flow is ready for business
            //
            GetLock(pFlow->Lock);
            SET_STATE(pFlow->State, OPEN);
            FreeLock(pFlow->Lock);
    
            //
            // Announce on the lists that we are ready for business
            //

            pInterface->FlowCount++;
            REFADD(&pInterface->RefCount, 'FLOW');
            InsertTailList(&pInterface->FlowList, &pFlow->Linkage);
            FreeLock(pGlobals->Lock);

        }


    
    }

    //
    // This ref was taken in TcAddFlow.
    //
    REFDEL(&pInterface->RefCount, 'TCAF');

}



VOID
CompleteModifyFlow(
        IN      PFLOW_STRUC             pFlow,
    IN  DWORD                   Status
    )
{
    ASSERT(pFlow);
    ASSERT(!ERROR_PENDING(Status));

    IF_DEBUG(CALLS) {
        WSPRINT(("CompleteModifyFlow: pFlow=0x%X Status=0x%X\n", 
                 PtrToUlong(pFlow), Status));
    }

    GetLock(pFlow->Lock);

    if(pFlow->CompletionBuffer) {

        FreeMem(pFlow->CompletionBuffer);
        pFlow->CompletionBuffer = NULL;

    }

    if (ERROR_FAILED(Status)) {

        //
        // failed, release the newly allocated generic flow parameters
        //
        
        FreeMem(pFlow->pGenFlow1);

    } else {

        //
        // modification accepted, update the generic flow parameters
        //
        
        FreeMem(pFlow->pGenFlow);
        pFlow->pGenFlow = pFlow->pGenFlow1;
        pFlow->GenFlowLen = pFlow->GenFlowLen;

    }

    //
    // clear the installing flag
    //
    
    pFlow->Flags &= ~TC_FLAGS_MODIFYING;
    pFlow->pGenFlow1 = NULL;
    pFlow->GenFlowLen1 = 0;

    FreeLock(pFlow->Lock);

    //
    // This ref was taken in TcModifyFlow
    //

    REFDEL(&pFlow->RefCount, 'TCMF');
    
    IF_DEBUG(CALLS) {
        WSPRINT(("CompleteModifyFlow: pFlow=0x%X Status=0x%X\n", 
                 PtrToUlong(pFlow), Status));
    }

}



VOID
CompleteDeleteFlow(
        IN      PFLOW_STRUC             pFlow,
    IN  DWORD                   Status
    )
{
    ASSERT(pFlow);
    //ASSERT(Status == NO_ERROR);
    //ASSERT(pFlow->CompletionBuffer);

    IF_DEBUG(CALLS) {
        WSPRINT(("CompleteDeleteFlow: pFlow=0x%X Status=0x%X\n", 
                 PtrToUlong(pFlow), Status));
    }

    //
    // okay, release resources
    //
    GetLock(pFlow->Lock);
    if (pFlow->CompletionBuffer) {
        
        FreeMem(pFlow->CompletionBuffer);
        pFlow->CompletionBuffer = NULL;
    
    }
    FreeLock(pFlow->Lock);
    
    IF_DEBUG(REFCOUNTS) { 
        WSPRINT(("#21 DEREF FLOW %X (%X) ref(%d)\n", pFlow->ClHandle, pFlow, pFlow->RefCount)); 
    }

    REFDEL(&pFlow->RefCount, 'FLOW');

}





DWORD
OpenGpcClients(
    IN  ULONG   CfInfoType
    )
{
    DWORD                               Status = NO_ERROR;
    PLIST_ENTRY                 pHead, pEntry;
    PGPC_CLIENT                 pGpcClient;
    //int                                       i;
    
    if (FindGpcClient(CfInfoType) == NULL) {
        
        //
        // create an entry in the 
        //
        
        AllocMem(&pGpcClient, sizeof(GPC_CLIENT) );
        
        if (pGpcClient == NULL) {
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pGpcClient->CfInfoType = CfInfoType;
        pGpcClient->RefCount = 1;
        
        //
        // register the gpc client
        //
        
        Status = IoRegisterClient(pGpcClient);
        
        if (ERROR_FAILED(Status)) {
            
            FreeMem(pGpcClient);

        } else {
        
            GetLock( pGlobals->Lock);
            InsertTailList(&pGlobals->GpcClientList, &pGpcClient->Linkage);
            FreeLock( pGlobals->Lock);
        }
    }
    
    return Status;
}




DWORD
DereferenceInterface(
                     IN      PINTERFACE_STRUC        pInterface
                     )
{

    DWORD   Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>DereferenceInterface: IfcH=%X RefCount=%d\n",
                 pInterface->ClHandle, pInterface->RefCount));
    }
    
    FreeHandle(pInterface->ClHandle);
    //GetLock(pGlobals->Lock);

    IF_DEBUG(REFCOUNTS) {
            
        WSPRINT(("==>DereferenceInterface: IfcH=%X Interface=%x\n",
                 pInterface->ClHandle, pInterface));

    }
    //
    // close the interface and all flows/filters
    //
    RemoveEntryList(&pInterface->Linkage);
    RemoveEntryList(&pInterface->NextIfc);

    //
    // Deregister from any guid notification requests
    //
    TcipDeleteInterfaceFromNotificationList(
                                            pInterface,
                                            0
                                            );

    //
    // #295267
    // Do not dereference Client OR decrement Interface Count until
    // the Interface is actually going away. Otherwise, the client structures
    // are cleaned out, and when the ref count finally goes down and we
    // touch this code path, we hit an AV.
    // 
    pInterface->pClient->InterfaceCount--;
    IF_DEBUG(HANDLES) {
        WSPRINT(("DEREF Client A : %x\n", pInterface->pClient->ClHandle));
    }

    REFDEL(&pInterface->pClient->RefCount, 'CIFC');
    REFDEL(&pInterface->pTcIfc->RefCount, 'CIFC');
    
    //
    // This is complex, so read carefully.
    // We want CloseInterface to wait until the event is set (292120). 
    // It is likely that in case the TcCloseInterface call didn't
    // come in, we dont have to set the Event since the TC_FLAGS_WAITING
    // will not be set in that case.
    //
    if (!IS_WAITING(pInterface->Flags)) {
            
        CloseHandle(pInterface->IfcEvent);

    } else {

        SetEvent(pInterface->IfcEvent);

    }

    //
    // free the interface resources
    //

    DeleteLock(pInterface->Lock);
    FreeMem(pInterface);
        
    //FreeLock(pGlobals->Lock);
    
    IF_DEBUG(CALLS) {
        WSPRINT(("<==DereferenceInterface: Status=%X\n", Status));
    }

    return Status;
}



DWORD
DereferenceFlow(
        IN      PFLOW_STRUC     pFlow
    )
{
    DWORD Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>DereferenceFlow: FlowH=%X Flow=%X\n",
                 pFlow->ClHandle, pFlow));
    }

    //GetLock(pGlobals->Lock);

    IF_DEBUG(REFCOUNTS) {
        WSPRINT(("==>DereferenceFlow: FlowH=%X Flow=%X\n",
                 pFlow->ClHandle, pFlow));
    }   

    FreeHandle(pFlow->ClHandle);

    GetLock(pFlow->Lock);
    if (QUERY_STATE(pFlow->State) != INSTALLING) {
            
        FreeLock(pFlow->Lock);
        RemoveEntryList(&pFlow->Linkage);
        pFlow->pInterface->FlowCount--;
            
        IF_DEBUG(HANDLES) {
            WSPRINT(("DEREF Interface A : %x\n", pFlow->pInterface->ClHandle));
        }

        REFDEL(&pFlow->pInterface->RefCount, 'FLOW');

    } else {
            
        FreeLock(pFlow->Lock);

    }

    //
    // moved here from CompleteDeleteFlow
    // 

    //
    // free the interface resources
    //

    DeleteFlowStruc(pFlow);
        
    //FreeLock(pGlobals->Lock);

    IF_DEBUG(CALLS) {
        WSPRINT(("<==DereferenceFlow: Status=%X\n", Status));
    }

    return Status;
}



DWORD
DereferenceClient(
        IN      PCLIENT_STRUC   pClient
    )
{
    //GetLock( pGlobals->Lock );

    IF_DEBUG(REFCOUNTS) {
        WSPRINT(("==>DereferenceClient: pClient=%x, Handle=%x, RefCount=%d\n",
                 pClient, pClient->ClHandle, pClient->RefCount));
    }   


    GetLock(pClient->Lock);
    SET_STATE(pClient->State, REMOVED);
    FreeLock(pClient->Lock);

    FreeHandle( pClient->ClHandle );
    RemoveEntryList( &pClient->Linkage );
    DeleteLock(pClient->Lock);
    FreeMem( pClient );

    //FreeLock( pGlobals->Lock );    
    
    return NO_ERROR;
}


DWORD
DereferenceFilter(
                  IN    PFILTER_STRUC     pFilter
                  )
{
    DWORD Status = NO_ERROR;

    IF_DEBUG(CALLS) {
        WSPRINT(("==>DereferenceFilter: FilterH=%X RefCount=%d\n",
                 pFilter->ClHandle, pFilter->RefCount));
    }

    //GetLock(pGlobals->Lock);

    IF_DEBUG(REFCOUNTS) {
        WSPRINT(("==>DereferenceFilter: FilterH=%X Filter=%X on FLOW=%X\n",
                 pFilter->ClHandle, pFilter, pFilter->pFlow));
    }   
        
    FreeHandle(pFilter->ClHandle);
        
    //
    // remove the flow from the list
    //
    GetLock(pFilter->Lock);
        
    if (QUERY_STATE(pFilter->State) != INSTALLING) {
            
        FreeLock(pFilter->Lock);
        RemoveEntryList(&pFilter->Linkage);
        pFilter->pFlow->FilterCount--;

        IF_DEBUG(REFCOUNTS) { 
            WSPRINT(("#22 DEREF FLOW %X (%X) ref(%d)\n", pFilter->pFlow->ClHandle, pFilter->pFlow, pFilter->pFlow->RefCount)); 
        }

        REFDEL(&pFilter->pFlow->RefCount, 'FILT');

    } else {
            
        FreeLock(pFilter->Lock);

    }

    DeleteFilterStruc(pFilter);
        
    //FreeLock(pGlobals->Lock);

    IF_DEBUG(CALLS) {
        WSPRINT(("<==DereferenceFilter: Status=%X\n", Status));
    }

    return Status;
}



DWORD
GetInterfaceIndex(
        IN  PADDRESS_LIST_DESCRIPTOR pAddressListDesc,
    OUT  PULONG pInterfaceIndex,
    OUT PULONG pSpecificLinkCtx)
{
    PNETWORK_ADDRESS_LIST       pAddrList;
    NETWORK_ADDRESS UNALIGNED   *pAddr;
    DWORD                                       n,k;
    DWORD                                       Status = NO_ERROR;
    PMIB_IPADDRTABLE            pIpAddrTbl;
    DWORD                                       dwSize = 2 KiloBytes;
    NETWORK_ADDRESS_IP UNALIGNED *pIpNetAddr = 0;
    DWORD                                       cAddr;

    *pInterfaceIndex = 0;
    *pSpecificLinkCtx = 0;

    cAddr = pAddressListDesc->AddressList.AddressCount;
    if (cAddr == 0) {

        //
        // no address
        //

        return NO_ERROR;
    }

#if INTERFACE_ID

    AllocMem(&pIpAddrTbl, dwSize);

    if (pIpAddrTbl == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pAddr = (UNALIGNED NETWORK_ADDRESS *) &pAddressListDesc->AddressList.Address[0];
    
    for (n = 0; n < cAddr; n++) {
            
        if (pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP) {
                
            pIpNetAddr = (UNALIGNED NETWORK_ADDRESS_IP *)&pAddr->Address[0];
            break;
        }
            
        pAddr = (UNALIGNED NETWORK_ADDRESS *)(((PUCHAR)pAddr) 
                                   + pAddr->AddressLength 
                                   + FIELD_OFFSET(NETWORK_ADDRESS, Address));
    }

    if (pIpNetAddr) {

        Status = GetIpAddrTableFromStack(
                                         pIpAddrTbl,
                                         dwSize,
                                         FALSE
                                         );
        if (Status == NO_ERROR) {
            
            //
            // search for the matching IP address to IpAddr
            // in the table we got back from the stack
            //

            for (k = 0; k < pIpAddrTbl->dwNumEntries; k++) {

                if (pIpAddrTbl->table[k].dwAddr == pIpNetAddr->in_addr) {

                    //
                    // found one, get the index
                    //
                    
                    *pInterfaceIndex = pIpAddrTbl->table[k].dwIndex;
                    break;
                }
            }

            if (pAddressListDesc->MediaType == NdisMediumWan) {
        
                if (n+1 < cAddr) {

                    //
                    // there is another address that contains
                    // the remote client address
                    // this should be used as the link ID
                    //

                    pAddr = (UNALIGNED NETWORK_ADDRESS *)(((PUCHAR)pAddr) 
                                               + pAddr->AddressLength 
                                               + FIELD_OFFSET(NETWORK_ADDRESS, Address));
                    
                    if (pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP) {
                    
                        //
                        // parse the second IP address,
                        // this would be the remote IP address for dialin WAN
                        // 
                        
                        pIpNetAddr = (UNALIGNED NETWORK_ADDRESS_IP *)&pAddr->Address[0];
                        *pSpecificLinkCtx = pIpNetAddr->in_addr;
                    }
                }
            }
            
        }
        
    }

    FreeMem(pIpAddrTbl);

#endif

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\callback.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module contains the traffic control call back routines
    that are called by OS, either IO conpletion routines or WMI
    notifications.

Author:

	Ofer Bar (oferbar)		Oct 1, 1997

--*/

#include "precomp.h"

/*
Calculate the length of a unicode string with the NULL char
*/
int StringLength(TCHAR * String)
{
    const TCHAR *eos = String;

    while( *eos++ ) ;

    return( (int)(eos - String) );
}



VOID
NTAPI CbAddFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PFLOW_STRUC				pFlow = (PFLOW_STRUC)ApcContext;
    DWORD					Status;
    PGPC_ADD_CF_INFO_RES    GpcRes;

    ASSERT(pFlow);

    GpcRes = (PGPC_ADD_CF_INFO_RES)pFlow->CompletionBuffer;
    
    ASSERT(GpcRes);

    Status = MapNtStatus2WinError(IoStatusBlock->Status);
    
    if (Status == NO_ERROR) {

        Status = MapNtStatus2WinError(GpcRes->Status);
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("CbAddFlowComplete: Flow=0x%X GpcRes=0x%X IoStatus=0x%X Information=%d Status=0x%X\n", 
                 PtrToUlong(pFlow), 
                 PtrToUlong(GpcRes),
                 IoStatusBlock->Status, IoStatusBlock->Information,
                 Status));
    }

    if (Status == NO_ERROR) {

        pFlow->GpcHandle = GpcRes->GpcCfInfoHandle;
        pFlow->InstanceNameLength = GpcRes->InstanceNameLength;
        wcscpy(pFlow->InstanceName, GpcRes->InstanceName );
    }

    //
    // locate the client and notify the add flow completion
    //

    ASSERT(pFlow->pInterface->pClient->ClHandlers.ClAddFlowCompleteHandler);

    pFlow->pInterface->pClient->ClHandlers.ClAddFlowCompleteHandler(pFlow->ClFlowCtx, Status);

    //
    // complete the add flow
    //

    CompleteAddFlow(pFlow, Status);
}



VOID
NTAPI CbModifyFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PFLOW_STRUC				pFlow = (PFLOW_STRUC)ApcContext;
    DWORD					Status;
    PGPC_MODIFY_CF_INFO_RES GpcRes;

    ASSERT(pFlow);

    GpcRes = (PGPC_MODIFY_CF_INFO_RES)pFlow->CompletionBuffer;
    
    // it is likely that the flow got deleted while we tried to 
    // modify it. in that case, just clean up, remove the ref 
    // and get out.
    GetLock(pFlow->Lock);

    if (QUERY_STATE(pFlow->State) != OPEN) {
    
        FreeLock(pFlow->Lock);
        
        if (pFlow->CompletionBuffer) {
            
            FreeMem(pFlow->CompletionBuffer);
            pFlow->CompletionBuffer = NULL;

        }
    
        if (pFlow->pGenFlow1) {
            FreeMem(pFlow->pGenFlow1);
            pFlow->pGenFlow1 = NULL;
        }

        // call them back.
        ASSERT(pFlow->pInterface->pClient->ClHandlers.ClModifyFlowCompleteHandler);

        pFlow->pInterface->pClient->ClHandlers.ClModifyFlowCompleteHandler(pFlow->ClFlowCtx,  ERROR_INVALID_HANDLE);

        //
        // This ref was taken in TcModifyFlow
        //

        REFDEL(&pFlow->RefCount, 'TCMF');
        return;

    }

    FreeLock(pFlow->Lock);

    ASSERT(GpcRes);

    Status = MapNtStatus2WinError(IoStatusBlock->Status);
    
    if (Status == NO_ERROR) {

        Status = MapNtStatus2WinError(GpcRes->Status);
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("CbModifyFlowComplete: Flow=0x%X GpcRes=0x%X IoStatus=0x%X Information=%d Status=0x%X\n", 
                 PtrToUlong(pFlow), 
                 PtrToUlong(GpcRes),
                 IoStatusBlock->Status, IoStatusBlock->Information,
                 Status));
    }

    //
    // locate the client and notify the modify flow completion
    //
    
    ASSERT(pFlow->pInterface->pClient->ClHandlers.ClModifyFlowCompleteHandler);
    
    pFlow->pInterface->pClient->ClHandlers.ClModifyFlowCompleteHandler(pFlow->ClFlowCtx, Status);

    //
    // complete the modify flow
    //

    CompleteModifyFlow(pFlow, Status);
}



VOID
NTAPI CbDeleteFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PFLOW_STRUC				pFlow = (PFLOW_STRUC)ApcContext;
    DWORD					Status;
    PGPC_REMOVE_CF_INFO_RES GpcRes;

    ASSERT(pFlow);

    GpcRes = (PGPC_REMOVE_CF_INFO_RES)pFlow->CompletionBuffer;
    
    ASSERT(GpcRes);

    Status = MapNtStatus2WinError(IoStatusBlock->Status);
    
    if (Status == NO_ERROR) {

        Status = MapNtStatus2WinError(GpcRes->Status);
    }

    ASSERT(Status != ERROR_SIGNAL_PENDING);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("CbDeleteFlowComplete: Flow=0x%X GpcRes=0x%X IoStatus=0x%X Information=%d Status=0x%X\n", 
                 PtrToUlong(pFlow), 
                 PtrToUlong(GpcRes),
                 IoStatusBlock->Status, IoStatusBlock->Information,
                 Status));
    }

    //
    // locate the client and notify the delete flow completion
    //

    ASSERT(pFlow->pInterface->pClient->ClHandlers.ClDeleteFlowCompleteHandler);

    pFlow->pInterface->pClient->ClHandlers.ClDeleteFlowCompleteHandler(pFlow->ClFlowCtx, Status);

    //
    // complete the Delete flow
    //

    CompleteDeleteFlow(pFlow, Status);
}



VOID
NTAPI 
CbGpcNotifyRoutine(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
{
    PGPC_NOTIFY_REQUEST_RES     GpcRes = (PGPC_NOTIFY_REQUEST_RES)ApcContext;
    PFLOW_STRUC					pFlow;
    PCLIENT_STRUC				pClient;
    PINTERFACE_STRUC			pInterface;
    HANDLE						FlowCtx;

    if (IoStatusBlock->Status == STATUS_CANCELLED) 
    {
        IF_DEBUG(IOCTLS) {
            WSPRINT(("==>CbGpcNotifyRoutine: CANCELLED\n"));
        }
        if ( GpcCancelEvent != INVALID_HANDLE_VALUE )
            SetEvent ( GpcCancelEvent );
            
        return;
    }
    
    ASSERT(GpcRes->SubCode == GPC_NOTIFY_CFINFO_CLOSED);
    
    IF_DEBUG(IOCTLS) {
        WSPRINT(("==>CbGpcNotifyRoutine: Context=%d IoStatus=0x%X Information=%d\n", 
                 ApcContext, IoStatusBlock->Status, IoStatusBlock->Information));
    }

    if (GpcRes->SubCode == GPC_NOTIFY_CFINFO_CLOSED) {

        pFlow = (PFLOW_STRUC)GpcRes->NotificationCtx;

        ASSERT(pFlow);

        pInterface = pFlow->pInterface;
        pClient = pInterface->pClient;

        //
        // since the GPC will NOT wait for confirmation about the 
        // flow deletion, we expect the user to delete each filter
        // but don't want the IOCTL to go down to the GPC,
        // therefore, we'll mark eahc filter with Delete flag.
        //

        GetLock(pGlobals->Lock);

        FlowCtx = pFlow->ClFlowCtx;
        
        //
        // The Flags need protection from flow->lock
        //
        GetLock(pFlow->Lock);
        SET_STATE(pFlow->State, REMOVED);
        FreeLock(pFlow->Lock);

        DeleteFlow( pFlow, TRUE );

        FreeLock(pGlobals->Lock);

        //
        // notify the user about the flow close
        //

        pClient->ClHandlers.ClNotifyHandler(pClient->ClRegCtx,
                                            pInterface->ClIfcCtx,
                                            TC_NOTIFY_FLOW_CLOSE,
                                            ULongToPtr(GpcRes->Reason),
                                            sizeof(FlowCtx),
                                            (PVOID)&FlowCtx
                                            );
    }        
    
    //
    // finally, release this memory
    //

    FreeMem(GpcRes);

    //
    // make the next call to the GPC.
    // Ignoring errors as nothing more can be done :-(

    IoRequestNotify();

    return;
}






VOID
CbParamNotifyClient(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    )
/*
  Description:

	This is a callback routine that is called when there is a incoming
    WMI interface parameter change event notification. The WMI notification
    handler calls a helper routine to walk the wnode and passing a pointer
    to this routine. This callback routine will be called for each instance
    name identified in the wnode with the buffer and buffer size.
    The client will be called on its notification handler (given during
    client registration) to let it know about the parameter value change.

*/  
{
    PINTERFACE_STRUC	pInterface, oldInterface = NULL;
    PTC_IFC				pTcIfc;
    PLIST_ENTRY			pHead, pEntry;
    TCI_NOTIFY_HANDLER	callback;

    IF_DEBUG(CALLBACK) {
        WSPRINT(("==>CbParamNotifyClient: Context=%d, Guid=%08x-%04x-%04x iName=%S Size=%d\n", 
                 Context, pGuid->Data1, pGuid->Data2, pGuid->Data3, InstanceName, DataSize));
    }

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    pTcIfc = GetTcIfcWithRef(InstanceName, 'CALL');
        
    if (pTcIfc) {

            GetLock(pGlobals->Lock);
    
            pHead = pEntry = &pTcIfc->ClIfcList;

            pEntry = pEntry->Flink;

            while (pEntry != pHead) {
    
                pInterface =    CONTAINING_RECORD(pEntry, INTERFACE_STRUC, NextIfc);
                ASSERT(pInterface);

                GetLock(pInterface->Lock);

                if (QUERY_STATE(pInterface->State) != OPEN) {
    
                    FreeLock(pInterface->Lock);
                    pEntry = pEntry->Flink;
                    continue;

                } else {

                    FreeLock(pInterface->Lock);
                    REFADD(&pInterface->RefCount, 'CBNC');

                }

                FreeLock(pGlobals->Lock);
                
                //
                // call the client
                //
                    

                callback = pInterface->pClient->ClHandlers.ClNotifyHandler;
                    
                ASSERT(callback);
                    
                IF_DEBUG(CALLBACK) {
                    WSPRINT(("CbParamNotifyClient: Context=%d, IfcH=%d ClientH=%d ClientCtx=%d IfcCtx=%d\n", 
                             Context, pInterface->ClHandle, pInterface->pClient->ClHandle, 
                             pInterface->pClient->ClRegCtx, pInterface->ClIfcCtx));
                }
        
                //
                // 258218: call the client only if it registered for this.
                //
                if (TcipClientRegisteredForNotification(pGuid, pInterface, 0)) {
                    
                    callback(pInterface->pClient->ClRegCtx,
                             pInterface->ClIfcCtx,
                             TC_NOTIFY_PARAM_CHANGED,
                             pGuid,
                             DataSize,
                             DataBuffer
                             );
                    
                }
    
                //
                // Take the lock, so that no one's monkeying with the list
                // while we are in there.
                //
                GetLock(pGlobals->Lock);

                pEntry = pEntry->Flink;
                    
                REFDEL(&pInterface->RefCount, 'CBNC');

            }
                
            FreeLock(pGlobals->Lock);
            
            REFDEL(&pTcIfc->RefCount, 'CALL');

        }


    IF_DEBUG(CALLBACK) {
        WSPRINT(("<==CbParamNotifyClient: exit\n"));
    }
}

VOID
CbInterfaceNotifyClient(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    )
/*
  Description:

	This is a callback routine that is called when there is a incoming
    WMI interface indication event notification. The WMI notification
    handler calls a helper routine to walk the wnode and passing a pointer
    to this routine. Each registered client should be called at its
    notification handler and be passed the client context. In addition,
    if the notified interface was opened by the client, the interface
    context will also be passed in the same call. There are three kernel
    interface indications (UP, DOWN, CHANGE) which are mapped to two
    user notifications: 
    {UP,CHANGE} ==> TC_NOTIFY_IFC_CHANGE
    {DOWN} ==> TC_NOTIFY_IFC_CLOSE

    This routine first update the internal cached TcIfcList, so that
    the next TcEnumerateInterfaces will return an updated view of the
    TC kernel interfaces.

*/  
{
    DWORD				Status;
    PINTERFACE_STRUC	pInterface;
    PCLIENT_STRUC		pClient;
    TCI_NOTIFY_HANDLER	callback;
    PTC_IFC				pTcIfc;
    PGEN_LIST			pNotifyInterfaceList = NULL;
    PGEN_LIST			pNotifyClientList = NULL;
    PGEN_LIST			pItem;
    PLIST_ENTRY			pEntry, pHead, pFlowEntry, pFilterEntry;
    PFLOW_STRUC         pFlow;
    PFILTER_STRUC       pFilter;
    PGEN_LIST 			p;
    ULONG				NotificationCode = 0;
    PTC_INDICATION_BUFFER	IndicationBuffer 
        = (PTC_INDICATION_BUFFER)DataBuffer;

    if (CompareGUIDs(pGuid, &GUID_QOS_TC_INTERFACE_DOWN_INDICATION)) {
        NotificationCode = TC_NOTIFY_IFC_CLOSE;
    } else if (CompareGUIDs(pGuid, &GUID_QOS_TC_INTERFACE_UP_INDICATION)) {
        NotificationCode = TC_NOTIFY_IFC_UP;
    } else if (CompareGUIDs(pGuid, &GUID_QOS_TC_INTERFACE_CHANGE_INDICATION)) {
        NotificationCode = TC_NOTIFY_IFC_CHANGE;
    }

    ASSERT(NotificationCode != 0);
        
    //
    // update the TC interface list, this means add a new interface,
    // remove an interface or update the net addr list
    //

    if (NotificationCode != TC_NOTIFY_IFC_CLOSE) {

        //
        // don't call this in case of IFC_DOWN now.
        // we'll do it after notifying the clients
        //

        Status = UpdateTcIfcList(InstanceName,
                                 DataSize,
                                 IndicationBuffer,
                                 NotificationCode
                                 );
    } 

    //
    // find a TC interface that matches the name
    //

    pTcIfc = GetTcIfcWithRef(InstanceName, 'CALL');
    
    if (pTcIfc == NULL) {

        //
        // no interface has been opened yet, possible that the driver
        // indicated a change before the interface up
        //
        
        return;
    }

    //
    // if the Interface is going down - just mark it for now.
    // In addition, mark the whole tree of objects that it supports too
    // This includes all the filters and flows..
    if (NotificationCode == TC_NOTIFY_IFC_CLOSE) {
        
        GetLock(pTcIfc->Lock);
        SET_STATE(pTcIfc->State, KERNELCLOSED_USERCLEANUP);
        FreeLock(pTcIfc->Lock);

        GetLock(pGlobals->Lock);

        pHead = &pTcIfc->ClIfcList;
        pEntry = pHead->Flink;
    
        while (pHead != pEntry) {
    
            pInterface = CONTAINING_RECORD(pEntry, INTERFACE_STRUC, NextIfc);
            GetLock(pInterface->Lock);
            if (QUERY_STATE(pInterface->State) == OPEN) {
                
                SET_STATE(pInterface->State, FORCED_KERNELCLOSE);
                FreeLock(pInterface->Lock);
                MarkAllNodesForClosing(pInterface, FORCED_KERNELCLOSE);            

            } else {
                
                FreeLock(pInterface->Lock);
                ASSERT(IsListEmpty(&pInterface->FlowList));

            }

            pEntry = pEntry->Flink;

        }

        FreeLock(pGlobals->Lock);

    }

    //
    // Build the list of every interface that needs to be notified
    //

    GetLock(pGlobals->Lock);

    pHead = &pTcIfc->ClIfcList;
    pEntry = pHead->Flink;

    while (pHead != pEntry) {

        pInterface = CONTAINING_RECORD(pEntry, INTERFACE_STRUC, NextIfc);
        
        //
        // Lock and check for open state.
        //
        GetLock(pInterface->Lock);

        if ((QUERY_STATE(pInterface->State) != OPEN) &&
            (QUERY_STATE(pInterface->State) != FORCED_KERNELCLOSE)) {
                
            FreeLock(pInterface->Lock);
            pEntry = pEntry->Flink;

        } else {

            FreeLock(pInterface->Lock);
            
            AllocMem(&pItem, sizeof(GEN_LIST));
    
            if (pItem == NULL)
                break;
    
            //
            // add a refcount since we'll release the lock later
            //
            REFADD(&pInterface->RefCount, 'CINC');
    
            //
            // add the interface to the list head
            //
            pItem->Next = pNotifyInterfaceList;
            pItem->Ptr = (PVOID)pInterface;
            pNotifyInterfaceList = pItem;
    
            pEntry = pEntry->Flink;

        }

    }

    //
    // now build the list of clients that don't have this interface opened
    // they still need to be notified, so they will be able to update the list
    // of interfaces
    //
    
    pHead = &pGlobals->ClientList;
    pEntry = pHead->Flink;

    while (pHead != pEntry) {

        pClient = CONTAINING_RECORD(pEntry, CLIENT_STRUC, Linkage);
        
        //
        // search the client on the interface notify list
        //
        GetLock(pClient->Lock);

        if (QUERY_STATE(pClient->State) != OPEN) {

        } else {

            for (p = pNotifyInterfaceList; p != NULL; p = p->Next) {

                if (pClient == ((PINTERFACE_STRUC)p->Ptr)->pClient) {
                
                    //
                    // found!
                    //
                    break;
                }
            }

            if (p == NULL) {

                //
                // add the client to the list head
                //

                AllocMem(&pItem, sizeof(GEN_LIST));
            
                if (pItem == NULL) {

                    FreeLock(pClient->Lock);
                    break;

                }

                REFADD(&pClient->RefCount, 'CINC'); // Dont want the client to slip away.
                pItem->Next = pNotifyClientList;
                pItem->Ptr = (PVOID)pClient;
                pNotifyClientList = pItem;
            }
        }

        pEntry = pEntry->Flink;
        FreeLock(pClient->Lock);

    }

    FreeLock(pGlobals->Lock);

    //
    // now we have two separate lists of clients and interfaces we
    // need to send notifications on
    //

    //
    // start with the list of interfaces
    //

    for (p = pNotifyInterfaceList; p != NULL; ) {
        
        pInterface = (PINTERFACE_STRUC)p->Ptr;

        callback = pInterface->pClient->ClHandlers.ClNotifyHandler;

        ASSERT(callback);
        
        // we now add the thread id to avoid deadlock.
        // in the callback, an app can come back in to
        // close the interface, we dont want to block there.
        // it is set back to Zero after the callback.
        pInterface->CallbackThreadId = GetCurrentThreadId();

        // 
        // 275482 - Indicate the Interfacename instead of the 
        // the addresses (what good are addresses, asks ericeil).
        //

        callback(pInterface->pClient->ClRegCtx,
                 pInterface->ClIfcCtx,
                 NotificationCode,
                 ULongToPtr(IndicationBuffer->SubCode),
                 StringLength(InstanceName) * sizeof(WCHAR),
                 InstanceName
                 );
        
        pNotifyInterfaceList = p->Next;
        FreeMem(p);
        p = pNotifyInterfaceList;

        // reset the threadid - the callback is done.
        pInterface->CallbackThreadId = 0;

        //
        // release the previous refcount we kept across the callback
        //

        REFDEL(&pInterface->RefCount, 'CINC');

        if (NotificationCode == TC_NOTIFY_IFC_CLOSE) {

            //
            // now we can remove the interface, and all the supported flows
            // and filters
            //
            
            GetLock(pInterface->Lock);
            SET_STATE(pInterface->State, KERNELCLOSED_USERCLEANUP);
            FreeLock(pInterface->Lock);

            CloseInterface(pInterface, TRUE);
        
        }

    }

    ASSERT(pNotifyInterfaceList == NULL);

    //
    // next, scan the list of clients (didn't open this interface)
    //

    for (p = pNotifyClientList; p != NULL; ) {
        
        pClient = (PCLIENT_STRUC)p->Ptr;

        callback = pClient->ClHandlers.ClNotifyHandler;

        ASSERT(callback);

        callback(pClient->ClRegCtx,
                 NULL,
                 NotificationCode,
                 ULongToPtr(IndicationBuffer->SubCode),
                 (wcslen(InstanceName) + 1)* sizeof(WCHAR),
                 InstanceName
                 );


        //
        // Deref the ref we took to keep the client around when we 
        // made the pnotifyclientlist
        //
        REFDEL(&pClient->RefCount, 'CINC');

        //
        // free the items as we walk down the list
        //

        pNotifyClientList = p->Next;
        FreeMem(p);
        p = pNotifyClientList;

    }


    REFDEL(&pTcIfc->RefCount, 'CALL');

    ASSERT(pNotifyClientList == NULL);

    if (NotificationCode == TC_NOTIFY_IFC_CLOSE) {

        //
        // time to remove the TC interface
        //
        Status = UpdateTcIfcList(InstanceName,
                                 DataSize,
                                 IndicationBuffer,
                                 NotificationCode
                                 );
    }

}


VOID
CbWmiParamNotification(
   IN  PWNODE_HEADER 	pWnodeHdr,
   IN  ULONG 			Context
   )
/*

Description:

	This callback routine is called by WMI when there is a notification
    for the GUID previously registered. The Context parameter is the
    interface handle. If it is still valid, we call the client's 
    notification handler (if exist) and pass it the notified data.
*/
{
    WalkWnode(pWnodeHdr,
              Context,
              CbParamNotifyClient
              );
}




VOID
CbWmiInterfaceNotification(
   IN  PWNODE_HEADER pWnodeHdr,
   IN  ULONG Context
   )
/*

Description:

	This callback routine is called by WMI when there is a notification
    for the GUID_QOS_TC_INTERFACE_INDICATION. We parse the data buffer
    in the Wnode and determine which event to notify the client.
    Each client will be notified at its notification handler.

*/
{
    WalkWnode(pWnodeHdr,
              Context,
              CbInterfaceNotifyClient
              );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\dbgmem.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgmem.h

Abstract:

    This module contains memory debug function prototypes and macros.

Author:

    Jim Stewart    January 8, 1997

Revision History:

	Ofer Bar ( oferbar )     Oct 1, 1996 - Revision II changes

--*/

#ifdef  DBG
//
// define the amount of symbol info to keep per function in the stack trace.
//
#define MAX_FUNCTION_INFO_SIZE  20
typedef struct {

    DWORD_PTR   Displacement;                   // displacement into the function
    UCHAR   Buff[MAX_FUNCTION_INFO_SIZE];   // name of function on call stack


} CALLER_SYM, *PCALLER_SYM;

//
// NOTE:
// If you change the structure of MEM_TRACKER, please make sure it's size
// aligned to 8-byte boundary
//
#define NCALLERS    5
typedef struct {

    LIST_ENTRY  Linkage;
    PSZ         szFile;
    ULONG       nLine;
    ULONG       nSize;
    ULONG       ulAllocNum;
    CALLER_SYM  Callers[NCALLERS];
    ULONG       ulCheckSum;
    ULONG       ulPad;          // To make the struct aligned to 8-byte

} MEM_TRACKER, *PMEM_TRACKER;


BOOL
InitDebugMemory(
    );

VOID
DeInitDebugMemory(
    );


VOID
UpdateCheckBytes(
    IN PMEM_TRACKER TrackMem
    );

BOOL
FCheckCheckBytes(
    IN PMEM_TRACKER TrackMem
    );

BOOL
FCheckAllocatedMemory();

VOID
AddPamem(
    IN PMEM_TRACKER TrackMem
    );

VOID
RemovePamem(
    IN  PMEM_TRACKER TrackMem
    );

VOID
GetCallStack(
    IN PCALLER_SYM pdwCaller,
    IN int         cSkip,
    IN int         cFind
    );

PVOID
AllocMemory(
    IN DWORD       nSize,
    IN BOOL        Calloc,
    IN PSZ         szFileName,
    IN DWORD       nLine
    );

PVOID
ReAllocMemory(
    IN PVOID    pvOld,
    IN DWORD    nSizeNew,
    IN PSZ      szFileName,
    IN DWORD    nLine
    );

VOID
FreeMemory(
    IN PVOID    pv,
    IN PSZ      szFileName,
    IN DWORD    nLine
    );

BOOL
DumpAllocatedMemory();

BOOL
SearchAllocatedMemory(
    IN PSZ      szFile,
    IN DWORD    nLine
    );

VOID
Trace(
    IN DWORD      Severity,
    IN const CHAR *Format,
    IN ...
    );

BOOL
ControlCTermination(
    IN DWORD      ControlType
    );


#endif  // #ifdef DBG


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\dbgmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dbgmem.c

Abstract:

    This module contains memory debug routines for catching memory leaks and memory
    overwrites.

Author:

    Jim Stewart   January 8, 1997

Revision History:

--*/

#include"precomp.h"
#pragma hdrstop

#include<imagehlp.h>


#ifdef DBG


#define ulCheckByteEnd          0x9ABCDEF0
#define cbExtraBytes            (sizeof(MEM_TRACKER) + sizeof(DWORD))
#define dwStackLimit            0x00010000      //  64KB for NT


// Protect access to allocated memory chain
CRITICAL_SECTION    critsMemory;
BOOL                SymbolsInitialized = FALSE;

//
// Head of allocated memory chain
//
LIST_ENTRY MemList;

//
// The type of machine we are on - needed to figure out the call stack
//
DWORD   MachineType;
HANDLE  OurProcess;

VOID
InitSymbols(
    );



BOOL
InitDebugMemory(
    )
/*++

Description:

    This routine initializes the debug memory functionality.

Arguments:

    none

Return Value:

    BOOL - pass or fail

--*/
{
    BOOL        status;
    SYSTEM_INFO SysInfo;

    __try {

        InitializeCriticalSection(&critsMemory);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
        return FALSE;
    }

    InitializeListHead( &MemList );

    OurProcess = GetCurrentProcess();

    GetSystemInfo( &SysInfo );
    switch (SysInfo.wProcessorArchitecture) {

    default:
    case PROCESSOR_ARCHITECTURE_INTEL:
        MachineType = IMAGE_FILE_MACHINE_I386;
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        //
        // note this may not detect R10000 machines correctly
        //
        MachineType = IMAGE_FILE_MACHINE_R4000;
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        MachineType = IMAGE_FILE_MACHINE_ALPHA;
        break;

    case PROCESSOR_ARCHITECTURE_PPC:
        MachineType = IMAGE_FILE_MACHINE_POWERPC;
        break;

    }

    return( TRUE );
}

VOID
DeInitDebugMemory(
    )
/*++

Description:

    This routine deinitializes the critical section used by the dbg mem functions.

Arguments:

    none

Return Value:

    none

--*/
{
    DeleteCriticalSection(&critsMemory);
}


VOID
InitSymbols(
    )
/*++

Description:

    This routine initializes the debug memory functionality.

Arguments:

    none

Return Value:

    BOOL - pass or fail

--*/
{
    BOOL        status;

    //
    // only load the symbols if we are going to track the call stack
    //

    IF_DEBUG(MEM_CALLSTACK) {
        status = SymInitialize( OurProcess,NULL,TRUE );
    }

    SymbolsInitialized = TRUE;
}


VOID
UpdateCheckBytes(
    IN PMEM_TRACKER MemTracker
    )
/*++

Description:

    This routine adds check bytes at the end of allocatedmemory. These check bytes are used to check
    for memory overwrites. Also a check sum in the MEM_TRACKER structure is also set here.

Arguments:

    MemTracker       newly allocated memory block

Return Value:

    none

--*/
{
    *((DWORD*)(((PUCHAR)MemTracker) + MemTracker->nSize + sizeof(MEM_TRACKER))) = ulCheckByteEnd;

    MemTracker->ulCheckSum = ulCheckByteEnd +
                            PtrToUlong(MemTracker->szFile) +
                            MemTracker->nLine +
                            MemTracker->nSize +
                            PtrToUlong(MemTracker->Linkage.Blink) +
                            PtrToUlong(MemTracker->Linkage.Flink);
}


BOOL
FCheckCheckBytes(
    IN PMEM_TRACKER MemTracker
    )
/*++

Description:

    This routine checks the check sum in the MEM_TRACKER structure, called before freeing the allocated
    memory.

Arguments:

    MemTracker       memory block whose check sum needs to be validated

Return Value:

    TRUE        if check sum is correct
    FALSE       otherwise

--*/
{
    DWORD   ul;

    ul = *((DWORD*)(((PUCHAR)MemTracker)+MemTracker->nSize+sizeof(MEM_TRACKER))) +
                  PtrToUlong(MemTracker->szFile) +
                  MemTracker->nLine +
                  MemTracker->nSize +
                  PtrToUlong(MemTracker->Linkage.Blink) +
                  PtrToUlong(MemTracker->Linkage.Flink);

    if (ul != MemTracker->ulCheckSum) {

        WSPRINT(( "Memory overwrite on location 0x%08lx\n",
                  PtrToUlong(MemTracker+sizeof(MEM_TRACKER)) ));

        return FALSE;
    }

    return TRUE;
}


BOOL
FCheckAllocatedMemory()
/*++

Description:

    This routine walks the allocated memory list and checks for validity of check sum and check
    bytes.

Arguments:

    none

Return Value:

    TRUE        if all the allocated memory pass the above two checks.
    FALSE       otherwise

--*/
{
    PMEM_TRACKER    MemTracker;
    BOOL            check = TRUE;
    PLIST_ENTRY     Entry;

    IF_DEBUG(CHKSUM_ALLMEM) {

        EnterCriticalSection(&critsMemory);

        for (Entry = MemList.Flink; Entry != &MemList; Entry = Entry->Flink ) {

            MemTracker = CONTAINING_RECORD( Entry,MEM_TRACKER,Linkage );
            if (!FCheckCheckBytes(MemTracker)) {
                check = FALSE;
            }

        }

        LeaveCriticalSection(&critsMemory);

    }

    return check;
}



VOID
AddMemTracker(
    IN PMEM_TRACKER     MemTracker
    )
/*++

Description:

    Adds the supplied MEM_TRACKER at the tail of the doubly linked allocated memory list and
    set the check sum also.

Arguments:

    MemTracker   MEM_TRACKER * to be added to the list

Return Value:

    none

--*/
{
    PMEM_TRACKER    Tracker;

    ASSERT(MemTracker);


    InsertTailList( &MemList,&MemTracker->Linkage );

    UpdateCheckBytes( MemTracker );
    FCheckCheckBytes( MemTracker );

    //
    // if there are other blocks in the list then change their check sum
    // since we have just changed their Flink to point to us
    //
    if (MemTracker->Linkage.Blink != &MemList) {

        Tracker = CONTAINING_RECORD( MemTracker->Linkage.Blink,MEM_TRACKER,Linkage );
        UpdateCheckBytes( Tracker );
        FCheckCheckBytes( Tracker );
    }
}



VOID
RemoveMemTracker(
    IN  PMEM_TRACKER MemTracker
    )
/*++

Description:

    Removes the supplied MEM_TRACKER * from the list of allocated memory. Also checks
    for memory overwites and updated the check sum for the entries before and
    after the entry being removed

Arguments:

    MemTracker   MEM_TRACKER to remove from the list

Return Value:

    none

--*/
{
    ASSERT(MemTracker);

    //
    // Validate the check sum before
    // removing from the list
    //

    FCheckCheckBytes(MemTracker);

    //
    // Remove MemTracker from the list
    //

    RemoveEntryList( &MemTracker->Linkage );

    //
    // Since the check sum is based on next and
    // prev pointers, need to update the check
    // sum for prev entry
    //

    if (MemTracker->Linkage.Blink != &MemList) {
        UpdateCheckBytes((MEM_TRACKER*)MemTracker->Linkage.Blink);
        FCheckCheckBytes((MEM_TRACKER*)MemTracker->Linkage.Blink);
    }

    if (MemTracker->Linkage.Flink != &MemList) {
        UpdateCheckBytes((MEM_TRACKER*)MemTracker->Linkage.Flink);
        FCheckCheckBytes((MEM_TRACKER*)MemTracker->Linkage.Flink);
    }

}

BOOL
ReadMem(
    IN HANDLE    hProcess,
    IN ULONG_PTR BaseAddr,
    IN PVOID     Buffer,
    IN DWORD     Size,
    IN PDWORD    NumBytes )
/*++

Description:

    This is a callback routine that StackWalk uses - it just calls teh system ReadProcessMemory
    routine with this process's handle

Arguments:


Return Value:

    none

--*/

{
    BOOL    status;
    SIZE_T  RealNumBytes;

    status = ReadProcessMemory( GetCurrentProcess(),
                                (LPCVOID)BaseAddr,
                                Buffer,
                                Size,
                                &RealNumBytes );
    *NumBytes = (DWORD)RealNumBytes;

    return( status );
}


VOID
GetCallStack(
    IN PCALLER_SYM   Caller,
    IN int           Skip,
    IN int           cFind
    )
/*++

Description:

    This routine walks te stack to find the return address of caller. The number of callers
    and the number of callers on top to be skipped can be specified.

Arguments:

    pdwCaller       array of DWORD to return callers
                    return addresses
    Skip            no. of callers to skip
    cFInd           no. of callers to find

Return Value:

    none

--*/
{
    BOOL             status;
    CONTEXT          ContextRecord;
    PUCHAR           Buffer[sizeof(IMAGEHLP_SYMBOL)-1 + MAX_FUNCTION_INFO_SIZE];
    PIMAGEHLP_SYMBOL Symbol = (PIMAGEHLP_SYMBOL)Buffer;
    STACKFRAME       StackFrame;
    INT              i;
    DWORD            Count;

    memset(Caller, 0, cFind * sizeof(CALLER_SYM));

    ZeroMemory( &ContextRecord,sizeof( CONTEXT ) );
    ContextRecord.ContextFlags = CONTEXT_CONTROL;
    status = GetThreadContext( GetCurrentThread(),&ContextRecord );

    ZeroMemory( &StackFrame,sizeof(STACKFRAME) );
    StackFrame.AddrPC.Segment = 0;
    StackFrame.AddrPC.Mode = AddrModeFlat;

#ifdef _M_IX86
    StackFrame.AddrFrame.Offset = ContextRecord.Ebp;
    StackFrame.AddrFrame.Mode = AddrModeFlat;

    StackFrame.AddrStack.Offset = ContextRecord.Esp;
    StackFrame.AddrStack.Mode = AddrModeFlat;

    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Eip;
#elif defined(_M_MRX000)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Fir;
#elif defined(_M_ALPHA)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Fir;
#elif defined(_M_PPC)
    StackFrame.AddrPC.Offset = (DWORD)ContextRecord.Iar;
#endif

    Count = 0;
    for (i=0;i<cFind+Skip ;i++ ) {
        status = StackWalk( MachineType,
                            OurProcess,
                            GetCurrentThread(),
                            &StackFrame,
                            (PVOID)&ContextRecord,
                            ReadMem,
                            SymFunctionTableAccess,
                            SymGetModuleBase,
                            NULL );


        if (status && i >= Skip) {
            DWORD_PTR   Displacement;

            ZeroMemory( Symbol,sizeof(IMAGEHLP_SYMBOL)-1 + MAX_FUNCTION_INFO_SIZE );
            Symbol->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
            Symbol->Address = StackFrame.AddrPC.Offset;
            Symbol->MaxNameLength = MAX_FUNCTION_INFO_SIZE-1;
            Symbol->Flags = SYMF_OMAP_GENERATED;

            status = SymGetSymFromAddr( OurProcess,
                                        StackFrame.AddrPC.Offset,
                                        &Displacement,
                                        Symbol );

            //
            // save the name of the function and the displacement into it for later printing
            //

            if (status) {
                strcpy( Caller[Count].Buff,Symbol->Name );
                Caller[Count].Displacement = Displacement;
            }
            Count++;

        }
    }

}


PVOID
AllocMemory(
    IN DWORD    nSize,
    IN BOOL     Calloc,
    IN PSZ      szFileName,
    IN DWORD    nLine
    )
/*++

Description:

    This routine is the memory allocator (like malloc) for DBG builds. This routine allocated
    more memory than requested by the caller. In this extra space this routine save info to
    track memory leaks, overwrite, callers etc. All the info is stored in a MEM_TRACKER structure
    which preceed the buffer to be returned.

Arguments:

    nSize           size of the required buffer.
    Calloc          if true then call Calloc ( which initializes memory to zero )
    szFileName      name of the file which contains
                    the routine asking for memory.
    nLine           line number in the above file
                    which has the call to PvAlloc.

Return Value:

    address of the allocated buffer.

--*/
{
    PVOID           pvRet;
    PMEM_TRACKER    MemTracker;
    static DWORD    ulAllocs = 0;
    PUCHAR          FileName;

    if (!SymbolsInitialized){
        InitSymbols();
    }

    EnterCriticalSection(&critsMemory);
    ++ulAllocs;


    //
    // Check entire allocated memory for overwite
    //

    if ( !FCheckAllocatedMemory() ) {
        WSPRINT(("Memory Overwrite detected in AllocMemory\n" ));
        ASSERT(0);
    }

    //
    // Size of the allocated memory is always
    // a multiple of sizeof(DWORD)
    //

    nSize = ((nSize +3) /4) * 4;

    //
    // shorten file name to just be the file name and not the path too
    //

    FileName = strrchr( szFileName,'\\' );
    if (!FileName) {
        FileName = szFileName;
    } else {
        FileName++; // skip /
    }

    //
    // Allocate extra for MEM_TRACKER and guard byte at end
    //

    if (!Calloc) {
        pvRet = malloc( nSize + cbExtraBytes );
    } else {
        //
        // this routine will initialize the memory to zero
        //
        pvRet = calloc( 1,(nSize + cbExtraBytes) );
    }
    if (!pvRet) {


        IF_DEBUG(ERRORS) {
            WSPRINT(( "Memory alloc failed size=%li, %s line %li\n",
                      nSize,
                      FileName,
                      nLine ));
        }

        LeaveCriticalSection(&critsMemory);
        return NULL;
    }

    //
    // Fill in new alloc with 0xFA.
    //

    if (!Calloc) {
        memset(pvRet, 0xFA, nSize+cbExtraBytes);
    }

    //
    // Save all the debug info needed in MEM_TRACKER
    //

    MemTracker = pvRet;
    MemTracker->szFile = FileName;
    MemTracker->nLine = nLine;
    MemTracker->nSize = nSize;
    MemTracker->ulAllocNum = ulAllocs;

    //
    // only save the call stack info if it is turned on
    //

    IF_DEBUG(MEM_CALLSTACK) {
        GetCallStack( MemTracker->Callers,
                      3,
                      NCALLERS);

    }

    //
    // Add to the list
    //

    AddMemTracker(MemTracker);

    LeaveCriticalSection(&critsMemory);

    IF_DEBUG(MEMORY_ALLOC) {
        WSPRINT(( "Memory alloc (0x%08lX) size=%li, %s line %li\n",
               PtrToUlong(pvRet)+sizeof(MEM_TRACKER),
               nSize,
               FileName,
               nLine ));
    }

    //
    // Return the address following the MEM_TRACKER as
    // address of the buffer allocated.
    //

    return (PVOID)((PUCHAR)pvRet+sizeof(MEM_TRACKER));
}



PVOID
ReAllocMemory(
    IN PVOID    pvOld,
    IN DWORD    nSizeNew,
    IN PSZ      szFileName,
    IN DWORD    nLine
    )
/*++

Description:

    This routine is the DBG version of realloc memory allocator function. This routine
    works just like PvAlloc function.

Arguments:

    pvOld           address of the buffer whose size
                    needs to be changed.
    nSizeNew        new size of the required buffer.
    szFileName      name of the file which contains
                    the routine asking for memory.
    nLine           line number in the above file
                    which has the call to PvAlloc.

Return Value:

    address of the buffer with the new size.

--*/
{
    PVOID           pvRet;
    PMEM_TRACKER    MemTracker;

    //
    // Check the entire allocated memory for
    // overwrites.
    //

    if ( !FCheckAllocatedMemory() ) {
        WSPRINT(("Memory Overwrite detected in ReAllocMemory\n" ));
        ASSERT(0);
    }


    ASSERT(pvOld);

    //
    // Size of the memory allocated is always
    // a multiple of sizeof(DWORD)
    //

    nSizeNew = ((nSizeNew + 3)/4) *4;

    //
    // Extra space for MEM_TRACKER and Guard bytes
    //

    pvRet = realloc(pvOld, nSizeNew+cbExtraBytes);
    if (!pvRet) {

        IF_DEBUG(MEMORY_ALLOC) {
            WSPRINT(( "Memory realloc failed (0x%08lX) size=%li, %s line %li\n",
                     PtrToUlong(pvOld) + sizeof(MEM_TRACKER),
                     nSizeNew,
                     szFileName,
                     nLine ));
        }
    } else {

        IF_DEBUG(MEMORY_ALLOC) {
            WSPRINT(( "Memory realloc succeeded (0x%08lX) size=%li, %s line %li\n",
                     PtrToUlong(pvOld) + sizeof(MEM_TRACKER),
                     PtrToUlong(pvRet)+sizeof(MEM_TRACKER),
                     nSizeNew,
                     szFileName,
                     nLine ));
        }

        MemTracker = (PMEM_TRACKER)pvRet;

        if (nSizeNew > (DWORD)MemTracker->nSize) {

            //
            // Fill in extra alloc with 0xEA.
            //

            memset((PUCHAR)pvRet+sizeof(MEM_TRACKER)+MemTracker->nSize, 0xEA, nSizeNew - MemTracker->nSize);
        }

        MemTracker = pvRet;
        MemTracker->szFile = szFileName;
        MemTracker->nLine = nLine;
        MemTracker->nSize = nSizeNew;
    }

    //
    // Add the new buffer to the list and update check sum
    //

    AddMemTracker(MemTracker);

    LeaveCriticalSection(&critsMemory);

    if (pvRet)
    return (PVOID)((PUCHAR)pvRet+sizeof(MEM_TRACKER));
    else
    return NULL;
}


VOID
FreeMemory(
    IN PVOID    pv,
    IN PSZ      szFileName,
    IN DWORD    nLine
    )
/*++

Description:

    This is the DBG version of free function. This routine checks for memory overwrites in the
    block of memory being freed before removing from the list.

Arguments:

    pv          address of the buffer to be freed
    szFileName  name of the file from which this
                block of memory is being freed.
    nLine       line number in the above file
                which has the call to FreePvFn.

Return Value:

    none

--*/
{
    PMEM_TRACKER   MemTracker;

    ASSERT(pv);
    if (NULL == pv)
    return;

    EnterCriticalSection(&critsMemory);

    MemTracker = (PMEM_TRACKER)((PUCHAR)pv-sizeof(MEM_TRACKER));

    //
    // Check for memory overwrites
    //

    if (!FCheckCheckBytes(MemTracker)) {
        WSPRINT(( "Memory Overwrite detected when freeing memory\n" ));
        ASSERT(0);
    }

    if ( !FCheckAllocatedMemory() ){
        WSPRINT(("Memory Overwrite - detected when checking allocated mem when freeing a block\n" ));
        ASSERT(0);
    }

    IF_DEBUG(MEMORY_FREE) {
        PUCHAR  FileName;

        //
        // shorten file name to just be the file name and not the path too
        //

        FileName = strrchr( szFileName,'\\' );
        if (!FileName) {
            FileName = szFileName;
        } else {
            FileName++; // skip /
        }
        WSPRINT(( "Memory freed (0x%08lX) size=%li, %s line %li\n",
                 PtrToUlong(pv),
                 MemTracker->nSize,
                 FileName,
                 nLine ));

    }
    //
    // Remove from the list
    //

    RemoveMemTracker(MemTracker);

    //
    // Fill in freed alloc with 0xCC.
    //

    memset(MemTracker, 0xCC, MemTracker->nSize+cbExtraBytes);

    free( MemTracker );

    LeaveCriticalSection(&critsMemory);
}


BOOL
DumpAllocatedMemory()
/*++

Description:

    This routine is called during shutdown to dump out any unfreed memory blocks.

Arguments:

    none

Return Value:

    TRUE        if there are any unfreed memory blocks.
    FALSE       if all the allocated memory has been freed.

--*/
{

    BOOL         status;
    PMEM_TRACKER MemTracker;
    DWORD        ulNumBlocks = 0;
    DWORD        ulTotalMemory = 0;
    PLIST_ENTRY  Entry;

    //
    // If the head of the chain is NULL,
    // all memory has been freed.
    //

    IF_DEBUG(DUMP_MEM) {
        EnterCriticalSection(&critsMemory);

        WSPRINT(("\n\n*** Start dumping unfreed memory ***\n\n",0 ));

        for (Entry = MemList.Flink; Entry != &MemList; Entry = Entry->Flink) {
            INT  i;

            MemTracker = CONTAINING_RECORD( Entry,MEM_TRACKER,Linkage );

            ulNumBlocks++;
            ulTotalMemory += MemTracker->nSize;

            WSPRINT(( "(0x%08lX) size=%li, %s line %li alloc# 0x%lx\n",
                      PtrToUlong(MemTracker)+sizeof(MEM_TRACKER),
                      MemTracker->nSize,
                      MemTracker->szFile,
                      MemTracker->nLine,
                      MemTracker->ulAllocNum ));


            //
            // dump the call stack if that debugging is on
            //

            IF_DEBUG(MEM_CALLSTACK) {
                for (i = 0; i < NCALLERS && MemTracker->Callers[i].Buff[0] != 0; i++) {

                    WSPRINT(( "%d %s + 0x%X \n",i,MemTracker->Callers[i].Buff,MemTracker->Callers[i].Displacement ));
                }
            }

            FCheckCheckBytes( MemTracker );
        }


        if (ulNumBlocks > 0) {

            WSPRINT(( "%li blocks allocated, and %li bytes\n",
                      ulNumBlocks,
                      ulTotalMemory ));

            status = TRUE;

        } else {
            status = FALSE;
        }

        WSPRINT(( "\n\n*** Finished dumping memory ***\n\n",0 ));

        LeaveCriticalSection(&critsMemory);
    }

    return status;
}


BOOL
SearchAllocatedMemory(
    IN PSZ      szFile,
    IN DWORD    nLine
    )
/*++

Description:

    This routine dumps details about memory allocated by a given line of code in a given file.

Arguments:

    szFile      name of the file
    nLine       line number of code whose memory allocationto be displayed

Return Value:

    TRUE        if there was atleast one memory block allocated by the given line number
                in the given file.
    FALE        otherwise.

--*/
{
    PMEM_TRACKER    MemTracker;
    BOOL            fFound = FALSE;
    PLIST_ENTRY     Entry;

    EnterCriticalSection(&critsMemory);

    WSPRINT(( "Searching memory\n", 0 ));

    for (Entry = MemList.Flink; Entry != &MemList; Entry = Entry->Flink ) {

        MemTracker = CONTAINING_RECORD( Entry,MEM_TRACKER,Linkage );

        //
        // Look for a match on filename and line number
        //

        if ( strcmp(MemTracker->szFile, szFile) == 0 &&  MemTracker->nLine == nLine ) {

            ASSERT(FALSE);
            WSPRINT(( "(0x%08lX) size=%li, %s line %li alloc# 0x%lx\n",
                     PtrToUlong(MemTracker)+sizeof(MEM_TRACKER),
                     MemTracker->nSize,
                     MemTracker->szFile,
                     MemTracker->nLine,
                     MemTracker->ulAllocNum));
            fFound = TRUE;
            break;
        }
    }

    LeaveCriticalSection(&critsMemory);

    WSPRINT(( "Finished searching memory\n",0 ));

    return fFound;
}



#endif      // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\handfact.c ===
/*
 *  handfact.c
 *
 *  author:	John R. Douceur
 *  date:	26 January 1998
 *
 *  This source file provides functions that implement assignment, release, and
 *  dereferencing operations with a handle_factory.  The code is object-oriented
 *  C, transliterated from a C++ implementation.
 *
 *  The handle factory is a component that generates and validates handles.  It
 *  is intended to be used in a software module that provides client software
 *  modules with means to refer to information structures contained within the
 *  provider.  While such a means could simply be a pointer, this would not
 *  enable the deletion of the information structures without explicitly
 *  notifying the clients of such deletion.  Unlike pointers, the handles
 *  generated by the handle factory can be examined (by the handle factory)
 *  to determine their validity.
 *
 *  Handles can be invalidated in one of two ways.  The handle can be released
 *  by calling the release_HF_handle() function, indicating to the handle
 *  factory that the handle is no longer necessary and that future requests
 *  to dereference this handle should be met with a null pointer.  Alternately,
 *  the handle can be revoked by the handle factory; this will happen unter two
 *  circumstances.  If a large number of handles (more than four billion) are
 *  issued and subsequently released, it becomes necessary to reuse portions of
 *  the handle space for future assignments; under these circumstances, very
 *  old handles will be revoked well before this recycling occurs, to give the
 *  holders of those handles ample opportunity to notice that their handles
 *  have become invalid and to request new handles.  The other situation in
 *  which revokation can occur is if the amount of available memory becomes
 *  too small to allocate additional space to expand the handle database; then,
 *  if the assignment of a new handle is requested, the least-recently-assigned
 *  handle will be revoked to make room for the new request.
 *
 *  Use of the handle factory in a multi-threaded environment requires a lock.
 *  This lock must be taken by a single thread for the execution of either
 *  assign_HF_handle() or release_HF_handle().  Use of dereference_HF_handle()
 *  does not require taking a lock, since synchronization is handled internally
 *  through careful sequencing of read and write operations.
 *
 *  None of the code or comments in this file need to be understood by writers
 *  of client code; all explanatory information for clients is found in the
 *  associated header file, handfact.h.
 *
 */

#include "precomp.h"

/*
 *  There are a number of aspects to the handle factory that must be understood
 *  by anyone wishing to modify this code.  The description in this comment
 *  block is intended to provide a progressive overview of the handle factory.
 *
 *  The basic system comprises a table of entries.  Each assigned handle
 *  corresponds to a single, unique entry, as determined by the handle value
 *  modulo the table size.  A handle is validated by comparing the handle value
 *  to the stored handle value in the entry.  The unassigned entries are kept
 *  on a list; when an entry is released (or revoked), it is put on the tail of
 *  the list, and when an entry is needed for an assignment, it is taken from
 *  the head of the list.
 *
 *  If there are no unassigned entries in the table when a new handle is
 *  requested, a new table of twice the size is allocated, and all assigned
 *  handles are relocated to the new table.  All unassigned handles in the new
 *  table are placed on the unassigned list.
 *
 *  As handles are released, the space required for handle entries is reduced.
 *  The table can be contracted into a table of half the size if no two assigned
 *  handles will yield the same entry address.  Two handles which will yield
 *  the same entry address in a half-size table are called a pair, and the
 *  number of such pairs is tracked in the variable pair_count, which must be
 *  zero in order to contract the table.  In order to minimize the number of
 *  pairs in the table, there are actually two lists of unassigned entries.
 *  Assigning an entry from the primary list will not increase the pair count,
 *  whereas assigning an entry from the secondary list will increase the pair
 *  count.  Thus, assignments are always made from the primary list, if it is
 *  not empty.
 *
 *  Assigned handles are also kept on a list, in order of assignment.  If it
 *  becomes necessary to revoke a handle to make room for another, the oldest
 *  handle will be revoked, and it will be found at the head of this list.
 *
 */

// This macro allocates an array of HFEntry structures.  The size of the array
// is provided as an argument to the macro.
//
#define NEW_HFEntry_array(array_size) \
	((HFEntry *)malloc(array_size * sizeof(HFEntry)))

// This macro allocates an array of integers.  The size of the array is
// provided as an argument to the macro.
//
#define NEW_int_array(array_size) \
	((int *)malloc(array_size * sizeof(int)))

/*
 *  Following are prototypes for static functions that are used internally by
 *  the handle factory routines.
 *
 */

// This function doubles the size of the table in which the handles and pointers
// are stored.  It is called by assign_HF_handle() when there is insufficient
// space in the table to assign the newly requested handle.  If the expansion
// is successful, the function returns a value of 0.  If the expansion fails
// (due, for example, to an inability to allocate memory), the function returns
// a value of 1.
//
int expand_HF_table(
	HandleFactory *hfact);

// This function halves the size of the table in which the handles and pointers
// are stored.  In order to reduce the amount of space consumed by the handle
// factory, this function is called called by release_HF_handle() and
// revoke_ancient_HF_handles() when they determine that the table can and should
// be contracted.  The table can be contracted when pair_count == 0 and
// table_size > 2.  However, the table may not be contracted then, because
// hysteresis is employed both to keep the mean assignment and release times
// constant and to minimize the allocation chatter of rapidly expanding and
// contracting the table.  If the contraction is successful, the function
// returns a value of 0.  If the contraction fails, the function returns a
// value of 1.
//
int contract_HF_table(
	HandleFactory *hfact);

// This function revokes handles that are between handle_base and handle_base
// + 2 * HANDLE_RANGE_STEP - 1, inclusive.  It then increments the value of
// handle_base by HANDLE_RANGE_STEP.  Suspended handles will be revoked one
// revokation pass later than non-suspended handles.
//
void revoke_ancient_HF_handles(
	HandleFactory *hfact);

// Every entry is on one of three lists, and the heads and tails of these lists
// are maintained in the entry_list[] array.  The index of this array is given
// by the following three manifest constants.
//
#define LD_PRIMARY 0       // first list from which to select an entry to assign
#define LD_SECONDARY 1    // second list from which to select an entry to assign
#define LD_ASSIGNED 2    // list of assigned entries, in order of assignment age

// When the handle space is recycled, there is a danger of handle collisions.
// In order to substantially reduce the likelihood of these collisions, very
// old handles are revoked well before their recycling begins, to give the
// holders of these handles ample opportunity to notice that their handles
// have become invalid and to request new handles.  Thus, handles are revoked
// when they become more than MAX_HANDLE_RANGE less than the currently generated
// handles.  To reduce overhead, revokations are performed in batches of size
// determined by HANDLE_RANGE_STEP.
//
// A handle may be suspended by incrementing the handle value by
// HANDLE_RANGE_STEP.  This causes the comparison in dereference_HF_handle() to
// fail, so the handle is judged to be invalid.  To reinstate the handle, the
// handle value is decremented by HANDLE_RANGE_STEP, returning the handle to its
// original value.  A handle that is suspended will be revoked one revokation
// pass later than it would have been if it hadn't been suspended.
//
#define HANDLE_RANGE_STEP ((HFHandle)0x20000000)
#define MAX_HANDLE_RANGE ((HFHandle)0x90000000)

// To keep the mean assignment and release times constant (and, indirectly, to
// minimize the allocation chatter of rapidly expanding and contracting the
// table), the table is not necessarily contracted as soon as possible.
// Hysteresis is employed to postpone the contraction until the computational
// cost of previous expansions and contractions is distributed over a sufficient
// number of assignment or release operations to maintain a constant cost per
// operation ratio.  The cost of each expansion is equal to the overhead of
// memory allocation and deallocation plus the cost to split each entry into
// two entries.  The cost of each contraction is equal to the overhead of
// memory allocation and deallocation plus the cost to merge each pair of
// entries into one entry.  The cost of memory allocation and deallocation is
// equal to ALLOCATION_COST times the mean cost of a single split or merge
// operation.  This value was determined by empirical measurement.
//
#define ALLOCATION_COST 12

// This manifest constant is used by the expand and contract routines to request
// access to a set of table_size and entries variables.  It is subtracted from
// the appropriate sync variable.  If there are ever more than SYNC_SUBTRAHEND
// threads simultaneously invoking dereference_HF_handle{), then the
// synchronization logic will break.
//
#define SYNC_SUBTRAHEND 1000000000

// Since this is not C++, the HandleFactory structure is not self-constructing;
// therefore, the following constructor code must be called on the HandleFactory
// structure after it is allocated.  If the construction is successful, the
// function returns a value of 0.  If the construction fails (due, for example,
// to an inability to allocate memory), the function returns a value of 1.
//
int
constructHandleFactory(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;

	// The table size is initially set to 2, and it will never be smaller.
	table_size = 2;
	// Allocate space for the initial table.
	entries = NEW_HFEntry_array(table_size);
	if (entries == 0)
	{
		// Memory could not be allocated for the array of entries created by
		// the constructor.  Therefore, we return an indication of failure to
		// the client.
		return 1;
	}
	// Initially, both sets of the table_size and entries variables are set
	// equal.  They will match most of the time except during the very brief
	// moments when the table size is changed during an expansion or
	// contraction.
	hfact->table_size[0] = table_size;
	hfact->entries[0] = entries;
	hfact->table_size[1] = table_size;
	hfact->entries[1] = entries;
	// The sync variables are initialized to zero.  These variables are
	// incremented by the dereference_HF_handle() routine to request access to
	// the corresponding table_size and entries variables.  They are massively
	// decremented (by a value of SYNC_SUBTRAHEND) by the expansion and
	// contraction routines to request permission to change the corresponding
	// table_size and entries variables.  If a sync variable is positive, then
	// at least one thread using the dereference routine has access to the
	// corresponding table_size and entries variables.  If a sync variable
	// equals -SYNC_SUBTRAHEND, then the expand or contract routine has access
	// to the corresponding variables.  A zero value means no one has requested
	// access, and a negative value greater than -SYNC_SUBTRAHEND means that
	// the expand or contract routine has requested access but has to wait
	// for one or more dereference threads to finish access.
	hfact->sync[0] = 0;
	hfact->sync[1] = 0;
	// Initially, the default variable set is set to zero.  This is arbitrary;
	// it could be set to one, instead.
	hfact->varset = 0;
	hfact->handle_base = 0;                         // handles will start with 0
	hfact->population = 0;                      // no handles initially assigned
	hfact->pair_count = 0;                // since no assigned handles, no pairs
	hfact->hysteresis_debt = 0;
	// Initialize the two entries that are initially allocated.  Both are marked
	// as unassigned; the larger value (2) is put on the secondary list, and the
	// smaller value (1) on the secondary list.  Record 0 contains an initial
	// handle value of 2 instead of 0 because a handle value of 0 is reserved.
	entries[0].handle = hfact->handle_base + table_size;
	entries[0].next_handle = hfact->handle_base + table_size;
	entries[0].reference = 0;
	entries[0].next_entry = &hfact->entry_list[LD_SECONDARY];
	entries[0].prev_entry = &hfact->entry_list[LD_SECONDARY];
	entries[1].handle = hfact->handle_base + 1;
	entries[1].next_handle = hfact->handle_base + 1;
	entries[1].reference = 0;
	entries[1].next_entry = &hfact->entry_list[LD_PRIMARY];
	entries[1].prev_entry = &hfact->entry_list[LD_PRIMARY];
	// Initialize the primary list.  This list initially contains entry 1.
	hfact->entry_list[LD_PRIMARY].handle = 0;
	hfact->entry_list[LD_PRIMARY].next_handle = 0;
	hfact->entry_list[LD_PRIMARY].reference = 0;
	hfact->entry_list[LD_PRIMARY].next_entry = &entries[1];
	hfact->entry_list[LD_PRIMARY].prev_entry = &entries[1];
	// Initialize the secondary list.  This list initially contains entry 0.
	hfact->entry_list[LD_SECONDARY].handle = 0;
	hfact->entry_list[LD_SECONDARY].next_handle = 0;
	hfact->entry_list[LD_SECONDARY].reference = 0;
	hfact->entry_list[LD_SECONDARY].next_entry = &entries[0];
	hfact->entry_list[LD_SECONDARY].prev_entry = &entries[0];
	// Initialize the assigned list.  This list initially is empty.
	hfact->entry_list[LD_ASSIGNED].handle = 0;
	hfact->entry_list[LD_ASSIGNED].next_handle = 0;
	hfact->entry_list[LD_ASSIGNED].reference = 0;
	hfact->entry_list[LD_ASSIGNED].next_entry = &hfact->entry_list[LD_ASSIGNED];
	hfact->entry_list[LD_ASSIGNED].prev_entry = &hfact->entry_list[LD_ASSIGNED];
	// Reduce handle_base by HANDLE_RANGE_STEP so that suspended handles will
	// not slip through revokation.
	hfact->handle_base -= HANDLE_RANGE_STEP;
	// return an indication of success to the client.
	return 0;
}

// Since this is not C++, the HandleFactory structure is not self-destructing;
// therefore, the following destructor code must be called on the HandleFactory
// structure before it is deallocated.
//
void
destructHandleFactory(
	HandleFactory *hfact)
{
	// Free the space consumed by the table of handles.
	free(hfact->entries[hfact->varset]);
}

// This function generates a new handle value, associates the handle value with
// the provided reference pointer, and returns the handle value.  Barring
// highly unusual circumstances, this handle will remain valid until it is
// explicitly released by a call to release_HF_handle().  However, there is no
// guarantee that the handle will persist for an arbitrary duration; it may
// become necessary for the handle factory to revoke the handle under some
// circumstances, particularly when the handle becomes very old or when memory
// becomes scarce.
//
// The assign_HF_handle() function will never return a handle value of zero.
// Thus, the client program is free to use a zero handle value as an escape
// indicator, if desired.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// release_HF_handle().
//
HFHandle
assign_HF_handle(
	HandleFactory *hfact,
	void *reference)
{
	int table_size;
	int list;
	HFEntry *entry;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing
	HFHandle handle;
	HFHandle handle_range;

	table_size = hfact->table_size[hfact->varset];
	if (hfact->population >= table_size)
	{
		// All entries in the table are assigned, so it is necessary to
		// increase the table size.
		int expansion_failure = expand_HF_table(hfact);
		// Update the local value of table_size to reflect the new value.
		table_size = hfact->table_size[hfact->varset];
		if (expansion_failure)
		{
			// Expanding the table failed, presumably due to inability to
			// allocate sufficient memory.  So, instead, we revoke the least-
			// recently assigned handle.  First, remove the entry from the
			// assigned list and place it on the secondary list.
			entry = hfact->entry_list[LD_ASSIGNED].next_entry;
			entry->next_entry->prev_entry = &hfact->entry_list[LD_ASSIGNED];
			hfact->entry_list[LD_ASSIGNED].next_entry = entry->next_entry;
			entry->next_entry = &hfact->entry_list[LD_SECONDARY];
			entry->prev_entry = hfact->entry_list[LD_SECONDARY].prev_entry;
			hfact->entry_list[LD_SECONDARY].prev_entry->next_entry = entry;
			hfact->entry_list[LD_SECONDARY].prev_entry = entry;
			// Then, invalidate the handle.  The order of the operations is
			// important to correct multi-threaded operation.
			seq_entry = entry;
			seq_entry->handle = entry->next_handle;   // first invalidate handle
			seq_entry->reference = 0;                    // then clear reference
			// Decrement the pair count and population, so that when they are
			// incremented in the code below, they will have correct values.
			hfact->pair_count--;
			hfact->population--;
		}
	}
	// At this point, there is at least one available entry.  If there is any
	// entry on the primary list, it should be selected.
	list = LD_PRIMARY;
	if (hfact->entry_list[LD_PRIMARY].next_entry ==
		&hfact->entry_list[LD_PRIMARY])
	{
		// The primary list is empty, so we take from the secondary list.  By
		// definition, this will increase the pair count.
		list = LD_SECONDARY;
		hfact->pair_count++;
	}
	// Remove the entry from the head of the appropriate list and place it on
	// the assigned list.
	entry = hfact->entry_list[list].next_entry;
	handle = entry->handle;
	entry->next_entry->prev_entry = entry->prev_entry;
	entry->prev_entry->next_entry = entry->next_entry;
	entry->next_entry = &hfact->entry_list[LD_ASSIGNED];
	entry->prev_entry = hfact->entry_list[LD_ASSIGNED].prev_entry;
	hfact->entry_list[LD_ASSIGNED].prev_entry->next_entry = entry;
	hfact->entry_list[LD_ASSIGNED].prev_entry = entry;
	// Set the reference pointer to that provided as an argument.
	entry->reference = reference;
	// The next handle for this entry will be greater by the table size.  It
	// is important to set this value in this routine because unequal values of
	// handle and next_handle indicate an assigned entry.
	entry->next_handle = handle + table_size;
	if (entry->next_handle == 0)
	{
		// The handle value has wrapped around back to zero; however, zero is
		// a reserved value, so we instead set the next handle to the subsequent
		// legal value, which is the table size.
		entry->next_handle = table_size;
	}
	// The population has increased by one.
	hfact->population++;
	// We're being tricky with unsigned integer math here.  We revoke ancient
	// handles if the value of the handle we are currently issuing is greater
	// than the handle base by more than MAX_HANDLE_RANGE, modulo the size of
	// the handle space.  The modulo is implicit.
	handle_range = handle - hfact->handle_base;
	if (handle_range > MAX_HANDLE_RANGE)
	{
		revoke_ancient_HF_handles(hfact);
	}
	// This assignment operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// Return the newly assigned handle.
	return handle;
}

// This function releases a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned, then it is released, and the function
// returns a value of 0.  If the handle is not currently assigned, the function
// aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle().
//
int
release_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int table_size;
	HFEntry *entries;
	int entry_index;
	HFEntry *entry;
	HFEntry *other_entry;
	int list;
	HFHandle adjusted_next_handle;
	HFHandle adjusted_other_next_handle;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & table_size - 1;
	entry = &entries[entry_index];
	if ((entry->handle != handle && entry->handle != handle + HANDLE_RANGE_STEP)
		|| entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle nor to
		// the provided handle's suspension value, or the entry is unassigned.
		// In any of these cases, abort and return an error code to the client.
		return 1;
	}
	// The "other entry" is the entry that would have to be merged with the
	// indexed entry if the table size were to be contracted in half.
	other_entry = &entries[entry_index ^ table_size / 2];
	if (other_entry->handle == other_entry->next_handle)
	{
		// We're being tricky with unsigned integer math here.  Before comparing
		// the two next handles, we subtract from each the value of handle_base,
		// modulo the size of the handle space (the modulo is implicit).  This
		// allows the effective comparison of their logical acyclic values
		// rather than their actual cyclic values.
		adjusted_next_handle = entry->next_handle - hfact->handle_base;
		adjusted_other_next_handle =
			other_entry->next_handle - hfact->handle_base;
		if (adjusted_other_next_handle < adjusted_next_handle)
		{
			// The other entry is unassigned and has a smaller handle value
			// than the indexed entry.  Thus, the other entry should be moved
			// from the secondary list to the primary list, and the indexed
			// entry should be placed on the secondary list.
			other_entry->next_entry->prev_entry = other_entry->prev_entry;
			other_entry->prev_entry->next_entry = other_entry->next_entry;
			other_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
			other_entry->prev_entry = hfact->entry_list[LD_PRIMARY].prev_entry;
			hfact->entry_list[LD_PRIMARY].prev_entry->next_entry = other_entry;
			hfact->entry_list[LD_PRIMARY].prev_entry = other_entry;
			list = LD_SECONDARY;
		}
		else
		{
			// The other entry is unassigned and has a larger handle value
			// than the indexed entry.  Thus, the indexed entry should be
			// placed on the secondary list.
			list = LD_PRIMARY;
		}
	}
	else
	{
		// The other entry is assigned.  Thus, the indexed entry should be
		// placed on the secondary list.  Also, since the two entries were
		// both assigned, they formed a pair.  Since we are releasing one of
		// them, the pair count drops by one.
		list = LD_SECONDARY;
		hfact->pair_count--;
	}
	// Remove the entry from the assigned list and place it on the
	// appropriate list.
	entry->next_entry->prev_entry = entry->prev_entry;
	entry->prev_entry->next_entry = entry->next_entry;
	entry->next_entry = &hfact->entry_list[list];
	entry->prev_entry = hfact->entry_list[list].prev_entry;
	hfact->entry_list[list].prev_entry->next_entry = entry;
	hfact->entry_list[list].prev_entry = entry;
	// Invalidate the handle.  The order of the operations is important to
	// correct multi-threaded operation.
	seq_entry = entry;
	seq_entry->handle = entry->next_handle;           // first invalidate handle
	seq_entry->reference = 0;                            // then clear reference
	// The population has decreased by one.
	hfact->population--;
	// This release operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// To contract the table, there must be no pairs, because otherwise two
	// assigned handles would yield the same entry index and thereby conflict.
	// Furthermore, the table size must be greater than 2, because much of the
	// handle factory code assumes that the table is at least of size 2.  In
	// addition to these strict requirements, hysteresis is employed both to
	// keep the mean assignment and release times constant and to minimize the
	// allocation chatter of rapidly expanding and contracting the table.  Only
	// if the hysteresis debt is zero will the table be contracted.
	if (hfact->pair_count == 0 && table_size > 2 &&
		hfact->hysteresis_debt == 0)
	{
		contract_HF_table(hfact);
		// Note that we ignore the return code.  If the contraction is
		// unsuccessful, we just continue as usual.  There is no real harm in
		// not contracting the table, except that we consume more space than
		// necessary.
	}
	// return an indication of success to the client.
	return 0;
}

// This function suspends a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle, unless and until
// reinstate_HF_handle() is called on the handle value.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned and not suspended, then it is suspended,
// and the function returns a value of 0.  If the handle is not currently
// assigned or has already been suspended, the function aborts and returns a
// value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and reinstate_HF_handle().
//
int
suspend_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int table_size;
	HFEntry *entries;
	int entry_index;
	HFEntry *entry;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & table_size - 1;
	entry = &entries[entry_index];
	if (entry->handle != handle || entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle, or
		// the entry is unassigned.  In either case, abort and return an error
		// code to the client.
		return 1;
	}
	// Suspend the handle.
	entry->handle += HANDLE_RANGE_STEP;
	// This suspension operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// return an indication of success to the client.
	return 0;
}

// This function reinstates a suspended handle, indicating that further attempts
// to dereference the handle should result in the pointer value that was
// originally assigned to the handle, rather than the null pointer value to
// which a suspended handle dereferences.  The handle factory checks the
// validity of the handle and returns a corresponding status code. If the handle
// is currently assigned and suspended, then it is reinstated, and the function
// returns a value of 0.  If the handle is not currently assigned or is not
// suspended, the function aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and suspend_HF_handle().
//
int
reinstate_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	int table_size;
	HFEntry *entries;
	int entry_index;
	HFEntry *entry;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & table_size - 1;
	entry = &entries[entry_index];
	if (entry->handle != handle + HANDLE_RANGE_STEP ||
		entry->handle == entry->next_handle)
	{
		// Either the indexed entry does not refer to the provided handle's
		// suspension value, or the entry is unassigned.  In either case, abort
		// and return an error code to the client.
		return 1;
	}
	// Reinstate the handle.
	entry->handle -= HANDLE_RANGE_STEP;
	// This reinstatement operation decreases the hysteresis debt.
	if (hfact->hysteresis_debt > 0)
	{
		hfact->hysteresis_debt--;
	}
	// return an indication of success to the client.
	return 0;
}

// This function validates a handle and returns either the associated pointer
// (if the handle is valid) or a null pointer value (if the handle is invalid).
// If the handle has not been released but a null value is returned, then the
// handle has been revoked by the handle factory.  This is expected to be a
// highly unusual occurrence; however, since it can happen, any program that
// employs the handle factory must have some auxiliary mechanism for retrieving
// the desired pointer information.  Once the pointer is retrieved through this
// (presumably expensive) auxiliary means, a new handle can be reassigned to
// the pointer by another call to assign_HF_handle().
//
// Even in a multi-threaded environment, it is not necessary to take a lock
// prior to calling this function.  Careful sequencing of read and write
// operations inside the handle factory code obviates the need to explicitly
// lock the data structure for dereferencing handles.
//
void *
dereference_HF_handle(
	HandleFactory *hfact,
	HFHandle handle)
{
	HFHandle entry_handle;
	void *reference;
	int entry_index;
	volatile HFEntry *entry;                    // volatile to ensure sequencing
	LONG sync;
	int varset;
    int loopcount = 0;

	// This loop spins until one of the sync variables passes the interlocked
	// increment with a non-negative value, indicating that the corresponding
	// data values are valid.  There is a very short sequence of instructions
	// in the expand and contract routines that modifies the values of the
	// entries and table_size variables and also frees memory, and these
	// modifications are bracketed by massive interlocked changes to the
	// associated sync variables.  The loop should rarely be entered, since
	// the modification in the other routines is so short.  The loop should
	// almost never be execute more than once, because this would require two
	// invokations of expand or contract during this short function.
	//
	// Start with the default variable set.
	// If we read hfact->varset at the same instant that another thread is
	// writing it, we should get either the old value or the new value, either
	// of which will work fine in the following code.  We should never get a
	// garbage value, but just to be safe, we clear all bits other than the
	// LSB, to ensure that the value we use is valid.
	varset = hfact->varset & 1;
	// Indicate intention to access table_size and entries.
	sync = InterlockedIncrement(&hfact->sync[varset]);
    loopcount = 0;

	while (sync < 0)
	{
		// We incremented the sync variable after the expand or contract
		// routine massively decremented it, so we can not be sure that we
		// have access to the table_size and entries variables.  Thus, we
		// indicate that we are no longer interested in accessing these
		// variables.
		InterlockedDecrement(&hfact->sync[varset]);
		// Since we didn't get access to the table_size and entries variables,
		// we try accessing the other set.
		varset = 1 - varset;
		sync = InterlockedIncrement(&hfact->sync[varset]);
        loopcount++;

	}

    if (loopcount > 2) {
        OutputDebugString(TEXT("Loopcount in deref was > 2 - how bizzare!\n"));
        DEBUGBREAK();
    }
	// We incremented the sync variable before the expand or contract routine
	// massively decremented it, so we have access to the table_size and
	// entries variables.
	//
	// Compute the index of the entry by taking the handle value modulo the
	// table size.  Since the table size is a power of two, we can simply
	// subtract one to produce a mask and then conjoin the mask with the
	// handle value.
	entry_index = handle & hfact->table_size[varset] - 1;
	entry = &hfact->entries[varset][entry_index];
	// Get local copies of the reference pointer and handle value.  The order
	// of the operations is important to correct multi-threaded operation.
	reference = entry->reference;                         // first get reference
	entry_handle = entry->handle;           // then get handle to check validity
	// Indicate that we're done with table_size and entries
	InterlockedDecrement(&hfact->sync[varset]);
	if (entry_handle == handle)
	{
		// The stored handle matches the provided handle, so the latter is
		// valid.  We thus return the reference pointer.
		return reference;
	}
	else
	{
		// The stored handle does not match the provided handle, so the latter
		// is invalid.  We thus return a null pointer.
		return 0;
	}
}

#ifdef _TEST_HANDFACT

// This is a test routine that simply verifies the internal valididy of the
// handle factory's data structures.  By defining the constant _TEST_HANDFACT,
// this routine will be compiled and available to the client code.  It can be
// called at any time, unless running in a multi-threaded environment, in which
// case the caller must first take the same lock used for assign_HF_handle()
// and release_HF_handle.  If the routine returns any value other than zero,
// then the internal lists of records are in an inconsistent state.
//
int
verify_HF_lists(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;
	int entry_count[3];
	int list;
	HFEntry *entry;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	for (list = 0; list < 3; list++)
	{
		entry_count[list] = 0;
		entry = &hfact->entry_list[list];
		do
		{
			entry_count[list]++;
			if (entry->next_entry->prev_entry != entry)
			{
				return 1;
			}
			entry = entry->next_entry;
		}	while (entry != &hfact->entry_list[list]);
		entry_count[list]--;
	}
	if (entry_count[2] != hfact->population)
	{
		return 2;
	}
	if (entry_count[0] + entry_count[2] - 2 * hfact->pair_count !=
		entry_count[1])
	{
		return 3;
	}
	if (entry_count[0] + entry_count[1] + entry_count[2] != table_size)
	{
		return 4;
	}
	return 0;
}

#endif /* _TEST_HANDFACT */

// This function doubles the size of the table in which the handles and pointers
// are stored.  It is called by assign_HF_handle() when there is insufficient
// space in the table to assign the newly requested handle.  If the expansion
// is successful, the function returns a value of 0.  If the expansion fails
// (due, for example, to an inability to allocate memory), the function returns
// a value of 1.
//
int expand_HF_table(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;
	int double_size;
	HFEntry *new_entries;
	HFEntry *old_entries;
	HFEntry *old_entry;
	HFEntry *low_entry;
	HFEntry *high_entry;
	HFEntry *assigned_entry;
	HFEntry *secondary_entry;
	HFEntry *other_entry;
	HFHandle handle;
	HFHandle next_handle;
	HFHandle other_handle;
	void *reference;
	int other_entry_index;
	int index;
	int varset;
    DWORD   StartTick =0, EndTick = 0;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Expanded table is double the size of the old table.
	double_size = table_size * 2;
	// Allocate space for the expanded table.
	new_entries = NEW_HFEntry_array(double_size);
	if (new_entries == 0)
	{
		// Memory could not be allocated for the new array of entries.
		// Therefore, we return an indication of failure.
		return 1;
	}
	// Since we are doubling the table size, we will be treating one more bit
	// of each handle as a bit of the entry index.  The value of this bit
	// determines the index of the entry in the new table.  For each entry,
	// we have to determine the value of this bit and relocate the entry to
	// the indicated location.
	for (index = 0; index < table_size; index++)
	{
		old_entry = &entries[index];
		low_entry = &new_entries[index];
		high_entry = &new_entries[table_size + index];
		handle = old_entry->handle;
		next_handle = old_entry->next_handle;
		reference = old_entry->reference;
		// One of the two entries in the new table that correspond to the
		// indexed entry in the old table will have a next handle value equal
		// to the next handle value of the entry in the old table, and one will
		// have a handle value equal to the indexed entry's next handle plus
		// the old table size.
		other_handle = next_handle + table_size;
		if (other_handle == 0)
		{
			// The handle value has wrapped around back to zero; however, zero
			// is a reserved value, so we instead set the next handle to the
			// subsequent legal value, which is the new table size.
			other_handle = double_size;
		}
		if ((handle & table_size) == 0)
		{
			// The handle of the old entry has a zero in its next bit, so the
			// old entry will be located in the lower half of the new table.
			if ((next_handle & table_size) == 0)
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the lower entry
				// and the other next handle value will be the next handle
				// value for the higher entry.  The high entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->handle = other_handle;
				high_entry->next_handle = other_handle;
				low_entry->next_handle = next_handle;
			}
			else
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the higher entry
				// and the other next handle value will be the next handle
				// value for the lower entry.  The high entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->handle = next_handle;
				high_entry->next_handle = next_handle;
				low_entry->next_handle = other_handle;
			}
			// The high entry is unassigned, so set its reference to null.
			// Copy the information from the old entry to the low entry.
			// Remove the old entry from the assigned list, and replace it
			// with the low entry.
			high_entry->reference = 0;
			low_entry->handle = handle;
			low_entry->reference = reference;
			old_entry->next_entry->prev_entry = low_entry;
			old_entry->prev_entry->next_entry = low_entry;
			low_entry->next_entry = old_entry->next_entry;
			low_entry->prev_entry = old_entry->prev_entry;
		}
		else
		{
			// The handle of the old entry has a one in its next bit, so the
			// old entry will be located in the higher half of the new table.
			if ((next_handle & table_size) == 0)
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the lower entry
				// and the other next handle value will be the next handle
				// value for the higher entry.  The low entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->next_handle = other_handle;
				low_entry->handle = next_handle;
				low_entry->next_handle = next_handle;
			}
			else
			{
				// The next handle of the old entry has a zero in its next bit,
				// so this value will be the next handle for the higher entry
				// and the other next handle value will be the next handle
				// value for the lower entry.  The low entry handle is set
				// equal to its next handle because it is unassigned.
				high_entry->next_handle = next_handle;
				low_entry->handle = other_handle;
				low_entry->next_handle = other_handle;
			}
			// The low entry is unassigned, so set its reference to null.
			// Copy the information from the old entry to the high entry.
			// Remove the old entry from the assigned list, and replace it
			// with the high entry.
			low_entry->reference = 0;
			high_entry->handle = handle;
			high_entry->reference = reference;
			old_entry->next_entry->prev_entry = high_entry;
			old_entry->prev_entry->next_entry = high_entry;
			high_entry->next_entry = old_entry->next_entry;
			high_entry->prev_entry = old_entry->prev_entry;
		}
	}
	// All of the unassigned entries in the new table will be placed on the
	// secondary list.  We loop through the assigned list and place the
	// unassigned entry corresponding each assigned entry onto the secondary
	// list.  Doing the list assignment in this manner tends to approximately
	// sort the secondary list according to handle value, since the assigned
	// list is sorted according to assignment order, and this approximately
	// correlates to the handle value.
	assigned_entry = hfact->entry_list[LD_ASSIGNED].next_entry;
	secondary_entry = &hfact->entry_list[LD_SECONDARY];
	while (assigned_entry != &hfact->entry_list[LD_ASSIGNED])
	{
		other_entry_index =
			assigned_entry->handle + table_size & double_size - 1;
		other_entry = &new_entries[other_entry_index];
		secondary_entry->next_entry = other_entry;
		other_entry->prev_entry = secondary_entry;
		secondary_entry = other_entry;
		assigned_entry = assigned_entry->next_entry;
	}
	// Wrap up lists by connecting in tails.
	secondary_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entry_list[LD_SECONDARY].prev_entry = secondary_entry;
	// This expansion increases the hysteresis debt by the cost of one set of
	// allocation and deallocation operations plus the cost of splitting each
	// entry into two entries.
	hfact->hysteresis_debt += ALLOCATION_COST + table_size;
	// Save a pointer to the old entry table so that it can be deallocated.
	old_entries = entries;
	// Note that we have not modified the handle, next_handle, or reference
	// fields of any entries in the old table.  Therefore, any calls to the
	// dereference_HF_handle() routine that may have been made by other threads
	// during the above operations would have been performed successfully.
	// We are now about to increase the table size and update the entries
	// variable to point to the new table.  We do this by first updating the
	// alternate table_size and entries variables and then updating the standard
	// ones.  That way, there will always be one set that is correct, so that
	// dereferences can proceed relatively unimpeded.
	//
	// Our local varset is initialized to the non-default set.
	varset = 1 - hfact->varset;
	// Indicate that the non-default table_size and entries are becoming
	// inaccessible.
	InterlockedExchangeAdd(&hfact->sync[varset], -SYNC_SUBTRAHEND);
	// Wait until no dereferences to the non-default variables are in progress.
    StartTick = GetTickCount();

	while (hfact->sync[varset] > -SYNC_SUBTRAHEND)
	{
		// no-op or sleep
        if ((GetTickCount() - StartTick) > 300000000) {
            OutputDebugString(TEXT("Expand 1\n"));
            DEBUGBREAK();
        }
	}
	// Update non-default table_size and entries to new table.
	hfact->entries[varset] = new_entries;
	hfact->table_size[varset] = double_size;
	// Indicate that non-default table_size and entries are usable again.
	InterlockedExchangeAdd(&hfact->sync[varset], SYNC_SUBTRAHEND);
	// Make non-default table_size and entries the default set.
	hfact->varset = varset;
	// Update our local varset so it again indicates the non-default set.
	varset = 1 - varset;
	// Indicate that the non-default table_size and entries are becoming
	// inaccessible.
	InterlockedExchangeAdd(&hfact->sync[varset], -SYNC_SUBTRAHEND);
	// Wait until no dereferences to the non-default variables are in progress.
	while (hfact->sync[varset] > -SYNC_SUBTRAHEND)
	{
        
        if ((GetTickCount() - StartTick) > 300000000) {
            OutputDebugString(TEXT("Expand 2\n"));
            DEBUGBREAK();
        }
		
        // no-op or sleep
	}
	// Update non-default table_size and entries to new table.
	hfact->entries[varset] = new_entries;
	hfact->table_size[varset] = double_size;
	// Indicate that non-default table_size and entries are usable again.
	InterlockedExchangeAdd(&hfact->sync[varset], SYNC_SUBTRAHEND);
	// Deallocate the old table.
	free(old_entries);
	// Since the new table was created by expanding a half-size table, the pair
	// count must be zero.
	hfact->pair_count = 0;
	// return an indication of success.
	return 0;
}

// This function halves the size of the table in which the handles and pointers
// are stored.  In order to reduce the amount of space consumed by the handle
// factory, this function is called called by release_HF_handle() and
// revoke_ancient_HF_handles() when they determine that the table can and should
// be contracted.  The table can be contracted when pair_count == 0 and
// table_size > 2.  However, the table may not be contracted then, because
// hysteresis is employed both to keep the mean assignment and release times
// constant and to minimize the allocation chatter of rapidly expanding and
// contracting the table.  If the contraction is successful, the function
// returns a value of 0.  If the contraction fails, the function returns a
// value of 1.
//
int contract_HF_table(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;
	HFEntry *new_entries;
	HFEntry *old_entries;
	int *list;
	int half_size;
	int quarter_size;
	int index;
	HFEntry *high_entry1;
	HFEntry *high_entry0;
	HFEntry *low_entry1;
	HFEntry *low_entry0;
	HFEntry *new_entry1;
	HFEntry *new_entry0;
	HFHandle adjusted_high_next_handle1;
	HFHandle adjusted_low_next_handle1;
	HFHandle next_handle1;
	HFHandle adjusted_high_next_handle0;
	HFHandle adjusted_low_next_handle0;
	HFHandle next_handle0;
	HFHandle adjusted_new_handle0;
	HFHandle adjusted_new_handle1;
	HFEntry *entry;
	HFEntry *primary_entry;
	HFEntry *secondary_entry;
	int varset;
    DWORD   StartTick = 0;

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Contracted table is half the size of the old table.
	half_size = table_size / 2;
	quarter_size = half_size / 2;
	// Allocate space for the contracted table.
	new_entries = NEW_HFEntry_array(half_size);
	if (new_entries == 0)
	{
		// Memory could not be allocated for the new array of entries, so we
		// are ironically prevented from reducing the amount of memory that
		// the handle factory is consuming. Therefore, we return an indication
		// of failure.
		return 1;
	}
	// Allocate space for auxiliary array of list indicators
	list = NEW_int_array(half_size);
	if (list == 0)
	{
		// Memory could not be allocated for the auxiliary array, so again we
		// are ironically prevented from reducing the amount of memory that
		// the handle factory is consuming. Therefore, we return an indication
		// of failure.  First, however, we must free the memory allocated for
		// the new array of entries above.
		free(new_entries);
		return 1;
	}
	// Since we are halving the size of the table, it might seem reasonable to
	// loop through each index of the new table and merge the two corresponding
	// entries from the old table.  This is in fact what the following routine
	// does; however, it does it by looping through only half of the new indices
	// and processing two merges for each index.  It does this so that it can
	// then examine the two new entries to determine on which list to place each
	// of them.
	for (index = 0; index < quarter_size; index++)
	{
		// We're looking at four entries at once.  First we merge high_entry1
		// and low_entry1, and then we independently merge high_entry0 and
		// low_entry0.  After the two merges, we examine the results jointly.
		high_entry1 = &entries[half_size + quarter_size + index];
		high_entry0 = &entries[half_size + index];
		low_entry1 = &entries[quarter_size + index];
		low_entry0 = &entries[index];
		new_entry1 = &new_entries[quarter_size + index];
		new_entry0 = &new_entries[index];
		// When merging two entries, the next handle value for the combined
		// entry is equal to the larger next handle value of the two, minus
		// the new table size.  However, the determination of which is larger
		// must be made with respect to their logical acyclic values rather
		// than their actual cyclic values, so we subtract from each the value
		// of handle_base, modulo the size of the handle space.  The modulo is
		// implicit.
		adjusted_high_next_handle1 =
			high_entry1->next_handle - hfact->handle_base;
		adjusted_low_next_handle1 =
			low_entry1->next_handle - hfact->handle_base;
		next_handle1 = __max(adjusted_high_next_handle1,
			adjusted_low_next_handle1) + hfact->handle_base - half_size;
		// Since handle 1 is -- by definition -- in either the second or fourth
		// quarter of the table, there is no need to check for the reserved
		// value of zero.
		if (high_entry1->handle != high_entry1->next_handle)
		{
			// The high entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry1->handle = high_entry1->handle;
			new_entry1->reference = high_entry1->reference;
			high_entry1->next_entry->prev_entry = new_entry1;
			high_entry1->prev_entry->next_entry = new_entry1;
			new_entry1->next_entry = high_entry1->next_entry;
			new_entry1->prev_entry = high_entry1->prev_entry;
		}
		else if (low_entry1->handle != low_entry1->next_handle)
		{
			// The low entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry1->handle = low_entry1->handle;
			new_entry1->reference = low_entry1->reference;
			low_entry1->next_entry->prev_entry = new_entry1;
			low_entry1->prev_entry->next_entry = new_entry1;
			new_entry1->next_entry = low_entry1->next_entry;
			new_entry1->prev_entry = low_entry1->prev_entry;
		}
		else
		{
			// Neither entry is assigned, so we indicate an unassigned condition
			// in the new entry.
			new_entry1->handle = next_handle1;
			new_entry1->reference = 0;
			if (adjusted_high_next_handle1 < adjusted_low_next_handle1)
			{
				// The high entry next handle has a lesser value than the low
				// entry next handle, so the high entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				high_entry1->next_entry->prev_entry = new_entry1;
				high_entry1->prev_entry->next_entry = new_entry1;
				new_entry1->next_entry = high_entry1->next_entry;
				new_entry1->prev_entry = high_entry1->prev_entry;
			}
			else
			{
				// The low entry next handle has a lesser value than the high
				// entry next handle, so the low entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				low_entry1->next_entry->prev_entry = new_entry1;
				low_entry1->prev_entry->next_entry = new_entry1;
				new_entry1->next_entry = low_entry1->next_entry;
				new_entry1->prev_entry = low_entry1->prev_entry;
			}
		}
		// Set the next handle for the new entry.
		new_entry1->next_handle = next_handle1;
		// When merging two entries, the next handle value for the combined
		// entry is equal to the larger next handle value of the two, minus
		// the new table size.  However, the determination of which is larger
		// must be made with respect to their logical acyclic values rather
		// than their actual cyclic values, so we subtract from each the value
		// of handle_base, modulo the size of the handle space.  The modulo is
		// implicit.
		adjusted_high_next_handle0 =
			high_entry0->next_handle - hfact->handle_base;
		adjusted_low_next_handle0 =
			low_entry0->next_handle - hfact->handle_base;
		next_handle0 = __max(adjusted_high_next_handle0,
			adjusted_low_next_handle0) + hfact->handle_base - half_size;
		if (next_handle0 == 0)
		{
			// The handle value has wrapped around back to zero; however, zero
			// is a reserved value, so we instead set the next handle to the
			// subsequent legal value, which is the new table size.
			next_handle0 = half_size;
		}
		if (high_entry0->handle != high_entry0->next_handle)
		{
			// The high entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry0->handle = high_entry0->handle;
			new_entry0->reference = high_entry0->reference;
			high_entry0->next_entry->prev_entry = new_entry0;
			high_entry0->prev_entry->next_entry = new_entry0;
			new_entry0->next_entry = high_entry0->next_entry;
			new_entry0->prev_entry = high_entry0->prev_entry;
		}
		else if (low_entry0->handle != low_entry0->next_handle)
		{
			// The low entry is assigned, so we copy its handle value and
			// reference pointer.  Also, we remove it from the assigned list
			// and replace it with the new entry.
			new_entry0->handle = low_entry0->handle;
			new_entry0->reference = low_entry0->reference;
			low_entry0->next_entry->prev_entry = new_entry0;
			low_entry0->prev_entry->next_entry = new_entry0;
			new_entry0->next_entry = low_entry0->next_entry;
			new_entry0->prev_entry = low_entry0->prev_entry;
		}
		else
		{
			// Neither entry is assigned, so we indicate an unassigned condition
			// in the new entry.
			new_entry0->handle = next_handle0;
			new_entry0->reference = 0;
			if (adjusted_high_next_handle0 < adjusted_low_next_handle0)
			{
				// The high entry next handle has a lesser value than the low
				// entry next handle, so the high entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				high_entry0->next_entry->prev_entry = new_entry0;
				high_entry0->prev_entry->next_entry = new_entry0;
				new_entry0->next_entry = high_entry0->next_entry;
				new_entry0->prev_entry = high_entry0->prev_entry;
			}
			else
			{
				// The low entry next handle has a lesser value than the high
				// entry next handle, so the low entry must be on the primary
				// list.  We remove it from the primary list and replace it
				// with the new entry.
				low_entry0->next_entry->prev_entry = new_entry0;
				low_entry0->prev_entry->next_entry = new_entry0;
				new_entry0->next_entry = low_entry0->next_entry;
				new_entry0->prev_entry = low_entry0->prev_entry;
			}
		}
		// Set the next handle for the new entry.
		new_entry0->next_handle = next_handle0;
		// Now that we have merged high_entry1 and low_entry1 into new_entry1,
		// and independently merged high_entry0 and low_entry0 into new_entry0,
		// we examine the two new entries to determine on which list to place
		// each of them.  Note that we do not actually manipulate the lists in
		// this portion of the code; we merely make decisions and record these
		// decisions for the future.
		if (new_entry0->handle == new_entry0->next_handle &&
			new_entry1->handle == new_entry1->next_handle)
		{
			// Both new_entry0 and new_entry1 are unassigned, so one of them
			// belongs on the primary list and the other on the secondary list.
			// Which goes on which is determined by a comparison of their handle
			// values.  We're being tricky with unsigned integer math here.
			// Before comparing the two handles, we subtract from each the value
			// of handle_base, modulo the size of the handle space (the modulo
			// is implicit).  This allows the effective comparison of their
			// logical acyclic values rather than their actual cyclic values.
			adjusted_new_handle0 = new_entry0->handle - hfact->handle_base;
			adjusted_new_handle1 = new_entry1->handle - hfact->handle_base;
			if (adjusted_new_handle0 < adjusted_new_handle1)
			{
				// The handle value for new_entry0 is lower, so new_entry0
				// belongs on the primary list and new_entry1 on the secondary
				// list.  We indicate this decision in the list array.
				list[index] = LD_PRIMARY;
				list[quarter_size + index] = LD_SECONDARY;
			}
			else
			{
				// The handle value for new_entry1 is lower, so new_entry1
				// belongs on the primary list and new_entry0 on the secondary
				// list.  We indicate this decision in the list array.
				list[index] = LD_SECONDARY;
				list[quarter_size + index] = LD_PRIMARY;
			}
		}
		else
		{
			// Either new_entry0 or new_entry1 (or both) is assigned, and it is
			// therefore already on the assigned list.  If one of the entries
			// is not assigned, it belongs on the secondary list.  We indicate
			// this decision in both places of the list array, which is safe to
			// do since the assigned entry's list indicator will never be
			// examined.
			list[index] = LD_SECONDARY;
			list[quarter_size + index] = LD_SECONDARY;
		}
		if (new_entry0->handle != new_entry0->next_handle &&
			new_entry1->handle != new_entry1->next_handle)
		{
			// Both new_entry0 and new_entry1 are assigned, so they form a pair.
			// We thus increment the pair count.  Note that we never set the
			// pair count to zero above, but this was not necessary since the
			// table could not be contracted unless the pair count was zero.
			hfact->pair_count++;
		}
	}
	// At this point, the table has been completely contracted except for the
	// reassembly of the unassigned lists.  In the code above, any entries that
	// had previously been on the secondary list were merged with assigned
	// entries, so they are no longer relevant.  Only those entries that had
	// previously been (and are still) on the primary list will still be
	// unassigned.  We now loop through the primary list and place each list
	// element on the appropriate list, as indicated by the list array.  Doing
	// the list assignment in these two steps preserves the general order of
	// the entries, which has some value since they will tend to be partially
	// sorted.
	entry = hfact->entry_list[LD_PRIMARY].next_entry;
	primary_entry = &hfact->entry_list[LD_PRIMARY];
	secondary_entry = &hfact->entry_list[LD_SECONDARY];
	while (entry != &hfact->entry_list[LD_PRIMARY])
	{
		if (list[entry->handle & half_size - 1] == LD_PRIMARY)
		{
			// The list array indicates the primary list, so place the entry
			// onto the primary list.
			primary_entry->next_entry = entry;
			entry->prev_entry = primary_entry;
			primary_entry = entry;
		}
		else
		{
			// The list array indicates the secondary list, so place the entry
			// onto the secondary list.
			secondary_entry->next_entry = entry;
			entry->prev_entry = secondary_entry;
			secondary_entry = entry;
		}
		entry = entry->next_entry;
	}
	// Wrap up lists by connecting in tails.
	primary_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
	hfact->entry_list[LD_PRIMARY].prev_entry = primary_entry;
	secondary_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
	hfact->entry_list[LD_SECONDARY].prev_entry = secondary_entry;
	// This contraction increases the hysteresis debt by the cost of one set of
	// allocation and deallocation operations plus the cost of merging each
	// pair of entries into a single entry.
	hfact->hysteresis_debt += ALLOCATION_COST + half_size;
	// Save a pointer to the old entry table so that it can be deallocated.
	old_entries = entries;
	// Note that we have not modified the handle, next_handle, or reference
	// fields of any entries in the old table.  Therefore, any calls to the
	// dereference_HF_handle() routine that may have been made by other threads
	// during the above operations would have been performed successfully.
	// We are now about to increase the table size and update the entries
	// variable to point to the new table.  We do this by first updating the
	// alternate table_size and entries variables and then updating the standard
	// ones.  That way, there will always be one set that is correct, so that
	// dereferences can proceed relatively unimpeded.
	//
	// Our local varset is initialized to the non-default set.
	varset = 1 - hfact->varset;
	// Indicate that the non-default table_size and entries are becoming
	// inaccessible.
	InterlockedExchangeAdd(&hfact->sync[varset], -SYNC_SUBTRAHEND);
	// Wait until no dereferences to the non-default variables are in progress.
    StartTick = GetTickCount();

	while (hfact->sync[varset] > -SYNC_SUBTRAHEND)
	{
		

        if ((GetTickCount() - StartTick) > 300000000) {
            OutputDebugString(TEXT("Contract 1\n"));
            DEBUGBREAK();
        }

        // no-op or sleep
	}
	// Update non-default table_size and entries to new table.
	hfact->table_size[varset] = half_size;
	hfact->entries[varset] = new_entries;
	// Indicate that non-default table_size and entries are usable again.
	InterlockedExchangeAdd(&hfact->sync[varset], SYNC_SUBTRAHEND);
	// Make non-default table_size and entries the default set.
	hfact->varset = varset;
	// Update our local varset so it again indicates the non-default set.
	varset = 1 - varset;
	// Indicate that the non-default table_size and entries are becoming
	// inaccessible.
	InterlockedExchangeAdd(&hfact->sync[varset], -SYNC_SUBTRAHEND);
	// Wait until no dereferences to the non-default variables are in progress.
	while (hfact->sync[varset] > -SYNC_SUBTRAHEND)
	{
		// no-op or sleep
        if ((GetTickCount() - StartTick) > 300000000) {
            OutputDebugString(TEXT("Contract 2\n"));
            DEBUGBREAK();
        }
	}
	// Update non-default table_size and entries to new table.
	hfact->table_size[varset] = half_size;
	hfact->entries[varset] = new_entries;
	// Indicate that non-default table_size and entries are usable again.
	InterlockedExchangeAdd(&hfact->sync[varset], SYNC_SUBTRAHEND);
	// Deallocate the old table and the auxiliary list indicator array.
	free(old_entries);
	free(list);
	// return an indication of success.
	return 0;
}

// This function revokes handles that are between handle_base and handle_base
// + 2 * HANDLE_RANGE_STEP - 1, inclusive.  It then increments the value of
// handle_base by HANDLE_RANGE_STEP.  Suspended handles will be revoked one
// revokation pass later than non-suspended handles.
//
void revoke_ancient_HF_handles(
	HandleFactory *hfact)
{
	int table_size;
	HFEntry *entries;
	HFHandle new_handle_base;
	int half_size;
	int index;
	HFEntry *high_entry;
	HFEntry *low_entry;
	HFHandle adjusted_high_handle;
	HFHandle adjusted_low_handle;
	HFHandle adjusted_high_next_handle;
	HFHandle adjusted_low_next_handle;
	HFHandle handle;
	volatile HFEntry *seq_entry;                // volatile to ensure sequencing

	table_size = hfact->table_size[hfact->varset];
	entries = hfact->entries[hfact->varset];
	// Compute new handle base.
	new_handle_base = hfact->handle_base + HANDLE_RANGE_STEP;
	// It might seem reasonable to loop through each index of the table and
	// determine whether to revoke the handle of each entry.  This is in fact
	// what the following routine does; however, it does it by looping through
	// only half of the indices and examining two entries for each index.  It
	// does this so that it can compare the two entries to determine on which
	// list to place each of them.
	half_size = table_size / 2;
	for (index = 0; index < half_size; index++)
	{
		// We're looking at two entries at once.
		high_entry = &entries[half_size + index];
		low_entry = &entries[index];
		// We're being tricky with unsigned integer math here.  Before making
		// comparisons on either handle, we subtract from it the value of
		// handle_base, modulo the size of the handle space (the modulo is
		// implicit).  This allows the effective comparison of its logical
		// acyclic value rather than its actual cyclic value.
		adjusted_high_handle = high_entry->handle - hfact->handle_base;
		adjusted_low_handle = low_entry->handle - hfact->handle_base;
		if (adjusted_high_handle < 2 * HANDLE_RANGE_STEP ||
			adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
		{
			// At least one of the handles is less than twice HANDLE_RANGE_STEP
			// more than the current handle base, so it will need to be updated.
			// For the vast majority of cases, this test is expected to fail,
			// and so all of the following work can be skipped.
			if (high_entry->handle != high_entry->next_handle &&
				low_entry->handle != low_entry->next_handle)
			{
				// Both of the entries are assigned, so, since at least one of
				// them will be revoked, we will be losing one pair.
				hfact->pair_count--;
			}
			if (high_entry->handle == high_entry->next_handle ||
				adjusted_high_handle < 2 * HANDLE_RANGE_STEP)
			{
				// Either the high entry is unassigned or in need of revokation
				// (after which it will be unassigned), so we remove it from
				// whatever list it is on.  We do this because all unassigned
				// entries will be added to the appropriate list below.
				high_entry->next_entry->prev_entry = high_entry->prev_entry;
				high_entry->prev_entry->next_entry = high_entry->next_entry;
				// Zeroing these pointers is unnecessary, but it will help to
				// catch any mistakes made further down.
				high_entry->next_entry = 0;
				high_entry->prev_entry = 0;
			}
			if (adjusted_high_handle < 2 * HANDLE_RANGE_STEP)
			{
				// The high handle needs to be updated.
				if (high_entry->handle != high_entry->next_handle)
				{
					// The high handle is assigned, so this updating will
					// revoke the handle.  Thus, we decrement the population.
					hfact->population--;
				}
				// Compute the handle value as the maximum of (1) the next
				// handle and (2) the new handle base plus the entry index.
				// We're being tricky with unsigned integer math here.  The
				// maximum involves partial decomposition of the sums, from
				// which we then subtract the value of handle_base, modulo the
				// size of the handle space (the modulo is implicit).  Thus,
				// the maximum is taken with respect to the logical acyclic
				// values rather than the actual cyclic values.
				adjusted_high_next_handle =
					high_entry->next_handle - hfact->handle_base;
				handle = __max(adjusted_high_next_handle,
					HANDLE_RANGE_STEP + half_size + index) + hfact->handle_base;
				// Since the high handle is -- by definition -- in the upper
				// half of the table, there is no need to check for the reserved
				// value of zero.
				// Update the handle value.  Since this updating will invalidate
				// the handle if it is currently assigned, the order of the
				// operations is important to correct multi-threaded operation.
				seq_entry = high_entry;
				seq_entry->next_handle = handle;
				seq_entry->handle = handle;           // first invalidate handle
				seq_entry->reference = 0;                // then clear reference
			}
			if (low_entry->handle == low_entry->next_handle ||
				adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
			{
				// Either the low entry is unassigned or in need of revokation
				// (after which it will be unassigned), so we remove it from
				// whatever list it is on.  We do this because all unassigned
				// entries will be added to the appropriate list below.
				low_entry->next_entry->prev_entry = low_entry->prev_entry;
				low_entry->prev_entry->next_entry = low_entry->next_entry;
				// Zeroing these pointers is unnecessary, but it will help to
				// catch any mistakes made further down.
				low_entry->next_entry = 0;
				low_entry->prev_entry = 0;
			}
			if (adjusted_low_handle < 2 * HANDLE_RANGE_STEP)
			{
				// The low handle needs to be updated.
				if (low_entry->handle != low_entry->next_handle)
				{
					// The low handle is assigned, so this updating will
					// revoke the handle.  Thus, we decrement the population.
					hfact->population--;
				}
				// Compute the handle value as the maximum of (1) the next
				// handle and (2) the new handle base plus the entry index.
				// We're being tricky with unsigned integer math here.  The
				// maximum involves partial decomposition of the sums, from
				// which we then subtract the value of handle_base, modulo the
				// size of the handle space (the modulo is implicit).  Thus,
				// the maximum is taken with respect to the logical acyclic
				// values rather than the actual cyclic values.
				adjusted_low_next_handle =
					low_entry->next_handle - hfact->handle_base;
				handle = __max(adjusted_low_next_handle,
					HANDLE_RANGE_STEP + index) + hfact->handle_base;
				if (handle == 0)
				{
					// The handle value has wrapped around back to zero;
					// however, zero is a reserved value, so we instead set the
					// handle to the subsequent legal value, which is the table
					// size.
					handle = table_size;
				}
				// Update the handle value.  Since this updating will invalidate
				// the handle if it is currently assigned, the order of the
				// operations is important to correct multi-threaded operation.
				seq_entry = low_entry;
				seq_entry->next_handle = handle;
				seq_entry->handle = handle;           // first invalidate handle
				seq_entry->reference = 0;                // then clear reference
			}
			if (high_entry->handle != high_entry->next_handle)
			{
				// The high entry is still assigned, so the low entry belongs
				// on the secondary list.
				low_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
				low_entry->prev_entry =
					hfact->entry_list[LD_SECONDARY].prev_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
					low_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry = low_entry;
			}
			else if (low_entry->handle != low_entry->next_handle)
			{
				// The low entry is still assigned, so the high entry belongs
				// on the secondary list.
				high_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
				high_entry->prev_entry =
					hfact->entry_list[LD_SECONDARY].prev_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
					high_entry;
				hfact->entry_list[LD_SECONDARY].prev_entry = high_entry;
			}
			else
			{
				// Neither entry is still assigned, so one entry belongs on the
				// primary list and one on the secondary list.  Which goes on
				// which is determined by a comparison of their handle values.
				// We're being tricky with unsigned integer math here.  Before
				// comparing the two handles, we subtract from each the value
				// of handle_base, modulo the size of the handle space (the
				// modulo is implicit).  This allows the effective comparison
				// of their logical acyclic values rather than their actual
				// cyclic values.
				adjusted_high_next_handle =
					high_entry->next_handle - new_handle_base;
				adjusted_low_next_handle =
					low_entry->next_handle - new_handle_base;
				if (adjusted_low_next_handle < adjusted_high_next_handle)
				{
					// The handle value for the low entry is smaller, so it
					// belongs on the primary list and the high entry on the
					// secondary list.
					high_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
					high_entry->prev_entry =
						hfact->entry_list[LD_SECONDARY].prev_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
						high_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry = high_entry;
					low_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
					low_entry->prev_entry =
						hfact->entry_list[LD_PRIMARY].prev_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry->next_entry =
						low_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry = low_entry;
				}
				else
				{
					// The handle value for the high entry is smaller, so it
					// belongs on the primary list and the low entry on the
					// secondary list.
					high_entry->next_entry = &hfact->entry_list[LD_PRIMARY];
					high_entry->prev_entry =
						hfact->entry_list[LD_PRIMARY].prev_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry->next_entry =
						high_entry;
					hfact->entry_list[LD_PRIMARY].prev_entry = high_entry;
					low_entry->next_entry = &hfact->entry_list[LD_SECONDARY];
					low_entry->prev_entry =
						hfact->entry_list[LD_SECONDARY].prev_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry->next_entry =
						low_entry;
					hfact->entry_list[LD_SECONDARY].prev_entry = low_entry;
				}
			}
		}
	}
	// Update the handle base with the new handle base.
	hfact->handle_base = new_handle_base;
	// To contract the table, there must be no pairs, because otherwise two
	// assigned handles would yield the same entry index and thereby conflict.
	// Furthermore, the table size must be greater than 2, because much of the
	// handle factory code assumes that the table is at least of size 2.  In
	// addition to these strict requirements, hysteresis is employed both to
	// keep the mean assignment and release times constant and to minimize the
	// allocation chatter of rapidly expanding and contracting the table.  Only
	// if the hysteresis debt is zero will the table be contracted.
	if (hfact->pair_count == 0 && table_size > 2 &&
		hfact->hysteresis_debt == 0)
	{
		contract_HF_table(hfact);
		// Note that we ignore the return code.  If the contraction is
		// unsuccessful, we just continue as usual.  There is no real harm in
		// not contracting the table, except that we consume more space than
		// necessary.
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\handfact.h ===
//#define WIN32_LEAN_AND_MEAN 1
//#include <windows.h>

/*
 *  handfact.h
 *
 *  author:	John R. Douceur
 *  date:	26 January 1998
 *
 *  This header file defines structures, function prototypes, and macros for
 *  the handle factory.  The code is object-oriented C, transliterated from a
 *  C++ implementation.
 *
 *  The handle factory is a component that generates and validates handles.  It
 *  is intended to be used in a software module that provides client software
 *  modules with means to refer to information structures contained within the
 *  provider.  While such a means could simply be a pointer, this would not
 *  enable the deletion of the information structures without explicitly
 *  notifying the clients of such deletion.  Unlike pointers, the handles
 *  generated by the handle factory can be examined (by the handle factory)
 *  to determine their validity.
 *
 *  Handles can be invalidated in one of two ways.  The handle can be released
 *  by calling the release_HF_handle() function, indicating to the handle
 *  factory that the handle is no longer necessary and that future requests
 *  to dereference this handle should be met with a null pointer.  Alternately,
 *  the handle can be revoked by the handle factory; this will happen unter two
 *  circumstances.  If a large number of handles (more than four billion) are
 *  issued and subsequently released, it becomes necessary to reuse portions of
 *  the handle space for future assignments; under these circumstances, very
 *  old handles will be revoked well before this recycling occurs, to give the
 *  holders of those handles ample opportunity to notice that their handles
 *  have become invalid and to request new handles.  The other situation in
 *  which revokation can occur is if the amount of available memory becomes
 *  too small to allocate additional space to expand the handle database; then,
 *  if the assignment of a new handle is requested, the least-recently-assigned
 *  handle will be revoked to make room for the new request.
 *
 *  Use of the handle factory in a multi-threaded environment requires a lock.
 *  This lock must be taken by a single thread for the execution of either
 *  assign_HF_handle() or release_HF_handle().  Use of dereference_HF_handle()
 *  does not require taking a lock, since synchronization is handled internally
 *  through careful sequencing of read and write operations.
 *
 *  Because this code is C, rather than C++, it is not possible to hide as
 *  much of the implementation from the client code as one might wish.
 *  Nonetheless, there is an attempt to isolate the client from some of the
 *  implementation details through the use of macros.  Below is described each
 *  of the functions and macros necessary to use the handle factory.
 *
 */

#ifndef _INC_HANDFACT

#define _INC_HANDFACT

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  There are two basic structures employed: the HFEntry and the HandleFactory.
 *  Ideally, these would be completely hidden from the client, but the size of
 *  the HandleFactory structure structure needs to be known by the client for
 *  allocation purposes, and this is most easily accomplished by declaring the
 *  structure itself here in the header file, which in turn requires declaring
 *  the HFEntry structure.  It is strongly urged that the client not directly
 *  refer to any of the fields of either of these structures.  To support the
 *  documentation of the accompanying rhizome.c file, these structures are
 *  annotated with internal comments, but these can be ignored by the reader
 *  who wishes only to understand how to write client code that makes use of
 *  the handle factory.
 *
 *  The handles generated by the handle factory are of type HFHandle.  This is
 *  typedefed to an unsigned int, but this fact can be ignored by the client,
 *  since it is an implementation detail.
 *
 */

//#include <stdlib.h>
//#include <malloc.h>

// HFHandle is the type of the handles generated by the handle factory.
//
typedef unsigned int HFHandle;

struct _HFEntry;

typedef struct _HFEntry HFEntry;

struct _HFEntry
{
	// This is the element in which each handle and its associated pointer are
	// stored.  If handle == next_handle, the entry is not assigned, and it is
	// available for assignment to a pointer via the assign_HF_handle()
	// function.  If handle != next_handle, then the entry is assigned to the
	// pointer in the reference field.
	//
	// Each entry is on one of three lists: the primary free list, the secondary
	// free list, or the assigned list.  Each of these lists is maintained via
	// the next_entry and prev_entry pointers.

	HFHandle handle;                                          // value of handle
	HFHandle next_handle;         // next value given to handle when invalidated
	void *reference;                           // pointer to which handle refers
	HFEntry *next_entry;                        // pointer to next entry in list
	HFEntry *prev_entry;                    // pointer to previous entry in list
};

struct _HandleFactory;

typedef struct _HandleFactory HandleFactory;

struct _HandleFactory
{
	// This structure contains private member variables for the handle factory.
	// The table_size and entries fields are marked volatile to insure that the
	// operations performed on them occur in the specified sequence.  The handle
	// factory can operate in a multi-threaded environment without requiring
	// that a lock be taken before calling dereference_HF_handle(), and this is
	// accomplished by careful sequencing of the read and write operations on
	// these two variables.
	//
	// There are two sets of table_size and entries variables, which are used
	// to provide a synchronization mechanism in conjunction with the two
	// sync variables.  The varset variable indicates which set of these three
	// variables is used by default.  Most normal operations (assign, release,
	// suspend, reinstate) simply use the default set of table_size and entries.
	// However, the expand and contract routines update both sets, and the
	// dereference routine needs to examine the sets in a special way to ensure
	// that it does not conflict with a concurrent expansion or contraction.
	//
	// The dereference_HF_handle() routine increments one of the sync variables
	// to indicate an intention to refer to the corresponding table_size and
	// entries variables.  The expand_HF_table() and contract_HF_table()
	// routines each massively decrement one of the sync variables to indicate
	// an intention to change the corresponding table_size and entries
	// variables.  All changes to the sync variables are done through
	// interlocked operations.
	//
	// The table that holds the handles can only be contracted (shrunk in half)
	// when for each assigned handle in the lower half of the table, there is
	// no assigned handle in the corresponding upper half of the table.  The
	// number of correspondences between the two table halves is given by
	// pair_count.

	volatile int table_size[2];             // size of table for storing entries
	HFEntry *volatile entries[2];                // pointer to tables of entries
	LONG sync[2];                                    // synchronization variable
	int varset;                                // variable set for default usage
	HFHandle handle_base;                // rolling point of lowest handle value
	int population;                      // number of handles currently assigned
	int pair_count;               // contractions can occur when pair_count == 0
	int hysteresis_debt;                      // must be zero before contraction
	HFEntry entry_list[3];                     // array of all three entry lists
};

/*
 *  The client interface to the handle factory is provided by seven functions
 *  and one macro.  It is expected that the provider will first instantiate a
 *  handle factory, either in the static data segment, on the stack, or on the
 *  heap.  Then, the provider will assign handles to various pointers by
 *  calling assign_HF_handle(), which it will distribute to its clients.  When
 *  the provider wishes to release these handles, it will do so by calling
 *  release_HF_handle().  Each time a client presents a handle to the provider,
 *  the provider can validate the handle and retrieve the associated pointer
 *  by calling dereference_HF_handle().  A client can temporarily suspend a
 *  handle by calling suspend_HF_handle(), after which it can either reinstate
 *  the handle by calling reinstate_HF_handle() or release the handle by calling
 *  release_HF_handle().
 *
 */

// A handle factory may be allocated in the static data segment or on the stack
// simply by declaring a variable of type HandleFactory.  To allocate it on the
// heap, the following macro returns a pointer to a new HandleFactory structure.
// If this macro is used, a corresponding call to free() must be made to
// deallocate the structure from the heap.
//
#define NEW_HandleFactory(_h) AllocMem(&(_h), sizeof(HandleFactory))

#define FreeHandleFactory(_h) FreeMem(_h)
// Since this is not C++, the HandleFactory structure is not self-constructing;
// therefore, the following constructor code must be called on the HandleFactory
// structure after it is allocated.  If the construction is successful, the
// function returns a value of 0.  If the construction fails (due, for example,
// to an inability to allocate memory), the function returns a value of 1.
//
int
constructHandleFactory(
	HandleFactory *hfact);

// Since this is not C++, the HandleFactory structure is not self-destructing;
// therefore, the following destructor code must be called on the HandleFactory
// structure before it is deallocated.
//
void
destructHandleFactory(
	HandleFactory *hfact);

// This function generates a new handle value, associates the handle value with
// the provided reference pointer, and returns the handle value.  Barring
// highly unusual circumstances, this handle will remain valid until it is
// explicitly released by a call to release_HF_handle().  However, there is no
// guarantee that the handle will persist for an arbitrary duration; it may
// become necessary for the handle factory to revoke the handle under some
// circumstances, particularly when the handle becomes very old or when memory
// becomes scarce.
//
// The assign_HF_handle() function will never return a handle value of zero.
// Thus, the client program is free to use a zero handle value as an escape
// indicator, if desired.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// release_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().
//
HFHandle
assign_HF_handle(
	HandleFactory *hfact,
	void *reference);

// This function releases a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned, then it is released, and the function
// returns a value of 0.  If the handle is not currently assigned, the function
// aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().
//
int
release_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function suspends a handle, indicating that further attempts to
// dereference the handle should result in a null pointer value rather than the
// pointer value that was originally assigned to the handle, unless and until
// reinstate_HF_handle() is called on the handle value.  The handle factory
// checks the validity of the handle and returns a corresponding status code.
// If the handle is currently assigned and not suspended, then it is suspended,
// and the function returns a value of 0.  If the handle is not currently
// assigned or has already been suspended, the function aborts and returns a
// value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and reinstate_HF_handle().
//
int
suspend_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function reinstates a suspended handle, indicating that further attempts
// to dereference the handle should result in the pointer value that was
// originally assigned to the handle, rather than the null pointer value to
// which a suspended handle dereferences.  The handle factory checks the
// validity of the handle and returns a corresponding status code. If the handle
// is currently assigned and suspended, then it is reinstated, and the function
// returns a value of 0.  If the handle is not currently assigned or is not
// suspended, the function aborts and returns a value of 1.
//
// In a multi-threaded environment, a single thread must take a lock prior to
// calling this function, and this must be the same lock taken before calling
// assign_HF_handle(), release_HF_handle(), and suspend_HF_handle().
//
int
reinstate_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

// This function validates a handle and returns either the associated pointer
// (if the handle is valid) or a null pointer value (if the handle is invalid).
// If the handle has not been released or suspended but a null value is
// returned, then the handle has been revoked by the handle factory.  This is
// expected to be a highly unusual occurrence; however, since it can happen, any
// program that employs the handle factory must have some auxiliary mechanism
// for retrieving the desired pointer information.  Once the pointer is
// retrieved through this (presumably expensive) auxiliary means, a new handle
// can be reassigned to the pointer by another call to assign_HF_handle().
//
// Even in a multi-threaded environment, it is not necessary to take a lock
// prior to calling this function.  Careful sequencing of read and write
// operations inside the handle factory code obviates the need to explicitly
// lock the data structure for dereferencing handles.
//
void *
dereference_HF_handle(
	HandleFactory *hfact,
	HFHandle handle);

#ifdef _TEST_HANDFACT

// This is a test routine that simply verifies the internal valididy of the
// handle factory's data structures.  By defining the constant _TEST_HANDFACT,
// this routine will be compiled and available to the client code.  It can be
// called at any time, unless running in a multi-threaded environment, in which
// case the caller must first take the same lock used for assign_HF_handle(),
// release_HF_handle(), suspend_HF_handle(), and reinstate_HF_handle().  If the
// routine returns any value other than zero, then the internal lists of records
// are in an inconsistent state.
//
int
verify_HF_lists(
	HandleFactory *hfact);

#endif /* _TEST_HANDFACT */

#ifdef __cplusplus
}
#endif

#endif	/* _INC_HANDFACT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\handles.c ===
/*++
Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    rsvphndls.c

Abstract:

    This file contains the code to create and release handles

Author:

    Jim Stewart (JStew) June 10, 1996

Environment:


Revision History:

	Ofer Bar (oferbar) Oct 1, 1997 - Revision II

--*/

#include "precomp.h"
#pragma hdrstop


PVOID
GetHandleObject(
	IN  HANDLE				h,
    IN  ENUM_OBJECT_TYPE	ObjType
    )
{
    ENUM_OBJECT_TYPE   *p;
    
    GetLock(pGlobals->Lock);
    p = (ENUM_OBJECT_TYPE *)dereference_HF_handle(pGlobals->pHandleTbl, 
                                                  PtrToUlong(h));

    if (p != NULL) {

        //
        // we found a reference for the handle
        // we verify that it's the right object type
        //

        if ((*p & ObjType) == 0) {

            //
            // sorry, wrong type
            //

            p = NULL;
        }
    } else {

        IF_DEBUG(HANDLES) {
            WSPRINT(("The handle (%x) is invalid\n", h));
            DEBUGBREAK();
        }

    }
    
    FreeLock(pGlobals->Lock);

    return (PVOID)p;

}


PVOID
GetHandleObjectWithRef(
	IN  HANDLE					h,
    IN  ENUM_OBJECT_TYPE	    ObjType,
    IN  ULONG                   RefType
    )
{
    ENUM_OBJECT_TYPE   *p, *p1;
    PCLIENT_STRUC       pClient;
    PFILTER_STRUC       pFilter;
    PFLOW_STRUC         pFlow;
    PINTERFACE_STRUC    pInterface;

    GetLock(pGlobals->Lock);

    p = (ENUM_OBJECT_TYPE *) dereference_HF_handle(pGlobals->pHandleTbl, 
                                                   PtrToUlong(h));

    if (p != NULL) {

        //
        // we found a reference for the handle
        // we verify that it's the right object type
        //

        if ((*p & ObjType) == 0) {

            //
            // sorry, wrong type
            //

            p = NULL;
        }
        
    }

    if (p != NULL) {

        p1 = p;

        switch (ObjType) {
 
        case ENUM_CLIENT_TYPE:

            pClient = (PCLIENT_STRUC)p;
            
            GetLock(pClient->Lock);
            if (QUERY_STATE(pClient->State) == OPEN) {
                REFADD(&pClient->RefCount, RefType);
            } else {
                p = NULL; // we can deref a struct that is not open for business
            }
            FreeLock(pClient->Lock);

            break;
        
        case ENUM_FILTER_TYPE:

            pFilter = (PFILTER_STRUC)p;

            GetLock(pFilter->Lock);
            if (QUERY_STATE(pFilter->State) == OPEN) {
                REFADD(&pFilter->RefCount, RefType);
            } else {
                p = NULL;
            }
            FreeLock(pFilter->Lock);

            break;

        case ENUM_INTERFACE_TYPE:
            
            pInterface = (PINTERFACE_STRUC)p;

            GetLock(pInterface->Lock);
            if (QUERY_STATE(pInterface->State) == OPEN) {
                REFADD(&pInterface->RefCount, RefType);
            } else {
                p = NULL;
            }
            FreeLock(pInterface->Lock);

            break;

        case ENUM_GEN_FLOW_TYPE:

            pFlow = (PFLOW_STRUC)p;

            GetLock(pFlow->Lock);
            
            // Return a HANDLE only if it is in OPEN state
            // Otherwise return INVALID_HANDLE_VALUE so the
            // caller will know that the Flow is not in the 
            // correct state
            if (QUERY_STATE(pFlow->State) == OPEN) 
            {
                REFADD(&pFlow->RefCount, RefType);
            } else 
            {
                p = INVALID_HANDLE_VALUE;
            }
            FreeLock(pFlow->Lock);

            break;
        
        case ENUM_CLASS_MAP_FLOW_TYPE:

            pFlow = (PFLOW_STRUC)p;

            GetLock(pFlow->Lock);
            if (QUERY_STATE(pFlow->State) == OPEN) {
                REFADD(&pFlow->RefCount, RefType);
            } else {
                p = NULL;
            }
            FreeLock(pFlow->Lock);

            break;

        default:
            ASSERT(0);
        
        }

        
        //
        // random debug code - please delete
        //
        IF_DEBUG(HANDLES) {
            if (p1 != p) {
                WSPRINT(("The object being derefed is NOT in OPEN state p1=%x and p=%x\n", p1, p));
                DEBUGBREAK();
            }
        }
        
    } else {
        
        IF_DEBUG(HANDLES) {
            WSPRINT(("The handle (%x) is invalid\n", h));
            DEBUGBREAK();
        }

    }
    
    FreeLock(pGlobals->Lock);

    return (PVOID)p;
}


HANDLE
AllocateHandle(
    IN  PVOID  Context
    )
/*++

Routine Description:

    This function creates a handle.

Arguments:

    Context     - the context value to store with the handle

Return Value:

	The handle factory handle, or NULL in case of en error

--*/
{
    HFHandle	Handle;
    PVOID		VerifyCtx;

    GetLock( pGlobals->Lock );

    Handle = assign_HF_handle(pGlobals->pHandleTbl, Context);

    //
    // verify the handle is valid
    //

    if (Handle) {
        VerifyCtx = dereference_HF_handle(pGlobals->pHandleTbl, Handle);
        ASSERT(VerifyCtx == Context);
        
        IF_DEBUG(HANDLES) {
            WSPRINT(("AllocHandle: (%x) being allocated\n", Handle ));
        }
    }
    FreeLock(pGlobals->Lock);

    return UlongToPtr(Handle);
}



VOID
FreeHandle(
    IN 	HANDLE    Handle
    )
/*++

Routine Description:

    This function frees the handle

Arguments:

    Handle - 

Return Value:

--*/
{
    int  r;

    GetLock( pGlobals->Lock );

    IF_DEBUG(HANDLES) {
        WSPRINT(("FreeHandle (%x) being freed\n", PtrToUlong(Handle) ));
    }

    r = release_HF_handle(pGlobals->pHandleTbl, PtrToUlong(Handle));

    ASSERT(r == 0);

    FreeLock(pGlobals->Lock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\init.c ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains initialization code for traffic.DLL.

Author:

    Jim Stewart ( jstew )    July 28, 1996

Revision History:

	Ofer Bar (oferbar)		Oct 1, 1997

--*/

#include "precomp.h"
//#pragma hdrstop

//#include "oscode.h"

//
// global data
//
ULONG       	DebugMask = 0;
BOOL        	NTPlatform = FALSE;
//LPWSCONTROL 	WsCtrl = NULL;
PGLOBAL_STRUC	pGlobals = NULL;
DWORD    		InitializationStatus = NO_ERROR;

static	BOOL				_init_rpc = FALSE;
static	PUSHORT 			_RpcStringBinding;

//
// 258218 changes
//
TRAFFIC_LOCK        NotificationListLock;
LIST_ENTRY          NotificationListHead;

TRAFFIC_LOCK        ClientRegDeregLock;
HANDLE              GpcCancelEvent = INVALID_HANDLE_VALUE;

PVOID               hinstTrafficDll;

VOID
CloseAll(VOID);

#if DBG
TCHAR *TC_States[] = {
    TEXT("INVALID"),
    TEXT("INSTALLING"),     // structures were allocated.
    TEXT("OPEN"),           // Open for business
    TEXT("USERCLOSED_KERNELCLOSEPENDING"), // the user component has closed it, we are awaiting a kernel close
    TEXT("FORCED_KERNELCLOSE"),            // the kernel component has forced a close.
    TEXT("KERNELCOSED_USERCLEANUP"),       // Kernel has closed it, we are ready to delete this obj.
    TEXT("REMOVED"),        // Its gone (being freed - remember that the handle has to be freed before removing)
    TEXT("EXIT_CLEANUP"),  // We are going away and need to be cleanedup
    TEXT("MAX_STATES")
    
};

#endif 

BOOL
Initialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
/*++

Description:
    This is the DLL entry point, called when a process  
    attaches or a thread is created

Arguments:

    DllHandle   - a handle to the DLL
    Reason      - why the dll entry point is being called
    Context     - additional information about call reason

Return Value:

    TRUE or FALSE

--*/
{
    HANDLE 		Handle;
    DWORD   	Error;

    //
    // On a thread detach, set up the context param so that all
    // necessary deallocations will occur. On a FreeLibrary call Context
    // will be NULL and that is the case that we DO want to cleanup.
    //

    if ( Reason == DLL_THREAD_DETACH ) {
        Context = NULL;
    }

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        // Save the DLL handle as it is used to change ref count on this DLL
        hinstTrafficDll = DllHandle;
        
        //
        // disable the DLL_THREAD_ATTACH event
        //

        DisableThreadLibraryCalls( DllHandle );

        SETUP_DEBUG_INFO();

        IF_DEBUG(INIT) {

            WSPRINT(( "Initialize: DLL Process Attach \n" ));
        }

        INIT_DBG_MEMORY();

        if (!InitializeGlobalData()) {

            CLOSE_DEBUG();
            return FALSE;
        }

        IF_DEBUG(INIT) {
            WSPRINT(("traffic.dll Version %d\n", CURRENT_TCI_VERSION));
        }

        InitializationStatus = InitializeOsSpecific();

        if (ERROR_FAILED(InitializationStatus)) {

            WSPRINT(("\tInitialize: Failed OS specific initialization!\n"));
            CLOSE_DEBUG();

            //
            // we return TRUE to succedd DLL loading into the process
            // all other TCI calls will check this and fail...
            //

            return TRUE;

        } else {

#if 0
            InitializeWmi();

            //
            // call to internally enumerate the interfaces
            //

             EnumAllInterfaces();
#endif
        }

        //InitializeIpRouteTab();

        break;

    case DLL_PROCESS_DETACH:

        if ( Context )
        {
            // As per MSDN a non-zero Context means process is
            // terminating. Do not do any cleanup
            break;
        }
        
        IF_DEBUG(SHUTDOWN) {

            WSPRINT(( "Shutdown: Process Detach, Context = %X\n",Context ));
        }

        //DUMP_MEM_ALLOCATIONS();

        //
        // Only clean up resources if we're being called because of a
        // FreeLibrary().  If this is because of process termination,
        // do not clean up, as the system will do it for us.  However 
        // we must still clear all flows and filters with the kernel 
        // since the system will not clean these up on termination.
        //

        //
        // don't want to get WMI notifications
        //

        DeInitializeWmi();

        //
        // close all flows and filters with the kernel and deregister from GPC
        //

        CloseAll();

        //
        // close the kernel file handle
        //

        DeInitializeOsSpecific();

        //
        // release all allocated resources
        //
       
        DeInitializeGlobalData();

        //
        // dump allocated memory, before and after we cleanup to 
        //  help track any leaks 

        DUMP_MEM_ALLOCATIONS();

        DEINIT_DBG_MEMORY();

        CLOSE_DEBUG();
        
        break;

    case DLL_THREAD_DETACH:

        IF_DEBUG(SHUTDOWN) {

            WSPRINT(( "Shutdown: thread detach\n" ));
        }

        break;

    case DLL_THREAD_ATTACH:
        break;

    default:

        ASSERT( FALSE );
        break;
    }

    return TRUE;

}



VOID
CloseAll()
/*++

Description:

    Close all interfaces, all flows and all filters. 
    Also deregister GPC clients and release all TC ineterfaces.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD       		Status;
    PLIST_ENTRY 		pEntry;
    PINTERFACE_STRUC  	pInterface;
    PCLIENT_STRUC		pClient;
    PGPC_CLIENT			pGpcClient;
    PTC_IFC				pTcIfc;

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "CloseAll: Attempting to close any open interface\n" ));
    }

    while (!IsListEmpty( &pGlobals->ClientList )) {

        pClient = CONTAINING_RECORD( pGlobals->ClientList.Flink,
                                     CLIENT_STRUC,
                                     Linkage );

        IF_DEBUG(SHUTDOWN) {
            WSPRINT(( "CloseAll: Closing client=0x%X\n",
                      PtrToUlong(pClient)));
        }

        while (!IsListEmpty( &pClient->InterfaceList )) {

            pInterface = CONTAINING_RECORD( pClient->InterfaceList.Flink,
                                            INTERFACE_STRUC,
                                            Linkage );

            //
            // remove all flows/filters and close the interface
            //


            IF_DEBUG(SHUTDOWN) {
                WSPRINT(( "CloseAll: Closing interface=0x%X\n",
                          PtrToUlong(pInterface)));
            }
		
            MarkAllNodesForClosing(pInterface, EXIT_CLEANUP); 
            CloseInterface(pInterface, TRUE);
        }

        //
        // deregister the client
        //

        IF_DEBUG(SHUTDOWN) {
            WSPRINT(( "CloseAll: Deregistring TC client\n"));
        }

        TcDeregisterClient(pClient->ClHandle);

    }


    //
    // Deregister GPC clients
    //

    while (!IsListEmpty( &pGlobals->GpcClientList )) {

        pEntry = pGlobals->GpcClientList.Flink;

        pGpcClient = CONTAINING_RECORD( pEntry,
                                        GPC_CLIENT,
                                        Linkage );

        IF_DEBUG(SHUTDOWN) {
            WSPRINT(( "CloseAll: Deregistring GPC client\n"));
        }

        IoDeregisterClient(pGpcClient);

        RemoveEntryList(pEntry);

        FreeMem(pGpcClient);
    }


    //
    // Remove TC interfaces
    //

    while (!IsListEmpty( &pGlobals->TcIfcList )) {

        pEntry = pGlobals->TcIfcList.Flink;

        pTcIfc = CONTAINING_RECORD( pEntry,
                                    TC_IFC,
                                    Linkage );

        ASSERT( IsListEmpty( &pTcIfc->ClIfcList ) );

        IF_DEBUG(SHUTDOWN) {
            WSPRINT(( "CloseAll: Remove TC (%x) interface from list\n", pTcIfc));
        }

        REFDEL(&pTcIfc->RefCount, 'KIFC');
    }

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "<==CloseAll: exit...\n"));
    }

}




DWORD
InitializeGlobalData(VOID)

/*++

Description:
    This routine initializes the global data.

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD   Status;
    //
    // allocate memory for the globals
    //

    AllocMem(&pGlobals, sizeof(GLOBAL_STRUC));

    if (pGlobals == NULL) {

        return FALSE;
    }

    RtlZeroMemory(pGlobals, sizeof(GLOBAL_STRUC));

    __try {

        InitLock( pGlobals->Lock );
        InitLock( NotificationListLock);
        InitLock( ClientRegDeregLock );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();

        IF_DEBUG(ERRORS) {
            WSPRINT(("TcRegisterClient: Exception Error: = 0x%X\n", Status ));
        }

        FreeMem(pGlobals);

        return FALSE;

    }

    //
    // initialize the handle table
    //

    NEW_HandleFactory(pGlobals->pHandleTbl);
    
    if (pGlobals->pHandleTbl == NULL) {

        FreeMem(pGlobals);
        return FALSE;
    }

    if (constructHandleFactory(pGlobals->pHandleTbl) != 0) {

        //
        // failed to construct the handle table, exit
        //

        FreeHandleFactory(pGlobals->pHandleTbl);
        FreeMem(pGlobals);
        return FALSE;
    }

    InitializeListHead( &pGlobals->ClientList );
    InitializeListHead( &pGlobals->TcIfcList );
    InitializeListHead( &pGlobals->GpcClientList );
    InitializeListHead( &NotificationListHead );        // 258218

    ASSERT(sizeof(IP_PATTERN) == sizeof(GPC_IP_PATTERN));
    ASSERT(FIELD_OFFSET(IP_PATTERN,SrcAddr) ==
           FIELD_OFFSET(GPC_IP_PATTERN,SrcAddr));
    ASSERT(FIELD_OFFSET(IP_PATTERN,ProtocolId) ==
           FIELD_OFFSET(GPC_IP_PATTERN,ProtocolId));
    return TRUE;
}




VOID
DeInitializeGlobalData(VOID)

/*++

Description:
    This routine de-initializes the global data.

Arguments:

    none

Return Value:

    none

--*/
{
    PLIST_ENTRY		pEntry;
    PTC_IFC			pTcIfc;
    PNOTIFICATION_ELEMENT   pNotifyElem;

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "DeInitializeGlobalData: cleanup global data\n"));
    }

    destructHandleFactory(pGlobals->pHandleTbl);
    FreeHandleFactory(pGlobals->pHandleTbl);

#if 0
    //
    // clear the TC interface structures 
    //

    while (!IsListEmpty(&pGlobals->TcIfcList)) {

        pEntry = RemoveHeadList(&pGlobals->TcIfcList);
        pTcIfc = (PTC_IFC)CONTAINING_RECORD(pEntry, TC_IFC, Linkage);

        FreeMem(pTcIfc);
    }
#endif

    DeleteLock( pGlobals->Lock );
    
    //
    // Free the notification elements (258218)
    //
    while (!IsListEmpty(&NotificationListHead)) {

        pEntry = RemoveHeadList(&NotificationListHead);
        pNotifyElem = (PNOTIFICATION_ELEMENT)CONTAINING_RECORD(pEntry, NOTIFICATION_ELEMENT, Linkage.Flink);

        FreeMem(pNotifyElem);
    }

    DeleteLock( NotificationListLock);
    DeleteLock( ClientRegDeregLock );
    

    FreeMem(pGlobals);

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "<==DeInitializeGlobalData: exit\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\oscode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    oscode.c

Abstract:

    This module contains support routines for the traffic DLL.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

--*/


#include "precomp.h"
//#pragma hdrstop

//#include "oscode.h"

//
// function pointers for NT functions to Open driver
//
FARPROC    CreateFileNt = NULL;
FARPROC    CloseNt = NULL;
FARPROC    NtStatusToDosError = NULL;
FARPROC    RtlInitUnicodeStringNt = NULL;

PTCHAR     NTDLL = L"\\ntdll.dll";

extern     PGPC_NOTIFY_REQUEST_RES     GpcResCb;

DWORD
OpenDriver(
    OUT HANDLE  *pHandle,
    IN  LPCWSTR DriverName
    )
/*++

Routine Description:

    This function opens a specified drivers control channel.

Arguments:

    pHandle -  the handle to the opened driver

    DriverName - name of the driver to be opened.

Return Value:

    Windows Error Code.

--*/
{
    NTSTATUS            Status = NO_ERROR;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      nameString;

    (*RtlInitUnicodeStringNt)(&nameString,DriverName);

    InitializeObjectAttributes( &objectAttributes,
                                &nameString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);
    //
    // Open a Handle to the driver.
    //

    Status = (NTSTATUS)(*CreateFileNt)( pHandle,
                              SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                              &objectAttributes,
                              &ioStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              0,
                              NULL,
                              0);

    if (Status == STATUS_SUCCESS) {

        //
        // send an IOCTL for driver notifications
        //

        // IOCTL is done when the first client registers
        // with TC. This is done in another thread so that
        // it can be cancelled when there are no clients
//        IoRequestNotify(/*pGpcClient*/);

    }

    return (Status == STATUS_SUCCESS ? 0 : ERROR_OPEN_FAILED);

}

DWORD
DeviceControl(
    IN  HANDLE                          FileHandle,
    IN  HANDLE                          EventHandle,
    IN  PIO_APC_ROUTINE         ApcRoutine,
    IN  PVOID                           ApcContext,
    OUT PIO_STATUS_BLOCK        pIoStatBlock,
    IN  ULONG                           Ioctl,
    IN  PVOID                           setBuffer,
    IN  ULONG                           setBufferSize,
    IN  PVOID                           OutBuffer,
    IN  ULONG                           OutBufferSize )
/*++

Routine Description:

    This routine issues a device control request to the GPC

Arguments:

    FileHandle    - Open handle to the GPC driver
    Ioctl         - The IOCTL to pass to the stack
    setBuffer     - Data buffer containing the information to be set
    setBufferSize - The size of the set data buffer.
    Outbuffer     - the returned buffer
    OutBufferSize - the size

Return Value:

    A winerror status value.

--*/
{
    NTSTATUS        NtStatus = NO_ERROR;
    DWORD                       Status;

    if (NTPlatform) {

        IF_DEBUG(IOCTLS) {
            WSPRINT(("==>DeviceIoControl: Ioctl= %x\n", Ioctl ));
        }

        NtStatus = NtDeviceIoControlFile( FileHandle,
                                          EventHandle,          // Event
                                          ApcRoutine,           // when completed
                                          ApcContext,           // for ApcRoutine
                                          pIoStatBlock,         // for ApcRoutine
                                          Ioctl,            // Control code
                                          setBuffer,        // Input buffer
                                          setBufferSize,    // Input buffer size
                                          OutBuffer,        // Output buffer
                                          OutBufferSize );  // Output buffer size

        if (ApcRoutine && NT_SUCCESS(NtStatus)) {

            Status = ERROR_SIGNAL_PENDING;
            
            IF_DEBUG(IOCTLS) {
                WSPRINT(("DeviceIoControl: ApcRoutine defined Status=0x%X\n", 
                         Status ));
            }
            
        } else {

          Status = MapNtStatus2WinError(NtStatus);
          
          IF_DEBUG(IOCTLS) {
              WSPRINT(("DeviceIoControl: NtStatus=0x%X, Status=0x%X\n", 
                       NtStatus, Status ));
          }

#if DBG
          if (EventHandle) {
              IF_DEBUG(IOCTLS) {
                  WSPRINT(("DeviceIoControl: Event defined\n"));
              }
          }
#endif          
        }


    } else {

        // yoramb - not supporting other OSs for now.

        WSPRINT(("DeviceControl: Only Windows NT supported at this time!\n"));

        Status = ERROR_NOT_SUPPORTED;

    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==DeviceIoControl: Returned=0x%X\n", 
                 Status ));
    }

    return( Status );
}



DWORD
InitializeOsSpecific(VOID)

/*++

Routine Description:

    

Arguments:

    status - status to convert:

Return Value:

    status

--*/

{
    DWORD           Status;
    OSVERSIONINFO   VersionInfo;

    //
    // determine the type of system we are running on
    //

    Status = NO_ERROR;
    NTPlatform = TRUE;

    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    if (GetVersionEx( &VersionInfo )) {
        if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            NTPlatform = TRUE;
        }

    } else {

        WSPRINT(("Could not get version\n"));
    }


    if (!NTPlatform) {

        //
        // Initially, only NT compatibility is required.
        //

        return(ERROR_SERVICE_DOES_NOT_EXIST);

    } else {

        HINSTANCE  NtDll;
        WCHAR      wszNtDllPath[MAX_PATH];
        DWORD      dwPos = 0;
        
        //
        // get the function ptrs to NT specific routines that we need
        //

        //
        // Obtain the path to the system directory.
        //
        dwPos = (DWORD) GetSystemDirectoryW(wszNtDllPath, MAX_PATH);

        if ((dwPos <= 0) || (dwPos >= (MAX_PATH - wcslen(NTDLL) -2)))
        {
            //
            // Either error or not enough room to write the path to ntdll.dll
            //
            WSPRINT(("InitializeOsSpecific: Failed to load ntdll.dll\n"));
            return(FALSE);
        }

        //
        // Concatenate the word "\NTDLL.DLL"
        //
        wcsncat(&wszNtDllPath[dwPos], NTDLL, wcslen(NTDLL));

        //
        // Terminate the string
        //
        wszNtDllPath[dwPos + wcslen(NTDLL)] = '\0';
        
        //
        // Finally, load the library.
        //
        NtDll = LoadLibraryExW(wszNtDllPath, NULL, 0);

        if (NtDll == NULL) {
            WSPRINT(("InitializeOsSpecific: Failed to load ntdll.dll\n"));
            return(FALSE);
        }

        CreateFileNt = GetProcAddress(NtDll,"NtCreateFile" );

        CloseNt = GetProcAddress( NtDll,"NtClose" );

        RtlInitUnicodeStringNt = GetProcAddress( NtDll,"RtlInitUnicodeString" );

        NtStatusToDosError = GetProcAddress( NtDll,"RtlNtStatusToDosError" );

        if ( (CreateFileNt == NULL)           ||
             (CloseNt == NULL)                ||
             (RtlInitUnicodeStringNt == NULL) ||
             (NtStatusToDosError == NULL) ) {

            FreeLibrary(NtDll);
            Status = ERROR_PATH_NOT_FOUND;

        } else {

            //
            // open a handle to the GPC
            //

            Status = OpenDriver( &pGlobals->GpcFileHandle, 
                                 (LPWSTR)DD_GPC_DEVICE_NAME);

            if (Status != NO_ERROR){

                WSPRINT(("\tThis version of traffic.dll requires kernel traffic control components.\n"));
                WSPRINT(("\tIt is unable to find these components.\n"));
                WSPRINT(("\tDilithium crystals may be used in their place...\n"));
            }

        }
    }

    return( Status );
}




VOID
DeInitializeOsSpecific(VOID)

/*++

Routine Description:

    This procedure closes the file handle passed in, in a platform dependent manner.

Arguments:

    Handle - the handle to close

Return Value:

    status

--*/

{

    //
    // only on NT do we close the handle, since on Win95, 
    // we don't actually open a file for Tcp, so there
    // is no handle in that case
    //

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "DeInitializeOsSpecific: closing the GPC file handle\n" ));
    }
    
    if (NTPlatform && pGlobals->GpcFileHandle) 
    {
        (*CloseNt)( pGlobals->GpcFileHandle );
    }

    IF_DEBUG(SHUTDOWN) {
        WSPRINT(( "<==DeInitializeOsSpecific: exit...\n" ));
    }

}


DWORD
MapNtStatus2WinError(
    NTSTATUS       NtStatus
    )

/*++

Routine Description:

    This procedure maps the ntstatus return codes Winerrors.

Arguments:

    status - status to convert:

Return Value:

    status

--*/

{
    DWORD   stat;

    switch (NtStatus) {

    case    STATUS_SUCCESS:
        stat = NO_ERROR;
        break;

    case    STATUS_INSUFFICIENT_RESOURCES:
        stat = ERROR_NO_SYSTEM_RESOURCES;
        break;

    case    STATUS_BUFFER_OVERFLOW:
        stat = ERROR_MORE_DATA;
        break;

    case    STATUS_INVALID_PARAMETER:
        stat = ERROR_INVALID_PARAMETER;
        break;

    case    STATUS_TRANSACTION_TIMED_OUT:
        stat = ERROR_TIMEOUT;
        break;

    case    STATUS_REQUEST_NOT_ACCEPTED:
        stat = ERROR_NETWORK_BUSY;
        break;

    case    STATUS_NOT_SUPPORTED:
    case        STATUS_UNSUCCESSFUL:
        stat = ERROR_NOT_SUPPORTED;
        break;

    case        STATUS_BUFFER_TOO_SMALL:
        stat = ERROR_INSUFFICIENT_BUFFER;
        break;

    case    STATUS_PENDING:
        stat = ERROR_SIGNAL_PENDING;
        break;

    case    STATUS_OBJECT_NAME_NOT_FOUND:
        stat = ERROR_PATH_NOT_FOUND;
        break;

    case        STATUS_DEVICE_NOT_READY:
      stat = ERROR_NOT_READY;
      break;

    case        STATUS_NOT_FOUND:
      stat = ERROR_NOT_FOUND;
      break;

    case        STATUS_DUPLICATE_NAME:
      stat = ERROR_DUPLICATE_FILTER;
      break;

    case        STATUS_INVALID_HANDLE:
      stat = ERROR_INVALID_HANDLE;
      break;

    case        STATUS_DIRECTORY_NOT_EMPTY:
      stat = ERROR_TC_SUPPORTED_OBJECTS_EXIST;
      break;

    case        STATUS_TOO_MANY_OPENED_FILES:
      stat = ERROR_TOO_MANY_OPEN_FILES;
      break;

    case        STATUS_NOT_IMPLEMENTED:
      stat = ERROR_CALL_NOT_IMPLEMENTED;
      break;

    case        STATUS_DATA_ERROR:
        stat = ERROR_INVALID_DATA;
        break;

    case NDIS_STATUS_INCOMPATABLE_QOS:
        stat = ERROR_INCOMPATABLE_QOS;
        break;

    case QOS_STATUS_INVALID_SERVICE_TYPE:
        stat = ERROR_INVALID_SERVICE_TYPE;
        break;

    case QOS_STATUS_INVALID_TOKEN_RATE:
        stat = ERROR_INVALID_TOKEN_RATE;
        break;

    case QOS_STATUS_INVALID_PEAK_RATE:
        stat = ERROR_INVALID_PEAK_RATE;
        break;

    case QOS_STATUS_INVALID_SD_MODE:
        stat = ERROR_INVALID_SD_MODE;
        break;

    case QOS_STATUS_INVALID_QOS_PRIORITY:
        stat = ERROR_INVALID_QOS_PRIORITY;
        break;

    case QOS_STATUS_INVALID_TRAFFIC_CLASS:
        stat = ERROR_INVALID_TRAFFIC_CLASS;
        break;

    case QOS_STATUS_TC_OBJECT_LENGTH_INVALID:
        stat = ERROR_TC_OBJECT_LENGTH_INVALID;
        break;

    case QOS_STATUS_INVALID_FLOW_MODE:
        stat = ERROR_INVALID_FLOW_MODE;
        break;

    case QOS_STATUS_INVALID_DIFFSERV_FLOW:
        stat = ERROR_INVALID_DIFFSERV_FLOW;
        break;

    case QOS_STATUS_DS_MAPPING_EXISTS:
        stat = ERROR_DS_MAPPING_EXISTS;
        break;

    case QOS_STATUS_INVALID_SHAPE_RATE:
        stat = ERROR_INVALID_SHAPE_RATE;
        break;

    case STATUS_NETWORK_UNREACHABLE:
        stat = ERROR_NETWORK_UNREACHABLE;
        break;

    case QOS_STATUS_INVALID_DS_CLASS:
        stat = ERROR_INVALID_DS_CLASS;
        break;

    case ERROR_TOO_MANY_OPEN_FILES:
    	stat = ERROR_TOO_MANY_CLIENTS;
    	break;

    default:
        stat = ERROR_GEN_FAILURE;

    }

    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\precomp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the main include file for traffic.dll

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

	Ofer Bar ( oferbar )     Oct 1, 1996 - Revision II changes

--*/

#ifndef __TRAFF_PRECOMP
#define __TRAFF_PRECOMP

#define UNICODE

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>

#include<tdi.h>
#include<tdiinfo.h>
#include<ntddtcp.h>
#include<ntddip.h>
#include<stdlib.h>
#include<string.h>
#include<ctype.h>
#include<stdarg.h>
#include<tchar.h>
#include<windows.h>

#include<winsock2.h>
#include<iprtrmib.h>
#include<ipinfo.h>
#include<iphlpstk.h>

#include <tcerror.h>
#include <wmium.h>
#include <ntddndis.h>

//
// traffic control include files
//
//#include"tcifx.h"

#include"refcnt.h"
#include"traffic.h"
#include"tcmacro.h"
#include"handfact.h"
#include"gpcifc.h"
#include"gpcstruc.h"
#include"ntddtc.h"
#include"tctypes.h"
#include"tcfwd.h"
#include"dbgmem.h"
#include"oscode.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\oscode.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    oscode.h

Abstract:

    This module contains the header definitions for NT support routines 
    for talking to the kernel on NT systems.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

	Ofer Bar ( oferbar )     Oct 1, 1996 - Revision II changes

--*/

#ifndef __OSCODE_H
#define __OSCODE_H

DWORD
MapNtStatus2WinError(
    NTSTATUS       NtStatus
    );


DWORD
OpenDriver(
    OUT HANDLE  *Handle,
    IN  LPCWSTR DriverName
    );

DWORD
DeviceControl(
    IN  HANDLE  			FileHandle,
    IN  HANDLE				EventHandle,
    IN  PIO_APC_ROUTINE		ApcRoutine,
    IN	PVOID				ApcContext,
    OUT	PIO_STATUS_BLOCK 	pIoStatusBlock,
    IN  ULONG   			Ioctl,
    IN  PVOID   			setBuffer,
    IN  ULONG   			setBufferSize,
    IN  PVOID   			OutBuffer,
    IN  ULONG   			OutBufferSize
    );

DWORD
InitializeOsSpecific(VOID);

VOID
DeInitializeOsSpecific(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\t1.c ===
#include "precomp.h"

int
__cdecl
main()
{
    TcSetupInterfaceConfiguration(ADDRESS_TYPE_IP,
                                  TRUE,				// installFlows
                                  TEXT("")
                                  );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\refcnt.h ===
/*++        

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.h

Abstract:


Author:

    Shreedhar Madhavapeddi (ShreeM)    18-October-1998

Revision History:

--*/

#ifndef REFCNT_H
#define REFCNT_H

//
// Reference Count Control Block
//
//  Elements:
//
//  - Count:            number of outstanding references
//  - Instance:      user supplied context 
//  - UserDeleteFunc:   user supplied delete function
//

#define TAG_CNT 12
#define REF_SIG 0x7841eeee

typedef struct
{
    ULONG   Tag;
    LONG    Count;
} REF_TAG;    

typedef struct  reference_count_control
{
    LONG       	        Count;
    PVOID               Instance;
    VOID                (*DeleteHandler)( PVOID );
#if DBG    
    int                 Sig;
    REF_TAG             Tags[TAG_CNT];
    CRITICAL_SECTION    Lock;
#endif     
}
REF_CNT, *PREF_CNT;


VOID    
ReferenceInit 
( 
    IN PREF_CNT pRefCnt, 
    PVOID       InstanceHandle, 
    VOID        (*DeleteHandler)( PVOID ) 
);

VOID
ReferenceAdd
(
    IN 	PREF_CNT  pRefCnt
);

VOID
ReferenceAddCount
(
    IN 	PREF_CNT    pRefCnt,
	IN	UINT	    Count
);

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
);

VOID
ReferenceApiTest
( 
	VOID 
);

#if DBG

VOID ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag);
VOID ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag);

#define REFADD(Rc, Tag)     ReferenceAddDbg(Rc, Tag)
#define REFDEL(Rc, Tag)     ReferenceRemoveDbg(Rc, Tag)

#else

#define REFADD(Rc, Tag)  ReferenceAdd(Rc);
#define REFDEL(Rc, Tag)  ReferenceRemove(Rc);

#endif

#define RefInitLock( _s1 )    InitializeCriticalSection( &(_s1)) 

#define RefDeleteLock( _s1 )  DeleteCriticalSection( &(_s1))

#define RefGetLock( _s1 )     EnterCriticalSection( &(_s1)) 

#define RefFreeLock(_s1)  LeaveCriticalSection( &(_s1)) 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\tcfwd.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tcfwd.h

Abstract:

    This module contains the forward function definitions for all the functions in
    the traffic control dll.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

	Ofer Bar (oferbar)     Oct 1, 1997 - Revision II

--*/

#ifndef __TCFWD_H
#define __TCFWD_H

//
// tckrnl.c
//



DWORD
IoModifyFlow(
    IN  PFLOW_STRUC	pFlow,
    IN  BOOLEAN		Async
    );

DWORD
IoAddFlow(
    IN  PFLOW_STRUC	pFlow,
    IN  BOOLEAN		Async
    );

DWORD
IoAddClassMapFlow(
    IN  PFLOW_STRUC	pFlow,
    IN  BOOLEAN		Async
    );

DWORD
IoDeleteFlow(
    IN  PFLOW_STRUC	pFlow,
    IN  BOOLEAN		Async
    );

DWORD
IoAddFilter(
    IN  PFILTER_STRUC	pFilter
    );

DWORD
IoDeleteFilter(
    IN  PFILTER_STRUC	pFilter
    );

DWORD
IoRegisterClient(
    IN  PGPC_CLIENT	pGpcClient
    );

DWORD
IoDeregisterClient(
    IN  PGPC_CLIENT	pGpcClient
    );

DWORD
IoEnumerateFlows(
	IN		PGPC_CLIENT				pGpcClient,
    IN OUT	PHANDLE					pEnumHandle,
    IN OUT	PULONG					pFlowCount,
    IN OUT	PULONG					pBufSize,
    OUT		PGPC_ENUM_CFINFO_RES 	*ppBuffer
    );

DWORD
IoRequestNotify(
	VOID
    //IN  PGPC_CLIENT	pGpcClient
    );

VOID
CancelIoRequestNotify(
	VOID
    );

DWORD
StartGpcNotifyThread();

DWORD
StopGpcNotifyThread();

//
// tcutils.c
//

VOID
WsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );

VOID
WsPrintf (
    char *Format,
    ...
    );

VOID
SetupDebugInfo( void );

VOID
CloseDbgFile( void );



//
// handles.c
//

PVOID
GetHandleObjectWithRef(
	IN  HANDLE					h,
    IN  ENUM_OBJECT_TYPE	    ObjType,
    IN  ULONG                   RefType
    );

PVOID
GetHandleObject(
	IN  HANDLE				h,
    IN  ENUM_OBJECT_TYPE	ObjType
    );

HANDLE
AllocateHandle(
    IN  PVOID 	Context
    );

VOID
FreeHandle(
    IN HANDLE   Handle
    );

//
// apiutil.c
//

VOID
MarkAllNodesForClosing(
                      PINTERFACE_STRUC pInterface,
                      STATE stateToMark
                      );

PTC_IFC
GetTcIfc(
	IN LPWSTR	pInterfaceName
    );

PTC_IFC
GetTcIfcWithRef(
        IN LPWSTR       pInterfaceName,
        IN ULONG        RefType
    );

DWORD
UpdateTcIfcList(
	IN	LPWSTR					InstanceName,
    IN	ULONG					IndicationBufferSize,
    IN  PTC_INDICATION_BUFFER	IndicationBuffer,
    IN  DWORD					IndicationCode
    );

DWORD
CreateClientStruc(
	IN  HANDLE ClRegCtx,
    OUT PCLIENT_STRUC *ppClient
    );

DWORD
CreateClInterfaceStruc(
	IN  HANDLE 		   		ClIfcCtx,
    OUT PINTERFACE_STRUC 	*ppClIfc
    );

DWORD
CreateFlowStruc(
	IN  HANDLE 			ClFlowCtx,
    IN  PTC_GEN_FLOW	pGenFlow,
    OUT PFLOW_STRUC 	*ppFlow
    );

DWORD
CreateClassMapFlowStruc(
	IN  HANDLE 				ClFlowCtx,
    IN  PTC_CLASS_MAP_FLOW	pClassMapFlow,
    OUT PFLOW_STRUC 		*ppFlow
    );

DWORD
CreateFilterStruc(
	IN	PTC_GEN_FILTER	pGenericFilter,
    IN  PFLOW_STRUC		pFlow,
    IN	PFILTER_STRUC	*ppFiler
);

VOID
DeleteFlowStruc(
    IN PFLOW_STRUC  pFlow
    );

DWORD
EnumAllInterfaces(VOID);


DWORD
CloseInterface(
    IN  PINTERFACE_STRUC	pInterface,
    IN	BOOLEAN				RemoveFlows
    );

PGPC_CLIENT
FindGpcClient(
	IN  ULONG  	CfInfoType
    );

VOID
CloseOpenFlows(
    IN PINTERFACE_STRUC   pInterface
    );

DWORD
DeleteFlow(
    IN PFLOW_STRUC  	pFlow,
    IN BOOLEAN			RemoveFilters
    );

DWORD
DeleteFilter(
    IN PFILTER_STRUC  	pFilter
    );

VOID
DeleteFilterStruc(
    IN PFILTER_STRUC  pFilter
    );

VOID
CompleteAddFlow(
	IN	PFLOW_STRUC		pFlow,
    IN	DWORD			Status
    );

VOID
CompleteAddClassMapFlow(
	IN	PFLOW_STRUC		pFlow,
    IN	DWORD			Status
    );

VOID
CompleteModifyFlow(
	IN	PFLOW_STRUC		pFlow,
    IN	DWORD			Status
    );

VOID
CompleteDeleteFlow(
	IN	PFLOW_STRUC		pFlow,
    IN	DWORD			Status
    );

DWORD
OpenGpcClients(
    IN	ULONG	CfInfoType
    );

DWORD
DereferenceInterface(
	IN	PINTERFACE_STRUC	pInterface
    );

DWORD
DereferenceFlow(
	IN	PFLOW_STRUC	pFlow
    );

DWORD
DereferenceFilter(
	IN	PFILTER_STRUC	pFilter
    );

DWORD
DereferenceClient(
	IN	PCLIENT_STRUC	pClient
    );


DWORD
GetInterfaceIndex(
	IN  PADDRESS_LIST_DESCRIPTOR pAddressListDesc,
    OUT  PULONG pInterfaceIndex,
    OUT PULONG pSpecificLinkCtx
    );

DWORD
CreateKernelInterfaceStruc(
                           OUT PTC_IFC        *ppTcIfc,
                           IN  DWORD          AddresssLength
                           );

DWORD
DereferenceKernelInterface(
                           PTC_IFC        pTcIfc
                           );



//
// tcglob.c
//

DWORD
InitializeGlobalData();

VOID
DeInitializeGlobalData();


//
// callback.c
//

VOID
NTAPI CbAddFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
NTAPI CbModifyFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
NTAPI CbDeleteFlowComplete(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
NTAPI CbGpcNotifyRoutine(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
CbParamNotifyClient(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    );

VOID
CbInterfaceNotifyClient(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    );

//
// tcwmi.c
//

DWORD
InitializeWmi(VOID);

DWORD
DeInitializeWmi(VOID);

VOID
CbWmiParamNotification(
   IN  PWNODE_HEADER WnodeHeader,
   IN  ULONG Index
   );

VOID
CbWmiInterfaceNotification(
   IN  PWNODE_HEADER WnodeHeader,
   IN  ULONG Index
   );

DWORD
WalkWnode(
   IN  PWNODE_HEADER 			pWnodeHdr,
   IN  ULONG 					Context,
   IN  CB_PER_INSTANCE_ROUTINE	CbPerInstance
   );

//
// tcutils.c
//

ULONG
LockedDec(
    IN  PULONG  Count
    );


//
// tcnotify.c
//
ULONG
TcipAddToNotificationList(
                          IN LPGUID             Guid,
                          IN PINTERFACE_STRUC   IfcHandle,
                          IN ULONG              Flags        
                          );

ULONG
TcipDeleteFromNotificationList(
                             IN LPGUID              Guid,
                             IN PINTERFACE_STRUC    IfcHandle,
                             IN ULONG               Flags        
                             );

ULONG
TcipClientRegisteredForNotification(
                            IN LPGUID               Guid,
                            IN PINTERFACE_STRUC     IfcHandle,
                            IN ULONG                Flags        
                            );

ULONG
TcipDeleteInterfaceFromNotificationList(
                               IN PINTERFACE_STRUC    IfcHandle,
                               IN ULONG               Flags        
                               );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\refcnt.c ===
/*++                                                                       

Copyright (c) 1996  Microsoft Corporation

Module Name:

    refcnt.c

Abstract:

    This module exports Reference Counting support functions. By 
    including a Reference Count Control Block (REF_CNT) in a
    dynamic type, and using this API, a Reference scheme can be
    implemented for that type.

Author:

    Shreedhar Madhavapeddi (ShreeM)    15-March-1999

Revision History:

--*/

//
// Include Files
//

#include "precomp.h"

#define EXPAND_TAG(t)   ((CHAR *)(&Tag))[0],((CHAR *)(&Tag))[1],((CHAR *)(&Tag))[2],((CHAR *)(&Tag))[3]
VOID
ReferenceInit 
(
    IN PREF_CNT pRefCnt,
    PVOID       InstanceHandle,
    VOID        (*DeleteHandler)( PVOID )
)

/*++

Routine Description:

    ReferenceInit initializes and adds one reference to the
    supplied Reference Control Block. If provided, an instance
    handle and delete handler are saved for use by the ReferenceRemove 
    function when all references to the instance are removed.

Arguments:

    pRefCnt - pointer to uninitialized Reference Control Block
    InstanceHandle - handle to the managed instance.
    DeleteHandler - pointer to delete function, NULL is OK.

Return Value:

    The function's value is VOID.

--*/

{
    IF_DEBUG(REFCOUNTX) { 
        WSPRINT(( "ReferenceInit( 0x%x, 0x%x, 0x%x )\n", 
                  pRefCnt, InstanceHandle, DeleteHandler ));
    }

    ASSERT( pRefCnt );

    // Set the reference to 1 and save the instance 
    // handle and the delete handler.

    pRefCnt->Count         = 0;
    pRefCnt->Instance      = InstanceHandle;
    pRefCnt->DeleteHandler = DeleteHandler;
    
#if DBG
    pRefCnt->Sig = REF_SIG;
    RtlZeroMemory(pRefCnt->Tags, sizeof(REF_TAG) * TAG_CNT);
    pRefCnt->Tags[0].Tag = 'LTOT';
    RefInitLock(pRefCnt->Lock);
#endif
        
}

VOID
ReferenceAdd
( 
    IN  PREF_CNT pRefCnt
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    ASSERT( pRefCnt );

    InterlockedIncrement(&pRefCnt->Count);
    IF_DEBUG(REFCOUNTX) { 
        WSPRINT(( "R+%d\n", pRefCnt->Count ));   
    }
}

VOID
ReferenceAddCount
(
    IN  PREF_CNT    pRefCnt,
    IN  UINT        Count
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    
    ASSERT( pRefCnt->Count > 0 );
    InterlockedExchangeAdd(&pRefCnt->Count, Count);

}

PVOID
ReferenceRemove 
(
    IN PREF_CNT  pRefCnt
)

/*++

Routine Description:
Arguments:
Return Value:


--*/

{
UINT    Count;
UINT    NoReference;
UINT    i;
PVOID   pInstance;

    ASSERT( pRefCnt );

    // Trap remove reference on a zero count
    ASSERT(pRefCnt->Count>0);

    pInstance = pRefCnt->Instance;
    
    //ASSERT( pRefCnt->Count > 0 );

    // If the decremented count is non zero return the instance handle

    if (InterlockedDecrement(&pRefCnt->Count) > 0 ) 
    {
        
        IF_DEBUG(REFCOUNTX) {
            
            WSPRINT(( "R-%d\n", pRefCnt->Count ));        
            WSPRINT(( "ReferenceRemove:remaining: %d\n", pRefCnt->Count ));

        }
#if DBG

        RefFreeLock(pRefCnt->Lock);            

#endif 

        return(pInstance);
    
    }

    // Delete this instance if a delete handler is available
    if( pRefCnt->DeleteHandler )
    {
        

#if DBG
        // sanity check
        for (i = 1; i < TAG_CNT; i++)
        {
            if ((pRefCnt->Tags[i].Tag != 0) && (pRefCnt->Tags[i].Count != 0))
            {
                IF_DEBUG(ERRORS) {
                    WSPRINT(("Allors!! There is a NON-zero ref and we are deleting...\n"));
                }
                DEBUGBREAK();
            }
        }
        


        IF_DEBUG(REFCOUNTX) { 
            WSPRINT(( "Executing DeleteHandler for %X\n", pRefCnt->Instance ));
        }

        //
        // All the Dereference* code takes the locks, so lets take it here.
        // Also, Take the global lock before releasing the ref lock.
        //

        // Time to delete the ref lock too.
        RefFreeLock(pRefCnt->Lock);            
#endif 

        GetLock(pGlobals->Lock);

#if DBG
        RefDeleteLock(pRefCnt->Lock);
#endif 


        (pRefCnt->DeleteHandler)( pRefCnt->Instance );
        FreeLock(pGlobals->Lock);
    
    }

    // Indicate no active references to this instance

    return( NULL );
}

//
// API Test Support
//

#if DBG

VOID
ReferenceApiTest( VOID )
{
REF_CNT  RefCnt;

    IF_DEBUG(REFCOUNTX) {
        WSPRINT(
        ( "\nReferenceApiTest\n" ));

        WSPRINT(( "\nTest #1: NULL delete handler\n" ));
    }

    ReferenceInit( &RefCnt, &RefCnt, NULL );

    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );
    ReferenceAdd( &RefCnt );

    while( ReferenceRemove( &RefCnt ) )
    {
        ;
    }

    IF_DEBUG(REFCOUNTX) {
        WSPRINT(( "\nTest #2: Delete Handler - TBD\n" ));
    }
}

VOID
ReferenceAddDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    int             TotalPerArray = 0;
    
    RefGetLock(pRefCnt->Lock);
    //ASSERT(pRefCnt->Sig == REF_SIG);
    if (pRefCnt->Sig != REF_SIG) {
        DEBUGBREAK();
    }
    
    IF_DEBUG(REFCOUNTX) {
        WSPRINT(("TCREF: add %X (%c%c%c%c) %d\n",
                  pRefCnt, EXPAND_TAG(Tag), pRefCnt->Count));    
    }
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == 0 || pRefCnt->Tags[i].Tag == Tag)
        {
            pRefCnt->Tags[i].Tag = Tag;
            InterlockedIncrement(&pRefCnt->Tags[i].Count);
            break;
        }
    }
    
    
    //ASSERT(i < TAG_CNT);
    if (i >= TAG_CNT) {
        
        DEBUGBREAK();

    }

    ReferenceAdd(pRefCnt);           
    
    InterlockedIncrement(&pRefCnt->Tags[0].Count);
 
    // sanity check
    
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }

    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgBreakPoint();
    }        
    

    
    RefFreeLock(pRefCnt->Lock);
}

VOID
ReferenceRemoveDbg(PREF_CNT pRefCnt, ULONG Tag)
{
    int             i;
    int             TotalPerArray = 0;
    BOOLEAN         FoundIt = FALSE;
    
    RefGetLock(pRefCnt->Lock);

    if (pRefCnt->Sig != REF_SIG) {
        DEBUGBREAK();
    }

    //ASSERT(pRefCnt->Sig == REF_SIG);

    IF_DEBUG(REFCOUNTX) { 
        WSPRINT(("TCREF: remove %X (%c%c%c%c) %d\n",
                 pRefCnt, EXPAND_TAG(Tag), pRefCnt->Count));
    }
             
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag == Tag)
        {
            FoundIt = TRUE;
            
            if(pRefCnt->Tags[i].Count <= 0) {
                
                DEBUGBREAK();

            }
            //ASSERT(pRefCnt->Tags[i].Count > 0);
            InterlockedDecrement(&pRefCnt->Tags[i].Count);
            if (pRefCnt->Tags[i].Count == 0)
                pRefCnt->Tags[i].Tag = Tag; 
            break;
        }
    }

    if (!FoundIt) {
        DEBUGBREAK();
    }
    
    ASSERT(FoundIt);
  
    ASSERT(pRefCnt->Tags[0].Count > 0);
      
    InterlockedDecrement(&pRefCnt->Tags[0].Count);

    // sanity check
    for (i = 1; i < TAG_CNT; i++)
    {
        if (pRefCnt->Tags[i].Tag != 0)
        {
            TotalPerArray += pRefCnt->Tags[i].Count;
            continue;
        }
    }
    
    ASSERT(TotalPerArray == pRefCnt->Tags[0].Count);
    
    if (TotalPerArray != pRefCnt->Tags[0].Count)
    {
        DbgPrint("Tag %X, RefCnt %X, perArray %d, total %d\n", Tag, pRefCnt,
                  TotalPerArray, pRefCnt->Tags[0].Count);
                  
        DbgBreakPoint();
    }    
    

    
    ReferenceRemove(pRefCnt);        
    

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\tcnotify.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tcnotify.c

Abstract:

    This module contains the notification interaction with WMI

Author:

    Shreedhar Madhavapeddi ( shreem )   Jan 12, 1999.

Revision History:

--*/

#include "precomp.h"


int 
IsEqualGUIDx(
                LPGUID guid1, 
                LPGUID guid2
                )
{
    return !memcmp(guid1, guid2, sizeof(GUID));
}

//
// Add the guid/ifchandle to the NotificationList.
// Although it shouldn't happen - check for dupes before adding it.
// Interface handle leads to Client handle 
// 
ULONG
TcipAddToNotificationList(
                          IN LPGUID             Guid,
                          IN PINTERFACE_STRUC   IfcHandle,
                          IN ULONG              Flags        
                          )
{
    PLIST_ENTRY             pCurrent;
    PNOTIFICATION_ELEMENT   pNotifyElem, pNewElem;
    int i = 0;
    //
    // Take the List Lock.
    // 
    pNotifyElem = NULL;
    GetLock(NotificationListLock);
    pCurrent = NotificationListHead.Flink;

    while (&NotificationListHead != pCurrent) {
        
        pNotifyElem = CONTAINING_RECORD(pCurrent, NOTIFICATION_ELEMENT, Linkage.Flink);
        
        if ((pNotifyElem->IfcHandle != IfcHandle) || 
            (FALSE == IsEqualGUIDx(&pNotifyElem->NotificationGuid, Guid))) {
            
            pCurrent = pNotifyElem->Linkage.Flink;

        } else {
            
            //
            // We found a guid/ifchandle combo already!
            
            //DEBUGBREAK();
            goto exit;

        }

        
    }

    //
    // If we are here, we couldnt find the GUID/IfcHAndle combo
    // Allocate a new element and add it to the list, return TRUE;
    //
    
    AllocMem(&pNewElem, sizeof(NOTIFICATION_ELEMENT));
    if (!pNewElem) {
        
        // cant alloc memory;
        goto exit;

    }
    pNewElem->IfcHandle = IfcHandle;
    pNewElem->NotificationGuid      = *Guid;

    InsertHeadList(&NotificationListHead, &pNewElem->Linkage);
    FreeLock(NotificationListLock);
    return TRUE;

exit:

    FreeLock(NotificationListLock);
    return FALSE;
}

//
// Remove the guid/ifchandle from the NotificationListHead.
// If DBG - check for more than one entries.
// 
ULONG
TcipDeleteFromNotificationList(
                             IN LPGUID              Guid,
                             IN PINTERFACE_STRUC    IfcHandle,
                             IN ULONG               Flags        
                             )
{

    PLIST_ENTRY             pCurrent;
    PNOTIFICATION_ELEMENT   pNotifyElem;


    pNotifyElem = NULL;

    GetLock(NotificationListLock);
    pCurrent = NotificationListHead.Flink;

    while (&NotificationListHead != pCurrent) {

        pNotifyElem = CONTAINING_RECORD(pCurrent, NOTIFICATION_ELEMENT, Linkage.Flink);
        
        if ((pNotifyElem->IfcHandle == IfcHandle) && 
            (TRUE == IsEqualGUIDx(&pNotifyElem->NotificationGuid, Guid))) {
            
            //
            // We found the guid/ifchandle combo - remove it.
            RemoveEntryList(&pNotifyElem->Linkage);
            FreeMem(pNotifyElem);
            break;



        } else {

            pCurrent = pNotifyElem->Linkage.Flink;            

        }

    }

    FreeLock(NotificationListLock);
    return TRUE;

}

// Take a Interface & GUID that has a notification from WMI, and
// find if this Client registered to be notified.
ULONG
TcipClientRegisteredForNotification(
                            IN LPGUID               Guid,
                            IN PINTERFACE_STRUC     IfcHandle,
                            IN ULONG                Flags        
                            )
{
    PLIST_ENTRY             pCurrent;
    PNOTIFICATION_ELEMENT   pNotifyElem;

    pNotifyElem = NULL;

    // make sure the list doesn't change under us.
    GetLock(NotificationListLock);
    pCurrent = NotificationListHead.Flink;

    while (&NotificationListHead != pCurrent) {
        
        pNotifyElem = CONTAINING_RECORD(pCurrent, NOTIFICATION_ELEMENT, Linkage.Flink);
        
        if ((pNotifyElem->IfcHandle == IfcHandle) && 
            (IsEqualGUIDx(&pNotifyElem->NotificationGuid, Guid))) {

            FreeLock(NotificationListLock);
            return TRUE;
        }

        pCurrent = pNotifyElem->Linkage.Flink;
    
    }

    FreeLock(NotificationListLock);

    return FALSE;

}

//
// Remove the guid/ifchandle from the NotificationListHead.
// 
ULONG
TcipDeleteInterfaceFromNotificationList(
                                        IN PINTERFACE_STRUC    IfcHandle,
                                        IN ULONG               Flags        
                                        )
{

    PLIST_ENTRY             pCurrent;
    PNOTIFICATION_ELEMENT   pNotifyElem;

    pNotifyElem = NULL;
    ASSERT(IfcHandle);
    
    GetLock(NotificationListLock);
    pCurrent = NotificationListHead.Flink;

    while (&NotificationListHead != pCurrent) {

        pNotifyElem = CONTAINING_RECORD(pCurrent, NOTIFICATION_ELEMENT, Linkage.Flink);
        
        if (pNotifyElem->IfcHandle == IfcHandle) {
            
            pCurrent = pNotifyElem->Linkage.Flink;            
            
            //
            // We found the guid/ifchandle combo - remove it.
            RemoveEntryList(&pNotifyElem->Linkage);
            FreeMem(pNotifyElem);

        } else {

            pCurrent = pNotifyElem->Linkage.Flink;            

        }

    }


    FreeLock(NotificationListLock);
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\tcglob.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tcglob.c

Abstract:

    This module contains global variables.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// global data
//
ULONG       DebugMask = 0;
BOOL        NTPlatform = FALSE;
LPWSCONTROL WsCtrl = NULL;




BOOL
InitializeGlobalData()

/*++

Description:
    This routine initializes the global data.

Arguments:

    none

Return Value:

    none

--*/
{

    DebugMask = DEBUG_FILE | DEBUG_LOCKS;
    InterfaceHandleTable = 0;

    InitializeListHead( &InterfaceList );

    InitLock( InterfaceListLock );

    INIT_DBG_MEMORY();

    return( TRUE );

}

VOID
DeInitializeGlobalData()

/*++

Description:
    This routine de-initializes the global data.

Arguments:

    none

Return Value:

    none

--*/
{

    InterfaceHandleTable = 0;

    DeleteLock( InterfaceListLock );

    DEINIT_DBG_MEMORY();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\tckrnl.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tckrnl.c

Abstract:

    This module contains routines that talk to the kernel

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

	Ofer Bar (oferbar)		Oct 1, 1997

--*/

#include "precomp.h"
#pragma hdrstop

//
// we use this mutex to synchronous start up with other traffic.dll's
//
const   UCHAR   TrafficSyncMutex[] = "_TRAFFIC_CTL_MUTEX";


HANDLE  hGpcNotifyThread = NULL;
HANDLE  hGpcNotifyStopEvent = NULL;
HANDLE  hGpcNotifyThreadStoppedEvent = NULL;


DWORD
IoAddFlow(
    IN  PFLOW_STRUC  	pFlow,
    IN  BOOLEAN			Async
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to add a flow.

Arguments:


Return Value:

    status

--*/

{
    DWORD					Status = NO_ERROR;
    PCLIENT_STRUC			pClient = pFlow->pInterface->pClient;
    PTC_IFC					pTcIfc = pFlow->pInterface->pTcIfc;
    PCF_INFO_QOS            Kflow;
    PGPC_ADD_CF_INFO_REQ    GpcReq;
    PGPC_ADD_CF_INFO_RES    GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    ULONG					CfInfoSize;
    PIO_APC_ROUTINE			pCbRoutine = NULL;
    ULONG					l;
    HANDLE					hEvent = NULL;

    //
    // allocate memory for a CF_INFO struct to be passed to the GPC. 
    //

    ASSERT(pFlow->pGenFlow);

    pFlow->GpcHandle = NULL;

    l = pFlow->GenFlowLen;
    ASSERT(l > 0);
    CfInfoSize = l + FIELD_OFFSET(CF_INFO_QOS, GenFlow);
        
    InBuffSize = sizeof(GPC_ADD_CF_INFO_REQ) + CfInfoSize;        

    //
    // And for the return info...
    //

    OutBuffSize = sizeof(GPC_ADD_CF_INFO_RES);

    AllocMem(&GpcRes, OutBuffSize);
    pFlow->CompletionBuffer = (PVOID)GpcRes;
    AllocMem(&GpcReq, InBuffSize);
        
    if (GpcRes && GpcReq) {

        RtlZeroMemory(GpcRes, OutBuffSize);
        RtlZeroMemory(GpcReq, InBuffSize);
    
        //
        // fill in the flow information
        //

        GpcReq->ClientHandle = pFlow->pGpcClient->GpcHandle;
        GpcReq->ClientCfInfoContext = pFlow;
        GpcReq->CfInfoSize = CfInfoSize;

        Kflow = (PCF_INFO_QOS)&GpcReq->CfInfo;

        //
        // fill the instance name
        //

        Kflow->InstanceNameLength = (USHORT) pTcIfc->InstanceNameLength;
        RtlCopyMemory(Kflow->InstanceName, 
                      pTcIfc->InstanceName,
                      pTcIfc->InstanceNameLength * sizeof(WCHAR));

        //
        // set the flow flags
        //
        Kflow->Flags = pFlow->UserFlags;

        //
        // copy the generic flow parameter
        //

        RtlCopyMemory(&Kflow->GenFlow,
                      pFlow->pGenFlow,
                      l);


        if (pClient->ClHandlers.ClAddFlowCompleteHandler && Async) {
            pCbRoutine = CbAddFlowComplete;
        } else {
            hEvent = pFlow->PendingEvent;
        }

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                hEvent,
                                pCbRoutine,
                                (PVOID)pFlow,
                                &pFlow->IoStatBlock,
                                IOCTL_GPC_ADD_CF_INFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);


        if (!ERROR_FAILED(Status)) {

            if (hEvent && Status == ERROR_SIGNAL_PENDING) {

                //
                // wait for the event to signal
                //
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: Waiting for event 0x%X...\n", 
                             PtrToUlong(hEvent)));
                }

                Status = WaitForSingleObject(hEvent,
                                             INFINITE
                                             );
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: ... Event 0x%X signaled, Status=0x%X\n", 
                             PtrToUlong(hEvent), Status));
                }

            }

            if (Status == NO_ERROR) {

                Status = MapNtStatus2WinError(GpcRes->Status);

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: GpcRes returned=0x%X mapped to =0x%X\n", 
                             GpcRes->Status, Status));
                }
            }
            
            if (ERROR_SUCCESS == Status) {

                ASSERT(GpcRes->GpcCfInfoHandle);
                
                pFlow->GpcHandle = GpcRes->GpcCfInfoHandle;

                pFlow->InstanceNameLength = GpcRes->InstanceNameLength;

                RtlCopyMemory(pFlow->InstanceName,
                              GpcRes->InstanceName,
                              GpcRes->InstanceNameLength
                              );

                pFlow->InstanceName[pFlow->InstanceNameLength/sizeof(WCHAR)] = L'\0';

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: Flow Handle=%d Name=%S\n", 
                             pFlow->GpcHandle,
                             pFlow->InstanceName));
                }
            }
        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // No, it's not a bug
    // GpcRes will be release in CompleteAddFlow
    //

    if (GpcReq)
        FreeMem(GpcReq);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoAddFlow: Status=0x%X\n", 
                 Status));
    }

    return Status;
}



DWORD
IoAddClassMapFlow(
    IN  PFLOW_STRUC  	pFlow,
    IN  BOOLEAN			Async
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to add a flow.

Arguments:


Return Value:

    status

--*/

{
    DWORD					Status = NO_ERROR;
    PCLIENT_STRUC			pClient = pFlow->pInterface->pClient;
    PTC_IFC					pTcIfc = pFlow->pInterface->pTcIfc;
    PCF_INFO_CLASS_MAP      Kflow;
    PGPC_ADD_CF_INFO_REQ    GpcReq;
    PGPC_ADD_CF_INFO_RES    GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    ULONG					CfInfoSize;
    PIO_APC_ROUTINE			pCbRoutine = NULL;
    ULONG					l;
    HANDLE					hEvent = NULL;

    return ERROR_CALL_NOT_IMPLEMENTED;

#if NEVER

    // As this is not published in MSDN and not implemented in PSCHED also
    //
    // allocate memory for a CF_INFO struct to be passed to the GPC. 
    //

    ASSERT(pFlow->pClassMapFlow);

    pFlow->GpcHandle = NULL;

    l = sizeof(TC_CLASS_MAP_FLOW) + pFlow->pClassMapFlow->ObjectsLength;
    CfInfoSize = l + FIELD_OFFSET(CF_INFO_CLASS_MAP, ClassMapInfo);
        
    InBuffSize = sizeof(GPC_ADD_CF_INFO_REQ) + CfInfoSize;

    //
    // And for the return info...
    //

    OutBuffSize = sizeof(GPC_ADD_CF_INFO_RES);

    AllocMem(&GpcRes, OutBuffSize);
    pFlow->CompletionBuffer = (PVOID)GpcRes;
    AllocMem(&GpcReq, InBuffSize);

    if (GpcRes && GpcReq) {

        RtlZeroMemory(GpcRes, OutBuffSize);
        RtlZeroMemory(GpcReq, InBuffSize);
    
        //
        // fill in the flow information
        //

        GpcReq->ClientHandle = pFlow->pGpcClient->GpcHandle;
        GpcReq->ClientCfInfoContext = pFlow;
        GpcReq->CfInfoSize = CfInfoSize;

        Kflow = (PCF_INFO_CLASS_MAP)&GpcReq->CfInfo;

        //
        // fill the instance name
        //

        Kflow->InstanceNameLength = (USHORT) pTcIfc->InstanceNameLength;
        RtlCopyMemory(Kflow->InstanceName, 
                      pTcIfc->InstanceName,
                      pTcIfc->InstanceNameLength * sizeof(WCHAR));

        //
        // copy the generic flow parameter
        //

        RtlCopyMemory(&Kflow->ClassMapInfo,
                      pFlow->pClassMapFlow,
                      l);


        if (pClient->ClHandlers.ClAddFlowCompleteHandler && Async) {
            pCbRoutine = CbAddFlowComplete;
        } else {
            hEvent = pFlow->PendingEvent;
        }

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                hEvent,
                                pCbRoutine,
                                (PVOID)pFlow,
                                &pFlow->IoStatBlock,
                                IOCTL_GPC_ADD_CF_INFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);


        if (!ERROR_FAILED(Status)) {

            if (hEvent && Status == ERROR_SIGNAL_PENDING) {

                //
                // wait for the event to signal
                //
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddClassMapFlow: Waiting for event 0x%X...\n", 
                             PtrToUlong(hEvent)));
                }

                Status = WaitForSingleObject(hEvent,
                                             INFINITE
                                             );
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddClassMapFlow: ... Event 0x%X signaled, Status=0x%X\n", 
                             PtrToUlong(hEvent), Status));
                }

            }

            if (Status == NO_ERROR) {

                Status = MapNtStatus2WinError(GpcRes->Status);

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFlow: GpcRes returned=0x%X mapped to =0x%X\n", 
                             GpcRes->Status, Status));
                }
            }
            
            if (!ERROR_FAILED(Status)) {

                ASSERT(GpcRes->GpcCfInfoHandle);
                
                pFlow->GpcHandle = GpcRes->GpcCfInfoHandle;

                pFlow->InstanceNameLength = GpcRes->InstanceNameLength;

                RtlCopyMemory(pFlow->InstanceName,
                              GpcRes->InstanceName,
                              GpcRes->InstanceNameLength
                              );

                pFlow->InstanceName[pFlow->InstanceNameLength/sizeof(WCHAR)] = L'\0';

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddClassMapFlow: Flow Handle=%d Name=%S\n", 
                             pFlow->GpcHandle,
                             pFlow->InstanceName));
                }
            }
        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // No, it's not a bug
    // GpcRes will be release in CompleteAddFlow
    //

    if (GpcReq)
        FreeMem(GpcReq);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoAddClassMapFlow: Status=0x%X\n", 
                 Status));
    }

    return Status;

#endif
}



DWORD
IoModifyFlow(
    IN  PFLOW_STRUC  	pFlow,
    IN  BOOLEAN			Async
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to modify a flow.

Arguments:

	pFlow

Return Value:

    status

--*/

{
    DWORD                	Status = NO_ERROR;
    PCLIENT_STRUC			pClient = pFlow->pInterface->pClient;
    PTC_IFC					pTcIfc = pFlow->pInterface->pTcIfc;
    PCF_INFO_QOS            Kflow;
    PGPC_MODIFY_CF_INFO_REQ GpcReq;
    PGPC_MODIFY_CF_INFO_RES GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    ULONG					CfInfoSize;
    PIO_APC_ROUTINE			pCbRoutine = NULL;
    ULONG					l;
    HANDLE					hEvent = NULL;

    //
    // allocate memory for a CF_INFO struct to be passed to the GPC. 
    //

    ASSERT(pFlow->pGenFlow1);

    l = pFlow->GenFlowLen1;
    ASSERT(l > 0);
    CfInfoSize = l + FIELD_OFFSET(CF_INFO_QOS, GenFlow);
        
    InBuffSize = sizeof(GPC_MODIFY_CF_INFO_REQ) + CfInfoSize;        

    //
    // And for the return info...
    //

    OutBuffSize = sizeof(GPC_MODIFY_CF_INFO_RES);

    AllocMem(&GpcRes, OutBuffSize);
    pFlow->CompletionBuffer = (PVOID)GpcRes;
    AllocMem(&GpcReq, InBuffSize);

    if (GpcRes && GpcReq) {

        RtlZeroMemory(GpcRes, OutBuffSize);
        RtlZeroMemory(GpcReq, InBuffSize);
    
        //
        // fill in the flow information
        //

        GpcReq->ClientHandle = pFlow->pGpcClient->GpcHandle;
        GpcReq->GpcCfInfoHandle = pFlow->GpcHandle;
        GpcReq->CfInfoSize = CfInfoSize;

        Kflow = (PCF_INFO_QOS)&GpcReq->CfInfo;

        //
        // fill the instance name
        //

        Kflow->InstanceNameLength = (USHORT) pTcIfc->InstanceNameLength;
        RtlCopyMemory(Kflow->InstanceName, 
                      pTcIfc->InstanceName,
                      pTcIfc->InstanceNameLength * sizeof(WCHAR));

        //
        // copy the generic flow parameter
        //

        RtlCopyMemory(&Kflow->GenFlow,
                      pFlow->pGenFlow1,
                      l);

                      
        if (pClient->ClHandlers.ClModifyFlowCompleteHandler && Async) {
            pCbRoutine = CbModifyFlowComplete;
        } else {
            hEvent = pFlow->PendingEvent;
        }

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                hEvent,
                                pCbRoutine,
                                (PVOID)pFlow,
                                &pFlow->IoStatBlock,
                                IOCTL_GPC_MODIFY_CF_INFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);

        if (!ERROR_FAILED(Status)) {

            if (hEvent && Status == ERROR_SIGNAL_PENDING) {

                //
                // wait for the event to signal
                //
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoModifyFlow: Waiting for event 0x%X\n", 
                             PtrToUlong(hEvent)));
                }

                Status = WaitForSingleObject(hEvent,
                                             INFINITE
                                             );
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoModifyFlow: ... Event 0x%X signaled, Status=0x%X\n",
                             PtrToUlong(hEvent), Status));
                }
            }

            if (Status == NO_ERROR) {

                Status = MapNtStatus2WinError(GpcRes->Status);
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoModifyFlow: GpcRes returned=0x%X mapped to =0x%X\n", 
                             GpcRes->Status, Status));
                }
            }
        } else{

            Status = MapNtStatus2WinError(GpcRes->Status);
            
            IF_DEBUG(IOCTLS) {
                WSPRINT(("IoModifyFlow: GpcRes returned=0x%X mapped to =0x%X\n", 
                         GpcRes->Status, Status));
            }

        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // No, it's not a bug
    // GpcRes will be release in CompleteModifyFlow
    //

    if (GpcReq)
        FreeMem(GpcReq);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("IoModifyFlow: Status=0x%X\n", 
                 Status));
    }

    return Status;
}



DWORD
IoDeleteFlow(
	IN  PFLOW_STRUC		pFlow,
    IN  BOOLEAN			Async
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to delete a flow.
    It then calls a routine to pass this info to the GPC. 

Arguments:

	pFlow

Return Value:

    status

--*/

{
    DWORD               		Status;
    ULONG               		InBuffSize;
    ULONG               		OutBuffSize;
    PGPC_REMOVE_CF_INFO_REQ     GpcReq;
    PGPC_REMOVE_CF_INFO_RES     GpcRes;
    PIO_APC_ROUTINE				pCbRoutine = NULL;
    PCLIENT_STRUC				pClient = pFlow->pInterface->pClient;
    HANDLE						hEvent = NULL;

    if (IS_REMOVED(pFlow->Flags)) {
        
        //
        // this flow has been already deleted in the kernel
        // due to a flow close notification.
        // no need to send IOTCL to GPC, just return OK
        //

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeleteFlow: Flow has already been deleted=0x%X\n", 
                     PtrToUlong(pFlow)));
        }

        return NO_ERROR;
    }

    //
    // If we add this over here, then if WMI deletes the flow, 
    // the user mode call will just return above.
    //
    GetLock(pFlow->Lock);
    pFlow->Flags |= TC_FLAGS_REMOVED;
    FreeLock(pFlow->Lock);

    //
    // allocate memory for in and out buffers
    //

    InBuffSize =  sizeof(GPC_REMOVE_CF_INFO_REQ);
    OutBuffSize = sizeof(GPC_REMOVE_CF_INFO_RES);

    AllocMem(&GpcRes, OutBuffSize);
    pFlow->CompletionBuffer = (PVOID)GpcRes;
    AllocMem(&GpcReq, InBuffSize);

    if (GpcReq && GpcRes){

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeleteFlow: preparing to delete the flow=0x%X\n", 
                     PtrToUlong(pFlow)));
        }

        GpcReq->ClientHandle = pFlow->pGpcClient->GpcHandle;
        GpcReq->GpcCfInfoHandle = pFlow->GpcHandle;

    
        if (pClient->ClHandlers.ClDeleteFlowCompleteHandler && Async) {
            pCbRoutine = CbDeleteFlowComplete;
        } else {
            hEvent = pFlow->PendingEvent;
        }

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                hEvent,
                                pCbRoutine,
                                (PVOID)pFlow,
                                &pFlow->IoStatBlock,
                                IOCTL_GPC_REMOVE_CF_INFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);

        if (!ERROR_FAILED(Status)) {
        
            if (hEvent && Status == ERROR_SIGNAL_PENDING) {

                //
                // wait for the event to signal
                //
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoDeleteFlow: Waiting for event 0x%X\n", 
                             PtrToUlong(hEvent)));
                }

                Status = WaitForSingleObject(hEvent,
                                             INFINITE
                                             );
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoDeleteFlow: ... Event 0x%X signaled, Status=0x%X\n",
                             PtrToUlong(hEvent), Status));
                }
            }

            if (Status == NO_ERROR) {

                Status = MapNtStatus2WinError(GpcRes->Status);

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoDeleteFlow: Gpc returned=0x%X mapped to 0x%X\n", 
                             GpcRes->Status, Status));
                }

                //
                // If the deletion was unsuccessful, let's un-mark the REMOVED flag.
                //
                if (ERROR_FAILED(Status)) {

                    GetLock(pFlow->Lock);
                    pFlow->Flags &= ~TC_FLAGS_REMOVED;
                    FreeLock(pFlow->Lock);

                }

            }
        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // No, it's not a bug
    // GpcRes will be release in CompleteDeleteFlow
    //

    if (GpcReq)
        FreeMem(GpcReq);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoDeleteFlow: Status=0x%X\n", 
                 Status));
    }

    return Status;
}




DWORD
IoAddFilter(
    IN  PFILTER_STRUC	pFilter
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to add a filter.
    It then calls a routine to pass this info to the GPC. 

Arguments:

	pFilter

Return Value:

    status

--*/
{
    DWORD					Status;
    PGPC_ADD_PATTERN_REQ 	GpcReq;
    PGPC_ADD_PATTERN_RES 	GpcRes;
    ULONG               	InBuffSize;
    ULONG               	OutBuffSize;
    PFLOW_STRUC         	pFlow = pFilter->pFlow;
    PTC_GEN_FILTER			pGpcFilter = pFilter->pGpcFilter;
    PUCHAR					p;
    ULONG					PatternSize;
    IO_STATUS_BLOCK			IoStatBlock;

    pFilter->GpcHandle = NULL;

    ASSERT(pGpcFilter);
    ASSERT(pFlow);

    PatternSize = pGpcFilter->PatternSize;

    InBuffSize = sizeof(GPC_ADD_PATTERN_REQ) + 2*PatternSize;
        
    OutBuffSize = sizeof(GPC_ADD_PATTERN_RES);

    AllocMem(&GpcReq, InBuffSize);
    AllocMem(&GpcRes, OutBuffSize);
    
    if (GpcReq && GpcRes){
        
        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoAddFilter: Filling request: size: in=%d, out=%d\n", 
                     InBuffSize, OutBuffSize));
        }

        GpcReq->ClientHandle            = pFlow->pGpcClient->GpcHandle;
        GpcReq->GpcCfInfoHandle         = pFlow->GpcHandle;
        GpcReq->ClientPatternContext    = (GPC_CLIENT_HANDLE)pFilter;
        GpcReq->Priority                = 0;
        GpcReq->PatternSize             = PatternSize;
        GpcReq->ProtocolTemplate		= pFilter->GpcProtocolTemplate;

        //
        // fill in the pattern
        //

        p = (PUCHAR)&GpcReq->PatternAndMask;

        RtlCopyMemory(p, pGpcFilter->Pattern, PatternSize);

        //
        // fill in the mask
        //

        p += PatternSize;

        RtlCopyMemory(p, pGpcFilter->Mask, PatternSize);
        
        Status = DeviceControl( pGlobals->GpcFileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatBlock,
                                IOCTL_GPC_ADD_PATTERN,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);

        if (!ERROR_FAILED(Status)) {

            Status = MapNtStatus2WinError(GpcRes->Status);
            
            IF_DEBUG(IOCTLS) {
                WSPRINT(("IoAddFilter: GpcRes returned=0x%X mapped to =0x%X\n", 
                         GpcRes->Status, Status));
            }
            
            //
            // save the filter handle 
            //

            if (!ERROR_FAILED(Status)) {
                
                pFilter->GpcHandle = GpcRes->GpcPatternHandle;
            
            } else {

                IF_DEBUG(IOCTLS) {
                    WSPRINT(("IoAddFilter: GpcRes returned=0x%X mapped to =0x%X\n", 
                             GpcRes->Status, Status));
                }
                
                IF_DEBUG(IOCTLS) {
                    WSPRINT(("Error - failed the addfilter call\n"));
                }
                
                //ASSERT(Status == ERROR_DUPLICATE_FILTER); removed for WAN - interface up down situation

            }   
            
        }

    } else {
        
        Status = ERROR_NOT_ENOUGH_MEMORY;

        IF_DEBUG(ERRORS) {
            WSPRINT(("IoAddFilter: Error =0x%X\n", 
                     Status));
        }

    }
    
    if (GpcReq)
        FreeMem(GpcReq);
    
    if (GpcRes)
        FreeMem(GpcRes);

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoAddFilter: Returned =0x%X\n", 
                 Status));
    }
            
    return Status;
}




DWORD
IoDeleteFilter(
    IN  PFILTER_STRUC	pFilter
    )

/*++

Routine Description:

    This procedure builds up the structure necessary to delete a filter.
    It then calls a routine to pass this info to the GPC. 

Arguments:

	pFilter

Return Value:

    status

--*/
{
    DWORD						Status;
    ULONG               		InBuffSize;
    ULONG               		OutBuffSize;
    GPC_REMOVE_PATTERN_REQ     	GpcReq;
    GPC_REMOVE_PATTERN_RES     	GpcRes;
    IO_STATUS_BLOCK				IoStatBlock;

    //
    // allocate memory for in and out buffers
    //

    if (IS_REMOVED(pFilter->Flags)) {
        
        //
        // this filter has been already deleted in the kernel
        // due to a flow close notification.
        // no need to send IOTCL to GPC, just return OK
        //

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeleteFilter: Filter has already been deleted=0x%X\n", 
                     PtrToUlong(pFilter)));
        }

        return NO_ERROR;
    }

    //
    // If we add this over here, then if WMI deletes the Interface (and the 
    // flows/filters) the user mode call will just return above.
    //
    GetLock(pFilter->Lock);
    pFilter->Flags |= TC_FLAGS_REMOVED;
    FreeLock(pFilter->Lock);

    InBuffSize = sizeof(GPC_REMOVE_PATTERN_REQ);
    OutBuffSize = sizeof(GPC_REMOVE_PATTERN_RES);

    GpcReq.ClientHandle = pFilter->pFlow->pGpcClient->GpcHandle;
    GpcReq.GpcPatternHandle = pFilter->GpcHandle;
    
    ASSERT(GpcReq.ClientHandle);
    ASSERT(GpcReq.GpcPatternHandle);

    Status = DeviceControl( pGlobals->GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_REMOVE_PATTERN,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );

    if (!ERROR_FAILED(Status)) {
        
        Status = MapNtStatus2WinError(GpcRes.Status);

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeleteFilter: GpcRes returned=0x%X mapped to =0x%X\n", 
                     GpcRes.Status, Status));
        }

        //
        // If the deletion was unsuccessful, let's un-mark the REMOVED flag.
        //
        if (ERROR_FAILED(Status)) {
            
            GetLock(pFilter->Lock);
            pFilter->Flags &= ~TC_FLAGS_REMOVED;
            FreeLock(pFilter->Lock);
        }

    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoDeleteFilter: Status=0x%X\n", 
                 Status));
    }

    return Status;
}




DWORD
IoRegisterClient(
    IN  PGPC_CLIENT	pGpcClient
    )
{
    DWORD  					Status;
    GPC_REGISTER_CLIENT_REQ	GpcReq;
    GPC_REGISTER_CLIENT_RES GpcRes;
    ULONG 					InBuffSize;
    ULONG 					OutBuffSize;
    IO_STATUS_BLOCK			IoStatBlock;

    InBuffSize = sizeof(GPC_REGISTER_CLIENT_REQ);
    OutBuffSize = sizeof(GPC_REGISTER_CLIENT_RES);

    GpcReq.CfId = pGpcClient->CfInfoType;
    GpcReq.Flags = GPC_FLAGS_FRAGMENT;
    GpcReq.MaxPriorities = 1;
    GpcReq.ClientContext = 
        (GPC_CLIENT_HANDLE)UlongToPtr(GetCurrentProcessId());	// process id

    Status = DeviceControl( pGlobals->GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_REGISTER_CLIENT,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize );

    if (!ERROR_FAILED(Status)) {
        
        Status = MapNtStatus2WinError(GpcRes.Status);
        pGpcClient->GpcHandle = GpcRes.ClientHandle;

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoRegisterClient: GpcRes returned=0x%X mapped to =0x%X\n", 
                     GpcRes.Status, Status));
        }
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoRegisterClient: Status=0x%X\n", 
                 Status));
    }

    return Status;
}



DWORD
IoDeregisterClient(
    IN  PGPC_CLIENT	pGpcClient
    )
{
    DWORD						Status;
    GPC_DEREGISTER_CLIENT_REQ   GpcReq;
    GPC_DEREGISTER_CLIENT_RES   GpcRes;
    ULONG 						InBuffSize;
    ULONG 						OutBuffSize;
    IO_STATUS_BLOCK				IoStatBlock;

    InBuffSize = sizeof(GPC_DEREGISTER_CLIENT_REQ);
    OutBuffSize = sizeof(GPC_DEREGISTER_CLIENT_RES);

    GpcReq.ClientHandle = pGpcClient->GpcHandle;

    Status = DeviceControl( pGlobals->GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_DEREGISTER_CLIENT,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );

    if (!ERROR_FAILED(Status)) {
                
        Status = MapNtStatus2WinError(GpcRes.Status);

        IF_DEBUG(IOCTLS) {
            WSPRINT(("IoDeegisterClient: GpcRes returned=0x%X mapped to =0x%X\n", 
                     GpcRes.Status, Status));
        }
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoDeregisterClient: Status=0x%X\n", 
                 Status));
    }

    return Status;
}

PGPC_NOTIFY_REQUEST_RES     GpcResCb;

DWORD
IoRequestNotify(
	VOID
    //IN  PGPC_CLIENT	pGpcClient
    )
/*
  Description:

  	This routine sends a notification request buffer to the GPC.
    The request will pend until the GPC notifies about a flow 
    being deleted. This will cause a callback to CbGpcNotifyRoutine.

*/
{
    DWORD               		Status;
    ULONG               		OutBuffSize;

    //
    // allocate memory for in and out buffers
    //

    OutBuffSize = sizeof(GPC_NOTIFY_REQUEST_RES);

    AllocMem(&GpcResCb, OutBuffSize);

    if (GpcResCb){

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                NULL,
                                CbGpcNotifyRoutine,
                                (PVOID)GpcResCb,
                                &GpcResCb->IoStatBlock,
                                IOCTL_GPC_NOTIFY_REQUEST,
                                NULL,		//GpcReq,
                                0,			//InBuffSize,
                                GpcResCb,
                                OutBuffSize);

        if (ERROR_FAILED(Status)) {
            
            FreeMem(GpcResCb);
            GpcResCb = NULL;
        }
        else if ( ERROR_PENDING(Status) )
        {
            Status = NO_ERROR;
        }
    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoRequestNotify: Buffer=%p Status=0x%X\n", 
                 GpcResCb, Status));
    }

    return Status;
}


VOID
CancelIoRequestNotify()
/*

    Description:
        This routine cancels the IRP in GPC and waits for the pending
        IO to be cancelled. The callback routine set an event when
        IO request is canclled and this routine waits for that event
        before returning.
        
 */
{
    // Non-zero value of GpcResCb indicates a pending IRP
    if (GpcResCb)
    {
        GpcCancelEvent = CreateEvent ( 
                            NULL,
                            FALSE,
                            FALSE,
                            NULL );
        
        if ( CancelIo ( pGlobals->GpcFileHandle ) )
        {
            if ( GpcCancelEvent )
            {
                WaitForSingleObjectEx(
                    GpcCancelEvent,
                    INFINITE,
                    TRUE );        
                    
                CloseHandle ( GpcCancelEvent );
                GpcCancelEvent = NULL;
            }
            else
            {
                IF_DEBUG(IOCTLS) {
                    WSPRINT((
                        "CancelIo: Status=0x%X\n", 
                        GetLastError() ));
                }
            }
        }    
        
        FreeMem(GpcResCb);

        IF_DEBUG(IOCTLS) 
        {
            WSPRINT(("<==CancelIoRequestNotify: Freed %p\n",
                    GpcResCb ));
        }
    }
    
    return;
}

void 
IncrementLibraryUsageCount(
    HINSTANCE   hinst, 
    int         nCount) 
/*

    Utility routine to increment the ref count on
    the TRAFFIC.DLL so that it will not get unloaded
    before the GPCNotify thread gets a chance to run.
    
 */
{
    TCHAR szModuleName[_MAX_PATH];

    memset(szModuleName, 0, sizeof(TCHAR) * _MAX_PATH);

    GetModuleFileName(hinst, szModuleName, _MAX_PATH);

    szModuleName[_MAX_PATH - 1] = 0;
   
    while (nCount--) 
        LoadLibrary(szModuleName);

    return;
}

DWORD
GpcNotifyThreadFunction ()
/*

    This routine registers an IRP with GPC to listen for
    FLOW close notifications and waits for the stop event.
    When the event is signalled the IRP is canceled and this
    thread exits.

    Since the wait is done in an alertable state GPC callbacks
    are executed in this thread itself.
    
 */
{
    DWORD   dwError;
    
    dwError = IoRequestNotify();

    WaitForSingleObjectEx(
        hGpcNotifyStopEvent,
        INFINITE,
        TRUE );        

    CancelIoRequestNotify();

    SetEvent( hGpcNotifyThreadStoppedEvent );

    FreeLibraryAndExitThread(
        hinstTrafficDll, 
        0 );

    return 0;
}

DWORD
StartGpcNotifyThread()
/*

    Description:
        This routine starts a thread which queues an IRP for
        GPC notifications.
    
    
 */
{
    DWORD   dwError = 0;
    DWORD   dwThreadId = 0;

    // Increment the ref count on this DLL so it will not be unloaded
    // before the GpcNotifyThreadFunction gets to run
    IncrementLibraryUsageCount(
        hinstTrafficDll,
        1);    

    // Create the stop event for the thread to receive 
    // GPC flow close notifications
    hGpcNotifyStopEvent = CreateEvent ( 
                            NULL,
                            FALSE,
                            FALSE,
                            NULL );
    if ( !hGpcNotifyStopEvent ) 
    {
        dwError = GetLastError();
        goto Error;
    }

    hGpcNotifyThreadStoppedEvent = CreateEvent (NULL,
                                                FALSE,
                                                FALSE,
                                                NULL );
    if ( !hGpcNotifyThreadStoppedEvent ) 
    {
        dwError = GetLastError();
        goto Error;
    }

    // Start the thread.
    hGpcNotifyThread = CreateThread( 
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE )GpcNotifyThreadFunction,
                            NULL,
                            0,
                            &dwThreadId );
    if ( !hGpcNotifyThread )
    {
        dwError = GetLastError();
        goto Error;
    }

    // Close the thread handle as we don't need it in any case. But, don't set
    // it to NULL because it is used as a check to figure out whether this
    // thread was started or not.
    CloseHandle ( hGpcNotifyThread );
    ASSERT(hGpcNotifyThread  != NULL);
    

    // Not closing the thread handle as StopGpcNotifyThread
    // routine will use this handle to wait for thread to
    // terminate.
    
    return 0;
    
Error:
    
    if ( hGpcNotifyStopEvent )
    {
        CloseHandle ( hGpcNotifyStopEvent );
        hGpcNotifyStopEvent = NULL;
    }
    
    if ( hGpcNotifyThreadStoppedEvent ) {
        CloseHandle ( hGpcNotifyThreadStoppedEvent );
        hGpcNotifyThreadStoppedEvent = NULL;
    }

    if ( hGpcNotifyThread )
    {
        CloseHandle ( hGpcNotifyThread );
        hGpcNotifyThread = NULL;
    }
    
    return dwError;
}


DWORD
StopGpcNotifyThread()
/*
    Description:
        Signal the GPC notification thread to stop
        and wait it to stop.
 */
{
    // If there was no thread created nothing more to do.
    if ( hGpcNotifyThread ) 
    {
    
        // Tell GPC Notify thread to stop
        SetEvent ( hGpcNotifyStopEvent );

        // Wait for it to stop
        WaitForSingleObject ( 
            hGpcNotifyThreadStoppedEvent,
            INFINITE );

        CloseHandle( hGpcNotifyThreadStoppedEvent );
        
        hGpcNotifyThread = NULL;

        CloseHandle ( hGpcNotifyStopEvent );
        
        hGpcNotifyStopEvent = NULL;
    }
    
    return 0;
}



DWORD
IoEnumerateFlows(
	IN		PGPC_CLIENT				pGpcClient,
    IN OUT	PHANDLE					pEnumHandle,
    IN OUT	PULONG					pFlowCount,
    IN OUT	PULONG					pBufSize,
    OUT		PGPC_ENUM_CFINFO_RES 	*ppBuffer
    )
/*
  Description:

  	This routine sends a notification request buffer to the GPC.
    The request will pend until the GPC notifies about a flow 
    being deleted. This will cause a callback to CbGpcNotifyRoutine.

*/
{
    DWORD	Status;
    ULONG               		InBuffSize;
    ULONG               		OutBuffSize;
    PGPC_ENUM_CFINFO_REQ     	GpcReq;
    PGPC_ENUM_CFINFO_RES     	GpcRes;
    IO_STATUS_BLOCK				IoStatBlock;
    
    //
    // allocate memory for in and out buffers
    //

    InBuffSize =  sizeof(GPC_ENUM_CFINFO_REQ);
    OutBuffSize = *pBufSize + FIELD_OFFSET(GPC_ENUM_CFINFO_RES,EnumBuffer);

    *ppBuffer = NULL;

    AllocMem(&GpcRes, OutBuffSize);
    AllocMem(&GpcReq, InBuffSize);

    if (GpcReq && GpcRes) {

        GpcReq->ClientHandle = pGpcClient->GpcHandle;
        GpcReq->EnumHandle = *pEnumHandle;
        GpcReq->CfInfoCount = *pFlowCount;

        Status = DeviceControl( pGlobals->GpcFileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatBlock,
                                IOCTL_GPC_ENUM_CFINFO,
                                GpcReq,
                                InBuffSize,
                                GpcRes,
                                OutBuffSize);

        if (!ERROR_FAILED(Status)) {

            Status = MapNtStatus2WinError(GpcRes->Status);

            IF_DEBUG(IOCTLS) {
                WSPRINT(("IoEnumerateFlows: GpcRes returned=0x%X mapped to =0x%X\n", 
                         GpcRes->Status, Status));
            }

            if (!ERROR_FAILED(Status)) {

                *pEnumHandle = GpcRes->EnumHandle;
                *pFlowCount = GpcRes->TotalCfInfo;
                *pBufSize = (ULONG)IoStatBlock.Information - 
                    FIELD_OFFSET(GPC_ENUM_CFINFO_RES,EnumBuffer);
                *ppBuffer = GpcRes;
            }
        }

    } else {

        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (GpcReq)
        FreeMem(GpcReq);

    if (ERROR_FAILED(Status)) {

        //
        // free GpcReq only if there was an error
        //

        if (GpcRes)
            FreeMem(GpcRes);
    }

    IF_DEBUG(IOCTLS) {
        WSPRINT(("<==IoEnumerateFlows: Status=0x%X\n", 
                 Status));
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\tcmacro.h ===
/*++
Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    rsvp.h

Abstract:

    This code contains the macros definitions for rsvp.sys

Author:

    Jim Stewart (JStew) June 12, 1996

Environment:

    Kernel mode

Revision History:

--*/

#ifndef __TCMACRO_H
#define __TCMACRO_H

#if DBG


#define WSPRINT( stuff )     WsPrintf stuff
#define SETUP_DEBUG_INFO     SetupDebugInfo
#define CLOSE_DEBUG          CloseDbgFile
#define DUMP_MEM_ALLOCATIONS DumpAllocatedMemory
#define INIT_DBG_MEMORY      InitDebugMemory
#define DEINIT_DBG_MEMORY    DeInitDebugMemory

#define IF_DEBUG( _ErrLevel ) if ( (DebugMask & DEBUG_ ## _ErrLevel ) != 0 )

#define TC_TRACE(_ErrLevel, String) if((DebugMask & DEBUG_ ## _ErrLevel) != 0) WsPrintf String

#define IF_DEBUG_CHECK(_status,_ErrLevel) if ( (_status != NO_ERROR) && ((DebugMask & DEBUG_ ## _ErrLevel) != 0) )

#define DEBUGBREAK DebugBreak

#undef ASSERT
/*++
VOID
Assert(
    IN Value
    )


Routine Description:

    Checks if the Value passed in is zero.  If its zero then assert.

Arguments:

    Value - the parameter to check against zero

Return Value:

    none

--*/
#define ASSERT( exp ) if ( !(exp) ) WsAssert( #exp, __FILE__,__LINE__ )

/*++
VOID
AllocMem(
    OUT PVOID   *Address,
    IN  ULONG   Length
    )


Routine Description:

    Allocates memory and then writes a tag and length into the first two Ulongs.  It
    then writes the same tag into the last Ulong.

Arguments:

    Address - the return address of the memory
    Length  - the length of the memory to allocate

Return Value:

    none

--*/
#define CAllocMem(_num,_size)           AllocMemory( _num*_size,TRUE, __FILE__, __LINE__ )
#define AllocMem(_Address,_cb)          *_Address = AllocMemory( _cb,FALSE,__FILE__, __LINE__ )
#define ReAllocMem(_pv, _cb)            ReAllocMemory(_pv,_cb,__FILE__,__LINE__ )
#if 0
#define AllocMem( _Address,_Length )                                                    \
{                                                                                       \
    PULONG  _Addr;                                                                      \
    ULONG   _Len;                                                                       \
    _Len = _Length + (sizeof(ULONG) << 2);                                              \
    _Addr = malloc( _Len );                                                             \
    IF_DEBUG(MEMORY_ALLOC) {                                                            \
        WSPRINT(( "AllocMemory %X, %d bytes %s %d\n",_Addr,_Length,__FILE__,__LINE__ ));\
    }                                                                                   \
                                                                                        \
    if (_Addr) {                                                                        \
        *(PULONG)_Addr++ = RSVP_TAG;                                                    \
        *(PULONG)_Addr++ = _Length;                                                     \
        *_Address = (PVOID)_Addr;                                                       \
        *(PULONG)((PUCHAR)_Addr + _Length) = RSVP_TAG;                                  \
    } else {                                                                            \
        *_Address = NULL;                                                               \
    }                                                                                   \
}
#endif

/*++
VOID
FreeMem(
    IN PVOID    Address
    )


Routine Description:

    Frees non-paged pool.  It checks if the tag value is still set at both the beginning
    and the end of the pool block and asserts if it's not.

Arguments:

    Address - the address of the memory

Return Value:

    none

--*/
#define FreeMem(_pv)                    FreeMemory( _pv,__FILE__,__LINE__ )
#if 0
#define FreeMem( _Address )                                                                    \
{                                                                                              \
    PULONG _Addr;                                                                              \
    _Addr = (PULONG)((PUCHAR)_Address - (sizeof(ULONG) << 1));                                 \
    if (( *_Addr++ != RSVP_TAG ) ||                                                            \
        (( *(PULONG)((PUCHAR)_Addr + *_Addr + sizeof(ULONG)) ) != RSVP_TAG)) {                 \
        WSPRINT(("Bogus Address passed in - Addr = %X\n",_Address ));                          \
        ASSERT( 0 );                                                                           \
    }                                                                                          \
    _Addr--;                                                                                   \
                                                                                               \
    IF_DEBUG(MEMORY_FREE) {                                                                    \
        WSPRINT(( "FreeMemory %X, %d bytes %s %d\n",_Address,*(_Addr + 1),__FILE__,__LINE__ ));\
    }                                                                                          \
    *(_Addr + 1) = 0;                                                                          \
    free( _Addr );                                                                             \
}
#endif

/*++
VOID
CheckMemoryOwner(
    IN PVOID    Address
    )


Routine Description:

    Check for a tag in the memory block to ensure we own the memory

Arguments:

    Address - the address of the memory

Return Value:

    none

--*/

#define CheckMemoryOwner( _Address )
#if 0
#define CheckMemoryOwner( _Address )                                      \
{                                                                         \
    if (( *(PULONG)((PUCHAR)_Address - sizeof( ULONG ))) != RSVP_TAG ) {  \
        WSPRINT(("Bogus Address passed in - Addr = %X\n",_Address ));     \
        ASSERT( 0 );                                                      \
    }                                                                     \
}
#endif


/*++
ULONG
LockedDecrement(
    IN PULONG   _Count
    )


Routine Description:

    Atomically decrement a counter and return an indication whether the count has gone to
    zero.  The value returned will be zero if the count is zero after the decrement. However if
    the count is either greater or less than zero then this routine will not return the current
    count value, but rather some number that has the same sign as the real count.

Arguments:

    _Count - the address of the memory to decrement

Return Value:

    none

--*/
#define LockedDecrement( _Count )  \
    LockedDec( _Count )

/*++
ULONG
LockedIncrement(
    IN PULONG   _Count
    )


Routine Description:

    Atomically increment a counter and return an indication whether the 
    count has gone to zero.  The value returned will be zero if the 
    count is zero after the increment. However if the count is either 
    greater or less than zero then this routine will not return the current
    count value, but rather some number that has the same sign 
    as the real count.

Arguments:

    _Count - the address of the memory to increment

Return Value:

    none

--*/
#define LockedIncrement( _Count )  ++(*_Count)


//
// this macro is used to vector exceptions to the debugger on a DBG build and to
// simply execute the exception handler on a free build
//
#define EXCEPTION_FILTER UnhandledExceptionFilter(GetExceptionInformation())

#define InitLock( _s1 )   {                                         \
    IF_DEBUG(LOCKS) WSPRINT(("INITLOCK %s [%d]\n", __FILE__,__LINE__)); \
    InitializeCriticalSection( &(_s1).Lock );                       \
    (_s1).LockAcquired = 0;                                        \
    strncpy((_s1).LastAcquireFile, strrchr(__FILE__, '\\')+1, 7);   \
    (_s1).LastAcquireLine = __LINE__;                               \
}

#define GetLock(_s1)                                                     \
{                                                                        \
      EnterCriticalSection( &(_s1).Lock);                                \
      IF_DEBUG(LOCKS) WSPRINT(("GETLOCK[%X] %s [%d]\n", &(_s1).Lock, __FILE__,__LINE__)); \
      (_s1).LockAcquired++;                                         \
      ASSERT((_s1).LockAcquired > 0);                               \
      (_s1).LastAcquireLine = __LINE__;                                  \
      strncpy((_s1).LastAcquireFile, strrchr(__FILE__,'\\')+1, 7);       \
}

#define SafeGetLock(_s1)                                                 \
    __try {                                                              \
      EnterCriticalSection( &(_s1).Lock);                                \
      IF_DEBUG(LOCKS) WSPRINT(("SGETLOCK %s [%d]\n", __FILE__,__LINE__));\
      (_s1).LockAcquired = TRUE;                                         \
      (_s1).LastAcquireLine = __LINE__;                                  \
      strncpy((_s1).LastAcquireFile, strrchr(__FILE__,'\\')+1, 7);       \
      
#define FreeLock(_s1)                                                    \
{                                                                        \
      IF_DEBUG(LOCKS) WSPRINT(("FREELOCK[%X] %s [%d]\n", &(_s1).Lock, __FILE__,__LINE__));\
      (_s1).LockAcquired--;                                        \
      ASSERT((_s1).LockAcquired >= 0);                               \
      (_s1).LastReleaseLine = __LINE__;                                  \
      strncpy((_s1).LastReleaseFile, strrchr(__FILE__,'\\')+1, 7);       \
      LeaveCriticalSection( &(_s1).Lock);                                \
}

#define SafeFreeLock(_s1)                                                         \
      } __finally {                                                               \
              IF_DEBUG(LOCKS) WSPRINT(("SFREELOCK %s [%d]\n", __FILE__,__LINE__));\
              (_s1).LockAcquired = FALSE;                                         \
              (_s1).LastReleaseLine = __LINE__;                                   \
              strncpy((_s1).LastReleaseFile, strrchr(__FILE__,'\\')+1, 7);        \
              LeaveCriticalSection( &(_s1).Lock);                                 \
}

#define DeleteLock( _s1 ) {                                                  \
    IF_DEBUG(LOCKS) WSPRINT(("DELLOCK[%X] %s [%d]\n", &(_s1).Lock, __FILE__,__LINE__));       \
    (_s1).LockAcquired--;                                                 \
    ASSERT((_s1).LockAcquired == -1);                                                 \
    strncpy((_s1).LastReleaseFile, strrchr(__FILE__, '\\')+1, 7);            \
    (_s1).LastReleaseLine = __LINE__;                                        \
    DeleteCriticalSection(&(_s1).Lock);                                      \
}


#define QUERY_STATE(_p)     (_p).State 

#define SET_STATE(_p, _state) {                                             \
    IF_DEBUG(STATES) {                                                      \
        DbgPrint("Setting Object to STATE [%s] (File:%s, Line%d)\n", TC_States[_state], __FILE__, __LINE__);       \
        }                                                                       \
   (_p).PreviousState = (_p).State;                                        \
   (_p).PreviousStateLine = (_p).CurrentStateLine;                         \
   (_p).CurrentStateLine = __LINE__;                                       \
   strncpy((_p).PreviousStateFile, (_p).CurrentStateFile, 7);              \
   strncpy((_p).CurrentStateFile, strrchr(__FILE__, '\\')+1, 7);           \
   (_p).State = _state;                                                    \
}

    
#else  // DBG

//
// These are the NON debug versions of the macros
//

#define IF_DEBUG( _ErrLevel ) if (FALSE)
#define IF_DEBUG_CHECK( _status,_ErrLevel ) if (FALSE)
#ifndef ASSERT
#define ASSERT(a)
#endif
#define WSPRINT(stuff)
#define TC_TRACE(_ErrLevel, stuff)
#define SETUP_DEBUG_INFO()
#define CLOSE_DEBUG()
#define DUMP_MEM_ALLOCATIONS()
#define INIT_DBG_MEMORY()
#define DEINIT_DBG_MEMORY()
#define DEBUGBREAK()

#define AllocMem( _Addr,_Len )  \
    *_Addr = malloc(_Len )

#define FreeMem( _Address )     \
    free( _Address )

#define CheckMemoryOwner( Address )

#define LockedDecrement( _Count )  \
    CTEInterlockedDecrementLong( _Count )

#define EXCEPTION_FILTER EXCEPTION_EXECUTE_HANDLER

#define InitLock( _s1 )    InitializeCriticalSection( &(_s1).Lock) 

#define DeleteLock( _s1 )  DeleteCriticalSection( &(_s1).Lock)

#define GetLock( _s1 )     EnterCriticalSection( &(_s1).Lock) 

#define SafeGetLock( _s1 ) __try { EnterCriticalSection( &(_s1).Lock);

#define FreeLock(_s1)  LeaveCriticalSection( &(_s1).Lock) 

#define SafeFreeLock( _s1 ) } __finally {LeaveCriticalSection( &(_s1).Lock);}

#define SET_STATE(_p, _state) { (_p).State = _state; }
#define QUERY_STATE(_p)     (_p).State
    

#endif // DBG

/*++
ULONG
IS_LENGTH(
    IN ULONG   _Length,
    )

Routine Description:

    This calculates the number of 32 bit words in a length and returns that.  It is used
    for Int Serv objects that require the size in 32 bit words.

Arguments:

    _Length - Length

Return Value:

    number of 32 bit words

--*/
#define IS_LENGTH( _Length )                                   \
    (_Length + 3)/sizeof(ULONG)


        //#define IS_INITIALIZED  (Initialized)

#define VERIFY_INITIALIZATION_STATUS	\
	if (InitializationStatus != NO_ERROR) return InitializationStatus

#define OffsetToPtr(Base, Offset)     ((PBYTE) ((PBYTE)Base + Offset))

#define ERROR_FAILED(_stat)	   (_stat!=NO_ERROR && _stat!=ERROR_SIGNAL_PENDING)
#define ERROR_PENDING(_stat)   (_stat==ERROR_SIGNAL_PENDING)

#define MULTIPLE_OF_EIGHT(_x)  (((_x)+7) & ~7)

#endif  // end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tools\qtcp\ioctl.h ===
#ifndef _IOCTL
#define _IOCTL

// Define the ioctls for adding and removing ports.
#define CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)

#define IOCTL_TIMESTMP_REGISTER_PORT       CTRL_CODE( 0x847, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_DEREGISTER_PORT     CTRL_CODE( 0x848, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#endif //_IOCTL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\tcutils.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tcutils.c

Abstract:

    This module contains support routines for the traffic DLL.

Author:

    Jim Stewart (jstew)    August 14, 1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <wincon.h>
#include <winuser.h>


#if DBG
BOOLEAN     ConsoleInitialized = FALSE;
HANDLE      DebugFileHandle = INVALID_HANDLE_VALUE;
PTCHAR      DebugFileName = L"/temp/traffic.log";
PTCHAR      TRAFFIC_DBG = L"Traffic.dbg";


VOID
WsAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    BOOL ok;
    CHAR choice[16];
    DWORD bytes;
    DWORD error;

    IF_DEBUG(CONSOLE) {
        WSPRINT(( " failed: %s\n  at line %ld of %s\n",
                    FailedAssertion, LineNumber, FileName ));
        do {
            WSPRINT(( "[B]reak/[I]gnore? " ));
            bytes = sizeof(choice);
            ok = ReadFile(
                    GetStdHandle(STD_INPUT_HANDLE),
                    &choice,
                    bytes,
                    &bytes,
                    NULL
                    );
            if ( ok ) {
                if ( toupper(choice[0]) == 'I' ) {
                    break;
                }
                if ( toupper(choice[0]) == 'B' ) {
                    DEBUGBREAK();
                }
            } else {
                error = GetLastError( );
            }
        } while ( TRUE );

        return;
    }

    RtlAssert( FailedAssertion, FileName, LineNumber, NULL );

} // WsAssert



VOID
WsPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;
    BOOL ret;

    length = (ULONG)wsprintfA( OutputBuffer, "TRAFFIC [%05d]: ", 
                               GetCurrentThreadId() );

    va_start( arglist, Format );

    wvsprintfA( OutputBuffer + length, Format, arglist );

    va_end( arglist );

    IF_DEBUG(DEBUGGER) {
        DbgPrint( "%s", OutputBuffer );
    }

    IF_DEBUG(CONSOLE) {

        if ( !ConsoleInitialized ) {
            CONSOLE_SCREEN_BUFFER_INFO csbi;
            COORD coord;

            ConsoleInitialized = TRUE;
            (VOID)AllocConsole( );
            (VOID)GetConsoleScreenBufferInfo(
                    GetStdHandle(STD_OUTPUT_HANDLE),
                    &csbi
                    );
            coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
            coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
            (VOID)SetConsoleScreenBufferSize(
                    GetStdHandle(STD_OUTPUT_HANDLE),
                    coord
                    );
        }

        length = strlen( OutputBuffer );

        ret = WriteFile(
                  GetStdHandle(STD_OUTPUT_HANDLE),
                  (LPVOID )OutputBuffer,
                  length,
                  &length,
                  NULL
                  );

        if ( !ret ) {
            DbgPrint( "WsPrintf: console WriteFile failed: %ld\n",
                          GetLastError( ) );
        }

    }

    IF_DEBUG(FILE) {

        if ( DebugFileHandle == INVALID_HANDLE_VALUE ) {
            DebugFileHandle = CreateFile(
                                  DebugFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  CREATE_ALWAYS,
                                  0,
                                  NULL
                                  );
        }

        if ( DebugFileHandle == INVALID_HANDLE_VALUE ) {

            //DbgPrint( "WsPrintf: Failed to open traffic debug log file %s: %ld\n",
            //              DebugFileName, GetLastError( ) );
        } else {

            length = strlen( OutputBuffer );

            ret = WriteFile(
                      DebugFileHandle,
                      (LPVOID )OutputBuffer,
                      length,
                      &length,
                      NULL
                      );
            
            if ( !ret ) {
                DbgPrint( "WsPrintf: file WriteFile failed: %ld\n",
                              GetLastError( ) );
            }
        }
    }

} // WsPrintf

#endif


ULONG
LockedDec(
    IN  PULONG  Count
    )

/*++

Routine Description:

    This routine is a debug routine used for checking decrements on counts.
    It asserts if the count goes negative. The Macro LockedDecrement calls it.

Arguments:

    pointer to the count.

Return Value:

    none

--*/

{
    ULONG Result;

    Result = InterlockedDecrement( (PLONG)Count );

    ASSERT( Result < 0x80000000 );
    return( Result );

}

#if DBG
VOID
SetupDebugInfo()

/*++

Description:
    This routine reads in a debug file that may contain debug instructions.

Arguments:

    none

Return Value:

    none

--*/
{
    HANDLE      handle;

    //
    // If there is a file in the current directory called "tcdebug"
    // open it and read the first line to set the debugging flags.
    //

    handle = CreateFile(
                        TRAFFIC_DBG,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

    if( handle == INVALID_HANDLE_VALUE ) {

        //
        // Set default value. changed - Oferbar
        //

        //DebugMask = DEBUG_DEBUGGER | DEBUG_CONSOLE;
        DebugMask |= DEBUG_ERRORS;  // always dump errors
        DebugMask |= DEBUG_FILE;    // always print a log.
        DebugMask |= DEBUG_WARNINGS;    // until Beta3, we want the warnings too

    } else {

        CHAR buffer[11];
        DWORD bytesRead;

        RtlZeroMemory( buffer, sizeof(buffer) );

        if ( ReadFile( handle, buffer, 10, &bytesRead, NULL ) ) {

            buffer[bytesRead] = '\0';

            DebugMask = strtoul( buffer, NULL, 16 );

        } else {

            WSPRINT(( "read file failed: %ld\n", GetLastError( ) ));
        }

        CloseHandle( handle );
    }

}

VOID
CloseDbgFile(
    )

/*++

Routine Description:

    This closes the debug output file if its open.

Arguments:

    none

Return Value:

    none

--*/
{

    if (DebugFileHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( DebugFileHandle );
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\tcwmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tcwmi.c

Abstract:

    This module contains WMI support for traffic control

Author:

        Ofer Bar (oferbar)              Oct 1, 1997

Revision History:


--*/

#include "precomp.h"


static BOOLEAN _init = FALSE;

DWORD
InitializeWmi(VOID)
{
    DWORD               Status = NO_ERROR;

    if (!_init) {

        __try {

            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_UP_INDICATION,
                                                  TRUE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_DOWN_INDICATION,
                                                  TRUE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_CHANGE_INDICATION,
                                                  TRUE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IF_DEBUG(ERRORS) {
                WSPRINT(("InitializeWmi: Exception Error: = %X\n", Status ));
            }

        }

        if (Status == NO_ERROR) 
            _init = TRUE;
    }

    return Status;
}



DWORD
DeInitializeWmi(VOID)
{
    DWORD               Status = NO_ERROR;

    if (_init) {

        __try {

            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_UP_INDICATION,
                                                  FALSE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_DOWN_INDICATION,
                                                  FALSE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );
            Status = WmiNotificationRegistration( (LPGUID)&GUID_QOS_TC_INTERFACE_CHANGE_INDICATION,
                                                  FALSE,
                                                  CbWmiInterfaceNotification,
                                                  0,
                                                  NOTIFICATION_CALLBACK_DIRECT
                                                  );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IF_DEBUG(ERRORS) {
                WSPRINT(("DeInitializeWmi: Exception Error: = %X\n", Status ));
            }

        }

        if (Status == NO_ERROR) 
            _init = FALSE;
    }

    return Status;
}



DWORD
WalkWnode(
   IN  PWNODE_HEADER                    pWnodeHdr,
   IN  ULONG                                    Context,
   IN  CB_PER_INSTANCE_ROUTINE  CbPerInstance
   )
{
    DWORD               Status;
    ULONG       Flags;
    PWCHAR      NamePtr;
    USHORT      NameSize;
    PBYTE       DataBuffer;
    ULONG       DataSize;
    PULONG              NameOffset;
    WCHAR               TmpName[512];

    Flags = pWnodeHdr->Flags;
    
    if (Flags & WNODE_FLAG_ALL_DATA) {

        //
        // WNODE_ALL_DATA structure has multiple interfaces
        //

        PWNODE_ALL_DATA pWnode = (PWNODE_ALL_DATA)pWnodeHdr;
        UINT            Instance;
        //PULONG        NameOffsets;
        
        NameOffset = (PULONG) OffsetToPtr(pWnode, 
                                          pWnode->OffsetInstanceNameOffsets );
        DataBuffer = (PBYTE) OffsetToPtr (pWnode, 
                                          pWnode->DataBlockOffset);
        
        for ( Instance = 0; 
              Instance < pWnode->InstanceCount; 
              Instance++) {
            
            //
            //  Instance Name
            //
            
            NamePtr = (PWCHAR) OffsetToPtr(pWnode, 
                                           NameOffset[Instance] 
                                           + sizeof(USHORT));
            NameSize = * (USHORT *) OffsetToPtr(pWnode, 
                                                NameOffset[Instance]);
            
            //
            //  Instance Data
            //
            //  Get size and pointer to the buffer
            //
        
            if ( Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE ) {
            
                DataSize = pWnode->FixedInstanceSize;
            
            } else {
            
                DataSize = 
                    pWnode->OffsetInstanceDataAndLength[Instance].LengthInstanceData;
                DataBuffer = 
                    (PBYTE)OffsetToPtr(pWnode,
                                       pWnode->OffsetInstanceDataAndLength[Instance].OffsetInstanceData);
            }

            //
            // a call back to a notification handler that calls the client
            //

            CbPerInstance(Context,
                          (LPGUID)&pWnode->WnodeHeader.Guid,
                          (LPWSTR)NamePtr,
                          DataSize,
                          DataBuffer
                          );
        }

    } else if (Flags & WNODE_FLAG_SINGLE_INSTANCE) {

        //
        // WNODE_SINGLE_INSTANCE structure has only one instance
        // 

        PWNODE_SINGLE_INSTANCE  pWnode = (PWNODE_SINGLE_INSTANCE)pWnodeHdr;
        
        if (Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) {

            //
            // What am I supposed to do with THAT ?!?
            // NOTHING! (55686)
            //
            
            return (-1);
        }

        NamePtr = (PWCHAR)OffsetToPtr(pWnode, 
                                      pWnode->OffsetInstanceName 
                                      + sizeof(USHORT) );
        NameSize = * (USHORT *) OffsetToPtr(pWnode, 
                                            pWnode->OffsetInstanceName);

        memcpy(TmpName, NamePtr, NameSize);
        TmpName[NameSize/sizeof(WCHAR)] = L'\0';

        //
        //  Data Size
        //

        DataSize = pWnode->SizeDataBlock;
        
        //
        //  Instance Data
        //

        DataBuffer = (PBYTE)OffsetToPtr (pWnode, pWnode->DataBlockOffset);
        
        //
        // a call back to a notification handler that calls the client
        //
        
        CbPerInstance(Context,
                      (LPGUID)&pWnode->WnodeHeader.Guid,
                      (LPWSTR)TmpName,
                      DataSize,
                      DataBuffer
                      );

    } else if (Flags & WNODE_FLAG_SINGLE_ITEM) {

        //
        // WNODE_SINGLE_INSTANCE structure has only one instance
        // 

        PWNODE_SINGLE_ITEM      pWnode = (PWNODE_SINGLE_ITEM)pWnodeHdr;
        
        if (Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES) {

            //
            // What am I supposed to do with THAT ?!?
            // NOTHING! (55686)
            //
            
            return (-1);
        }

        NamePtr = (PWCHAR)OffsetToPtr(pWnode, 
                                      pWnode->OffsetInstanceName 
                                      + sizeof(USHORT) );
        NameSize = * (USHORT *) OffsetToPtr(pWnode, 
                                            pWnode->OffsetInstanceName);
        //
        //  Data Size
        //

        DataSize = pWnode->SizeDataItem;
        
        //
        //  Instance Data
        //

        DataBuffer = (PBYTE)OffsetToPtr (pWnode, pWnode->DataBlockOffset);
        
        //
        // a call back to a notification handler that calls the client
        //
        
        CbPerInstance(Context,
                      (LPGUID)&pWnode->WnodeHeader.Guid,
                      (LPWSTR)NamePtr,
                      DataSize,
                      DataBuffer
                      );
        
    } else {

        ASSERT(0);

    }
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tc\dll\tctypes.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    tctypes.h

Abstract:

    This module contains various types and macros for traffic.dll.

Author:

    Jim Stewart ( jstew )    July 28, 1996

Revision History:

	Ofer Bar ( oferbar )     Oct 1, 1996 - Revision II changes

--*/


//
// just patch it in, I can't include ndis.h now
//

#define NDIS_STATUS_INCOMPATABLE_QOS			0xC0010027L


//
// debug mask values for DebugMask
//

#define  DEBUG_CONSOLE        0x00000001
#define  DEBUG_FILE           0x00000002
#define  DEBUG_DEBUGGER       0x00000004
#define  DEBUG_INIT           0x00000008
#define  DEBUG_MEMORY_ALLOC   0x00000010
#define  DEBUG_MEMORY_FREE    0x00000020
#define  DEBUG_MEM_CALLSTACK  0x00000040
#define  DEBUG_CHKSUM_ALLMEM  0x00000080
#define  DEBUG_DUMP_MEM       0x00000100
#define  DEBUG_ERRORS         0x00000200
#define  DEBUG_SHUTDOWN       0x00000400
#define  DEBUG_IOCTLS         0x00000800
#define  DEBUG_CALLS          0x00001000
#define  DEBUG_LOCKS          0x00002000
#define  DEBUG_CALLBACK       0x00004000
#define  DEBUG_STATES         0x00008000
#define  DEBUG_REFCOUNTS      0x00010000
#define  DEBUG_WARNINGS       0x00020000
#define  DEBUG_HANDLES        0x00040000
#define  DEBUG_INTERFACES     0x00080000
#define  DEBUG_REFCOUNTX      0x00100000

#define KiloBytes  		* 1024
//#define MAX_STRING_LENGTH	256

//
// internal flow/filter flags
//
#define TC_FLAGS_INSTALLING		0x00010000
#define TC_FLAGS_MODIFYING		0x00020000
#define TC_FLAGS_DELETING		0x00040000
#define TC_FLAGS_REMOVED		0x00080000
#define TC_FLAGS_WAITING		0x00100000

#define IS_INSTALLING(_f)   (((_f)&TC_FLAGS_INSTALLING)==TC_FLAGS_INSTALLING)
#define IS_MODIFYING(_f)    (((_f)&TC_FLAGS_MODIFYING)==TC_FLAGS_MODIFYING)
#define IS_DELETING(_f)		(((_f)&TC_FLAGS_DELETING)==TC_FLAGS_DELETING)
#define IS_REMOVED(_f)		(((_f)&TC_FLAGS_REMOVED)==TC_FLAGS_REMOVED)
#define IS_WAITING(_f)		(((_f)&TC_FLAGS_WAITING)==TC_FLAGS_WAITING)
#define IS_FLOW_READY(_f)   (!IS_INSTALLING(_f) && \
                             !IS_MODIFYING(_f) && \
                             !IS_DELETING(_f) && \
                             !IS_REMOVED(_f))

//
// GUID compare
//
#define CompareGUIDs(rguid1, rguid2)  (memcmp(rguid1,rguid2,sizeof(GUID))==0)

//
// define object type enum for handle verification
//
typedef enum ULONG ENUM_OBJECT_TYPE;

#define ENUM_CLIENT_TYPE 			0x00000001
#define ENUM_INTERFACE_TYPE			0x00000002
#define ENUM_GEN_FLOW_TYPE			0x00000004
#define ENUM_CLASS_MAP_FLOW_TYPE	0x00000008
#define ENUM_FILTER_TYPE			0x00000010

//
// N.B. tcmacro.h has an array that needs to be in synch with the following
//
typedef enum _STATE {
        INVALID,        // 0 
        INSTALLING,     // 1 - structures were allocated.
        OPEN,           // 2 - Open for business
        USERCLOSED_KERNELCLOSEPENDING, // 3 - the user component has closed it, we are awaiting a kernel close
        FORCED_KERNELCLOSE,            // 4 - the kernel component has forced a close.
        KERNELCLOSED_USERCLEANUP,       // 5 - Kernel has closed it, we are ready to delete this obj.
        REMOVED,        // 6 - Its gone (being freed - remember that the handle has to be freed before removing)
        EXIT_CLEANUP,   // 7 - we are unloading and need to be cleanedup
        MAX_STATES

} STATE;

#define IF_UNKNOWN 0xbaadf00d

#if DBG
//
// N.B. Ensure that this array is in sync with the enum in tctypes.h
//

extern TCHAR *TC_States[];
/* = {
    TEXT("INVALID"),
    TEXT("INSTALLING"),     // structures were allocated.
    TEXT("OPEN"),           // Open for business
    TEXT("USERCLOSED_KERNELCLOSEPENDING"), // the user component has closed it, we are awaiting a kernel close
    TEXT("FORCED_KERNELCLOSE"),            // the kernel component has forced a close.
    TEXT("KERNELCOSED_USERCLEANUP"),       // Kernel has closed it, we are ready to delete this obj.
    TEXT("REMOVED"),        // Its gone (being freed - remember that the handle has to be freed before removing)
    TEXT("EXIT_CLEANUP"),  // we are unloading and need to be cleanedup
    TEXT("MAX_STATES")
    
};*/
#endif 

typedef struct _TRAFFIC_STATE {

    STATE   State;              // current state

#if DBG 
    UCHAR   CurrentStateFile[8];
    ULONG   CurrentStateLine;
    STATE   PreviousState;      // The previous state
    UCHAR   PreviousStateFile[8];       
    ULONG   PreviousStateLine;
#endif 

} TRAFFIC_STATE;

typedef HandleFactory HANDLE_TABLE, *PHANDLE_TABLE;

typedef struct _TRAFFIC_LOCK {

    CRITICAL_SECTION Lock;
#if DBG
    LONG  LockAcquired;             // is it current held?
    UCHAR LastAcquireFile[8];       
    ULONG LastAcquireLine;
    UCHAR LastReleaseFile[8];
    ULONG LastReleaseLine;
#endif

} TRAFFIC_LOCK, *PTRAFFIC_LOCK;


//
// A global structure per process to hold handle table, client list, etc...
//

typedef struct _GLOBAL_STRUC {

    PHANDLE_TABLE		pHandleTbl;
    TRAFFIC_STATE       State;
    LIST_ENTRY			ClientList;    // list of clients
    LIST_ENTRY			TcIfcList;     // list of kernel TC interfaces
    LIST_ENTRY          GpcClientList; // list of GPC clients
    HANDLE				GpcFileHandle; // result of CreateFile on GPC device
    TRAFFIC_LOCK        Lock;

} GLOBAL_STRUC, *PGLOBAL_STRUC;


//
// TC interface structure that holds the kernel interfaces information
//
typedef struct _TC_IFC {

    LIST_ENTRY		Linkage;						// next TC ifc
    LIST_ENTRY		ClIfcList;						// client interface list
    TRAFFIC_STATE   State;                          // need this state for bug 273978
    TRAFFIC_LOCK    Lock;
    REF_CNT         RefCount;
    ULONG			InstanceNameLength;				// 
    WCHAR			InstanceName[MAX_STRING_LENGTH];// instance friendly name
    ULONG			InstanceIDLength;				// 
    WCHAR			InstanceID[MAX_STRING_LENGTH];  // instance ID
    ULONG			AddrListBytesCount;
	PADDRESS_LIST_DESCRIPTOR	pAddressListDesc;   //
    ULONG			InterfaceIndex; 				// the interafce index from the OS
    ULONG			SpecificLinkCtx;				// the link context (only for WAN)

} TC_IFC, *PTC_IFC;


//
// A GPC client structure, one per CF_INFO type
//
typedef struct _GPC_CLIENT {

    LIST_ENTRY		Linkage;	// next GPC client
    ULONG			CfInfoType; // QOS, CBQ, etc.
    GPC_HANDLE		GpcHandle;	// return by GPC after GpcRegisterClient call
    ULONG			RefCount;
    
} GPC_CLIENT, *PGPC_CLIENT;

//
// this is the client structure that is allocated per TcRegisterClient
//
typedef struct _CLIENT_STRUC {

    ENUM_OBJECT_TYPE		ObjectType;	// must be first!
    TRAFFIC_STATE           State;
    TRAFFIC_LOCK            Lock;
    LIST_ENTRY				Linkage;	// next client
    HANDLE					ClHandle;	// client handle
    TCI_CLIENT_FUNC_LIST	ClHandlers;	// client's handler list
    HANDLE					ClRegCtx;   // client registration context
    REF_CNT					RefCount;
    LIST_ENTRY				InterfaceList;	// list of opened interface for the client
    ULONG					InterfaceCount;

} CLIENT_STRUC, *PCLIENT_STRUC;


//
// this type is allocated each time an app calls TcOpenInterface
//
typedef struct _INTERFACE_STRUC {

    ENUM_OBJECT_TYPE	ObjectType;		// must be first!
    TRAFFIC_STATE       State;          
    TRAFFIC_LOCK        Lock;
    LIST_ENTRY  		Linkage;    	// linkage onto the client's list
    LIST_ENTRY  		NextIfc;    	// next interface for the same TcIfc
    HANDLE				ClHandle;     	// handle returned to the app
    HANDLE				ClIfcCtx;       // client context for this interface
    PTC_IFC				pTcIfc;			// pointer to the kernel TC interface struct
    PCLIENT_STRUC		pClient;		// supporting client
    REF_CNT				RefCount;
    LIST_ENTRY  		FlowList;		// list of open flows on the Interface
    ULONG				FlowCount;
    HANDLE              IfcEvent;       
    ULONG               Flags;          // Used for deciding if we need to wait 
                                        // while closing the interface.
    DWORD               CallbackThreadId;
} INTERFACE_STRUC, *PINTERFACE_STRUC;


//
// this type is allocated each time TcAddFlow is called
//
typedef struct _FLOW_STRUC {

    ENUM_OBJECT_TYPE	ObjectType;	// must be first!
    TRAFFIC_STATE       State;
    TRAFFIC_LOCK        Lock;
    LIST_ENTRY  		Linkage;	// next flow on the interface
    USHORT				InstanceNameLength;				// 
    WCHAR				InstanceName[MAX_STRING_LENGTH];// instance ID
    PINTERFACE_STRUC  	pInterface;	// back ptr to interface struc
    GPC_HANDLE			GpcHandle;	// GPC handle
    HANDLE        		ClHandle;	// handle returned to app
    HANDLE				ClFlowCtx;	// client flow context
    ULONG				Flags;		// status indication
    ULONG				UserFlags;	// User defined flags
    PGPC_CLIENT			pGpcClient;	// GPC client to use
    PTC_GEN_FLOW		pGenFlow;	// save the flow spec
    PTC_GEN_FLOW		pGenFlow1;	// save the modified flow spec
    ULONG				GenFlowLen;
    ULONG				GenFlowLen1;
    PTC_CLASS_MAP_FLOW	pClassMapFlow;	//
    PTC_CLASS_MAP_FLOW	pClassMapFlow1;	//
    IO_STATUS_BLOCK		IoStatBlock;// for async completion
    PVOID    			CompletionBuffer;
    HANDLE				PendingEvent;
    REF_CNT				RefCount;
    LIST_ENTRY  		FilterList; // head of list of filters on this flow
    ULONG               FilterCount;
} FLOW_STRUC, *PFLOW_STRUC;

//
// this type is allocated each time TcAddFilter is called
//
typedef struct _FILTER_STRUC {

    ENUM_OBJECT_TYPE	ObjectType;	// must be first!
    TRAFFIC_STATE       State;      
    TRAFFIC_LOCK        Lock;
    LIST_ENTRY  		Linkage; 	// next filter on the flow
    REF_CNT             RefCount;   // When do we remove the structure?
    PFLOW_STRUC 		pFlow; 		// back ptr to flow struc
    HANDLE      		GpcHandle;	// GPC handle
    HANDLE				ClHandle;	// handle returned to app
    ULONG				Flags;
    ULONG				GpcProtocolTemplate;
    PTC_GEN_FILTER		pGpcFilter; // GPC pattern

} FILTER_STRUC, *PFILTER_STRUC;


//
// gen linked list
//
typedef struct _GEN_LIST {

    struct _GEN_LIST	*Next;
    PVOID				Ptr;

} GEN_LIST, *PGEN_LIST;

//
// callback routine typedef
//
typedef
VOID (* CB_PER_INSTANCE_ROUTINE)(
    IN	ULONG	Context,
    IN  LPGUID	pGuid,
	IN	LPWSTR	InstanceName,
    IN	ULONG	DataSize,
    IN	PVOID	DataBuffer
    );

//
// Global Variable definitions
//

extern ULONG    DebugMask;

//
// ptr to global structure per process
//

extern PGLOBAL_STRUC	pGlobals;

//
// keep track of which platform - NT or Win95
//

extern BOOL             NTPlatform;

//
// This is the ptr used in Win95 to access the Ioctl functions via Winsock
//

//extern LPWSCONTROL             WsCtrl;

//
// set when we call InitializeOsSpecific(), it will indicate status
// for the initialization routine, that will later be reported
// in TcRegisterClient, since we don't want to fail clients, like RSVP
// during DLL init time when TC is not available, but rather prevent it
// from doing any TC
//

extern DWORD    InitializationStatus;

//
// NtBug : 258218
// Within a process, need to maintain notification registrations specific 
// a Client, interface and Notification GUID. Lets define the struct below
// that will enable us to do this. Maintain a list of every notification
// that we care about. (yes, its not the most optimized Data Structure)
//

extern TRAFFIC_LOCK         NotificationListLock;
extern LIST_ENTRY           NotificationListHead;

typedef struct _NOTIFICATION_ELEMENT {
    
    LIST_ENTRY              Linkage;            // Other notification elements
    PINTERFACE_STRUC        IfcHandle;          // Interface on which we want this notification
    GUID                    NotificationGuid;   // Notification GUID

} NOTIFICATION_ELEMENT, *PNOTIFICATION_ELEMENT;

extern  TRAFFIC_LOCK        ClientRegDeregLock;
extern  HANDLE              GpcCancelEvent;
extern  PVOID               hinstTrafficDll;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tools\timestmp\timestmp.h ===
#ifndef _TIMESTMP_

#define _TIMESTMP_

#include <ntosp.h>
#include <ndis.h>
#include <qos.h>
#include <traffic.h>
#include <ntddtc.h>
#include <cxport.h>
#include <ip.h>
#include <pktsched.h>
#include "ioctl.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tools\timestmp\ioctl.h ===
#ifndef _IOCTL
#define _IOCTL

//
// Create a list of the ports we want to keep timestamps for
// 5003 is no longer all we do.
//
typedef struct _PORT_ENTRY {
    LIST_ENTRY      Linkage;
    USHORT          Port;
    PFILE_OBJECT    FileObject;
    } PORT_ENTRY, *PPORT_ENTRY;

LIST_ENTRY      PortList;

NDIS_SPIN_LOCK  PortSpinLock;


// Prototypes
NTSTATUS
IoctlInitialize(
                PDRIVER_OBJECT  DriverObject
                );

NTSTATUS
IoctlHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IoctlCleanup();

PPORT_ENTRY 
CheckInPortList
               (USHORT Port
               );

VOID
RemoveAllPortsForFileObject(
                            PFILE_OBJECT FileObject
                            );


// Other vars.

PDEVICE_OBJECT          TimestmpDeviceObject;
#pragma NDIS_PAGEABLE_FUNCTION(IoctlHandler)

//
// Define the ioctls for adding and removing ports.
#define CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)

#define IOCTL_TIMESTMP_REGISTER_PORT       CTRL_CODE( 0x847, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_TIMESTMP_DEREGISTER_PORT     CTRL_CODE( 0x848, METHOD_BUFFERED, FILE_WRITE_ACCESS)

UNICODE_STRING  TimestmpDriverName;
UNICODE_STRING  symbolicLinkName;
DRIVER_OBJECT   TimestmpDriverObject;

#endif //_IOCTL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tools\timestmp\timestmp.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    timestmp.c

Abstract:

    Timestamper module

Author:
    Shreedhar Madhavapeddi (shreem)

Revision History:

--*/

#include <timestmp.h>

//
// The following struct has to be in ssync with
// ndis\trfccntl\tools\qtcp\qtcp.c
//
typedef struct _LOG_RECORD{
    UINT64  TimeSent;
    UINT64  TimeReceived;
    UINT64  TimeSentWire;         // These fields are used by the kernel timestamper
    UINT64  TimeReceivedWire;     // These fields are used by the kernel timestamper
    UINT64  Latency;
    INT     BufferSize;
    INT     SequenceNumber;
} LOG_RECORD, *PLOG_RECORD;

ULONG           GlobalSequenceNumber = 0;        

// 321618 needs checking for PSCHED's existence.
NDIS_STRING     PschedDriverName           = NDIS_STRING_CONST("\\Device\\PSched");
HANDLE          PschedHandle;
NTSTATUS CheckForPsched(VOID);

	
//
// TCP Headers (redefined here, since there are no exported headers
//
#define IP_OFFSET_MASK          ~0x00E0         // Mask for extracting offset field.
#define net_short(x) ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))

/*
 * Protocols (from winsock.h)
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */
#define IPPROTO_IPSEC                   51              /* ???????? */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

#define IP_MF_FLAG                          0x0020              // 'More fragments flag'
#define IP_VERSION                      0x40
#define IP_VER_FLAG                     0xF0


#define TCP_OFFSET_MASK 0xf0
#define TCP_HDR_SIZE(t) (uint)(((*(uchar *)&(t)->tcp_flags) & TCP_OFFSET_MASK) >> 2)

typedef int             SeqNum;                         // A sequence number.


struct TCPHeader {
        ushort                          tcp_src;                        // Source port.
        ushort                          tcp_dest;                       // Destination port.
        SeqNum                          tcp_seq;                        // Sequence number.
        SeqNum                          tcp_ack;                        // Ack number.
        ushort                          tcp_flags;                      // Flags and data offset.
        ushort                          tcp_window;                     // Window offered.
        ushort                          tcp_xsum;                       // Checksum.
        ushort                          tcp_urgent;                     // Urgent pointer.
};

typedef struct TCPHeader TCPHeader;

struct UDPHeader {
        ushort          uh_src;                         // Source port.
        ushort          uh_dest;                        // Destination port.
        ushort          uh_length;                      // Length
        ushort          uh_xsum;                        // Checksum.
}; /* UDPHeader */

typedef struct UDPHeader UDPHeader;

#ifdef DBG
//
// Define the Trace Level.
//
#define TS_DBG_DEATH               1
#define TS_DBG_TRACE               2

//
// Masks
//
#define TS_DBG_PIPE      0x00000001
#define TS_DBG_FLOW      0x00000002
#define TS_DBG_SEND      0x00000004
#define TS_DBG_RECV      0x00000008
#define TS_DBG_INIT      0x00000010
#define TS_DBG_OID       0x00000020
#define TS_DBG_CLASS_MAP 0x00000040

ULONG DbgTraceLevel = 1;
ULONG DbgTraceMask  = 0x8;

#define TimeStmpTrace(_DebugLevel, _DebugMask, _Out) \
    if ((DbgTraceLevel >= _DebugLevel) &&           \
        ((_DebugMask) & DbgTraceMask)){             \
        DbgPrint("TimeStamp: ");                       \
        DbgPrint _Out;                              \
    }

#else // DBG
#define TimeStmpTrace
#endif

#define         PORT_RANGE  20
USHORT          IPIDList[PORT_RANGE];
NDIS_SPIN_LOCK  IPIDListLock;

#define         PORT_RANGE  20
USHORT          IPIDListRecv[PORT_RANGE];
NDIS_SPIN_LOCK  IPIDListLockRecv;

/*
Let's create a driver unload function, so that timestmp is stoppable via net sto
p timestmp
*/
VOID
TimeStmpUnload(
               IN PDRIVER_OBJECT DriverObject
               )
{

	IoctlCleanup();
    return;

}

NDIS_STATUS
TimeStmpInitializePipe (
    IN HANDLE PsPipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters,
    IN PPS_PIPE_CONTEXT ComponentPipeContext,
    IN PPS_PROCS PsProcs,
    IN PPS_UPCALLS Upcalls
    )
{
    PPS_PIPE_CONTEXT Pipe = ComponentPipeContext;

    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_PIPE, ("[TimeStmpIndicatePipe]: \n"));
    return (*Pipe->NextComponent->InitializePipe)(
        PsPipeContext,
        PipeParameters,
        Pipe->NextComponentContext,
        PsProcs,
        Upcalls);
}

NDIS_STATUS
TimeStmpModifyPipe (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_PIPE_PARAMETERS PipeParameters
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_PIPE, ("[TimeStmpModifyPipe]: \n"));
    return (*Pipe->NextComponent->ModifyPipe)(
        Pipe->NextComponentContext, PipeParameters);
}

VOID
TimeStmpDeletePipe (
    IN PPS_PIPE_CONTEXT PipeContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_PIPE, ("[TimeStmpDeletePipe]: \n"));
    (*Pipe->NextComponent->DeletePipe)(Pipe->NextComponentContext);
}


NDIS_STATUS
TimeStmpCreateFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsFlowContext,
    IN PCO_CALL_PARAMETERS CallParameters,
    IN PPS_FLOW_CONTEXT ComponentFlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;

    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_FLOW, ("[TimeStmpCreateFlow]: \n"));
    return (*Pipe->NextComponent->CreateFlow)(
                Pipe->NextComponentContext,
                PsFlowContext,
                CallParameters,
                ComponentFlowContext->NextComponentContext);
}


NDIS_STATUS
TimeStmpModifyFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PCO_CALL_PARAMETERS CallParameters
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_FLOW, ("[TimeStmpModifyFlow]: \n"));
    return (*Pipe->NextComponent->ModifyFlow)(
                Pipe->NextComponentContext,
                FlowContext->NextComponentContext,
                CallParameters);
    
}


VOID
TimeStmpDeleteFlow (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext
    )
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_FLOW, ("[TimeStmpDeleteFlow]: \n"));
    (*Pipe->NextComponent->DeleteFlow)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext);
}


BOOLEAN
TimeStmpSubmitPacket (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
    IN PPACKET_INFO_BLOCK PacketInfo
    )
{
    PPS_PIPE_CONTEXT    Pipe = PipeContext;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH    = NULL;
    TCPHeader UNALIGNED *TCPH   = NULL;
    UDPHeader UNALIGNED *UDPH   = NULL;
    PVOID               ArpH    = NULL, GeneralVA = NULL, Data = NULL;
    IPAddr              Src, Dst;
    PNDIS_BUFFER        ArpBuf = NULL, IpBuf = NULL, TcpBuf = NULL, DataBuf = NULL, UdpBuf = NULL;
    ULONG               ArpLen = 0, IpLen = 0, IpHdrLen = 0, TcpLen = 0, DataLen = 0, TotalLen = 0, TcpHeaderOffset = 0;
    ULONG               UdpLen = 0;
    USHORT              SrcPort = 0, DstPort = 0, IPID = 0, FragOffset = 0;
    PLIST_ENTRY         CurrentEntry = NULL, LastEntry = NULL;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;
    ULONG               i = 0;
    PLOG_RECORD         pRecord = NULL;
    PNDIS_PACKET        Packet = PacketInfo->NdisPacket;

    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: \n"));
    
    //
    // Steps  
    // Parse the IP Packet. 
    // Look for the appropriate ports.
    // Look for the data portion and put in the Time & length there.
    //

    NdisGetFirstBufferFromPacket(
                                 Packet,
                                 &ArpBuf,
                                 &ArpH,
                                 &ArpLen,
                                 &TotalLen
                                 );

    //
    // We are guaranteed that the ARP buffer if always a different MDL, so
    // jump to the next MDL
    //
    NdisGetNextBuffer(ArpBuf, &IpBuf)

    if (IpBuf) {

        NdisQueryBuffer(IpBuf,
                        &GeneralVA,
                        &IpLen
                        );
        
        IPH = (IPHeader *) GeneralVA;
    
        if (!IPH) {
            goto FAILURE;
        }

        Src = net_short(IPH->iph_src);
        Dst = net_short(IPH->iph_dest);
        IPID = net_short(IPH->iph_id);
        //IpHdrLen = 8 * net_short(IPH->iph_length);
        IpHdrLen = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);
        
        FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
        FragOffset = net_short(FragOffset) * 8;

        bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
        bFirstFragment = bFragment && (FragOffset == 0);
        bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

        if (bFragment && (!bFirstFragment)) {
            
            //
            // Its a fragment alright and NOT the first one.
            //
            NdisAcquireSpinLock(&IPIDListLock);

            for (i = 0; i < PORT_RANGE; i++) {
            
                //
                // Found the match...
                //
                if (IPIDList[i] == IPID) {
                
                    if (bLastFragment) {
                        //
                        // Since it is the last fragment, recall
                        // the IP ID.
                        //
                        IPIDList[i] = 0xffff;
                    }

                    NdisReleaseSpinLock(&IPIDListLock);
                    
                    //
                    // Is the data in the same buffer?
                    //
                    if (IpLen <= IpHdrLen) {
                        
                        NdisGetNextBuffer(IpBuf, &DataBuf);
            
                        if(DataBuf) {
            
                            NdisQueryBuffer(DataBuf,
                                            &Data,
                                            &DataLen
                                            );

                            goto TimeStamp;
        
                        } else {
        
                            goto FAILURE;
                        }


                    } else {

                        //
                        // The Data Offsets need to be primed now.
                        //
                        DataLen = IpLen - FragOffset;
                        Data    = ((PUCHAR) GeneralVA) + IpHdrLen; 
                        goto TimeStamp;
                    }
                }
            }

            NdisReleaseSpinLock(&IPIDListLock);
            //
            // If we are here, we dont care about this IPID for this fragment.
            // Just return TRUE to continue processing.
            //
            
            //
            // Ready to go.
            //
            PacketInfo->FlowContext = FlowContext;
            PacketInfo->ClassMapContext = ClassMapContext;

            return (*Pipe->NextComponent->SubmitPacket)(
                                                 Pipe->NextComponentContext,
                                                 FlowContext->NextComponentContext, 
                                                 ClassMapContext?ClassMapContext->NextComponentContext:0,
                                                 PacketInfo);

        }

        //
        // If it is not a fragment, depending upon the protocol, process differently
        //

        switch (IPH->iph_protocol) {
        
        case IPPROTO_TCP :
            
            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Procol TCP\n"));

            if (IPH && ((USHORT)IpLen > IpHdrLen)) {

                //
                // We have more than the IP Header in this MDL.
                //
                TCPH = (TCPHeader *) ((PUCHAR)GeneralVA + IpHdrLen);
                TcpLen = IpLen - IpHdrLen;
                TcpBuf = IpBuf;

            } else {
                
                //
                // TCP Header is in the next MDL
                //
                
                NdisGetNextBuffer(IpBuf, &TcpBuf);
    
                if(TcpBuf) {
    
                    GeneralVA = NULL;
                    NdisQueryBuffer(TcpBuf,
                                    &GeneralVA,
                                    &TcpLen
                                    );
                
                    TCPH = (TCPHeader *) GeneralVA;
                } else {

                    goto FAILURE;

                }
            }

            //
            // Get the port numbers out.
            //
            SrcPort = net_short(TCPH->tcp_src);
            DstPort = net_short(TCPH->tcp_dest);

            //
            // We have the TCP Buffer now. Get to the DATA.
            //
            TcpHeaderOffset = TCP_HDR_SIZE(TCPH);

            if (TcpLen > TcpHeaderOffset) {

                //
                // We have the DATA right here!
                //

                Data = (PUCHAR)TCPH + TcpHeaderOffset;
                DataLen = TcpLen - TcpHeaderOffset;

            } else {
            
                NdisGetNextBuffer(TcpBuf, &DataBuf);
    
                if(DataBuf) {
    
                    GeneralVA = NULL;
                    NdisQueryBuffer(DataBuf,
                                    &Data,
                                    &DataLen
                                    );

                } else {

                    goto FAILURE;
                }
            }

            if (CheckInPortList(DstPort) && bFirstFragment) {

                NdisAcquireSpinLock(&IPIDListLock);
                
                // need new Entry for IPID
                for (i = 0; i < PORT_RANGE; i++) {
                    //
                    // Look for a free slot
                    //
                    if (0xffff == IPIDList[i]) {
                        
                        IPIDList[i] = IPID;
                        break;
                    
                    }


                }

                NdisReleaseSpinLock(&IPIDListLock);
                
                if (i == PORT_RANGE) {

                   TimeStmpTrace(TS_DBG_DEATH, TS_DBG_SEND, ("Couldn't find an empty IPID - Bailing \n"));
                   goto FAILURE;
                }
                //DbgBreakPoint();

            } 
            
            //
            // Let's timestmp this now.
            //
            if (CheckInPortList(DstPort)) {

                goto TimeStamp;

            } else {

                //
                // This is not one of our packet, get out.
                // 
                goto FAILURE;
            }

            break;

        case IPPROTO_UDP:
            
            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol UDP\n"));

            if (IPH && (IpLen > IpHdrLen)) {

                //
                // We have more than the IP Header in this MDL.
                //
                UDPH = (UDPHeader *) ((PUCHAR)GeneralVA + IpHdrLen);
                UdpLen = IpLen - IpHdrLen;
                UdpBuf = IpBuf;

            } else {
                
                //
                // UDP Header is in the next MDL
                //
    
                NdisGetNextBuffer(IpBuf, &UdpBuf);

                if(UdpBuf) {

                    GeneralVA = NULL;
                    NdisQueryBuffer(UdpBuf,
                                    &GeneralVA,
                                    &UdpLen
                                    );
    
                    UDPH = (UDPHeader *) GeneralVA;
                } else {
                    
                    goto FAILURE;

                }
            }

            SrcPort = net_short(UDPH->uh_src);      // Source port.
            DstPort = net_short(UDPH->uh_dest);         // Destination port.


            //
            // Get to the data. 
            //
            if (UdpLen > sizeof (UDPHeader)) {

                //
                // We have the DATA right here!
                //
                Data = (PUCHAR) UDPH + sizeof (UDPHeader);
                DataLen = UdpLen - sizeof (UDPHeader);

            } else {

                NdisGetNextBuffer(UdpBuf, &DataBuf);

                if(DataBuf) {

                    GeneralVA = NULL;
                    NdisQueryBuffer(DataBuf,
                                    &Data,
                                    &DataLen
                                    );

                } else {

                    goto FAILURE;

                }
            }


            if (CheckInPortList(DstPort) && bFirstFragment) {

                NdisAcquireSpinLock(&IPIDListLock);
                
                // need new Entry for IPID
                for (i = 0; i < PORT_RANGE; i++) {
                    //
                    // Look for a free slot
                    //
                    if (0xffff == IPIDList[i]) {
                        
                        IPIDList[i] = IPID;
                        break;
                    
                    }

                    ASSERT(FALSE);

                }

                NdisReleaseSpinLock(&IPIDListLock);
                
                //
                // Couldnt find a free IPID place holder, lets bail.
                //
                if (PORT_RANGE == i) {

                    goto FAILURE;

                }

            } 
            
            
            
            //
            // Let's timestmp this now.
            //
            if (CheckInPortList(DstPort)) {

                goto TimeStamp;

            } else {

                //
                // This is not one of our packet, get out.
                // 
                goto FAILURE;
            }

            break;

        case IPPROTO_RAW:
            
            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol RAW\n"));
            goto FAILURE;

            break;
        
        case IPPROTO_IGMP:
            
            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol IGMP\n"));
            goto FAILURE;

            break;
        
        case IPPROTO_ICMP:

            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol TCMP\n"));
            goto FAILURE;

            break;

        default:
            
            //TimeStmpTrace(TS_DBG_DEATH, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: Protocol - UNKNOWN (%d)\n", IPH->iph_protocol));
            goto FAILURE;

            //DbgBreakPoint();

        }

    } else {

        TimeStmpTrace(TS_DBG_TRACE, TS_DBG_SEND, ("[TimeStmpSubmitPacket]: NO Buffer beyond MAC Header\n"));
        goto FAILURE;

    }

TimeStamp:
    //
    // If we get here, the Data and DataLen variables have been primed.
    // Set the Time and Length.
    //
    if (Data) {
        
        pRecord = (PLOG_RECORD) Data;
        
        if (DataLen > sizeof (LOG_RECORD)) {
            
            LARGE_INTEGER   PerfFrequency;
            UINT64          Freq;

            //
            // Set the fields accordingly
            pRecord->BufferSize = DataLen;
            //pRecord->SequenceNumber = InterlockedIncrement(&GlobalSequenceNumber);
            CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

            //
            // Convert the perffrequency into 100ns interval.
            //
            Freq = 0;
            Freq |= PerfFrequency.HighPart;
            Freq = Freq << 32;
            Freq |= PerfFrequency.LowPart;


            //
            // Convert from LARGE_INTEGER to UINT64
            //
            pRecord->TimeSentWire = 0;
            pRecord->TimeSentWire |= CurrentTime.HighPart;
            pRecord->TimeSentWire = pRecord->TimeSentWire << 32;
            pRecord->TimeSentWire |= CurrentTime.LowPart;

            // Normalize cycles with the frequency.
            pRecord->TimeSentWire *= 10000000;
            pRecord->TimeSentWire /= Freq;

        }
    
    }
    //
    // Ready to go.
    //
    PacketInfo->FlowContext = FlowContext;
    PacketInfo->ClassMapContext = ClassMapContext;

    return (*Pipe->NextComponent->SubmitPacket)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext, 
        ClassMapContext?ClassMapContext->NextComponentContext:0,
        PacketInfo);

FAILURE: 

    //
    // Ready to go.
    //
    PacketInfo->FlowContext = FlowContext;
    PacketInfo->ClassMapContext = ClassMapContext;

    return (*Pipe->NextComponent->SubmitPacket)(
        Pipe->NextComponentContext,
        FlowContext->NextComponentContext, 
        ClassMapContext?ClassMapContext->NextComponentContext:0,
        PacketInfo);

}


BOOLEAN
TimeStmpReceivePacket (
    IN PPS_PIPE_CONTEXT         PipeContext,
    IN PPS_FLOW_CONTEXT         FlowContext,
    IN PPS_CLASS_MAP_CONTEXT    ClassMapContext,
    IN PNDIS_PACKET             Packet,
    IN NDIS_MEDIUM              Medium
    )
{
    PPS_PIPE_CONTEXT    Pipe = PipeContext;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH    = NULL;
    TCPHeader UNALIGNED *TCPH   = NULL;
    UDPHeader UNALIGNED *UDPH   = NULL;
    IPAddr              Src, Dst;
    PUCHAR              headerBuffer = NULL, pData = NULL;
    PNDIS_BUFFER        pFirstBuffer = NULL;
    ULONG               firstbufferLength = 0, bufferLength = 0, HeaderLength = 0;
    ULONG               TotalIpLen = 0, IPDataLength = 0, IpHdrLen = 0;
    ULONG               TotalTcpLen = 0, TcpDataLen = 0, TotalLen = 0, TcpHeaderOffset = 0, Size = 0;
    ULONG               TotalUdpLen = 0, UdpDataLen = 0, UdpHdrLen = 0;
    USHORT              SrcPort = 0, DstPort = 0, IPID = 0, FragOffset = 0;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;
    ULONG               i = 0;
    PLOG_RECORD         pRecord = NULL;
    UINT  HeaderBufferSize = NDIS_GET_PACKET_HEADER_SIZE(Packet);

    ushort          type;                       // Protocol type
    uint            ProtOffset;                 // Offset in Data to non-media info.

    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: \n"));

    NdisGetFirstBufferFromPacket(Packet,                // packet
                                 &pFirstBuffer,         // first buffer descriptor
                                 &headerBuffer,         // ptr to the start of packet
                                 &firstbufferLength,    // length of the header+lookahead
                                 &bufferLength);        // length of the bytes in the buffers

    IPH = (IPHeader *) ((PUCHAR)headerBuffer + HeaderBufferSize);
    
    // Check the header length and the version. If any of these
    // checks fail silently discard the packet.
    HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);


    if (HeaderLength >= sizeof(IPHeader) && HeaderLength <= bufferLength) {

        //
        // Get past the IP Header and get the rest of the stuff out.
        //
        TotalIpLen = (uint)net_short(IPH->iph_length);

        if ((IPH->iph_verlen & IP_VER_FLAG) == IP_VERSION &&
            TotalIpLen >= HeaderLength  && TotalIpLen <= bufferLength) {

            Src = net_short(IPH->iph_src);
            Dst = net_short(IPH->iph_dest);
            IPID = net_short(IPH->iph_id);

            FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
            FragOffset = net_short(FragOffset) * 8;

            bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
            bFirstFragment = bFragment && (FragOffset == 0);
            bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

            //
            // If this is a fragment and NOT the first one, just put the Timestamp in here.
            // Otherwise, let it get to the protocols for processing.
            //
            if (bFragment && !bFirstFragment) {

                NdisAcquireSpinLock(&IPIDListLockRecv);

                for (i = 0; i < PORT_RANGE; i++) {

                    if (IPID == IPIDListRecv[i]) {
                        
                        if (bLastFragment) {
                            //
                            // If its the last fragment, release the slot.
                            //
                            IPIDListRecv[i] = 0xffff;
                        }

                        break;
                    }

                }

                NdisReleaseSpinLock(&IPIDListLockRecv);

                if (i == PORT_RANGE) {

                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("Couldnt find an IPID that we care about, get outta here.\n"));
                    goto RECV_FAILURE;

                } 
                //
                // So we found a IPID that matches - set the timestamp and get out after this.
                //
                
                TotalLen = TotalIpLen - FragOffset;
                pData    = ((PUCHAR) IPH) + IpHdrLen; 
                
                if (TotalLen > sizeof (LOG_RECORD)) {

                    LARGE_INTEGER   PerfFrequency;
                    UINT64          RecdTime, Freq;

                    pRecord = (LOG_RECORD *) pData;
                    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);
                    
                    //
                    // Convert the perffrequency into 100ns interval.
                    //
                    Freq = 0;
                    Freq |= PerfFrequency.HighPart;
                    Freq = Freq << 32;
                    Freq |= PerfFrequency.LowPart;

                    //convert from Largeinteger to uint64
                    pRecord->TimeReceivedWire = 0;
                    pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                    pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                    pRecord->TimeReceivedWire |= CurrentTime.LowPart;

                    // Normalize cycles with the frequency.
                    pRecord->TimeReceivedWire *= 10000000;
                    pRecord->TimeReceivedWire /= Freq;

                }
                
                return TRUE;

            }

            //
            // Do the protocol specific stuff.
            //

            switch (IPH->iph_protocol) {
            case IPPROTO_TCP:
            
                TotalTcpLen = TotalIpLen - HeaderLength;
                TCPH = (TCPHeader *) (((PUCHAR)IPH) + HeaderLength);

                SrcPort = net_short(TCPH->tcp_src);
                DstPort = net_short(TCPH->tcp_dest);

                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: *TCP* Address: SRC = %x DST = %x, Port S : %x, Port D: %x\n",
                                                          IPH->iph_src, 
                                                          IPH->iph_dest, 
                                                          SrcPort, 
                                                          DstPort));

                TcpHeaderOffset = TCP_HDR_SIZE(TCPH);
                pData = (PUCHAR) TCPH + TcpHeaderOffset;
                TcpDataLen = TotalTcpLen - TcpHeaderOffset;

                if ((CheckInPortList(DstPort)) && (TcpDataLen > sizeof (LOG_RECORD))) {
                    
                    LARGE_INTEGER   PerfFrequency;
                    UINT64          RecdTime, Freq;

                    pRecord = (LOG_RECORD *) pData;
                    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);
                    
                    //
                    // Convert the perffrequency into 100ns interval.
                    //
                    Freq = 0;
                    Freq |= PerfFrequency.HighPart;
                    Freq = Freq << 32;
                    Freq |= PerfFrequency.LowPart;

                    //convert from large_integer to uint64

                    pRecord->TimeReceivedWire = 0;
                    pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                    pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                    pRecord->TimeReceivedWire |= CurrentTime.LowPart;

                    // Normalize cycles with the frequency.
                    pRecord->TimeReceivedWire *= 10000000;
                    pRecord->TimeReceivedWire /= Freq;


                } else if (CheckInPortList(DstPort)) {

                    if (TcpDataLen < sizeof(LOG_RECORD)) 
                        TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("The Datagram was too small!! IpLen:%d, Tcplen:%d HeaderOff(tcp):%d log_record:%d\n", TotalIpLen, TotalTcpLen, TcpHeaderOffset, sizeof (LOG_RECORD)));

                }
    
                //
                // If its the first fragment, keep a place holder so we know which
                // subsequent IP fragments to timestamp.
                //
                if ((CheckInPortList(DstPort)) && bFirstFragment) {

                    NdisAcquireSpinLock(&IPIDListLockRecv);
    
                    // need new Entry for IPID
                    for (i = 0; i < PORT_RANGE; i++) {
                        //
                        // Look for a free slot
                        //
                        if (0xffff == IPIDListRecv[i]) {
            
                            IPIDListRecv[i] = IPID;
                            break;
        
                        }


                    }

                    NdisReleaseSpinLock(&IPIDListLockRecv);
    
                    if (i == PORT_RANGE) {

                        TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("Couldn't find an empty IPID - Bailing \n"));
                    }
                }


                break;

            case IPPROTO_UDP:
            
                TotalUdpLen = TotalIpLen - HeaderLength;
                UDPH = (UDPHeader *) (((PUCHAR)IPH) + HeaderLength);
                
                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("PAcket %x, IPH = %x, UDPH = %x, HeaderLength = %x\n", Packet, IPH, UDPH, HeaderLength));

                UdpDataLen = TotalUdpLen - sizeof(UDPHeader);
                pData = ((PUCHAR) UDPH) + sizeof (UDPHeader);

                SrcPort = net_short(UDPH->uh_src);          // Source port.
                DstPort = net_short(UDPH->uh_dest);             // Destination port.

                if (UdpDataLen < sizeof(UDPHeader)) {
                    return TRUE;
                } 
                
                if ((CheckInPortList(DstPort)) && (UdpDataLen > sizeof(LOG_RECORD))) {
                    
                    LARGE_INTEGER   PerfFrequency;
                    UINT64          RecdTime, Freq;

                    pRecord = (LOG_RECORD *) pData;
                    CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                    //
                    // Convert the perffrequency into 100ns interval.
                    //
                    Freq = 0;
                    Freq |= PerfFrequency.HighPart;
                    Freq = Freq << 32;
                    Freq |= PerfFrequency.LowPart;

                    // convert to uint64

                    pRecord->TimeReceivedWire = 0;
                    pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                    pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                    pRecord->TimeReceivedWire |= CurrentTime.LowPart;
                                        
                    // Normalize cycles with the frequency.
                    pRecord->TimeReceivedWire *= 10000000;
                    pRecord->TimeReceivedWire /= Freq;


                    //
                    // Dont want to get rejected due to bad xsum ...
                    //
                    UDPH->uh_xsum = 0;

                } else if (CheckInPortList(DstPort)) {

                    if ((UdpDataLen) < sizeof(LOG_RECORD))
                        TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("The Datagram was too small (UDP)!! IpLen:%d, Size:%d log_record:%d\n", 
                                                                  TotalIpLen, UdpDataLen, sizeof (LOG_RECORD)));

                }

                if ((CheckInPortList(DstPort)) && bFirstFragment) {

                    NdisAcquireSpinLock(&IPIDListLockRecv);

                    // need new Entry for IPID
                    for (i = 0; i < PORT_RANGE; i++) {
                        //
                        // Look for a free slot
                        //
                        if (0xffff == IPIDListRecv[i]) {

                            IPIDListRecv[i] = IPID;
                            break;

                        }


                    }

                    NdisReleaseSpinLock(&IPIDListLockRecv);

                    if (i == PORT_RANGE) {

                        TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("Couldn't find an empty IPID - Bailing \n"));
                    }
                }

                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: *UDP* Address: SRC = %x DST = %x, Port S : %x, Port D: %x\n",
                                          IPH->iph_src, 
                                          IPH->iph_dest, 
                                          UDPH->uh_src, 
                                          UDPH->uh_dest));

                break;

            case IPPROTO_RAW:
            
                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: Protocol RAW\n"));

                break;
        
            case IPPROTO_IGMP:
            
                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: Protocol IGMP\n"));

                break;
        
            case IPPROTO_ICMP:

                TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceivePacket]: Protocol TCMP\n"));

                break;

            default:
            
                ;
                //TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("[TimeStmpReceivePacket]: Protocol - UNKNOWN (%d)\n", IPH->iph_protocol));
                //DbgBreakPoint();

            }
        }
    }

RECV_FAILURE:

    return TRUE;
}

//
// This function receives a buffer from NDIS which is indicated to the transport.
// We use this function and work past the headers (tcp, ip) and get to the data.
// Then, we timestamp and reset the checksum flags.
// We make the assumption that the lookahead is atleast 128. 
// mac header ~ 8+8, ip header ~20, tcp/udp ~ 20+options, LOG_RECORD ~ 44
// they all add up to less than 128. If this is not a good assumption, We will need
// to get into MiniportTransferData and such.
//
BOOLEAN
TimeStmpReceiveIndication(
                          IN PPS_PIPE_CONTEXT PipeContext,
                          IN PPS_FLOW_CONTEXT FlowContext,
                          IN PPS_CLASS_MAP_CONTEXT ClassMapContext,
                          IN PVOID    HeaderBuffer,
                          IN UINT     HeaderBufferSize,
                          IN PVOID    LookAheadBuffer,
                          IN UINT     LookAheadBufferSize,
                          IN UINT     PacketSize,
                          IN UINT     TransportHeaderOffset
                          )
{
    PPS_PIPE_CONTEXT    Pipe = PipeContext;
    LARGE_INTEGER       CurrentTime;
    IPHeader UNALIGNED  *IPH    = NULL;
    TCPHeader UNALIGNED *TCPH   = NULL;
    UDPHeader UNALIGNED *UDPH   = NULL;
    IPAddr              Src, Dst;
    PUCHAR              headerBuffer = NULL, pData = NULL;
    PNDIS_BUFFER        pFirstBuffer = NULL;
    ULONG               firstbufferLength = 0, bufferLength = 0, HeaderLength = 0;
    ULONG               TotalIpLen = 0, IPDataLength = 0, IpHdrLen = 0;
    ULONG               TotalTcpLen = 0, TcpDataLen = 0, TotalLen = 0, TcpHeaderOffset = 0, Size = 0;
    ULONG               TotalUdpLen = 0, UdpDataLen = 0, UdpHdrLen = 0;
    USHORT              SrcPort = 0, DstPort = 0, IPID = 0, FragOffset = 0;
    BOOLEAN             bFragment, bFirstFragment, bLastFragment;
    ULONG               i = 0;
    PLOG_RECORD         pRecord = NULL;
    ushort              type;                       // Protocol type
    uint                ProtOffset;                 // Offset in Data to non-media info.
    UINT                MoreHeaderInLookAhead = 0;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: \n"));

    //
    // Don't know anything about the MAC headers, piggy back from PSCHED...
    // Calculate if the header is more than the standard HeaderBufferSize (i.e. SNAP header, etc.)
    //
    MoreHeaderInLookAhead = TransportHeaderOffset - HeaderBufferSize;

    if (MoreHeaderInLookAhead) {
        
        //
        // Just munge these, so that we can actually get down to business.
        //
        ((PUCHAR) LookAheadBuffer) += MoreHeaderInLookAhead;
        LookAheadBufferSize -= MoreHeaderInLookAhead;

    }

    if (LookAheadBufferSize > sizeof(IPHeader)) {

        IPH = (IPHeader *) (PUCHAR)LookAheadBuffer;
    
        // Check the header length and the version. If any of these
        // checks fail silently discard the packet.
        HeaderLength = ((IPH->iph_verlen & (uchar)~IP_VER_FLAG) << 2);

        if (HeaderLength >= sizeof(IPHeader) && HeaderLength <= LookAheadBufferSize) {

            //
            // Get past the IP Header and get the rest of the stuff out.
            //
            TotalIpLen = (uint)net_short(IPH->iph_length);

            if ((IPH->iph_verlen & IP_VER_FLAG) == IP_VERSION &&
                TotalIpLen >= HeaderLength  && TotalIpLen <= LookAheadBufferSize) {

                Src = net_short(IPH->iph_src);
                Dst = net_short(IPH->iph_dest);
                IPID = net_short(IPH->iph_id);

                FragOffset = IPH->iph_offset & IP_OFFSET_MASK;
                FragOffset = net_short(FragOffset) * 8;

                bFragment = (IPH->iph_offset & IP_MF_FLAG) || (FragOffset > 0);
                bFirstFragment = bFragment && (FragOffset == 0);
                bLastFragment = bFragment && (!(IPH->iph_offset & IP_MF_FLAG));

                //
                // If this is a fragment and NOT the first one, just put the Timestamp in here.
                // Otherwise, let it get to the protocols for processing.
                //
                if (bFragment && !bFirstFragment) {

                    NdisAcquireSpinLock(&IPIDListLockRecv);

                    for (i = 0; i < PORT_RANGE; i++) {

                        if (IPID == IPIDListRecv[i]) {
                        
                            if (bLastFragment) {
                                //
                                // If its the last fragment, release the slot.
                                //
                                IPIDListRecv[i] = 0xffff;
                            }

                            break;
                        }

                    }

                    NdisReleaseSpinLock(&IPIDListLockRecv);

                    if (i == PORT_RANGE) {

                        TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("Couldnt find an IPID that we care about, get outta here.\n"));
                        goto RECV_FAILURE;

                    } 
                    //
                    // So we found a IPID that matches - set the timestamp and get out after this.
                    //
                
                    TotalLen = TotalIpLen - FragOffset;
                    pData    = ((PUCHAR) IPH) + IpHdrLen; 
                
                    if (TotalLen >= sizeof (LOG_RECORD)) {

                        LARGE_INTEGER   PerfFrequency;
                        UINT64          RecdTime, Freq;

                        pRecord = (LOG_RECORD *) pData;
                        CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                        //
                        // Convert the perffrequency into 100ns interval.
                        //
                        Freq = 0;
                        Freq |= PerfFrequency.HighPart;
                        Freq = Freq << 32;
                        Freq |= PerfFrequency.LowPart;

                        //
                        // Convert from LARGE_INTEGER to UINT64
                        //
                        pRecord->TimeReceivedWire = 0;
                        pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                        pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                        pRecord->TimeReceivedWire |= CurrentTime.LowPart;
                        
                        // Normalize cycles with the frequency.
                        pRecord->TimeReceivedWire *= 10000000;
                        pRecord->TimeReceivedWire /= Freq;


                    }
                
                    return TRUE;

                }

                //
                // Do the protocol specific stuff.
                //

                switch (IPH->iph_protocol) {
                case IPPROTO_TCP:
            
                    TotalTcpLen = TotalIpLen - HeaderLength;
                    TCPH = (TCPHeader *) (((PUCHAR)IPH) + HeaderLength);

                    SrcPort = net_short(TCPH->tcp_src);
                    DstPort = net_short(TCPH->tcp_dest);

                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: *TCP* Address: SRC = %x DST = %x, Port S : %x, Port D: %x\n",
                                                              IPH->iph_src, 
                                                              IPH->iph_dest, 
                                                              SrcPort, 
                                                              DstPort));

                    TcpHeaderOffset = TCP_HDR_SIZE(TCPH);
                    pData = (PUCHAR) TCPH + TcpHeaderOffset;
                    TcpDataLen = TotalTcpLen - TcpHeaderOffset;

                    if ((CheckInPortList(DstPort)) && (TcpDataLen > sizeof (LOG_RECORD))) {
                    
                        LARGE_INTEGER   PerfFrequency;
                        UINT64          RecdTime, Freq;

                        pRecord = (LOG_RECORD *) pData;
                        CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                        //
                        // Convert the perffrequency into 100ns interval.
                        //
                        Freq = 0;
                        Freq |= PerfFrequency.HighPart;
                        Freq = Freq << 32;
                        Freq |= PerfFrequency.LowPart;

                        // convert to uint64
                        pRecord->TimeReceivedWire = 0;
                        pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                        pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                        pRecord->TimeReceivedWire |= CurrentTime.LowPart;
                    
                        // Normalize cycles with the frequency.
                        pRecord->TimeReceivedWire *= 10000000;
                        pRecord->TimeReceivedWire /= Freq;


                        //
                        //pRecord->TimeReceivedWire);
                        //

                    } else if (CheckInPortList(DstPort)) {

                        if (TcpDataLen < sizeof(LOG_RECORD)) 
                            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV,
                            ("The Datagram was too small!! IpLen:%d, Tcplen:%d HeaderOff(tcp):%d log_record:%d\n", TotalIpLen, TotalTcpLen, TcpHeaderOffset, sizeof (LOG_RECORD)));

                    }
    
                    //
                    // If its the first fragment, keep a place holder so we know which
                    // subsequent IP fragments to timestamp.
                    //
                    if ((CheckInPortList(DstPort)) && bFirstFragment) {

                        NdisAcquireSpinLock(&IPIDListLockRecv);
    
                        // need new Entry for IPID
                        for (i = 0; i < PORT_RANGE; i++) {
                            //
                            // Look for a free slot
                            //
                            if (0xffff == IPIDListRecv[i]) {
            
                                IPIDListRecv[i] = IPID;
                                break;
        
                            }


                        }

                        NdisReleaseSpinLock(&IPIDListLockRecv);
    
                        if (i == PORT_RANGE) {

                            TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("Couldn't find an empty IPID - Bailing \n"));
                        }
                    }


                    break;

                case IPPROTO_UDP:
            
                    TotalUdpLen = TotalIpLen - HeaderLength;
                    UDPH = (UDPHeader *) (((PUCHAR)IPH) + HeaderLength);
                
                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("PAcket %x, IPH = %x, UDPH = %x, HeaderLength = %x\n", LookAheadBuffer, IPH, UDPH, HeaderLength));

                    UdpDataLen = TotalUdpLen - sizeof(UDPHeader);
                    pData = ((PUCHAR) UDPH) + sizeof (UDPHeader);

                    SrcPort = net_short(UDPH->uh_src);      // Source port.
                    DstPort = net_short(UDPH->uh_dest);         // Destination port.

                    if (UdpDataLen < sizeof(UDPHeader)) {
                        return TRUE;
                    } 
                
                    if ((CheckInPortList(DstPort)) && (UdpDataLen > sizeof(LOG_RECORD))) {

                        LARGE_INTEGER   PerfFrequency;
                        UINT64          RecdTime, Freq;

                        pRecord = (LOG_RECORD *) pData;
                        CurrentTime = KeQueryPerformanceCounter(&PerfFrequency);

                        //
                        // Convert the perffrequency into 100ns interval.
                        //
                        Freq = 0;
                        Freq |= PerfFrequency.HighPart;
                        Freq = Freq << 32;
                        Freq |= PerfFrequency.LowPart;

                        pRecord->TimeReceivedWire = 0;
                        pRecord->TimeReceivedWire |= CurrentTime.HighPart;
                        pRecord->TimeReceivedWire = pRecord->TimeReceivedWire << 32;
                        pRecord->TimeReceivedWire |= CurrentTime.LowPart;

                        // Normalize cycles with the frequency.
                        pRecord->TimeReceivedWire *= 10000000;
                        pRecord->TimeReceivedWire /= Freq;


                        //
                        // Dont want to get rejected due to bad xsum ...
                        //
                        UDPH->uh_xsum = 0;

                    } else if (CheckInPortList(DstPort)) {

                        if ((UdpDataLen) < sizeof(LOG_RECORD))
                            TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("The Datagram was too small (UDP)!! IpLen:%d, Size:%d log_record:%d\n", 
                                                                      TotalIpLen, UdpDataLen, sizeof (LOG_RECORD)));

                    }

                    if ((CheckInPortList(DstPort)) && bFirstFragment) {

                        NdisAcquireSpinLock(&IPIDListLockRecv);

                        // need new Entry for IPID
                        for (i = 0; i < PORT_RANGE; i++) {
                            //
                            // Look for a free slot
                            //
                            if (0xffff == IPIDListRecv[i]) {

                                IPIDListRecv[i] = IPID;
                                break;

                            }


                        }

                        NdisReleaseSpinLock(&IPIDListLockRecv);

                        if (i == PORT_RANGE) {

                            TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("Couldn't find an empty IPID - Bailing \n"));
                        }
                    }

                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: *UDP* Address: SRC = %x DST = %x, Port S : %x, Port D: %x\n",
                                                              IPH->iph_src, 
                                                              IPH->iph_dest, 
                                                              UDPH->uh_src, 
                                                              UDPH->uh_dest));

                    break;

                case IPPROTO_RAW:
            
                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: Protocol RAW\n"));

                    break;
        
                case IPPROTO_IGMP:
            
                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: Protocol IGMP\n"));

                    break;
        
                case IPPROTO_ICMP:

                    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: Protocol TCMP\n"));

                    break;

                default:
            
                
                    TimeStmpTrace(TS_DBG_DEATH, TS_DBG_RECV, ("[TimeStmpReceiveIndication]: Protocol - UNKNOWN (%d)\n", IPH->iph_protocol));

                    //DbgBreakPoint();

                }
            }
        }
    }

RECV_FAILURE:

    return TRUE;
}


VOID
TimeStmpSetInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN void *Data)
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    PPS_FLOW_CONTEXT Flow = FlowContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_OID, ("[TimeStmpSetInformation]:\n"));
    (*Pipe->NextComponent->SetInformation)(
        Pipe->NextComponentContext,
        (Flow)?Flow->NextComponentContext:0,
        Oid,
        Len,
        Data);
}


VOID
TimeStmpQueryInformation (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_FLOW_CONTEXT FlowContext,
    IN NDIS_OID Oid,
    IN ULONG Len,
    IN PVOID Data,
    IN OUT PULONG BytesWritten,
    IN OUT PULONG BytesNeeded,
    IN OUT PNDIS_STATUS Status)
{
    PPS_PIPE_CONTEXT Pipe = PipeContext;
    PPS_FLOW_CONTEXT Flow = FlowContext;
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_OID, ("[TimeStmpQueryInformation]:\n"));
    (*Pipe->NextComponent->QueryInformation)(
        Pipe->NextComponentContext,
        (Flow)?Flow->NextComponentContext:0,
        Oid,
        Len,
        Data,
        BytesWritten,
        BytesNeeded,
        Status);
}

NDIS_STATUS 
TimeStmpCreateClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN HANDLE PsClassMapContext,
    IN PTC_CLASS_MAP_FLOW ClassMap,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    )
{
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_CLASS_MAP, ("[TimeStmpCreateClassMap]: \n"));
    return (*PipeContext->NextComponent->CreateClassMap)(
        PipeContext->NextComponentContext,
        PsClassMapContext,
        ClassMap,
        ComponentClassMapContext->NextComponentContext);
}

NDIS_STATUS 
TimeStmpDeleteClassMap (
    IN PPS_PIPE_CONTEXT PipeContext,
    IN PPS_CLASS_MAP_CONTEXT ComponentClassMapContext
    )
{
    TimeStmpTrace(TS_DBG_TRACE, TS_DBG_CLASS_MAP, ("[TimeStmpDeleteClassMap]: \n"));
    return (*PipeContext->NextComponent->DeleteClassMap)(
        PipeContext->NextComponentContext,
        ComponentClassMapContext->NextComponentContext);
}
    
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    PSI_INFO        Component;
    NDIS_HANDLE     ConfigHandle;
    NDIS_STATUS     Status;
    NDIS_STRING     ComponentKey = NDIS_STRING_CONST("DisplayName");
    NDIS_STRING     ComponentName = NDIS_STRING_CONST("TimeStmp");
    PNDIS_CONFIGURATION_PARAMETER pConfigParam;
    NDIS_STRING     PsParamKey;
    PWSTR           p = RegistryPath->Buffer + RegistryPath->Length;
    PS_DEBUG_INFO   Dbg;
    ULONG           i = 0;

    // The last word of Registry Path points to the driver name.
    // NdisOpenProtocol needs that name!
    while(p != RegistryPath->Buffer && *p != L'\\')
        p-- ;
    p++;
    RtlInitUnicodeString(&PsParamKey, p);
    DbgPrint("PsParamKey:%s\n", PsParamKey);

    NdisOpenProtocolConfiguration(&Status, &ConfigHandle, &PsParamKey);

    DbgPrint("Status of NdisOpenProtocol:%x\n", Status);

    if (!NT_SUCCESS(Status)) {
        goto failure;
    }

    //
    // Check if psched is installed by opening it.
    // If it fails, we dont load either.
    //
    Status = CheckForPsched();
    
    if (!NT_SUCCESS(Status)) {
        
        DbgPrint("PSCHED is NOT installed. Timestmp is bailing too\n");
        goto failure;
    }

    IoctlInitialize(DriverObject);

	// this list maintains a list of all ports that need to be timestamped.
    InitializeListHead(&PortList);
    NdisAllocateSpinLock(&PortSpinLock);
    
    DriverObject->DriverUnload = TimeStmpUnload;
    
    
    //
    // We need to keep track of IPIDs for dealing with fragments 
    // that we need to stamp...
    // 
    for (i = 0; i < PORT_RANGE; i++) {
        IPIDList[i] = 0xffff;
    }

    NdisAllocateSpinLock(&IPIDListLock);

    //
    // Do the same for the receive side.
    // 
    for (i = 0; i < PORT_RANGE; i++) {
        IPIDListRecv[i] = 0xffff;
    }

    NdisAllocateSpinLock(&IPIDListLockRecv);


    if ( NT_SUCCESS( Status )) 
    {
        // Read the name of the component from the registry
#if 0
        NdisReadConfiguration( &Status,
                               &pConfigParam,
                               ConfigHandle,
                               &ComponentKey,
                               NdisParameterString);
        if( NT_SUCCESS( Status ))
        {
            RtlInitUnicodeString(&Component.ComponentName,
                                pConfigParam->ParameterData.StringData.Buffer);
#else 
            RtlInitUnicodeString(&Component.ComponentName, ComponentName.Buffer);
#endif

            Component.Version = PS_COMPONENT_CURRENT_VERSION;
            Component.PacketReservedLength = 0;
            Component.PipeContextLength = sizeof(PS_PIPE_CONTEXT);
            Component.FlowContextLength = sizeof(PS_FLOW_CONTEXT);
            Component.ClassMapContextLength = sizeof(PS_CLASS_MAP_CONTEXT);
            Component.SupportedOidsLength  = 0;
            Component.SupportedOidList = 0;
            Component.SupportedGuidsLength = 0;
            Component.SupportedGuidList = 0;
            Component.InitializePipe = TimeStmpInitializePipe;
            Component.ModifyPipe = TimeStmpModifyPipe;
            Component.DeletePipe = TimeStmpDeletePipe;
            Component.CreateFlow = TimeStmpCreateFlow;
            Component.ModifyFlow = TimeStmpModifyFlow;
            Component.DeleteFlow = TimeStmpDeleteFlow;
            Component.CreateClassMap = TimeStmpCreateClassMap;
            Component.DeleteClassMap = TimeStmpDeleteClassMap;
            Component.SubmitPacket = TimeStmpSubmitPacket;
            Component.ReceivePacket = TimeStmpReceivePacket;
            Component.ReceiveIndication = TimeStmpReceiveIndication;
            Component.SetInformation = TimeStmpSetInformation;
            Component.QueryInformation = TimeStmpQueryInformation;

            //
            // Call Psched's RegisterPsComponent
            //
            Status = RegisterPsComponent(&Component, sizeof(Component), 
                                         &Dbg);
            if(Status != NDIS_STATUS_SUCCESS)
            {
                
                DbgPrint("Status of RegisterPsComponent%x\n", Status);

                TimeStmpTrace(TS_DBG_DEATH, TS_DBG_INIT, 
                          ("DriverEntry: RegisterPsComponent Failed \n"));
            } 
            else 
            {
                
                DbgPrint("Status of RegisterPsComponent:%x\n", Status);

            }

#if 0
                
        }
        else 
        {
            DbgPrint("Status of NdisReadProtocol:%x\n", Status);
            
            DbgBreakPoint();
            TimeStmpTrace(TS_DBG_DEATH, TS_DBG_INIT, 
                      ("DriverEntry: ComponentName not specified \n"));
        }
#endif
    }
    else 
    
    {
        DbgPrint("Status of NdisOpenProtocol:%x\n", Status);

        TimeStmpTrace(TS_DBG_DEATH, TS_DBG_INIT,
                  ("DriverEntry: Can't read driver information in registry"
                   "\n"));
    }

failure:
    return Status;
}


//
// The following function checks for the existence of PSCHED on the machine.
// The assumption being that PSCHED gets loaded before TimeStmp on a system.
// If we can open the device, it means that PSCHED is on, otherwise, we bail.
// This fix is for Bug - 321618
//
NTSTATUS
CheckForPsched(
               VOID
               )

{
    NTSTATUS                    status;
    IO_STATUS_BLOCK             ioStatusBlock;
    OBJECT_ATTRIBUTES           objectAttr;

    InitializeObjectAttributes(
        &objectAttr,
        &PschedDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = NtCreateFile(
                &PschedHandle,
                GENERIC_READ,
                &objectAttr,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0L);

    if (!NT_SUCCESS(status)) {

        return status;

    } else {

        NtClose(PschedHandle);

    }

    return status;
}

PPORT_ENTRY 
CheckInPortList(USHORT Port) {

	PLIST_ENTRY		ListEntry;
	PPORT_ENTRY		pPortEntry;
	
	NdisAcquireSpinLock(&PortSpinLock);
	ListEntry = PortList.Flink;
	
	while (ListEntry != &PortList) {

		pPortEntry = CONTAINING_RECORD(ListEntry, PORT_ENTRY, Linkage);
		if (Port == pPortEntry->Port) {
		
			//DbgPrint("Found Port%d\n", Port);
			NdisReleaseSpinLock(&PortSpinLock);
			return pPortEntry;

		} else {
		
			ListEntry = ListEntry->Flink;
			//DbgPrint("NOT Found Trying NEXT\n");
		}
		
	}

	NdisReleaseSpinLock(&PortSpinLock);
	//DbgPrint("NOT Found returning from function\n");
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tools\timestmp\ioctl.c ===
#include "timestmp.h"

#define FRIENDLY_NAME 	L"\\DosDevices\\Timestmp"

NTSTATUS
IoctlInitialize(
    PDRIVER_OBJECT 	DriverObject
    )

/*++

Routine Description:

    Perform initialization 

Arguments:

    DriverObject - pointer to DriverObject from DriverEntry
    InitShutdownMask - pointer to mask used to indicate which events have been
        successfully init'ed

Return Value:

    STATUS_SUCCESS if everything worked ok

--*/

{
    NTSTATUS Status;
    UINT FuncIndex;

    //
    // Initialize the driver object's entry points
    //

    DriverObject->FastIoDispatch = NULL;

    for (FuncIndex = 0; FuncIndex <= IRP_MJ_MAXIMUM_FUNCTION; FuncIndex++) {
        DriverObject->MajorFunction[FuncIndex] = IoctlHandler;
    }

	RtlInitUnicodeString(&TimestmpDriverName,   
                     L"\\Device\\Timestmp");

    Status = IoCreateDevice(DriverObject,
                            0,
                            &TimestmpDriverName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &TimestmpDeviceObject);

    if ( NT_SUCCESS( Status )) {

		// Now create a symbolic link so that apps can open with createfile.
		
        DbgPrint("IoCreateDevice SUCCESS!\n");

	 	RtlInitUnicodeString (&symbolicLinkName, FRIENDLY_NAME);

	 	DbgPrint("The DeviceName(%ws) and FriendlyName(%ws) are OK\n", TimestmpDriverName, symbolicLinkName);
		Status = IoCreateSymbolicLink(&symbolicLinkName, &TimestmpDriverName);

 		if (!NT_SUCCESS (Status)) {

	    	DbgPrint("Failed to create symbolic link: %lx\n", Status);
     		//IoDeleteDevice(TimestmpDeviceObject);
	     	return STATUS_UNSUCCESSFUL;
 		}

        TimestmpDeviceObject->Flags |= DO_BUFFERED_IO;

    } else {
    
        DbgPrint("IoCreateDevice failed. Status = %x\n", Status);
        TimestmpDeviceObject = NULL;
    }

    return Status;
}


NTSTATUS
IoctlHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
    Irp      - pointer to an I/O Request Packet

Return Value:

    None

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PVOID               ioBuffer;
    ULONG               inputBufferLength;
    ULONG               outputBufferLength;
    ULONG               ioControlCode;
    UCHAR				saveControlFlags;
    NTSTATUS            Status = STATUS_SUCCESS;
	PPORT_ENTRY			pPortEntry;
	PLIST_ENTRY			ListEntry;
	USHORT				Port = 0;
    PAGED_CODE();

    //
    // Init to default settings- we only expect 1 type of
    //     IOCTL to roll through here, all others an error.
    //

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuffer           	= Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  	= irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength 	= irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode 		= irpStack->Parameters.DeviceIoControl.IoControlCode;
    saveControlFlags 	= irpStack->Control;


	
    switch (irpStack->MajorFunction) {

    case IRP_MJ_CREATE:
		DbgPrint("CREATE\n");
        break;

    case IRP_MJ_READ:
		DbgPrint("READ\n");
        break;

    case IRP_MJ_CLOSE:
    	DbgPrint("CLOSE\n");
        DbgPrint("FileObject %X\n", irpStack->FileObject);

        RemoveAllPortsForFileObject(irpStack->FileObject);
        
        //
        // make sure we clean all the objects for this particular
        // file object, since it's closing right now.
        //

        break;

    case IRP_MJ_CLEANUP:
		DbgPrint("CLEANUP\n");

        break;

    case IRP_MJ_SHUTDOWN:
    	DbgPrint("Shutdown\n");
        break;

    case IRP_MJ_DEVICE_CONTROL:

		DbgPrint("The ioBuffer is %X and the contents are %d\n", ioBuffer, Port);
		Port = *(USHORT *)ioBuffer;
		DbgPrint("The Port number being added is %d\n", Port);

        switch (ioControlCode) {

        case IOCTL_TIMESTMP_REGISTER_PORT:
			DbgPrint("Register\n");
			//
			// Grab the PortList lock and Insert the new port.
			//
			NdisAcquireSpinLock(&PortSpinLock);

			pPortEntry = ExAllocatePoolWithTag(NonPagedPool,sizeof(PORT_ENTRY),'pmST');

			if (pPortEntry) {

				InitializeListHead(&pPortEntry->Linkage);
				pPortEntry->Port = Port;
				pPortEntry->FileObject = irpStack->FileObject;
				InsertHeadList(&PortList, &pPortEntry->Linkage);
				DbgPrint("Successfully inserted %d\n", Port);											

			} else {

				DbgPrint("Couldn't allocate memory\n");

			}
			
			NdisReleaseSpinLock(&PortSpinLock);
        	break;

		case IOCTL_TIMESTMP_DEREGISTER_PORT:

			DbgPrint("DERegister\n");
			//
			// Grab the PortList lock and REMOVE the new port.
			//
			NdisAcquireSpinLock(&PortSpinLock);

			pPortEntry = CheckInPortList(Port);
			if (pPortEntry) {

				RemoveEntryList(&pPortEntry->Linkage);
				ExFreePool(pPortEntry);
				
				DbgPrint("Successfully removed/freed %d\n", Port);											

			} else {

				DbgPrint("Couldn't find port %d\n", Port);

			}

			
			NdisReleaseSpinLock(&PortSpinLock);

	        break;
        
        }	// switch (ioControlCode)
        
        break;


    default:
        DbgPrint("GPCIoctl: Unknown IRP major function = %08X\n", irpStack->MajorFunction);

        Status = STATUS_UNSUCCESSFUL;
        break;
    }

    DbgPrint("GPCIoctl: Status=0x%X, IRP=0x%X, outSize=%d\n", Status, (ULONG_PTR)Irp,  outputBufferLength);
    
    if (Status != STATUS_PENDING) {

        //
        // IRP completed and it's not Pending, we need to restore the Control flags,
        // since it might have been marked as Pending before...
        //

        irpStack->Control = saveControlFlags;
        
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = outputBufferLength;
        
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }


    return Status;

} // GPCIoctl




VOID
IoctlCleanup(
	    	)

/*++

Routine Description:

    Cleanup code for Initialize

Arguments:

    ShutdownMask - mask indicating which functions need to be cleaned up

Return Value:

    None

--*/

{

	IoDeleteDevice( TimestmpDeviceObject );

}

VOID
RemoveAllPortsForFileObject(
							PFILE_OBJECT FileObject
							)
{

	PLIST_ENTRY		ListEntry;
	PPORT_ENTRY		pPortEntry;
	
	NdisAcquireSpinLock(&PortSpinLock);
	ListEntry = PortList.Flink;
	
	while (ListEntry != &PortList) {

		pPortEntry = CONTAINING_RECORD(ListEntry, PORT_ENTRY, Linkage);

		ListEntry = ListEntry->Flink;

		if (FileObject == pPortEntry->FileObject) {

			DbgPrint("Deleting Port%d for FileObject0x%X\n", pPortEntry->Port, pPortEntry->FileObject);
			RemoveEntryList(&pPortEntry->Linkage);
			ExFreePool(pPortEntry);

		}
		
	}

	NdisReleaseSpinLock(&PortSpinLock);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tools\tsinstl\main.c ===
//
// Popup choices and install Timestamp driver.
//
// ShreeM (January 31, 1999)
//
// This command line based installation program does the following -
// 1. TcEnumerateInterfaces.
// 2. Display these interfaces to the user.
// 3. Based on the user input - Plumb the registry.
// 4. Ask the user if the service needs to be AUTO or MANUAL.
//

#define UNICODE
#define INITGUID
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <wmium.h>
#include <ntddndis.h>
#include <qos.h>
#include <qossp.h>
#include <wtypes.h>
#include <traffic.h>
#include <tcerror.h>
#include <tcguid.h>
#include <winsock2.h>
#include <ndisguid.h>
#include <tlhelp32.h>
#include <ntddpsch.h>

#define LAST_COMPATIBLE_OS_VERSION  2050

HANDLE  hClient = NULL;
ULONG   ClientContext = 12;
BOOLEAN WANlink = FALSE;
#define REGKEY_SERVICES                 TEXT("System\\CurrentControlSet\\Services")
#define REGKEY_PSCHED                   TEXT("System\\CurrentControlSet\\Services\\Psched")
#define REGKEY_PSCHED_PARAMS            TEXT("System\\CurrentControlSet\\Services\\Psched\\Parameters")
#define REGKEY_PSCHED_PARAMS_ADAPTERS   TEXT("System\\CurrentControlSet\\Services\\Psched\\Parameters\\Adapters")
#define REGKEY_TIMESTMP                 TEXT("System\\CurrentControlSet\\Services\\TimeStmp")
TCHAR   Profiles[] = TEXT("LANTEST");
TCHAR   Lantest[] = TEXT("TokenBucketConformer\0TrafficShaper\0DRRSequencer\0TimeStmp");

//
// Function prototype
//

VOID ShutdownNT();

VOID _stdcall NotifyHandler(
              HANDLE   ClRegCtx, 
              HANDLE   ClIfcCtx, 
              ULONG    Event, 
              HANDLE   SubCode, 
              ULONG    BufSize,
              PVOID    Buffer)
{                                                                                                            
        //                                                                                                   
        // This function may get executed in a new thread, so we can't fire the events directly (because     
        // it breaks some clients, like VB and IE.)  To get around this, we'll fire off an APC in the origina
        // thread, which will handle the actual event firing.                                                
        //                                                                                                   
    OutputDebugString(TEXT("Notify called\n"));

                                                                                                             
}                                                                                                            

//
// Delete the service and cleanup Psched regkeys
//
BOOLEAN
DeleteTimeStamp(PTC_IFC_DESCRIPTOR pIf);
            
// Just delete the service (no psched stuff)
VOID RemoveTimeStampService();


void _cdecl main(
          INT argc,
          CHAR *argv[]
          )
{      
    
    TCI_CLIENT_FUNC_LIST ClientHandlerList;
    ULONG   err;
    TCHAR   SzBuf[MAX_PATH], *TBuffer, *KeyBuffer;
    ULONG   i = 0, len = 0, j = 0, cb = 0, Number = 0, size = 0, interfaceid = 0;
    WCHAR   servicetype, response;
    BYTE    *Buffer;
    TC_IFC_DESCRIPTOR   *pIf, WanIf;
    DWORD   ret, Disposition, starttype, choice, InstallFlag = -1;
    HKEY    hConfigKey, TimeStampKey;
    SC_HANDLE    schService;
    SC_HANDLE    schSCManager;
    BOOLEAN Success = FALSE;
    OSVERSIONINFO       osversion;
    
    ClientHandlerList.ClNotifyHandler               = NotifyHandler;
    ClientHandlerList.ClAddFlowCompleteHandler      = NULL;
    ClientHandlerList.ClModifyFlowCompleteHandler   = NULL;
    ClientHandlerList.ClDeleteFlowCompleteHandler   = NULL;
    

    wprintf(TEXT("Installer for Time Stamp module 1.0 for Windows NT (c) Microsoft Corp.\n\n"));

    // check if the psched versions will be compatible before doing anything here.
    osversion.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    osversion.dwBuildNumber = 0;
    GetVersionEx(&osversion);
    if (osversion.dwBuildNumber < LAST_COMPATIBLE_OS_VERSION) {
        wprintf(TEXT("Install ERROR!\nYour current Windows 2000 OS build number is %d.\n"), osversion.dwBuildNumber);
        wprintf(TEXT("To use the version of TIMESTMP in the QoS Tools CD, you will be required to upgrade \nto an OS build number of atleast 2050 or later.\n"));
        return;
    }
    
    wprintf(TEXT("Running this program will (un)install this module on one Interface at a time.\n"));
    wprintf(TEXT("You will the prompted for basic choices in the installation process.\n"));
    
    j = 0;
get_again:
    wprintf(TEXT("[1] Install\n[2] Uninstall\n[3] Exit\n Your Choice:"));
    fflush(stdin);
    wscanf(TEXT("%d"), &choice);

    if (1 == choice) {
        InstallFlag = 1;
    } else if (2 == choice) {
        InstallFlag = 0;
    } else if (3 == choice) {
        return;
    } else if (j < 3) {
        j++;
        goto get_again;
    } else {
        return;
    }

    err = TcRegisterClient(
              CURRENT_TCI_VERSION,
              (HANDLE)UlongToPtr(ClientContext),
              &ClientHandlerList,
              &hClient
              );

    if (NO_ERROR != err) {

        hClient = NULL;
        wsprintf(SzBuf, TEXT("Error registering Client: %d - %d\n"), err, GetLastError());
        OutputDebugString(SzBuf);
        wprintf(TEXT("INSTALLER: QoS is not installed on this machine\n\n"));

        //
        // However, if it should be ok to Uninstall the Timestmp service using this easily.
        //
        if (0 == InstallFlag) {
            RemoveTimeStampService();
        }
        return;
    
    } else {

        OutputDebugString(TEXT("Registered Client:\n"));

    }
    
    size = 0;
    // Query Buffer Size required.
    err = TcEnumerateInterfaces(	
                                hClient,
                                &size,
                                (TC_IFC_DESCRIPTOR *)NULL
                                );
    
    if (NO_ERROR != err) {
        wsprintf(SzBuf, TEXT("Error Enumerating Interfaces: %d - (size reqd. %d) \n"), err, size);
        OutputDebugString(SzBuf);

    } else {

        wsprintf(SzBuf, TEXT("Enumerating Interfaces works??? : %d - ITS OK!\n"), size);
        OutputDebugString(SzBuf);
        wprintf(TEXT("INSTALLER: QoS is either not installed on this machine\n\t OR \n"));
        wprintf(TEXT("None of the adapters are enabled for QoS\n"));
        
        //
        // However, if it should be ok to Uninstall the Timestmp service using this easily.
        //
        if (0 == InstallFlag) {
            RemoveTimeStampService();
        }

        wprintf(TEXT("Exiting...\n"));

        goto cleanup_no_free;
    }

    // if there are no interfaces (qos is not installed on this machine), get out.
    // 
    if (!size) {
        wprintf(TEXT("INSTALLER: QoS is either not installed on this machine\n\t OR \n"));
        wprintf(TEXT("None of the adapters are enabled for QoS\n"));

        //
        // However, if it should be ok to Uninstall the Timestmp service using this easily.
        //
        if (0 == InstallFlag) {
            RemoveTimeStampService();
        }
        
        wprintf(TEXT("Exiting...\n"));

        goto cleanup_no_free;
    }

    // query the interfaces
    Buffer = malloc (size);
    err = TcEnumerateInterfaces(	
                                hClient,
                                &size,
                                (TC_IFC_DESCRIPTOR *)Buffer
                                );
    
    if (NO_ERROR != err) {
        wsprintf(SzBuf, TEXT("Error Enumerating Interfaces: %d (size:%d)!\n"), err, size);
        OutputDebugString(SzBuf);
        
        //
        // However, if it should be ok to Uninstall the Timestmp service using this easily.
        //
        if (0 == InstallFlag) {
            RemoveTimeStampService();
        }
        
        wprintf(TEXT("Exiting...\n"));

        goto cleanup;

    } else {

        OutputDebugString(TEXT("OK, so we got the interfaces.\n"));

    }

    // Display the interfaces for the user.
    wprintf(TEXT("\nThe interfaces available for (un)installing time stamp module are - \n"));
    len = 0;

    for (i = 1; len < size ; i++) {

        pIf = (PTC_IFC_DESCRIPTOR)(Buffer + len);
        wprintf(TEXT("[%d]:%ws\n\t%ws\n"), i, pIf->pInterfaceName, pIf->pInterfaceID);

        // Move to next interface
        len += pIf->Length;
        
        if (NULL != wcsstr(pIf->pInterfaceName, L"WAN")) {
            wprintf(TEXT("Please disconnect WAN links before installing Timestmp\n"));
            goto cleanup;
        }

    }

    wprintf(TEXT("[%d]:NDISWANIP (the WAN Interface)\n"), i);
    
    // Try to get the interface ID thrice...
    j = 0;

get_interfaceid:
    
    wprintf(TEXT("\nYour choice:"));
    fflush(stdin);

    wscanf(TEXT("%d"), &interfaceid);
    
    if (interfaceid < 1 || (interfaceid > i)) {

        j++;
        
        if (j > 2) {

            wprintf(TEXT("Invalid Choice - Exiting...\n"));
            goto cleanup;
        
        } else {
            
            wprintf(TEXT("Invalid choice - pick again\n"));
            goto get_interfaceid;
        }
    }

    // Get to the interface ID for the Interface selected.

    pIf = NULL;
    len = 0;

    if (i == interfaceid) {

        wprintf(TEXT("\nInterface selected for (un)installing Time Stamp - \nNdisWanIp\n\n\n"));
        WANlink = TRUE;
        pIf = NULL;

    } else {

        for (i = 1; i <= interfaceid ; i++) {

            pIf = (PTC_IFC_DESCRIPTOR)(Buffer + len);
            wprintf(TEXT("[%d]:%ws\n\t%ws\n"), i, pIf->pInterfaceName, pIf->pInterfaceID);

            if (i == interfaceid) {

                break;

            }

            // Move to next interface
            len += pIf->Length;

        }
        wprintf(TEXT("\nInterface selected for (un)installing Time Stamp - \n%ws\n\n\n"), pIf->pInterfaceName);

    }


    //
    // Branch here for Uninstall/Install.
    //
    if (InstallFlag == FALSE) {
        
        if (!DeleteTimeStamp(pIf)) {
            
            wprintf(TEXT("Delete TimeStamp Failed!\n"));

        }

        return;
    } 

    //
    // This is the regular install path.
    //

    j = 0;
get_servicetype:
    wprintf(TEXT("\nWould you like this service to be- [A]UTO, [M]ANUAL, [D]ISABLED:"));
    fflush(stdin);
    wscanf(TEXT("%[a-z]"), &servicetype);

    switch (towupper(servicetype)) {
    
    case TEXT('A'):
        
        wprintf(TEXT("\nYou have chosen AUTO start up option\n"));
        starttype = SERVICE_AUTO_START;

        break;

    case TEXT('D'):
        
        wprintf(TEXT("\nYou have chosen DISABLED start up option\n"));
        starttype = SERVICE_DISABLED;
        break;

    case TEXT('M'):
        
        wprintf(TEXT("\nYou have chosen MANUAL start up option"));
        starttype = SERVICE_DEMAND_START;
        break;

    default:
        
        if (j > 2) {
            
            wprintf(TEXT("\nIncorrect choice. Exiting...\n"));
            goto cleanup;

        } else {

            j++;
            wprintf(TEXT("\nInvalid - Choose again.\n"));
            goto get_servicetype;

        }
        break;
        
    }

    wprintf(TEXT("\n\n\n"));
    //
    // We have enough info to muck with the registry now.
    //

    // 1.1 open psched regkey and add profile
    ret = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       REGKEY_PSCHED_PARAMS,
                       0,
                       KEY_ALL_ACCESS,
                       &hConfigKey);
    
    if (ret !=ERROR_SUCCESS){

        wprintf(TEXT("Cant OPEN key\n"));
        goto cleanup;

    }

    ret = RegSetValueEx(
                        hConfigKey,
                        TEXT("Profiles"),
                        0,
                        REG_MULTI_SZ,
                        (LPBYTE)Profiles,
                        sizeof(Profiles)
                        );

    if (ret !=ERROR_SUCCESS){

        wprintf(TEXT("Cant SET Value:Profiles\n"));
        RegCloseKey(hConfigKey);
        goto cleanup;


    }

    ret = RegSetValueEx(
                    hConfigKey,
                    TEXT("LANTEST"),
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)Lantest,
                    sizeof(Lantest)
                    );

    if (ret !=ERROR_SUCCESS){

        wprintf(TEXT("Cant SET Value:LANTEST\n"));
        RegCloseKey(hConfigKey);
        goto cleanup;


    } 

    RegCloseKey(hConfigKey);

    // 1.2 Open the adapters section and add the profile
    if (!WANlink) {
        KeyBuffer = malloc(sizeof(TCHAR) * (wcslen(pIf->pInterfaceID) + wcslen(REGKEY_PSCHED_PARAMS_ADAPTERS)));
    
    } else {

        KeyBuffer = malloc(sizeof(TCHAR) * (wcslen(TEXT("NdisWanIp")) + wcslen(REGKEY_PSCHED_PARAMS_ADAPTERS)));

    }
    wcscpy(KeyBuffer, REGKEY_PSCHED_PARAMS_ADAPTERS);
    wcscat(KeyBuffer, TEXT("\\"));
    if (!WANlink) {
        wcscat(KeyBuffer, pIf->pInterfaceID);
    } else {
        wcscat(KeyBuffer, TEXT("NdisWanIp"));
    }

    ret = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       KeyBuffer,
                       0,
                       KEY_ALL_ACCESS,
                       &hConfigKey);

    if (ret != ERROR_SUCCESS) {

        wprintf(TEXT("INSTALLER: Couldn't open Regkey for Adapter specific info\n"));
        free(KeyBuffer);
        RegCloseKey(hConfigKey);
        goto cleanup;


    }

    ret = RegSetValueEx(
                    hConfigKey,
                    TEXT("Profile"),
                    0,
                    REG_SZ,
                    (LPBYTE)Profiles,
                    sizeof(Profiles)
                    );

    if (ret !=ERROR_SUCCESS){

        wprintf(TEXT("Cant SET Value:LANTEST under PARAMETERS\\ADAPTERS\n"));
        free(KeyBuffer);
        RegCloseKey(hConfigKey);
        goto cleanup;


    } 

    free(KeyBuffer);
    RegCloseKey(hConfigKey);

    // 2. throw in time stamp into the registry

    ret = RegCreateKeyEx(
                         HKEY_LOCAL_MACHINE,                // handle of an open key
                         REGKEY_TIMESTMP,         // address of subkey name
                         0,           // reserved
                         TEXT(""),           // address of class string
                         REG_OPTION_NON_VOLATILE,          // special options flag
                         KEY_ALL_ACCESS,        // desired security access
                         NULL,                            // address of key security structure
                         &TimeStampKey,          // address of buffer for opened handle
                         &Disposition   // address of disposition value buffer
                         );
 
    if (ret != ERROR_SUCCESS) {
        wprintf(TEXT("Couldn't open Regkey to plumb time stamp module\n"));
        RegCloseKey(hConfigKey);
        goto cleanup;

    }

    if (Disposition == REG_OPENED_EXISTING_KEY) {
        wprintf(TEXT("Time Stamp module is already installed.\n\n\n\n"));
        RegCloseKey(hConfigKey);
        goto cleanup;

    }
    
    RegCloseKey(hConfigKey);    

    // 3. Create the service...

    schSCManager = OpenSCManager(
                                 NULL,            // machine (NULL == local)
                                 NULL,            // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS    // access required
                                 );
    
    if ( schSCManager ) {

        schService = CreateService(
                                   schSCManager,        // SCManager database
                                   TEXT("TimeStmp"),            // name of service
                                   TEXT("TimeStmp"),        // name to display
                                   SERVICE_ALL_ACCESS,        // desired access
                                   SERVICE_KERNEL_DRIVER,    // service type
                                   starttype,        // start type 
                                   SERVICE_ERROR_NORMAL,    // error control type
                                   TEXT("System32\\Drivers\\timestmp.sys"),            // service's binary
                                   NULL,            // no load ordering group
                                   NULL,            // no tag identifier
                                   NULL,            // BUGBUG: no depend upon PNP_TDI??
                                   NULL,            // LocalSystem account
                                   NULL);            // no password

        if (!schService) {

            // couldn't create it.
            wprintf(TEXT("Could NOT create Time Stamp service - %d"), GetLastError());
            goto cleanup;

        } else {

            wprintf(TEXT("\nThe service will start on reboot.\n"));
            Success = TRUE;

        }

        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
    
    } else {

        wprintf(TEXT("\nINSTALLER: Couldn't open Service Control Manager - Do you have access?\n"));

    }
    
    wprintf(TEXT("The Time Stamp module installation is complete.\n"));
    wprintf(TEXT("Please ensure that a copy of timestmp.sys exists in your\n"));
    wprintf(TEXT("\\system32\\drivers directory before you reboot.\n"));

cleanup:
    // cleanup before getting out
    free(Buffer);

cleanup_no_free:
    // deregister before bailing...

    err = TcDeregisterClient(hClient);

    if (NO_ERROR != err) {
        hClient = NULL;
        wsprintf(SzBuf, TEXT("Error DEregistering Client: %d - %d\n"), err, GetLastError());
        OutputDebugString(SzBuf);
        return;
    }

    if (Success) {
        ShutdownNT();
    }
}

//
// Delete the service and cleanup Psched regkeys
// 
BOOLEAN
DeleteTimeStamp(PTC_IFC_DESCRIPTOR pIf)
{

    SC_HANDLE       schService;
    SC_HANDLE       schSCManager;
    TCHAR           *KBuffer;
    DWORD           err;
    HKEY            hKey;

    //
    // 1. Delete Timestamp service.
    //
    schSCManager = OpenSCManager(
                                 NULL,            // machine (NULL == local)
                                 NULL,            // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS    // access required
                                 );
    
    if ( schSCManager ) {

        schService = OpenService(
                                 schSCManager,  // handle to service control manager 
                                 TEXT("TimeStmp"), // pointer to name of service to start
                                 SERVICE_ALL_ACCESS // type of access to service
                                 );

        if (!schService) {

            // couldn't open it.
            wprintf(TEXT("Could NOT open Time Stamp service - %d\n"), GetLastError());
            wprintf(TEXT("Deletion of Time Stamp Service was UNSUCCESSFUL\n"));
            //return FALSE;

        } else {

            if (!DeleteService(schService)) {

                wprintf(TEXT("\nThe deletion of Timestamp service has failed - error (%d).\n"), GetLastError());

            } else {

                wprintf(TEXT("\nThe service will NOT start on reboot.\n"));
            }

            

        }

        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);
    
    } else {

        wprintf(TEXT("\nINSTALLER: Couldn't open Service Control Manager - Do you have access?\n"));

    }

    //
    // 2. Clean up psched registry.
    //
    err = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       REGKEY_PSCHED_PARAMS,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey);
    
    if (err !=ERROR_SUCCESS){

        wprintf(TEXT("Cant OPEN key\n"));
        return FALSE;

    }

    err = RegDeleteValue(
                         hKey,
                         TEXT("Profiles")
                         );

    if (err !=ERROR_SUCCESS){

        wprintf(TEXT("Cant Delete Value:Profiles\n"));
        RegCloseKey(hKey);
        return FALSE;
    }

    err = RegDeleteValue(
                         hKey,
                         TEXT("LANTEST")
                         );

    if (err != ERROR_SUCCESS){

        wprintf(TEXT("Cant Delete Value:LANTEST\n"));
        RegCloseKey(hKey);
        return FALSE;
    } 

    RegCloseKey(hKey);

    // 2.2 Clean up the adapter specific registry
    if (!WANlink) {
        KBuffer = malloc(sizeof(TCHAR) * (wcslen(pIf->pInterfaceID) + wcslen(REGKEY_PSCHED_PARAMS_ADAPTERS)));
    
    } else {

        KBuffer = malloc(sizeof(TCHAR) * (wcslen(TEXT("NdisWanIp")) + wcslen(REGKEY_PSCHED_PARAMS_ADAPTERS)));

    }
    wcscpy(KBuffer, REGKEY_PSCHED_PARAMS_ADAPTERS);
    wcscat(KBuffer, TEXT("\\"));
    if (!WANlink) {
        wcscat(KBuffer, pIf->pInterfaceID);
    } else {
        wcscat(KBuffer, TEXT("NdisWanIp"));
    }

    err = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       KBuffer,
                       0,
                       KEY_ALL_ACCESS,
                       &hKey);

    if (err != ERROR_SUCCESS) {

        wprintf(TEXT("INSTALLER: Couldn't open Regkey for Adapter specific info\n"));
        wprintf(TEXT("INSTALLER: CLEAN UP is partial\n"));
        free(KBuffer);
        return FALSE;
    }

    err = RegDeleteValue(
                    hKey,
                    TEXT("Profile")
                    );

    if (err !=ERROR_SUCCESS){

        wprintf(TEXT("Cant Delete Value:LANTEST under PARAMETERS\\ADAPTERS\n"));
        wprintf(TEXT("INSTALLER: CLEAN UP is partial\n"));
        free(KBuffer);
        RegCloseKey(hKey);
        return FALSE;
    } 

    free(KBuffer);
    RegCloseKey(hKey);
    
    wprintf(TEXT("The Time Stamp service is successfully deleted\n"));
    wprintf(TEXT("You need to reboot for the changes to take effect\n"));
    return TRUE;

}

// Just delete the service (no psched stuff)
VOID RemoveTimeStampService(
                            )
{
    SC_HANDLE       schService;
    SC_HANDLE       schSCManager;
    TCHAR           *KBuffer;
    DWORD           err;
    HKEY            hKey;

    //
    // 1. Delete Timestamp service.
    //
    schSCManager = OpenSCManager(
                                 NULL,            // machine (NULL == local)
                                 NULL,            // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS    // access required
                                 );

    if ( schSCManager ) {

        schService = OpenService(
                                 schSCManager,  // handle to service control manager 
                                 TEXT("TimeStmp"), // pointer to name of service to start
                                 SERVICE_ALL_ACCESS // type of access to service
                                 );

        if (!schService) {

            // couldn't open it.
            wprintf(TEXT("Could NOT open Time Stamp service - %d\n"), GetLastError());
            wprintf(TEXT("Deletion of Time Stamp Service was UNSUCCESSFUL\n"));
            return;

        } else {

            if (!DeleteService(schService)) {

                wprintf(TEXT("\nThe deletion of Timestamp service has failed - error (%d).\n"), GetLastError());

            } else {

                wprintf(TEXT("\nThe service will NOT start on reboot.\n"));
            }

        
            
        }

        CloseServiceHandle(schService);
        CloseServiceHandle(schSCManager);

    } else {

        wprintf(TEXT("\nINSTALLER: Couldn't open Service Control Manager - Do you have access?\n"));

    }

    wprintf(TEXT("The Time Stamp service is successfully deleted\n"));
    wprintf(TEXT("You need to reboot for the changes to take effect\n"));
    return;
}

VOID ShutdownNT()
{


	HANDLE				hToken;		// handle to process token
	TOKEN_PRIVILEGES	tkp;		// ptr. to token structure
    TCHAR               SzBuf[MAX_PATH];  
	BOOL                fResult;					// system shutdown flag
    INT                 nRet = IDYES;
	
	// Get the curren process token handle
	// so we can get shutdown privilege.

    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
        wsprintf(SzBuf, TEXT("OpenProcessToken failed (%d)\n"), GetLastError());
        OutputDebugString(SzBuf);
        return;
    }									

	// Get the LUID for shutdown privilege

    LookupPrivilegeValue (NULL, SE_SHUTDOWN_NAME,
                          &tkp.Privileges[0].Luid);

    tkp.PrivilegeCount = 1;			// one privilege to set
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Get shutdown privileges for this process

    AdjustTokenPrivileges (hToken, 
                           FALSE, 
                           &tkp, 
                           0,
                           (PTOKEN_PRIVILEGES) NULL, 
                           0);

	// Cannot test the return value of AdjustTokenPrivileges

	if (GetLastError() != ERROR_SUCCESS) {
        wsprintf(SzBuf, TEXT("AdjustTokenPriviledges failed (%d)\n"), GetLastError());
        OutputDebugString(SzBuf);
        CloseHandle(hToken);
        return;
    }

    CloseHandle(hToken);

    /*if (!InitiateSystemShutdownEx(
                                  NULL,
                                  ,
                                  0xffffff00,
                                  FALSE,    //BOOL bForceAppsClosed,  
                                  TRUE,     //BOOL bRebootAfterShutdown,  
                                  0         //DWORD dwReason
                                  )) {*/

    //
    // OK, so how about a popup?
    //


    nRet = MessageBox (
                       NULL,//hwndParent, 
                       TEXT("A reboot is required for TimeStamp Driver to get loaded. Please ensure that your %windir%\\system32\\driver's directory has a copy of timestmp.sys. Reboot now?"), 
                       TEXT("TIMESTAMP Driver Install Program"),
                       MB_YESNO | MB_ICONEXCLAMATION
                       );

    if (nRet == IDYES) {

        if (!ExitWindowsEx(EWX_REBOOT, 10)) {
    
            wsprintf(SzBuf, TEXT("InitializeShutdownEx failed (%d)\n"), GetLastError());
            OutputDebugString(SzBuf);

        } else {

            return;

        }


    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\qos\tools\qtcp\qtcp.c ===
//
//  QTCP.C version 1.0.3
//
// This program tests the quality of a network connection in terms of 
// variation in latency (jitter). It is based on TTCP, a public domain 
// program, written for BSD. The version of TTCP upon which this was
// based has been contributed to by:
//
//      T.C. Slattery, USNA (18 Dec 84)
//      Mike Muuss and T. Slattery (16 Oct 85)
//      Silicon Graphics, Inc. (1989)
//
// QTCP is written by Yoram Bernet (yoramb@microsoft.com)
//      further development work by John Holmes (jsholmes@mit.edu)
// 
// QTCP user level code may be used to provide rough jitter measurements,
// which indicate both operating system and network jitter. However, QTCP
// is intended to be used in conjunction with kernel timestamping for precise
// jitter measurements. The kernel component timestmp.sys should be installed
// when running on Win2000 (beta-3 or later).
//
// timestmp.sys is written by Shreedhar Madhavapeddi (shreem@microsoft.com)
//
//
// Distribution Status -
//      Public Domain.  Distribution Unlimited.
//

// Version History -
//   0.8:
//		- adaptation of TTCP by Yoram Bernet -- core functionality
//   0.9: (6/15/99)
//		- first version by John Holmes -- bug fixes and new features
//      - fixed all compile warnings
//      - added -v option to set up RSVP connection without sending data
//      - added -y option to skip confirmation of continues
//      - fixed line length error in log files
//      - fixed service type string to display properly
//      - added best effort and no service service types (BE & NS)
//      - added version string print upon execution
//   0.9.1: (6/17/99)
//      - check for hardware clock reset using correlation coefficient
//      - fixed incorrect clock skew in .sta file
//      - fixed -v option to keep socket open until user carriage returns
//      - added local statistics to clock skew computation for better estimate
//      - added -k option to prevent using local statistics for clock skew
//      - fixed maximum latency computation
//   0.9.2: (6/23/99)
//  	- fixed peak rate in flowspec so no shaping happens in CL servicetype
//      - added -e option to force shaping
//      - fixed error in allocating size of log array with bufsize <= 1500 bytes
//      - fixed not exiting on receiver
//      - fixed access violation if no filename specified on receiver
//      - changed dummy log entries to be off by default
//      - added -F option to convert raw file to log file
//   0.9.3: (6/29/99)
//      - improved low transmission speed at high packet/second rates by changing
//        default # async buffers from 3 to 32
//      - fixed user mode timestamps to use NtQueryPerformanceCounter()
//      - added -u option to use usermode timestamps in log generation
//   0.9.4: (7/8/99)
//      - cleaned up source (chopped up main into a bunch of functions to improve readability)
//      - fixed default buffer size to be 1472 bytes, so whole packet is 1500 bytes.
//      - rewrote i/o code to use callbacks for asynch i/o in order to improve throughput
//      - doing the right thing if not getting kernel-mode timestamps
//      - added ability to run for a specified amount of time with -n##s paramater
//      - added dynamic resizing of log array on receiver to prevent access violations
//        with mismatched parameters
//      - fixed devious bug in the GrowLogArray routine
//      - fixed total time reported for long runs (use UINT64 instead of DWORD)
//      - fixed problem with -F option specified on empty but extant file
//      - added RSVPMonitor Thread to watch for RSVP-err messages on receiver and
//        early abort by sender
//      - removed -a option as it is now obsolete
//      - revised usage screen to make more clear what pertains to sender and what
//        pertains to receiver
//      - fixed crash if receiver terminates before transmitter finishes
//   0.9.5: (7/15/99)
//      - re-added error checking on WriteFileEx and ReadFileEx routines
//   0.9.6: (7/20/99)
//      - changed default filler data in buffer so that it is less compressible to 
//        better account for links that compress data before sending
//      - added -i option to use more compressible data
//   0.9.7: (7/24/99)
//      - put back a thread to watch for 'q' on receiver to quit properly before sender's done
//      - added control channel to better handle RSVP timeouts, early aborts, etc.
//      - if no calibrations are specified, we calibrate based on all buffers
//      - gracefully exit if LogRecord runs out of memory, saving all logs we've got so far
//      - changed default behavior so raw file is dumped with no normalization whatsoever.
//      - improved the way anomalous points are caught in clock-skew calc
//   0.9.8: (7/28/99)
//      - fixed field assignments & file opening problem on converting raw file to log.
//      - changed latency to be written to file to signed and fixed normalization routine for
//        cases when clocks are orders of magnitude different (underflow error)
//      - added absolute deviation as goodness of fit measure
//      - added routine to look for clock jumps and fix for them (with -k3 option)
//   0.9.9: (8/4/99)
//      - changed format of .sta file to include more useful information and test params
//      - changed Logging scheme so that we are limited by disk space instead of memory
//        (now using a memory mapped file for the log, so the theoretical limit has gone from
//        less than 2GB to 18EB, but we won't ever get that in practice on normal disks)
//      - added -ni option to run indefinitely
//      - added -R##B option to specify tokenrate in bytes
//      - made default not to show dropped packets at console (it only causes more drops)
//      - added -q## option to log only every nth packet
//   1.0.0: (8/6/99)
//      - fixed bug where if a new qtcp receiver is started immediately after a previous
//        instance, it will think "theend" packets are normal packets and AV
//      - added check for the piix4 timer chip and an appropriate warning
//      - using precise incorrect value in FixWackyTimestamps function
//      - added -A option (aggregate data processing of all .sta files in a directory)
//   1.0.1: (8/6/99)
//      - fixed incorrect calculation of send rate with dropped packets
//   1.0.2: (8/23/99)
//      - improved clock skip detection algorithm
//      - fixed a bug in control channel communication of TokenRate
//      - fixed problem with forceshape option when rate is specified in bytes
//   1.0.3: (8/26/99)
//      - fixed SENDERS NO_SENDERS bug
//      - added summary over time to aggregate stats option
//      - changed .sta file format to include number of drops
//      - fixed shaping in best effort servicetype

// ToDo:
//      - add histogram to output in .sta file and on console
//      - add ability to run w/o control channel connection
//      - mark control channel traffic as higher priority
//      - add more aggregate stats (time varying statistics) -- maybe fourier xform

#ifndef lint
static char RCSid[] = "qtcp.c $Revision: 1.0.3 $";
#endif

#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <io.h>
#include <signal.h>
#include <ctype.h>
#include <sys/types.h>
#include <winsock2.h>
#include <qossp.h>
#include <winbase.h>
#include <time.h>
#include <shlwapi.h>

#if defined(_AMD64_)
#include <math.h>
#endif

#include "ioctl.h"

#define CONTROL_PORT 7239

CHAR *VERSION_STRING = "1.0.3";
#define MAX_STRING 255

INT64 MAX_INT64=9223372036854775807;

HANDLE hRSVPMonitor;
DWORD idRSVPMonitor;

INT64 g_BadHalAdjustment = 46869688;  // this is the value on a piix4 chip
SYSTEM_INFO g_si;
char g_szErr[255];
CRITICAL_SECTION g_csLogRecord;
EXCEPTION_RECORD g_erec;

BOOL g_fOtherSideFinished = FALSE;
BOOL g_fReadyForXmit = FALSE;
SOCKET fd;
SOCKET g_sockControl = INVALID_SOCKET;
struct sockaddr_in sinhim;
struct sockaddr_in sinme;
short port = 5003;              // UDP port number
char *host;                     // ptr to name of host
char szHisAddr[MAX_STRING];
char szMyAddr[MAX_STRING];

int trans;                      // 0=receive, !0=transmit mode
int normalize = 0;              // dump raw file after normalizing

char *Name = NULL;              // Name of file for logs
HANDLE hRawFile = NULL;
HANDLE hLogFile = NULL;
HANDLE hStatFile = NULL;
HANDLE hDriver = NULL;	// handle to the timestmp.sys driver

WSADATA WsaData;
WSAEVENT QoSEvents;

SYSTEMTIME systimeStart;
INT64 timeStart;
INT64 time0;
INT64 time1;
INT64 timeElapsed;

CHAR* TheEnd = "TheEnd";
CHAR* ControlledLoad = "CL";
CHAR* Guaranteed = "GR";
CHAR* BestEffort = "BE";
CHAR* NoTraffic = "NT";

LPCTSTR DriverName = TEXT("\\\\.\\Timestmp");

BOOL fWackySender = FALSE;
BOOL fWackyReceiver = FALSE;

typedef struct {
    HANDLE hSocket;
    INT TokenRate;   
    INT MaxSDUSize;
    INT BucketSize;
    INT MinPolicedSize;
    SERVICETYPE dwServiceType;
    CHAR *szServiceType;
    INT buflen;          // length of buffer
    INT nbuf;            // number of buffers to send
    INT64 calibration;
    BOOLEAN UserStamps;  // By default, we use kernel mode timestamping, if available
    BOOLEAN SkipConfirm; // By default, we wait for user confirmation at certain times
    BOOLEAN RESVonly;    // By default, we send data after getting the resv
    int SkewFitMode;     // by default, 0 = no fit, 1 = chisq, 2 = chisq w/outlier removal
                         //   3 = abs dev
    BOOLEAN Wait;        // By default, we wait for a QoS reservation
    BOOLEAN Dummy;       // insert dummy rows in log by default
    BOOLEAN PrintDrops;  // report dropped packets on console
    BOOLEAN ForceShape;  // by default, we do not force shaping on CL flows
    BOOLEAN RateInBytes; // KB by default
    BOOLEAN AggregateStats; // by default, we do not do this
    BOOLEAN ConvertOnly; // by default, we act normally and do not go around converting files
    BOOLEAN NoSenderTimestamps;
    BOOLEAN NoReceiverTimestamps;
    BOOLEAN TimedRun;    // true if we're running for a specified amount of time
    BOOLEAN RunForever;  // run until the person pushes 'q'
    BOOLEAN nBufUnspecified; // true if the user has not specified the -n parameter
    BOOLEAN RandomFiller;// by default, we use random, incompressible filler data
    int LoggingPeriod;   // by default, 1 (log every packet)
} QTCPPARAMS, *PQTCPPARAMS;

QTCPPARAMS g_params;

typedef struct {
    BOOL Done;             // done if true
    int nWritesInProgress; // number of writes outstanding
    int nReadsInProgress;  // number of reads outstanding
    int nBuffersSent;      // number of buffers sent to the device
    int nBuffersReceived;  // number of buffers received from network
    int nBytesTransferred; // number of bytes written to device
} QTCPSTATE, *PQTCPSTATE;

QTCPSTATE g_state;

typedef struct {
    OVERLAPPED Overlapped;
    PVOID pBuffer;
    DWORD BytesWritten;
} IOREQ, *PIOREQ;

#define MAX_PENDING_IO_REQS 64  // number of simultaneous async calls.

// This format is used for the buffer
// transmitted on the wire.
typedef struct _BUFFER_FORMAT{
    INT64 TimeSentUser;
    INT64 TimeReceivedUser;
    INT64 TimeSent;
    INT64 TimeReceived;
    INT64 Latency;
    INT BufferSize;
    INT SequenceNumber;
} BUFFER_FORMAT, *PBUFFER_FORMAT;

// This format is used for the scheduling record
// written based on the received buffers.
typedef struct _LOG_RECORD{
    INT64 TimeSentUser;
    INT64 TimeReceivedUser;
    INT64 TimeSent;
    INT64 TimeReceived;
    INT64 Latency;
    INT BufferSize;
    INT SequenceNumber;
} LOG_RECORD, *PLOG_RECORD;

// The LOG structure is a data abstraction for a log of LOG_RECORDS that uses memory
// mapped files to have a theoretical storage limit of 18EB. It uses two buffers in memory
// along with a watcher thread so that there is no delay when switching from one bit to
// the next.
typedef struct {
    INT64 nBuffersLogged;
    PBYTE pbMapView;           // view of file in Get/SetLogElement functions
    INT64 qwMapViewOffset;     // offset of Get/Set view in file (rounded down to allocation)
    char *szStorageFile;       // the name of the mapped file on disk (so we can delete it)
    HANDLE hStorageFile;       // the memory mapped file on disk
    HANDLE hFileMapping;       // the file mapping object for our storage file
    INT64 qwFileSize;          // the size of the storage file in bytes
} LOG, *PLOG;
LOG g_log;

// The STATS structure keeps a record of overall statistics for the qtcp run
typedef struct {
    char szStaFile[MAX_PATH];
    char szSender[MAX_STRING];
    char szReceiver[MAX_STRING];
    int nBuffers;
    int nTokenRate;
    int nBytesPerBuffer;
    double sendrate;
    double recvrate;
    double median;
    double mean;
    double var;
    double kurt;
    double skew;
    double abdev;
    FILETIME time; 
    int nDrops;
} STATS, *PSTATS;

INT64 totalBuffers;
INT anomalies = 0;
INT SequenceNumber = 0;
INT LastSequenceNumber = -1;

#define bcopy(s, d, c)  memcpy((u_char *)(d), (u_char *)(s), (c))
#define bzero(d, l)     memset((d), '\0', (l))

#define SENDER      1
#define RECEIVER    0

#define SECONDS_BETWEEN_HELLOS 120
// control messages
#define MSGCH_DELIMITER '!'
#define MSGST_RSVPERR "RSVPERR"
#define MSGST_ABORT "ABORT"
#define MSGST_ERROR "ERROR"
#define MSGST_DONE "DONE"
#define MSGST_HELLO "HELLO"
#define MSGST_RATE "RATE"
#define MSGST_SIZE "SIZE"
#define MSGST_NUM "NUM"
#define MSGST_READY "READY"
#define MSGST_VER "VER"

// -------------------
// Function prototypes
// -------------------

VOID
SetDefaults();

VOID
Usage();

BOOLEAN
GoodParams();

VOID
SetupLogs();

VOID
SetupSockets();
	
SOCKET 
OpenQoSSocket();

INT
SetQoSSocket(
    SOCKET fd,
    BOOL Sending);

VOID
WaitForQoS(
    BOOL Sender,
    SOCKET fd);

ULONG
GetRsvpStatus(
    DWORD dwTimeout,
    SOCKET fd);

VOID
PrintRSVPStatus(
    ULONG code);

VOID
DoTransmit();

VOID WINAPI
TransmitCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped);

VOID WINAPI
DelimiterSendCompletion(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped);

VOID
FillBuffer(
    CHAR *Cp,
    INT   Cnt);

INT
TimeStamp(
    CHAR *Cp, 
    INT   Cnt);

VOID
DoReceive();

VOID WINAPI
RecvCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped);

VOID
LogRecord(CHAR * Buffer);

BOOL CreateLog(PLOG plog, INT64 c);
BOOL GetLogEntry(PLOG plog, PLOG_RECORD prec, INT64 i);
BOOL DestroyLog(PLOG plog);
BOOL SetLogEntry(PLOG plog, PLOG_RECORD prec, INT64 i);
BOOL AddLogEntry(PLOG plog, PLOG_RECORD prec);

UINT64
GetUserTime();

DWORD
MyCreateFile(
    IN PCHAR Name,
    IN PCHAR Extension,
    OUT HANDLE *File);
    
void AggregateStats();

int IndexOfStatRecWith(int rate, int size, INT64 time, PSTATS pStats, int cStats);

BOOL GetStatsFromFile(PSTATS pstats);

VOID
DoStatsFromFile();
    
DWORD
OpenRawFile(
	IN PCHAR Name,
	OUT HANDLE *File);

INT64 ReadSchedulingRecords(HANDLE file);
	
VOID
DoStats();
	
VOID
WriteSchedulingRecords(
    HANDLE File,
    BOOLEAN InsertDummyRows);

void AdvancedStats();

VOID
GenericStats();

VOID
CheckForLostPackets();

VOID
WriteStats(
    UCHAR * HoldingBuffer,
    INT Count);

VOID
NormalizeTimeStamps();

VOID
ClockSkew(
    DOUBLE * Slope,
    DOUBLE * Offset);

BOOLEAN
AnomalousPoint(
    DOUBLE x,
    DOUBLE y);

VOID
AdjustForClockSkew(
    DOUBLE Slope,
    DOUBLE Offset);
    
BOOL FixWackyTimestamps();

// monitor threads
DWORD WINAPI RSVPMonitor (LPVOID lpvThreadParm);    
DWORD WINAPI KeyboardMonitor (LPVOID lpvThreadParm);
DWORD WINAPI ControlSocketMonitor(LPVOID lpvThreadParm);
DWORD WINAPI LogWatcher(LPVOID lpvThreadParm);

// utilities
int SendControlMessage(SOCKET sock, char * szMsg);
void ErrorExit(char *msg, DWORD dwErrorNumber);
UINT64 GetBadHalAdjustment();
//int compare( const void *arg1, const void *arg2 );
int __cdecl compare(const void *elem1, const void *elem2 ) ;
void medfit(double x[], double y[], int N, double *a, double *b, double *abdev);
double mode(const double data[], const int N);
void RemoveDuplicates(int rg[], int * pN);
void RemoveDuplicatesI64(INT64 rg[], int * pN);
#define RoundUp(val, unit) (val + (val % unit))
#define InRange(val, low, high) ((val >= low) && (val < high)) ? TRUE:FALSE
void PrintFlowspec(LPFLOWSPEC lpfs);

VOID __cdecl
main(INT argc,CHAR **argv)
{
    int 		error;
    char 		*stopstring;
    char 		szBuf[MAX_STRING];
	BOOL        b;
	ULONG		bytesreturned;
	
    printf("qtcp version %s\n\n",VERSION_STRING);

    if (GetBadHalAdjustment() == (UINT64)g_BadHalAdjustment) {
        printf("WARNING: This machine has a timer whose frequency matches that of the piix4\n");
        printf("         chip. There is a known bug in the HAL for this timer that causes the\n");
        printf("         timer to jump forward about 4.7 seconds every once in a while.\n");
        printf("         If you notice large jumps in the timestamps from this machine, try\n");
        printf("         running with the -k3 option to attempt to correct for the timer bug.\n\n");
    }    
    
    srand( (unsigned)time( NULL ) ); // seed the random number generator
    timeStart = GetUserTime();
    GetSystemInfo(&g_si);
    error = WSAStartup( 0x0101, &WsaData );
    if (error == SOCKET_ERROR) {
        printf("qtcp: WSAStartup failed %ld:", WSAGetLastError());
    }

    if (argc < 2) Usage();

    Name = malloc(MAX_STRING);
    bzero(Name,MAX_STRING);

    SetDefaults();

    argv++; argc--;
    while( argc>0 && argv[0][0] == '-' )  {
        switch (argv[0][1]) {
            case 'B':
                g_params.BucketSize = atoi(&argv[0][2]);
                break;
            case 'm':
                g_params.MinPolicedSize = atoi(&argv[0][2]);
                break;
            case 'M':
                g_params.MaxSDUSize = atoi(&argv[0][2]);
                break;
            case 'R':
                g_params.TokenRate = (int)strtod(&argv[0][2],&stopstring);
                if (*stopstring == 0) { // normal run
                    g_params.RateInBytes = FALSE;
                    break;
                }
                if (*stopstring == 'B') { // rate is in bytes / sec, not kbytes/sec
                    g_params.RateInBytes = TRUE;
                    break;
                }
                else {
                    Usage();
                    break;
                }
            case 'S':
                g_params.szServiceType = &argv[0][2];
                if(!strncmp(g_params.szServiceType, ControlledLoad, 2)){
                    g_params.dwServiceType = SERVICETYPE_CONTROLLEDLOAD;
                break;
                }
                if(!strncmp(g_params.szServiceType, Guaranteed, 2)){
                    g_params.dwServiceType = SERVICETYPE_GUARANTEED;
                break;
                }
				if(!strncmp(g_params.szServiceType, BestEffort, 2)){
				    g_params.dwServiceType = SERVICETYPE_BESTEFFORT;
					g_params.Wait = FALSE;
					break;
			    }
				if(!strncmp(g_params.szServiceType, NoTraffic, 2)){
					g_params.dwServiceType = SERVICETYPE_NOTRAFFIC;
					g_params.Wait = FALSE;
					break;
				}
                fprintf(stderr, "Invalid service type (not CL or GR).\n");
                fprintf(stderr, "Using GUARANTEED service.\n");
                break;
            case 'e':
                g_params.ForceShape = TRUE;
              	break;
            case 'W':
                g_params.Wait = FALSE;
                break;
            case 't':
                trans = 1;
                break;
            case 'f':
                strcpy(Name,&argv[0][2]);
                break;
            case 'F':
                strcpy(Name,&argv[0][2]);
                g_params.ConvertOnly = TRUE;
              	break;
            case 'A':
                strcpy(Name,&argv[0][2]);
                g_params.AggregateStats = TRUE;
                break;
            case 'r':
                trans = 0;
                break;
            case 'n':
                g_params.nbuf = (INT)strtod(&argv[0][2],&stopstring);
                if (*stopstring == 0) { // normal run
                    g_params.nBufUnspecified = FALSE;
                    break;
                }
                if (*stopstring == 'i') { // run for an infinite time
                    g_params.RunForever = TRUE;
                    break;
                }
                if (*stopstring == 's') { // run for a specified time
                    g_params.TimedRun = TRUE;
                    printf("Running for %d seconds\n",g_params.nbuf);
                    break;
                }
                else {
                    Usage();
                    break;
                }
            case 'c':
                g_params.calibration = atoi(&argv[0][2]);
                break;
		    case 'k':
		        g_params.SkewFitMode = atoi(&argv[0][2]);
		        if (g_params.SkewFitMode < 0 || g_params.SkewFitMode > 3)
		            ErrorExit("Invalid Skew Fit Mode",g_params.SkewFitMode);
		        break;
            case 'l':
                g_params.buflen = atoi(&argv[0][2]);
                break;
            case 'p':

                port = (short)atoi(&argv[0][2]);


                break;
            case 'd':
                g_params.Dummy = TRUE;
                break;
            case 'N':
                normalize = 1;
                break;
            case 'P':
                g_params.PrintDrops = TRUE;
                break;
			case 'v':
			    g_params.RESVonly = TRUE;
				break;
			case 'y':
				g_params.SkipConfirm = TRUE;
				break;
			case 'u':
			    g_params.UserStamps = TRUE;
			    break;
			case 'i':
			    g_params.RandomFiller = FALSE;
			    break;
			case 'q':
                g_params.LoggingPeriod = atoi(&argv[0][2]);
			    break;
            default:
                Usage();
        }
        argv++; 
        argc--;
    }

	//
	// Make an ioctl to Timestmp driver, if its exists about the 
	// port to timestamp on.
	//
	printf("Trying to open %s\n", DriverName);
				
    hDriver = CreateFile(DriverName,
                         GENERIC_READ | GENERIC_WRITE, 
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0,                     // Default security
                         OPEN_EXISTING,
                         0,  
                         0);                    // No template
   	if(hDriver == INVALID_HANDLE_VALUE) {
	            
		printf("Timestmp.sys CreateFile- Error %ld - Maybe its not INSTALLED\n", GetLastError());
		// Otherwise, print success and close the driver
		
	} else {

       	printf("Timestmp.sys - CreateFile Success.\n");

		b = DeviceIoControl(
					  		hDriver,              			// handle to a device, file, or directory 
							IOCTL_TIMESTMP_REGISTER_PORT,   // control code of operation to perform
							&port,                          // pointer to buffer to supply input data
							2, //nInBufferSize,         	// size, in bytes, of input buffer
							NULL, //lpOutBuffer,            // pointer to buffer to receive output data
							0, //nOutBufferSize,        	// size, in bytes, of output buffer
							&bytesreturned, 				// pointer to variable to receive byte count
                            NULL                            // pointer to overlapped structure
							);

		printf("IOCTL performed\n");
		
		if (!b) {

			printf("IOCTL FAILED!\n", GetLastError());
          	// Close the driver
           	CloseHandle(hDriver);
    	            	
		} else {
			printf("IOCTL succeeded!\n");
		}
   	}
	
    // get the host address if we're the sender
    if(trans)  {
        if(argc != 1)
            Usage();
        host = malloc(strlen(argv[0]) + 1);
        strcpy(host,argv[0]);
    }
        
	// first, we see if this is a conversion -- if it is, just jump right in, else go on
	if (g_params.ConvertOnly) {
		DoStatsFromFile();
		exit(0);
	}

    // see if we're supposed to do stat aggregation
    if (g_params.AggregateStats) {
        AggregateStats();
        exit(0);
    }
    
    // Do argument sanity tests & set default values if not already set
    if (!GoodParams()) exit(1); 

    // Spawn off the control socket monitor thread
    CreateThread(NULL, 0, ControlSocketMonitor, (LPVOID)host, 0, NULL);

    // Get the sockets ready, set for QoS, and wait for a connection
    SetupSockets();

    // Check for a RESV only session
	if (g_params.RESVonly) {  // keep socket open and hang out
		fprintf(stdout, "RSVP connection established. Press return to quit.\n");
		while(TRUE){
			if(getchar())
				break;
		}
		exit(0);
	}

    // start up the RSVPMonitor and keyboard monitor threads to watch for wackiness
    hRSVPMonitor = CreateThread(NULL,0,RSVPMonitor,NULL,0,&idRSVPMonitor);
    CreateThread(NULL,0,KeyboardMonitor,NULL,0,NULL);

    // wait for the control channel to be set up, if it's not already
    while (g_sockControl == INVALID_SOCKET) Sleep(50);

    if (!trans) { // we want to make sure these are not initialized, so we don't put wrong values in .sta
        g_params.buflen = 0;
        g_params.nbuf = 2048; // it's ok to init this because it's not saved in .sta
        g_params.TokenRate = 0;
    }
    
    totalBuffers = g_params.nbuf + g_params.calibration;
    // Tell the receiver the important parameters
    if (trans) {
        if (g_params.RunForever) totalBuffers = 2048;
        sprintf(szBuf, "%s %d", MSGST_NUM, totalBuffers);
        SendControlMessage(g_sockControl, szBuf);
        sprintf(szBuf, "%s %d", MSGST_SIZE, g_params.buflen);
        SendControlMessage(g_sockControl, szBuf);
        if (g_params.RateInBytes) sprintf(szBuf, "%s %d", MSGST_RATE, g_params.TokenRate);
        else sprintf(szBuf, "%s %d", MSGST_RATE, 1000 * g_params.TokenRate);
        SendControlMessage(g_sockControl, szBuf);
    }

    while (!g_fReadyForXmit) Sleep(50);
    
    // If we're the receiver, set up the log buffer and files
    if((Name != NULL) && !trans){
        SetupLogs();
    }

    // Let the user know what's up
    if(trans){
        fprintf(stdout, "qtcp TRANSMITTER\n");
        if (g_params.calibration)
            fprintf(stdout, "\tSending %d calibration buffers.\n", g_params.calibration);
        fprintf(stdout, "\tSending %d buffers of length %d.\n", g_params.nbuf, g_params.buflen);
        fprintf(stdout, "\tDestination address (port) is %s (%d).\n", argv[0], port);
        if (g_params.RateInBytes)
            fprintf(stdout, "\tToken rate is %d bytes/sec.\n", g_params.TokenRate);
        else
            fprintf(stdout, "\tToken rate is %d Kbytes/sec.\n", g_params.TokenRate);
        fprintf(stdout, "\tBucket size is %d bytes.\n", g_params.BucketSize);
    }
    else{
        fprintf(stdout, "qtcp RECEIVER\n");
        if (g_params.calibration)
            fprintf(stdout, "\tPrepared to receive %d calibration buffers.\n", g_params.calibration);
        if (!g_params.nBufUnspecified) {
            fprintf(stdout, "\tPrepared to receive %d buffers.\n", g_params.nbuf); 
        }
    }
    
    // Do the actual communication
    time0 = GetUserTime();
    
    if (trans)
        DoTransmit();
    else
        DoReceive();
        
    time1 = GetUserTime();
    timeElapsed = (time1 - time0)/10000;

    // tell the other guy we're done
    SendControlMessage(g_sockControl, MSGST_DONE);
    
    // get to a new line
    printf("\n");

    // put some stats on the transmitter console
    if (trans) {
        printf("Sent %ld bytes in %I64d milliseconds = %I64d KBps\n", 
            g_state.nBytesTransferred, timeElapsed, g_state.nBytesTransferred/timeElapsed);
    }

    // wait for the other side to tell us it's done.
    while (!g_fOtherSideFinished) Sleep(50);
    
    // let the user know if timestmp.sys was installed
    if (g_params.NoSenderTimestamps && g_params.NoReceiverTimestamps)
        printf("WARNING: No kernel-level timestamps detected on sender or receiver\n\tUsing user-mode timestamps.\n");
    else if (g_params.NoSenderTimestamps)
        printf("WARNING: No kernel-level timestamps detected on sender\n\tUsing user-mode timestamps.\n");
    else if (g_params.NoReceiverTimestamps)
        printf("WARNING: No kernel-level timestamps detected on receiver\n         Using user-mode timestamps.\n");
    

    // Close down the sockets
    if (closesocket((SOCKET)g_params.hSocket) != 0)
        fprintf(stderr,"closesocket failed: %d\n",WSAGetLastError());

    if(timeElapsed <= 100){
        fprintf(stdout,
                "qtcp %s:Time interval too short for valid measurement!\n",
                trans?"-t":"-r");
    }

    // Close files & exit
    if(!trans && Name != NULL){
        if (g_log.nBuffersLogged) {
            DoStats();
        } else {
            printf("ERROR: no buffers logged due to errors.\n");
        }
        CloseHandle(hRawFile);
        CloseHandle(hLogFile);
        CloseHandle(hStatFile);
        DestroyLog(&g_log);
    }
    
    if (WSACleanup() != 0)
        fprintf(stderr,"WSACleanup failed: %d\n",WSAGetLastError());
        
    printf("\n");
    _exit(0);
}  // main()

VOID SetDefaults()
{
    g_params.hSocket = NULL;
    g_params.TokenRate = 100;
    g_params.MaxSDUSize = QOS_NOT_SPECIFIED;
    g_params.BucketSize = QOS_NOT_SPECIFIED;
    g_params.MinPolicedSize = QOS_NOT_SPECIFIED;
    g_params.dwServiceType = SERVICETYPE_GUARANTEED;
    g_params.szServiceType = "GR";
    g_params.buflen = 1472;              /* length of buffer */
    g_params.nbuf = 2 * 1024;            /* number of buffers to send */
    g_params.calibration = 0;
    g_params.UserStamps = FALSE;  // By default, we use kernel mode timestamping, if available
    g_params.SkipConfirm = FALSE; // By default, we wait for user confirmation at certain times
    g_params.SkewFitMode = 2;     // by default, we use absolute deviation
    g_params.Wait = TRUE;         // By default, we wait for a QoS reservation
    g_params.Dummy = FALSE;       // insert dummy rows in log by default
    g_params.PrintDrops = FALSE;   // report dropped packets on console
    g_params.ForceShape = FALSE;  // by default, we do not force shaping on CL flows
    g_params.RateInBytes = FALSE; // KB by default
    g_params.ConvertOnly = FALSE; // by default, we act normally and do not go around converting files
    g_params.AggregateStats = FALSE;
    g_params.NoSenderTimestamps = FALSE;
    g_params.NoReceiverTimestamps = FALSE;
    g_params.TimedRun = FALSE;    // by default, we run for a number of packets
    g_params.RunForever = FALSE;  // by default, we run fora  number of packets
    g_params.nBufUnspecified = TRUE;
    g_params.RandomFiller = TRUE; // by default, we use random filler to prevent compression
    g_params.LoggingPeriod = 1;
} // SetDefaults()

VOID Usage()
{
    fprintf(stderr,"Usage: qtcp [-options] -t host\n");
    fprintf(stderr,"       qtcp [-options] -r\n");
    fprintf(stderr," -t options:\n");
    fprintf(stderr,"        -B##    TokenBucket size signaled to network and to traffic control\n"); 
    fprintf(stderr,"                (default is equal to buffer size)\n");
    fprintf(stderr,"        -m##    MinPolicedSize signaled to network and to traffic control\n");
    fprintf(stderr,"                (default is equal to buffer size)\n");
    fprintf(stderr,"        -R##    TokenRate in kilobytes per second (default is 100 KBPS)\n");
    fprintf(stderr,"        -R##B   TokenRate in bytes per second\n");
    fprintf(stderr,"        -e      Force shaping to TokenRate.\n");
    fprintf(stderr,"        -M      MaxSDUSize to be used in signaling messages (default is buffer\n");
    fprintf(stderr,"                size\n");
    fprintf(stderr,"        -l##    length of buffers to transmit (default is 1472 bytes)\n");
    fprintf(stderr,"        -n##    number of source bufs written to network (default is 2048 bytes)\n");
    fprintf(stderr,"        -n##s   numbef of seconds to send buffers for (numbef of buffers will\n");
    fprintf(stderr,"                be calculated based on other parameters\n");
    fprintf(stderr,"        -ni     run indefinitely (will stop when 'q' is pressed on either)\n");
    fprintf(stderr,"        -c##    Specifies number of calibration packets to be sent\n");
    fprintf(stderr,"                Calibration packets will be sent immediately\n"); 
    fprintf(stderr,"                After calibration packets are sent, n additional\n");
    fprintf(stderr,"                packets will be sent. This option is useful if you want to\n");
    fprintf(stderr,"                change network conditions after a set calibration phase\n");
	fprintf(stderr,"        -y      skip confirmation message after calibration phase\n");
    fprintf(stderr,"        -p##    port number to send to or listen at (default 5003)\n");
    fprintf(stderr,"        -i      use more compressible buffer data\n");
    fprintf(stderr," -r options:\n");
    fprintf(stderr,"        -f\"filename\"    Name prefix to be used in generating log file and\n");
    fprintf(stderr,"                statistics summary. (no file generated by default)\n");
    fprintf(stderr,"        -c##    Specifies number of buffers to use in clock-skew calibration\n");
	fprintf(stderr,"        -k0     do not calculate clock skew\n");
	fprintf(stderr,"        -k1     use chi squared as goodness of fit\n");
	fprintf(stderr,"        -k2     use absolute deviation as goodness of fit (default)\n");
	fprintf(stderr,"        -k3     use abs dev and check for clock jumps\n");
    fprintf(stderr,"        -d      suppress insertion of dummy log records for lost packets.\n");
    fprintf(stderr,"        -N      Normalize before dumping raw file (default is after)\n");
    fprintf(stderr,"        -P      enables console reporting of dropped packets\n");
    fprintf(stderr,"        -u      use user mode timestamps instead of kernel timestamps in logs\n");
    fprintf(stderr,"        -q##    log only every ##th packet\n");
    fprintf(stderr," common options:\n");
    fprintf(stderr,"        -S\"service type\" (CL or GR -- GR is default)\n");
    fprintf(stderr,"        -W      Suppress waiting for QoS reservation\n");
	fprintf(stderr,"        -v      Set up QoS reservation only, send no data\n");
    fprintf(stderr,"        -F\"filename\"  Name prefix of raw file to be converted to log file\n");
    fprintf(stderr,"        -A\"path\"      Path to directory for aggregate statistics computation\n");

    WSACleanup();
    exit(1);
} // Usage()

BOOLEAN GoodParams()
{          
    BOOLEAN ok = TRUE;
    
    if(g_params.buflen < sizeof(BUFFER_FORMAT)){
        printf("Buffer size too small for record!\n");
        ok = FALSE;
    }

    // Unless otherwise specified, min policed size will be equal to 
    // buflen.
    
    if(g_params.MinPolicedSize == QOS_NOT_SPECIFIED){
        g_params.MinPolicedSize = g_params.buflen;
    }
    
    // Same goes for bucket size
    
    if(g_params.BucketSize == QOS_NOT_SPECIFIED){
        g_params.BucketSize = g_params.buflen;
    }

    // And for MaxSDU
    
    if(g_params.MaxSDUSize == QOS_NOT_SPECIFIED){
        g_params.MaxSDUSize = g_params.buflen;
    }

    // If the bucket size is smaller than the buffer size,
    // and this is a sender, then warn the user because 
    // data will be discarded
    
    if((g_params.BucketSize < g_params.buflen) && trans){
        printf("Token bucket size is smaller than buffer size!\n");
        ok = FALSE;
    }

    if(g_params.MaxSDUSize < g_params.buflen){
        printf("MaxSDU cannot be less than buffer size!\n");
        ok = FALSE;
    }

    if(g_params.buflen < 5){
        g_params.buflen = 5;   // send more than the sentinel size
    }

    if(g_params.TimedRun) {
        if (g_params.RateInBytes)
            g_params.nbuf = g_params.nbuf * g_params.TokenRate / g_params.buflen;
        else
            g_params.nbuf = g_params.nbuf * g_params.TokenRate * 1000 / g_params.buflen;
        printf("Using %d buffers\n",g_params.nbuf);
    }

    return ok;
} // GoodParams()

VOID SetupLogs()
{
    CreateLog(&g_log, totalBuffers);

    // set up logging files
    if(ERROR_SUCCESS != MyCreateFile(Name,".raw",&hRawFile)){
        fprintf(stderr, "WARNING: Could not create raw file.\n");
    } 
    
    if(ERROR_SUCCESS == MyCreateFile(Name,".log", &hLogFile)){
        fprintf(stdout,"Logging per-packet data to %s.log.\n",Name);
    }
    else{
        fprintf(stderr, "WARNING: Could not create log file.\n");
    }

    if(ERROR_SUCCESS == MyCreateFile(Name, ".sta", &hStatFile)){
        fprintf(stdout,"Writing statistics sumary to %s.sta\n",Name);
    }
    else{
        fprintf(stderr,"Could not create statistics file.\n");
    }
} // SetupLogs()

VOID SetupSockets() 
{
    struct hostent *addr;
    ULONG addr_tmp;
    char szAddr[MAX_STRING];
    int dwAddrSize, dwError;

        
    // Set address and port parameters 
    if(trans)  {
        bzero((char *)&sinhim, sizeof(sinhim));
        if (atoi(host) > 0 )  {
            sinhim.sin_family = AF_INET;
            sinhim.sin_addr.s_addr = inet_addr(host);
        } 
        else{
            if ((addr=gethostbyname(host)) == NULL){
                printf("ERROR: bad hostname\n");
                WSACleanup();
                exit(1);
            }
            sinhim.sin_family = addr->h_addrtype;
            bcopy(addr->h_addr,(char*)&addr_tmp, addr->h_length);
            sinhim.sin_addr.s_addr = addr_tmp;
        }

        sinhim.sin_port = htons(port);
        sinme.sin_port = 0;             /* free choice */
    } 
    else{
        sinme.sin_port =  htons(port);
    }

    sinme.sin_family = AF_INET;

    // Open socket for QoS traffic
    fd = OpenQoSSocket();

    if((fd == (UINT_PTR)NULL) || (fd == INVALID_SOCKET)){
        fprintf(stderr,"Failed to open QoS socket!\n");
        exit(1);
    }

    // Prepare to get QoS notifications

    if((QoSEvents = WSACreateEvent()) == WSA_INVALID_EVENT){
        fprintf(stderr,
                "Failed to create an event for QoS notifications %ld\n",
                WSAGetLastError());
        exit(1);
    }

    if(WSAEventSelect(fd, QoSEvents, FD_QOS) == SOCKET_ERROR){
        fprintf(stderr,
                "Unable to get notifications for QoS events. %ld\n",
                WSAGetLastError());
    }

    if(trans){
        // Set QoS on sending traffic
        if(SetQoSSocket(fd, TRUE)){
            exit(1);
        }

        fprintf(stdout, "Initiated QoS connection. Waiting for receiver.\n");

        WaitForQoS(SENDER, fd);
    }
    else{ // we're the receiver, so bind and wait
        if(bind(fd, (PSOCKADDR)&sinme, sizeof(sinme)) < 0){
            printf("bind() failed: %ld\n", GetLastError( ));
        }

        if(SetQoSSocket(fd, FALSE)){
            exit(1);
        }

        fprintf(stdout, "Waiting for QoS sender to initiate QoS connection.\n");

        WaitForQoS(RECEIVER, fd);
    }

    // set some options
    // none to set!

    g_params.hSocket = (HANDLE)fd;
} // SetupSockets()

SOCKET 
OpenQoSSocket(
    )
{
    INT bufferSize = 0;
    INT numProtocols;
    LPWSAPROTOCOL_INFO installedProtocols, qosProtocol; 
    INT i;
    SOCKET fd;
    BOOLEAN QoSInstalled = FALSE;

    // Call WSAEnumProtocols to determine buffer size required

    numProtocols = WSAEnumProtocols(NULL, NULL, &bufferSize);

    if((numProtocols != SOCKET_ERROR) && (WSAGetLastError() != WSAENOBUFS)){
        printf("Failed to enumerate protocols!\n");
        return((UINT_PTR)NULL);
    }
    else{
        // Enumerate the protocols, find the QoS enabled one

        installedProtocols = (LPWSAPROTOCOL_INFO)malloc(bufferSize);

        numProtocols = WSAEnumProtocols(NULL,
                                        (LPVOID)installedProtocols,
                                        &bufferSize);

        if(numProtocols == SOCKET_ERROR){
            printf("Failed to enumerate protocols!\n");
            return((UINT_PTR)NULL);
        }
        else{
            qosProtocol = installedProtocols;

            for(i=0; i<numProtocols; i++){
                if((qosProtocol->dwServiceFlags1 & XP1_QOS_SUPPORTED)&&
                   (qosProtocol->dwServiceFlags1 & XP1_CONNECTIONLESS) &&
                   (qosProtocol->iAddressFamily == AF_INET)){
                        QoSInstalled = TRUE;
                        break;
                }
                qosProtocol++;
            }
        }

        // Now open the socket.

        if (!QoSInstalled) {
            fprintf(stderr,"ERROR: No QoS protocols installed on this machine\n");
            exit(1);
        }

        fd = WSASocket(0, 
                       SOCK_DGRAM, 
                       0, 
                       qosProtocol, 
                       0, 
                       WSA_FLAG_OVERLAPPED);

        free(installedProtocols);

        return(fd);
    }
}  // OpenQoSSocket()

INT
SetQoSSocket(
    SOCKET fd,
    BOOL Sending)
{
    QOS qos;
    INT status;
    LPFLOWSPEC flowSpec;
    INT dummy;

    INT receiverServiceType = Sending?
                              SERVICETYPE_NOTRAFFIC:
                              g_params.dwServiceType;

    qos.ProviderSpecific.len = 0;
    qos.ProviderSpecific.buf = 0;

    // receiving flowspec is either NO_TRAFFIC (on a sender) or all
    // defaults except for the service type (on a receiver)

    flowSpec = &qos.ReceivingFlowspec;

    flowSpec->TokenRate = QOS_NOT_SPECIFIED;
    flowSpec->TokenBucketSize = QOS_NOT_SPECIFIED;
    flowSpec->PeakBandwidth = QOS_NOT_SPECIFIED;
    flowSpec->Latency = QOS_NOT_SPECIFIED;
    flowSpec->DelayVariation = QOS_NOT_SPECIFIED;
    flowSpec->ServiceType = receiverServiceType;
    flowSpec->MaxSduSize = QOS_NOT_SPECIFIED;
    flowSpec->MinimumPolicedSize = QOS_NOT_SPECIFIED;

    // now do the sending flowspec

    flowSpec = &qos.SendingFlowspec;

    if(Sending){
        if (g_params.RateInBytes)
            flowSpec->TokenRate = g_params.TokenRate;
        else
            flowSpec->TokenRate = g_params.TokenRate * 1000;
        flowSpec->TokenBucketSize = g_params.BucketSize; 
        

        if (g_params.ForceShape) {
            if (g_params.RateInBytes)
                flowSpec->PeakBandwidth = g_params.TokenRate;
    	    else
    	        flowSpec->PeakBandwidth = g_params.TokenRate * 1000;
    	}
        else 
	        flowSpec->PeakBandwidth = QOS_NOT_SPECIFIED;
        flowSpec->Latency = QOS_NOT_SPECIFIED;
        flowSpec->DelayVariation = QOS_NOT_SPECIFIED;
        flowSpec->ServiceType = g_params.dwServiceType;
        
        if (g_params.ForceShape && flowSpec->ServiceType == SERVICETYPE_BESTEFFORT )
            flowSpec->ServiceType = SERVICETYPE_GUARANTEED | SERVICE_NO_QOS_SIGNALING;

        flowSpec->MaxSduSize = g_params.MaxSDUSize;
        flowSpec->MinimumPolicedSize = g_params.MinPolicedSize;

        printf("Sending Flowspec\n");
        PrintFlowspec(&qos.SendingFlowspec);
        
        status = WSAConnect(fd,
                            (PSOCKADDR)&sinhim,
                            sizeof(sinhim),
                            NULL,
                            NULL,
                            &qos,
                            NULL);
        if(status){
            printf("SetQoS failed on socket: %ld\n", WSAGetLastError());
        }
    }
    else{
        flowSpec->TokenRate = QOS_NOT_SPECIFIED;
        flowSpec->TokenBucketSize = QOS_NOT_SPECIFIED;
        flowSpec->PeakBandwidth = QOS_NOT_SPECIFIED;
        flowSpec->Latency = QOS_NOT_SPECIFIED;
        flowSpec->DelayVariation = QOS_NOT_SPECIFIED;
        flowSpec->ServiceType = SERVICETYPE_NOTRAFFIC;
        flowSpec->MaxSduSize = QOS_NOT_SPECIFIED;
        flowSpec->MinimumPolicedSize = QOS_NOT_SPECIFIED;

        status = WSAIoctl(fd,
                          SIO_SET_QOS,
                          &qos,
                          sizeof(QOS),
                          NULL,
                          0,
                          &dummy,
                          NULL,
                          NULL);
        if(status){
            printf("SetQoS failed on socket: %ld\n", WSAGetLastError());
        }
    }
    
    return(status);
} // SetQoSSocket()
   
VOID
WaitForQoS(
    BOOL Sender,
    SOCKET fd)
{
    ULONG status;

    if(!g_params.Wait){
        // For best effort, we don't do anything QoS... Return
        // right away. In this case, the sender should be started
        // after the reciever, since there is no synchronization
        // via rsvp and data could be missed.

        fprintf(stdout, "WARNING: Not waiting for QoS reservation.\n");
        return;
    }
        
    while(TRUE){
        // get the statuscode, waiting for as long as it takes
        status = GetRsvpStatus(WSA_INFINITE,fd);

        switch (status) {
            case WSA_QOS_RECEIVERS:      // at least one RESV has arrived 
                if (Sender)
                    fprintf(stdout, "QoS reservation installed for %s service.\n", g_params.szServiceType);
                break;
            case WSA_QOS_SENDERS:        // at least one PATH has arrived 
                if (!Sender)
                    fprintf(stdout, "QoS sender detected using %s service.\n", g_params.szServiceType);
                break;
            default:
                PrintRSVPStatus(status);
                break;
        }

        // if we received one of the coveted status codes, break out
        // altogether. otherwise wait and see if we get another batch
        // of indications.
        if( ((status == WSA_QOS_RECEIVERS) && Sender) ||
            ((status == WSA_QOS_SENDERS) && !Sender) ) {
            break;
        }
    }
} // WaitForQoS()

ULONG
GetRsvpStatus(
    DWORD dwTimeout,
    SOCKET fd)
{
    LPQOS   qos;
    UCHAR   qosBuffer[500];
    LPRSVP_STATUS_INFO rsvpStatus;
    INT bytesReturned;
    
    qos = (LPQOS)qosBuffer;
    qos->ProviderSpecific.len = sizeof(RSVP_STATUS_INFO);
    qos->ProviderSpecific.buf = (PUCHAR)(qos+1);
    
    // wait for notification that a QoS event has occured
    WSAWaitForMultipleEvents(1,
                            &QoSEvents,
                            FALSE,
                            dwTimeout,
                            TRUE);

    // loop through all qos events
    WSAIoctl(fd,
             SIO_GET_QOS,
             NULL,
             0,
             qosBuffer,
             sizeof(qosBuffer),
             &bytesReturned,
             NULL,
             NULL);

    rsvpStatus = (LPRSVP_STATUS_INFO)qos->ProviderSpecific.buf;
    
    return rsvpStatus->StatusCode;
} // GetRsvpStatus

VOID
PrintRSVPStatus(ULONG code) 
{    
    switch (code) {
        case WSA_QOS_RECEIVERS:             // at least one RESV has arrived 
            printf("WSA_QOS_RECEIVERS\n");
            break;
        case WSA_QOS_SENDERS:               // at least one PATH has arrived 
            printf("WSA_QOS_SENDERS\n");
            break;
        case WSA_QOS_REQUEST_CONFIRMED:     // Reserve has been confirmed
            printf("WSA_QOS_REQUEST_CONFIRMED\n"); 
            break;
        case WSA_QOS_ADMISSION_FAILURE:     // error due to lack of resources
            printf("WSA_QOS_ADMISSION_FAILURE\n"); 
            break;
        case WSA_QOS_POLICY_FAILURE:        // rejected for admin reasons
            printf("WSA_QOS_POLICY_FAILURE\n"); 
            break;
        case WSA_QOS_BAD_STYLE:             // unknown or conflicting style
            printf("WSA_QOS_BAD_STYLE\n"); 
            break;
        case WSA_QOS_BAD_OBJECT:            // problem with some part of the 
                                            // filterspec/providerspecific 
                                            // buffer in general 
            printf("WSA_QOS_BAD_OBJECT\n"); 
            break;
        case WSA_QOS_TRAFFIC_CTRL_ERROR:    // problem with some part of the 
                                            // flowspec
            printf("WSA_QOS_TRAFFIC_CTRL_ERROR\n"); 
            break;
        case WSA_QOS_GENERIC_ERROR:         // general error 
            printf("WSA_QOS_GENERIC_ERROR\n");
            break;
        default:
            printf("Unknown RSVP StatusCode %lu\n", code); 
            break;
    }
} // PrintRSVPStatus


VOID
DoTransmit()
{
    IOREQ IOReq[MAX_PENDING_IO_REQS] = { 0 };
    INT i;
    BOOL ret;
    BOOL fOk;

    g_state.nBytesTransferred = 0;
    g_state.nBuffersSent = 0;
    g_state.nWritesInProgress = 0;

    // fill up the initial buffers and send them on their way    
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        IOReq[i].pBuffer = malloc(g_params.buflen);
        FillBuffer(IOReq[i].pBuffer,g_params.buflen);
        TimeStamp(IOReq[i].pBuffer,g_params.buflen);
        IOReq[i].Overlapped.Internal = 0;
        IOReq[i].Overlapped.InternalHigh = 0;
        IOReq[i].Overlapped.Offset = 0;
        IOReq[i].Overlapped.OffsetHigh = 0;
        IOReq[i].Overlapped.hEvent = NULL;

        if (g_state.nBuffersSent < totalBuffers) {
            WriteFileEx(g_params.hSocket,
                        IOReq[i].pBuffer,
                        g_params.buflen,
                        &IOReq[i].Overlapped,
                        TransmitCompletionRoutine);

            g_state.nWritesInProgress++;
            g_state.nBuffersSent++;
        }
    } 

    // now loop until an error happens or we're done writing to the socket
    while (g_state.nWritesInProgress > 0) {
        SleepEx(INFINITE, TRUE);
    }

    // send the end of transmission delimiters
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        strncpy(IOReq[i].pBuffer,TheEnd,strlen(TheEnd));
        fOk = WriteFileEx(g_params.hSocket,
                    IOReq[i].pBuffer,
                    strlen(TheEnd),
                    &IOReq[i].Overlapped,
                    DelimiterSendCompletion);
        g_state.nWritesInProgress++;

        if (!fOk) {
            printf("WriteFileEx() failed: %lu\n",GetLastError());
        }

    }

    // wait for all the delimiters to be sent
    while (g_state.nWritesInProgress > 0) {
        SleepEx(INFINITE, TRUE);
    }

    // free up the used memory
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        free(IOReq[i].pBuffer);
    }
} // DoTransmit()

VOID WINAPI
TransmitCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped)
{
    PIOREQ pIOReq = (PIOREQ) pOverlapped;
    BOOL fOk;
    
    if (dwErrorCode == ERROR_REQUEST_ABORTED) {
        g_state.Done = TRUE;
    }
    else if (dwErrorCode != NO_ERROR) {
        printf("ERROR: Write completed abnormally: %u\n",dwErrorCode);
    }

    g_state.nWritesInProgress--;
    g_state.nBytesTransferred += dwNumberOfBytesTransferred;

    // check to make sure we're not done
    if (g_state.Done)
        return;

    // give some indication of life
    if(!(g_state.nBuffersSent % 100)){
        fprintf(stdout, ".");
    }

    // if there are more buffers to go, send one
    if (g_state.nBuffersSent < totalBuffers || g_params.RunForever) {
    
        // see if this was the last of the calibration buffers (if we want confirmation)
        if (g_params.SkipConfirm == FALSE) {
            if (g_params.calibration && (g_state.nBuffersSent == g_params.calibration)) {
                printf("\nCalibration complete. Type 'c' to continue.\n");
                while(TRUE){
                    if(getchar() == 'c'){
                        break;
                    }
                }
            }
        }
    
        // fill in the buffer with new values
        FillBuffer(pIOReq->pBuffer,g_params.buflen);
        TimeStamp(pIOReq->pBuffer,g_params.buflen);

        // send a request to write the new buffer
        fOk = WriteFileEx(g_params.hSocket,
                    pIOReq->pBuffer,
                    g_params.buflen,
                    pOverlapped,
                    TransmitCompletionRoutine);

        if (!fOk) {
            printf("WriteFileEx() failed: %lu\n",GetLastError());
        }

        g_state.nWritesInProgress++;
        g_state.nBuffersSent++;
    }
} // TransmitCompletionRoutine()

VOID WINAPI
DelimiterSendCompletion(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped)
{
    g_state.nWritesInProgress--;
} // DelimiterSendCompletion()

VOID
FillBuffer(
    CHAR *Cp,
    INT   Cnt)
{
    PBUFFER_FORMAT buf = (PBUFFER_FORMAT) Cp;
    CHAR c = 0;
    
    // Fill with a background pattern
    if (g_params.RandomFiller) { // incompressible
        while(Cnt-- > 0) {
            c = rand() % 0x5F;
            c += 0x20;
            *Cp++ = c;
        }
    }
    else { // compressible
        while(Cnt-- > 0){
            while(!isprint((c&0x7F))) c++;
            *Cp++ = (c++&0x7F);
        }
    }

    buf->TimeSent = -1;
    buf->TimeReceived = -1;
} // FillBuffer()

INT
TimeStamp(
    CHAR *Cp, 
    INT   Cnt)
{
    PBUFFER_FORMAT record;
    LARGE_INTEGER timeSent;
    INT64 time;

    record = (BUFFER_FORMAT *)Cp;
        
    // Stamp with length and sequence number
    
    if(Cnt < sizeof(BUFFER_FORMAT)){
        printf("ERROR: Buffer length smaller than record size!\n");
        return(0);
    }
    else{
        time = GetUserTime();
        record->TimeSentUser = time;
        record->BufferSize = Cnt;
        record->SequenceNumber = SequenceNumber++;
    }
    return 1;
} // TimeStamp()

VOID
DoReceive()
{
    IOREQ IOReq[MAX_PENDING_IO_REQS] = { 0 };
    INT i;
    BOOL ret;
    
    // set the start state
    g_state.Done = FALSE;
    g_state.nBytesTransferred = 0;
    g_state.nBuffersReceived = 0;
    g_state.nReadsInProgress = 0;

    // fill up the initial buffers and send them on their way    
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        IOReq[i].pBuffer = malloc(g_params.buflen);
        
        IOReq[i].Overlapped.Internal = 0;
        IOReq[i].Overlapped.InternalHigh = 0;
        IOReq[i].Overlapped.Offset = 0;
        IOReq[i].Overlapped.OffsetHigh = 0;
        IOReq[i].Overlapped.hEvent = NULL;

        if (g_state.nBuffersReceived < totalBuffers) {
            ReadFileEx(g_params.hSocket,
                       IOReq[i].pBuffer,
                       g_params.buflen,
                       &IOReq[i].Overlapped,
                       RecvCompletionRoutine);

            g_state.nReadsInProgress++;
        }
    }

    InitializeCriticalSection(&g_csLogRecord);

    // now loop until an error happens or we're done writing to the socket
    while ((g_state.nReadsInProgress > 0) && !g_state.Done) {
        SleepEx(5000, TRUE);
        if (g_state.Done)
            break;
    }
    DeleteCriticalSection(&g_csLogRecord);

    // cancel the other pending reads
    CancelIo(g_params.hSocket);

    // free up the used memory
    for (i=0; i<MAX_PENDING_IO_REQS; i++) {
        free(IOReq[i].pBuffer);
    }
} // DoReceive()

VOID WINAPI
RecvCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransferred,
    LPOVERLAPPED pOverlapped)
{
    PIOREQ pIOReq = (PIOREQ) pOverlapped;
    BOOL fOk;
    static BOOL fLastWasError = FALSE;

    g_state.nReadsInProgress--;
    g_state.nBytesTransferred += dwNumberOfBytesTransferred;

    if (dwNumberOfBytesTransferred == 0) { // an error occurred
        if (!fLastWasError) {
            printf("ERROR in RecvCompletionRoutine: code=%d, lasterr=%d\n",
                dwErrorCode, GetLastError());
            printf("\tReceived no data. Telling sender to abort...\n");
            SendControlMessage(g_sockControl, MSGST_ERROR);
        }
        fLastWasError = TRUE;
    }
    else fLastWasError = FALSE;

    // if this is the first packet we've received, save the system time
    if (g_state.nBuffersReceived == 0) {
        GetSystemTime(&systimeStart);
    }

    // give some indication of life
    if(!(g_state.nBuffersReceived % 100)){
        fprintf(stdout, ".");
    }

    // end of transmission delimiter? if so, set the total buffers to the number got
    if(!(strncmp(pIOReq->pBuffer, TheEnd, 6))) {
        totalBuffers = g_state.nBuffersReceived;
        g_state.Done = TRUE;
    }

    // check to see if someone's set our done flag (if they have, leave)
    if (g_state.Done)
        return;

    // if not, then the buffer should hold a scheduling record.
    if(dwNumberOfBytesTransferred>0 && dwNumberOfBytesTransferred <= sizeof(BUFFER_FORMAT)) {
        printf("Buffer too small for scheduling record\n");
        printf("\tOnly %d bytes read.\n", dwNumberOfBytesTransferred);
    }

    // Log the record, but don't log more than one at a time (lock on this call)
    if (dwNumberOfBytesTransferred >= sizeof(BUFFER_FORMAT) && 
            g_state.nBuffersReceived % g_params.LoggingPeriod == 0) {
        EnterCriticalSection(&g_csLogRecord);
        LogRecord(pIOReq->pBuffer);
        LeaveCriticalSection(&g_csLogRecord);
    }

    // if there are more buffers (or if we don't know how many are coming), ask for one
    if ((g_state.nBuffersReceived < totalBuffers) || g_params.nBufUnspecified) {        
        // send a request to read the next buffer
        fOk = ReadFileEx(g_params.hSocket,
                   pIOReq->pBuffer,
                   g_params.buflen,
                   pOverlapped,
                   RecvCompletionRoutine);

        if (!fOk) {
            printf("ReadFileEx() failed: %lu\n",GetLastError());
        }
        
        g_state.nReadsInProgress++;
        g_state.nBuffersReceived++;
    }
} // RecvCompletionRoutine()

void LogRecord(char * Buffer)
{
    // This function copies the recieved record to the scheduling array.
    // The contents of the array are processed and written to file once
    // reception is complete.
 
    PBUFFER_FORMAT inRecord = (PBUFFER_FORMAT)Buffer;
    LOG_RECORD outRecord;
    INT64 time;
    SYSTEMTIME CurrentTime;

    time = GetUserTime();

	outRecord.TimeSentUser = inRecord->TimeSentUser;
	outRecord.TimeReceivedUser = time;
    outRecord.TimeSent = inRecord->TimeSent;
    outRecord.TimeReceived = inRecord->TimeReceived;
    outRecord.BufferSize = inRecord->BufferSize;
    outRecord.SequenceNumber = inRecord->SequenceNumber;

    if (inRecord->TimeSent == -1) {
        outRecord.TimeSent = outRecord.TimeSentUser;
        g_params.NoSenderTimestamps = TRUE;
    }

    if (inRecord->TimeReceived == -1) {
        outRecord.TimeReceived = outRecord.TimeReceivedUser;
        g_params.NoReceiverTimestamps = TRUE;
    }

    if(g_params.UserStamps){
        outRecord.TimeSent = outRecord.TimeSentUser;
        outRecord.TimeReceived = outRecord.TimeReceivedUser;
    }
    outRecord.Latency = outRecord.TimeReceived - outRecord.TimeSent;

    AddLogEntry(&g_log, &outRecord);

    if(g_params.PrintDrops){
        if(inRecord->SequenceNumber != LastSequenceNumber + g_params.LoggingPeriod){
            GetLocalTime(&CurrentTime);

            printf("\n%4d/%02d/%02d %02d:%02d:%02d:%04d: ",
                    CurrentTime.wYear,
                    CurrentTime.wMonth,
                    CurrentTime.wDay,
                    CurrentTime.wHour,
                    CurrentTime.wMinute,
                    CurrentTime.wSecond,
                    CurrentTime.wMilliseconds);

            printf("Dropped %d packets after packet %d.\n",
                    inRecord->SequenceNumber - LastSequenceNumber,
                    LastSequenceNumber);
        }

        LastSequenceNumber = inRecord->SequenceNumber;
    }
    return;
} // LogRecord()

BOOL CreateLog(PLOG plog, INT64 c) {
    // sets up a log structure that can hold c entries
    char szTempFile[MAX_PATH];
    char szTempPath[MAX_PATH];
    SYSTEM_INFO si;
    DWORD dwFileSizeHigh;
    DWORD dwFileSizeLow;
    INT64 qwFileSize;

    // get some system info
    GetSystemInfo(&si);
    
    // allocate logging array
    plog->nBuffersLogged = 0;
    plog->pbMapView = NULL;
    plog->qwMapViewOffset = -1;

    // set up the temporary storage file for logging
    GetTempPath(MAX_PATH, szTempPath);
    GetTempFileName(szTempPath, "qtc", 0, szTempFile);
    plog->szStorageFile = malloc(strlen(szTempFile) + 1);
    strcpy(plog->szStorageFile, szTempFile);
    plog->hStorageFile = CreateFile(szTempFile, GENERIC_READ | GENERIC_WRITE, 0, 
        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);
    if (plog->hStorageFile == INVALID_HANDLE_VALUE)
        ErrorExit("Could not create temp storage file",GetLastError());

    // create the memory mapping kernel object
    qwFileSize = c * sizeof(LOG_RECORD);
    dwFileSizeHigh = (DWORD) (qwFileSize >> 32);
    dwFileSizeLow = (DWORD) (qwFileSize & 0xFFFFFFFF);
    plog->qwFileSize = qwFileSize;
    plog->hFileMapping = CreateFileMapping(plog->hStorageFile, NULL, PAGE_READWRITE,
        dwFileSizeHigh,dwFileSizeLow,NULL);
    if (plog->hFileMapping == NULL)
        ErrorExit("Could not create mapping for temp storage file",GetLastError());
    
    return TRUE;
}

BOOL DestroyLog(PLOG plog) {
    DWORD dwError;
    // destroys the log and all associated data
    dwError = CloseHandle(plog->hFileMapping);
    if (!dwError) printf("Error in DestroyLog:CloseHandle(FileMapping) %d\n",GetLastError());
    dwError = CloseHandle(plog->hStorageFile);
    if (!dwError) printf("Error in DestroyLog:CloseHandle(StorageFile) %d\n",GetLastError());
    dwError = UnmapViewOfFile(plog->pbMapView);
    if (!dwError) printf("Error in DestroyLog:UnmapViewOfFile(plog->pbMapView) %d\n",GetLastError());
    dwError = DeleteFile(plog->szStorageFile);
    if (!dwError) printf("Error in DestroyLog:DeleteFile(StroageFile) %d\n",GetLastError());
    free(plog->szStorageFile);
    return FALSE;
}

void PrintLogRecord(PLOG_RECORD prec) {
    char szBuf[MAX_STRING];

    sprintf(szBuf,"%d: %I64u - %I64u (%I64d)",
        prec->SequenceNumber,prec->TimeSent,prec->TimeReceived,prec->Latency);
    puts(szBuf);
}

BOOL ExtendLog(PLOG plog) {
    // makes the log bigger by some fixed constant
    HANDLE hNewFileMapping;
    INT64 qwNewFileSize;
    
    UnmapViewOfFile(plog->pbMapView);

    qwNewFileSize = plog->qwFileSize + g_si.dwAllocationGranularity * sizeof(LOG_RECORD);
    hNewFileMapping = CreateFileMapping(plog->hStorageFile, NULL, PAGE_READWRITE,
                (DWORD)(qwNewFileSize >> 32), (DWORD)(qwNewFileSize & 0xFFFFFFFF), NULL);
    if (hNewFileMapping == NULL) {
        ErrorExit("Could not create mapping for temp storage file",GetLastError());
        return FALSE;
    }
    plog->qwFileSize = qwNewFileSize;
    CloseHandle(plog->hFileMapping);
    plog->hFileMapping = hNewFileMapping;
    plog->qwMapViewOffset = -1;
    return TRUE;
}

BOOL GetLogEntry(PLOG plog, PLOG_RECORD prec, INT64 i) {
    // fills prec with the (0 indexed) i'th log in plog
    // returns TRUE if it was successful, FALSE otherwise
    INT64 qwT;
    PLOG_RECORD entry;

    // first, check to see if this is within the range of our file
    if ((INT64)((i+1)*sizeof(LOG_RECORD)) > plog->qwFileSize) {
        // too high, so we return false
        return FALSE;
    }
    
    // we have to round down to the nearest allocation boundary
    qwT = sizeof(LOG_RECORD) * i;   // offset within file
    qwT /= g_si.dwAllocationGranularity; // in allocation granularity units

    // check to see if we do not already have this mapped in memory
    if (plog->qwMapViewOffset != qwT * g_si.dwAllocationGranularity) {
        if (plog->pbMapView != NULL) UnmapViewOfFile(plog->pbMapView);
        plog->qwMapViewOffset = qwT * g_si.dwAllocationGranularity;  // offset of lower allocation bound  
        if (plog->qwFileSize < (INT64)g_si.dwAllocationGranularity) {
            // file is smaller than allocation granularity
            plog->qwMapViewOffset = 0;
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE, 0, 0, 0);
        }
        else if (plog->qwFileSize - plog->qwMapViewOffset < g_si.dwAllocationGranularity) {
            // we're within an allocation granularity of the end of the file
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE,
                                (DWORD)(plog->qwMapViewOffset >> 32),
                                (DWORD)(plog->qwMapViewOffset & 0xFFFFFFFF), 
                                (DWORD)(plog->qwFileSize - plog->qwMapViewOffset));
        }
        else {
            // we're just somewhere in the file with space around us
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE, 
                                (DWORD)(plog->qwMapViewOffset >> 32),
                                (DWORD)(plog->qwMapViewOffset & 0xFFFFFFFF), 
                                RoundUp(g_si.dwAllocationGranularity,sizeof(LOG_RECORD)));
        }
        if (plog->pbMapView == NULL) 
            ErrorExit("GetLogEntry could not MapViewOfFile",GetLastError());
    }
    qwT = sizeof(LOG_RECORD) * i;
    entry = (PLOG_RECORD)(plog->pbMapView + (qwT - plog->qwMapViewOffset));
    CopyMemory(prec, entry, sizeof(LOG_RECORD));
    return TRUE;
}


BOOL SetLogEntry(PLOG plog, PLOG_RECORD prec, INT64 i) {
    // fills log entry i with the data pointed to by prec
    // returns TRUE if it was successful, FALSE otherwise
    INT64 qwT;
    PLOG_RECORD entry;

    // first, check to see if this is within the range of our file
    if ((INT64)((i+1)*sizeof(LOG_RECORD)) > plog->qwFileSize) {
        // we need to make our mapping bigger
        ExtendLog(plog);
    }
    
    // we have to round down to the nearest allocation boundary
    qwT = sizeof(LOG_RECORD) * i;   // offset within file
    qwT /= g_si.dwAllocationGranularity; // in allocation granularity units

    // check to see if we do not already have this mapped in memory
    if (plog->qwMapViewOffset != qwT * g_si.dwAllocationGranularity) {
        if (plog->pbMapView != NULL) UnmapViewOfFile(plog->pbMapView);
        plog->qwMapViewOffset = qwT * g_si.dwAllocationGranularity;  // offset of lower allocation bound  
        if (plog->qwFileSize < (INT64)g_si.dwAllocationGranularity) {
            // file is smaller than allocation granularity
            plog->qwMapViewOffset = 0;
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE, 0, 0, 0);
        }
        else if (plog->qwFileSize - plog->qwMapViewOffset < g_si.dwAllocationGranularity) {
            // we're within an allocation granularity of the end of the file
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE,
                                (DWORD)(plog->qwMapViewOffset >> 32),
                                (DWORD)(plog->qwMapViewOffset & 0xFFFFFFFF), 
                                (DWORD)(plog->qwFileSize - plog->qwMapViewOffset));
        }
        else {
            // we're just somewhere in the file with space around us
            plog->pbMapView = MapViewOfFile(plog->hFileMapping, FILE_MAP_WRITE, 
                                (DWORD)(plog->qwMapViewOffset >> 32),
                                (DWORD)(plog->qwMapViewOffset & 0xFFFFFFFF), 
                                RoundUp(g_si.dwAllocationGranularity,sizeof(LOG_RECORD)));
        }
        if (plog->pbMapView == NULL) 
            ErrorExit("SetLogEntry could not MapViewOfFile",GetLastError());
    }
    qwT = sizeof(LOG_RECORD) * i;
    entry = (PLOG_RECORD)(plog->pbMapView + (qwT - plog->qwMapViewOffset));

    CopyMemory(entry, prec, sizeof(LOG_RECORD));
    
    return TRUE;
}

BOOL AddLogEntry(PLOG plog, PLOG_RECORD prec) {
    PLOG_RECORD entry;
    // adds the data pointed to by prec to the end of the log
    // returns TRUE if it was successful, FALSE otherwise

    SetLogEntry(plog, prec, plog->nBuffersLogged);

    plog->nBuffersLogged++;

    return TRUE;
}

UINT64
GetUserTime()
{   // This function returns the performance counter time in units of 100ns
    LARGE_INTEGER count, freq;

    NtQueryPerformanceCounter(&count,&freq);
    
    // make sure we have hardware performance counting
    if(freq.QuadPart == 0) {
        NtQuerySystemTime(&count);
        return (UINT64)count.QuadPart;
    }
   
    return (UINT64)((10000000 * count.QuadPart) / freq.QuadPart);
} // GetUserTime()

UINT64
GetBadHalAdjustment() {
    // this function returns the amount the hal timer in a machine with 
    // an intel chipset with the piix4 timer chip will jump forward in the case of
    // repeated garbage returned fom the piix4 (bug #347410) so we can correct it out
    // in the FixWackyTimestamps routine
    LARGE_INTEGER freq;
    UINT64 diff;

    QueryPerformanceFrequency(&freq);
    // so we want to find how much it is increased in 100ns intervals if we increase
    // byte 3 by 1.
    diff   = 0x01000000;
    diff *= 10000000;
    diff  /= (UINT64)freq.QuadPart;
    return diff;
}

DWORD
MyCreateFile(
    IN PCHAR Name,
    IN PCHAR Extension,
    OUT HANDLE *File)
{
    HANDLE hFile;
    UCHAR * fileName;

    fileName = malloc(strlen(Name) + 5);
    bzero(fileName,strlen(Name) + 5);
    strncpy(fileName, Name, strlen(Name));
    if (strlen(Extension)==4) {
        strcat(fileName,Extension);
    }
    else
        return !ERROR_SUCCESS;

    hFile = CreateFile(fileName,
                       GENERIC_WRITE | GENERIC_READ,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    *File = hFile;

    return(INVALID_HANDLE_VALUE == hFile ? (!(ERROR_SUCCESS)) : ERROR_SUCCESS);
} // MyCreateFile()

void AggregateStats() {
    // this will go through the directory specified in Name and aggregate stats from
    // all the .sta files therein. it will then output the results of the aggregation
    // in a file within that directory called stats.qtc
    char szDirPath[3 * MAX_PATH];
    char szSearchString[3 * MAX_PATH];
    WIN32_FIND_DATA FileData;   // Data structure describes the file found
    HANDLE hSearch;             // Search handle returned by FindFirstFile
    PCHAR rgszStaFiles[1000];   // an array of the names of the .sta files
    int cStaFiles = 0, i,j,k,l; // keeps track of how many of the .sta files there are
    STATS * pStats;
    int rgSizes[1000], cSizes = 0;
    int rgRates[1000], cRates = 0;
    char szAggFile[3 * MAX_PATH];
    char szLineBuf[1000];
    STATS statsT;
    FILE *pfile;
    FILETIME rgtime[1000];
    SYSTEMTIME st;
    ULARGE_INTEGER uliT;
    int ctime = 0;
    int cSpecs = 0;

    PathCanonicalize(szDirPath,Name);
    if (szDirPath[strlen(szDirPath) - 1] == '"') szDirPath[strlen(szDirPath) - 1] = 0;
    if (!PathIsDirectory(szDirPath)) {
        printf("Path (%s) is not a directory\n",szDirPath);
        ErrorExit("Invalid Path for aggregate stats", -1);
    }

    // so now szDirPath is the path to the directory we want to go through
    // and we begin our search for .sta files
    sprintf(szSearchString,"%s\\*.sta",szDirPath);
    hSearch = FindFirstFile (szSearchString, &FileData);
    if (hSearch == INVALID_HANDLE_VALUE) {
        ErrorExit("No .sta files found.",GetLastError());
    }
    
    do {
        rgszStaFiles[cStaFiles] = malloc(sizeof(char) * 3 * MAX_PATH);
        // check to see if it's a good .sta file
        sprintf(statsT.szStaFile,"%s\\%s", szDirPath, FileData.cFileName);
        if (GetStatsFromFile(&statsT)) {
            // if it's good, include it
            strcpy(rgszStaFiles[cStaFiles], FileData.cFileName);
            cStaFiles++;
        }
    } while (FindNextFile(hSearch, &FileData));
    if (GetLastError() != ERROR_NO_MORE_FILES) {
        ErrorExit("Problem in FindNextFile()",GetLastError());
    }

    // open the stats file
    sprintf(szAggFile,"%s\\stats.qtc",szDirPath);
    pfile = fopen(szAggFile,"w+");
    if (pfile == NULL) printf("Could not open file for aggregate stats: %s\n",szAggFile);
    
    pStats = malloc(cStaFiles * sizeof(STATS));
    ZeroMemory(pStats, cStaFiles * sizeof(STATS));
    for (i=0; i<cStaFiles; i++) {
        sprintf(pStats[i].szStaFile, "%s\\%s", szDirPath, rgszStaFiles[i]);
        GetStatsFromFile(&(pStats[i]));
    }

    // at this point our pStats array is loaded up, so we can go to work
    for (i=0; i<cStaFiles; i++) {
        rgSizes[i] = pStats[i].nBytesPerBuffer;
        rgRates[i] = pStats[i].nTokenRate;
        rgtime[i] = pStats[i].time;
    }

    // now sort them and get out the dupliates
    cSizes = cRates = ctime = cStaFiles;
    RemoveDuplicates(rgSizes, &cSizes);
    RemoveDuplicates(rgRates, &cRates);
    RemoveDuplicatesI64((INT64 *)rgtime, &ctime);
    // --- do the stats by by time ---
    fprintf(pfile, "Latency Characteristics at varying times\n");
    fprintf(pfile, "                                 Latency Characteristics (microseconds)              Rates (Bps)           Buffers\n");
    fprintf(pfile, "       Time (UTC)            Median      StDev       Mean     Skew     Kurt       Send    Receive   Received    Dropped\n");
    for (i=0; i<cRates; i++) {
        for (j=0; j<cSizes; j++) {
            // print the flowspec
            if (IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles) != -1) {
                fprintf(pfile, "FLOWSPEC %d: %dB buffers at %d Bps\n",
                    cSpecs++, rgSizes[j], rgRates[i]);
                for (k=0; k<ctime; k++) {
                    // check to see if there is something with these params and print it
                    ZeroMemory(&uliT, sizeof(ULARGE_INTEGER));
                    CopyMemory(&uliT, &rgtime[k], sizeof(ULARGE_INTEGER));
                    l = IndexOfStatRecWith(rgRates[i],rgSizes[j],uliT.QuadPart,pStats,cStaFiles);
                    if (l > 0) {
                        FileTimeToSystemTime(&pStats[l].time, &st);
                        fprintf(pfile,"%02hu/%02hu/%04hu %2hu:%02hu.%02hu.%03hu: %10.1lf %10.1lf %10.1lf %8.2lf %8.2lf %10.1lf %10.1lf %10d %10d\n",
                            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, 
                            pStats[l].median, sqrt((double)pStats[l].var), pStats[l].mean, 
                            pStats[l].skew, pStats[l].kurt, pStats[l].sendrate, pStats[l].recvrate,
                            pStats[l].nBuffers, pStats[l].nDrops);
                    }
                }
                fprintf(pfile,"\n");
            }
        }
    }

    fprintf(pfile, "Latency Characteristics by flowspec\n");
    // --- do the stats by flowspec ---
    // now write the file, line by line, to szLineBuf, then to the file
    // median
    fprintf(pfile,"Median Latency (microseconds)\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.1lf ",pStats[k].median);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");
    // mean
    fprintf(pfile,"Mean Latency (microseconds)\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.2lf ",pStats[k].mean);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // variance
    fprintf(pfile,"Latency Standard Deviation\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.2lf ",sqrt((double)pStats[k].var));
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // skew
    fprintf(pfile,"Latency Skew\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.2lf ",pStats[k].skew);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // kurtosis
    fprintf(pfile,"Latency Kurtosis\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.2lf ",pStats[k].kurt);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // send rate
    fprintf(pfile,"Send Rate (Bps)\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.1lf ",pStats[k].sendrate);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // recv rate
    fprintf(pfile,"Receive Rate (Bps)\n");
    fprintf(pfile,"           ");
    for (i=0; i<cSizes; i++)
        fprintf(pfile,"%9dB ",rgSizes[i]);
    fprintf(pfile,"\n");
    for (i=0; i<cRates; i++) {
        fprintf(pfile,"%7dBps ",rgRates[i]);
        for (j=0; j<cSizes; j++) {
            k = IndexOfStatRecWith(rgRates[i],rgSizes[j],-1,pStats,cStaFiles);
            if (k != -1) {
                fprintf(pfile,"%10.1lf ",pStats[k].recvrate);
            }
            else {
                fprintf(pfile,"           ");
            }
        }
        fprintf(pfile,"\n");
    }
    fprintf(pfile,"\n");

    // show the file to the screen, just for kicks
    rewind(pfile);
    while (fgets(szLineBuf, 1000, pfile) != NULL)
        printf("%s", szLineBuf);
        
    // we're done, so we free up the memory we used    
    printf("Saved aggregate stats to %s\n",szAggFile);
    fclose(pfile);
    for (i=0; i<cStaFiles; i++) {
        free(rgszStaFiles[i]);
    }
    free(pStats);
}

int IndexOfStatRecWith(int rate, int size, INT64 time, PSTATS pStats, int cStats) {
    // returns an index into pStats that has the requested values for rate and size
    // if there are more than one, returns arbitrary match
    // returns -1 if no suitable entry is found.
    int i;
    ULARGE_INTEGER uliT;

    for (i=0; i<cStats; i++) {
        if (rate == -1 || pStats[i].nTokenRate == rate) {
            if (size == -1 || pStats[i].nBytesPerBuffer == size) {
                CopyMemory(&uliT, &(pStats[i].time), sizeof(ULARGE_INTEGER));
                if (time == -1 || uliT.QuadPart == (UINT64)time) {
                    return i;
                }
            }
        }
    }

    return -1;
}

BOOL GetStatsFromFile(PSTATS pstats) {
    // this function gets the overall statistics from the .sta file it's pointed to
    // it returns true if successful, false otherwise
    PCHAR szBuf = NULL;
    double T1,T2,T3;
    int nT1,nT2,nT3,nT4,nT5,nT6;
    HANDLE hFile;
    DWORD dwFileSize;
    DWORD dwRead;
    int nFields;
    SYSTEMTIME st;

    szBuf = malloc(sizeof(CHAR) * 1000);
    
    if (!szBuf) return FALSE;
        
    ZeroMemory(szBuf,1000);
    // open the file
    hFile = CreateFile(pstats->szStaFile,GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL);
    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == 0) return FALSE;
    
    // read the whole file into szBuf
    ReadFile(hFile, szBuf, dwFileSize, &dwRead, NULL);

    // close the file
    CloseHandle(hFile);

    // parse the buffer
    nFields = sscanf(szBuf,
                 "Sender: %s Receiver: %s\n" \
                 "First packet received: %hu:%hu.%hu.%hu %hu/%hu/%hu (UTC)\n" \
                 "Buffer size: %d\tTokenrate: %d\n" \
                 "Received %d packets.\n" \
                 "Logged %d records.\n" \
                 "Received %d bytes in %d milliseconds = %d KBps\n" \
                 "Clock skew is %lf microseconds per second.\n " \
                 "\tbased on %d calibration points\n" \
                 "Overall send rate: %lf Bytes/s\n" \
                 "Overall recv rate: %lf Bytes/s\n" \
                 "Latency Statistics (microsecond units): median: %lf\n" \
                 "\tMean: %lf\tStdev: %lf\tAbDev: %lf\n" \
                 "\tVariance: %lf\tSkew: %lf\t Kurtosis: %lf \n" \
                 "Dropped %d packets\n",
                 pstats->szSender, pstats->szReceiver,
                 &(st.wHour), &(st.wMinute), &(st.wSecond), &(st.wMilliseconds), 
                 &(st.wDay), &(st.wMonth), &(st.wYear),
                 &(pstats->nBytesPerBuffer), &(pstats->nTokenRate),
                 &(pstats->nBuffers), &nT2, &nT3, &nT4, &nT5, &T1, &nT6, &(pstats->sendrate), 
                 &(pstats->recvrate), &(pstats->median),
                 &(pstats->mean),&T2,&(pstats->abdev),
                 &(pstats->var),&(pstats->skew),&(pstats->kurt),
                 &(pstats->nDrops));

    if (nFields != 28 && nFields != 27) { // see if they ran without clock skew calc
        nFields = sscanf(szBuf,
                 "Sender: %s Receiver: %s\n" \
                 "First packet received: %hu:%hu.%hu.%hu %hu/%hu/%hu (UTC)\n" \
                 "Buffer size: %d\tTokenrate: %d\n" \
                 "Received %d packets.\n" \
                 "Logged %d records.\n" \
                 "Received %d bytes in %d milliseconds = %d KBps\n" \
                 "Overall send rate: %lf Bytes/s\n" \
                 "Overall recv rate: %lf Bytes/s\n" \
                 "Latency Statistics (microsecond units): median: %lf\n" \
                 "\tMean: %lf\tStdev: %lf\tAbDev: %lf\n" \
                 "\tVariance: %lf\tSkew: %lf\t Kurtosis: %lf \n" \
                 "Dropped %d packets\n",
                 pstats->szSender, pstats->szReceiver,
                 &(st.wHour), &(st.wMinute), &(st.wSecond), &(st.wMilliseconds), 
                 &(st.wDay), &(st.wMonth), &(st.wYear),
                 &(pstats->nBytesPerBuffer), &(pstats->nTokenRate),
                 &nT1, &nT2, &nT3, &nT4, &nT5, &(pstats->sendrate), 
                 &(pstats->recvrate), &(pstats->median),
                 &(pstats->mean),&T2,&(pstats->abdev),
                 &(pstats->var),&(pstats->skew),&(pstats->kurt),
                 &(pstats->nDrops));
    
        if (nFields != 26 && nFields != 25) return FALSE;
    }


    // assemble a FILETIME structure from the date & time
    if (!SystemTimeToFileTime(&st,&pstats->time)) {
        return FALSE;
    }

    free(szBuf);

    return TRUE;    
}

VOID
DoStatsFromFile()
{
    DOUBLE slope = 0;
	DOUBLE offset = 0;
	
    printf("Logging stats from file.\n");
	if (Name == NULL) {
		fprintf(stderr, "ERROR: you must specify a file to convert\n");
	}
	if(MyCreateFile(Name, ".log", &hLogFile) != ERROR_SUCCESS) {
		fprintf(stderr, "ERROR: could not create log file\n");
		exit(1);
	}
	if(OpenRawFile(Name, &hRawFile) != ERROR_SUCCESS) {
		fprintf(stderr, "ERROR: could not open raw file\n");
		exit(1);
	}

    ReadSchedulingRecords(hRawFile);
		
    if (g_params.calibration == 0)
        g_params.calibration = g_log.nBuffersLogged;
        
	NormalizeTimeStamps();

    // here we check for wacky timestamps on the sender and receiver
    if (g_params.SkewFitMode == 3)
        FixWackyTimestamps();
    
	if (g_params.SkewFitMode) {
    	ClockSkew(&slope, &offset);
	    AdjustForClockSkew(slope,offset);
	    NormalizeTimeStamps();
	}

	if(hLogFile != INVALID_HANDLE_VALUE) {
		WriteSchedulingRecords(hLogFile, g_params.Dummy);
	}
	printf("Done stats from file.\n");
} // DoStatsFromFile()

DWORD
OpenRawFile(
	IN PCHAR Name,
	OUT HANDLE *File
	)
{   
	HANDLE hFile;
    UCHAR * logName;

    logName = malloc(strlen(Name) + 4);
    strncpy(logName, Name, strlen(Name));
    
    logName[strlen(Name)+0] = '.';
    logName[strlen(Name)+1] = 'r';
    logName[strlen(Name)+2] = 'a';
    logName[strlen(Name)+3] = 'w';
    logName[strlen(Name)+4] = (UCHAR)NULL;

    hFile = CreateFile(logName,
                       GENERIC_READ,
                       0,
                       NULL,
                       OPEN_EXISTING ,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
                       
    *File = hFile;

    return(INVALID_HANDLE_VALUE == hFile ? (!(ERROR_SUCCESS)) : ERROR_SUCCESS);
} // OpenRawFile()

INT64 ReadSchedulingRecords(HANDLE File)
{
    char szTempFile[MAX_PATH];
    char szTempPath[MAX_PATH];
	LOG_RECORD currentRecord;
	CHAR lineBuf[MAX_STRING];
	CHAR nextChar[2] = {0,0};
	DWORD readBytes = 0;
	INT assignedFields;

	if (!File || (File == INVALID_HANDLE_VALUE)) {
		fprintf(stderr,"ERROR: Invalid File\n");
		return 0;
	}

    CreateLog(&g_log, 2048);
	// loop through the file, reading in line after line
	do 
	{
		// get the next line of characters
		bzero(lineBuf, MAX_STRING);
		ZeroMemory(lineBuf, MAX_STRING);
		do {
			ReadFile(File,nextChar,1,&readBytes,NULL);
			if (readBytes == 0) {
			    if (g_log.nBuffersLogged == 0) {
			        fprintf(stderr,"ERROR: no logs read\n");
			        exit(1);
			    }
			    break;
			}
			strcat(lineBuf,nextChar);
		} while (*nextChar != '\n');
		// parse line and add it to the log
		assignedFields = sscanf(lineBuf, 
			"%I64u:%I64u:%I64u:%d:%d\n", 
			&(currentRecord.TimeSent),
			&(currentRecord.TimeReceived),
			&(currentRecord.Latency),
			&(currentRecord.BufferSize),
			&(currentRecord.SequenceNumber));
		if ((assignedFields != 5) && (assignedFields != EOF))
			printf("ERROR: parsing the log gave bad field assignments on record %d\n", 
			    g_log.nBuffersLogged);

		if (assignedFields == EOF) break;
        AddLogEntry(&g_log, &currentRecord);
	}
	while (readBytes != 0);

    printf("read %d records\n",g_log.nBuffersLogged);
	return g_log.nBuffersLogged;  // return the number of records read
} // ReadSchedulingRecords()

VOID
DoStats()
{
    DOUBLE slope = 0;
    DOUBLE offset = 0;

    GenericStats();
    
    if(!normalize){
        if(hRawFile != INVALID_HANDLE_VALUE){
            WriteSchedulingRecords(hRawFile, FALSE);
        }
    }
    
    NormalizeTimeStamps();
    
    if(normalize){
        if(hRawFile != INVALID_HANDLE_VALUE){
            WriteSchedulingRecords(hRawFile, FALSE);
        }
    }

    if(!g_params.calibration) { // if we have nothing specified, calibrate on all buffers
        g_params.calibration = g_state.nBuffersReceived;
    }
   
    // here we check for wacky timestamps on the sender and receiver
    if (g_params.SkewFitMode == 3)
        FixWackyTimestamps();
    
    if(g_params.SkewFitMode) {
        ClockSkew(&slope, &offset);
        AdjustForClockSkew(slope, offset);
        NormalizeTimeStamps();
    }

    // we calculate these stats on the normalized / skew adjusted data
    AdvancedStats();
    
    CheckForLostPackets();
    
    if(hLogFile != INVALID_HANDLE_VALUE){
        WriteSchedulingRecords(hLogFile, g_params.Dummy);
    }
    printf("\n");
}

VOID
WriteSchedulingRecords(
    HANDLE File,
    BOOLEAN InsertDummyRows)
{
    
    LOG_RECORD scheduleRecord;
    CHAR formattingBuffer[MAX_STRING];
    INT dwWritten;
    INT64 records = g_log.nBuffersLogged;
	INT wrote;
    INT i;
    INT64 maxLatency = (INT64)0;

    if(!File || (File == INVALID_HANDLE_VALUE)){
        return;
    }

    while(records){
        GetLogEntry(&g_log, &scheduleRecord, g_log.nBuffersLogged - records);
		ZeroMemory(formattingBuffer,MAX_STRING);
		
        wrote = sprintf(formattingBuffer,
		                "%020I64u:%020I64u:%010I64d:%10d:%10d\n", 
						scheduleRecord.TimeSent,
						scheduleRecord.TimeReceived,
				        scheduleRecord.Latency,
					    scheduleRecord.BufferSize,
						scheduleRecord.SequenceNumber);

        WriteFile(File, formattingBuffer, wrote, &dwWritten, NULL);

        records--;
    }
} // WriteSchedulingRecords()

VOID
GenericStats()
{
    INT bytesWritten;
    UCHAR holdingBuffer[MAX_STRING];
    INT count;

    // say who the sender and receiver are
    count = sprintf(holdingBuffer, "Sender: %s Receiver: %s\n",szHisAddr, szMyAddr);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);

    // say when we received the first packet
    count = sprintf(holdingBuffer, "First packet received: %02u:%02u.%02u.%03u %02u/%02u/%04u (UTC)\n",
        systimeStart.wHour, systimeStart.wMinute, systimeStart.wSecond, 
        systimeStart.wMilliseconds, systimeStart.wDay, systimeStart.wMonth, systimeStart.wYear);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);
    
    // write the test params to the .sta file
    bzero(holdingBuffer, MAX_STRING);
    count = _snprintf(holdingBuffer, MAX_STRING -1,
                      "Buffer size: %d\tTokenrate: %d\n",
                      g_params.buflen, g_params.TokenRate);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);
    
    // write some generic results
    bzero(holdingBuffer, MAX_STRING);
    count = _snprintf(holdingBuffer,
                      MAX_STRING-1, // leave room for NULL
                      "Received %u packets.\n",
                      g_state.nBuffersReceived);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);

    bzero(holdingBuffer, MAX_STRING);
    count = _snprintf(holdingBuffer,
                      MAX_STRING-1, // leave room for NULL
                      "Logged %I64u records.\n",
                      g_log.nBuffersLogged);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);

    bzero(holdingBuffer, MAX_STRING);
    count = _snprintf(holdingBuffer,
                      MAX_STRING-1, // room for NULL
                      "Received %ld bytes in %I64d milliseconds = %I64d KBps\n",
                      g_state.nBytesTransferred,
                      timeElapsed,
                      g_state.nBytesTransferred/timeElapsed);
    WriteStats(holdingBuffer, count);
    printf("%s",holdingBuffer);
} // GenericStats()

void AdvancedStats() {
    // write some more interesting stats to the .sta file
    char szBuf[MAX_STRING];
    INT64 i,n;
    int count;
    INT64 FirstTime,LastTime;
    double rate, median, mean, var, abdev, skew, kurt, sdev, ep = 0.0, s, p;
    LOG_RECORD rec;
    double * sortedLatencies;

    // overall send rate
    GetLogEntry(&g_log, &rec, 0);
    FirstTime = rec.TimeSent;
    GetLogEntry(&g_log, &rec, g_log.nBuffersLogged - 1);
    LastTime = rec.TimeSent;
    rate = (rec.SequenceNumber * g_params.buflen)/((double)(LastTime - FirstTime)/10000000.0);
    count = sprintf(szBuf, "Overall send rate: %.3f Bytes/s\n",rate);
    WriteStats(szBuf, count);
    printf("%s",szBuf);
    GetLogEntry(&g_log, &rec, 0);
    FirstTime = rec.TimeReceived;
    GetLogEntry(&g_log, &rec, g_log.nBuffersLogged - 1);
    LastTime = rec.TimeReceived;
    rate = (g_state.nBytesTransferred)/((double)(LastTime - FirstTime)/10000000.0);
    count = sprintf(szBuf, "Overall recv rate: %.3f Bytes/s\n",rate);
    WriteStats(szBuf, count);
    printf("%s",szBuf);

    // now show mean, variance, avdev, etc of latency.
    s = 0.0;
    n = g_log.nBuffersLogged;
    sortedLatencies = malloc(sizeof(double) * (UINT)n);
    for (i=0; i < n; i++) { // first pass, we get mean
        GetLogEntry(&g_log, &rec, i);
        s += (double)rec.Latency/10.0;
        sortedLatencies[i] = (double)rec.Latency/10.0;
    }
    qsort(sortedLatencies,(UINT)n,sizeof(double),compare);
    median = (n & 1) ? sortedLatencies[(n-1)/2] : 0.5*(sortedLatencies[n/2] + sortedLatencies[n/2 - 1]);
    free(sortedLatencies);
    mean = s / n;
    abdev = var = skew = kurt = 0.0;
    for (i=0; i<n; i++) { // second pass, we get 1st,2nd,3rd,4th moments of deviation from mean
        GetLogEntry(&g_log, &rec, i);
        abdev += fabs(s=(double)rec.Latency/10.0 - mean);
        ep += s;
        var += (p = s*s);
        skew += (p *= s);
        kurt += (p *= s);
    }
    abdev /= n;
    var = (var - ep*ep/n) / (n-1);
    sdev = sqrt(var);
    if (var) {           // if var=0, no skew/kurtosis defined
        skew /= (n*var*sdev);
        kurt  = kurt / (n*var*var) - 3.0;
    }

    count = sprintf(szBuf, "Latency Statistics (microsecond units): median: %.1lf\n",median);
    WriteStats(szBuf, count);
    printf("%s",szBuf);
    count = sprintf(szBuf, "\tMean:     %6.2lf\tStdev: %6.2lf\tAbDev:    %6.2lf\n",mean,sdev,abdev);
    WriteStats(szBuf, count);
    printf("%s",szBuf);
    count = sprintf(szBuf, "\tVariance: %6.2lf\tSkew:  %6.2lf\tKurtosis: %6.2lf\n",var,skew,kurt);
    WriteStats(szBuf, count);
    printf("%s",szBuf);
}

VOID
CheckForLostPackets()
{
    LOG_RECORD currentRecord;
    INT currentSequenceNumber = 0;
    INT bytesWritten;
    UCHAR holdingBuffer[MAX_STRING];
    INT count;
    INT64 nLost = 0;
    INT i;

    for(i=0; i<g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        if(currentRecord.SequenceNumber != currentSequenceNumber){
            nLost += currentRecord.SequenceNumber - currentSequenceNumber;
            currentSequenceNumber = currentRecord.SequenceNumber;
        }

        currentSequenceNumber += g_params.LoggingPeriod;
    }
    count = sprintf(holdingBuffer, "Dropped %I64u packets\n", nLost);
    WriteStats(holdingBuffer, count);
} // CheckForLostPackets()

VOID
WriteStats(
    UCHAR * HoldingBuffer,
    INT Count)
{
    INT bytesWritten;

    if(Count < 0){
        Count = MAX_STRING;
    }

    WriteFile(hStatFile,
              HoldingBuffer,
              Count,
              &bytesWritten,
              NULL);
} // WriteStats()

VOID
NormalizeTimeStamps()
{
    LOG_RECORD currentRecord;
    INT bytesWritten;
    UCHAR holdingBuffer[MAX_STRING];
    INT count;
    INT i;

    UINT64 timeSent;
    UINT64 timeReceived;
    UINT64 smaller;
    INT64 constantDelay = MAX_INT64;
    INT64 currentDelay;
    UINT64 base = 0xFFFFFFFFFFFFFFFF;

    for(i=0; i<g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        currentDelay = currentRecord.TimeReceived - currentRecord.TimeSent;
        constantDelay = (currentDelay < constantDelay) ? currentDelay : constantDelay;
    }

    // now subtract off the constant delay off
    for(i=0; i<g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        currentRecord.TimeReceived -= constantDelay;
        currentRecord.Latency = currentRecord.TimeReceived - currentRecord.TimeSent;
        SetLogEntry(&g_log, &currentRecord, i);
    }

    for (i=0; i<g_log.nBuffersLogged; i++) {
        GetLogEntry(&g_log, &currentRecord, i);
        smaller = (currentRecord.TimeReceived < currentRecord.TimeSent) ?
            currentRecord.TimeReceived : currentRecord.TimeSent;
        base = (base < smaller)?base:smaller;  // find the smallest timestamp
    }        
    
    // now we can subtract the base off of the send & receive times
    for (i=0; i<g_log.nBuffersLogged; i++) {
        GetLogEntry(&g_log, &currentRecord, i);
        currentRecord.TimeSent -= base;
        currentRecord.TimeReceived -= base;
        SetLogEntry(&g_log, &currentRecord, i);
    }
} // NormalizeTimeStamps()

VOID
ClockSkew(
    DOUBLE * Slope,
    DOUBLE * Offset) {
    // If there is a calibration period, we can estimate clock skew between
    // sender and receiver. See comments under AdjustForClockSkew. We use
    // calculus to determine the best-fit slope.

    INT i;
    LOG_RECORD currentRecord;
	DOUBLE N;
    DOUBLE slope;
    DOUBLE offset;
    UCHAR holdingBuffer[MAX_STRING];
    INT count;
    double *x, *y, abdev;
    double devpercent;
    
    // We find the clock skew using medfit, a function which fits to minimum absolute deviation
    N = (double) g_params.calibration;
    x = malloc(sizeof(double) * (UINT)N);
    y = malloc(sizeof(double) * (UINT)N);
    for (i = 0; i<N; i++) {
        GetLogEntry(&g_log,&currentRecord,i);
        x[i] = (DOUBLE)currentRecord.TimeSent;
        y[i] = (DOUBLE)currentRecord.Latency;
    }
    medfit(x, y, (INT)N, &offset, &slope, &abdev);

    // Now write out our findings.
    bzero(holdingBuffer, MAX_STRING);

    count = _snprintf(holdingBuffer,
					MAX_STRING-1, // leave room for NULL
					"Clock skew is %f microseconds per second.\n  " \
					"\tbased on %d calibration points\n",
					100000*slope, g_params.calibration);

    WriteStats(holdingBuffer, count);
	printf("%s",holdingBuffer);

    for (i = 0,devpercent = 0.0; i<N; i++) {
        devpercent += y[i];
    }
    devpercent /= N;
    devpercent = 100 * abdev / devpercent;

    printf("\tfit resulted in avg. absolute deviation of %f percent from mean\n",devpercent);

    free(x);
    free(y);
    *Slope = slope;
    *Offset = offset;
} // ClockSkew()

BOOLEAN
AnomalousPoint(
			   DOUBLE x,
			   DOUBLE y)
{
	// here we simply keep a buffer of the past 10 calls and if this one 
	// falls out of a few standard deviations of the 8 inner points, we deem it anomalous
	static DOUBLE buf[10];
	DOUBLE sortedbuf[10];
	DOUBLE mean = 0;
	DOUBLE sum = 0;
	DOUBLE sumsqdev = 0;
	DOUBLE median = 0;
	DOUBLE sdev = 0;
	DOUBLE N;
	static int curIndex = 0;
	int i;
	static INT64 submittedPoints;

	buf[curIndex % 10] = y;
	curIndex++;
	submittedPoints++;
	
	if (g_params.SkewFitMode != 4)
		return FALSE;

	if (submittedPoints >= 10) {
		sum = 0;
		sumsqdev = 0;

        // sort them into sortedbuf
        for (i=0; i<10; i++) sortedbuf[i] = buf[i];
        qsort(sortedbuf, 10, sizeof(DOUBLE), compare);

        // use only the inner 8 points in the calculation of mean & var
		for (i = 1; i < 9; i++) {
			sum += sortedbuf[i];
		}

		N = 8.0; // using only 8 points
		mean = sum / N;

		for (i = 1; i < 9; i++) {
			sumsqdev += ((sortedbuf[i] - mean) * (sortedbuf[i] - mean));
		}
		
		sdev = sqrt(sumsqdev / N);
		if (fabs(y - mean) < 2.5 * sdev) {
			return FALSE;
		}
		else {
		    anomalies++;
			return TRUE;
		}
	}

	return TRUE;
} // AnomalousPoint()

VOID
AdjustForClockSkew(
    DOUBLE Slope,
    DOUBLE Offset)
{
    //
    // When measuring very low jitter, clock drift between machines 
    // introduces noise in the form of a monotonically increasing 
    // skew between sending and receiving clock. This effect can be 
    // filtered out by finding the best-fit slope for all samples 
    // taken during the calibration period, then using this slope to
    // normalize the entire run. This routine normalizes using the 
    // slope determined in the routine ClockSkew.
    //

    INT i;
    LOG_RECORD currentRecord;
    INT64 minLatency = MAX_INT64;
    INT64 x;
    DOUBLE mXPlusB;

    for(i=0; i < g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        mXPlusB = (currentRecord.TimeSent*Slope) + Offset; // offset is not necessary

        currentRecord.TimeReceived -= (INT64)mXPlusB;
        currentRecord.Latency -= (INT64)mXPlusB;

        SetLogEntry(&g_log, &currentRecord, i);

        //
        // find the minimum latency value
        //

        minLatency = (currentRecord.Latency < minLatency)?
                        currentRecord.Latency:
                        minLatency;
    }

    for(i=0; i < g_log.nBuffersLogged; i++){
        GetLogEntry(&g_log, &currentRecord, i);
        currentRecord.Latency -= minLatency;
        currentRecord.TimeReceived -= minLatency;
        SetLogEntry(&g_log, &currentRecord, i);   
    }
} // AdjustForClockSkew()

#define WACKY 2.5

BOOL FixWackyTimestamps() {
    // This routine will look over the sender & receiver timestamps and try to see if there
    // are any non-clock skew related irregularities (such as one of them bumping it's clock
    // a fixed amount every once-in-a-while) and try to remove them.
    INT64 *sendstamps, *recvstamps;
    double *sendgaps, *recvgaps;
    double *sortedsendgaps, *sortedrecvgaps;
    double sendmean, sendsdev, sendsum, sendsumsqdev;
    double recvmean, recvsdev, recvsum, recvsumsqdev;
    double mediansendgap, medianrecvgap;
    double modesendgap, moderecvgap;
    double meansendwackiness, sdevsendwackiness, sumsendwackiness, sumsqdevsendwackiness;
    double meanrecvwackiness, sdevrecvwackiness, sumrecvwackiness, sumsqdevrecvwackiness;
    double fractionaldevofsendwackiness, fractionaldevofrecvwackiness;
    double normalsendgapmean, normalrecvgapmean;
    double trimmeansendgap, trimmeanrecvgap;
    BOOL *fWackoSend, *fWackoRecv;
    int cWackoSend, cWackoRecv;
    BOOL *fMaybeWackoSend, *fMaybeWackoRecv;
    int i,N;
    LOG_RECORD currentRecord;
    const double FixThreshold = 0.1;
    double CumulativeFixMagnitude = 0.0;

    N = (int)g_log.nBuffersLogged;
    cWackoSend = cWackoRecv = 0;
    // fill our arrays.
    sendstamps = malloc(sizeof(INT64) * N);
    recvstamps = malloc(sizeof(INT64) * N);
    sendgaps = malloc(sizeof(double) * N);
    recvgaps = malloc(sizeof(double) * N);
    sortedsendgaps = malloc(sizeof(double) *N);
    sortedrecvgaps = malloc(sizeof(double) *N);
    fWackoRecv = malloc(sizeof(BOOL) * N);
    fWackoSend = malloc(sizeof(BOOL) * N);
    fMaybeWackoSend = malloc(sizeof(BOOL) * N);
    fMaybeWackoRecv = malloc(sizeof(BOOL) * N);

    for (i=0; i<N; i++) {
        GetLogEntry(&g_log, &currentRecord, i);
        sendstamps[i] = currentRecord.TimeSent;
        recvstamps[i] = currentRecord.TimeReceived;
        fWackoSend[i] = FALSE;
        fMaybeWackoSend[i] = FALSE;
        fWackoRecv[i] = FALSE;
        fMaybeWackoRecv[i] = FALSE;
    }
    
    // First, check for wacky timestamps. This is a multistep process:
    //    1. Calculate the interpacket gaps on both sender & receiver.
    for (i=1; i<N; i++) {
        sendgaps[i] = (double) (sendstamps[i] - sendstamps[i-1]);
        recvgaps[i] = (double) (recvstamps[i] - recvstamps[i-1]);
    }
    //    2. We will define wacky as being at least WACKY standard deviations away from the
    //       mean.
    sendsum = recvsum = 0.0;
    for (i=1; i<N; i++) {
        sendsum += sendgaps[i];
        recvsum += recvgaps[i];
    }
    sendmean = sendsum / N;
    recvmean = recvsum / N;
    sendsumsqdev = recvsumsqdev = 0.0;
    for (i=1; i<N; i++) {
        sendsumsqdev += ((sendgaps[i] - sendmean) * (sendgaps[i] - sendmean));
        recvsumsqdev += ((recvgaps[i] - recvmean) * (recvgaps[i] - recvmean));
    }
	sendsdev = sqrt(sendsumsqdev / N);
	recvsdev = sqrt(recvsumsqdev / N);

    for (i=1; i<N; i++) {
        if ((sendgaps[i] < sendmean - WACKY*sendsdev) ||
            (sendgaps[i] > sendmean + WACKY*sendsdev)) {
            fMaybeWackoSend[i] = fWackoSend[i] = TRUE;
        }
        if ((recvgaps[i] < recvmean - WACKY*recvsdev) ||
            (recvgaps[i] > recvmean + WACKY*recvsdev)) {
            fMaybeWackoRecv[i] = fWackoRecv[i] = TRUE;
        }        
    }
    
    //    3. Check to see if any wacky points are unpaired (that is, a wacky point in the
    //       sending timestamps is not matched with an equally wacky point in the receiving
    //       timestamps).
    for (i=1; i<N; i++) {
        if (fMaybeWackoSend[i] && fMaybeWackoRecv[i]) {
            // I should check to make sure they're equally wacky, but i'm not currently
            fMaybeWackoSend[i] = fWackoSend[i] = FALSE;
            fMaybeWackoRecv[i] = fWackoRecv[i] = FALSE;
        }
    }
    //    4. Check to see if any wacky unpaired points are solitary (that is, they are not
    //       surrounded by other wacky points).
    for (i=1; i<N-1; i++) {
        if (fMaybeWackoSend[i]) {
            if (fMaybeWackoSend[i-1] || fMaybeWackoSend[i+1]) {
                fWackoSend[i] = FALSE;
            }
        }
        if (fMaybeWackoRecv[i]) {
            if (fMaybeWackoRecv[i-1] || fMaybeWackoRecv[i+1]) {
                fWackoRecv[i] = FALSE;
            }
        }
    }
    if (fMaybeWackoSend[N-1] && fMaybeWackoSend[N-2]) fWackoSend[N-1] = FALSE;
    if (fMaybeWackoRecv[N-1] && fMaybeWackoRecv[N-2]) fWackoRecv[N-1] = FALSE;
    //    5. If we find a point that meets all these criteria, label it wacky and add it to
    //       our list of wacky points.
    for (i=1; i<N; i++) {
        fMaybeWackoSend[i] = fWackoSend[i];
        fMaybeWackoRecv[i] = fWackoRecv[i];    
    }

    // Now we find out the stats for the sends & receivees to use as the baseline
    sendsum = recvsum = 0.0;
    cWackoSend = cWackoRecv = 0;
    for (i=1; i<N; i++) {
        sortedsendgaps[i] = sendgaps[i];
        sortedrecvgaps[i] = recvgaps[i];
        if (!fWackoSend[i]) {
            sendsum += sendgaps[i];
            cWackoSend++;
        }
        if (!fWackoRecv[i]) {
            recvsum += recvgaps[i];
            cWackoRecv++;
        }
    }
    normalsendgapmean = sendsum / cWackoSend;
    normalrecvgapmean = recvsum / cWackoRecv;
    qsort(sortedsendgaps, N, sizeof(double), compare);
    qsort(sortedrecvgaps, N, sizeof(double), compare);
    if (N & 1) { // odd N
        mediansendgap = sortedsendgaps[(N+1) / 2];
        medianrecvgap = sortedrecvgaps[(N+1) / 2];
    } else { // even N
        i = N/2;
        mediansendgap = 0.5 * (sortedsendgaps[i] + sortedsendgaps[i+1]);
        medianrecvgap = 0.5 * (sortedrecvgaps[i] + sortedrecvgaps[i+1]);
    }
    sendsum = recvsum = 0.0;
    for (i=(int)(0.05*N); i<(int)(0.85*N); i++) { // find the 80% trimmean (bottom heavy)
        sendsum += sortedsendgaps[i];
        recvsum += sortedrecvgaps[i];
    }
    trimmeansendgap = sendsum / (0.80 * N);
    trimmeanrecvgap = recvsum / (0.80 * N);
    modesendgap = mode(sendgaps, N);
    moderecvgap = mode(recvgaps, N);

    // 6. we have to check to see if the wackiness at each wacky point is about equal to what
    // we think it ought to be, based on the timer clock
    for (i=1; i<N; i++) {
        if (fWackoSend[i]) {
            if (!InRange(sendgaps[i] - g_BadHalAdjustment, 
                    mediansendgap - sendsdev, mediansendgap + sendsdev)) {
               fWackoSend[i] = FALSE;
               cWackoSend--;
            }
        }
        if (fWackoRecv[i]) {
            if (!InRange(recvgaps[i] - g_BadHalAdjustment, 
                    medianrecvgap - recvsdev, medianrecvgap + recvsdev)) {
               fWackoRecv[i] = FALSE;
               cWackoRecv--;
            }
        }
    }

    // Now we want to correct for the wacky timestamps, so we see if the wacky points are all
    // equally wacky. If they are, we're psyched and we simply subtract off the wackiness
    // from the wacky points and all points after them. (Wackiness is cumulative!)
    cWackoSend = cWackoRecv = 0;
    sumsendwackiness = sumrecvwackiness = sumsqdevsendwackiness = sumsqdevrecvwackiness = 0.0;
    for (i=1; i<N; i++) {
        if (fWackoSend[i]) {
            sumsendwackiness += (sendgaps[i] - trimmeansendgap);
            cWackoSend++;
        }
        if (fWackoRecv[i]) {
            sumrecvwackiness += (recvgaps[i] - trimmeanrecvgap);
            cWackoRecv++;
        }
    }
    meansendwackiness = sumsendwackiness / cWackoSend;
    meanrecvwackiness = sumrecvwackiness / cWackoRecv;
    for (i=1; i<N; i++) {
        if (fWackoSend[i])
            sumsqdevsendwackiness += ((sendgaps[i]-trimmeansendgap-meansendwackiness) * (sendgaps[i]-normalsendgapmean-meansendwackiness));
        if (fWackoRecv[i])
            sumsqdevrecvwackiness += ((recvgaps[i]-trimmeanrecvgap-meanrecvwackiness) * (recvgaps[i]-normalrecvgapmean-meanrecvwackiness));
    }
    sdevsendwackiness = sqrt(sumsqdevsendwackiness / cWackoSend);
    sdevrecvwackiness = sqrt(sumsqdevrecvwackiness / cWackoRecv);
    
    // so if the fractional deviation is less than some set amount, we apply the fix
    fractionaldevofsendwackiness = sdevsendwackiness / meansendwackiness;
    fractionaldevofrecvwackiness = sdevrecvwackiness / meanrecvwackiness;
    if (cWackoSend && (fractionaldevofsendwackiness < FixThreshold)) {
        // apply fix to send timestamps
        CumulativeFixMagnitude = 0.0;
        cWackoSend = 0;
        for (i=0; i<N; i++) {
            if (fWackoSend[i]) {
                fWackySender = TRUE;
                CumulativeFixMagnitude += g_BadHalAdjustment;
                cWackoSend++;
            }
            sendstamps[i] -= (INT64)CumulativeFixMagnitude;
        }
    }
    if (cWackoRecv && (fractionaldevofrecvwackiness < FixThreshold)) {
        // apply fix to recv timestamps
        CumulativeFixMagnitude = 0.0;
        cWackoRecv = 0;
        for (i=0; i<N; i++) {
            if (fWackoRecv[i]) {
                fWackyReceiver = TRUE;
                CumulativeFixMagnitude += g_BadHalAdjustment;
                cWackoRecv++;
            }
            recvstamps[i] -= (INT64)CumulativeFixMagnitude;
        }
    }

    // set the globals to reflect our "fixed" values
    for (i=0; i<N; i++) {
        if (fWackySender) {
            GetLogEntry(&g_log, &currentRecord, i);
            currentRecord.TimeSent = sendstamps[i];
            SetLogEntry(&g_log, &currentRecord, i);
        }
        if (fWackyReceiver) {
            GetLogEntry(&g_log, &currentRecord, i);
            currentRecord.TimeReceived = recvstamps[i];
            SetLogEntry(&g_log, &currentRecord, i);
        }
    }
    if (fWackySender || fWackyReceiver) {
        printf("WARNING: I noticed some oddities among the timestamps on the");
        if (fWackySender) printf(" sender");
        if (fWackySender && fWackyReceiver) printf(" and");
        if (fWackyReceiver) printf(" receiver");
        printf(".\n");
        if (fWackySender) {
            printf("\t%d of them on the order of %fms each on the sender.\n",
                cWackoSend, meansendwackiness / 10000); }
        if (fWackyReceiver) {
            printf("\t%d of them on the order of %fms each on the receiver.\n",
                cWackoRecv, meanrecvwackiness / 10000); }
        printf("\tThey are caused by a malfunctioning clock on the afflicted machine.\n");
        printf("\tI have tried to compensate for them in the .log file.\n");
        NormalizeTimeStamps(); // we have to renormalize now
    }
    return FALSE;
}

DWORD WINAPI RSVPMonitor (LPVOID lpvThreadParm) {   
    DWORD dwResult = 0;
    ULONG status;
    BOOLEAN confirmed = FALSE;
    UINT64 ui64LastHi = 0,ui64Now = 0;
    FILETIME filetime;
    ULARGE_INTEGER ulargeint;
    BOOLEAN fResvGood = FALSE;

    // don't do anything until the control socket is established
    while (g_sockControl == INVALID_SOCKET) {
        Sleep(10);
    }

    while(TRUE){
        // send a HELLO message every once in a while
        GetSystemTimeAsFileTime(&filetime);
        memcpy(&ulargeint, &filetime, sizeof(FILETIME));
        ui64Now = ulargeint.QuadPart;
        if (ui64LastHi + 10000000*SECONDS_BETWEEN_HELLOS < ui64Now) {
            SendControlMessage(g_sockControl,MSGST_HELLO);
            ui64LastHi = ui64Now;
        }
        
        // get the RSVP statuscode, waiting for as long as it takes
        status = GetRsvpStatus(WSA_INFINITE,fd);

        if (g_state.Done) {
            ExitThread(1);
        }
        switch (status) {
            case WSA_QOS_TRAFFIC_CTRL_ERROR: // sad if we get this
                printf("RSVP-ERR: Reservation rejected by traffic control on server. Aborting.\n");
                SendControlMessage(g_sockControl,MSGST_RSVPERR);
                g_state.Done = TRUE;
                exit(1);
                break;
            case WSA_QOS_REQUEST_CONFIRMED:  // happy if we get this
                if (!confirmed) {
                    printf("RSVP: Reservation confirmed\n");
                    confirmed = TRUE;
                    fResvGood = TRUE;
                }
                break;
            case WSA_QOS_SENDERS:
                if (!fResvGood && !trans) {
                    printf("\nRSVP Monitor: WSA_QOS_SENDERS at t=%I64ds\n",
                        (GetUserTime() - timeStart) / 10000000);
                    fResvGood = TRUE;
                }
                break;
            case WSA_QOS_RECEIVERS:
                if (!fResvGood && trans) {
                    printf("\nRSVP Monitor: WSA_QOS_RECEIVERS at t=%I64ds\n",
                        (GetUserTime() - timeStart) / 10000000);
                    fResvGood = TRUE;
                }
                break;
            case WSA_QOS_NO_SENDERS: // the sender is now gone, so we stop
                if (fResvGood && !trans) {
                    printf("\nRSVP Monitor: WSA_QOS_NO_SENDERS at t=%I64ds\n",
                        (GetUserTime() - timeStart) / 10000000);
                    fResvGood = FALSE;
                }
                break;
            case WSA_QOS_NO_RECEIVERS: // means the sender is done, so he should exit
                if (fResvGood && trans) {
                    printf("\nRSVP Monitor: WSA_QOS_NO_RECEIVERS at t=%I64ds\n",
                        (GetUserTime() - timeStart) / 10000000);
                    fResvGood = FALSE;
                }
                break;
            default:
                break;
        }
        Sleep(1000); // check at most once per second
    }
    
    return dwResult;
} // RSVPMonitor()

DWORD WINAPI KeyboardMonitor(LPVOID lpvThreadParm) {
    DWORD dwResult = 0;
    char ch;
    while (TRUE) {
        ch = (CHAR) getchar();
        switch (ch) {
        case 'q':
            SendControlMessage(g_sockControl,MSGST_DONE);
            g_state.Done = TRUE;
            ExitThread(1);
            break;
        }
    }
    return 0;
}

DWORD WINAPI ControlSocketMonitor(LPVOID lpvThreadParm) {
    DWORD dwResult = 0;
    DWORD dwError, cbBuf = 0;
    DWORD dwAddrSize = MAX_STRING;
    char szAddr[MAX_STRING];
    char szBuf[MAX_STRING],szCommand[MAX_STRING], *pchStart, *pchEnd;
    int cch;
    char szT[MAX_STRING];
    char szT2[MAX_STRING];
    char * szHost;
    BOOL fSender;
    SOCKET sockControl, sockListen;
    SOCKADDR_IN sinmeControl, sinhimControl;
    PHOSTENT phostent;
    UINT64 ui64LastHello = 0;
    BOOL fDone = FALSE;
    BOOL fGotRate=FALSE, fGotSize=FALSE, fGotNum=FALSE;
    BOOL fSentReady =FALSE;

    // find out if we're the sender or receiver
    if (lpvThreadParm == NULL) fSender = FALSE;
    else fSender = TRUE;

    // if sender, copy the host address into our local host string
    if (fSender) {
        szHost = malloc(strlen((char *)lpvThreadParm) + 1);
        strcpy(szHost, (const char *)lpvThreadParm);
    }        

    // set up a control socket
    if (fSender) {
        sockControl = socket(AF_INET, SOCK_STREAM, 0);
    }
    else {
        sockListen = socket(AF_INET, SOCK_STREAM, 0);
    }
    
    // bind properly
    sinmeControl.sin_family = AF_INET;
    sinmeControl.sin_addr.s_addr = INADDR_ANY;
    sinhimControl.sin_family = AF_INET;
    if (fSender) {
        sinmeControl.sin_port = 0;
        // set up the sinhim structure
        if (atoi(szHost) > 0 )  {
            sinhimControl.sin_addr.s_addr = inet_addr(szHost);
        }
        else{
            if ((phostent=gethostbyname(szHost)) == NULL) {
                ErrorExit("bad host name",WSAGetLastError());
            }
            sinhimControl.sin_family = phostent->h_addrtype;
            memcpy(&(sinhimControl.sin_addr.s_addr), phostent->h_addr, phostent->h_length);
        }
        sinhimControl.sin_port = htons(CONTROL_PORT);
        dwError = bind(sockControl,(SOCKADDR*)&sinmeControl,sizeof(sinmeControl));
    }
    else { // receiver
        sinmeControl.sin_port = htons(CONTROL_PORT);
        dwError = bind(sockListen,(SOCKADDR*)&sinmeControl,sizeof(sinmeControl));
    }
    if (dwError == SOCKET_ERROR)
        ErrorExit("bind failed",WSAGetLastError());

    // now connect the socket
    sinhimControl.sin_family = AF_INET;
    if (fSender) {
        // if we're the sender, keep trying to connect until we get through
        dwAddrSize = MAX_STRING;
        dwError = WSAAddressToString((SOCKADDR *)&(sinhimControl),
                               sizeof(SOCKADDR_IN),
                               NULL,
                               szAddr,
                               &dwAddrSize);
        if (dwError == SOCKET_ERROR)
            ErrorExit("WSAAddressToString failed", WSAGetLastError());
        else
            strcpy(szHisAddr,szAddr);
        
        while (TRUE) {
            dwError = connect(sockControl,(SOCKADDR*)&sinhimControl,sizeof(sinhimControl));
            if (!dwError) {
                printf("control socket: connected to %s\n",szAddr);
                break;
            }
            dwError = WSAGetLastError();
            if (dwError != WSAECONNREFUSED) {
                ErrorExit("connect() failed",dwError);
            }
            Sleep(500); // wait a half second between attempts
        }
    }
    else {
        // if we're the receiver, listen / accept
        if (listen(sockListen, SOMAXCONN) == SOCKET_ERROR) {
            ErrorExit("listen() failed", WSAGetLastError());
        }

        sockControl = accept(sockListen, (SOCKADDR*)&sinhimControl, &dwAddrSize);
        // once we've accepted, close the listen socket
        closesocket(sockListen);
        if ((INT_PTR)sockControl < 0) {
            ErrorExit("accept() failed",WSAGetLastError());
        }
        
        dwAddrSize = MAX_STRING;    
        dwError = WSAAddressToString((SOCKADDR *)&(sinhimControl),
                               sizeof(SOCKADDR_IN),
                               NULL,
                               szAddr,
                               &dwAddrSize);
        if (dwError == SOCKET_ERROR)
            ErrorExit("WSAAddressToString failed", WSAGetLastError());
        else
            strcpy(szHisAddr, szAddr);
        
        printf("control socket: accepted connection from %s\n",szAddr);
    }

    // set our global control socket variable
    g_sockControl = sockControl;

    // record my name
    dwAddrSize = sizeof(SOCKADDR_IN);
    getsockname(sockControl,(SOCKADDR *)&(sinmeControl),&dwAddrSize);
    dwAddrSize = MAX_STRING;    
    dwError = WSAAddressToString((SOCKADDR *)&(sinmeControl),
                    sizeof(SOCKADDR_IN), NULL, szAddr, &dwAddrSize);
    if (dwError == SOCKET_ERROR)
        ErrorExit("WSAAddressToString failed", WSAGetLastError());
    else
        strcpy(szMyAddr, szAddr);  
        
    // exchange version information
    sprintf(szBuf, "%s %s", MSGST_VER, VERSION_STRING);
    SendControlMessage(sockControl, szBuf);
    
    // now that we're all set, do the actual work of the control socket
    while (!fDone) {
        ZeroMemory(szBuf,MAX_STRING);
        dwError = cbBuf = recv(sockControl, szBuf, MAX_STRING, 0);
        pchStart = szBuf;
        pchEnd = szBuf + cbBuf;
        if (dwError == 0) { // the connection's been gracefully closed
            fDone = TRUE;
            closesocket(sockControl);
            g_fOtherSideFinished=TRUE;
            ExitThread(0);
        }
        if (dwError == SOCKET_ERROR) {
            dwError = WSAGetLastError();
            if (dwError == WSAECONNRESET) {
                printf("\ncontrol socket: connection reset by peer");
                printf("\n\t%I64us since last HELLO packet received",
                    (GetUserTime() - ui64LastHello)/10000000);
                printf("\n\t%I64us since start",
                    (GetUserTime() - timeStart)/10000000);
                g_state.Done = TRUE;
                fDone = TRUE;
                g_fOtherSideFinished = TRUE;
                closesocket(sockControl);
                ExitThread(1);
            }
            else {
                printf("\ncontrol socket: error in recv: %d\n",dwError);
                g_state.Done = TRUE;
                fDone = TRUE;
                g_fOtherSideFinished = TRUE;
                closesocket(sockControl);
                ExitThread(1);
            }
            continue;
        }
        while (pchStart < pchEnd) {
            ZeroMemory(szCommand,MAX_STRING);
            // consume the first command and act on it
            if (pchEnd > szBuf + cbBuf) break;
            pchEnd = strchr(pchStart, MSGCH_DELIMITER);
            if (pchEnd == NULL) break;
            strncpy(szCommand,pchStart,pchEnd - pchStart);
            if (strcmp(szCommand,MSGST_HELLO) == 0) {
                // update last hello time
                ui64LastHello = GetUserTime();
                // i should do something like set a timer here that sleeps until a certain timeout
                // passes, at which point it aborts our transfer
            }
            if (strcmp(szCommand,MSGST_ERROR) == 0) {
                // the other guy's had an error, so we stop and tell him to abort
                g_fOtherSideFinished = TRUE;
                g_state.Done = TRUE;
                fDone = TRUE;
                SendControlMessage(sockControl,MSGST_ABORT);
                closesocket(sockControl);
                ExitThread(1);
            }
            if (strcmp(szCommand,MSGST_ABORT) == 0) {
                // we're told to abort, so do so
                g_fOtherSideFinished = TRUE;
                g_state.Done = TRUE;
                fDone = TRUE;
                closesocket(sockControl);
                ExitThread(1);
            }
            if (strcmp(szCommand,MSGST_DONE) == 0) {
                // we're told the other guy's done, so therefore are we
                closesocket(sockControl);
                g_fOtherSideFinished = TRUE;
                g_state.Done = TRUE;
                fDone = TRUE;
                ExitThread(1);
            }
            if (strcmp(szCommand,MSGST_RSVPERR) == 0) {
                // we're told the other guy got an rsvp error, so we abort the whole program
                closesocket(sockControl);
                g_fOtherSideFinished = TRUE;
                g_state.Done = TRUE;
                fDone = TRUE;
                exit(1);
            }
            if (strncmp(szCommand,MSGST_SIZE,4) == 0) {
                // the sender is telling us how big the buffers are
                sscanf(szCommand,"%s %d",szT, &g_params.buflen);
                fGotSize = TRUE;
            }
            if (strncmp(szCommand,MSGST_RATE,4) == 0) {
                // the sender is telling us how fast the buffers are coming
                sscanf(szCommand, "%s %d",szT, &g_params.TokenRate);
                fGotRate = TRUE;
            }
            if (strncmp(szCommand,MSGST_NUM,3) == 0) {
                // the sender is telling us how many buffers it's sending
                sscanf(szCommand, "%s %d",szT, &g_params.nbuf);
                totalBuffers = g_params.nbuf;
                fGotNum = TRUE;
            }
            if (strncmp(szCommand,MSGST_VER,3) == 0) {
                sscanf(szCommand, "%s %s",szT, szT2);
                if (strcmp(szT2,VERSION_STRING) != 0) {
                    printf("WARNING: remote machine using different version of qtcp: %s vs. %s\n", 
                        szT2,VERSION_STRING);
                }
            }
            if (trans) {
                if (strcmp(szCommand,MSGST_READY) == 0) {
                    g_fReadyForXmit = TRUE;
                }
            }
            else {
                if (!fSentReady && fGotRate && fGotSize && fGotNum) {
                    SendControlMessage(sockControl, MSGST_READY);
                    fSentReady = TRUE;
                    g_fReadyForXmit = TRUE;
                }
            }
            pchStart = pchEnd + 1;
            pchEnd = szBuf + cbBuf;
        }    
    }
    return 0;
}

int SendControlMessage(SOCKET sock, char * szMsg) {
    int iResult;
    char szBuf[MAX_STRING];

    sprintf(szBuf,"%s%c",szMsg,MSGCH_DELIMITER);
    iResult = send (sock, szBuf, strlen(szBuf), 0);

    if (iResult == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    return iResult;
}

void ErrorExit(char *msg, DWORD dwErrorNumber) {
    fprintf(stderr,"ERROR: %d\n",dwErrorNumber);
    if (msg != NULL)
        fprintf(stderr,"\t%s\n",msg);
    else {
        switch(dwErrorNumber) {
        case WSAEFAULT:
            fprintf(stderr,"\tWSAEFAULT: Buffer too small to contain name\n");
            break;
        case WSAEINVAL:
            fprintf(stderr,"\tWSAEINVAL: Invalid socket address\n");
            break;
        case WSANOTINITIALISED:
            fprintf(stderr,"\tWSANOTINITIALIZED: WSA Not initialized\n");
            break;
        default:
            fprintf(stderr,"\tUnknown error\n");
            break;
        }
    }
    SendControlMessage(g_sockControl, MSGST_ABORT);
    
    DestroyLog(&g_log);
    WSACleanup();
    exit(1);
    _exit(1);
}

// some math utility functions

// comparison for doubles (to use in qsort)
int __cdecl compare( const void *arg1, const void *arg2 )
{
    DOUBLE dTemp;
    DOUBLE d1 = * (DOUBLE *) arg1;
    DOUBLE d2 = * (DOUBLE *) arg2;
    dTemp = d1 - d2;
    if (dTemp < 0) return -1;
    if (dTemp == 0) return 0;
    else 
        return 1;

}
// comparison for ints (to use in qsort)
int __cdecl compareint( const void *arg1, const void *arg2 )
{
    int nTemp;
    int n1 = * (int *) arg1;
    int n2 = * (int *) arg2;
    nTemp = n1 - n2;
    if (nTemp < 0) return -1;
    if (nTemp == 0) return 0;
    else 
      return 1;
}
// comparison for int64s (to use in qsort)
int __cdecl compareI64( const void *arg1, const void *arg2 )
{
    INT64 nTemp;
    INT64 n1 = * (INT64 *) arg1;
    INT64 n2 = * (INT64 *) arg2;
    nTemp = n1 - n2;
    if (nTemp < 0) return -1;
    if (nTemp == 0) return 0;
    else return 1;
}


#define EPS 1.0e-7
// sum up error function for given value of b
double rofunc(double b, int N, double yt[], double xt[], double * paa, double * pabdevt) {
    int i;
    double *pfT;
    double d, sum=0.0;
    double aa = *paa;
    double abdevt = *pabdevt;

    pfT = malloc(sizeof(double) * N);
    for (i = 0; i < N; i++) pfT[i] = yt[i]-b*xt[i];
    qsort(pfT, N, sizeof(DOUBLE), compare);
    if (N & 1) { // odd N
        aa = pfT[(N+1) / 2];
    }
    else {
        i = N / 2;
        aa = 0.5 * (pfT[i] + pfT[i+1]);
    }
    abdevt = 0.0;
    for (i = 0; i<N; i++) {
        d = yt[i] - (b*xt[i]+aa);
        abdevt += fabs(d);
        if (yt[i] != 0.0) d /= fabs(yt[i]);
        if (fabs(d) > EPS) sum += (d >= 0.0 ? xt[i]: -xt[i]);
    }
    *paa = aa;
    *pabdevt = abdevt;
    free(pfT);
    return sum;
}

#define SIGN(a,b) ((b) >= 0 ? fabs(a) : fabs(-a))

void medfit(double x[], double y[], int N, double *a, double *b, double *abdev) {
    // fit y = a + bx to least absolute deviation. abdev is mean absolute deviation.
    // incoming, a and b are treated as starting guesses
    int i;
    double *xt = x;
    double *yt = y;
    double sx, sy, sxy, sxx, chisq;
    double del, sigb;
    double bb, b1, b2, aa, abdevt, f, f1, f2, temp;

    sx = sy = sxy = sxx = chisq = 0.0;
    // we find chisq fit to use as starting guess
    for (i=0; i<N; i++) {
        sx += x[i];
        sy += y[i];
        sxy += x[i]*y[i];
        sxx += x[i]*x[i];
    }
    del = N*sxx - sx*sx;
    aa = (sxx*sy-sx*sxy) / del;
    bb = (N*sxy - sx*sy) / del;
    // do the absolute deviation fit, if we're supposed to.
    if (g_params.SkewFitMode == 2) { 
        for (i=0; i<N; i++)
            chisq += (temp=y[i]-(aa+bb*x[i]), temp*temp);
        sigb = sqrt(chisq/del);
        b1 = bb;
        f1 = rofunc(b1, N, yt, xt, &aa, &abdevt);
        // guess the bracket as 3 sigma away in downhill direction from f1
        b2 = bb + SIGN(3.0 * sigb, f1);
        f2 = rofunc(b2, N, yt, xt, &aa, &abdevt);
        if (b2 == b1) {
            *a = aa;
            *b = bb;
            *abdev = abdevt / N;
            return;
        }
        // Bracketing
        while ((f1*f2) > 0.0) {
            if (fabs(f1) < fabs(f2))
                f1 = rofunc(b1 += 1.6*(b1-b2),N,yt,xt,&aa,&abdevt);
            else
                f2 = rofunc(b2 += 1.6*(b2-b1),N,yt,xt,&aa,&abdevt);
        }
        
        sigb = 0.000001 * sigb; // refine
        while (fabs(b2 - b1) > sigb) {
            bb = b1 + 0.5 * (b2 - b1);
            if (bb == b1 || bb == b2) break;
            f = rofunc(bb, N, yt, xt, &aa, &abdevt);
            if (f*f1 >= 0.0) {
                f1 = f;
                b1 = bb;
            } else {
                f2 = f;
                b2 = bb;
            }
        }
    }
    
    *a = aa;
    *b = bb;
    *abdev = abdevt / N;
}

double mode(const double data[], const int N) {
    // finds and returns the mode of the N points in data
    double * sorted;
    double mode, cur=0;
    int cMode, cCur;
    int i;

    sorted = malloc(N * sizeof(double));

    for (i=0; i<N; i++) sorted[i] = data[i];
    qsort(sorted, N, sizeof(double), compare);
    mode = sorted[0];
    cMode = cCur = 0;
    for (i=0; i<N; i++) {
        if (cCur > cMode) {
            mode = cur;
            cMode = cCur;
        }
        if (sorted[i] == mode) {
            cMode++;
        } else {
            if (sorted[i] == cur) cCur++;
            else {
                cur = sorted[i];
                cCur = 1;
            }
        }
    }
    
    free(sorted);
    return mode;
}

void RemoveDuplicates(int rg[], int * pN) {
    // this removes duplicates from the array passed in and returns it with *pN = #remaining
    // it makes no guarantees about elements after rg[#remaining]
    int *pNewArray;
    int cNew;
    int i;
    
    qsort(rg,*pN,sizeof(int),compareint);
    pNewArray = malloc(sizeof(int) * *pN);
    pNewArray[0] = rg[0];
    cNew = 1;
    for (i=1; i<*pN; i++) {
        if (rg[i] != pNewArray[cNew - 1]) {
            pNewArray[cNew++] = rg[i];
        }
    }
    *pN = cNew;
    for (i=0; i<cNew; i++)
        rg[i] = pNewArray[i];
}

void RemoveDuplicatesI64(INT64 rg[], int * pN) {
    // this removes duplicates from the array passed in and returns it with *pN = #remaining
    // it makes no guarantees about elements after rg[#remaining]
    INT64 *pNewArray;
    int cNew;
    int i;
    
    qsort(rg,*pN,sizeof(INT64),compareI64);
    pNewArray = malloc(sizeof(INT64) * *pN);
    pNewArray[0] = rg[0];
    cNew = 1;
    for (i=1; i<*pN; i++) {
        if (rg[i] != pNewArray[cNew - 1]) {
            pNewArray[cNew++] = rg[i];
        }
    }
    *pN = cNew;
    for (i=0; i<cNew; i++)
        rg[i] = pNewArray[i];
}

void PrintFlowspec(LPFLOWSPEC lpfs) {
    printf("TokenRate:          %lu bytes/sec\n",lpfs->TokenRate);
    printf("TokenBucketSize:    %lu bytes\n",lpfs->TokenBucketSize);
    printf("PeakBandwidth:      %lu bytes/sec\n",lpfs->PeakBandwidth);
    printf("Latency:            %lu microseconds\n",lpfs->Latency);
    printf("DelayVariation:     %lu microseconds\n",lpfs->DelayVariation);
    printf("ServiceType:        %X\n",lpfs->ServiceType);
    printf("MaxSduSize:         %lu bytes\n",lpfs->MaxSduSize);
    printf("MinimumPolicedSize: %lu bytes\n",lpfs->MinimumPolicedSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\usb8023.inf: $(_INX)\usb8023.inx $(_LNG)\usb8023.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\inc\rndisioc.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDISIOC.H

Abstract:

    Header file for controlling the RNDIS Miniport driver.

Environment:

    User/Kernel mode

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    10/19/99:  created

Author:

    ArvindM


****************************************************************************/

#ifndef _RNDISIOC__H
#define _RNDISIOC__H


#define OID_RNDISMP_STATISTICS      0xFFA0C90A
#ifdef BINARY_MOF_TEST
#define OID_RNDISMP_DEVICE_OID      0xFFA0C90B
#define OID_RNDISMP_GET_MOF_OID     0xFFA0C90C
#endif // BINARY_MOF_TEST

typedef struct _RNDISMP_ADAPTER_STATS
{
    ULONG                       XmitToMicroport;
    ULONG                       XmitOk;
    ULONG                       XmitError;
    ULONG                       SendMsgLowRes;
    ULONG                       RecvOk;
    ULONG                       RecvError;
    ULONG                       RecvNoBuf; 
    ULONG                       RecvLowRes;
    ULONG                       Resets;
    ULONG                       KeepAliveTimeout;
    ULONG                       MicroportSendError;
} RNDISMP_ADAPTER_STATS, *PRNDISMP_ADAPTER_STATS;


typedef struct _RNDISMP_ADAPTER_INFO
{
    RNDISMP_ADAPTER_STATS       Statistics;
    ULONG                       HiWatPendedMessages;
    ULONG                       LoWatPendedMessages;
    ULONG                       CurPendedMessages;
} RNDISMP_ADAPTER_INFO, *PRNDISMP_ADAPTER_INFO;

#endif // _RNDISIOC__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\inc\rndisapi.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDISAPI.H

Abstract:

    This module defines the Remote NDIS Wrapper API set.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2/8/99 : created

Authors:

    Arvind Murching and Tom Green

    
****************************************************************************/



#ifndef _RNDISAPI_H_
#define _RNDISAPI_H_


#define RNDIS_VERSION                       0x00010000


//
//  RNDIS Microport Channel type definitions.
//
typedef enum _RM_CHANNEL_TYPE
{
    RMC_DATA,   // for NDIS Packet messages
    RMC_CONTROL // all other messages (Init/Query/Set)

} RM_CHANNEL_TYPE, *PRM_CHANNEL_TYPE;


//
//  RNDIS Microport handler templates:
//
typedef
NDIS_STATUS
(*RM_DEVICE_INIT_HANDLER)(
    OUT   PNDIS_HANDLE                      pMicroportAdapterContext,
    OUT   PULONG                            pMaxReceiveSize,
    IN    NDIS_HANDLE                       MiniportAdapterContext,
    IN    NDIS_HANDLE                       NdisMiniportHandle,
    IN    NDIS_HANDLE                       WrapperConfigurationContext,
	IN    PDEVICE_OBJECT					Pdo
    );

typedef
NDIS_STATUS
(*RM_DEVICE_INIT_CMPLT_NOTIFY_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext,
    IN    ULONG                             DeviceFlags,
    IN OUT PULONG                           pMaxTransferSize
    );

typedef
VOID
(*RM_DEVICE_HALT_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext
    );

typedef
VOID
(*RM_SHUTDOWN_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext
    );

typedef
VOID
(*RM_UNLOAD_HANDLER)(
    IN    NDIS_HANDLE                       MicroportContext
    );

typedef
VOID
(*RM_SEND_MESSAGE_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext,
    IN    PMDL                              pMessageHead,
    IN    NDIS_HANDLE                       RndisMessageHandle,
    IN    RM_CHANNEL_TYPE                   ChannelType
    );

typedef
VOID
(*RM_RETURN_MESSAGE_HANDLER)(
    IN    NDIS_HANDLE                       MicroportAdapterContext,
    IN    PMDL                              pMessageHead,
    IN    NDIS_HANDLE                       MicroportMessageContext
    );


typedef struct _RNDIS_MICROPORT_CHARACTERISTICS
{
    ULONG                                   RndisVersion;           // RNDIS_VERSION
    ULONG                                   Reserved;               // Should be 0
    RM_DEVICE_INIT_HANDLER                  RmInitializeHandler;
    RM_DEVICE_INIT_CMPLT_NOTIFY_HANDLER     RmInitCompleteNotifyHandler;
    RM_DEVICE_HALT_HANDLER                  RmHaltHandler;
    RM_SHUTDOWN_HANDLER                     RmShutdownHandler;
    RM_UNLOAD_HANDLER                       RmUnloadHandler;
    RM_SEND_MESSAGE_HANDLER                 RmSendMessageHandler;
    RM_RETURN_MESSAGE_HANDLER               RmReturnMessageHandler;

} RNDIS_MICROPORT_CHARACTERISTICS, *PRNDIS_MICROPORT_CHARACTERISTICS;


//
//  RNDIS APIs
//
#ifndef RNDISMP
DECLSPEC_IMPORT
#endif
NDIS_STATUS
RndisMInitializeWrapper(
    OUT   PNDIS_HANDLE                      pNdisWrapperHandle,
    IN    PVOID                             MicroportContext,
    IN    PVOID                             DriverObject,
    IN    PVOID                             RegistryPath,
    IN    PRNDIS_MICROPORT_CHARACTERISTICS  pCharacteristics
    );

#ifndef RNDISMP
DECLSPEC_IMPORT
#endif
VOID
RndisMSendComplete(
    IN    NDIS_HANDLE                       MiniportAdapterContext,
    IN    NDIS_HANDLE                       RndisMessageHandle,
    IN    NDIS_STATUS                       SendStatus
    );

#ifndef RNDISMP
DECLSPEC_IMPORT
#endif
VOID
RndisMIndicateReceive(
    IN    NDIS_HANDLE                       MiniportAdapterContext,
    IN    PMDL                              pMessageHead,
    IN    NDIS_HANDLE                       MicroportMessageContext,
    IN    RM_CHANNEL_TYPE                   ChannelType,
    IN    NDIS_STATUS                       ReceiveStatus
    );


#endif // _RNDISAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\comini.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    COMINI.C

Abstract:

    CO-NDIS Miniport driver entry points for the Remote NDIS miniport.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    12/16/99:   Created

Author:

    ArvindM

    
****************************************************************************/

#include "precomp.h"



/****************************************************************************/
/*                          RndismpCoCreateVc                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to create a VC. We allocate a local VC structure, and send  */
/*  off a CreateVc message to the device.                                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - pointer to our adapter structure               */
/*  NdisVcHandle - the NDIS wrapper's handle for this VC                    */
/*  pMiniportVcContext - place to return our context for this VC            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoCreateVc(IN  NDIS_HANDLE    MiniportAdapterContext,
                  IN  NDIS_HANDLE    NdisVcHandle,
                  OUT PNDIS_HANDLE   pMiniportVcContext)
{
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_VC             pVc;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    NDIS_STATUS             Status;
    ULONG                   RefCount = 0;

    pVc = NULL;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    do
    {
        if (pAdapter->Halting)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        pVc = AllocateVc(pAdapter);
        if (pVc == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        RNDISMP_REF_VC(pVc);    // Creation ref

        //
        //  Prepare a CreateVc message to send to the device.
        //
        pMsgFrame = BuildRndisMessageCoMiniport(pAdapter,
                                                pVc,
                                                REMOTE_CONDIS_MP_CREATE_VC_MSG,
                                                NULL);
        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pVc->VcState = RNDISMP_VC_CREATING;

        RNDISMP_REF_VC(pVc);    // Pending CreateVc response

        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendCoCreateVc);

    }
    while (FALSE);

    //
    //  Clean up if failure.
    //
    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pVc != NULL)
        {
            RNDISMP_DEREF_VC(pVc, &RefCount);  // Creation ref

            ASSERT(RefCount == 0); // the Vc should be dealloc'ed above.
        }
    }

    return (Status);
}

/****************************************************************************/
/*                          CompleteSendCoCreateVc                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine called when microport completes sending a CreateVc     */
/*  message to the device.                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame                                    */
/*  SendStatus - status of the microport send.                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendCoCreateVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                       IN NDIS_STATUS               SendStatus)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pTmpMsgFrame;
    ULONG                   RefCount = 0;

    if (SendStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  The message was sent successfully. Do nothing until
        //  we get a response from the device.
        //
    }
    else
    {
        pVc = pMsgFrame->pVc;
        pAdapter = pVc->pAdapter;

        TRACE1(("CompleteSendCoCreateVc: VC %x, Adapter %x, fail status %x\n",
                pVc, pAdapter, SendStatus));

        //
        //  Failed to send it to the device. Remove this message from
        //  the pending list and free it.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pTmpMsgFrame, pAdapter, pMsgFrame->RequestId);
        ASSERT(pMsgFrame == pTmpMsgFrame);
        DereferenceMsgFrame(pMsgFrame);

        HandleCoCreateVcFailure(pVc, SendStatus);
    }

} // CompleteSendCoCreateVc


/****************************************************************************/
/*                          HandleCoCreateVcFailure                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to handle failure of a CreateVc, either due to a local  */
/*  microport send failure, or via explicit rejection by the device.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC on which this failure has occurred                  */
/*  Status - NDIS status associated with this failure                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
HandleCoCreateVcFailure(IN PRNDISMP_VC      pVc,
                        IN NDIS_STATUS      Status)
{
    NDIS_HANDLE         NdisVcHandle;
    BOOLEAN             bFailActivateVc = FALSE;
    PCO_CALL_PARAMETERS pCallParameters;
    ULONG               RefCount = 0;
   
    RNDISMP_ACQUIRE_VC_LOCK(pVc);

    NdisVcHandle = pVc->NdisVcHandle;

    switch (pVc->VcState)
    {
        case RNDISMP_VC_CREATING:
            pVc->VcState = RNDISMP_VC_CREATE_FAILURE;
            break;
        
        case RNDISMP_VC_CREATING_DELETE_PENDING:
            pVc->VcState = RNDISMP_VC_ALLOCATED;
            break;

        case RNDISMP_VC_CREATING_ACTIVATE_PENDING:
            bFailActivateVc = TRUE;
            pCallParameters = pVc->pCallParameters;
            pVc->VcState = RNDISMP_VC_CREATE_FAILURE;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount);    // Pending CreateVc response

    if (RefCount != 0)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    if (bFailActivateVc)
    {
        NdisMCoActivateVcComplete(Status,
                                  NdisVcHandle,
                                  pCallParameters);
    }

} // HandleCoCreateVcFailure


/****************************************************************************/
/*                          RndismpCoDeleteVc                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to delete a VC. We send a DeleteVc message to the device.   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportVcContext - pointer to our VC structure                         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoDeleteVc(IN NDIS_HANDLE    MiniportVcContext)
{
    PRNDISMP_VC             pVc;
    NDIS_STATUS             Status;

    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);

    Status = StartVcDeletion(pVc);
    return (Status);

} // RndismpCoDeleteVc


/****************************************************************************/
/*                          StartVcDeletion                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Initiate a DeleteVc operation on the specified VC.                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC structure                                           */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
StartVcDeletion(IN PRNDISMP_VC      pVc)
{
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    NDIS_STATUS             Status;
    ULONG                   RefCount = 0;
    BOOLEAN                 bSendDeleteVc;

    pAdapter = pVc->pAdapter;

    bSendDeleteVc = FALSE;
    pMsgFrame = NULL;

    do
    {
        //
        //  Prepare a DeleteVc message to send to the device.
        //
        pMsgFrame = BuildRndisMessageCoMiniport(pAdapter,
                                                pVc,
                                                REMOTE_CONDIS_MP_DELETE_VC_MSG,
                                                NULL);

        Status = NDIS_STATUS_SUCCESS;

        TRACE2(("StartVcDeletion: VC %x, state %d, Msg %x\n", pVc, pVc->VcState, pMsgFrame));

        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        switch (pVc->VcState)
        {
            case RNDISMP_VC_CREATED:
                if (pMsgFrame != NULL)
                {
                    pVc->VcState = RNDISMP_VC_DELETING;
                    bSendDeleteVc = TRUE;
                }
                else
                {
                    Status = NDIS_STATUS_RESOURCES;
                    bSendDeleteVc = FALSE;
                }
                break;

            case RNDISMP_VC_CREATING:
                bSendDeleteVc = FALSE;
                pVc->VcState = RNDISMP_VC_CREATING_DELETE_PENDING;
                break;
            
            case RNDISMP_VC_CREATE_FAILURE:
                bSendDeleteVc = FALSE;
                pVc->VcState = RNDISMP_VC_ALLOCATED;
                break;
            
            default:
                bSendDeleteVc = FALSE;
                Status = NDIS_STATUS_NOT_ACCEPTED;
                break;
        }

        RNDISMP_RELEASE_VC_LOCK(pVc);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        if (bSendDeleteVc)
        {
            ASSERT(pMsgFrame != NULL);
            RNDISMP_REF_VC(pVc);    // pending DeleteVc message

            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendCoDeleteVc);
        }

        RNDISMP_DEREF_VC(pVc, &RefCount); // successful DeleteVc

    }
    while (FALSE);

    if (!bSendDeleteVc)
    {
        if (pMsgFrame != NULL)
        {
            DereferenceMsgFrame(pMsgFrame);
        }
    }

    return (Status);

} // StartVcDeletion


/****************************************************************************/
/*                          CompleteSendCoDeleteVc                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine called when microport completes sending a DeleteVc     */
/*  message to the device.                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame                                    */
/*  SendStatus - status of the microport send.                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendCoDeleteVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                       IN NDIS_STATUS               SendStatus)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pTmpMsgFrame;

    if (SendStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  The message was sent successfully. Do nothing until
        //  we get a response from the device.
        //
    }
    else
    {
        pVc = pMsgFrame->pVc;
        pAdapter = pVc->pAdapter;

        TRACE1(("CompleteSendCoDeleteVc: VC %x, Adapter %x, fail status %x\n",
                pVc, pAdapter, SendStatus));

        //
        //  Failed to send it to the device. Remove this message from
        //  the pending list and free it.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pTmpMsgFrame, pAdapter, pMsgFrame->RequestId);
        ASSERT(pMsgFrame == pTmpMsgFrame);
        DereferenceMsgFrame(pMsgFrame);

        //
        //  Take care of the VC now.
        //
        HandleCoDeleteVcFailure(pVc, SendStatus);
    }

} // CompleteSendCoDeleteVc


/****************************************************************************/
/*                          HandleCoDeleteVcFailure                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to handle failure of a DeleteVc, either due to a local  */
/*  microport send failure, or via explicit rejection by the device.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC on which this failure has occurred                  */
/*  Status - NDIS status associated with this failure                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
HandleCoDeleteVcFailure(IN PRNDISMP_VC      pVc,
                        IN NDIS_STATUS      Status)
{
    ULONG       RefCount = 0;

    RNDISMP_ACQUIRE_VC_LOCK(pVc);

    switch (pVc->VcState)
    {
        case RNDISMP_VC_DELETING:
            pVc->VcState = RNDISMP_VC_DELETE_FAIL;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount);    // Pending DeleteVc response

    if (RefCount != 0)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

} // HandleCoDeleteVcFailure


/****************************************************************************/
/*                          RndismpCoActivateVc                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to activate a VC. We send an ActivateVc message to the      */
/*  device.                                                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportVcContext - pointer to our VC structure                         */
/*  pCallParameters - CONDIS parameters for the VC                          */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoActivateVc(IN NDIS_HANDLE          MiniportVcContext,
                    IN PCO_CALL_PARAMETERS  pCallParameters)
{
    PRNDISMP_VC             pVc;
    NDIS_STATUS             Status;

    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);

    pVc->pCallParameters = pCallParameters;
    Status = StartVcActivation(pVc);

    return (Status);

} // RndismpCoActivateVc


/****************************************************************************/
/*                          StartVcActivation                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Start an Activate-VC operation on the specified VC.                     */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC structure                                           */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
StartVcActivation(IN PRNDISMP_VC            pVc)
{
    NDIS_STATUS             Status;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    PRNDISMP_ADAPTER        pAdapter;
    BOOLEAN                 bSendActivateVc;
    NDIS_HANDLE             NdisVcHandle;
    PCO_CALL_PARAMETERS     pCallParameters;

    Status = NDIS_STATUS_PENDING;
    bSendActivateVc = FALSE;

    NdisVcHandle = pVc->NdisVcHandle;
    pCallParameters = pVc->pCallParameters;
    pAdapter = pVc->pAdapter;

    do
    {
        //
        //  Prepare an ActivateVc message to send to the device.
        //
        pMsgFrame = BuildRndisMessageCoMiniport(pAdapter,
                                                pVc,
                                                REMOTE_CONDIS_MP_ACTIVATE_VC_MSG,
                                                pCallParameters);

        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        switch (pVc->VcState)
        {
            case RNDISMP_VC_CREATING:

                pVc->VcState = RNDISMP_VC_CREATING_ACTIVATE_PENDING;
                break;

            case RNDISMP_VC_CREATED:

                if (pMsgFrame != NULL)
                {
                    pVc->VcState = RNDISMP_VC_ACTIVATING;
                    bSendActivateVc = TRUE;
                }
                else
                {
                    TRACE1(("StartVcAct: VC %x, failed to build msg!\n", pVc));
                    Status = NDIS_STATUS_RESOURCES;
                }
                break;

            default:

                TRACE1(("StartVcAct: VC %x in invalid state %d\n", pVc, pVc->VcState));
                Status = NDIS_STATUS_NOT_ACCEPTED;
                break;
        }

        RNDISMP_RELEASE_VC_LOCK(pVc);

        if (Status != NDIS_STATUS_PENDING)
        {
            break;
        }

        if (bSendActivateVc)
        {
            ASSERT(pMsgFrame != NULL);
            RNDISMP_REF_VC(pVc);    // pending ActivateVc message

            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendCoActivateVc);
        }
    }
    while (FALSE);

    if (!bSendActivateVc)
    {
        if (pMsgFrame != NULL)
        {
            DereferenceMsgFrame(pMsgFrame);
        }
    }

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisMCoActivateVcComplete(
            Status,
            NdisVcHandle,
            pCallParameters);
        
        Status = NDIS_STATUS_PENDING;
    }

    return (Status);

} // StartVcActivation


/****************************************************************************/
/*                          CompleteSendCoActivateVc                        */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine to handle send-completion of an Activate VC message.   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame                                    */
/*  SendStatus - status of the microport send.                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendCoActivateVc(IN PRNDISMP_MESSAGE_FRAME      pMsgFrame,
                         IN NDIS_STATUS                 SendStatus)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pTmpMsgFrame;
    PCO_CALL_PARAMETERS     pCallParameters;
    ULONG                   RefCount = 0;
    NDIS_HANDLE             NdisVcHandle;

    if (SendStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  The message was sent successfully. Do nothing until
        //  we get a response from the device.
        //
    }
    else
    {
        pVc = pMsgFrame->pVc;
        pAdapter = pVc->pAdapter;

        TRACE1(("CompleteSendCoActivateVc: VC %x, Adapter %x, fail status %x\n",
                pVc, pAdapter, SendStatus));

        ASSERT(SendStatus != NDIS_STATUS_PENDING);

        //
        //  Failed to send it to the device. Remove this message from
        //  the pending list and free it.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pTmpMsgFrame, pAdapter, pMsgFrame->RequestId);
        ASSERT(pMsgFrame == pTmpMsgFrame);
        DereferenceMsgFrame(pMsgFrame);

        //
        //  Take care of the VC now.
        //
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        NdisVcHandle = pVc->NdisVcHandle;
        pCallParameters = pVc->pCallParameters;

        pVc->VcState = RNDISMP_VC_CREATED;

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending ActivateVc

        if (RefCount != 0)
        {
            RNDISMP_RELEASE_VC_LOCK(pVc);
        }

        NdisMCoActivateVcComplete(
            SendStatus,
            NdisVcHandle,
            pCallParameters);
        
    }

} // CompleteSendCoActivateVc


/****************************************************************************/
/*                        RndismpCoDeactivateVc                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to de-activate a VC. We send an DeactivateVc message to the */
/*  device.                                                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportVcContext - pointer to our VC structure                         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoDeactivateVc(IN NDIS_HANDLE          MiniportVcContext)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    NDIS_STATUS             Status;
    NDIS_HANDLE             NdisVcHandle;
    BOOLEAN                 bVcLockAcquired = FALSE;
    BOOLEAN                 bSendDeactivateVc = FALSE;

    pMsgFrame = NULL;
    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);
    pAdapter = pVc->pAdapter;
    Status = NDIS_STATUS_PENDING;

    do
    {
        //
        //  Prepare a DeactivateVc message to send to the device.
        //
        pMsgFrame = BuildRndisMessageCoMiniport(pAdapter,
                                                pVc,
                                                REMOTE_CONDIS_MP_DEACTIVATE_VC_MSG,
                                                NULL);

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        NdisVcHandle = pVc->NdisVcHandle;

        if (pVc->VcState != RNDISMP_VC_ACTIVATED)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        switch (pVc->VcState)
        {
            case RNDISMP_VC_ACTIVATED:

                if (pMsgFrame != NULL)
                {
                    bSendDeactivateVc = TRUE;
                    pVc->VcState = RNDISMP_VC_DEACTIVATING;
                }
                else
                {
                    bSendDeactivateVc = FALSE;
                    Status = NDIS_STATUS_RESOURCES;
                }
                break;

            default:

                bSendDeactivateVc = FALSE;
                break;
         }

         if (bSendDeactivateVc)
         {
            RNDISMP_REF_VC(pVc);    // pending Deactivate VC

            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendCoDeactivateVc);
        }
    }
    while (FALSE);


    if (!bSendDeactivateVc)
    {
        if (pMsgFrame != NULL)
        {
            DereferenceMsgFrame(pMsgFrame);
        }
    }

    if (Status != NDIS_STATUS_PENDING)
    {
        ASSERT(Status != NDIS_STATUS_SUCCESS);
        NdisMCoDeactivateVcComplete(
            Status,
            NdisVcHandle);
        
        Status = NDIS_STATUS_PENDING;
    }

    return (Status);
}

/****************************************************************************/
/*                          CompleteSendCoDeactivateVc                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine to handle send-completion of a deactivate VC message.  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame                                    */
/*  SendStatus - status of the microport send.                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendCoDeactivateVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                           IN NDIS_STATUS               SendStatus)
{
    PRNDISMP_VC             pVc;
    PRNDISMP_ADAPTER        pAdapter;
    PRNDISMP_MESSAGE_FRAME  pTmpMsgFrame;
    PCO_CALL_PARAMETERS     pCallParameters;
    ULONG                   RefCount = 0;
    NDIS_HANDLE             NdisVcHandle;

    if (SendStatus == NDIS_STATUS_SUCCESS)
    {
        //
        //  The message was sent successfully. Do nothing until
        //  we get a response from the device.
        //
    }
    else
    {
        pVc = pMsgFrame->pVc;
        pAdapter = pVc->pAdapter;

        TRACE1(("CompleteSendCoDeactivateVc: VC %x, Adapter %x, fail status %x\n",
                pVc, pAdapter, SendStatus));

        ASSERT(SendStatus != NDIS_STATUS_PENDING);

        //
        //  Failed to send it to the device. Remove this message from
        //  the pending list and free it.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pTmpMsgFrame, pAdapter, pMsgFrame->RequestId);
        ASSERT(pMsgFrame == pTmpMsgFrame);
        DereferenceMsgFrame(pMsgFrame);

        //
        //  Take care of the VC now.
        //
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        NdisVcHandle = pVc->NdisVcHandle;
        pCallParameters = pVc->pCallParameters;

        pVc->VcState = RNDISMP_VC_ACTIVATED;

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending DeactivateVc

        if (RefCount != 0)
        {
            RNDISMP_RELEASE_VC_LOCK(pVc);
        }

        NdisMCoDeactivateVcComplete(
            SendStatus,
            NdisVcHandle);
        
    }

} // CompleteSendCoDeactivateVc


/****************************************************************************/
/*                          RndismpCoRequest                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to handle a CO-request. We send a MiniportCoRequest message */
/*  to the device.                                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - pointer to our adapter structure               */
/*  MiniportVcContext - pointer to our VC structure                         */
/*  pRequest - Pointer to NDIS request                                      */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpCoRequest(IN NDIS_HANDLE          MiniportAdapterContext,
                 IN NDIS_HANDLE          MiniportVcContext,
                 IN OUT PNDIS_REQUEST    pRequest)
{
    PRNDISMP_ADAPTER    pAdapter;
    PRNDISMP_VC         pVc;
    NDIS_STATUS         Status;
    NDIS_OID            Oid;

    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);
    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);

    switch (pRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        case NdisRequestQueryStatistics:

            Oid = pRequest->DATA.QUERY_INFORMATION.Oid;

            TRACE2(("CoReq: Adapter %x, Req %x, QueryInfo/Stat (%d) Oid %x\n",
                pAdapter, pRequest, pRequest->RequestType, Oid));

            Status = ProcessQueryInformation(pAdapter,
                                             pVc,
                                             pRequest,
                                             Oid,
                                             pRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                                             pRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                                             &pRequest->DATA.QUERY_INFORMATION.BytesWritten,
                                             &pRequest->DATA.QUERY_INFORMATION.BytesNeeded);
            break;
        
        case NdisRequestSetInformation:

            Oid = pRequest->DATA.SET_INFORMATION.Oid;

            TRACE1(("CoReq: Adapter %x, Req %x, SetInfo Oid %x\n",
                 pAdapter, pRequest, Oid));

            Status = ProcessSetInformation(pAdapter,
                                           pVc,
                                           pRequest,
                                           Oid,
                                           pRequest->DATA.SET_INFORMATION.InformationBuffer,
                                           pRequest->DATA.SET_INFORMATION.InformationBufferLength,
                                           &pRequest->DATA.SET_INFORMATION.BytesRead,
                                           &pRequest->DATA.SET_INFORMATION.BytesNeeded);
            break;
        
        default:
            TRACE1(("CoReq: Unsupported request type %d\n",
                        pRequest->RequestType));
                
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    return (Status);
}

/****************************************************************************/
/*                          RndismpCoSendPackets                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point to send one or more packets on a VC.                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportVcContext - pointer to our VC structure                         */
/*  PacketArray - Array of packet pointers                                  */
/*  NumberOfPackets - number of packets in array above                      */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
RndismpCoSendPackets(IN NDIS_HANDLE          MiniportVcContext,
                     IN PNDIS_PACKET *       PacketArray,
                     IN UINT                 NumberOfPackets)
{
    PRNDISMP_VC         pVc;
    UINT                i;

    pVc = PRNDISMP_VC_FROM_CONTEXT_HANDLE(MiniportVcContext);

    RNDISMP_ACQUIRE_VC_LOCK(pVc);

    pVc->RefCount += NumberOfPackets;

    if (pVc->VcState == RNDISMP_VC_ACTIVATED)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);

        DoMultipleSend(pVc->pAdapter,
                       pVc,
                       PacketArray,
                       NumberOfPackets);
    }
    else
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);

        for (i = 0; i < NumberOfPackets; i++)
        {
            CompleteSendDataOnVc(pVc, PacketArray[i], NDIS_STATUS_VC_NOT_ACTIVATED);
        }
    }

} // RndismpCoSendPackets

/****************************************************************************/
/*                          ReceiveCreateVcComplete                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a CONDIS CreateVcComplete message from the device               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceiveCreateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied)
{
    BOOLEAN                         bDiscardPkt = TRUE;
    PRNDISMP_VC                     pVc;
    PRNDISMP_MESSAGE_FRAME          pCreateVcMsgFrame;
    PRCONDIS_MP_CREATE_VC_COMPLETE  pCreateVcComp;
    RNDISMP_VC_STATE                VcState;
    BOOLEAN                         bVcLockAcquired = FALSE;
    ULONG                           RefCount = 0;
    NDIS_STATUS                     Status;

    pVc = NULL;

    do
    {
        pCreateVcComp = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        //
        //  TBD - Validate lengths?
        //

        //
        //  Check the request Id.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pCreateVcMsgFrame, pAdapter, pCreateVcComp->RequestId);
        if (pCreateVcMsgFrame == NULL)
        {
            TRACE1(("CreateVcComp: Adapter %x, Invalid ReqId %d!\n",
                    pAdapter, pCreateVcComp->RequestId));
            break;
        }

        pVc = pCreateVcMsgFrame->pVc;
        Status = pCreateVcComp->Status;

        DereferenceMsgFrame(pCreateVcMsgFrame);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            HandleCoCreateVcFailure(pVc, Status);
            break;
        }

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending CreateVc

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
            break;
        }

        pVc->DeviceVcContext = pCreateVcComp->DeviceVcHandle;

        VcState = pVc->VcState;

        switch (VcState)
        {
            case RNDISMP_VC_CREATING:

                pVc->VcState = RNDISMP_VC_CREATED;
                break;
            
            case RNDISMP_VC_CREATING_ACTIVATE_PENDING:

                pVc->VcState = RNDISMP_VC_CREATED;
                RNDISMP_RELEASE_VC_LOCK(pVc);
                bVcLockAcquired = FALSE;

                Status = StartVcActivation(pVc);
                ASSERT(Status == NDIS_STATUS_PENDING);
                break;

            case RNDISMP_VC_CREATING_DELETE_PENDING:

                pVc->VcState = RNDISMP_VC_CREATED;
                RNDISMP_RELEASE_VC_LOCK(pVc);
                bVcLockAcquired = FALSE;

                Status = StartVcDeletion(pVc);
                break;
                
            default:

                TRACE1(("CreateVcComp: VC %x, wrong state %d\n",
                        pVc, VcState));
                break;
        }

    }
    while (FALSE);

    if (bVcLockAcquired)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                        ReceiveActivateVcComplete                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a CONDIS ActivateVcComplete message from the device             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceiveActivateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                          IN PRNDIS_MESSAGE      pMessage,
                          IN PMDL                pMdl,
                          IN ULONG               TotalLength,
                          IN NDIS_HANDLE         MicroportMessageContext,
                          IN NDIS_STATUS         ReceiveStatus,
                          IN BOOLEAN             bMessageCopied)
{
    BOOLEAN                         bDiscardPkt = TRUE;
    PRNDISMP_VC                     pVc;
    PRNDISMP_MESSAGE_FRAME          pActVcMsgFrame;
    PRCONDIS_MP_ACTIVATE_VC_COMPLETE        pActVcComp;
    BOOLEAN                         bVcLockAcquired = FALSE;
    ULONG                           RefCount = 0;
    NDIS_STATUS                     Status;
    NDIS_HANDLE                     NdisVcHandle;
    PCO_CALL_PARAMETERS             pCallParameters;

    pVc = NULL;

    do
    {
        pActVcComp = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        //
        //  TBD - Validate lengths?
        //

        //
        //  Check the request Id.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pActVcMsgFrame, pAdapter, pActVcComp->RequestId);
        if (pActVcMsgFrame == NULL)
        {
            TRACE1(("ActVcComp: Adapter %x, Invalid ReqId %d!\n",
                    pAdapter, pActVcComp->RequestId));
            break;
        }

        pVc = pActVcMsgFrame->pVc;

        DereferenceMsgFrame(pActVcMsgFrame);

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending ActivateVc

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
            break;
        }

        if (pVc->VcState != RNDISMP_VC_ACTIVATING)
        {
            TRACE1(("ActVcComp: Adapter %x, VC %x: invalid state %d\n",
                    pAdapter, pVc, pVc->VcState));
            break;
        }

        Status = pActVcComp->Status;

        if (Status == NDIS_STATUS_SUCCESS)
        {
            pVc->VcState = RNDISMP_VC_ACTIVATED;
        }
        else
        {
            pVc->VcState = RNDISMP_VC_CREATED;
        }
            
        NdisVcHandle = pVc->NdisVcHandle;
        pCallParameters = pVc->pCallParameters;
        
        RNDISMP_RELEASE_VC_LOCK(pVc);
        bVcLockAcquired = FALSE;

        NdisMCoActivateVcComplete(
            pActVcComp->Status,
            NdisVcHandle,
            pCallParameters);

    }
    while (FALSE);

    if (bVcLockAcquired)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                        ReceiveDeleteVcComplete                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a CONDIS DeleteVcComplete message from the device               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceiveDeleteVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied)
{
    BOOLEAN                         bDiscardPkt = TRUE;
    PRNDISMP_VC                     pVc;
    PRCONDIS_MP_DELETE_VC_COMPLETE  pDeleteVcComp;
    PRNDISMP_MESSAGE_FRAME          pDeleteVcMsgFrame;
    RNDISMP_VC_STATE                VcState;
    BOOLEAN                         bVcLockAcquired = FALSE;
    ULONG                           RefCount = 0;
    NDIS_STATUS                     Status;

    pVc = NULL;

    do
    {
        pDeleteVcComp = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        //
        //  TBD - Validate lengths?
        //

        //
        //  Check the request Id.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pDeleteVcMsgFrame, pAdapter, pDeleteVcComp->RequestId);
        if (pDeleteVcMsgFrame == NULL)
        {
            TRACE1(("DeleteVcComp: Adapter %x, Invalid ReqId %d!\n",
                    pAdapter, pDeleteVcComp->RequestId));
            break;
        }

        pVc = pDeleteVcMsgFrame->pVc;
        Status = pDeleteVcComp->Status;

        DereferenceMsgFrame(pDeleteVcMsgFrame);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            HandleCoDeleteVcFailure(pVc, Status);
            break;
        }

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending DeleteVc

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
            break;
        }

        if (pVc->VcState != RNDISMP_VC_DELETING)
        {
            TRACE1(("DeleteVcComp: Adapter %x, VC %x: invalid state %d\n",
                    pAdapter, pVc, pVc->VcState));
            break;
        }

        pVc->VcState = RNDISMP_VC_ALLOCATED;

        RNDISMP_DEREF_VC(pVc, &RefCount);   // remove create ref

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
        }
    }
    while (FALSE);

    if (bVcLockAcquired)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                        ReceiveDeactivateVcComplete                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a CONDIS DeActivateVcComplete message from the device           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceiveDeactivateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                            IN PRNDIS_MESSAGE      pMessage,
                            IN PMDL                pMdl,
                            IN ULONG               TotalLength,
                            IN NDIS_HANDLE         MicroportMessageContext,
                            IN NDIS_STATUS         ReceiveStatus,
                            IN BOOLEAN             bMessageCopied)
{
    BOOLEAN                         bDiscardPkt = TRUE;
    PRNDISMP_VC                     pVc;
    RNDISMP_VC_STATE                VcState;
    PRNDISMP_MESSAGE_FRAME          pDeactivateVcMsgFrame;
    PRCONDIS_MP_DEACTIVATE_VC_COMPLETE  pDeactivateVcComp;
    BOOLEAN                         bVcLockAcquired = FALSE;
    BOOLEAN                         bAddTempRef = FALSE;
    ULONG                           RefCount = 0;
    NDIS_STATUS                     Status;

    pVc = NULL;

    do
    {
        pDeactivateVcComp = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        //
        //  TBD - Validate lengths?
        //

        //
        //  Check the request Id.
        //
        RNDISMP_LOOKUP_PENDING_MESSAGE(pDeactivateVcMsgFrame, pAdapter, pDeactivateVcComp->RequestId);
        if (pDeactivateVcMsgFrame == NULL)
        {
            TRACE1(("DeactivateVcComp: Adapter %x, Invalid ReqId %d!\n",
                    pAdapter, pDeactivateVcComp->RequestId));
            break;
        }

        pVc = pDeactivateVcMsgFrame->pVc;

        DereferenceMsgFrame(pDeactivateVcMsgFrame);

        bVcLockAcquired = TRUE;
        RNDISMP_ACQUIRE_VC_LOCK(pVc);

        RNDISMP_DEREF_VC_LOCKED(pVc, &RefCount); // pending DeactivateVc

        if (RefCount == 0)
        {
            bVcLockAcquired = FALSE;
            break;
        }

        if (pVc->VcState != RNDISMP_VC_DEACTIVATING)
        {
            TRACE1(("DeactVcComp: Adapter %x, VC %x: invalid state %d\n",
                    pAdapter, pVc, pVc->VcState));
            ASSERT(FALSE);
            break;
        }

        if (pDeactivateVcComp->Status == NDIS_STATUS_SUCCESS)
        {
            pVc->VcState = RNDISMP_VC_DEACTIVATED;

            //
            //  We add a temp ref on the VC to help complete deactivate-VC
            //  from a common place (see bAddTempRef below).
            //
            RNDISMP_REF_VC(pVc);    // temp ref, deactivate vc complete OK
            bAddTempRef = TRUE;
        }
        else
        {
            pVc->VcState = RNDISMP_VC_ACTIVATED;
        }

        RNDISMP_RELEASE_VC_LOCK(pVc);
        bVcLockAcquired = FALSE;

        if (bAddTempRef)
        {
            //
            //  The following deref will check and call NDIS'
            //  deactivate vc complete API if we don't have any
            //  outstanding sends or receives on this VC.
            //
            RNDISMP_DEREF_VC(pVc, &RefCount); // temp ref
        }
    }
    while (FALSE);

    if (bVcLockAcquired)
    {
        RNDISMP_RELEASE_VC_LOCK(pVc);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                          BuildRndisMessageCoMiniport                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate resources for message and frame and build an RNDIS message     */
/*  for sending to a remote CONDIS Miniport device.                         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to adapter structure                                 */
/*  pVc - Pointer to VC structure                                           */
/*  NdisMessageType - RNDIS message type                                    */
/*  pCallParameters - optional pointer to call parameters, applicable to    */
/*       certain message types.                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_MESSAGE_FRAME                                                  */
/*                                                                          */
/****************************************************************************/
PRNDISMP_MESSAGE_FRAME
BuildRndisMessageCoMiniport(IN  PRNDISMP_ADAPTER    pAdapter,
                            IN  PRNDISMP_VC         pVc,
                            IN  UINT                NdisMessageType,
                            IN  PCO_CALL_PARAMETERS pCallParameters OPTIONAL)
{
    PRNDIS_MESSAGE          pMessage;
    UINT                    MessageSize;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;

    switch (NdisMessageType)
    {
        case REMOTE_CONDIS_MP_CREATE_VC_MSG:
        {
            PRCONDIS_MP_CREATE_VC       pCreateVc;

            MessageSize = RNDIS_MESSAGE_SIZE(RCONDIS_MP_CREATE_VC);

            pMsgFrame = AllocateMessageAndFrame(pAdapter, MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pCreateVc = &pMessage->Message.CoMiniportCreateVc;
            pCreateVc->RequestId = pMsgFrame->RequestId;
            pCreateVc->NdisVcHandle = pVc->VcId;

            break;
        }

        case REMOTE_CONDIS_MP_DELETE_VC_MSG:
        {
            PRCONDIS_MP_DELETE_VC       pDeleteVc;

            MessageSize = RNDIS_MESSAGE_SIZE(RCONDIS_MP_DELETE_VC);

            pMsgFrame = AllocateMessageAndFrame(pAdapter, MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pDeleteVc = &pMessage->Message.CoMiniportDeleteVc;
            pDeleteVc->RequestId = pMsgFrame->RequestId;
            pDeleteVc->DeviceVcHandle = pVc->DeviceVcContext;

            break;
        }

        case REMOTE_CONDIS_MP_ACTIVATE_VC_MSG:
        {
            PRCONDIS_MP_ACTIVATE_VC_REQUEST             pActivateVc;
            PRCONDIS_CALL_MANAGER_PARAMETERS    pCallMgrParams;
            PRCONDIS_MEDIA_PARAMETERS           pMediaParams;
            ULONG_PTR                           FillLocation;
            UINT                                FillOffset;

            ASSERT(pCallParameters != NULL);
            MessageSize = RNDIS_MESSAGE_SIZE(RCONDIS_MP_ACTIVATE_VC_REQUEST);

            if (pCallParameters->CallMgrParameters)
            {
                MessageSize += (sizeof(RCONDIS_CALL_MANAGER_PARAMETERS) +
                                pCallParameters->CallMgrParameters->CallMgrSpecific.Length);
            }

            if (pCallParameters->MediaParameters)
            {
                MessageSize += (sizeof(RCONDIS_MEDIA_PARAMETERS) +
                                pCallParameters->MediaParameters->MediaSpecific.Length);
            }

            pMsgFrame = AllocateMessageAndFrame(pAdapter, MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pActivateVc = &pMessage->Message.CoMiniportActivateVc;
            pActivateVc->RequestId = pMsgFrame->RequestId;
            pActivateVc->DeviceVcHandle = pVc->DeviceVcContext;
            pActivateVc->Flags = pCallParameters->Flags;

            FillOffset = RNDIS_MESSAGE_SIZE(RCONDIS_MP_ACTIVATE_VC_REQUEST);
            FillLocation = ((ULONG_PTR)pMessage + FillOffset);

            //
            //  Fill in Media parameters, if present.
            //
            if (pCallParameters->MediaParameters)
            {
                PCO_SPECIFIC_PARAMETERS     pMediaSpecific;

                pMediaSpecific = &pCallParameters->MediaParameters->MediaSpecific;
                pMediaParams = (PRCONDIS_MEDIA_PARAMETERS)FillLocation;
                pActivateVc->MediaParamsOffset = (UINT32)(FillLocation - (ULONG_PTR)pActivateVc);
                pActivateVc->MediaParamsLength = sizeof(RCONDIS_MEDIA_PARAMETERS) +
                                                    pMediaSpecific->Length;
                RNDISMP_MOVE_MEM(pMediaParams,
                                 pCallParameters->MediaParameters,
                                 FIELD_OFFSET(RCONDIS_MEDIA_PARAMETERS, MediaSpecific));

                FillLocation += sizeof(RCONDIS_MEDIA_PARAMETERS);
                FillOffset += sizeof(RCONDIS_MEDIA_PARAMETERS);

                pMediaParams->MediaSpecific.ParameterOffset =
                                 sizeof(RCONDIS_SPECIFIC_PARAMETERS);
                pMediaParams->MediaSpecific.ParameterType =
                                 pMediaSpecific->ParamType;
                pMediaParams->MediaSpecific.ParameterLength =
                                 pMediaSpecific->Length;

                RNDISMP_MOVE_MEM((PVOID)FillLocation,
                                 &pMediaSpecific->Parameters[0],
                                 pMediaSpecific->Length);

                FillLocation += pMediaSpecific->Length;
                FillOffset += pMediaSpecific->Length;
            }
            else
            {
                pActivateVc->MediaParamsOffset = 0;
                pActivateVc->MediaParamsLength = 0;
            }

            //
            //  Fill in Call manager parameters, if present.
            //
            if (pCallParameters->CallMgrParameters)
            {
                PCO_SPECIFIC_PARAMETERS     pCallMgrSpecific;

                pCallMgrSpecific = &pCallParameters->CallMgrParameters->CallMgrSpecific;

                pCallMgrParams = (PRCONDIS_CALL_MANAGER_PARAMETERS)FillLocation;
                pActivateVc->CallMgrParamsOffset = (UINT32)(FillLocation - (ULONG_PTR)pActivateVc);
                pActivateVc->CallMgrParamsLength = sizeof(RCONDIS_CALL_MANAGER_PARAMETERS) +
                                                    pCallMgrSpecific->Length;
                
                RNDISMP_MOVE_MEM(pCallMgrParams,
                                 pCallParameters->CallMgrParameters,
                                 FIELD_OFFSET(RCONDIS_CALL_MANAGER_PARAMETERS, CallMgrSpecific));

                FillLocation += sizeof(RCONDIS_CALL_MANAGER_PARAMETERS);
                FillOffset += sizeof(RCONDIS_CALL_MANAGER_PARAMETERS);
                
                pCallMgrParams->CallMgrSpecific.ParameterOffset =
                                 sizeof(RCONDIS_SPECIFIC_PARAMETERS);
                pCallMgrParams->CallMgrSpecific.ParameterType =
                                 pCallMgrSpecific->ParamType;
                pCallMgrParams->CallMgrSpecific.ParameterLength =
                                 pCallMgrSpecific->Length;
                

                RNDISMP_MOVE_MEM((PVOID)FillLocation,
                                 &pCallMgrSpecific->Parameters[0],
                                 pCallMgrSpecific->Length);

                FillLocation += pCallMgrSpecific->Length;
                FillOffset += pCallMgrSpecific->Length;
            }
            else
            {
                pActivateVc->CallMgrParamsOffset = 0;
                pActivateVc->CallMgrParamsLength = 0;
            }

            break;
        }

        case REMOTE_CONDIS_MP_DEACTIVATE_VC_MSG:
        {
            PRCONDIS_MP_DEACTIVATE_VC_REQUEST       pDeactivateVc;

            MessageSize = RNDIS_MESSAGE_SIZE(RCONDIS_MP_DEACTIVATE_VC_REQUEST);

            pMsgFrame = AllocateMessageAndFrame(pAdapter, MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pDeactivateVc = &pMessage->Message.CoMiniportDeactivateVc;
            pDeactivateVc->RequestId = pMsgFrame->RequestId;
            pDeactivateVc->DeviceVcHandle = pVc->DeviceVcContext;

            break;
        }

        default:

            ASSERT(FALSE);
            pMsgFrame = NULL;
            break;
    }


    return (pMsgFrame);

} // BuildRndisMessageCoMiniport

/****************************************************************************/
/*                          CompleteSendDataOnVc                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Handle send-completion of CONDIS data                                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to Vc                                                     */
/*  pNdisPacket - Packet being completed                                    */
/*  Status - send completion status                                         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendDataOnVc(IN PRNDISMP_VC         pVc,
                     IN PNDIS_PACKET        pNdisPacket,
                     IN NDIS_STATUS         Status)
{
    ULONG   RefCount;

    NdisMCoSendComplete(Status,
                        pVc->NdisVcHandle,
                        pNdisPacket);

    RNDISMP_DEREF_VC(pVc, &RefCount);
}

/****************************************************************************/
/*                   IndicateReceiveDataOnVc                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Handle reception of a bunch of CONDIS packets on a Vc.                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC on which data arrived.                              */
/*  PacketArray - Array of packets                                          */
/*  NumberOfPackets - size of above array                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
IndicateReceiveDataOnVc(IN PRNDISMP_VC         pVc,
                        IN PNDIS_PACKET *      PacketArray,
                        IN UINT                NumberOfPackets)
{
    UINT            i;

    do
    {
        if (pVc->VcState != RNDISMP_VC_ACTIVATED)
        {
            TRACE1(("Rcv VC data: VC %x, invalid state %d\n", pVc, pVc->VcState));
            break;
        }

        for (i = 0; i < NumberOfPackets; i++)
        {
            RNDISMP_REF_VC(pVc);
        }

        NdisMCoIndicateReceivePacket(pVc->NdisVcHandle,
                                     PacketArray,
                                     NumberOfPackets);
    }
    while (FALSE);

} // IndicateReceiveDataOnVc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\inc\rndis.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDIS.H

Abstract:

    This module defines the Remote NDIS message structures.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    2/8/99 : created

Authors:

    
****************************************************************************/


#ifndef _RNDIS_H_
#define _RNDIS_H_

//
//  Basic types
//
typedef UINT32                                  RNDIS_REQUEST_ID;
typedef UINT32                                  RNDIS_HANDLE;
typedef UINT32                                  RNDIS_STATUS;
typedef UINT32                                  RNDIS_REQUEST_TYPE;
typedef UINT32                                  RNDIS_OID;
typedef UINT32                                  RNDIS_CLASS_ID;
typedef UINT32                                  RNDIS_MEDIUM;
typedef UINT32                                  *PRNDIS_REQUEST_ID;
typedef UINT32                                  *PRNDIS_HANDLE;
typedef UINT32                                  *PRNDIS_STATUS;
typedef UINT32                                  *PRNDIS_REQUEST_TYPE;
typedef UINT32                                  *PRNDIS_OID;
typedef UINT32                                  *PRNDIS_CLASS_ID;
typedef UINT32                                  *PRNDIS_MEDIUM;
typedef UINT32                                  RNDIS_AF;

//
//  Status codes
//

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                          (0x00000000L)
#endif

#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL                     (0xC0000001L)
#endif

#ifndef STATUS_PENDING
#define STATUS_PENDING                          (0x00000103L)
#endif

#ifndef STATUS_INSUFFICIENT_RESOURCES
#define STATUS_INSUFFICIENT_RESOURCES           (0xC000009AL)
#endif

#ifndef STATUS_BUFFER_OVERFLOW
#define STATUS_BUFFER_OVERFLOW                  (0x80000005L)
#endif

#ifndef STATUS_NOT_SUPPORTED
#define STATUS_NOT_SUPPORTED                    (0xC00000BBL)
#endif

#define RNDIS_STATUS_SUCCESS                    ((RNDIS_STATUS)STATUS_SUCCESS)
#define RNDIS_STATUS_PENDING                    ((RNDIS_STATUS)STATUS_PENDING)
#define RNDIS_STATUS_NOT_RECOGNIZED             ((RNDIS_STATUS)0x00010001L)
#define RNDIS_STATUS_NOT_COPIED                 ((RNDIS_STATUS)0x00010002L)
#define RNDIS_STATUS_NOT_ACCEPTED               ((RNDIS_STATUS)0x00010003L)
#define RNDIS_STATUS_CALL_ACTIVE                ((RNDIS_STATUS)0x00010007L)

#define RNDIS_STATUS_ONLINE                     ((RNDIS_STATUS)0x40010003L)
#define RNDIS_STATUS_RESET_START                ((RNDIS_STATUS)0x40010004L)
#define RNDIS_STATUS_RESET_END                  ((RNDIS_STATUS)0x40010005L)
#define RNDIS_STATUS_RING_STATUS                ((RNDIS_STATUS)0x40010006L)
#define RNDIS_STATUS_CLOSED                     ((RNDIS_STATUS)0x40010007L)
#define RNDIS_STATUS_WAN_LINE_UP                ((RNDIS_STATUS)0x40010008L)
#define RNDIS_STATUS_WAN_LINE_DOWN              ((RNDIS_STATUS)0x40010009L)
#define RNDIS_STATUS_WAN_FRAGMENT               ((RNDIS_STATUS)0x4001000AL)
#define RNDIS_STATUS_MEDIA_CONNECT              ((RNDIS_STATUS)0x4001000BL)
#define RNDIS_STATUS_MEDIA_DISCONNECT           ((RNDIS_STATUS)0x4001000CL)
#define RNDIS_STATUS_HARDWARE_LINE_UP           ((RNDIS_STATUS)0x4001000DL)
#define RNDIS_STATUS_HARDWARE_LINE_DOWN         ((RNDIS_STATUS)0x4001000EL)
#define RNDIS_STATUS_INTERFACE_UP               ((RNDIS_STATUS)0x4001000FL)
#define RNDIS_STATUS_INTERFACE_DOWN             ((RNDIS_STATUS)0x40010010L)
#define RNDIS_STATUS_MEDIA_BUSY                 ((RNDIS_STATUS)0x40010011L)
#define RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION  ((RNDIS_STATUS)0x40010012L)
#define RNDIS_STATUS_WW_INDICATION              RNDIS_STATUS_MEDIA_SPECIFIC_INDICATION
#define RNDIS_STATUS_LINK_SPEED_CHANGE          ((RNDIS_STATUS)0x40010013L)

#define RNDIS_STATUS_NOT_RESETTABLE             ((RNDIS_STATUS)0x80010001L)
#define RNDIS_STATUS_SOFT_ERRORS                ((RNDIS_STATUS)0x80010003L)
#define RNDIS_STATUS_HARD_ERRORS                ((RNDIS_STATUS)0x80010004L)
#define RNDIS_STATUS_BUFFER_OVERFLOW            ((RNDIS_STATUS)STATUS_BUFFER_OVERFLOW)

#define RNDIS_STATUS_FAILURE                    ((RNDIS_STATUS)STATUS_UNSUCCESSFUL)
#define RNDIS_STATUS_RESOURCES                  ((RNDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
#define RNDIS_STATUS_CLOSING                    ((RNDIS_STATUS)0xC0010002L)
#define RNDIS_STATUS_BAD_VERSION                ((RNDIS_STATUS)0xC0010004L)
#define RNDIS_STATUS_BAD_CHARACTERISTICS        ((RNDIS_STATUS)0xC0010005L)
#define RNDIS_STATUS_ADAPTER_NOT_FOUND          ((RNDIS_STATUS)0xC0010006L)
#define RNDIS_STATUS_OPEN_FAILED                ((RNDIS_STATUS)0xC0010007L)
#define RNDIS_STATUS_DEVICE_FAILED              ((RNDIS_STATUS)0xC0010008L)
#define RNDIS_STATUS_MULTICAST_FULL             ((RNDIS_STATUS)0xC0010009L)
#define RNDIS_STATUS_MULTICAST_EXISTS           ((RNDIS_STATUS)0xC001000AL)
#define RNDIS_STATUS_MULTICAST_NOT_FOUND        ((RNDIS_STATUS)0xC001000BL)
#define RNDIS_STATUS_REQUEST_ABORTED            ((RNDIS_STATUS)0xC001000CL)
#define RNDIS_STATUS_RESET_IN_PROGRESS          ((RNDIS_STATUS)0xC001000DL)
#define RNDIS_STATUS_CLOSING_INDICATING         ((RNDIS_STATUS)0xC001000EL)
#define RNDIS_STATUS_NOT_SUPPORTED              ((RNDIS_STATUS)STATUS_NOT_SUPPORTED)
#define RNDIS_STATUS_INVALID_PACKET             ((RNDIS_STATUS)0xC001000FL)
#define RNDIS_STATUS_OPEN_LIST_FULL             ((RNDIS_STATUS)0xC0010010L)
#define RNDIS_STATUS_ADAPTER_NOT_READY          ((RNDIS_STATUS)0xC0010011L)
#define RNDIS_STATUS_ADAPTER_NOT_OPEN           ((RNDIS_STATUS)0xC0010012L)
#define RNDIS_STATUS_NOT_INDICATING             ((RNDIS_STATUS)0xC0010013L)
#define RNDIS_STATUS_INVALID_LENGTH             ((RNDIS_STATUS)0xC0010014L)
#define RNDIS_STATUS_INVALID_DATA               ((RNDIS_STATUS)0xC0010015L)
#define RNDIS_STATUS_BUFFER_TOO_SHORT           ((RNDIS_STATUS)0xC0010016L)
#define RNDIS_STATUS_INVALID_OID                ((RNDIS_STATUS)0xC0010017L)
#define RNDIS_STATUS_ADAPTER_REMOVED            ((RNDIS_STATUS)0xC0010018L)
#define RNDIS_STATUS_UNSUPPORTED_MEDIA          ((RNDIS_STATUS)0xC0010019L)
#define RNDIS_STATUS_GROUP_ADDRESS_IN_USE       ((RNDIS_STATUS)0xC001001AL)
#define RNDIS_STATUS_FILE_NOT_FOUND             ((RNDIS_STATUS)0xC001001BL)
#define RNDIS_STATUS_ERROR_READING_FILE         ((RNDIS_STATUS)0xC001001CL)
#define RNDIS_STATUS_ALREADY_MAPPED             ((RNDIS_STATUS)0xC001001DL)
#define RNDIS_STATUS_RESOURCE_CONFLICT          ((RNDIS_STATUS)0xC001001EL)
#define RNDIS_STATUS_NO_CABLE                   ((RNDIS_STATUS)0xC001001FL)

#define RNDIS_STATUS_INVALID_SAP                ((RNDIS_STATUS)0xC0010020L)
#define RNDIS_STATUS_SAP_IN_USE                 ((RNDIS_STATUS)0xC0010021L)
#define RNDIS_STATUS_INVALID_ADDRESS            ((RNDIS_STATUS)0xC0010022L)
#define RNDIS_STATUS_VC_NOT_ACTIVATED           ((RNDIS_STATUS)0xC0010023L)
#define RNDIS_STATUS_DEST_OUT_OF_ORDER          ((RNDIS_STATUS)0xC0010024L)
#define RNDIS_STATUS_VC_NOT_AVAILABLE           ((RNDIS_STATUS)0xC0010025L)
#define RNDIS_STATUS_CELLRATE_NOT_AVAILABLE     ((RNDIS_STATUS)0xC0010026L)
#define RNDIS_STATUS_INCOMPATABLE_QOS           ((RNDIS_STATUS)0xC0010027L)
#define RNDIS_STATUS_AAL_PARAMS_UNSUPPORTED     ((RNDIS_STATUS)0xC0010028L)
#define RNDIS_STATUS_NO_ROUTE_TO_DESTINATION    ((RNDIS_STATUS)0xC0010029L)

#define RNDIS_STATUS_TOKEN_RING_OPEN_ERROR      ((RNDIS_STATUS)0xC0011000L)


//
// Object Identifiers used by NdisRequest Query/Set Information
//

//
// General Objects
//

#define RNDIS_OID_GEN_SUPPORTED_LIST                    0x00010101
#define RNDIS_OID_GEN_HARDWARE_STATUS                   0x00010102
#define RNDIS_OID_GEN_MEDIA_SUPPORTED                   0x00010103
#define RNDIS_OID_GEN_MEDIA_IN_USE                      0x00010104
#define RNDIS_OID_GEN_MAXIMUM_LOOKAHEAD                 0x00010105
#define RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE                0x00010106
#define RNDIS_OID_GEN_LINK_SPEED                        0x00010107
#define RNDIS_OID_GEN_TRANSMIT_BUFFER_SPACE             0x00010108
#define RNDIS_OID_GEN_RECEIVE_BUFFER_SPACE              0x00010109
#define RNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE               0x0001010A
#define RNDIS_OID_GEN_RECEIVE_BLOCK_SIZE                0x0001010B
#define RNDIS_OID_GEN_VENDOR_ID                         0x0001010C
#define RNDIS_OID_GEN_VENDOR_DESCRIPTION                0x0001010D
#define RNDIS_OID_GEN_CURRENT_PACKET_FILTER             0x0001010E
#define RNDIS_OID_GEN_CURRENT_LOOKAHEAD                 0x0001010F
#define RNDIS_OID_GEN_DRIVER_VERSION                    0x00010110
#define RNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE                0x00010111
#define RNDIS_OID_GEN_PROTOCOL_OPTIONS                  0x00010112
#define RNDIS_OID_GEN_MAC_OPTIONS                       0x00010113
#define RNDIS_OID_GEN_MEDIA_CONNECT_STATUS              0x00010114
#define RNDIS_OID_GEN_MAXIMUM_SEND_PACKETS              0x00010115
#define RNDIS_OID_GEN_VENDOR_DRIVER_VERSION             0x00010116
#define RNDIS_OID_GEN_NETWORK_LAYER_ADDRESSES           0x00010118
#define RNDIS_OID_GEN_TRANSPORT_HEADER_OFFSET           0x00010119
#define RNDIS_OID_GEN_MACHINE_NAME                      0x0001021A
#define RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER            0x0001021B

#define RNDIS_OID_GEN_XMIT_OK                           0x00020101
#define RNDIS_OID_GEN_RCV_OK                            0x00020102
#define RNDIS_OID_GEN_XMIT_ERROR                        0x00020103
#define RNDIS_OID_GEN_RCV_ERROR                         0x00020104
#define RNDIS_OID_GEN_RCV_NO_BUFFER                     0x00020105

#define RNDIS_OID_GEN_DIRECTED_BYTES_XMIT               0x00020201
#define RNDIS_OID_GEN_DIRECTED_FRAMES_XMIT              0x00020202
#define RNDIS_OID_GEN_MULTICAST_BYTES_XMIT              0x00020203
#define RNDIS_OID_GEN_MULTICAST_FRAMES_XMIT             0x00020204
#define RNDIS_OID_GEN_BROADCAST_BYTES_XMIT              0x00020205
#define RNDIS_OID_GEN_BROADCAST_FRAMES_XMIT             0x00020206
#define RNDIS_OID_GEN_DIRECTED_BYTES_RCV                0x00020207
#define RNDIS_OID_GEN_DIRECTED_FRAMES_RCV               0x00020208
#define RNDIS_OID_GEN_MULTICAST_BYTES_RCV               0x00020209
#define RNDIS_OID_GEN_MULTICAST_FRAMES_RCV              0x0002020A
#define RNDIS_OID_GEN_BROADCAST_BYTES_RCV               0x0002020B
#define RNDIS_OID_GEN_BROADCAST_FRAMES_RCV              0x0002020C

#define RNDIS_OID_GEN_RCV_CRC_ERROR                     0x0002020D
#define RNDIS_OID_GEN_TRANSMIT_QUEUE_LENGTH             0x0002020E

#define RNDIS_OID_GEN_GET_TIME_CAPS                     0x0002020F
#define RNDIS_OID_GEN_GET_NETCARD_TIME                  0x00020210

//
// These are connection-oriented general OIDs.
// These replace the above OIDs for connection-oriented media.
//
#define RNDIS_OID_GEN_CO_SUPPORTED_LIST                 0x00010101
#define RNDIS_OID_GEN_CO_HARDWARE_STATUS                0x00010102
#define RNDIS_OID_GEN_CO_MEDIA_SUPPORTED                0x00010103
#define RNDIS_OID_GEN_CO_MEDIA_IN_USE                   0x00010104
#define RNDIS_OID_GEN_CO_LINK_SPEED                     0x00010105
#define RNDIS_OID_GEN_CO_VENDOR_ID                      0x00010106
#define RNDIS_OID_GEN_CO_VENDOR_DESCRIPTION             0x00010107
#define RNDIS_OID_GEN_CO_DRIVER_VERSION                 0x00010108
#define RNDIS_OID_GEN_CO_PROTOCOL_OPTIONS               0x00010109
#define RNDIS_OID_GEN_CO_MAC_OPTIONS                    0x0001010A
#define RNDIS_OID_GEN_CO_MEDIA_CONNECT_STATUS           0x0001010B
#define RNDIS_OID_GEN_CO_VENDOR_DRIVER_VERSION          0x0001010C
#define RNDIS_OID_GEN_CO_MINIMUM_LINK_SPEED             0x0001010D

#define RNDIS_OID_GEN_CO_GET_TIME_CAPS                  0x00010201
#define RNDIS_OID_GEN_CO_GET_NETCARD_TIME               0x00010202

//
// These are connection-oriented statistics OIDs.
//
#define RNDIS_OID_GEN_CO_XMIT_PDUS_OK                   0x00020101
#define RNDIS_OID_GEN_CO_RCV_PDUS_OK                    0x00020102
#define RNDIS_OID_GEN_CO_XMIT_PDUS_ERROR                0x00020103
#define RNDIS_OID_GEN_CO_RCV_PDUS_ERROR                 0x00020104
#define RNDIS_OID_GEN_CO_RCV_PDUS_NO_BUFFER             0x00020105


#define RNDIS_OID_GEN_CO_RCV_CRC_ERROR                  0x00020201
#define RNDIS_OID_GEN_CO_TRANSMIT_QUEUE_LENGTH          0x00020202
#define RNDIS_OID_GEN_CO_BYTES_XMIT                     0x00020203
#define RNDIS_OID_GEN_CO_BYTES_RCV                      0x00020204
#define RNDIS_OID_GEN_CO_BYTES_XMIT_OUTSTANDING         0x00020205
#define RNDIS_OID_GEN_CO_NETCARD_LOAD                   0x00020206

//
// These are objects for Connection-oriented media call-managers.
//
#define RNDIS_OID_CO_ADD_PVC                            0xFF000001
#define RNDIS_OID_CO_DELETE_PVC                         0xFF000002
#define RNDIS_OID_CO_GET_CALL_INFORMATION               0xFF000003
#define RNDIS_OID_CO_ADD_ADDRESS                        0xFF000004
#define RNDIS_OID_CO_DELETE_ADDRESS                     0xFF000005
#define RNDIS_OID_CO_GET_ADDRESSES                      0xFF000006
#define RNDIS_OID_CO_ADDRESS_CHANGE                     0xFF000007
#define RNDIS_OID_CO_SIGNALING_ENABLED                  0xFF000008
#define RNDIS_OID_CO_SIGNALING_DISABLED                 0xFF000009


//
// 802.3 Objects (Ethernet)
//

#define RNDIS_OID_802_3_PERMANENT_ADDRESS               0x01010101
#define RNDIS_OID_802_3_CURRENT_ADDRESS                 0x01010102
#define RNDIS_OID_802_3_MULTICAST_LIST                  0x01010103
#define RNDIS_OID_802_3_MAXIMUM_LIST_SIZE               0x01010104
#define RNDIS_OID_802_3_MAC_OPTIONS                     0x01010105

//
//
#define NDIS_802_3_MAC_OPTION_PRIORITY                  0x00000001

#define RNDIS_OID_802_3_RCV_ERROR_ALIGNMENT             0x01020101
#define RNDIS_OID_802_3_XMIT_ONE_COLLISION              0x01020102
#define RNDIS_OID_802_3_XMIT_MORE_COLLISIONS            0x01020103

#define RNDIS_OID_802_3_XMIT_DEFERRED                   0x01020201
#define RNDIS_OID_802_3_XMIT_MAX_COLLISIONS             0x01020202
#define RNDIS_OID_802_3_RCV_OVERRUN                     0x01020203
#define RNDIS_OID_802_3_XMIT_UNDERRUN                   0x01020204
#define RNDIS_OID_802_3_XMIT_HEARTBEAT_FAILURE          0x01020205
#define RNDIS_OID_802_3_XMIT_TIMES_CRS_LOST             0x01020206
#define RNDIS_OID_802_3_XMIT_LATE_COLLISIONS            0x01020207


//
// 802.5 Objects (Token-Ring)
//

#define RNDIS_OID_802_5_PERMANENT_ADDRESS               0x02010101
#define RNDIS_OID_802_5_CURRENT_ADDRESS                 0x02010102
#define RNDIS_OID_802_5_CURRENT_FUNCTIONAL              0x02010103
#define RNDIS_OID_802_5_CURRENT_GROUP                   0x02010104
#define RNDIS_OID_802_5_LAST_OPEN_STATUS                0x02010105
#define RNDIS_OID_802_5_CURRENT_RING_STATUS             0x02010106
#define RNDIS_OID_802_5_CURRENT_RING_STATE              0x02010107

#define RNDIS_OID_802_5_LINE_ERRORS                     0x02020101
#define RNDIS_OID_802_5_LOST_FRAMES                     0x02020102

#define RNDIS_OID_802_5_BURST_ERRORS                    0x02020201
#define RNDIS_OID_802_5_AC_ERRORS                       0x02020202
#define RNDIS_OID_802_5_ABORT_DELIMETERS                0x02020203
#define RNDIS_OID_802_5_FRAME_COPIED_ERRORS             0x02020204
#define RNDIS_OID_802_5_FREQUENCY_ERRORS                0x02020205
#define RNDIS_OID_802_5_TOKEN_ERRORS                    0x02020206
#define RNDIS_OID_802_5_INTERNAL_ERRORS                 0x02020207


//
// FDDI Objects
//

#define RNDIS_OID_FDDI_LONG_PERMANENT_ADDR              0x03010101
#define RNDIS_OID_FDDI_LONG_CURRENT_ADDR                0x03010102
#define RNDIS_OID_FDDI_LONG_MULTICAST_LIST              0x03010103
#define RNDIS_OID_FDDI_LONG_MAX_LIST_SIZE               0x03010104
#define RNDIS_OID_FDDI_SHORT_PERMANENT_ADDR             0x03010105
#define RNDIS_OID_FDDI_SHORT_CURRENT_ADDR               0x03010106
#define RNDIS_OID_FDDI_SHORT_MULTICAST_LIST             0x03010107
#define RNDIS_OID_FDDI_SHORT_MAX_LIST_SIZE              0x03010108

#define RNDIS_OID_FDDI_ATTACHMENT_TYPE                  0x03020101
#define RNDIS_OID_FDDI_UPSTREAM_NODE_LONG               0x03020102
#define RNDIS_OID_FDDI_DOWNSTREAM_NODE_LONG             0x03020103
#define RNDIS_OID_FDDI_FRAME_ERRORS                     0x03020104
#define RNDIS_OID_FDDI_FRAMES_LOST                      0x03020105
#define RNDIS_OID_FDDI_RING_MGT_STATE                   0x03020106
#define RNDIS_OID_FDDI_LCT_FAILURES                     0x03020107
#define RNDIS_OID_FDDI_LEM_REJECTS                      0x03020108
#define RNDIS_OID_FDDI_LCONNECTION_STATE                0x03020109

#define RNDIS_OID_FDDI_SMT_STATION_ID                   0x03030201
#define RNDIS_OID_FDDI_SMT_OP_VERSION_ID                0x03030202
#define RNDIS_OID_FDDI_SMT_HI_VERSION_ID                0x03030203
#define RNDIS_OID_FDDI_SMT_LO_VERSION_ID                0x03030204
#define RNDIS_OID_FDDI_SMT_MANUFACTURER_DATA            0x03030205
#define RNDIS_OID_FDDI_SMT_USER_DATA                    0x03030206
#define RNDIS_OID_FDDI_SMT_MIB_VERSION_ID               0x03030207
#define RNDIS_OID_FDDI_SMT_MAC_CT                       0x03030208
#define RNDIS_OID_FDDI_SMT_NON_MASTER_CT                0x03030209
#define RNDIS_OID_FDDI_SMT_MASTER_CT                    0x0303020A
#define RNDIS_OID_FDDI_SMT_AVAILABLE_PATHS              0x0303020B
#define RNDIS_OID_FDDI_SMT_CONFIG_CAPABILITIES          0x0303020C
#define RNDIS_OID_FDDI_SMT_CONFIG_POLICY                0x0303020D
#define RNDIS_OID_FDDI_SMT_CONNECTION_POLICY            0x0303020E
#define RNDIS_OID_FDDI_SMT_T_NOTIFY                     0x0303020F
#define RNDIS_OID_FDDI_SMT_STAT_RPT_POLICY              0x03030210
#define RNDIS_OID_FDDI_SMT_TRACE_MAX_EXPIRATION         0x03030211
#define RNDIS_OID_FDDI_SMT_PORT_INDEXES                 0x03030212
#define RNDIS_OID_FDDI_SMT_MAC_INDEXES                  0x03030213
#define RNDIS_OID_FDDI_SMT_BYPASS_PRESENT               0x03030214
#define RNDIS_OID_FDDI_SMT_ECM_STATE                    0x03030215
#define RNDIS_OID_FDDI_SMT_CF_STATE                     0x03030216
#define RNDIS_OID_FDDI_SMT_HOLD_STATE                   0x03030217
#define RNDIS_OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG       0x03030218
#define RNDIS_OID_FDDI_SMT_STATION_STATUS               0x03030219
#define RNDIS_OID_FDDI_SMT_PEER_WRAP_FLAG               0x0303021A
#define RNDIS_OID_FDDI_SMT_MSG_TIME_STAMP               0x0303021B
#define RNDIS_OID_FDDI_SMT_TRANSITION_TIME_STAMP        0x0303021C
#define RNDIS_OID_FDDI_SMT_SET_COUNT                    0x0303021D
#define RNDIS_OID_FDDI_SMT_LAST_SET_STATION_ID          0x0303021E
#define RNDIS_OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS       0x0303021F
#define RNDIS_OID_FDDI_MAC_BRIDGE_FUNCTIONS             0x03030220
#define RNDIS_OID_FDDI_MAC_T_MAX_CAPABILITY             0x03030221
#define RNDIS_OID_FDDI_MAC_TVX_CAPABILITY               0x03030222
#define RNDIS_OID_FDDI_MAC_AVAILABLE_PATHS              0x03030223
#define RNDIS_OID_FDDI_MAC_CURRENT_PATH                 0x03030224
#define RNDIS_OID_FDDI_MAC_UPSTREAM_NBR                 0x03030225
#define RNDIS_OID_FDDI_MAC_DOWNSTREAM_NBR               0x03030226
#define RNDIS_OID_FDDI_MAC_OLD_UPSTREAM_NBR             0x03030227
#define RNDIS_OID_FDDI_MAC_OLD_DOWNSTREAM_NBR           0x03030228
#define RNDIS_OID_FDDI_MAC_DUP_ADDRESS_TEST             0x03030229
#define RNDIS_OID_FDDI_MAC_REQUESTED_PATHS              0x0303022A
#define RNDIS_OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE         0x0303022B
#define RNDIS_OID_FDDI_MAC_INDEX                        0x0303022C
#define RNDIS_OID_FDDI_MAC_SMT_ADDRESS                  0x0303022D
#define RNDIS_OID_FDDI_MAC_LONG_GRP_ADDRESS             0x0303022E
#define RNDIS_OID_FDDI_MAC_SHORT_GRP_ADDRESS            0x0303022F
#define RNDIS_OID_FDDI_MAC_T_REQ                        0x03030230
#define RNDIS_OID_FDDI_MAC_T_NEG                        0x03030231
#define RNDIS_OID_FDDI_MAC_T_MAX                        0x03030232
#define RNDIS_OID_FDDI_MAC_TVX_VALUE                    0x03030233
#define RNDIS_OID_FDDI_MAC_T_PRI0                       0x03030234
#define RNDIS_OID_FDDI_MAC_T_PRI1                       0x03030235
#define RNDIS_OID_FDDI_MAC_T_PRI2                       0x03030236
#define RNDIS_OID_FDDI_MAC_T_PRI3                       0x03030237
#define RNDIS_OID_FDDI_MAC_T_PRI4                       0x03030238
#define RNDIS_OID_FDDI_MAC_T_PRI5                       0x03030239
#define RNDIS_OID_FDDI_MAC_T_PRI6                       0x0303023A
#define RNDIS_OID_FDDI_MAC_FRAME_CT                     0x0303023B
#define RNDIS_OID_FDDI_MAC_COPIED_CT                    0x0303023C
#define RNDIS_OID_FDDI_MAC_TRANSMIT_CT                  0x0303023D
#define RNDIS_OID_FDDI_MAC_TOKEN_CT                     0x0303023E
#define RNDIS_OID_FDDI_MAC_ERROR_CT                     0x0303023F
#define RNDIS_OID_FDDI_MAC_LOST_CT                      0x03030240
#define RNDIS_OID_FDDI_MAC_TVX_EXPIRED_CT               0x03030241
#define RNDIS_OID_FDDI_MAC_NOT_COPIED_CT                0x03030242
#define RNDIS_OID_FDDI_MAC_LATE_CT                      0x03030243
#define RNDIS_OID_FDDI_MAC_RING_OP_CT                   0x03030244
#define RNDIS_OID_FDDI_MAC_FRAME_ERROR_THRESHOLD        0x03030245
#define RNDIS_OID_FDDI_MAC_FRAME_ERROR_RATIO            0x03030246
#define RNDIS_OID_FDDI_MAC_NOT_COPIED_THRESHOLD         0x03030247
#define RNDIS_OID_FDDI_MAC_NOT_COPIED_RATIO             0x03030248
#define RNDIS_OID_FDDI_MAC_RMT_STATE                    0x03030249
#define RNDIS_OID_FDDI_MAC_DA_FLAG                      0x0303024A
#define RNDIS_OID_FDDI_MAC_UNDA_FLAG                    0x0303024B
#define RNDIS_OID_FDDI_MAC_FRAME_ERROR_FLAG             0x0303024C
#define RNDIS_OID_FDDI_MAC_NOT_COPIED_FLAG              0x0303024D
#define RNDIS_OID_FDDI_MAC_MA_UNITDATA_AVAILABLE        0x0303024E
#define RNDIS_OID_FDDI_MAC_HARDWARE_PRESENT             0x0303024F
#define RNDIS_OID_FDDI_MAC_MA_UNITDATA_ENABLE           0x03030250
#define RNDIS_OID_FDDI_PATH_INDEX                       0x03030251
#define RNDIS_OID_FDDI_PATH_RING_LATENCY                0x03030252
#define RNDIS_OID_FDDI_PATH_TRACE_STATUS                0x03030253
#define RNDIS_OID_FDDI_PATH_SBA_PAYLOAD                 0x03030254
#define RNDIS_OID_FDDI_PATH_SBA_OVERHEAD                0x03030255
#define RNDIS_OID_FDDI_PATH_CONFIGURATION               0x03030256
#define RNDIS_OID_FDDI_PATH_T_R_MODE                    0x03030257
#define RNDIS_OID_FDDI_PATH_SBA_AVAILABLE               0x03030258
#define RNDIS_OID_FDDI_PATH_TVX_LOWER_BOUND             0x03030259
#define RNDIS_OID_FDDI_PATH_T_MAX_LOWER_BOUND           0x0303025A
#define RNDIS_OID_FDDI_PATH_MAX_T_REQ                   0x0303025B
#define RNDIS_OID_FDDI_PORT_MY_TYPE                     0x0303025C
#define RNDIS_OID_FDDI_PORT_NEIGHBOR_TYPE               0x0303025D
#define RNDIS_OID_FDDI_PORT_CONNECTION_POLICIES         0x0303025E
#define RNDIS_OID_FDDI_PORT_MAC_INDICATED               0x0303025F
#define RNDIS_OID_FDDI_PORT_CURRENT_PATH                0x03030260
#define RNDIS_OID_FDDI_PORT_REQUESTED_PATHS             0x03030261
#define RNDIS_OID_FDDI_PORT_MAC_PLACEMENT               0x03030262
#define RNDIS_OID_FDDI_PORT_AVAILABLE_PATHS             0x03030263
#define RNDIS_OID_FDDI_PORT_MAC_LOOP_TIME               0x03030264
#define RNDIS_OID_FDDI_PORT_PMD_CLASS                   0x03030265
#define RNDIS_OID_FDDI_PORT_CONNECTION_CAPABILITIES     0x03030266
#define RNDIS_OID_FDDI_PORT_INDEX                       0x03030267
#define RNDIS_OID_FDDI_PORT_MAINT_LS                    0x03030268
#define RNDIS_OID_FDDI_PORT_BS_FLAG                     0x03030269
#define RNDIS_OID_FDDI_PORT_PC_LS                       0x0303026A
#define RNDIS_OID_FDDI_PORT_EB_ERROR_CT                 0x0303026B
#define RNDIS_OID_FDDI_PORT_LCT_FAIL_CT                 0x0303026C
#define RNDIS_OID_FDDI_PORT_LER_ESTIMATE                0x0303026D
#define RNDIS_OID_FDDI_PORT_LEM_REJECT_CT               0x0303026E
#define RNDIS_OID_FDDI_PORT_LEM_CT                      0x0303026F
#define RNDIS_OID_FDDI_PORT_LER_CUTOFF                  0x03030270
#define RNDIS_OID_FDDI_PORT_LER_ALARM                   0x03030271
#define RNDIS_OID_FDDI_PORT_CONNNECT_STATE              0x03030272
#define RNDIS_OID_FDDI_PORT_PCM_STATE                   0x03030273
#define RNDIS_OID_FDDI_PORT_PC_WITHHOLD                 0x03030274
#define RNDIS_OID_FDDI_PORT_LER_FLAG                    0x03030275
#define RNDIS_OID_FDDI_PORT_HARDWARE_PRESENT            0x03030276
#define RNDIS_OID_FDDI_SMT_STATION_ACTION               0x03030277
#define RNDIS_OID_FDDI_PORT_ACTION                      0x03030278
#define RNDIS_OID_FDDI_IF_DESCR                         0x03030279
#define RNDIS_OID_FDDI_IF_TYPE                          0x0303027A
#define RNDIS_OID_FDDI_IF_MTU                           0x0303027B
#define RNDIS_OID_FDDI_IF_SPEED                         0x0303027C
#define RNDIS_OID_FDDI_IF_PHYS_ADDRESS                  0x0303027D
#define RNDIS_OID_FDDI_IF_ADMIN_STATUS                  0x0303027E
#define RNDIS_OID_FDDI_IF_OPER_STATUS                   0x0303027F
#define RNDIS_OID_FDDI_IF_LAST_CHANGE                   0x03030280
#define RNDIS_OID_FDDI_IF_IN_OCTETS                     0x03030281
#define RNDIS_OID_FDDI_IF_IN_UCAST_PKTS                 0x03030282
#define RNDIS_OID_FDDI_IF_IN_NUCAST_PKTS                0x03030283
#define RNDIS_OID_FDDI_IF_IN_DISCARDS                   0x03030284
#define RNDIS_OID_FDDI_IF_IN_ERRORS                     0x03030285
#define RNDIS_OID_FDDI_IF_IN_UNKNOWN_PROTOS             0x03030286
#define RNDIS_OID_FDDI_IF_OUT_OCTETS                    0x03030287
#define RNDIS_OID_FDDI_IF_OUT_UCAST_PKTS                0x03030288
#define RNDIS_OID_FDDI_IF_OUT_NUCAST_PKTS               0x03030289
#define RNDIS_OID_FDDI_IF_OUT_DISCARDS                  0x0303028A
#define RNDIS_OID_FDDI_IF_OUT_ERRORS                    0x0303028B
#define RNDIS_OID_FDDI_IF_OUT_QLEN                      0x0303028C
#define RNDIS_OID_FDDI_IF_SPECIFIC                      0x0303028D


//
// WAN objects
//

#define RNDIS_OID_WAN_PERMANENT_ADDRESS                 0x04010101
#define RNDIS_OID_WAN_CURRENT_ADDRESS                   0x04010102
#define RNDIS_OID_WAN_QUALITY_OF_SERVICE                0x04010103
#define RNDIS_OID_WAN_PROTOCOL_TYPE                     0x04010104
#define RNDIS_OID_WAN_MEDIUM_SUBTYPE                    0x04010105
#define RNDIS_OID_WAN_HEADER_FORMAT                     0x04010106

#define RNDIS_OID_WAN_GET_INFO                          0x04010107
#define RNDIS_OID_WAN_SET_LINK_INFO                     0x04010108
#define RNDIS_OID_WAN_GET_LINK_INFO                     0x04010109

#define RNDIS_OID_WAN_LINE_COUNT                        0x0401010A

#define RNDIS_OID_WAN_GET_BRIDGE_INFO                   0x0401020A
#define RNDIS_OID_WAN_SET_BRIDGE_INFO                   0x0401020B
#define RNDIS_OID_WAN_GET_COMP_INFO                     0x0401020C
#define RNDIS_OID_WAN_SET_COMP_INFO                     0x0401020D
#define RNDIS_OID_WAN_GET_STATS_INFO                    0x0401020E


//
// LocalTalk objects
//

#define RNDIS_OID_LTALK_CURRENT_NODE_ID                 0x05010102

#define RNDIS_OID_LTALK_IN_BROADCASTS                   0x05020101
#define RNDIS_OID_LTALK_IN_LENGTH_ERRORS                0x05020102

#define RNDIS_OID_LTALK_OUT_NO_HANDLERS                 0x05020201
#define RNDIS_OID_LTALK_COLLISIONS                      0x05020202
#define RNDIS_OID_LTALK_DEFERS                          0x05020203
#define RNDIS_OID_LTALK_NO_DATA_ERRORS                  0x05020204
#define RNDIS_OID_LTALK_RANDOM_CTS_ERRORS               0x05020205
#define RNDIS_OID_LTALK_FCS_ERRORS                      0x05020206


//
// Arcnet objects
//

#define RNDIS_OID_ARCNET_PERMANENT_ADDRESS              0x06010101
#define RNDIS_OID_ARCNET_CURRENT_ADDRESS                0x06010102

#define RNDIS_OID_ARCNET_RECONFIGURATIONS               0x06020201


//
// TAPI objects
//
#define RNDIS_OID_TAPI_ACCEPT                           0x07030101
#define RNDIS_OID_TAPI_ANSWER                           0x07030102
#define RNDIS_OID_TAPI_CLOSE                            0x07030103
#define RNDIS_OID_TAPI_CLOSE_CALL                       0x07030104
#define RNDIS_OID_TAPI_CONDITIONAL_MEDIA_DETECTION      0x07030105
#define RNDIS_OID_TAPI_CONFIG_DIALOG                    0x07030106
#define RNDIS_OID_TAPI_DEV_SPECIFIC                     0x07030107
#define RNDIS_OID_TAPI_DIAL                             0x07030108
#define RNDIS_OID_TAPI_DROP                             0x07030109
#define RNDIS_OID_TAPI_GET_ADDRESS_CAPS                 0x0703010A
#define RNDIS_OID_TAPI_GET_ADDRESS_ID                   0x0703010B
#define RNDIS_OID_TAPI_GET_ADDRESS_STATUS               0x0703010C
#define RNDIS_OID_TAPI_GET_CALL_ADDRESS_ID              0x0703010D
#define RNDIS_OID_TAPI_GET_CALL_INFO                    0x0703010E
#define RNDIS_OID_TAPI_GET_CALL_STATUS                  0x0703010F
#define RNDIS_OID_TAPI_GET_DEV_CAPS                     0x07030110
#define RNDIS_OID_TAPI_GET_DEV_CONFIG                   0x07030111
#define RNDIS_OID_TAPI_GET_EXTENSION_ID                 0x07030112
#define RNDIS_OID_TAPI_GET_ID                           0x07030113
#define RNDIS_OID_TAPI_GET_LINE_DEV_STATUS              0x07030114
#define RNDIS_OID_TAPI_MAKE_CALL                        0x07030115
#define RNDIS_OID_TAPI_NEGOTIATE_EXT_VERSION            0x07030116
#define RNDIS_OID_TAPI_OPEN                             0x07030117
#define RNDIS_OID_TAPI_PROVIDER_INITIALIZE              0x07030118
#define RNDIS_OID_TAPI_PROVIDER_SHUTDOWN                0x07030119
#define RNDIS_OID_TAPI_SECURE_CALL                      0x0703011A
#define RNDIS_OID_TAPI_SELECT_EXT_VERSION               0x0703011B
#define RNDIS_OID_TAPI_SEND_USER_USER_INFO              0x0703011C
#define RNDIS_OID_TAPI_SET_APP_SPECIFIC                 0x0703011D
#define RNDIS_OID_TAPI_SET_CALL_PARAMS                  0x0703011E
#define RNDIS_OID_TAPI_SET_DEFAULT_MEDIA_DETECTION      0x0703011F
#define RNDIS_OID_TAPI_SET_DEV_CONFIG                   0x07030120
#define RNDIS_OID_TAPI_SET_MEDIA_MODE                   0x07030121
#define RNDIS_OID_TAPI_SET_STATUS_MESSAGES              0x07030122


//
// ATM Connection Oriented Ndis
//
#define RNDIS_OID_ATM_SUPPORTED_VC_RATES                0x08010101
#define RNDIS_OID_ATM_SUPPORTED_SERVICE_CATEGORY        0x08010102
#define RNDIS_OID_ATM_SUPPORTED_AAL_TYPES               0x08010103
#define RNDIS_OID_ATM_HW_CURRENT_ADDRESS                0x08010104
#define RNDIS_OID_ATM_MAX_ACTIVE_VCS                    0x08010105
#define RNDIS_OID_ATM_MAX_ACTIVE_VCI_BITS               0x08010106
#define RNDIS_OID_ATM_MAX_ACTIVE_VPI_BITS               0x08010107
#define RNDIS_OID_ATM_ALIGNMENT_REQUIRED                0x08010108
#define RNDIS_OID_ATM_MAX_AAL0_PACKET_SIZE              0x08010109
#define RNDIS_OID_ATM_MAX_AAL1_PACKET_SIZE              0x0801010A
#define RNDIS_OID_ATM_MAX_AAL34_PACKET_SIZE             0x0801010B
#define RNDIS_OID_ATM_MAX_AAL5_PACKET_SIZE              0x0801010C

#define RNDIS_OID_ATM_SIGNALING_VPIVCI                  0x08010201
#define RNDIS_OID_ATM_ASSIGNED_VPI                      0x08010202
#define RNDIS_OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES      0x08010203
#define RNDIS_OID_ATM_RELEASE_ACCESS_NET_RESOURCES      0x08010204
#define RNDIS_OID_ATM_ILMI_VPIVCI                       0x08010205
#define RNDIS_OID_ATM_DIGITAL_BROADCAST_VPIVCI          0x08010206
#define RNDIS_OID_ATM_GET_NEAREST_FLOW                  0x08010207

//
// ATM specific statistics OIDs.
//
#define RNDIS_OID_ATM_RCV_CELLS_OK                      0x08020101
#define RNDIS_OID_ATM_XMIT_CELLS_OK                     0x08020102
#define RNDIS_OID_ATM_RCV_CELLS_DROPPED                 0x08020103

#define RNDIS_OID_ATM_RCV_INVALID_VPI_VCI               0x08020201
#define RNDIS_OID_ATM_CELLS_HEC_ERROR                   0x08020202
#define RNDIS_OID_ATM_RCV_REASSEMBLY_ERROR              0x08020203

//
// PCCA (Wireless) object
//

//
// All WirelessWAN devices must support the following OIDs
//

#define RNDIS_OID_WW_GEN_NETWORK_TYPES_SUPPORTED        0x09010101
#define RNDIS_OID_WW_GEN_NETWORK_TYPE_IN_USE            0x09010102
#define RNDIS_OID_WW_GEN_HEADER_FORMATS_SUPPORTED       0x09010103
#define RNDIS_OID_WW_GEN_HEADER_FORMAT_IN_USE           0x09010104
#define RNDIS_OID_WW_GEN_INDICATION_REQUEST             0x09010105
#define RNDIS_OID_WW_GEN_DEVICE_INFO                    0x09010106
#define RNDIS_OID_WW_GEN_OPERATION_MODE                 0x09010107
#define RNDIS_OID_WW_GEN_LOCK_STATUS                    0x09010108
#define RNDIS_OID_WW_GEN_DISABLE_TRANSMITTER            0x09010109
#define RNDIS_OID_WW_GEN_NETWORK_ID                     0x0901010A
#define RNDIS_OID_WW_GEN_PERMANENT_ADDRESS              0x0901010B
#define RNDIS_OID_WW_GEN_CURRENT_ADDRESS                0x0901010C
#define RNDIS_OID_WW_GEN_SUSPEND_DRIVER                 0x0901010D
#define RNDIS_OID_WW_GEN_BASESTATION_ID                 0x0901010E
#define RNDIS_OID_WW_GEN_CHANNEL_ID                     0x0901010F
#define RNDIS_OID_WW_GEN_ENCRYPTION_SUPPORTED           0x09010110
#define RNDIS_OID_WW_GEN_ENCRYPTION_IN_USE              0x09010111
#define RNDIS_OID_WW_GEN_ENCRYPTION_STATE               0x09010112
#define RNDIS_OID_WW_GEN_CHANNEL_QUALITY                0x09010113
#define RNDIS_OID_WW_GEN_REGISTRATION_STATUS            0x09010114
#define RNDIS_OID_WW_GEN_RADIO_LINK_SPEED               0x09010115
#define RNDIS_OID_WW_GEN_LATENCY                        0x09010116
#define RNDIS_OID_WW_GEN_BATTERY_LEVEL                  0x09010117
#define RNDIS_OID_WW_GEN_EXTERNAL_POWER                 0x09010118

//
// Network Dependent OIDs - Mobitex:
//

#define RNDIS_OID_WW_MBX_SUBADDR                        0x09050101
// OID 0x09050102 is reserved and may not be used
#define RNDIS_OID_WW_MBX_FLEXLIST                       0x09050103
#define RNDIS_OID_WW_MBX_GROUPLIST                      0x09050104
#define RNDIS_OID_WW_MBX_TRAFFIC_AREA                   0x09050105
#define RNDIS_OID_WW_MBX_LIVE_DIE                       0x09050106
#define RNDIS_OID_WW_MBX_TEMP_DEFAULTLIST               0x09050107

//
// Network Dependent OIDs - Pinpoint:
//

#define RNDIS_OID_WW_PIN_LOC_AUTHORIZE                  0x09090101
#define RNDIS_OID_WW_PIN_LAST_LOCATION                  0x09090102
#define RNDIS_OID_WW_PIN_LOC_FIX                        0x09090103

//
// Network Dependent - CDPD:
//

#define RNDIS_OID_WW_CDPD_SPNI                          0x090D0101
#define RNDIS_OID_WW_CDPD_WASI                          0x090D0102
#define RNDIS_OID_WW_CDPD_AREA_COLOR                    0x090D0103
#define RNDIS_OID_WW_CDPD_TX_POWER_LEVEL                0x090D0104
#define RNDIS_OID_WW_CDPD_EID                           0x090D0105
#define RNDIS_OID_WW_CDPD_HEADER_COMPRESSION            0x090D0106
#define RNDIS_OID_WW_CDPD_DATA_COMPRESSION              0x090D0107
#define RNDIS_OID_WW_CDPD_CHANNEL_SELECT                0x090D0108
#define RNDIS_OID_WW_CDPD_CHANNEL_STATE                 0x090D0109
#define RNDIS_OID_WW_CDPD_NEI                           0x090D010A
#define RNDIS_OID_WW_CDPD_NEI_STATE                     0x090D010B
#define RNDIS_OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER   0x090D010C
#define RNDIS_OID_WW_CDPD_SLEEP_MODE                    0x090D010D
#define RNDIS_OID_WW_CDPD_CIRCUIT_SWITCHED              0x090D010E
#define RNDIS_OID_WW_CDPD_TEI                           0x090D010F
#define RNDIS_OID_WW_CDPD_RSSI                          0x090D0110

//
// Network Dependent - Ardis:
//

#define RNDIS_OID_WW_ARD_SNDCP                          0x09110101
#define RNDIS_OID_WW_ARD_TMLY_MSG                       0x09110102
#define RNDIS_OID_WW_ARD_DATAGRAM                       0x09110103

//
// Network Dependent - DataTac:
//

#define RNDIS_OID_WW_TAC_COMPRESSION                    0x09150101
#define RNDIS_OID_WW_TAC_SET_CONFIG                     0x09150102
#define RNDIS_OID_WW_TAC_GET_STATUS                     0x09150103
#define RNDIS_OID_WW_TAC_USER_HEADER                    0x09150104

//
// Network Dependent - Metricom:
//

#define RNDIS_OID_WW_MET_FUNCTION                       0x09190101

//
// IRDA objects
//
#define RNDIS_OID_IRDA_RECEIVING                        0x0A010100
#define RNDIS_OID_IRDA_TURNAROUND_TIME                  0x0A010101
#define RNDIS_OID_IRDA_SUPPORTED_SPEEDS                 0x0A010102
#define RNDIS_OID_IRDA_LINK_SPEED                       0x0A010103
#define RNDIS_OID_IRDA_MEDIA_BUSY                       0x0A010104

#define RNDIS_OID_IRDA_EXTRA_RCV_BOFS                   0x0A010200
#define RNDIS_OID_IRDA_RATE_SNIFF                       0x0A010201
#define RNDIS_OID_IRDA_UNICAST_LIST                     0x0A010202
#define RNDIS_OID_IRDA_MAX_UNICAST_LIST_SIZE            0x0A010203



//
// Remote NDIS message types
//
#define REMOTE_NDIS_PACKET_MSG                  0x00000001
#define REMOTE_NDIS_INITIALIZE_MSG              0x00000002
#define REMOTE_NDIS_HALT_MSG                    0x00000003
#define REMOTE_NDIS_QUERY_MSG                   0x00000004
#define REMOTE_NDIS_SET_MSG                     0x00000005
#define REMOTE_NDIS_RESET_MSG                   0x00000006
#define REMOTE_NDIS_INDICATE_STATUS_MSG         0x00000007
#define REMOTE_NDIS_KEEPALIVE_MSG               0x00000008

#define REMOTE_CONDIS_MP_CREATE_VC_MSG          0x00008001
#define REMOTE_CONDIS_MP_DELETE_VC_MSG          0x00008002
#define REMOTE_CONDIS_MP_ACTIVATE_VC_MSG        0x00008005
#define REMOTE_CONDIS_MP_DEACTIVATE_VC_MSG      0x00008006
#define REMOTE_CONDIS_INDICATE_STATUS_MSG       0x00008007


// Remote NDIS message completion types
#define REMOTE_NDIS_INITIALIZE_CMPLT            0x80000002
#define REMOTE_NDIS_QUERY_CMPLT                 0x80000004
#define REMOTE_NDIS_SET_CMPLT                   0x80000005
#define REMOTE_NDIS_RESET_CMPLT                 0x80000006
#define REMOTE_NDIS_KEEPALIVE_CMPLT             0x80000008

#define REMOTE_CONDIS_MP_CREATE_VC_CMPLT        0x80008001
#define REMOTE_CONDIS_MP_DELETE_VC_CMPLT        0x80008002
#define REMOTE_CONDIS_MP_ACTIVATE_VC_CMPLT      0x80008005
#define REMOTE_CONDIS_MP_DEACTIVATE_VC_CMPLT    0x80008006

//
// Reserved message type for private communication between lower-layer
// host driver and remote device, if necessary.
//
#define REMOTE_NDIS_BUS_MSG                     0xff000001



//
//  Defines for DeviceFlags in RNDIS_INITIALIZE_COMPLETE
//
#define RNDIS_DF_CONNECTIONLESS             0x00000001
#define RNDIS_DF_CONNECTION_ORIENTED        0x00000002
#define RNDIS_DF_RAW_DATA                   0x00000004

//
//  Remote NDIS medium types.
//
#define RNdisMedium802_3                    0x00000000
#define RNdisMedium802_5                    0x00000001
#define RNdisMediumFddi                     0x00000002
#define RNdisMediumWan                      0x00000003
#define RNdisMediumLocalTalk                0x00000004
#define RNdisMediumArcnetRaw                0x00000006
#define RNdisMediumArcnet878_2              0x00000007
#define RNdisMediumAtm                      0x00000008
#define RNdisMediumWirelessWan              0x00000009
#define RNdisMediumIrda                     0x0000000a
#define RNdisMediumCoWan                    0x0000000b
#define RNdisMediumMax                      0x0000000d     // Not a real medium, defined as an upper-bound

//
// Remote NDIS medium connection states.
//
#define RNdisMediaStateConnected            0x00000000
#define RNdisMediaStateDisconnected         0x00000001

//
//  Remote NDIS version numbers
//
#define RNDIS_MAJOR_VERSION                 0x00000001
#define RNDIS_MINOR_VERSION                 0x00000000

//
//  NdisInitialize message
//
typedef struct _RNDIS_INITIALIZE_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    UINT32                                  MajorVersion;
    UINT32                                  MinorVersion;
    UINT32                                  MaxTransferSize;
} RNDIS_INITIALIZE_REQUEST, *PRNDIS_INITIALIZE_REQUEST;


//
//  Response to NdisInitialize
//
typedef struct _RNDIS_INITIALIZE_COMPLETE 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
    UINT32                                  MajorVersion;
    UINT32                                  MinorVersion;
    UINT32                                  DeviceFlags;
    RNDIS_MEDIUM                            Medium;
    UINT32                                  MaxPacketsPerMessage;
    UINT32                                  MaxTransferSize;
    UINT32                                  PacketAlignmentFactor;
    UINT32                                  AFListOffset;
    UINT32                                  AFListSize;
} RNDIS_INITIALIZE_COMPLETE, *PRNDIS_INITIALIZE_COMPLETE;


//
//  Call manager devices only: Information about an address family
//  supported by the device is appended to the response to NdisInitialize.
//
typedef struct _RNDIS_CO_ADDRESS_FAMILY
{
    RNDIS_AF                                AddressFamily;
    UINT32                                  MajorVersion;
    UINT32                                  MinorVersion;
} RNDIS_CO_ADDRESS_FAMILY, *PRNDIS_CO_ADDRESS_FAMILY;


//
//  NdisHalt message
//
typedef struct _RNDIS_HALT_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
} RNDIS_HALT_REQUEST, *PRNDIS_HALT_REQUEST;


//
// NdisQueryRequest message
//
typedef struct _RNDIS_QUERY_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_OID                               Oid;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
    RNDIS_HANDLE                            DeviceVcHandle;
} RNDIS_QUERY_REQUEST, *PRNDIS_QUERY_REQUEST;


//
//  Response to NdisQueryRequest
//
typedef struct _RNDIS_QUERY_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
} RNDIS_QUERY_COMPLETE, *PRNDIS_QUERY_COMPLETE;


//
//  NdisSetRequest message
//
typedef struct _RNDIS_SET_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_OID                               Oid;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
    RNDIS_HANDLE                            DeviceVcHandle;
} RNDIS_SET_REQUEST, *PRNDIS_SET_REQUEST;


//
//  Response to NdisSetRequest
//
typedef struct _RNDIS_SET_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RNDIS_SET_COMPLETE, *PRNDIS_SET_COMPLETE;


//
//  NdisReset message
//
typedef struct _RNDIS_RESET_REQUEST
{
    UINT32                                  Reserved;
} RNDIS_RESET_REQUEST, *PRNDIS_RESET_REQUEST;

//
//  Response to NdisReset
//
typedef struct _RNDIS_RESET_COMPLETE
{
    RNDIS_STATUS                            Status;
    UINT32                                  AddressingReset;
} RNDIS_RESET_COMPLETE, *PRNDIS_RESET_COMPLETE;


//
//  NdisMIndicateStatus message
//
typedef struct _RNDIS_INDICATE_STATUS
{
    RNDIS_STATUS                            Status;
    UINT32                                  StatusBufferLength;
    UINT32                                  StatusBufferOffset;
} RNDIS_INDICATE_STATUS, *PRNDIS_INDICATE_STATUS;


//
//  Diagnostic information passed as the status buffer in
//  RNDIS_INDICATE_STATUS messages signifying error conditions.
//
typedef struct _RNDIS_DIAGNOSTIC_INFO
{
    RNDIS_STATUS                            DiagStatus;
    UINT32                                  ErrorOffset;
} RNDIS_DIAGNOSTIC_INFO, *PRNDIS_DIAGNOSTIC_INFO;



//
//  NdisKeepAlive message
//
typedef struct _RNDIS_KEEPALIVE_REQUEST
{
    RNDIS_REQUEST_ID                        RequestId;
} RNDIS_KEEPALIVE_REQUEST, *PRNDIS_KEEPALIVE_REQUEST;


//
// Response to NdisKeepAlive
//  
typedef struct _RNDIS_KEEPALIVE_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RNDIS_KEEPALIVE_COMPLETE, *PRNDIS_KEEPALIVE_COMPLETE;


//
//  Data message. All Offset fields contain byte offsets from the beginning
//  of the RNDIS_PACKET structure. All Length fields are in bytes.
//  VcHandle is set to 0 for connectionless data, otherwise it
//  contains the VC handle.
//
typedef struct _RNDIS_PACKET
{
    UINT32                                  DataOffset;
    UINT32                                  DataLength;
    UINT32                                  OOBDataOffset;
    UINT32                                  OOBDataLength;
    UINT32                                  NumOOBDataElements;
    UINT32                                  PerPacketInfoOffset;
    UINT32                                  PerPacketInfoLength;
    RNDIS_HANDLE                            VcHandle;
    UINT32                                  Reserved;
} RNDIS_PACKET, *PRNDIS_PACKET;

//
//  Optional Out of Band data associated with a Data message.
//
typedef struct _RNDIS_OOBD
{
    UINT32                                  Size;
    RNDIS_CLASS_ID                          Type;
    UINT32                                  ClassInformationOffset;
} RNDIS_OOBD, *PRNDIS_OOBD;

//
//  Packet extension field contents associated with a Data message.
//
typedef struct _RNDIS_PER_PACKET_INFO
{
    UINT32                                  Size;
    UINT32                                  Type;
    UINT32                                  PerPacketInformationOffset;
} RNDIS_PER_PACKET_INFO, *PRNDIS_PER_PACKET_INFO;


//
//  Format of Information buffer passed in a SetRequest for the OID
//  OID_GEN_RNDIS_CONFIG_PARAMETER.
//
typedef struct _RNDIS_CONFIG_PARAMETER_INFO
{
    UINT32                                  ParameterNameOffset;
    UINT32                                  ParameterNameLength;
    UINT32                                  ParameterType;
    UINT32                                  ParameterValueOffset;
    UINT32                                  ParameterValueLength;
} RNDIS_CONFIG_PARAMETER_INFO, *PRNDIS_CONFIG_PARAMETER_INFO;

//
//  Values for ParameterType in RNDIS_CONFIG_PARAMETER_INFO
//
#define RNDIS_CONFIG_PARAM_TYPE_INTEGER     0
#define RNDIS_CONFIG_PARAM_TYPE_STRING      2


//
//  CONDIS Miniport messages for connection oriented devices
//  that do not implement a call manager.
//

//
//  CoNdisMiniportCreateVc message
//
typedef struct _RCONDIS_MP_CREATE_VC 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_HANDLE                            NdisVcHandle;
} RCONDIS_MP_CREATE_VC, *PRCONDIS_MP_CREATE_VC;

//
//  Response to CoNdisMiniportCreateVc
//
typedef struct _RCONDIS_MP_CREATE_VC_COMPLETE 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_HANDLE                            DeviceVcHandle;
    RNDIS_STATUS                            Status;
} RCONDIS_MP_CREATE_VC_COMPLETE, *PRCONDIS_MP_CREATE_VC_COMPLETE;


//
//  CoNdisMiniportDeleteVc message
//
typedef struct _RCONDIS_MP_DELETE_VC 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_HANDLE                            DeviceVcHandle;
} RCONDIS_MP_DELETE_VC, *PRCONDIS_MP_DELETE_VC;

//
//  Response to CoNdisMiniportDeleteVc
//
typedef struct _RCONDIS_MP_DELETE_VC_COMPLETE 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RCONDIS_MP_DELETE_VC_COMPLETE, *PRCONDIS_MP_DELETE_VC_COMPLETE;


//
//  CoNdisMiniportQueryRequest message
//
typedef struct _RCONDIS_MP_QUERY_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_REQUEST_TYPE                      RequestType;
    RNDIS_OID                               Oid;
    RNDIS_HANDLE                            DeviceVcHandle;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
} RCONDIS_MP_QUERY_REQUEST, *PRCONDIS_MP_QUERY_REQUEST;


//
//  CoNdisMiniportSetRequest message
//
typedef struct _RCONDIS_MP_SET_REQUEST 
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_REQUEST_TYPE                      RequestType;
    RNDIS_OID                               Oid;
    RNDIS_HANDLE                            DeviceVcHandle;
    UINT32                                  InformationBufferLength;
    UINT32                                  InformationBufferOffset;
} RCONDIS_MP_SET_REQUEST, *PRCONDIS_MP_SET_REQUEST;


//
//  CoNdisIndicateStatus message
//
typedef struct _RCONDIS_INDICATE_STATUS
{
    RNDIS_HANDLE                            NdisVcHandle;
    RNDIS_STATUS                            Status;
    UINT32                                  StatusBufferLength;
    UINT32                                  StatusBufferOffset;
} RCONDIS_INDICATE_STATUS, *PRCONDIS_INDICATE_STATUS;


//
//  CONDIS Call/VC parameters
//

typedef struct _RCONDIS_SPECIFIC_PARAMETERS
{
    UINT32                                  ParameterType;
    UINT32                                  ParameterLength;
    UINT32                                  ParameterOffset;
} RCONDIS_SPECIFIC_PARAMETERS, *PRCONDIS_SPECIFIC_PARAMETERS;

typedef struct _RCONDIS_MEDIA_PARAMETERS
{
    UINT32                                  Flags;
    UINT32                                  Reserved1;
    UINT32                                  Reserved2;
    RCONDIS_SPECIFIC_PARAMETERS             MediaSpecific;
} RCONDIS_MEDIA_PARAMETERS, *PRCONDIS_MEDIA_PARAMETERS;


typedef struct _RNDIS_FLOWSPEC
{
    UINT32                                  TokenRate;
    UINT32                                  TokenBucketSize;
    UINT32                                  PeakBandwidth;
    UINT32                                  Latency;
    UINT32                                  DelayVariation;
    UINT32                                  ServiceType;
    UINT32                                  MaxSduSize;
    UINT32                                  MinimumPolicedSize;
} RNDIS_FLOWSPEC, *PRNDIS_FLOWSPEC;

typedef struct _RCONDIS_CALL_MANAGER_PARAMETERS
{
    RNDIS_FLOWSPEC                          Transmit;
    RNDIS_FLOWSPEC                          Receive;
    RCONDIS_SPECIFIC_PARAMETERS             CallMgrSpecific;
} RCONDIS_CALL_MANAGER_PARAMETERS, *PRCONDIS_CALL_MANAGER_PARAMETERS;

//
//  CoNdisMiniportActivateVc message
//
typedef struct _RCONDIS_MP_ACTIVATE_VC_REQUEST
{
    RNDIS_REQUEST_ID                        RequestId;
    UINT32                                  Flags;
    RNDIS_HANDLE                            DeviceVcHandle;
    UINT32                                  MediaParamsOffset;
    UINT32                                  MediaParamsLength;
    UINT32                                  CallMgrParamsOffset;
    UINT32                                  CallMgrParamsLength;
} RCONDIS_MP_ACTIVATE_VC_REQUEST, *PRCONDIS_MP_ACTIVATE_VC_REQUEST;

//
//  Response to CoNdisMiniportActivateVc
//
typedef struct _RCONDIS_MP_ACTIVATE_VC_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RCONDIS_MP_ACTIVATE_VC_COMPLETE, *PRCONDIS_MP_ACTIVATE_VC_COMPLETE;


//
//  CoNdisMiniportDeactivateVc message
//
typedef struct _RCONDIS_MP_DEACTIVATE_VC_REQUEST
{
    RNDIS_REQUEST_ID                        RequestId;
    UINT32                                  Flags;
    RNDIS_HANDLE                            DeviceVcHandle;
} RCONDIS_MP_DEACTIVATE_VC_REQUEST, *PRCONDIS_MP_DEACTIVATE_VC_REQUEST;

//
//  Response to CoNdisMiniportDeactivateVc
//
typedef struct _RCONDIS_MP_DEACTIVATE_VC_COMPLETE
{
    RNDIS_REQUEST_ID                        RequestId;
    RNDIS_STATUS                            Status;
} RCONDIS_MP_DEACTIVATE_VC_COMPLETE, *PRCONDIS_MP_DEACTIVATE_VC_COMPLETE;


//
// union with all of the RNDIS messages
//
typedef union _RNDIS_MESSAGE_CONTAINER
{
    RNDIS_PACKET                        Packet;
    RNDIS_INITIALIZE_REQUEST            InitializeRequest;
    RNDIS_HALT_REQUEST                  HaltRequest;
    RNDIS_QUERY_REQUEST                 QueryRequest;
    RNDIS_SET_REQUEST                   SetRequest;
    RNDIS_RESET_REQUEST                 ResetRequest;
    RNDIS_KEEPALIVE_REQUEST             KeepaliveRequest;
    RNDIS_INDICATE_STATUS               IndicateStatus;
    RNDIS_INITIALIZE_COMPLETE           InitializeComplete;
    RNDIS_QUERY_COMPLETE                QueryComplete;
    RNDIS_SET_COMPLETE                  SetComplete;
    RNDIS_RESET_COMPLETE                ResetComplete;
    RNDIS_KEEPALIVE_COMPLETE            KeepaliveComplete;
    RCONDIS_MP_CREATE_VC                CoMiniportCreateVc;
    RCONDIS_MP_DELETE_VC                CoMiniportDeleteVc;
    RCONDIS_INDICATE_STATUS             CoIndicateStatus;
    RCONDIS_MP_ACTIVATE_VC_REQUEST      CoMiniportActivateVc;
    RCONDIS_MP_DEACTIVATE_VC_REQUEST    CoMiniportDeactivateVc;
    RCONDIS_MP_CREATE_VC_COMPLETE       CoMiniportCreateVcComplete;
    RCONDIS_MP_DELETE_VC_COMPLETE       CoMiniportDeleteVcComplete;
    RCONDIS_MP_ACTIVATE_VC_COMPLETE     CoMiniportActivateVcComplete;
    RCONDIS_MP_DEACTIVATE_VC_COMPLETE   CoMiniportDeactivateVcComplete;


} RNDIS_MESSAGE_CONTAINER, *PRNDIS_MESSAGE_CONTAINER;

//
// Remote NDIS message format
//
typedef struct _RNDIS_MESSAGE 
{
    UINT32                                  NdisMessageType;

    //
    // Total length of this message, from the beginning
    // of the RNDIS_MESSAGE struct, in bytes.
    //
    UINT32                                  MessageLength;

    // Actual message
    RNDIS_MESSAGE_CONTAINER                 Message;

} RNDIS_MESSAGE, *PRNDIS_MESSAGE;



//
// Handy macros

// get the size of an RNDIS message. Pass in the message type, 
// RNDIS_SET_REQUEST, RNDIS_PACKET for example
#define RNDIS_MESSAGE_SIZE(Message)                             \
    (sizeof(Message) + (sizeof(RNDIS_MESSAGE) - sizeof(RNDIS_MESSAGE_CONTAINER)))

// get pointer to info buffer with message pointer
#define MESSAGE_TO_INFO_BUFFER(Message)                         \
    (((PUCHAR)(Message)) + Message->InformationBufferOffset)

// get pointer to status buffer with message pointer
#define MESSAGE_TO_STATUS_BUFFER(Message)                       \
    (((PUCHAR)(Message)) + Message->StatusBufferOffset)

// get pointer to OOBD buffer with message pointer
#define MESSAGE_TO_OOBD_BUFFER(Message)                         \
    (((PUCHAR)(Message)) + Message->OOBDataOffset)

// get pointer to data buffer with message pointer
#define MESSAGE_TO_DATA_BUFFER(Message)                         \
    (((PUCHAR)(Message)) + Message->PerPacketInfoOffset)

// get pointer to contained message from NDIS_MESSAGE pointer
#define RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(RndisMessage)          \
    ((PVOID) &RndisMessage->Message)

// get pointer to contained message from NDIS_MESSAGE pointer
#define RNDIS_MESSAGE_RAW_PTR_TO_MESSAGE_PTR(RndisMessage)      \
    ((PVOID) RndisMessage)

#endif // _RNDIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\debug.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    DEBUG.C

Abstract:

    Debug routines

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    6/6/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"

#if DBG

// this is for translating a code into an ASCII string
typedef struct Code2Ascii
{
	NDIS_OID				Oid;
	PCHAR					OidName;
} Code2Ascii;


static Code2Ascii OidList[] =
{
    OID_GEN_SUPPORTED_LIST,                 "OID_GEN_SUPPORTED_LIST",
    OID_GEN_HARDWARE_STATUS,                "OID_GEN_HARDWARE_STATUS",
    OID_GEN_MEDIA_SUPPORTED,                "OID_GEN_MEDIA_SUPPORTED",
    OID_GEN_MEDIA_IN_USE,                   "OID_GEN_MEDIA_IN_USE",
    OID_GEN_MAXIMUM_LOOKAHEAD,              "OID_GEN_MAXIMUM_LOOKAHEAD",
    OID_GEN_MAXIMUM_FRAME_SIZE,             "OID_GEN_MAXIMUM_FRAME_SIZE",
    OID_GEN_LINK_SPEED,                     "OID_GEN_LINK_SPEED",
    OID_GEN_TRANSMIT_BUFFER_SPACE,          "OID_GEN_TRANSMIT_BUFFER_SPACE",
    OID_GEN_RECEIVE_BUFFER_SPACE,           "OID_GEN_RECEIVE_BUFFER_SPACE",
    OID_GEN_TRANSMIT_BLOCK_SIZE,            "OID_GEN_TRANSMIT_BLOCK_SIZE",
    OID_GEN_RECEIVE_BLOCK_SIZE,             "OID_GEN_RECEIVE_BLOCK_SIZE",
    OID_GEN_VENDOR_ID,                      "OID_GEN_VENDOR_ID",
    OID_GEN_VENDOR_DESCRIPTION,             "OID_GEN_VENDOR_DESCRIPTION",
    OID_GEN_CURRENT_PACKET_FILTER,          "OID_GEN_CURRENT_PACKET_FILTER",
    OID_GEN_TRANSPORT_HEADER_OFFSET,        "OID_GEN_TRANSPORT_HEADER_OFFSET",
    OID_GEN_CURRENT_LOOKAHEAD,              "OID_GEN_CURRENT_LOOKAHEAD",
    OID_GEN_DRIVER_VERSION,                 "OID_GEN_DRIVER_VERSION",
    OID_GEN_VENDOR_DRIVER_VERSION,          "OID_GEN_VENDOR_DRIVER_VERSION",
    OID_GEN_MAXIMUM_TOTAL_SIZE,             "OID_GEN_MAXIMUM_TOTAL_SIZE",
    OID_GEN_PROTOCOL_OPTIONS,               "OID_GEN_PROTOCOL_OPTIONS",
    OID_GEN_MAC_OPTIONS,                    "OID_GEN_MAC_OPTIONS",
    OID_GEN_MEDIA_CONNECT_STATUS,           "OID_GEN_MEDIA_CONNECT_STATUS",
    OID_GEN_MAXIMUM_SEND_PACKETS,           "OID_GEN_MAXIMUM_SEND_PACKETS",
    OID_GEN_SUPPORTED_GUIDS,                "OID_GEN_SUPPORTED_GUIDS",
    OID_GEN_XMIT_OK,                        "OID_GEN_XMIT_OK",
    OID_GEN_RCV_OK,                         "OID_GEN_RCV_OK",
    OID_GEN_XMIT_ERROR,                     "OID_GEN_XMIT_ERROR",
    OID_GEN_RCV_ERROR,                      "OID_GEN_RCV_ERROR",
    OID_GEN_RCV_NO_BUFFER,                  "OID_GEN_RCV_NO_BUFFER",
    OID_GEN_RCV_CRC_ERROR,                  "OID_GEN_RCV_CRC_ERROR",
    OID_GEN_TRANSMIT_QUEUE_LENGTH,          "OID_GEN_TRANSMIT_QUEUE_LENGTH",
    OID_802_3_PERMANENT_ADDRESS,            "OID_802_3_PERMANENT_ADDRESS",
    OID_802_3_CURRENT_ADDRESS,              "OID_802_3_CURRENT_ADDRESS",
    OID_802_3_MULTICAST_LIST,               "OID_802_3_MULTICAST_LIST",
    OID_802_3_MAXIMUM_LIST_SIZE,            "OID_802_3_MAXIMUM_LIST_SIZE",
    OID_802_3_RCV_ERROR_ALIGNMENT,          "OID_802_3_RCV_ERROR_ALIGNMENT",
    OID_802_3_XMIT_ONE_COLLISION,           "OID_802_3_XMIT_ONE_COLLISION",
    OID_802_3_XMIT_MORE_COLLISIONS,         "OID_802_3_XMIT_MORE_COLLISIONS",
    OID_802_3_XMIT_DEFERRED,                "OID_802_3_XMIT_DEFERRED",
    OID_802_3_XMIT_MAX_COLLISIONS,          "OID_802_3_XMIT_MAX_COLLISIONS",
    OID_802_3_RCV_OVERRUN,                  "OID_802_3_RCV_OVERRUN",
    OID_802_3_XMIT_UNDERRUN,                "OID_802_3_XMIT_UNDERRUN",
    OID_802_3_XMIT_HEARTBEAT_FAILURE,       "OID_802_3_XMIT_HEARTBEAT_FAILURE",
    OID_802_3_XMIT_TIMES_CRS_LOST,          "OID_802_3_XMIT_TIMES_CRS_LOST",
    OID_802_3_XMIT_LATE_COLLISIONS,         "OID_802_3_XMIT_LATE_COLLISIONS",
    OID_802_3_MAC_OPTIONS,                  "OID_802_3_MAC_OPTIONS",
    OID_TCP_TASK_OFFLOAD,                   "OID_TCP_TASK_OFFLOAD",
    OID_PNP_CAPABILITIES,                   "OID_PNP_CAPABILITIES",
    OID_PNP_SET_POWER,                      "OID_PNP_SET_POWER",
    OID_PNP_QUERY_POWER,                    "OID_PNP_QUERY_POWER",
    OID_PNP_ADD_WAKE_UP_PATTERN,            "OID_PNP_ADD_WAKE_UP_PATTERN",
    OID_PNP_REMOVE_WAKE_UP_PATTERN,         "OID_PNP_REMOVE_WAKE_UP_PATTERN",
    OID_PNP_ENABLE_WAKE_UP,                 "OID_PNP_ENABLE_WAKE_UP"
};


static UINT NumOid = sizeof(OidList) / sizeof(Code2Ascii);


//
// Debug level
//
UINT            RndismpDebugFlags = DBG_LEVEL0 | DBG_LEVEL1; // | DBG_LEVEL2; // | DBG_DUMP; // | DBG_OID_LIST;


/****************************************************************************/
/*                          GetOidName                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Returns string with OID name                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Oid - OID to find                                                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PCHAR                                                                   */
/*                                                                          */
/****************************************************************************/
PCHAR
GetOidName(IN NDIS_OID Oid)
{
    UINT Index;

    // see if the matching Oid and string are in the list
    for(Index = 0; Index < NumOid; Index++)
    {
        if(Oid == OidList[Index].Oid)
        {
            return OidList[Index].OidName;
        }
    }

    DbgPrint("GetOidName: unknown OID %x\n", Oid);
    return "Unknown OID";

} // GetOidName


/****************************************************************************/
/*                          DisplayOidList                                  */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Prints list of supported OIDs and whether they are supported in         */
/*  the device or driver                                                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
DisplayOidList(IN PRNDISMP_ADAPTER Adapter)
{
    ASSERT(Adapter->SupportedOIDList);

    ASSERT(Adapter->OIDHandlerList);

    if(RndismpDebugFlags & DBG_OID_LIST)
    {
        UINT Index;

        for(Index = 0;Index < Adapter->NumOIDSupported;Index++)
        {
            if(Adapter->OIDHandlerList[Index] == DRIVER_SUPPORTED_OID)
            {
                DbgPrint("Support (%s)  OID (%s)\n", "Driver",
                         GetOidName(Adapter->SupportedOIDList[Index]));
            }
            else if(Adapter->OIDHandlerList[Index] ==
                    DEVICE_SUPPORTED_OID)
            {
                DbgPrint("Support (%s)  OID (%s)\n", "Device",
                         GetOidName(Adapter->SupportedOIDList[Index]));
            }
            else
            {
                DbgPrint("Support (%s)  OID (%s) (%08X)\n", "Unknown",
                         GetOidName(Adapter->SupportedOIDList[Index]),                         
                         Adapter->OIDHandlerList[Index]);
            }
        }
    }
} // DisplayOidList


#define BYTES_PER_LINE				16
#define CHARS_PER_BYTE				 3	// e.g. " 12"

ULONG   MaxHexDumpLength = 0xffff;

VOID
RndisPrintHexDump(PVOID            Pointer,
                  ULONG            Length)
{
    CHAR    DumpArray[BYTES_PER_LINE*CHARS_PER_BYTE+1];
    PCHAR   pBuf;
    PUCHAR  pInBuf;
    ULONG   i;

    pInBuf = (PUCHAR)Pointer;
    pBuf = DumpArray;

    Length = MIN(Length, MaxHexDumpLength);

    for (i = 0; i < Length; i++)
    {
        //
        //  Are we at the end of a line?
        //
        if ((i > 0) && ((i & 0xf) == 0))
        {
            *pBuf = '\0';
            DbgPrint("%s\n", DumpArray);
            pBuf = &DumpArray[0];
        }

        //
        //  Print the address if we are at the start of a new line.
        //
        if ((i & 0xf) == 0)
        {
            DbgPrint("%08x  ", pInBuf);
        }

        //
        //  Convert the current hex byte into a sequence of two chars.
        //
        *pBuf = ' ';
        pBuf++;

        *pBuf = ((*pInBuf) >> 4);
        *pBuf = ((*pBuf > 9)? (*pBuf - 10 + 'a') : (*pBuf + '0'));

        pBuf++;

        *pBuf = ((*pInBuf) & 0x0F);
        *pBuf = ((*pBuf > 9)? (*pBuf - 10 + 'a') : (*pBuf + '0'));

        pBuf++;

        pInBuf++;
    }

    if (Length > 0)
    {
        *pBuf = '\0';
        DbgPrint("%s\n", DumpArray);
    }
}


#define LOG_ENTRY_SIZE      128
#define LOG_BUFFER_SIZE     (2 * PAGE_SIZE)

VOID
RndisLogSendMessage(
    IN  PRNDISMP_ADAPTER        pAdapter,
    IN  PRNDISMP_MESSAGE_FRAME  pMsgFrame)
{
    NDIS_STATUS Status;
    BOOLEAN     bLockAcquired;
    PUCHAR      pMsgData;
    ULONG       CopyLength;
    PUCHAR      pDst;

    bLockAcquired = TRUE;
    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    do
    {
        if (pAdapter->pSendLogBuffer == NULL)
        {
            pAdapter->LogBufferSize = LOG_BUFFER_SIZE;
            Status = MemAlloc(&pAdapter->pSendLogBuffer, LOG_BUFFER_SIZE);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("Failed to alloc log buffer (%d bytes)\n", LOG_BUFFER_SIZE));
                break;
            }

            pAdapter->pSendLogWrite = pAdapter->pSendLogBuffer;
        }


        pDst = pAdapter->pSendLogWrite;
        pAdapter->pSendLogWrite += LOG_ENTRY_SIZE;
        if (pAdapter->pSendLogWrite >= pAdapter->pSendLogBuffer + pAdapter->LogBufferSize)
        {
            pAdapter->pSendLogWrite = pDst = pAdapter->pSendLogBuffer;
        }

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
        bLockAcquired = FALSE;

        CopyLength = MIN(LOG_ENTRY_SIZE, RNDISMP_GET_MDL_LENGTH(pMsgFrame->pMessageMdl));
        pMsgData = RNDISMP_GET_MDL_ADDRESS(pMsgFrame->pMessageMdl);

        RtlFillMemory(pDst, LOG_ENTRY_SIZE, 0);
        RNDISMP_MOVE_MEM(pDst, pMsgData, CopyLength);

    }
    while (FALSE);

    if (bLockAcquired)
    {
        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\precomp.h ===
#include "ndis.h"
#include "rndisioc.h"
#include "rndis.h"
#include "rndisapi.h"
#include "rndismp.h"
#include "rmdat.h"
#include "queue.h"
#include "wmiguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\init.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    INIT.C

Abstract:

    Remote NDIS Miniport driver initialization code

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/13/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"

extern ULONG    MsgFrameAllocs;

/****************************************************************************/
/*                          SetupSendQueues                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Set up queues for sending packets to microport                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
SetupSendQueues(IN PRNDISMP_ADAPTER Adapter)
{
    NdisInitializeNPagedLookasideList(
        &Adapter->MsgFramePool,
        NULL,
        NULL,
        0,
        sizeof(RNDISMP_MESSAGE_FRAME),
        RNDISMP_TAG_SEND_FRAME,
        0);

    Adapter->MsgFramePoolAlloced = TRUE;

    return NDIS_STATUS_SUCCESS;
} // SetupSendQueues


/****************************************************************************/
/*                          SetupReceiveQueues                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate resources for receiving packets from the microport             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
SetupReceiveQueues(IN PRNDISMP_ADAPTER Adapter)
{
    NDIS_STATUS                 AllocationStatus;
    UINT                        Index;

    TRACE2(("SetupReceiveQueues\n"));


    do
    {
        Adapter->InitialReceiveFrames = INITIAL_RECEIVE_FRAMES;
        Adapter->MaxReceiveFrames = MAX_RECEIVE_FRAMES;

        // Set up a pool of receive data frame structures
        NdisInitializeNPagedLookasideList(
            &Adapter->RcvFramePool,
            NULL,
            NULL,
            0,
            sizeof(RNDISMP_RECV_DATA_FRAME),
            RNDISMP_TAG_RECV_DATA_FRAME,
            0);

        Adapter->RcvFramePoolAlloced = TRUE;

        // Set up a pool of packets for indicating groups of packets to NDIS
        NdisAllocatePacketPoolEx(&AllocationStatus,
                                 &Adapter->ReceivePacketPool,
                                 Adapter->InitialReceiveFrames,
                                 Adapter->MaxReceiveFrames,
                                 NUM_BYTES_PROTOCOL_RESERVED_SECTION);

        if (AllocationStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE2(("NdisAllocatePacketPool failed (%08X)\n", AllocationStatus));
            break;
        }

        // Set up our pool of buffer descriptors one per packet
        NdisAllocateBufferPool(&AllocationStatus,
                               &Adapter->ReceiveBufferPool,
                               Adapter->MaxReceiveFrames);

        if (AllocationStatus != NDIS_STATUS_SUCCESS)
        {
            TRACE2(("NdisAllocateBufferPool failed (%08X)\n", AllocationStatus));
            break;
        }

    }
    while (FALSE);

    if (AllocationStatus != NDIS_STATUS_SUCCESS)
    {
        FreeReceiveResources(Adapter);
    }

    return AllocationStatus;

} // SetupReceiveQueues



/****************************************************************************/
/*                          AllocateTransportResources                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate resources for transmit, receive, and requests                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
AllocateTransportResources(IN PRNDISMP_ADAPTER Adapter)
{
    NDIS_STATUS Status;

    TRACE2(("AllocateTransportResources\n"));

    Status = SetupSendQueues(Adapter);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        goto AllocateDone;
    }
    
    Status = SetupReceiveQueues(Adapter);

    if(Status != NDIS_STATUS_SUCCESS)
    {
        FreeSendResources(Adapter);
        goto AllocateDone;
    }
    
AllocateDone:
    return Status;
} // AllocateTransportResources

/****************************************************************************/
/*                          FreeTransportResources                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free up resources for transmit, receive, and requests                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeTransportResources(IN PRNDISMP_ADAPTER Adapter)
{
    TRACE2(("FreeTransportResources\n"));

    FreeSendResources(Adapter);
    FreeReceiveResources(Adapter);
} // FreeTransportResources

/****************************************************************************/
/*                          FreeSendResources                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free up resources for sending packets                                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeSendResources(IN PRNDISMP_ADAPTER Adapter)
{

    TRACE3(("FreeSendResources\n"));

    if (Adapter->MsgFramePoolAlloced)
    {
        NdisDeleteNPagedLookasideList(&Adapter->MsgFramePool);
        Adapter->MsgFramePoolAlloced = FALSE;
    }

} // FreeSendResources


/****************************************************************************/
/*                          FreeReceiveResources                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free up resources allocated for receiving packets                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeReceiveResources(IN PRNDISMP_ADAPTER Adapter)
{
    UINT                    Index;
    UINT                    Size;
    PUCHAR                  Buffer;

    TRACE3(("FreeReceiveResources\n"));

    // free up buffer pool
    if (Adapter->ReceiveBufferPool)
    {
        NdisFreeBufferPool(Adapter->ReceiveBufferPool);
        Adapter->ReceiveBufferPool = NULL;
    }
    
    // free up packet pool
    if (Adapter->ReceivePacketPool)
    {
        NdisFreePacketPool(Adapter->ReceivePacketPool);
        Adapter->ReceivePacketPool = NULL;
    }

    // delete receive data frame pool.
    if (Adapter->RcvFramePoolAlloced)
    {
        NdisDeleteNPagedLookasideList(&Adapter->RcvFramePool);
        Adapter->RcvFramePoolAlloced = FALSE;
    }

} // FreeReceiveResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\receive.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RECEIVE.C

Abstract:

    Packet and message receive routines

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/20/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"


//
//  Some debug stuff, not critical to operation:
//
ULONG   RcvFrameAllocs = 0;
ULONG   RcvTimerCount = 0;
ULONG   RcvPacketCount = 0;
ULONG   RcvMaxPackets = 0;
ULONG   RcvIndicateCount = 0;
ULONG   RcvReturnCount = 0;

//
//  For raw encapsulation test
//

extern ULONG gRawEncap;

/****************************************************************************/
/*                          RndismpGetReturnedPackets                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  This function is called by NDIS to return to our possession a packet    */
/*  that we had indicated up.                                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  pNdisPacket - the packet that is being freed                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RndismpReturnPacket(IN NDIS_HANDLE    MiniportAdapterContext,
                    IN PNDIS_PACKET   pNdisPacket)
{
    PRNDISMP_ADAPTER            pAdapter;
    PRNDISMP_RECV_PKT_RESERVED  pRcvResvd;
    PRNDISMP_RECV_DATA_FRAME    pRcvFrame;
    PRNDISMP_VC                 pVc;
    PNDIS_BUFFER                pNdisBuffer;
    ULONG                       RefCount;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE2(("RndismpReturnPacket: Adapter %x, Pkt %x\n", pAdapter, pNdisPacket));

    // get receive frame context
    pRcvResvd = PRNDISMP_RESERVED_FROM_RECV_PACKET(pNdisPacket);
    pRcvFrame = pRcvResvd->pRcvFrame;
    pVc = pRcvResvd->pVc;

    // Free the buffer.
    NdisQueryPacket(pNdisPacket,
                    NULL,
                    NULL,
                    &pNdisBuffer,
                    NULL);
    
    NdisFreeBuffer(pNdisBuffer);

    DereferenceRcvFrame(pRcvFrame, pAdapter);

    if (pVc != NULL)
    {
        RNDISMP_DEREF_VC(pVc, &RefCount);
    }

    NdisFreePacket(pNdisPacket);
    RcvReturnCount++;

} // RndismpReturnPacket


/****************************************************************************/
/*                          DereferenceRcvFrame                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to deref a receive frame structure, e.g. when a         */
/*  received packet is returned to us from higher layers.                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pRcvFrame - Pointer to receive frame to be deref'ed.                    */
/*  pAdapter - Pointer to adapter structure                                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
DereferenceRcvFrame(IN PRNDISMP_RECV_DATA_FRAME pRcvFrame,
                    IN PRNDISMP_ADAPTER         pAdapter)
{
    ULONG   ReturnsPending;

    ReturnsPending = NdisInterlockedDecrement(&pRcvFrame->ReturnsPending);

    if (ReturnsPending == 0)
    {
        TRACE3(("DerefRcvFrame: Adapter %x, Frame %p, uPcontext %x, LocalCopy %d\n",
                    pAdapter, pRcvFrame, pRcvFrame->MicroportMessageContext, pRcvFrame->bMessageCopy));

        if (pRcvFrame->bMessageCopy)
        {
            FreeRcvMessageCopy(pRcvFrame->pLocalMessageCopy);
        }
        else
        {
            TRACE3(("DerefRcvFrame: uP MDL %x, uPContext %x\n",
                            pRcvFrame->pMicroportMdl,
                            pRcvFrame->MicroportMessageContext));

            RNDISMP_RETURN_TO_MICROPORT(pAdapter,
                                        pRcvFrame->pMicroportMdl,
                                        pRcvFrame->MicroportMessageContext);
        }

        FreeReceiveFrame(pRcvFrame, pAdapter);

    }

} // DereferenceRcvFrame


/****************************************************************************/
/*                          RndisMIndicateReceive                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by microport to indicate receiving RNDIS messages                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  pMdl - pointer to MDL chain describing RNDIS message                    */
/*  MicroportMessageContext - context for message from micorport            */
/*  ChannelType - channel on which this message arrived (control/data)      */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndisMIndicateReceive(IN NDIS_HANDLE        MiniportAdapterContext,
                      IN PMDL               pMdl,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN RM_CHANNEL_TYPE    ChannelType,
                      IN NDIS_STATUS        ReceiveStatus)
{
    PRNDISMP_ADAPTER            Adapter;
    PRNDIS_MESSAGE              pMessage;
    BOOLEAN                     bMessageCopied = FALSE;
    PRNDISMP_MSG_HANDLER_FUNC   pMsgHandlerFunc;
    BOOLEAN                     bReturnToMicroport;
    NDIS_STATUS                 Status;
    PRNDISMP_RECV_MSG_CONTEXT   pRcvMsg;
    PMDL                        pTmpMdl;
    ULONG                       TotalLength;

    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(Adapter);

    TRACE2(("RndisIndicateReceive: Adapter %x, Mdl %x\n", Adapter, pMdl));

    // RNDISMP_ASSERT_AT_DISPATCH(); - not true for InfiniBand.
    bReturnToMicroport = TRUE;

#if DBG
    NdisInterlockedIncrement(&Adapter->MicroportReceivesOutstanding);
#endif

    do
    {
        //
        // Find the total length first.
        //
        TotalLength = 0;
        for (pTmpMdl = pMdl; pTmpMdl != NULL; pTmpMdl = RNDISMP_GET_MDL_NEXT(pTmpMdl))
        {
            TotalLength += RNDISMP_GET_MDL_LENGTH(pTmpMdl);
        }

        //
        // Check if the entire message is in a single MDL - if not, make a copy
        // TBD -- handle multi-MDL messages without copying.
        //
        if ((RNDISMP_GET_MDL_NEXT(pMdl) == NULL) &&
            (!Adapter->bRunningOnWin9x || (ReceiveStatus != NDIS_STATUS_RESOURCES)))
        {
            pMessage = RNDISMP_GET_MDL_ADDRESS(pMdl);
            if (pMessage == NULL)
            {
                TRACE0(("RndisMIndicateReceive: Adapter %x: failed to"
                        " access msg from MDL %x\n", Adapter, pMdl));
                break;
            }
        }
        else
        {
            pMessage = CoalesceMultiMdlMessage(pMdl, TotalLength);
            if (pMessage == NULL)
            {
                break;
            }
            bMessageCopied = TRUE;
        }

        TRACEDUMP(("Received msg (%d bytes):\n", TotalLength),
                     pMessage, TotalLength);

        // get timer tick for this message
        NdisGetSystemUpTime(&Adapter->LastMessageFromDevice);

        if (Adapter->bRunningOnWin9x)
        {
            Status = MemAlloc(&pRcvMsg, sizeof(RNDISMP_RECV_MSG_CONTEXT));

            if (Status != NDIS_STATUS_SUCCESS)
            {
                bReturnToMicroport = TRUE;
                TRACE1(("RndisMIndicateReceive: Adapter %x, failed to alloc rcv msg\n",
                        Adapter));
                break;
            }

            pRcvMsg->MicroportMessageContext = MicroportMessageContext;
            pRcvMsg->pMdl = pMdl;
            pRcvMsg->TotalLength = TotalLength;
            pRcvMsg->pMessage = pMessage;
            pRcvMsg->ReceiveStatus = ReceiveStatus;
            pRcvMsg->bMessageCopied = bMessageCopied;
            pRcvMsg->ChannelType = ChannelType;

            //
            //  Queue all packets for indicating receives up to protocols.
            //  We do this rather than indicate packets directly because
            //  we are in a DPC context, and need to be in a "global event"
            //  context to make the upper layers happy. One way to be in a
            //  global event context is to be in the context of an NDIS timer
            //  callback function.
            //
            //  So, queue this up on the adapter and start a timer
            //  routine if necessary.
            //

            bReturnToMicroport = FALSE;

            RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

            InsertTailList(&Adapter->PendingRcvMessageList, &pRcvMsg->Link);

            if (!Adapter->IndicatingReceives)
            {
                Adapter->IndicatingReceives = TRUE;

                NdisSetTimer(&Adapter->IndicateTimer, 0);
            }

            RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
        }
        else
        {
            //
            //  Running on NT.
           
            if ((Adapter->DeviceFlags & RNDIS_DF_RAW_DATA) || (gRawEncap))
            {
                if (ChannelType == RMC_CONTROL)
                {
                    RNDISMP_GET_MSG_HANDLER(pMsgHandlerFunc,pMessage->NdisMessageType);
#if DBG
                    ASSERT(pMessage->NdisMessageType != REMOTE_NDIS_PACKET_MSG);
#endif
                } else
                {
                    pMsgHandlerFunc = ReceivePacketMessageRaw;
                }
            } else
            {
                RNDISMP_GET_MSG_HANDLER(pMsgHandlerFunc, pMessage->NdisMessageType);
#if DBG
                if (pMessage->NdisMessageType == REMOTE_NDIS_PACKET_MSG)
                {
                    ASSERT(ChannelType == RMC_DATA);
                }
                else
                {
                    ASSERT(ChannelType == RMC_CONTROL);
                }
#endif
	        }

            bReturnToMicroport = (*pMsgHandlerFunc)(
                                    Adapter,
                                    pMessage,
                                    pMdl,
                                    TotalLength,
                                    MicroportMessageContext,
                                    ReceiveStatus,
                                    bMessageCopied);
        }
    }
    while (FALSE);

    //
    // Are we done with the microport's message?
    //
    if (bReturnToMicroport || bMessageCopied)
    {
        RNDISMP_RETURN_TO_MICROPORT(Adapter,
                                    pMdl,
                                    MicroportMessageContext);
    }

    //
    // If we had made a copy of the microport's message, are we done with
    // this copy?
    //
    if (bMessageCopied && bReturnToMicroport)
    {
        FreeRcvMessageCopy(pMessage);
    }
}

/****************************************************************************/
/*                          CoalesceMultiMdlMessage                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Make a copy of a received message that is in a chain of multiple        */
/*  MDLs, into one single buffer.                                           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMdl - pointer to MDL that is the head of the chain.                    */
/*  TotalLength - length of data contained in entire chain.                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDIS_MESSAGE                                                          */
/*                                                                          */
/****************************************************************************/
PRNDIS_MESSAGE
CoalesceMultiMdlMessage(IN PMDL         pMdl,
                        IN ULONG        TotalLength)
{
    ULONG           MdlLength;
    PRNDIS_MESSAGE  pMessage;
    NDIS_STATUS     Status;
    PMDL            pTmpMdl;
    PUCHAR          pDest;

    TRACE2(("Coalesce: Mdl %x\n", pMdl));

    Status = MemAlloc(&pMessage, TotalLength);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        pDest = (PUCHAR)pMessage;
        for (pTmpMdl = pMdl; pTmpMdl != NULL; pTmpMdl = RNDISMP_GET_MDL_NEXT(pTmpMdl))
        {
            MdlLength = RNDISMP_GET_MDL_LENGTH(pTmpMdl);
            RNDISMP_MOVE_MEM(pDest,
                             RNDISMP_GET_MDL_ADDRESS(pTmpMdl),
                             MdlLength);
            pDest = (PUCHAR)pDest + MdlLength;
        }
    }
    else
    {
        pMessage = NULL;
    }

    return (pMessage);
}

/****************************************************************************/
/*                          FreeRcvMessageCopy                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free the local copy of a received RNDIS message.                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMessage - pointer to RNDIS message                                     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeRcvMessageCopy(IN PRNDIS_MESSAGE    pMessage)
{
    TRACE3(("FreeRcvMessageCopy: pMessage %x\n", pMessage));
    MemFree(pMessage, -1);
}

/****************************************************************************/
/*                          ReceivePacketMessage                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Got a packet message, so send it to the upper layers                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceivePacketMessage(IN PRNDISMP_ADAPTER    pAdapter,
                     IN PRNDIS_MESSAGE      pMessage,
                     IN PMDL                pMdl,
                     IN ULONG               TotalLength,
                     IN NDIS_HANDLE         MicroportMessageContext,
                     IN NDIS_STATUS         ReceiveStatus,
                     IN BOOLEAN             bMessageCopied)
{
    ULONG                       LengthRemaining; // in entire message
    PMDL                        pTmpMdl;
    PRNDISMP_RECV_DATA_FRAME    pRcvFrame;
    ULONG                       NumberOfPackets;
    PRNDIS_PACKET               pRndisPacket;
    ULONG                       i;
#define MAX_RECV_PACKETS_IN_MSG     40
    PNDIS_PACKET                PacketArray[MAX_RECV_PACKETS_IN_MSG];
    ULONG                       NumPackets;

    PNDIS_PACKET                pNdisPacket;
    PRNDISMP_RECV_PKT_RESERVED  pRcvResvd;
    PNDIS_BUFFER                pNdisBuffer;
    NDIS_STATUS                 BufferStatus;
    NDIS_STATUS                 Status;
    BOOLEAN                     bDiscardPkt;
    PRNDISMP_VC                 pVc;

    bDiscardPkt = FALSE;
    pVc = NULL;

    do
    {
#ifndef BUILD_WIN9X
        if (bMessageCopied)
        {
            ReceiveStatus = NDIS_STATUS_SUCCESS;
        }
#else
        //
        // Rur ReturnPacket handler never gets called on
        // Win98 Gold, so we force the status to be able
        // to reclaim the indicated packet immediately.
        //
        ReceiveStatus = NDIS_STATUS_RESOURCES;
#endif

        //
        // Allocate a receive frame to keep track of this RNDIS packet message.
        //
        pRcvFrame = AllocateReceiveFrame(pAdapter);

        if (pRcvFrame == NULL)
        {
            bDiscardPkt = TRUE;
            break;
        }

        pRcvFrame->MicroportMessageContext = MicroportMessageContext;
        if (bMessageCopied)
        {
            pRcvFrame->pLocalMessageCopy = pMessage;
            pRcvFrame->bMessageCopy = TRUE;
        }
        else
        {
            pRcvFrame->pMicroportMdl = pMdl;
            pRcvFrame->bMessageCopy = FALSE;
        }

        NumberOfPackets = 0;

        LengthRemaining = TotalLength;

        //
        // TBD - Check that the received message is well-formed!
        //

        //
        //  Temp ref to take care of multiple indications.
        //
        pRcvFrame->ReturnsPending = 1;

        //
        //  Prepare NDIS packets for indicating up. 
        //
        do
        {
            pRndisPacket = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

            //
            // Some sanity checks. TBD - do better checks!
            //
            if ((pMessage->MessageLength > LengthRemaining) ||
                (pMessage->NdisMessageType != REMOTE_NDIS_PACKET_MSG) ||
                (pMessage->MessageLength < RNDIS_MESSAGE_SIZE(RNDIS_PACKET)))
            {
                TRACE1(("ReceivePacketMessage: Msg %x: length %d  or type %x has a problem\n",
                        pMessage, pMessage->MessageLength, pMessage->NdisMessageType));
                ASSERT(FALSE);
                RNDISMP_INCR_STAT(pAdapter, RecvError);
                break;
            }

            if (pRndisPacket->DataLength > pMessage->MessageLength)
            {
                TRACE1(("ReceivePacketMessage: invalid data length (%d) > Msg length (%d)\n",
                    pRndisPacket->DataLength, pMessage->MessageLength));
                RNDISMP_INCR_STAT(pAdapter, RecvError);
                break;
            }

            if (pRndisPacket->VcHandle != 0)
            {
                pVc = LookupVcId(pAdapter, pRndisPacket->VcHandle);
                if (pVc == NULL)
                {
                    TRACE1(("ReceivePacketMessage: invalid Vc handle %x\n", pRndisPacket->VcHandle));
                    RNDISMP_INCR_STAT(pAdapter, RecvError);
                    break;
                }
            }

            //
            // Allocate an NDIS packet to do the indication with.
            //
            NdisAllocatePacket(&Status, &pNdisPacket, pAdapter->ReceivePacketPool);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                pNdisPacket = NULL;

                TRACE2(("ReceivePacketMessage: failed to allocate packet, Adapter %X\n",
                    pAdapter));

                RNDISMP_INCR_STAT(pAdapter, RecvNoBuf);
                break;
            }

            NDIS_SET_PACKET_STATUS(pNdisPacket, ReceiveStatus);

            switch (pAdapter->Medium)
            {
                case NdisMedium802_3:
                    NDIS_SET_PACKET_HEADER_SIZE(pNdisPacket, ETHERNET_HEADER_SIZE);
                    break;
                default:
                    break;
            }

            NdisAllocateBuffer(&BufferStatus,
                               &pNdisBuffer,
                               pAdapter->ReceiveBufferPool,
                               GET_PTR_TO_RNDIS_DATA_BUFF(pRndisPacket),
                               pRndisPacket->DataLength);

            if (BufferStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("ReceivePacketMessage: failed to allocate"
                        " buffer, Adapter %X\n", pAdapter));
                NdisFreePacket(pNdisPacket);
                RNDISMP_INCR_STAT(pAdapter, RecvNoBuf);
                break;
            }

            TRACE2(("Rcv: msg Pkt %d bytes\n", pRndisPacket->DataLength));
            TRACEDUMP(("Rcv %d bytes\n", pRndisPacket->DataLength),
                        GET_PTR_TO_RNDIS_DATA_BUFF(pRndisPacket),
                        MIN(pRndisPacket->DataLength, 32));

            NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

            //
            //  Check if there is per-packet info.
            //
            if (!pAdapter->bRunningOnWin9x)
            {
                PRNDIS_PER_PACKET_INFO  pPerPacketInfo;
                ULONG                   PerPacketInfoLength;

                if (PerPacketInfoLength = pRndisPacket->PerPacketInfoLength)
                {
                    TRACE1(("ReceivePacketMessage: Adapter %p, Pkt %p:"
                        " non-zero perpacket length %d\n",
                        pAdapter, pRndisPacket, PerPacketInfoLength));

                    pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pRndisPacket +
                                        pRndisPacket->PerPacketInfoOffset);

                    while (PerPacketInfoLength != 0)
                    {
                        switch (pPerPacketInfo->Type)
                        {
                            case TcpIpChecksumPacketInfo:
                                NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, TcpIpChecksumPacketInfo) =
                                    UlongToPtr(*(PULONG)((PUCHAR)pPerPacketInfo + pPerPacketInfo->PerPacketInformationOffset));
                                break;

                            case Ieee8021pPriority:
                                NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, Ieee8021pPriority) =
                                    UlongToPtr(*(PULONG)((PUCHAR)pPerPacketInfo + pPerPacketInfo->PerPacketInformationOffset));

                            default:
                                break;
                        }
                        PerPacketInfoLength -= pPerPacketInfo->Size;
                        pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPerPacketInfo +
                                    pPerPacketInfo->Size);
                    }
                }
            }

            //
            // Add this to the array of packets to be indicated up.
            //
            PacketArray[NumberOfPackets] = pNdisPacket;
            NumberOfPackets++;
            RNDISMP_INCR_STAT(pAdapter, RecvOk);

            pRcvResvd = PRNDISMP_RESERVED_FROM_RECV_PACKET(pNdisPacket);
            pRcvResvd->pRcvFrame = pRcvFrame;
            pRcvResvd->pVc = pVc;

            TRACE2(("ReceivePacketMessage: pRndisPkt %X, MsgLen %d,"
                    " DataLen %d, Stat %x, Discard %d\n", 
                        pRndisPacket, pMessage->MessageLength,
                        pRndisPacket->DataLength, ReceiveStatus, bDiscardPkt));

            LengthRemaining -= pMessage->MessageLength;
            pMessage = (PRNDIS_MESSAGE)((ULONG_PTR)pMessage + pMessage->MessageLength);

            NdisInterlockedIncrement(&pRcvFrame->ReturnsPending);

            if ((NumberOfPackets == MAX_RECV_PACKETS_IN_MSG) ||
                (LengthRemaining < RNDIS_MESSAGE_SIZE(RNDIS_PACKET)))
            {
                if (pVc == NULL)
                {
                    RcvIndicateCount += NumberOfPackets;
                    NdisMIndicateReceivePacket(pAdapter->MiniportAdapterHandle,
                                               PacketArray,
                                               NumberOfPackets);
                }
                else
                {
                    IndicateReceiveDataOnVc(pVc, PacketArray, NumberOfPackets);
                }
            
                if (ReceiveStatus == NDIS_STATUS_RESOURCES)
                {
                    for (i = 0; i < NumberOfPackets; i++)
                    {
                        RNDISMP_INCR_STAT(pAdapter, RecvLowRes);
                        RndismpReturnPacket(pAdapter,
                                            PacketArray[i]);
                    }
                }

                NumberOfPackets = 0;
            }
        }
        while (LengthRemaining >= RNDIS_MESSAGE_SIZE(RNDIS_PACKET));


        if (NumberOfPackets != 0)
        {
            //
            //  We bailed out of the above loop. Return what we
            //  have collected so far.
            //
            for (i = 0; i < NumberOfPackets; i++)
            {
                RndismpReturnPacket(pAdapter,
                                    PacketArray[i]);
            }
        }

        //
        //  Remove temp ref we added at the top.
        //
        DereferenceRcvFrame(pRcvFrame, pAdapter);
            
    }
    while (FALSE);

    if (pVc != NULL)
    {
        ULONG       RefCount;

        RNDISMP_DEREF_VC(pVc, &RefCount);
    }

    return (bDiscardPkt);
}

/****************************************************************************/
/*                        ReceivePacketMessageRaw                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Got a packet message, so send it to the upper layers                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ReceivePacketMessageRaw(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied)
{
    ULONG                       LengthRemaining; // in entire message
    PMDL                        pTmpMdl;
    PRNDISMP_RECV_DATA_FRAME    pRcvFrame;
    ULONG                       NumberOfPackets;
    PRNDIS_PACKET               pRndisPacket;
    ULONG                       i;
#define MAX_RECV_PACKETS_IN_MSG     40
    PNDIS_PACKET                PacketArray[MAX_RECV_PACKETS_IN_MSG];
    ULONG                       NumPackets;

    PNDIS_PACKET                pNdisPacket;
    PRNDISMP_RECV_PKT_RESERVED  pRcvResvd;
    PNDIS_BUFFER                pNdisBuffer;
    NDIS_STATUS                 BufferStatus;
    NDIS_STATUS                 Status;
    BOOLEAN                     bDiscardPkt;
    PRNDISMP_VC                 pVc;

    bDiscardPkt = FALSE;
    pVc = NULL;
    pRcvFrame = NULL;

    do
    {
#ifndef BUILD_WIN9X
        if (bMessageCopied)
        {
            ReceiveStatus = NDIS_STATUS_SUCCESS;
        }
#else
        //
        // Rur ReturnPacket handler never gets called on
        // Win98 Gold, so we force the status to be able
        // to reclaim the indicated packet immediately.
        //
        ReceiveStatus = NDIS_STATUS_RESOURCES;
#endif

        //
        // Allocate a receive frame to keep track of this RNDIS packet message.
        //
        pRcvFrame = AllocateReceiveFrame(pAdapter);

        if (pRcvFrame == NULL)
        {
            bDiscardPkt = TRUE;
            break;
        }

        pRcvFrame->MicroportMessageContext = MicroportMessageContext;
        if (bMessageCopied)
        {
            pRcvFrame->pLocalMessageCopy = pMessage;
            pRcvFrame->bMessageCopy = TRUE;
        }
        else
        {
            pRcvFrame->pMicroportMdl = pMdl;
            pRcvFrame->bMessageCopy = FALSE;
        }

        NumberOfPackets = 0;

        LengthRemaining = TotalLength;

        //
        //  Temp ref to take care of multiple indications.
        //
        pRcvFrame->ReturnsPending = 1;

        //
        //  Prepare NDIS packets for indicating up. 
        //
        {
            pRndisPacket = RNDIS_MESSAGE_RAW_PTR_TO_MESSAGE_PTR(pMessage);

            //
            // Allocate an NDIS packet to do the indication with.
            //
            NdisAllocatePacket(&Status, &pNdisPacket, pAdapter->ReceivePacketPool);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                pNdisPacket = NULL;

                TRACE2(("ReceivePacketMessage: failed to allocate packet, Adapter %X\n",
                    pAdapter));

                RNDISMP_INCR_STAT(pAdapter, RecvNoBuf);
                bDiscardPkt = TRUE;
                break;
            }

            NDIS_SET_PACKET_STATUS(pNdisPacket, ReceiveStatus);

            switch (pAdapter->Medium)
            {
                case NdisMedium802_3:
                    NDIS_SET_PACKET_HEADER_SIZE(pNdisPacket, ETHERNET_HEADER_SIZE);
                    break;
                default:
                    break;
            }

            NdisAllocateBuffer(&BufferStatus,
                               &pNdisBuffer,
                               pAdapter->ReceiveBufferPool,
                               pRndisPacket,
                               TotalLength);

            if (BufferStatus != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("ReceivePacketMessage: failed to allocate"
                        " buffer, Adapter %X\n", pAdapter));
                NdisFreePacket(pNdisPacket);
                RNDISMP_INCR_STAT(pAdapter, RecvNoBuf);
                bDiscardPkt = TRUE;
                break;
            }

            TRACE2(("Rcv: msg Pkt %d bytes\n", pMessage->MessageLength));
            TRACEDUMP(("Rcv %d bytes\n", pMessage->MessageLength),
                        pRndisPacket,
						MIN(pMessage->MessageLength, 32));

            NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

            //
            // Add this to the array of packets to be indicated up.
            //
            PacketArray[NumberOfPackets] = pNdisPacket;
            NumberOfPackets++;
            RNDISMP_INCR_STAT(pAdapter, RecvOk);

            pRcvResvd = PRNDISMP_RESERVED_FROM_RECV_PACKET(pNdisPacket);
            pRcvResvd->pRcvFrame = pRcvFrame;
            pRcvResvd->pVc = pVc;

            TRACE1(("ReceivePacketMessageRaw: pRcvFrame %p/%d, pRndisPkt %p,"
                    " DataLen %d, Stat %x, Discard %d\n", 
                        pRcvFrame, pRcvFrame->ReturnsPending,
                        pRndisPacket,
                        pRndisPacket->DataLength, 
						ReceiveStatus, 
						bDiscardPkt));

            LengthRemaining -= pMessage->MessageLength;

            NdisInterlockedIncrement(&pRcvFrame->ReturnsPending);

            NdisMIndicateReceivePacket(pAdapter->MiniportAdapterHandle,
                                       PacketArray,
                                       NumberOfPackets);

            if (ReceiveStatus == NDIS_STATUS_RESOURCES)
            {
                for (i = 0; i < NumberOfPackets; i++)
                {
                    RNDISMP_INCR_STAT(pAdapter, RecvLowRes);
                    RndismpReturnPacket(pAdapter,
                                        PacketArray[i]);
                }
            }

        }

        //
        //  Remove temp ref we added at the top.
        //
        DereferenceRcvFrame(pRcvFrame, pAdapter);
            
    }
    while (FALSE);

    if (bDiscardPkt)
    {
    	//
    	//  Some failure occured above.
    	//
    	if (pRcvFrame != NULL)
    	{
	        FreeReceiveFrame(pRcvFrame, pAdapter);
	    }
	}

    return (bDiscardPkt);
}

/****************************************************************************/
/*                          IndicateStatusMessage                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Got an indicate status message, so send to upper layers                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
IndicateStatusMessage(IN PRNDISMP_ADAPTER   pAdapter,
              IN PRNDIS_MESSAGE     pMessage,
              IN PMDL               pMdl,
              IN ULONG              TotalLength,
              IN NDIS_HANDLE        MicroportMessageContext,
              IN NDIS_STATUS        ReceiveStatus,
              IN BOOLEAN            bMessageCopied)
{
    PRNDIS_INDICATE_STATUS  pRndisIndicateStatus;

    TRACE3(("IndicateStatusMessage: Adapter %x, Mdl %x\n", pAdapter, pMdl));

    // get a pointer to the indicate status message
    pRndisIndicateStatus = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

    if (!pAdapter->Initing)
    {
#if DBG
        if (pRndisIndicateStatus->Status == NDIS_STATUS_MEDIA_CONNECT)
        {
            TRACE1(("Adapter %x: +++ Media Connect +++\n", pAdapter));
        }
        else if (pRndisIndicateStatus->Status == NDIS_STATUS_MEDIA_DISCONNECT)
        {
            TRACE1(("Adapter %x: --- Media Disconnect ---\n", pAdapter));
        }
#endif // DBG

        // send status indication to upper layers
        NdisMIndicateStatus(pAdapter->MiniportAdapterHandle,
                            (NDIS_STATUS) pRndisIndicateStatus->Status,
                            MESSAGE_TO_STATUS_BUFFER(pRndisIndicateStatus),
                            pRndisIndicateStatus->StatusBufferLength);

        // always have to indicate status complete
        NdisMIndicateStatusComplete(pAdapter->MiniportAdapterHandle);
    }
    else
    {
        //
        // drop status indications that arrive when we are
        // in the process of initializing.
        //
        TRACE1(("Adapter %x: indicated status %x when still initializing\n",
                pAdapter, (NDIS_STATUS) pRndisIndicateStatus->Status));
    }

    return (TRUE);
} // IndicateStatusMessage

/****************************************************************************/
/*                          UnknownMessage                                  */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a message with unknown message type. We simply drop it for now. */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
UnknownMessage(IN PRNDISMP_ADAPTER   pAdapter,
       IN PRNDIS_MESSAGE     pMessage,
       IN PMDL               pMdl,
       IN ULONG              TotalLength,
       IN NDIS_HANDLE        MicroportMessageContext,
       IN NDIS_STATUS        ReceiveStatus,
       IN BOOLEAN            bMessageCopied)
{
    TRACE1(("Unknown Message on Adapter %x, type %x, MDL %x, uPContext %x\n",
            pAdapter, pMessage->NdisMessageType, pMdl, MicroportMessageContext));

    ASSERT(FALSE);
    return TRUE;
}

/****************************************************************************/
/*                          AllocateReceiveFrame                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a receive frame to keep context about a single RNDIS_PACKET    */
/*  message.                                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_RECV_DATA_FRAME                                                */
/*                                                                          */
/****************************************************************************/
PRNDISMP_RECV_DATA_FRAME
AllocateReceiveFrame(IN PRNDISMP_ADAPTER    pAdapter)
{
    PRNDISMP_RECV_DATA_FRAME    pRcvFrame;

#ifndef DONT_USE_LOOKASIDE_LIST
    pRcvFrame = (PRNDISMP_RECV_DATA_FRAME)
                NdisAllocateFromNPagedLookasideList(&pAdapter->RcvFramePool);
#else
    {
        NDIS_STATUS     Status;

        Status = MemAlloc(&pRcvFrame, sizeof(RNDISMP_RECV_DATA_FRAME));

        if (Status == NDIS_STATUS_SUCCESS)
        {
            NdisInterlockedIncrement(&RcvFrameAllocs);
        }
        else
        {
            pRcvFrame = NULL;
        }
    }
#endif // DONT_USE_LOOKASIDE_LIST

    return (pRcvFrame);
}

/****************************************************************************/
/*                          FreeReceiveFrame                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a receive frame to keep context about a single RNDIS_PACKET    */
/*  message.                                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pRcvFrame - Pointer to receive frame being freed                        */
/*  pAdapter - Pointer to our Adapter structure                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
FreeReceiveFrame(IN PRNDISMP_RECV_DATA_FRAME    pRcvFrame,
                 IN PRNDISMP_ADAPTER            pAdapter)
{
#ifndef DONT_USE_LOOKASIDE_LIST
    NdisFreeToNPagedLookasideList(&pAdapter->RcvFramePool, pRcvFrame);
#else
    MemFree(pRcvFrame, sizeof(RNDISMP_RECV_DATA_FRAME));
    NdisInterlockedDecrement(&RcvFrameAllocs);
#endif // DONT_USE_LOOKASIDE_LIST
}



/****************************************************************************/
/*                          IndicateTimeout                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Timeout callback routine to handle all receive indications. The actual  */
/*  NDIS routines to indicate receives is done from here, since this        */
/*  function runs in the right environment for protocols on WinME.          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  SystemSpecific[1-3] - Ignored                                           */
/*  Context - Pointer to our Adapter structure                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
IndicateTimeout(IN PVOID SystemSpecific1,
                IN PVOID Context,
                IN PVOID SystemSpecific2,
                IN PVOID SystemSpecific3)
{
    PRNDISMP_ADAPTER            pAdapter;
    PLIST_ENTRY                 pEntry;
    PRNDISMP_RECV_MSG_CONTEXT   pRcvMsg;
    PRNDISMP_MSG_HANDLER_FUNC   pMsgHandlerFunc;
    PRNDIS_MESSAGE              pMessage;
    BOOLEAN                     bMessageCopied;
    BOOLEAN                     bReturnToMicroport;
    ULONG                       CurMsgs;

    pAdapter = (PRNDISMP_ADAPTER)Context;
    CHECK_VALID_ADAPTER(pAdapter);

    ASSERT(pAdapter->IndicatingReceives == TRUE);

    CurMsgs = 0;
    RcvTimerCount++;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    while (!IsListEmpty(&pAdapter->PendingRcvMessageList))
    {
        pEntry = RemoveHeadList(&pAdapter->PendingRcvMessageList);

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

        CurMsgs++;

        pRcvMsg = CONTAINING_RECORD(pEntry, RNDISMP_RECV_MSG_CONTEXT, Link);

        RNDISMP_GET_MSG_HANDLER(pMsgHandlerFunc, pRcvMsg->pMessage->NdisMessageType);

        bMessageCopied = pRcvMsg->bMessageCopied;
        pMessage = pRcvMsg->pMessage;

        bReturnToMicroport = (*pMsgHandlerFunc)(
                                pAdapter,
                                pMessage,
                                pRcvMsg->pMdl,
                                pRcvMsg->TotalLength,
                                pRcvMsg->MicroportMessageContext,
                                pRcvMsg->ReceiveStatus,
                                bMessageCopied);

        //
        // Are we done with the message?
        //
        if (bReturnToMicroport)
        {
            if (!bMessageCopied)
            {
                RNDISMP_RETURN_TO_MICROPORT(pAdapter,
                                            pRcvMsg->pMdl,
                                            pRcvMsg->MicroportMessageContext);
            }
            else
            {
                FreeRcvMessageCopy(pMessage);
            }
        }

        MemFree(pRcvMsg, sizeof(RNDISMP_RECV_MSG_CONTEXT));

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);
    }

    pAdapter->IndicatingReceives = FALSE;

    RcvMaxPackets = MAX(RcvMaxPackets, CurMsgs);

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);


} // IndicateTimeout
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\request.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    REQUEST.C

Abstract:

    Handles set and query requests

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/13/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"


#ifdef TESTING
extern PUCHAR   pOffloadBuffer;
extern ULONG    OffloadSize;
#endif

// supported OID list
NDIS_OID RndismpSupportedOids[] = 
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_MAC_OPTIONS,
    OID_RNDISMP_STATISTICS,
#ifdef TESTING
    OID_TCP_TASK_OFFLOAD,
    OID_GEN_TRANSPORT_HEADER_OFFSET,
    OID_GEN_PHYSICAL_MEDIUM,
#endif
    OID_GEN_SUPPORTED_GUIDS
};

UINT RndismpSupportedOidsNum = sizeof(RndismpSupportedOids) / sizeof(NDIS_OID);

#ifdef BINARY_MOF_TEST

UCHAR RndismpBinaryMof[] = { 
    0x46, 0x4f, 0x4d, 0x42, 0x01, 0x00, 0x00, 0x00, 0x45, 0x02, 0x00, 0x00, 0xbc, 0x04, 0x00, 0x00,
    0x44, 0x53, 0x00, 0x01, 0x1a, 0x7d, 0xda, 0x54, 0x18, 0x44, 0x82, 0x00, 0x01, 0x06, 0x18, 0x42,
    0x20, 0xe4, 0x03, 0x89, 0xc0, 0x61, 0x68, 0x24, 0x18, 0x06, 0xe5, 0x01, 0x44, 0x6a, 0x20, 0xe4,
    0x82, 0x89, 0x09, 0x10, 0x01, 0x21, 0xaf, 0x02, 0x6c, 0x0a, 0x30, 0x09, 0xa2, 0xfe, 0xfd, 0x15,
    0xa1, 0xa1, 0x84, 0x40, 0x48, 0xa2, 0x00, 0xf3, 0x02, 0x74, 0x0b, 0x30, 0x2c, 0xc0, 0xb6, 0x00,
    0xd3, 0x02, 0x1c, 0x23, 0x12, 0x65, 0xd0, 0x94, 0xc0, 0x4a, 0x20, 0x24, 0x54, 0x80, 0x72, 0x01,
    0xbe, 0x05, 0x68, 0x07, 0x94, 0x64, 0x01, 0x96, 0x61, 0x34, 0x07, 0x0e, 0xc6, 0x09, 0x8a, 0x46,
    0x46, 0xa9, 0x80, 0x90, 0x67, 0x01, 0xd6, 0x71, 0x09, 0x41, 0xf7, 0x02, 0xa4, 0x09, 0x70, 0x26,
    0xc0, 0xdb, 0x34, 0xa4, 0x59, 0xc0, 0x30, 0x22, 0xd8, 0x16, 0x8e, 0x30, 0xe2, 0x9c, 0x42, 0x94,
    0xc6, 0x10, 0x84, 0x19, 0x31, 0x4a, 0x73, 0x58, 0x82, 0x8a, 0x11, 0xa5, 0x30, 0x04, 0x01, 0x86,
    0x88, 0x55, 0x9c, 0x00, 0x6b, 0x58, 0x42, 0x39, 0x80, 0x13, 0xb0, 0xfd, 0x39, 0x48, 0x13, 0x84,
    0x1c, 0x4c, 0x0b, 0x25, 0x7b, 0x40, 0x9a, 0xc6, 0xf1, 0x05, 0x39, 0x87, 0x83, 0x61, 0x26, 0x86,
    0x2c, 0x55, 0x98, 0x28, 0x2d, 0x73, 0x23, 0xe3, 0xb4, 0x45, 0x01, 0xe2, 0x05, 0x08, 0x07, 0xd5,
    0x58, 0x3b, 0xc7, 0xd0, 0x05, 0x80, 0xa9, 0x1e, 0x1e, 0x4a, 0xcc, 0x98, 0x09, 0x5a, 0xbc, 0x93,
    0x38, 0xcc, 0xc0, 0x61, 0x4b, 0xc7, 0xd0, 0x40, 0x02, 0x27, 0x68, 0x10, 0x49, 0x8a, 0x71, 0x84,
    0x14, 0xe4, 0x5c, 0x42, 0x9c, 0x7c, 0x41, 0x02, 0x94, 0x0a, 0xd0, 0x09, 0xac, 0x19, 0x77, 0x3a,
    0x66, 0x4d, 0x39, 0x50, 0x78, 0x8f, 0xdc, 0xf8, 0x41, 0xe2, 0xf4, 0x09, 0xac, 0x79, 0x44, 0x89,
    0x13, 0xba, 0xa9, 0x09, 0x28, 0xa4, 0x02, 0x88, 0x16, 0x40, 0x94, 0x66, 0x32, 0xa8, 0xab, 0x40,
    0x82, 0x47, 0x03, 0x8f, 0xe0, 0xa8, 0x0c, 0x7a, 0x1a, 0x41, 0xe2, 0x7b, 0x18, 0xef, 0x04, 0x1e,
    0x99, 0x87, 0x79, 0x8a, 0x0c, 0xf3, 0xff, 0xff, 0x8e, 0x80, 0x75, 0x8d, 0xa7, 0x11, 0x9d, 0x80,
    0xe5, 0xa0, 0xa1, 0xae, 0x03, 0x1e, 0x57, 0xb4, 0xf8, 0xa7, 0x6c, 0xb8, 0xba, 0xc6, 0x82, 0xba,
    0x2a, 0xd8, 0xe1, 0x54, 0x34, 0xb6, 0x52, 0x05, 0x98, 0x1d, 0x9c, 0xe6, 0x9c, 0xe0, 0x68, 0x3c,
    0x55, 0xcf, 0xe6, 0xe1, 0x20, 0xc1, 0x23, 0x82, 0xa7, 0xc0, 0xa7, 0x65, 0x1d, 0xc3, 0x25, 0x03,
    0x34, 0x62, 0xb8, 0x73, 0x32, 0x7a, 0x82, 0x3b, 0x94, 0x80, 0xd1, 0xc0, 0xbd, 0x1b, 0x1c, 0x0d,
    0xec, 0x59, 0xbf, 0x04, 0x44, 0x78, 0x38, 0xf0, 0x5c, 0x3d, 0x06, 0xfd, 0x08, 0xe4, 0x64, 0x36,
    0x28, 0x3d, 0x37, 0x02, 0x7a, 0x05, 0xe0, 0x27, 0x09, 0x76, 0x3c, 0x30, 0xc8, 0x29, 0x1d, 0xad,
    0x53, 0x43, 0xe8, 0xad, 0xe1, 0x19, 0xc1, 0x05, 0x7e, 0x4c, 0x00, 0xcb, 0xe9, 0x00, 0x3b, 0x16,
    0x3c, 0x52, 0xe3, 0x47, 0x0c, 0xe1, 0x18, 0x31, 0xc6, 0x69, 0x04, 0x0a, 0xeb, 0x91, 0x04, 0xa9,
    0x70, 0xf6, 0x64, 0x98, 0x6f, 0x0a, 0x35, 0x0a, 0xb8, 0x09, 0x58, 0xd4, 0x65, 0x02, 0x25, 0xe5,
    0x32, 0x81, 0x98, 0x47, 0xd8, 0xb7, 0x04, 0x4f, 0xf8, 0xac, 0x7c, 0x98, 0xf0, 0xa5, 0x00, 0xfe,
    0xed, 0xc3, 0xc3, 0x08, 0xfd, 0xb0, 0xf1, 0x44, 0xe2, 0x23, 0x43, 0x5c, 0xcc, 0xff, 0x1f, 0xd7,
    0x03, 0xb7, 0x5f, 0x01, 0x08, 0xb1, 0xcb, 0xbc, 0x16, 0xe8, 0x38, 0x11, 0x21, 0xc1, 0x1b, 0x05,
    0x16, 0xe3, 0x60, 0x3c, 0x50, 0x9f, 0x13, 0x3c, 0x4c, 0x83, 0x1c, 0x59, 0xbc, 0x88, 0x09, 0x4e,
    0xed, 0xa8, 0xb1, 0x73, 0xe0, 0x03, 0x38, 0x86, 0xf0, 0xe7, 0x13, 0xfe, 0x00, 0xa2, 0x1c, 0xc7,
    0x21, 0x79, 0xc8, 0x46, 0x38, 0x81, 0x72, 0x2f, 0x2b, 0xe4, 0x58, 0x72, 0x14, 0xa7, 0xf5, 0x74,
    0x10, 0xe8, 0x04, 0x30, 0x0a, 0x6d, 0xfa, 0xd4, 0x68, 0xd4, 0xaa, 0x41, 0x99, 0x1a, 0x65, 0x1a,
    0xd4, 0xea, 0x53, 0xa9, 0x31, 0x63, 0xf3, 0xb5, 0xb4, 0x77, 0x83, 0x40, 0x1c, 0x0a, 0x84, 0x66,
    0xa4, 0x10, 0x88, 0xff, 0xff};

ULONG  RndismpBinaryMofSize = sizeof(RndismpBinaryMof);

#define RNDISMPDeviceOIDGuid \
    { 0x437cf222,0x72fe,0x11d4, { 0x97,0xf9,0x00,0x20,0x48,0x57,0x03,0x37}}

#endif // BINARY_MOF_TEST

NDIS_GUID CustomGuidList[] =
{
    {
            RNDISMPStatisticsOIDGuid,
            OID_RNDISMP_STATISTICS,
            sizeof(UINT32), // size is size of each element in the array
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ARRAY)
    }
#ifdef BINARY_MOF_TEST
,
    {
            RNDISMPDeviceOIDGuid,
            OID_RNDISMP_DEVICE_OID,
            sizeof(UINT32),
            fNDIS_GUID_TO_OID
    },
    {
            BINARY_MOF_GUID,
            OID_RNDISMP_GET_MOF_OID,
            sizeof(UINT8),
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ARRAY)
    }
#endif
};

UINT CustomGuidCount = sizeof(CustomGuidList)/sizeof(NDIS_GUID);

/****************************************************************************/
/*                          RndismpQueryInformation                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    NDIS Entry point called to handle a query for a particular OID.       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    MiniportAdapterContext - a context version of our Adapter pointer     */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesWritten - a pointer to the number of bytes written into the     */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpQueryInformation(IN  NDIS_HANDLE MiniportAdapterContext,
                        IN  NDIS_OID    Oid,
                        IN  PVOID       InformationBuffer,
                        IN  ULONG       InformationBufferLength,
                        OUT PULONG      pBytesWritten,
                        OUT PULONG      pBytesNeeded)
{
    PRNDISMP_ADAPTER    pAdapter;
    NDIS_STATUS         Status;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE3(("RndismpQueryInformation\n"));

    Status = ProcessQueryInformation(pAdapter,
                                     NULL,
                                     NULL,
                                     Oid,
                                     InformationBuffer,
                                     InformationBufferLength,
                                     pBytesWritten,
                                     pBytesNeeded);
    return Status;
}


/****************************************************************************/
/*                          ProcessQueryInformation                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    Utility routine to process a Query (connection-less or connection-    */
/*    oriented).                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - Pointer to our adapter structure                           */
/*    pVc - Pointer to a VC, possibly NULL.                                 */
/*    pRequest - Pointer to NDIS request, if this came via our CoRequest    */
/*          handler.                                                        */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesWritten - a pointer to the number of bytes written into the     */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
ProcessQueryInformation(IN  PRNDISMP_ADAPTER    pAdapter,
                        IN  PRNDISMP_VC         pVc,
                        IN  PNDIS_REQUEST       pRequest,
                        IN  NDIS_OID            Oid,
                        IN  PVOID               InformationBuffer,
                        IN  ULONG               InformationBufferLength,
                        OUT PULONG              pBytesWritten,
                        OUT PULONG              pBytesNeeded)
{
    NDIS_STATUS         Status;
    UINT                OIDHandler;

    OIDHandler = GetOIDSupport(pAdapter, Oid);
    
    switch(OIDHandler)
    {
        case DRIVER_SUPPORTED_OID:
            Status = DriverQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            Oid,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);
            break;
        case DEVICE_SUPPORTED_OID:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            Oid,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);
            break;
        case OID_NOT_SUPPORTED:
        default:
            TRACE2(("Invalid Query OID (%08X)\n", Oid));
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    TRACE2(("ProcessQueryInfo: Oid %08X, returning Status %x\n", Oid, Status));

    return Status;
} // ProcessQueryInformation

    
/****************************************************************************/
/*                          RndismpSetInformation                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    The RndismpSetInformation processes a Set request for                 */
/*    NDIS_OIDs that are specific about the Driver.                         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    MiniportAdapterContext - a context version of our Adapter pointer     */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - Holds the data to be set.                         */
/*    InformationBufferLength - The length of InformationBuffer.            */
/*    pBytesRead - If the call is successful, returns the number            */
/*        of bytes read from InformationBuffer.                             */
/*    pBytesNeeded - If there is not enough data in InformationBuffer       */
/*        to satisfy the OID, returns the amount of storage needed.         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpSetInformation(IN  NDIS_HANDLE   MiniportAdapterContext,
                      IN  NDIS_OID      Oid,
                      IN  PVOID         InformationBuffer,
                      IN  ULONG         InformationBufferLength,
                      OUT PULONG        pBytesRead,
                      OUT PULONG        pBytesNeeded)
{
    PRNDISMP_ADAPTER    pAdapter;
    NDIS_STATUS         Status;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE3(("RndismpSetInformation\n"));

    Status = ProcessSetInformation(pAdapter,
                                   NULL,
                                   NULL,
                                   Oid,
                                   InformationBuffer,
                                   InformationBufferLength,
                                   pBytesRead,
                                   pBytesNeeded);
    return Status;
}


/****************************************************************************/
/*                          ProcessSetInformation                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    Utility routine to process a Set (connection-less or connection-      */
/*    oriented).                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - Pointer to our adapter structure                           */
/*    pVc - Pointer to a VC, possibly NULL.                                 */
/*    pRequest - Pointer to NDIS request, if this came via our CoRequest    */
/*          handler.                                                        */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesRead - a pointer to the number of bytes read from the           */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
ProcessSetInformation(IN  PRNDISMP_ADAPTER    pAdapter,
                      IN  PRNDISMP_VC         pVc OPTIONAL,
                      IN  PNDIS_REQUEST       pRequest OPTIONAL,
                      IN  NDIS_OID            Oid,
                      IN  PVOID               InformationBuffer,
                      IN  ULONG               InformationBufferLength,
                      OUT PULONG              pBytesRead,
                      OUT PULONG              pBytesNeeded)
{
    NDIS_STATUS         Status;
    UINT                OIDHandler;

    OIDHandler = GetOIDSupport(pAdapter, Oid);
    
    switch(OIDHandler)
    {
        case DRIVER_SUPPORTED_OID:
            Status = DriverSetInformation(pAdapter,
                                          pVc,
                                          pRequest,
                                          Oid,
                                          InformationBuffer,
                                          InformationBufferLength,
                                          pBytesRead,
                                          pBytesNeeded);
            break;

        case DEVICE_SUPPORTED_OID:
            Status = DeviceSetInformation(pAdapter,
                                          pVc,
                                          pRequest,
                                          Oid,
                                          InformationBuffer,
                                          InformationBufferLength,
                                          pBytesRead,
                                          pBytesNeeded);
            break;

        case OID_NOT_SUPPORTED:
        default:
            TRACE2(("Invalid Set OID (%08X), Adapter %p\n", Oid, pAdapter));
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    return Status;
} // ProcessSetInformation

/****************************************************************************/
/*                          DriverQueryInformation                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    The RndismpQueryInformation processes a Query request for             */
/*    NDIS_OIDs that are specific about the Driver. This routine            */
/*    Handles OIDs supported by the driver instead of the device            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - Pointer to our adapter structure                           */
/*    pVc - Pointer to a VC, possibly NULL.                                 */
/*    pRequest - Pointer to NDIS request, if this came via our CoRequest    */
/*          handler.                                                        */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesWritten - a pointer to the number of bytes written into the     */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
DriverQueryInformation(IN  PRNDISMP_ADAPTER pAdapter,
                       IN  PRNDISMP_VC      pVc OPTIONAL,
                       IN  PNDIS_REQUEST    pRequest OPTIONAL,
                       IN  NDIS_OID         Oid,
                       IN  PVOID            InformationBuffer,
                       IN  ULONG            InformationBufferLength,
                       OUT PULONG           pBytesWritten,
                       OUT PULONG           pBytesNeeded)
{
    NDIS_STATUS         Status;
    PVOID               MoveSource;
    UINT                MoveBytes;
    ULONG               GenericUlong;
    USHORT              GenericUshort;
    CHAR                VendorDescription[] = "Remote NDIS Network Card";

    TRACE3(("DriverQueryInformation\n"));
    OID_NAME_TRACE(Oid, "DriverQuery");

    Status      = NDIS_STATUS_SUCCESS;
    MoveSource  = (PVOID) (&GenericUlong);
    MoveBytes   = sizeof(GenericUlong);

    // this is one we have to handle
    switch(Oid)
    {
        case OID_GEN_DRIVER_VERSION:
            GenericUshort = (pAdapter->DriverBlock->MajorNdisVersion << 8) +
                            (pAdapter->DriverBlock->MinorNdisVersion);

            MoveSource = (PVOID)&GenericUshort;
            MoveBytes = sizeof(GenericUshort);
            break;

        case OID_GEN_VENDOR_ID:
            TRACE1(("Query for OID_GEN_VENDOR_ID not supported by device!\n"));
            GenericUlong = 0xFFFFFF;
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            TRACE1(("Query for OID_GEN_VENDOR_DESCRIPTION not supported by device!\n"));
            if (pAdapter->FriendlyNameAnsi.Length != 0)
            {
                MoveSource = pAdapter->FriendlyNameAnsi.Buffer;
                MoveBytes = pAdapter->FriendlyNameAnsi.Length;
            }
            else
            {
                MoveSource = VendorDescription;
                MoveBytes = sizeof(VendorDescription);
            }
            break;
        
        case OID_GEN_VENDOR_DRIVER_VERSION:
            TRACE1(("Query for OID_GEN_VENDOR_DRIVER_VERSION not supported by device!\n"));
            GenericUlong = 0xA000B;
            break;

        case OID_GEN_MAC_OPTIONS:
            GenericUlong = pAdapter->MacOptions;
            break;

        case OID_GEN_SUPPORTED_LIST:
            // get the list we generated
            MoveSource  = (PVOID) (pAdapter->SupportedOIDList);
            MoveBytes   = pAdapter->SupportedOIDListSize;
            break;

        case OID_GEN_MEDIA_IN_USE:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            OID_GEN_MEDIA_SUPPORTED,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);                                        
            break;

        case OID_GEN_MAXIMUM_LOOKAHEAD:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            OID_GEN_MAXIMUM_FRAME_SIZE,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);

            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            GenericUlong = pAdapter->MaxTransferSize;
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            GenericUlong = pAdapter->MaxReceiveSize * 8;
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            OID_GEN_MAXIMUM_FRAME_SIZE,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);

            break;

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            Status = DeviceQueryInformation(pAdapter,
                                            pVc,
                                            pRequest,
                                            OID_GEN_MAXIMUM_FRAME_SIZE,
                                            InformationBuffer,
                                            InformationBufferLength,
                                            pBytesWritten,
                                            pBytesNeeded);

            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        	TRACE1(("Query for OID_GEN_MAXIMUM_TOTAL_SIZE not supported by device!\n"));
            GenericUlong = (ULONG) MAXIMUM_ETHERNET_PACKET_SIZE;
            break;

        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        	TRACE1(("Query for OID_GEN_TRANSMIT_BLOCK_SIZE not supported by device!\n"));
            GenericUlong = (ULONG) MAXIMUM_ETHERNET_PACKET_SIZE;
            break;

        case OID_GEN_RECEIVE_BLOCK_SIZE:
        	TRACE1(("Query for OID_GEN_RECEIVE_BLOCK_SIZE not supported by device!\n"));
            GenericUlong = (ULONG) MAXIMUM_ETHERNET_PACKET_SIZE;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            GenericUlong = (ULONG) pAdapter->MaxPacketsPerMessage;
            break;

        case OID_PNP_CAPABILITIES:
        case OID_PNP_QUERY_POWER:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

        case OID_GEN_XMIT_OK:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, XmitOk);
            break;
        
        case OID_GEN_XMIT_ERROR:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, XmitError);
            break;
        
        case OID_GEN_RCV_OK:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, RecvOk);
            break;
        
        case OID_GEN_RCV_ERROR:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, RecvError);
            break;
        
        case OID_GEN_RCV_NO_BUFFER:
            GenericUlong = RNDISMP_GET_ADAPTER_STATS(pAdapter, RecvNoBuf);
            break;
        
        case OID_GEN_SUPPORTED_GUIDS:
            MoveSource = (PVOID)&CustomGuidList[0];
            MoveBytes = sizeof(CustomGuidList);
            TRACE1(("Query for supported GUIDs, len %d\n", InformationBufferLength));
            break;

        case OID_RNDISMP_STATISTICS:
            MoveSource = &pAdapter->Statistics;
            MoveBytes = sizeof(pAdapter->Statistics);
            break;

#ifdef BINARY_MOF_TEST

        case OID_RNDISMP_DEVICE_OID:
            DbgPrint("*** RNDISMP: Query for Device OID\n");
            GenericUlong = 0xabcdefab;
            break;

        case OID_RNDISMP_GET_MOF_OID:
            DbgPrint("*** RNDISMP: Query for MOF Info: Src %p, Size %d\n",
                RndismpBinaryMof, RndismpBinaryMofSize);
            MoveSource = RndismpBinaryMof;
            MoveBytes = RndismpBinaryMofSize;
            break;

#endif // BINARY_MOF_TEST

#ifdef TESTING
        case OID_TCP_TASK_OFFLOAD:
        	DbgPrint("RNDISMP: got query for TCP offload\n");
        	MoveSource = pOffloadBuffer;
        	MoveBytes = OffloadSize;
        	break;
		case OID_GEN_PHYSICAL_MEDIUM:
			DbgPrint("RNDISMP: got query for physical medium\n");
			GenericUlong = NdisPhysicalMediumDSL;
			break;
#endif

        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    // copy stuff to information buffer
    if (Status == NDIS_STATUS_SUCCESS)
    {
        if (MoveBytes > InformationBufferLength)
        {
            // Not enough room in InformationBuffer
            *pBytesNeeded = MoveBytes;

            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
        }
        else
        {
            // Copy result into InformationBuffer
            *pBytesWritten = MoveBytes;

            if (MoveBytes > 0)
                RNDISMP_MOVE_MEM(InformationBuffer, MoveSource, MoveBytes);
        }
    }

    TRACE2(("Status (%08X)  BytesWritten (%08X)\n", Status, *pBytesWritten));

    return Status;
} // DriverQueryInformation

/****************************************************************************/
/*                          DeviceQueryInformation                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    The DeviceQueryInformation processes a Query request                  */
/*    that is going to the Remote NDIS device                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - pointer to our Adapter structure                           */
/*    pVc - optional pointer to our VC structure, if this is a per-Vc req.  */
/*    pRequest - optional pointer to NDIS request, if CONDIS.               */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - a pointer into the NdisRequest->InformationBuffer */
/*     into which store the result of the query.                            */
/*    InformationBufferLength - a pointer to the number of bytes left in    */
/*     the InformationBuffer.                                               */
/*    pBytesWritten - a pointer to the number of bytes written into the     */
/*     InformationBuffer.                                                   */
/*    pBytesNeeded - If there is not enough room in the information buffer  */
/*     then this will contain the number of bytes needed to complete the    */
/*     request.                                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
DeviceQueryInformation(IN  PRNDISMP_ADAPTER pAdapter,
                       IN  PRNDISMP_VC      pVc OPTIONAL,
                       IN  PNDIS_REQUEST    pRequest OPTIONAL,
                       IN  NDIS_OID         Oid,
                       IN  PVOID            InformationBuffer,
                       IN  ULONG            InformationBufferLength,
                       OUT PULONG           pBytesWritten,
                       OUT PULONG           pBytesNeeded)
{
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    NDIS_STATUS                 Status;
    PUCHAR                      pSrcBuffer;
    ULONG                       ByteLength;

    OID_NAME_TRACE(Oid, "DeviceQuery");
    TRACE3(("DeviceQuery: OID %x, InfoBuf %p, Len %d, pBytesWrit %p, pBytesNeed %p\n",
        Oid, InformationBuffer, InformationBufferLength, pBytesWritten, pBytesNeeded));

    //
    // Debug code for Win9X/WinMe:
    //
    // TRACE1(("DeviceQuery: NdisRequest = %x, AdapterFlags %x, list empty %d\n",
    //        *(PULONG)((PUCHAR)pAdapter->MiniportAdapterHandle + 0x13c),
    //        *(PULONG)((PUCHAR)pAdapter->MiniportAdapterHandle + 0x3c),
    //        IsListEmpty(&pAdapter->PendingFrameList)
    //        ));
    // if (!IsListEmpty(&pAdapter->PendingFrameList))
    // {
    //     TRACE0(("DeviceQuery: Adapter %p, PendingFrameList @%p not empty!\n",
    //         pAdapter, &pAdapter->PendingFrameList));
    //     DbgBreakPoint();
    // }

    do
    {
        if (pAdapter->Halting)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        if (pAdapter->bRunningOnWin9x)
        {
            //
            // Intercept some queries to complete them synchronously.
            // This is because NDIS/Win9X-Me has a very short timeout for
            // internally generated queries (the ones intercepted below).
            //
            switch (Oid)
            {
                case OID_802_3_MAXIMUM_LIST_SIZE:
                    pSrcBuffer = (PUCHAR)&pAdapter->MaxMulticastListSize;
                    ByteLength = sizeof(pAdapter->MaxMulticastListSize);
                    break;

                case OID_GEN_MAXIMUM_LOOKAHEAD:
                case OID_GEN_MAXIMUM_FRAME_SIZE:
                    pSrcBuffer = (PUCHAR)&pAdapter->MaximumFrameSize;
                    ByteLength = sizeof(pAdapter->MaximumFrameSize);
                    break;

                case OID_802_3_CURRENT_ADDRESS:
                    pSrcBuffer = (PUCHAR)pAdapter->MacAddress;
                    ByteLength = ETH_LENGTH_OF_ADDRESS;
                    break;

                case OID_GEN_MAC_OPTIONS:
                    pSrcBuffer = (PUCHAR)&pAdapter->MacOptions;
                    ByteLength = sizeof(pAdapter->MacOptions);
                    break;

                default:
                    pSrcBuffer = NULL;
                    ByteLength = 0;
                    break;
            }

            if (pSrcBuffer != NULL)
            {
                if (InformationBufferLength < ByteLength)
                {
                    *pBytesNeeded = ByteLength;
                    Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                }
                else
                {
                    TRACE1(("DeviceQuery: Adapter %p, intercepted OID %x\n",
                        pAdapter, Oid));
                    *pBytesNeeded = *pBytesWritten = ByteLength;
                    NdisMoveMemory(InformationBuffer, pSrcBuffer, ByteLength);
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
            }
        }

        pReqContext = AllocateRequestContext(pAdapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // HACKHACK to avoid a strange length from going to the device,
        // we minimize the amount of data sent with the query.
        //
        // In general, there is no point sending a huge information buffer
        // along with a Query that does not require an IN parameter.
        // Long term, we may have to separate out the few OIDs that do
        // use IN parameters and allow those buffers to pass through
        //

        pMsgFrame = BuildRndisMessageCommon(pAdapter, 
                                            pVc,
                                            REMOTE_NDIS_QUERY_MSG,
                                            Oid,
                                            InformationBuffer,
                                            ((InformationBufferLength > 48)?
                                               48: InformationBufferLength));

        // see if we got a message
        if (!pMsgFrame)
        {
            Status = NDIS_STATUS_RESOURCES;
            FreeRequestContext(pAdapter, pReqContext);
            break;
        }

        Status = NDIS_STATUS_PENDING;

        pReqContext->InformationBuffer = InformationBuffer;
        pReqContext->InformationBufferLength = InformationBufferLength;
        pReqContext->pBytesRead = NULL;
        pReqContext->pBytesWritten = pBytesWritten;
        pReqContext->pBytesNeeded = pBytesNeeded;
        pReqContext->Oid = Oid;
        pReqContext->RetryCount = 0;
        pReqContext->bInternal = FALSE;
        pReqContext->pVc = pVc;
        pReqContext->pNdisRequest = pRequest;

        pMsgFrame->pReqContext = pReqContext;

        // Add a ref to keep the frame around until we complete the request.
        ReferenceMsgFrame(pMsgFrame);

        TRACE3(("DeviceQuery: Oid %x, pReqContext %p, InfoBuf %p, pMsgFrame %p/%d\n",
                Oid, pReqContext, pReqContext->InformationBuffer, pMsgFrame, pMsgFrame->RefCount));

        // send the message to the microport
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendDeviceRequest);

        break;
    }
    while (FALSE);

    return Status;

} // DeviceQueryInformation

/****************************************************************************/
/*                          DriverSetInformation                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    Utility routine to handle SetInformation requests that aren't         */
/*    specific to the device. We also land up here for requests for any     */
/*    OIDs that aren't supported by the device.                             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - Pointer to our adapter structure                           */
/*    pVc - Pointer to a VC, possibly NULL.                                 */
/*    pRequest - Pointer to NDIS request, if this came via our CoRequest    */
/*          handler.                                                        */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - Holds the data to be set.                         */
/*    InformationBufferLength - The length of InformationBuffer.            */
/*    pBytesRead - If the call is successful, returns the number            */
/*        of bytes read from InformationBuffer.                             */
/*    pBytesNeeded - If there is not enough data in InformationBuffer       */
/*        to satisfy the OID, returns the amount of storage needed.         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
DriverSetInformation(IN  PRNDISMP_ADAPTER   pAdapter,
                     IN  PRNDISMP_VC        pVc OPTIONAL,
                     IN  PNDIS_REQUEST      pRequest OPTIONAL,
                     IN  NDIS_OID           Oid,
                     IN  PVOID              InformationBuffer,
                     IN  ULONG              InformationBufferLength,
                     OUT PULONG             pBytesRead,
                     OUT PULONG             pBytesNeeded)
{
    NDIS_STATUS                 Status;

    TRACE2(("DriverSetInformation: Adapter %p, Oid %x\n", pAdapter, Oid));

    OID_NAME_TRACE(Oid, "DriverSet");

    Status = NDIS_STATUS_SUCCESS;

    switch(Oid)
    {
        case OID_GEN_CURRENT_LOOKAHEAD:
            // Verify the Length
            if(InformationBufferLength != sizeof(ULONG))
                Status = NDIS_STATUS_INVALID_LENGTH;

            *pBytesRead = sizeof(ULONG);
            break;

        case OID_PNP_SET_POWER:
        case OID_PNP_ADD_WAKE_UP_PATTERN:
        case OID_PNP_REMOVE_WAKE_UP_PATTERN:
        case OID_PNP_ENABLE_WAKE_UP:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

#ifdef TESTING
        case OID_TCP_TASK_OFFLOAD:
        	Status = NDIS_STATUS_SUCCESS;
        	DbgPrint("RNDISMP: Set TCP_TASK_OFFLOAD\n");
        	break;
		case OID_GEN_TRANSPORT_HEADER_OFFSET:
			Status = NDIS_STATUS_SUCCESS;
			break;
#endif
        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    TRACE2(("Status (%08X)  BytesRead (%08X)\n", Status, *pBytesRead));

    return Status;
} // DriverSetInformation

/****************************************************************************/
/*                          DeviceSetInformation                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    The DeviceSetInformation processes a set request                      */
/*    that is going to the Remote NDIS device                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - pointer to our Adapter structure                           */
/*    pVc - optional pointer to our VC structure, if this is a per-Vc req.  */
/*    pRequest - optional pointer to NDIS request, if CONDIS.               */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - Holds the data to be set.                         */
/*    InformationBufferLength - The length of InformationBuffer.            */
/*    pBytesRead - If the call is successful, returns the number            */
/*        of bytes read from InformationBuffer.                             */
/*    pBytesNeeded - If there is not enough data in InformationBuffer       */
/*        to satisfy the OID, returns the amount of storage needed.         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
DeviceSetInformation(IN  PRNDISMP_ADAPTER   pAdapter,
                     IN  PRNDISMP_VC        pVc OPTIONAL,
                     IN  PNDIS_REQUEST      pRequest OPTIONAL,
                     IN  NDIS_OID           Oid,
                     IN  PVOID              InformationBuffer,
                     IN  ULONG              InformationBufferLength,
                     OUT PULONG             pBytesRead,
                     OUT PULONG             pBytesNeeded)
{
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    NDIS_STATUS                 Status;

    TRACE2(("DeviceSetInformation: Adapter %p, Oid %x\n"));

    OID_NAME_TRACE(Oid, "DeviceSet");

#if DBG
    if (Oid == OID_GEN_CURRENT_PACKET_FILTER)
    {
        PULONG      pFilter = (PULONG)InformationBuffer;

        TRACE1(("DeviceSetInfo: Adapter %p: Setting packet filter to %x\n",
                pAdapter, *pFilter));
    }
#endif

    do
    {
        if (pAdapter->Halting)
        {
            TRACE1(("DeviceSetInfo: Adapter %p is halting: succeeding Oid %x\n",
                    pAdapter, Oid));
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        pReqContext = AllocateRequestContext(pAdapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pMsgFrame = BuildRndisMessageCommon(pAdapter, 
                                            pVc,
                                            REMOTE_NDIS_SET_MSG,
                                            Oid,
                                            InformationBuffer,
                                            InformationBufferLength);

        // see if we got a message
        if (!pMsgFrame)
        {
            Status = NDIS_STATUS_RESOURCES;
            FreeRequestContext(pAdapter, pReqContext);
            break;
        }

        Status = NDIS_STATUS_PENDING;

        pReqContext->InformationBuffer = InformationBuffer;
        pReqContext->InformationBufferLength = InformationBufferLength;
        pReqContext->pBytesRead = pBytesRead;
        pReqContext->pBytesWritten = NULL;
        pReqContext->pBytesNeeded = pBytesNeeded;
        pReqContext->Oid = Oid;
        pReqContext->RetryCount = 0;
        pReqContext->bInternal = FALSE;
        pReqContext->pVc = pVc;
        pReqContext->pNdisRequest = pRequest;

        pMsgFrame->pReqContext = pReqContext;

#ifndef BUILD_WIN9X
        // Add a ref to keep the frame around until we complete the request.
        ReferenceMsgFrame(pMsgFrame);

        // send the message to the microport
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendDeviceRequest);
#else
        //
        // Win9X!
        //
        // Special-case for setting the current packet filter to 0.
        // We complete this one synchronously, otherwise NdisCloseAdapter
        // doesn't seem to complete.
        //
        if ((Oid == OID_GEN_CURRENT_PACKET_FILTER )
					&&
            ( (*(PULONG)InformationBuffer == 0) || (pAdapter->bRunningOnWin98Gold) ))
        {
            //
            // Do not queue the request, so that when we get a completion
            // from the device, we simply drop it.
            //
            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, FALSE, CompleteSendDiscardDeviceRequest);
            Status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            // Add a ref to keep the frame around until we complete the request.
            ReferenceMsgFrame(pMsgFrame);

            // send the message to the microport
            RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, CompleteSendDeviceRequest);
        }

#endif // BUILD_WIN9X
        break;
    }
    while (FALSE);

    return Status;
} // DeviceSetInformation


/****************************************************************************/
/*                          QuerySetCompletionMessage                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion message from microport in response to query or set message   */
/*  miniport sent. This information is now ready to pass to upper layers    */
/*  since the original call into the miniport returned STATUS_PENDING       */
/*                                                                          */
/*  Danger Danger - an OID_GEN_SUPPORTED_LIST query is special cased here   */
/*  This is only sent to the device from the adapter init routine to build  */
/*  a list of OIDs supported by the driver and device.                      */
/*  All OID_GEN_SUPPORTED_LIST queries from upper layers are handled by     */
/*  the driver and not the device.                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
QuerySetCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                          IN PRNDIS_MESSAGE     pMessage,
                          IN PMDL               pMdl,
                          IN ULONG              TotalLength,
                          IN NDIS_HANDLE        MicroportMessageContext,
                          IN NDIS_STATUS        ReceiveStatus,
                          IN BOOLEAN            bMessageCopied)
{
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    PRNDIS_QUERY_COMPLETE       pQueryComplMessage;
    PRNDIS_SET_COMPLETE         pSetComplMessage;
    UINT32                      NdisMessageType;
    NDIS_STATUS                 Status;
    UINT                        BytesWritten;
    UINT                        BytesRead;
    BOOLEAN                     bInternal;

    TRACE3(("QuerySetCompletionMessage\n"));

    pReqContext = NULL;
    pMsgFrame = NULL;

    pQueryComplMessage = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);
    pSetComplMessage = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);
    bInternal = FALSE;
    NdisMessageType = 0xdead;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        // get request frame from request ID in message
        RNDISMP_LOOKUP_PENDING_MESSAGE(pMsgFrame, pAdapter, pQueryComplMessage->RequestId);

        if (pMsgFrame == NULL)
        {
            // invalid request ID or aborted request.
            TRACE1(("Invalid/aborted request ID %08X in Query/Set Complete msg %p\n",
                    pQueryComplMessage->RequestId, pQueryComplMessage));
            break;
        }

        pReqContext = pMsgFrame->pReqContext;
        ASSERT(pReqContext != NULL);
        bInternal = pReqContext->bInternal;

        NdisMessageType = pMessage->NdisMessageType;
        
        if (NdisMessageType != RNDIS_COMPLETION(pMsgFrame->NdisMessageType))
        {
            TRACE1(("Query/Response mismatch: Msg @ %p, ReqId %d, req type %X, compl type %X\n",
                    pMessage,
                    pQueryComplMessage->RequestId,
                    pMsgFrame->NdisMessageType,
                    NdisMessageType));
            ASSERT(FALSE);
            pMsgFrame = NULL;
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        switch(NdisMessageType)
        {
            // a query complete message indicates we have a response
            // to a query message the miniport sent down. we carry around
            // appropriate context so we can indicate the completion
            // to upper layers and pass the query data up
            //
            // OID_GEN_SUPPORTED_LIST is a special case since it
            // is never indicated to upper layers from the device

            case REMOTE_NDIS_QUERY_CMPLT:

                // an OID_GEN_SUPPORTED_LIST is never completed to the upper
                // layers. This is sent from our adapter init routine
                // in preparation for building a list of OIDs

                TRACE2(("QueryCompl: pReqContext %p, OID %08X, pMsgFrame %p, %d bytes, Status %x\n",
                        pReqContext,
                        pReqContext->Oid,
                        pMsgFrame,
                        pQueryComplMessage->InformationBufferLength,
                        pQueryComplMessage->Status));

                pReqContext->CompletionStatus = pQueryComplMessage->Status;
                if (pReqContext->Oid == OID_GEN_SUPPORTED_LIST)
                {
                    if (pReqContext->CompletionStatus == NDIS_STATUS_SUCCESS)
                    {
                        // Build a list of supported OIDs.

                        TRACE1(("QueryComplete: SupportedList: InfoBufLength %d (%d OIDs)\n",
                                    pQueryComplMessage->InformationBufferLength,
                                    pQueryComplMessage->InformationBufferLength/sizeof(NDIS_OID)));

                        Status = BuildOIDLists(pAdapter, 
                                               (PNDIS_OID) (((PUCHAR)(pQueryComplMessage)) +
                                               pQueryComplMessage->InformationBufferOffset),
                                               pQueryComplMessage->InformationBufferLength / sizeof(NDIS_OID),
                                               pAdapter->DriverOIDList,
                                               pAdapter->NumDriverOIDs);

                    }

                    // the adapter init routine is waiting for a response
                    NdisSetEvent(pReqContext->pEvent);

                    break;
                }

                // something other than OID_GEN_SUPPORTED_LIST
                *pReqContext->pBytesNeeded = pQueryComplMessage->InformationBufferLength;

                if (pQueryComplMessage->InformationBufferLength > pReqContext->InformationBufferLength)
                {
                    TRACE0(("Query Complete (Oid = %08X): InfoBuffLen %d < %d\n",
                        pReqContext->Oid,
                        pQueryComplMessage->InformationBufferLength,
                        pReqContext->InformationBufferLength));

                    Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                    break;
                }

                if (pQueryComplMessage->Status != RNDIS_STATUS_SUCCESS)
                {
                    TRACE0(("Query Complete (Oid = %08X): error status %08X\n",
                        pReqContext->Oid, pQueryComplMessage->Status));

                    *pReqContext->pBytesNeeded = pQueryComplMessage->InformationBufferLength;
                    *pReqContext->pBytesWritten = 0;
                    Status = pQueryComplMessage->Status;
                }
                else
                {
                    // copy information from RNDIS message to NDIS buffer passed down
                    TRACE2(("QueryCompl: copy %d bytes to %p\n",
                        pQueryComplMessage->InformationBufferLength,
                        pReqContext->InformationBuffer));

                    RNDISMP_MOVE_MEM(pReqContext->InformationBuffer,
                                     MESSAGE_TO_INFO_BUFFER(pQueryComplMessage),
                                     pQueryComplMessage->InformationBufferLength);

                    // tell the upper layers the size
                    *pReqContext->pBytesWritten = pQueryComplMessage->InformationBufferLength;

                    BytesWritten = *pReqContext->pBytesWritten;
                    TRACE3(("Query Compl OK: Adapter %p, Oid %x\n",
                    		pAdapter, pReqContext->Oid));

                    TRACE2(("Info Data (%08X)\n", *((PUINT) pReqContext->InformationBuffer)));

                    if (pReqContext->Oid == OID_GEN_MEDIA_CONNECT_STATUS)
                    {
                    	TRACE3(("Adapter %p: link is %s\n",
                    		pAdapter, (((*(PULONG)pReqContext->InformationBuffer) == NdisMediaStateConnected)?
                    			"Connected": "Not connected")));
                    }

                    if (pReqContext->Oid == OID_GEN_MAC_OPTIONS)
                    {
                        PULONG  pMacOptions = (PULONG)pReqContext->InformationBuffer;
                        ULONG   MacOptions = *pMacOptions;

                        TRACE1(("Adapter %p: OID_GEN_MAC_OPTIONS from device is %x\n",
                                pAdapter, MacOptions));
                        //
                        // We only let the device dictate some of these bits.
                        //
                        MacOptions = (MacOptions & RNDIS_DEVICE_MAC_OPTIONS_MASK) |
                                      pAdapter->MacOptions;

                        *pMacOptions = MacOptions;

                        TRACE1(("Adapter %p: Modified OID_GEN_MAC_OPTIONS is %x\n",
                                pAdapter, *pMacOptions));
                    }


#if 0
                    //
                    //  Temp hack for old-firmware Peracom devices - report a smaller
                    //  value for max multicast list aize.
                    //  
                    if (pReqContext->Oid == OID_802_3_MAXIMUM_LIST_SIZE)
                    {
                        PULONG  pListSize = (PULONG)pReqContext->InformationBuffer;
                        if (*pListSize > 64)
                        {

                            TRACE1(("Adapter %p: Truncating max multicast list size from %d to 63!\n",
                                pAdapter, *pListSize));
                            *pListSize = 64;

                        }
                    }
#endif
                    //
                    // If this is an internally generated query,
                    // wake up the originating thread - that thread will
                    // take care of freeing resources.
                    //
                    if (bInternal && pReqContext->pEvent)
                    {
                        NdisSetEvent(pReqContext->pEvent);
                        pMsgFrame = NULL;
                        pReqContext = NULL;
                    }

                    Status = NDIS_STATUS_SUCCESS;
                }

                break;

            case REMOTE_NDIS_SET_CMPLT:

                TRACE2(("SetCompl: OID %08X, pReq %p, Status %x\n",
                        pReqContext->Oid,
                        pReqContext,
                        pSetComplMessage->Status));

                if (pSetComplMessage->Status == RNDIS_STATUS_SUCCESS)
                {
                    *pReqContext->pBytesRead = pReqContext->InformationBufferLength;
                    BytesRead = *pReqContext->pBytesRead;
                    Status = NDIS_STATUS_SUCCESS;
                }
                else
                {
                    // don't really expect to see this other than via NDISTEST

                    TRACE1(("Set Complete (Oid = %08X) failure: %08X\n",
                                pReqContext->Oid,
                                pSetComplMessage->Status));

                    *pReqContext->pBytesRead = 0;
                    BytesRead = 0;
                    Status = pSetComplMessage->Status;
                }

                pReqContext->CompletionStatus = Status;

                if (bInternal && pReqContext->pEvent)
                {
                    NdisSetEvent(pReqContext->pEvent);
                    pMsgFrame = NULL;
                    pReqContext = NULL;
                }

                break;

            default:
                TRACE1(("Invalid Ndis Message Type (%08X)\n", NdisMessageType));
                ASSERT(FALSE);  // we shouldn't have sent an invalid message type!
                break;
        }

        break;
    }
    while (FALSE);

    //
    // Send the completion to the upper layers unless it was a request
    // we generated outselves.
    //
    if (!bInternal && pReqContext)
    {
        if (pReqContext->pNdisRequest)
        {
            NdisMCoRequestComplete(Status,
                                   pAdapter->MiniportAdapterHandle,
                                   pReqContext->pNdisRequest);
        }
        else
        {
            if (NdisMessageType == REMOTE_NDIS_QUERY_CMPLT)
            {
                TRACE3(("Status (%08X)  BytesWritten (%08X)\n", Status, BytesWritten));
    
                // complete the query
    
                NdisMQueryInformationComplete(pAdapter->MiniportAdapterHandle,
                                              Status);
            }
            else if (NdisMessageType == REMOTE_NDIS_SET_CMPLT)
            {
                TRACE3(("Status (%08X)  BytesRead (%08X)\n", Status, BytesRead));

                // complete the set
                NdisMSetInformationComplete(pAdapter->MiniportAdapterHandle,
                                            Status);
            }
        }
    }

    if (pReqContext)
    {
        FreeRequestContext(pAdapter, pReqContext);
    }

    if (pMsgFrame)
    {
        DereferenceMsgFrame(pMsgFrame);
    }

    return (TRUE);

} // QuerySetCompletionMessage

/****************************************************************************/
/*                          CompleteSendDeviceRequest                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion of send of a device set or query request thru the microport. */
/*  If the message send failed, complete the request right now.             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - our context for the message                                 */
/*  SendStatus - microport's send status                                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  None.                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendDeviceRequest(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                          IN NDIS_STATUS            SendStatus)
{
    PRNDISMP_ADAPTER            pAdapter;
    PRNDISMP_MESSAGE_FRAME      pOrgMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    UINT                        NdisMessageType;

    pAdapter = pMsgFrame->pAdapter;

    TRACE3(("CompleteSendDevice Request: Adapter %p, MsgFrame %p, Status %x\n",
        pAdapter, pMsgFrame, SendStatus));
    
    if (SendStatus != NDIS_STATUS_SUCCESS)
    {
        //
        // Microport failed to send the Request message;
        // attempt to fail the original NDIS request.
        //
        TRACE1(("CompleteSendDeviceReq: Adapter %p, MsgFrame %p, failed %x\n",
                pAdapter, pMsgFrame, SendStatus));

        RNDISMP_LOOKUP_PENDING_MESSAGE(pOrgMsgFrame, pAdapter, pMsgFrame->RequestId);

        if (pOrgMsgFrame == pMsgFrame)
        {
            //
            // The request has not been aborted, so complete it now.
            //
            pReqContext = pMsgFrame->pReqContext;
            NdisMessageType = pMsgFrame->NdisMessageType;

            TRACE1(("CompleteSendReq: Adapter %p: Device req send failed, Oid %x, retry count %d\n",
                    pAdapter, pReqContext->Oid, pReqContext->RetryCount));

            if (NdisMessageType == REMOTE_NDIS_QUERY_MSG)
            {
                // complete the query
                NdisMQueryInformationComplete(pAdapter->MiniportAdapterHandle,
                                              SendStatus);
            }
            else if (NdisMessageType == REMOTE_NDIS_SET_MSG)
            {
                // complete the set
                NdisMSetInformationComplete(pAdapter->MiniportAdapterHandle,
                                            SendStatus);
            }
            else
            {
                ASSERT(FALSE);
            }

            FreeRequestContext(pAdapter, pReqContext);
            pMsgFrame->pReqContext = (PRNDISMP_REQUEST_CONTEXT)UlongToPtr(0xbcbcbcbc);

            //
            // Deref for NDIS request completion:
            //
            DereferenceMsgFrame(pMsgFrame);
        }
        //
        // else we failed to locate the request on the pending list;
        // it must have been removed when aborting all requests due
        // to a reset.
        //
    }
    //
    //  else sent the message out successfully; wait for a response.
    //

    //
    // Deref for send-complete:
    //
    DereferenceMsgFrame(pMsgFrame);
}

#ifdef BUILD_WIN9X
/****************************************************************************/
/*                    CompleteSendDiscardDeviceRequest                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion of send of a device set or query request thru the microport. */
/*  The sender of the request just wants us to free it up here.             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - our context for the message                                 */
/*  SendStatus - microport's send status                                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  None.                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendDiscardDeviceRequest(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                                 IN NDIS_STATUS            SendStatus)
{
    PRNDISMP_ADAPTER            pAdapter;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;

    pAdapter = pMsgFrame->pAdapter;
    pReqContext = pMsgFrame->pReqContext;

    TRACE1(("CompleteSendDiscard: Adapter %p, MsgFrame %p, ReqContext %p\n",
            pAdapter, pMsgFrame, pReqContext));

    FreeRequestContext(pAdapter, pReqContext);
    DereferenceMsgFrame(pMsgFrame);
}
#endif // BUILD_WIN9X

/****************************************************************************/
/*                          BuildOIDLists                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Build list of supported OIDs and associated function pointers           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - Adapter object                                                */
/*  DeviceOIDList - list of OIDs supported by the device                    */
/*  NumDeviceOID - number of OIDs supported by device                       */
/*  DriverOIDList - list of OIDs supported by the driver                    */
/*  NumDriverOID - number of OIDs supported by driver                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
BuildOIDLists(IN PRNDISMP_ADAPTER  Adapter, 
              IN PNDIS_OID         DeviceOIDList,
              IN UINT              NumDeviceOID,
              IN PNDIS_OID         DriverOIDList,
              IN UINT              NumDriverOID)
{
    UINT        DeviceIndex;
    UINT        DriverIndex;
    UINT        NumOID;
    NDIS_STATUS Status;
    PNDIS_OID   OIDList;
    PUINT       OIDHandlerList;

    TRACE3(("BuildOIDLists\n"));

    ASSERT(DeviceOIDList);
    ASSERT(DriverOIDList);
    
    NumOID  = NumDriverOID;

    // see what OIDs are duplicated in the device and route
    // those to the device
    for(DeviceIndex = 0; DeviceIndex < NumDeviceOID; DeviceIndex++)
    {
        for(DriverIndex = 0; DriverIndex < NumDriverOID; DriverIndex++)
        {
            if(DeviceOIDList[DeviceIndex] == DriverOIDList[DriverIndex])
            {
                // this OID is supported by the device, so don't
                // support in the driver, set to 0 for when we build new list
                DriverOIDList[DriverIndex] = 0;
                break;
            }
        }

        // if no match, increment the OID count
        if(DriverIndex == NumDriverOID)
            NumOID++;
    }

    // allocate OID list
    Status = MemAlloc(&Adapter->SupportedOIDList, 
                       NumOID * sizeof(NDIS_OID));

    // see if we got our buffer
    if(Status == NDIS_STATUS_SUCCESS)
    {
        Adapter->SupportedOIDListSize = NumOID * sizeof(NDIS_OID);
    }
    else
    {
        Adapter->OIDHandlerList         = (PUINT) NULL;
        Adapter->OIDHandlerListSize     = 0;

        Adapter->SupportedOIDList       = (PNDIS_OID) NULL;
        Adapter->SupportedOIDListSize   = 0;

        Status = NDIS_STATUS_FAILURE;

        goto BuildDone;
    }
    
    // allocate list to indicate whether the OID is device or driver supported
    Status = MemAlloc(&Adapter->OIDHandlerList, 
                       NumOID * sizeof(UINT));

    // see if we got our buffer
    if(Status == NDIS_STATUS_SUCCESS)
    {
        Adapter->OIDHandlerListSize = NumOID * sizeof(UINT);
    }
    else
    {
        // free up allocated OID list cause this allocation failed
        MemFree(Adapter->SupportedOIDList, Adapter->SupportedOIDListSize);

        Adapter->OIDHandlerList         = (PUINT) NULL;
        Adapter->OIDHandlerListSize     = 0;

        Adapter->SupportedOIDList       = (PNDIS_OID) NULL;
        Adapter->SupportedOIDListSize   = 0;

        Status = NDIS_STATUS_FAILURE;

        goto BuildDone;
    }

    Adapter->NumOIDSupported    = NumOID;
    OIDHandlerList              = Adapter->OIDHandlerList;
    OIDList                     = Adapter->SupportedOIDList;

    // O.K., build our lists
    for(DriverIndex = 0; DriverIndex < NumDriverOID; DriverIndex++)
    {
        if(DriverOIDList[DriverIndex] != 0)
        {
            // got one, so add to the list
            *OIDList = DriverOIDList[DriverIndex];
            OIDList++;

            // set flag
            *OIDHandlerList = DRIVER_SUPPORTED_OID;
            OIDHandlerList++;
        }
    }

    // let's add device supported OIDs
    for(DeviceIndex = 0; DeviceIndex < NumDeviceOID; DeviceIndex++)
    {
        if(DeviceOIDList[DeviceIndex] != 0)
        {
            // got one, so add to the list
            *OIDList = DeviceOIDList[DeviceIndex];
            OIDList++;

            // set flag
            *OIDHandlerList = DEVICE_SUPPORTED_OID;
            OIDHandlerList++;
        }
    }

    // Now do a fixup to point OID_GEN_SUPPORTED_LIST at the driver since
    // we now have a complete list.
    //
    for(DeviceIndex = 0; DeviceIndex < Adapter->NumOIDSupported; DeviceIndex++)
    {
        if (Adapter->SupportedOIDList[DeviceIndex] == OID_GEN_SUPPORTED_LIST)
        {
            Adapter->OIDHandlerList[DeviceIndex] = DRIVER_SUPPORTED_OID;
        }
    }

BuildDone:

    if(Status == NDIS_STATUS_SUCCESS)
    {
        DISPLAY_OID_LIST(Adapter);
    }

    return Status;
} // BuildOIDLists

/****************************************************************************/
/*                          GetOIDSupport                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Returns flag to indicate if OID is device or driver supported           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - Adapter object                                                */
/*  Oid - looking for a match on this OID                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  UINT                                                                    */
/*                                                                          */
/****************************************************************************/
UINT
GetOIDSupport(IN PRNDISMP_ADAPTER Adapter, IN NDIS_OID Oid)
{
    UINT Index;

    TRACE3(("GetOIDSupport\n"));

    // sanity check
    ASSERT(Adapter->SupportedOIDList);
    ASSERT(Adapter->OIDHandlerList);

    // search for a match on the OID
    for(Index = 0; Index < Adapter->NumOIDSupported; Index++)
    {
        if(Adapter->SupportedOIDList[Index] == Oid)
        {
            return Adapter->OIDHandlerList[Index];
        }
    }

    return OID_NOT_SUPPORTED;
} // GetOIDSupport


/****************************************************************************/
/*                          FreeOIDLists                                    */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free OID and handler lists                                              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - Adapter object                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
FreeOIDLists(IN PRNDISMP_ADAPTER Adapter)
{
    UINT        Size1, Size2;
    PUCHAR      Buffer1, Buffer2;

    TRACE3(("FreeOIDLists\n"));

    // grab the spinlock
    NdisAcquireSpinLock(&Adapter->Lock);

    Buffer1                         = (PUCHAR) Adapter->SupportedOIDList;
    Size1                           = Adapter->SupportedOIDListSize;

    Buffer2                         = (PUCHAR) Adapter->OIDHandlerList;
    Size2                           = Adapter->OIDHandlerListSize;

    Adapter->SupportedOIDList       = (PUINT) NULL;
    Adapter->SupportedOIDListSize   = 0;

    Adapter->OIDHandlerList         = (PUINT) NULL;
    Adapter->OIDHandlerListSize     = 0;
    Adapter->NumOIDSupported        = 0;

    // release spinlock
    NdisReleaseSpinLock(&Adapter->Lock);

    if(Buffer1)
        MemFree(Buffer1, Size1);

    if(Buffer2)
        MemFree(Buffer2, Size2);

} // FreeOIDLists    

/****************************************************************************/
/*                        AllocateRequestContext                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a context structure to keep track of an NDIS request           */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   PRNDISMP_REQUEST_CONTEXT                                               */
/*                                                                          */
/****************************************************************************/
PRNDISMP_REQUEST_CONTEXT
AllocateRequestContext(IN PRNDISMP_ADAPTER pAdapter)
{
    NDIS_STATUS                 Status;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;

    Status = MemAlloc(&pReqContext, sizeof(RNDISMP_REQUEST_CONTEXT));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        pReqContext = NULL;
    }

    TRACE3(("AllocReqContext: %p\n", pReqContext));

    return pReqContext;
} // AllocateRequestContext


/****************************************************************************/
/*                          FreeRequestContext                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Freeing up miniport resources associated with a request                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  pReqContext - Pointer to request context to be freed                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
FreeRequestContext(IN PRNDISMP_ADAPTER pAdapter, 
                   IN PRNDISMP_REQUEST_CONTEXT pReqContext)
{

    TRACE3(("FreeReqContext: %p\n", pReqContext));

    MemFree(pReqContext, -1);
} // FreeRequestContext




/****************************************************************************/
/*                          SyncQueryDevice                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Init-time routine called to query the device for an OID, and wait       */
/*  until we get a response.                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  Oid - Object Identifier to be queried                                   */
/*  InformationBuffer - buffer to copy query response into                  */
/*  InformationBufferLength - length of the above                           */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS_SUCCESS if successful, NDIS_STATUS_xxx error otherwise     */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
SyncQueryDevice(IN PRNDISMP_ADAPTER pAdapter,
                IN NDIS_OID Oid,
                IN OUT PUCHAR InformationBuffer,
                IN ULONG InformationBufferLength)
{
    NDIS_STATUS                 Status;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame = NULL;
    PRNDISMP_MESSAGE_FRAME      pPendingMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext = NULL;
    RNDIS_REQUEST_ID            RequestId;
    NDIS_EVENT                  Event;
    BOOLEAN                     bWokenUp;
    ULONG                       BytesNeeded, BytesWritten;

    do
    {
        pReqContext = AllocateRequestContext(pAdapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Build a query message for the specified OID.
        //
        pMsgFrame = BuildRndisMessageCommon(pAdapter, 
                                            NULL,
                                            REMOTE_NDIS_QUERY_MSG,
                                            Oid,
                                            (PVOID) NULL,
                                            0);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Context for the request - mark this as an internally generated
        // request.
        //
        pReqContext->pNdisRequest = NULL;
        pReqContext->Oid = Oid;
        pReqContext->InformationBuffer = InformationBuffer;
        pReqContext->InformationBufferLength = InformationBufferLength;
        pReqContext->pBytesNeeded = &BytesNeeded;
        pReqContext->pBytesWritten = &BytesWritten;
        pReqContext->pBytesRead = NULL;
        pReqContext->bInternal = TRUE;
        pReqContext->CompletionStatus = NDIS_STATUS_DEVICE_FAILED;

        NdisInitializeEvent(&Event);
        pReqContext->pEvent = &Event;

        pMsgFrame->pVc = NULL;
        pMsgFrame->pReqContext = pReqContext;

        RequestId = pMsgFrame->RequestId;

        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, NULL);

        RNDISMP_ASSERT_AT_PASSIVE();
        bWokenUp = NdisWaitEvent(&Event, MINIPORT_INIT_TIMEOUT);

        // remove the message from the pending queue - it may or may not be there.
        RNDISMP_LOOKUP_PENDING_MESSAGE(pPendingMsgFrame, pAdapter, RequestId);

        if (!bWokenUp || (pReqContext->CompletionStatus != NDIS_STATUS_SUCCESS))
        {
            TRACE1(("SyncQueryDevice error: Adapter %p, Oid %x, WokenUp %d, ComplStatus %x\n",
                pAdapter, Oid, bWokenUp, pReqContext->CompletionStatus));
            Status = NDIS_STATUS_DEVICE_FAILED;
            break;
        }

        Status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (pReqContext != NULL)
    {
        FreeRequestContext(pAdapter, pReqContext);
    }

    if (pMsgFrame != NULL)
    {
        DereferenceMsgFrame(pMsgFrame);
    }

    return (Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\queue.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    QUEUE.H

Abstract:

    Queueing routines used for lists of transmit, receive, and request "frames"

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/20/99 : created

Author:

    Tom Green

    
****************************************************************************/

#ifndef _QUEUE_H_
#define _QUEUE_H_


// QueueInitList - Macro which will initialize a queue to NULL
#define QueueInitList(_L) (_L)->Link.Flink = (_L)->Link.Blink = (PLIST_ENTRY)NULL;


// QueueEmpty - Macro which checks to see if a queue is empty
#define QueueEmpty(_L) (QueueGetHead((_L)) == (PRNDISMP_LIST_ENTRY) NULL)


// QueueGetHead - Macro which returns the head of the queue, but does not
//                remove the head from the queue
#define QueueGetHead(_L) ((PRNDISMP_LIST_ENTRY)((_L)->Link.Flink))


// QueuePushHead - Macro which puts an element at the head of the queue
#define QueuePushHead(_L, _E)                               \
{                                                           \
    ASSERT(_L);                                             \
    ASSERT(_E);                                             \
    if(!((_E)->Link.Flink = (_L)->Link.Flink))              \
    {                                                       \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E);               \
    }                                                       \
    (_L)->Link.Flink = (PLIST_ENTRY)(_E);                   \
}


// QueueRemoveHead - Macro which removes the head of queue
#define QueueRemoveHead(_L)                                 \
{                                                           \
    PRNDISMP_LIST_ENTRY ListElem;                           \
    ASSERT((_L));                                           \
    if(ListElem = (PRNDISMP_LIST_ENTRY)(_L)->Link.Flink)    \
    {                                                       \
        if(!((_L)->Link.Flink = ListElem->Link.Flink))      \
            (_L)->Link.Blink = (PLIST_ENTRY) NULL;          \
    }                                                       \
}

// QueuePutTail - Macro which puts an element at the tail (end) of the queue
#define QueuePutTail(_L, _E)                                \
{                                                           \
    ASSERT(_L);                                             \
    ASSERT(_E);                                             \
    if((_L)->Link.Blink)                                    \
    {                                                       \
        ((PRNDISMP_LIST_ENTRY)                              \
            (_L)->Link.Blink)->Link.Flink =                 \
            (PLIST_ENTRY)(_E);                              \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E);               \
    }                                                       \
    else                                                    \
    {                                                       \
        (_L)->Link.Flink =                                  \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E);               \
    }                                                       \
    (_E)->Link.Flink = (PLIST_ENTRY) NULL;                  \
}

// QueueGetTail - Macro which returns the tail of the queue, but 
//                does not remove the tail from the queue
#define QueueGetTail(_L) ((PRNDISMP_LIST_ENTRY)((_L)->Link.Blink))

// QueuePopHead -- Macro which  will pop the head off of a queue (list), and
//                 return it (this differs only from queueremovehead only in the 1st line)
#define QueuePopHead(_L)                                    \
(PRNDISMP_LIST_ENTRY) (_L)->Link.Flink; QueueRemoveHead(_L);

#endif // _QUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\send.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    SEND.C

Abstract:

    Multiple packet send routines for Remote NDIS Miniport driver

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/13/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"


ULONG   MdlsAllocated = 0;
ULONG   PktWrapperAllocated = 0;
ULONG   SndPacketCount = 0;
ULONG   SndTimerCount = 0;
ULONG   SndMaxPackets = 0;

BOOLEAN FirstDbg = FALSE;
BOOLEAN PrintPkts = FALSE;

/****************************************************************************/
/*                          RndismpMultipleSend                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  NDIS Entry point to send an array of NDIS packets on the specified      */
/*  adapter.                                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  PacketArray - An array of pointers to NDIS packets                      */
/*  NumberOfPackets - Number of packets in array                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RndismpMultipleSend(IN NDIS_HANDLE   MiniportAdapterContext,
                    IN PPNDIS_PACKET PacketArray,
                    IN UINT          NumberOfPackets)
{
    PRNDISMP_ADAPTER                pAdapter;
    PNDIS_PACKET                    pNdisPacket;
    PRNDISMP_SEND_PKT_RESERVED_TEMP pSendRsvdTemp;
    ULONG                           i;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE2(("RndismpMultipleSend\n"));

    if (pAdapter->bRunningOnWin9x)
    {
        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

        for (i = 0; i < NumberOfPackets; i++)
        {
            pNdisPacket = PacketArray[i];
            pSendRsvdTemp = PRNDISMP_RESERVED_TEMP_FROM_SEND_PACKET(pNdisPacket);

            InsertTailList(&pAdapter->PendingSendProcessList, &pSendRsvdTemp->Link);
        }

        if (!pAdapter->SendProcessInProgress)
        {
            pAdapter->SendProcessInProgress = TRUE;
            NdisSetTimer(&pAdapter->SendProcessTimer, 0);
        }

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
    }
    else
    {
        //
        //  Running on NT.
        //

        ASSERT(pAdapter->MultipleSendFunc != NULL);

        pAdapter->MultipleSendFunc(pAdapter,
                                   NULL,
                                   PacketArray,
                                   NumberOfPackets);
    }

}

/****************************************************************************/
/*                             DoMultipleSend                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  NDIS Entry point to send an array of NDIS packets on the specified      */
/*  adapter. Handles both connection-less and connection-oriented data.     */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to Adapter structure                                 */
/*  pVc - pointer to VC structure (NULL if CL send)                         */
/*  PacketArray - An array of pointers to NDIS packets                      */
/*  NumberOfPackets - Number of packets in array                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
DoMultipleSend(IN PRNDISMP_ADAPTER  pAdapter,
               IN PRNDISMP_VC       pVc OPTIONAL,
               IN PPNDIS_PACKET     PacketArray,
               IN UINT              NumberOfPackets)
{
    UINT                    PacketCount;
    PNDIS_PACKET            pNdisPacket;
    PNDIS_PACKET *          pPacketArray;
    PNDIS_PACKET *          pPktPointer;
    PRNDISMP_SEND_PKT_RESERVED   pResvd, pPrevResvd;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    PRNDISMP_PACKET_WRAPPER pPktWrapper;
    PMDL                    pMdl;
    ULONG                   TotalMessageLength; // of current message
    ULONG                   MessagePacketCount; // # of NDIS_PACKETS in this message
    ULONG                   CurPacketLength;
    PULONG                  pNextPacketOffset;
    NDIS_STATUS             Status;
    ULONG                   i;
    BOOLEAN                 bMorePackets;


    pNextPacketOffset = NULL;
    pMsgFrame = NULL;
    Status = NDIS_STATUS_SUCCESS;
    PacketCount = 0;

    do
    {
        if (pAdapter->Halting)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

        pPacketArray = &PacketArray[0];

#if DBG
        if (NumberOfPackets > 1)
        {
            if (FirstDbg)
            {
                FirstDbg = FALSE;
                PrintPkts = TRUE;
            }
            else
            {
                PrintPkts = FALSE;
            }
        }
#endif

        for (PacketCount = 0;
             PacketCount < NumberOfPackets;
             NOTHING)
        {
            pNdisPacket = *pPacketArray;

            NdisQueryPacket(pNdisPacket, NULL, NULL, NULL, &CurPacketLength);

            TRACE2(("Send: Pkt %d bytes\n", CurPacketLength));

            bMorePackets = (pAdapter->bMultiPacketSupported &&
                            (PacketCount < NumberOfPackets - 1));

            if (pMsgFrame == NULL)
            {
                //
                //  Allocate a frame.
                //
                pMsgFrame = AllocateMsgFrame(pAdapter);
                if (pMsgFrame == NULL)
                {
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }

                pMsgFrame->NdisMessageType = REMOTE_NDIS_PACKET_MSG;
                pMsgFrame->pVc = pVc;
                pMsgFrame->pNdisPacket = NULL;
                pPktPointer = &pMsgFrame->pNdisPacket;
                TotalMessageLength = 0;
                MessagePacketCount = 0;
                pPrevResvd = NULL;
            }

            //
            //  Allocate and fill up the RNDIS message header for this packet.
            //
            pPktWrapper = PrepareDataMessage(
                            pNdisPacket,
                            pAdapter,
                            pVc,
                            &TotalMessageLength);

            if (pPktWrapper != NULL)
            {
                pPktWrapper->pMsgFrame = pMsgFrame;
                pMdl = pPktWrapper->pHeaderMdl;

                //
                //  Initialize our context in this packet.
                //
                pResvd = PRNDISMP_RESERVED_FROM_SEND_PACKET(pNdisPacket);
                pResvd->pPktWrapper = pPktWrapper;
                pResvd->pNext = NULL;

                if (pMsgFrame->pMessageMdl == NULL)
                {
                    pMsgFrame->pMessageMdl = pMdl;
                }

                //
                //  Link this packet to the list.
                //
                *pPktPointer = pNdisPacket;
                MessagePacketCount++;

                if (pPrevResvd != NULL)
                {
                    pPrevResvd->pPktWrapper->pTailMdl->Next = pMdl;
                }
            }

            if ((pPktWrapper == NULL) ||
                (!bMorePackets) ||
                (MessagePacketCount == pAdapter->MaxPacketsPerMessage))
            {
                //
                //  Check if we have some data that we can send.
                //
                if (MessagePacketCount != 0)
                {
                    //
                    //  Send this off to the microport.
                    //
#if DBG
                    if (NumberOfPackets != 1)
                    {
                        TRACE2(("Send: MsgFrame %x, FirstPkt %x, %d/%d pkts\n",
                                pMsgFrame,
                                pMsgFrame->pNdisPacket,
                                MessagePacketCount,
                                NumberOfPackets));
                    }

                    {
                        PMDL    pTmpMdl;
                        PUCHAR  pBuf;
                        ULONG   Length;

                        for (pTmpMdl = pMsgFrame->pMessageMdl;
                             pTmpMdl != NULL;
                             pTmpMdl = pTmpMdl->Next)
                        {
                            Length = RNDISMP_GET_MDL_LENGTH(pTmpMdl);
                            pBuf = RNDISMP_GET_MDL_ADDRESS(pTmpMdl);
                            if (pBuf != NULL)
                            {
                                TRACEDUMP(("MDL %x\n", pTmpMdl), pBuf, Length);
                            }
                        }
                    }
#endif // DBG
                    {
                        ULONG   k;

                        for (k = 0; k < MessagePacketCount; k++)
                        {
                            RNDISMP_INCR_STAT(pAdapter, XmitToMicroport);
                        }
                    }

                    RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, FALSE, CompleteSendData);
                    MessagePacketCount = 0;
                    pMsgFrame = NULL;

                    if (pPktWrapper != NULL)
                    {
                        PacketCount++;
                        pPacketArray++;
                    }

                    continue;
                }
                else
                {
                    TRACE1(("RndismpMultipleSend: Adapter %x, fail: PktWrp %x, bMore %d, MsgPktCount %d\n",
                            pAdapter,
                            pPktWrapper,
                            bMorePackets,
                            MessagePacketCount));
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }
            }

            pPktPointer = &pResvd->pNext;

            pPrevResvd = pResvd;
            PacketCount++;
            pPacketArray++;
        }

        if (PacketCount < NumberOfPackets)
        {
            break;
        }

        Status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("DoMultipleSend: Adapter %x, failure Status %x, PktCount %d, TotalPkts %d\n",
             pAdapter, Status, PacketCount, NumberOfPackets));

        //
        //  Undo all we have done so far.
        //
        for (i = PacketCount; i < NumberOfPackets; i++)
        {
            RNDISMP_INCR_STAT(pAdapter, XmitError);

            if (pVc == NULL)
            {
                TRACE1(("DoMultipleSend: Adapter %x, failing pkt %x\n",
                        pAdapter, PacketArray[i]));

                NdisMSendComplete(pAdapter->MiniportAdapterHandle,
                                  PacketArray[i],
                                  Status);
            }
            else
            {
                CompleteSendDataOnVc(pVc, PacketArray[i], Status);
            }
        }

        if (pMsgFrame)
        {
            pMsgFrame->pMessageMdl = NULL;
            DereferenceMsgFrame(pMsgFrame);
        }

    }

    return;
}

/****************************************************************************/
/*                            DoMultipleSendRaw                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  NDIS Entry point to send an array of NDIS packets on the specified      */
/*  adapter. Unlike DoMultipleSend, this handles raw encapsulation.         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to Adapter structure                                 */
/*  pVc - pointer to VC structure (NULL if CL send)                         */
/*  PacketArray - An array of pointers to NDIS packets                      */
/*  NumberOfPackets - Number of packets in array                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
DoMultipleSendRaw(IN PRNDISMP_ADAPTER  pAdapter,
               IN PRNDISMP_VC       pVc OPTIONAL,
               IN PPNDIS_PACKET     PacketArray,
               IN UINT              NumberOfPackets)
{
    UINT                    PacketCount;
    PNDIS_PACKET            pNdisPacket;
    PNDIS_PACKET *          pPacketArray;
    PNDIS_PACKET *          pPktPointer;
    PRNDISMP_SEND_PKT_RESERVED   pResvd, pPrevResvd;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    PRNDISMP_PACKET_WRAPPER pPktWrapper;
    PMDL                    pMdl;
    ULONG                   TotalMessageLength; // of current message
    ULONG                   MessagePacketCount; // # of NDIS_PACKETS in this message
    ULONG                   CurPacketLength;
    PULONG                  pNextPacketOffset;
    NDIS_STATUS             Status;
    ULONG                   i;
    BOOLEAN                 bMorePackets;


    pNextPacketOffset = NULL;
    pMsgFrame = NULL;
    Status = NDIS_STATUS_SUCCESS;
    PacketCount = 0;

    if (pAdapter->Halting)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    } else
    {
        pPacketArray = &PacketArray[0];

#if DBG
        if (NumberOfPackets > 1)
        {
            if (FirstDbg)
            {
                FirstDbg = FALSE;
                PrintPkts = TRUE;
            }
            else
            {
                PrintPkts = FALSE;
            }
        }
#endif

        for (PacketCount = 0;
            PacketCount < NumberOfPackets;
            NOTHING)
        {
            pNdisPacket = *pPacketArray;

            NdisQueryPacket(pNdisPacket, NULL, NULL, NULL, &CurPacketLength);

            TRACE2(("Send: Pkt %d bytes\n", CurPacketLength));

            //
            //  Allocate a frame.
            //
            pMsgFrame = AllocateMsgFrame(pAdapter);
            if (pMsgFrame == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            pMsgFrame->NdisMessageType = REMOTE_NDIS_PACKET_MSG;
            pMsgFrame->pNdisPacket = pNdisPacket;
            NdisQueryPacket(pNdisPacket,NULL,NULL,&(pMsgFrame->pMessageMdl),NULL);
            TotalMessageLength = 0;

            pPktWrapper = PrepareDataMessageRaw(
                            pNdisPacket,
                            pAdapter,
                            &TotalMessageLength);

            if (pPktWrapper != NULL)
            {
                pPktWrapper->pMsgFrame = pMsgFrame;
                pMdl = pPktWrapper->pHeaderMdl;

                pResvd = PRNDISMP_RESERVED_FROM_SEND_PACKET(pNdisPacket);
                pResvd->pPktWrapper = pPktWrapper;
                pResvd->pNext = NULL;

                pMsgFrame->pMessageMdl = pMdl;

#ifdef DBG
                TRACE2(("Send: MsgFrame %x, Pkt %x\n",pMsgFrame, pMsgFrame->pNdisPacket));
#endif

                RNDISMP_INCR_STAT(pAdapter,XmitToMicroport);

                RNDISMP_SEND_TO_MICROPORT(pAdapter,pMsgFrame,FALSE,CompleteSendData);
            }

            PacketCount++;
        }
    }


    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("DoMultipleSendRaw: Adapter %x, failure Status %x, PktCount %d, TotalPkts %d\n",
             pAdapter, Status, PacketCount, NumberOfPackets));

        //
        //  Undo all we have done so far.
        //
        for (i = PacketCount; i < NumberOfPackets; i++)
        {
            RNDISMP_INCR_STAT(pAdapter, XmitError);

            TRACE1(("DoMultipleSendRaw: Adapter %x, failing pkt %x\n",
                     pAdapter, PacketArray[i]));

            NdisMSendComplete(pAdapter->MiniportAdapterHandle,
                              PacketArray[i],
                              Status);
        }

        if (pMsgFrame)
        {
            pMsgFrame->pMessageMdl = NULL;
            DereferenceMsgFrame(pMsgFrame);
        }

    }

    return;
}

/****************************************************************************/
/*                          PrepareDataMessage                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to prepare a complete or part of a data message.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pNdisPacket - the NDIS packet to be converted                           */
/*  pAdapter    - Adapter on which the packet is being sent                 */
/*  pVc         - VC on which the packet is sent (NULL if no VC context)    */
/*  pTotalMessageLength - On input, contains the total message length       */
/*       filled in so far. Updated on output.                               */
/*                                                                          */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_PACKET_WRAPPER                                               */
/*                                                                          */
/****************************************************************************/
PRNDISMP_PACKET_WRAPPER
PrepareDataMessage(IN   PNDIS_PACKET            pNdisPacket,
                   IN   PRNDISMP_ADAPTER        pAdapter,
                   IN   PRNDISMP_VC             pVc         OPTIONAL,
                   IN OUT PULONG                pTotalMessageLength)
{
    PMDL                        pMdl, pNextMdl;
    PMDL *                      ppNextMdl;
    PRNDISMP_PACKET_WRAPPER     pPktWrapper;
    RNDIS_MESSAGE UNALIGNED *   pRndisMessage;
    RNDIS_PACKET UNALIGNED *    pPacketMsg;
    PNDIS_BUFFER                pNdisBuffer;
    PNDIS_BUFFER                pNextNdisBuffer;
    ULONG                       TotalMessageLength;
    ULONG                       PacketMsgLength;
    ULONG                       OobDataLength;
    ULONG                       PerPacketInfoLength;
    ULONG                       AlignedLength;
    ULONG                       AlignmentOffset;
    ULONG                       TotalDataLength;
    ULONG                       TcpipChecksum, TcpLargeSend, PacketPriority;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    pPktWrapper = NULL;
    pMdl = NULL;

    do
    {
        TotalMessageLength = 0;

        RNDISMP_GET_ALIGNED_LENGTH(AlignedLength, *pTotalMessageLength, pAdapter);
        AlignmentOffset = (AlignedLength - *pTotalMessageLength);

        //
        //  Compute attachments. Zero for now.
        //  TBD -- do the real thing.
        //
        OobDataLength = 0;
        PerPacketInfoLength = 0;

        //
        //  Look for per-packet info elements, only on Win2K/Whistler.
        //
        if (!pAdapter->bRunningOnWin9x)
        {
            //
            //  TCP/IP checksum offload?
            //
            TcpipChecksum = PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, TcpIpChecksumPacketInfo));
            if (TcpipChecksum != 0)
            {
                PerPacketInfoLength += sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                TRACE2(("Send: Pkt %p has TCP checksum %x\n",
                        pNdisPacket, TcpipChecksum));
            }

            //
            //  TCP large send offload?
            //
            TcpLargeSend = PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, TcpLargeSendPacketInfo));
            if (TcpLargeSend != 0)
            {
                PerPacketInfoLength += sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                TRACE2(("Send: Pkt %p has TCP large send %x\n",
                        pNdisPacket, TcpLargeSend));
            }

            //
            //  Packet priority?
            //
            PacketPriority = PtrToUlong(NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, Ieee8021pPriority));
            if (PacketPriority != 0)
            {
                PerPacketInfoLength += sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                TRACE2(("Send: Pkt %p has priority %x\n",
                        pNdisPacket, PacketPriority));
            }
        }

        PacketMsgLength = sizeof(*pPacketMsg) +
                          OobDataLength +
                          PerPacketInfoLength +
                          AlignmentOffset;

        //
        //  Need space for common RNDIS message header.
        //
        PacketMsgLength += (sizeof(RNDIS_MESSAGE) - sizeof(RNDIS_MESSAGE_CONTAINER));

        NdisQueryPacket(pNdisPacket, NULL, NULL, NULL, &TotalDataLength);

        //
        //  We know the max transfer size of any message that we are allowed
        //  to send to the device. Is this going beyond that limit?
        //
        if (*pTotalMessageLength + PacketMsgLength + TotalDataLength >
                pAdapter->MaxTransferSize)
        {
            TRACE2(("PrepareDataMessage: Adapter %x, pkt %x, length %d > device limit (%d)\n",
                    pAdapter,
                    pNdisPacket,
                    *pTotalMessageLength + PacketMsgLength + TotalDataLength,
                    pAdapter->MaxTransferSize));
            break;
        }

        //
        //  Allocate an RNDIS_PACKET buffer.
        //
        pPktWrapper = AllocatePacketMsgWrapper(pAdapter, PacketMsgLength);

        if (pPktWrapper == NULL)
        {
            TRACE1(("PrepareDataMessage: failed to alloc wrapper, Adapter %x, Length %d\n", pAdapter, PacketMsgLength));
            ASSERT(FALSE);
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pPktWrapper->pNdisPacket = pNdisPacket;
        pPktWrapper->pVc = pVc;
        pRndisMessage = (PRNDIS_MESSAGE)
                        ((ULONG_PTR)&pPktWrapper->Packet[0] + AlignmentOffset);

        pPacketMsg = (PRNDIS_PACKET)(&pRndisMessage->Message);
        pRndisMessage->NdisMessageType = REMOTE_NDIS_PACKET_MSG;

        if (pVc == NULL)
        {
            pPacketMsg->VcHandle = 0;
        }
        else
        {
            pPacketMsg->VcHandle = pVc->DeviceVcContext;
        }

#if DBG
        if (PrintPkts)
        {
            TRACE1(("  Offs %d/x%x AlignOff %d/x%x, DataLen %d/x%x\n",
                    *pTotalMessageLength, *pTotalMessageLength,
                    AlignmentOffset, AlignmentOffset,
                    TotalDataLength, TotalDataLength));
        }
#endif // DBG

        //
        //  Allocate MDLs for the RNDIS_PACKET header and for each
        //  component NDIS buffer in the packet.
        //
        pMdl = IoAllocateMdl(
                    &pPktWrapper->Packet[0],
                    PacketMsgLength,
                    FALSE,
                    FALSE,
                    NULL);


        if (pMdl == NULL)
        {
            TRACE1(("PrepareDataMsg: Adapter %x failed to alloc MDL for header\n", pAdapter));
            Status = NDIS_STATUS_RESOURCES;
            TRACE1(("PrepareDataMsg: outstanding MDL count %d, at %x\n", MdlsAllocated, &MdlsAllocated));
            ASSERT(FALSE);
            break;
        }

        NdisInterlockedIncrement(&MdlsAllocated);

        MmBuildMdlForNonPagedPool(pMdl);

        pMdl->Next = NULL;
        pPktWrapper->pHeaderMdl = pMdl;
        ppNextMdl = &pMdl->Next;

        TRACE2(("PrepareDataMsg: NdisPkt %x, PacketMsgLen %d, TotalDatalen %d, Mdl %x, pRndisMessage %x\n",
                pNdisPacket, PacketMsgLength, TotalDataLength, pMdl, pRndisMessage));

        TotalDataLength = 0;

        for (pNdisBuffer = pNdisPacket->Private.Head;
             pNdisBuffer != NULL;
             pNdisBuffer = pNextNdisBuffer)
        {
            PVOID       VirtualAddress;
            UINT        BufferLength;

            NdisGetNextBuffer(pNdisBuffer, &pNextNdisBuffer);

#ifndef BUILD_WIN9X
            NdisQueryBufferSafe(pNdisBuffer, &VirtualAddress, &BufferLength, NormalPagePriority);
            if ((BufferLength != 0) && (VirtualAddress == NULL))
            {
                TRACE1(("PrepareDataMsg: Adapter %x failed to query buffer %p, Pkt %p\n",
                        pAdapter, pNdisBuffer, pNdisPacket));
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
#else
            NdisQueryBuffer(pNdisBuffer, &VirtualAddress, &BufferLength);
#endif // BUILD_WIN9X

            //
            //  Skip any 0-length buffers given to us by IP or NDISTEST
            //
            if (BufferLength != 0)
            {
                TotalDataLength += BufferLength;

                pMdl = IoAllocateMdl(
                        VirtualAddress,
                        BufferLength,
                        FALSE,
                        FALSE,
                        NULL);

                if (pMdl == NULL)
                {
                    TRACE1(("PrepareDataMsg: Adapter %x failed to alloc MDL\n", pAdapter));
                    Status = NDIS_STATUS_RESOURCES;
                    TRACE1(("PrepareDataMsg: outstanding MDL count %d, at %x\n", MdlsAllocated, &MdlsAllocated));
                    ASSERT(FALSE);
                    break;
                }

                NdisInterlockedIncrement(&MdlsAllocated);

                MmBuildMdlForNonPagedPool(pMdl);
                *ppNextMdl = pMdl;
                ppNextMdl = &pMdl->Next;

                pMdl->Next = NULL;
            }
        }
        
        if (pNdisBuffer != NULL)
        {
            //
            //  We bailed out before reaching the end of the list.
            //
            break;
        }

        *ppNextMdl = NULL;
        pPktWrapper->pTailMdl = pMdl;

        TotalMessageLength += (PacketMsgLength + TotalDataLength);
        pRndisMessage->MessageLength = PacketMsgLength + TotalDataLength;

        *pTotalMessageLength += TotalMessageLength;

        //
        //  Fill in the RNDIS_PACKET message completely now.
        //
        pPacketMsg->DataOffset = sizeof(RNDIS_PACKET) + OobDataLength + PerPacketInfoLength;
        pPacketMsg->DataLength = TotalDataLength;

        if (PerPacketInfoLength)
        {
            PRNDIS_PER_PACKET_INFO  pPerPacketInfo;

            pPacketMsg->PerPacketInfoOffset = sizeof(RNDIS_PACKET);
            pPacketMsg->PerPacketInfoLength = PerPacketInfoLength;

            pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPacketMsg + sizeof(RNDIS_PACKET));
            if (TcpipChecksum)
            {
                pPerPacketInfo->Size = sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                pPerPacketInfo->Type = TcpIpChecksumPacketInfo;
                pPerPacketInfo->PerPacketInformationOffset = sizeof(RNDIS_PER_PACKET_INFO);
                *(PULONG)(pPerPacketInfo + 1) = TcpipChecksum;
                pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPerPacketInfo + pPerPacketInfo->Size);
            }

            if (TcpLargeSend)
            {
                pPerPacketInfo->Size = sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                pPerPacketInfo->Type = TcpLargeSendPacketInfo;
                pPerPacketInfo->PerPacketInformationOffset = sizeof(RNDIS_PER_PACKET_INFO);
                *(PULONG)(pPerPacketInfo + 1) = TcpLargeSend;
                pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPerPacketInfo + pPerPacketInfo->Size);
                //
                //  Since we do not have a send-completion message, we fill up
                //  the "ack" for large send right here.
                //
                NDIS_PER_PACKET_INFO_FROM_PACKET(pNdisPacket, TcpLargeSendPacketInfo) =
                    UlongToPtr(TotalDataLength);
            }

            if (PacketPriority)
            {
                pPerPacketInfo->Size = sizeof(RNDIS_PER_PACKET_INFO) + sizeof(ULONG);
                pPerPacketInfo->Type = Ieee8021pPriority;
                pPerPacketInfo->PerPacketInformationOffset = sizeof(RNDIS_PER_PACKET_INFO);
                *(PULONG)(pPerPacketInfo + 1) = PacketPriority;
                pPerPacketInfo = (PRNDIS_PER_PACKET_INFO)((PUCHAR)pPerPacketInfo + pPerPacketInfo->Size);
            }
        }

    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("PrepareDataMessage: Adapter %x, failed %x\n", pAdapter, Status));

        //
        //  Undo all we have done so far.
        //
        if (pPktWrapper)
        {
            for (pMdl = pPktWrapper->pHeaderMdl;
                 pMdl != NULL;
                 pMdl = pNextMdl)
            {
                pNextMdl = pMdl->Next;
                IoFreeMdl(pMdl);
                NdisInterlockedDecrement(&MdlsAllocated);
            }

            FreePacketMsgWrapper(pPktWrapper);

            pPktWrapper = NULL;
        }
    }

    TRACE2(("PrepareDataMessage (%08X)\n", pPktWrapper));
    return (pPktWrapper);
}
/****************************************************************************/
/*                         PrepareDataMessageRaw                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility routine to prepare a complete or part of a data message.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pNdisPacket - the NDIS packet to be converted                           */
/*  pAdapter    - Adapter on which the packet is being sent                 */
/*  pVc         - VC on which the packet is sent (NULL if no VC context)    */
/*  pTotalMessageLength - On input, contains the total message length       */
/*       filled in so far. Updated on output.                               */
/*                                                                          */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_PACKET_WRAPPER                                               */
/*                                                                          */
/****************************************************************************/
PRNDISMP_PACKET_WRAPPER
PrepareDataMessageRaw(IN   PNDIS_PACKET            pNdisPacket,
                      IN   PRNDISMP_ADAPTER        pAdapter,
                      IN OUT PULONG                pTotalMessageLength)
{
    PMDL                        pMdl, pNextMdl;
    PMDL *                      ppNextMdl;
    PRNDISMP_PACKET_WRAPPER     pPktWrapper;
    RNDIS_MESSAGE UNALIGNED *   pRndisMessage;
    PNDIS_BUFFER                pNdisBuffer;
    PNDIS_BUFFER                pNextNdisBuffer;
    ULONG                       TotalMessageLength;
    ULONG                       TotalDataLength;
    ULONG                       AlignedLength;
    ULONG                       AlignmentOffset;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    pPktWrapper = NULL;
    pMdl = NULL;
    
    RNDISMP_GET_ALIGNED_LENGTH(AlignedLength, *pTotalMessageLength, pAdapter);
    AlignmentOffset = (AlignedLength - *pTotalMessageLength);

    do
    {
        TotalMessageLength = 0;


        //
        //  Allocate an RNDIS_PACKET buffer.
        //
        pPktWrapper = AllocatePacketMsgWrapper(pAdapter, 0);

        if (pPktWrapper == NULL)
        {
            TRACE1(("PrepareDataMessage: failed to alloc wrapper, Adapter %x\n", pAdapter));
            ASSERT(FALSE);
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pPktWrapper->pNdisPacket = pNdisPacket;
        pPktWrapper->pVc = NULL;
		pPktWrapper->pHeaderMdl = NULL;

        TotalDataLength = 0;

        for (pNdisBuffer = pNdisPacket->Private.Head;
             pNdisBuffer != NULL;
             pNdisBuffer = pNextNdisBuffer)
        {
            PVOID       VirtualAddress;
            UINT        BufferLength;

            NdisGetNextBuffer(pNdisBuffer, &pNextNdisBuffer);

#ifndef BUILD_WIN9X
            NdisQueryBufferSafe(pNdisBuffer, &VirtualAddress, &BufferLength, NormalPagePriority);
            if ((BufferLength != 0) && (VirtualAddress == NULL))
            {
                TRACE1(("PrepareDataMsg: Adapter %x failed to query buffer %p, Pkt %p\n",
                        pAdapter, pNdisBuffer, pNdisPacket));
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
#else
            NdisQueryBuffer(pNdisBuffer, &VirtualAddress, &BufferLength);
#endif // BUILD_WIN9X

            //
            //  Skip any 0-length buffers given to us by IP or NDISTEST
            //
            if (BufferLength != 0)
            {
                TotalDataLength += BufferLength;

                pMdl = IoAllocateMdl(
                        VirtualAddress,
                        BufferLength,
                        FALSE,
                        FALSE,
                        NULL);

                if (pMdl == NULL)
                {
                    TRACE1(("PrepareDataMsg: Adapter %x failed to alloc MDL\n", pAdapter));
                    Status = NDIS_STATUS_RESOURCES;
                    TRACE1(("PrepareDataMsg: outstanding MDL count %d, at %x\n", MdlsAllocated, &MdlsAllocated));
                    ASSERT(FALSE);
                    break;
                }

                pMdl->Next = NULL;

                if (pPktWrapper->pHeaderMdl == NULL)
                {
                    pPktWrapper->pHeaderMdl = pMdl;
                    pPktWrapper->pTailMdl = pMdl;
                } else
                {
                    pPktWrapper->pTailMdl->Next = pMdl;
                    pPktWrapper->pTailMdl = pMdl;
                }


                NdisInterlockedIncrement(&MdlsAllocated);
                MmBuildMdlForNonPagedPool(pMdl);
            }
        }
        
        if (pNdisBuffer != NULL)
        {
            //
            //  We bailed out before reaching the end of the list.
            //
            break;
        }

        

        *pTotalMessageLength += TotalDataLength;

    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("PrepareDataMessage: Adapter %x, failed %x\n", pAdapter, Status));

        //
        //  Undo all we have done so far.
        //
        if (pPktWrapper)
        {
            for (pMdl = pPktWrapper->pHeaderMdl;
                 pMdl != NULL;
                 pMdl = pNextMdl)
            {
                pNextMdl = pMdl->Next;
                IoFreeMdl(pMdl);
                NdisInterlockedDecrement(&MdlsAllocated);
            }

            FreePacketMsgWrapper(pPktWrapper);

            pPktWrapper = NULL;
        }
    }

    TRACE2(("PrepareDataMessage (%08X)\n", pPktWrapper));
    return (pPktWrapper);
}



/****************************************************************************/
/*                          AllocatePacketMsgWrapper                        */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a structure to keep information about one NDIS packet sent     */
/*  through the microport.                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Adapter on which this packet is going to be sent.            */
/*  MsgHeaderLength - Total length of the wrapper structure                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_PACKET_WRAPPER                                               */
/*                                                                          */
/****************************************************************************/
PRNDISMP_PACKET_WRAPPER
AllocatePacketMsgWrapper(IN PRNDISMP_ADAPTER        pAdapter,
                         IN ULONG                   MsgHeaderLength)
{
    PRNDISMP_PACKET_WRAPPER     pPktWrapper;
    NDIS_STATUS                 Status;
    ULONG                       TotalLength;

    TotalLength = sizeof(RNDISMP_PACKET_WRAPPER) + MsgHeaderLength;

    Status = MemAlloc(&pPktWrapper, TotalLength);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisZeroMemory(pPktWrapper, TotalLength);
        NdisInterlockedIncrement(&PktWrapperAllocated);
    }
    else
    {
        TRACE1(("AllocPacketMsgWrapper failed, adapter %x, alloc count %d at %x\n",
            pAdapter, PktWrapperAllocated, &PktWrapperAllocated));
        ASSERT(FALSE);
        pPktWrapper = NULL;
    }

    return (pPktWrapper);
}

    


/****************************************************************************/
/*                          FreePacketMsgWrapper                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free a structure used to keep information about one NDIS packet sent    */
/*  through the microport.                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pPktWrapper - Pointer to wrapper structure.                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
FreePacketMsgWrapper(IN PRNDISMP_PACKET_WRAPPER     pPktWrapper)
{
    MemFree(pPktWrapper, sizeof(RNDISMP_PACKET_WRAPPER));
    NdisInterlockedDecrement(&PktWrapperAllocated);
}


/****************************************************************************/
/*                          CompleteSendData                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback function to handle completion of send data message sent        */
/*  down to microport                                                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - our frame structure holding information about a send        */
/*  SendStatus - indicate status of send message                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendData(IN  PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN  NDIS_STATUS            SendStatus)
{
    PRNDISMP_ADAPTER            Adapter;
    PNDIS_PACKET                Packet;
    PMDL                        pMdl, pNextMdl;
    PRNDISMP_PACKET_WRAPPER     pPktWrapper, pNextPktWrapper;
    PRNDISMP_SEND_PKT_RESERVED  pResvd;
    PNDIS_PACKET                NextPacket;
    PRNDISMP_VC                 pVc;


    Adapter = pMsgFrame->pAdapter;

    TRACE2(("CompleteSendData: Adapter %x, MsgFrame %x, SendStatus %x\n",
                Adapter, pMsgFrame, SendStatus));

#if DBG_TIME_STAMPS
    {
        ULONG   NowTime;
        ULONG   PendedTime;

        RNDISMP_GET_TIME_STAMP(&NowTime);
        PendedTime = NowTime - pMsgFrame->TimeSent;
        if (PendedTime > Adapter->MaxSendCompleteTime)
        {
            TRACE1(("CompleteSendData: Adapter %x: pend time %d millisec\n",
                    Adapter, PendedTime));
            Adapter->MaxSendCompleteTime = PendedTime;
        }
    }
#endif // DBG_TIME_STAMPS

    //
    // free all MDLs we had allocated.
    //
    for (pMdl = pMsgFrame->pMessageMdl;
         pMdl != NULL;
         pMdl = pNextMdl)
    {
        pNextMdl = pMdl->Next;
        IoFreeMdl(pMdl);
        NdisInterlockedDecrement(&MdlsAllocated);
    }


    //
    // we may have sent several NDIS packets in one message
    // so we have to walk the list and complete each one
    //
    for (Packet = pMsgFrame->pNdisPacket;
         Packet != NULL;
         Packet = NextPacket)
    {
        pResvd = PRNDISMP_RESERVED_FROM_SEND_PACKET(Packet);

        // get the next packet linked
        NextPacket = pResvd->pNext;

        pPktWrapper = pResvd->pPktWrapper;
#if DBG
        if (NextPacket != NULL)
        {
            TRACE2(("CompleteSendData: multi: MsgFrame %x, tpkt %x, wrapper %x\n",
                pMsgFrame, Packet,
                // *(PULONG)((PUCHAR)Packet + 0x98),
                pPktWrapper));
        }
#endif // DBG

        pVc = pPktWrapper->pVc;

        // free the wrapper structure for this packet.
        FreePacketMsgWrapper(pPktWrapper);

        // send completion to upper layers
        TRACE2(("CompleteSendData: Adapter %x, completing pkt %x\n", Adapter, Packet));

        if (SendStatus == NDIS_STATUS_SUCCESS)
        {
            RNDISMP_INCR_STAT(Adapter, XmitOk);
        }
        else
        {
            RNDISMP_INCR_STAT(Adapter, XmitError);
        }

        if (pVc == NULL)
        {
            NdisMSendComplete(Adapter->MiniportAdapterHandle,
                              Packet,
                              SendStatus);
        }
        else
        {
            CompleteSendDataOnVc(pVc, Packet, SendStatus);
        }
    }

    // free up frame and resources
    pMsgFrame->pMessageMdl = NULL;
    DereferenceMsgFrame(pMsgFrame);


} // CompleteSendData


/****************************************************************************/
/*                          FreeMsgAfterSend                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by microport to indicate completion of send data message sent    */
/*  down by miniport                                                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - our frame structure holding information about a send        */
/*  SendStatus - indicate status of send message                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
FreeMsgAfterSend(IN  PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN  NDIS_STATUS            SendStatus)
{
    DereferenceMsgFrame(pMsgFrame);
}


#if THROTTLE_MESSAGES
/****************************************************************************/
/*                          QueueMessageToMicroport                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Queue the given message on the list of messages to be send to the       */
/*  microport, and start sending down these, if we haven't sent too many    */
/*  already.                                                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter  - our Adapter structure                                       */
/*  pMsgFrame - our frame structure holding information about a send        */
/*  bQueueMessageForResponse - add this message to the pending-response     */
/*                              list on the adapter. We expect a response   */
/*                              for this from the device.                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
QueueMessageToMicroport(IN PRNDISMP_ADAPTER pAdapter,
                        IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                        IN BOOLEAN bQueueMessageForResponse)
{
    PLIST_ENTRY             pEnt;
    PRNDISMP_MESSAGE_FRAME  pFrame;
    RM_CHANNEL_TYPE         ChannelType;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    do
    {
        if (pMsgFrame)
        {
            //
            //  Add to waiting queue.
            //
            InsertTailList(&pAdapter->WaitingMessageList, &pMsgFrame->PendLink);
            if (bQueueMessageForResponse)
            {
                InsertTailList(&pAdapter->PendingFrameList, &pMsgFrame->Link);
            }
        }

        //
        //  Prevent more than one thread from executing below.
        //
        if (pAdapter->SendInProgress)
        {
            break;
        }

        pAdapter->SendInProgress = TRUE;

        //
        //  Send as many messages to the microport as we can, without exceeding
        //  the high-water mark for messages pending at the microport.
        //
        while ((pAdapter->CurPendedMessages < pAdapter->HiWatPendedMessages) &&
               !IsListEmpty(&pAdapter->WaitingMessageList))
        {
            //
            //  Take out the first message in the waiting queue.
            //
            pEnt = pAdapter->WaitingMessageList.Flink;
            pFrame = CONTAINING_RECORD(pEnt, RNDISMP_MESSAGE_FRAME, PendLink);
            RemoveEntryList(pEnt);

            CHECK_VALID_FRAME(pFrame);

            pAdapter->CurPendedMessages++;
            InsertTailList(&pAdapter->PendingAtMicroportList, pEnt);

            RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

            RNDISMP_GET_TIME_STAMP(&pFrame->TimeSent);

            DBG_LOG_SEND_MSG(pAdapter, pFrame);

            //
            //  Check if we are halting the adapter, fail if so.
            //  NOTE: the only message we let thru is a HALT.
            //
            if (pAdapter->Halting &&
                (pFrame->NdisMessageType != REMOTE_NDIS_HALT_MSG))
            {
                TRACE1(("QueueMsg: Adapter %x is halting, dropped msg 0x%x!\n", 
                        pAdapter, pFrame->NdisMessageType));

                RndisMSendComplete(
                    (NDIS_HANDLE)pAdapter,
                    pFrame,
                    NDIS_STATUS_NOT_ACCEPTED);

                RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

                continue;
            }
            
            //
            //  Send the message to the microport. The microport will
            //  call RndisMSendComplete when it is done with it.
            //
#if DBG
            {
                ULONG       Length;
                PUCHAR      pBuf;

                Length = RNDISMP_GET_MDL_LENGTH(pFrame->pMessageMdl);
                pBuf = RNDISMP_GET_MDL_ADDRESS(pFrame->pMessageMdl);
                if (pBuf != NULL)
                {
                    TRACEDUMP(("Sending msg type %x (%d bytes):\n",
                                pFrame->NdisMessageType, Length), pBuf, Length);
                }
            }
#endif

            //
            // Does this go on the data or control channel of the microport?
            //
            if (pFrame->NdisMessageType == REMOTE_NDIS_PACKET_MSG)
            {
                ChannelType = RMC_DATA;
            }
            else
            {
                ChannelType = RMC_CONTROL;
            }

            (pAdapter)->RmSendMessageHandler(pAdapter->MicroportAdapterContext,
                                             pFrame->pMessageMdl,
                                             (NDIS_HANDLE)pFrame,
                                             ChannelType);

            RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);
        }

        pAdapter->SendInProgress = FALSE;

    }
    while (FALSE);

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
}


/****************************************************************************/
/*                          FlushPendingMessages                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Remove and send-complete any messages pending to be sent to the         */
/*  microport.                                                              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter  - our Adapter structure                                       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
FlushPendingMessages(IN  PRNDISMP_ADAPTER        pAdapter)
{
    PLIST_ENTRY             pEnt;
    PRNDISMP_MESSAGE_FRAME  pFrame;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    //
    //  Prevent further sends to microport.
    //
    pAdapter->SendInProgress = TRUE;

    while (!IsListEmpty(&pAdapter->WaitingMessageList))
    {
        //
        //  Take out the first message in the waiting queue.
        //
        pEnt = pAdapter->WaitingMessageList.Flink;
        pFrame = CONTAINING_RECORD(pEnt, RNDISMP_MESSAGE_FRAME, PendLink);
        RemoveEntryList(pEnt);
        
        CHECK_VALID_FRAME(pFrame);

        //
        //  Fake send to microport
        //
        pAdapter->CurPendedMessages++;
        InsertTailList(&pAdapter->PendingAtMicroportList, pEnt);

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

        TRACE1(("Flush: Adapter %x, MsgFrame %x, MsgType %x\n",
                pAdapter, pFrame, pFrame->NdisMessageType));

        //
        //  Complete it right here.
        //
        RndisMSendComplete(
            (NDIS_HANDLE)pAdapter,
            pFrame,
            NDIS_STATUS_NOT_ACCEPTED);

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);
    }

    pAdapter->SendInProgress = FALSE;

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

    TRACE1(("Flush done, adapter %x\n", pAdapter));
}



#endif // THROTTLE_MESSAGES



/****************************************************************************/
/*                       SendProcessTimeout                                 */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Timeout callback routine to handle all sends. This is to avoid issues   */
/*  with TCP/IP stack preemption on WinME.                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  SystemSpecific[1-3] - Ignored                                           */
/*  Context - Pointer to our Adapter structure                              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
SendProcessTimeout(IN PVOID SystemSpecific1,
                 IN PVOID Context,
                 IN PVOID SystemSpecific2,
                 IN PVOID SystemSpecific3)
{
    PRNDISMP_ADAPTER                pAdapter;
    PNDIS_PACKET                    pNdisPacket;
    PRNDISMP_SEND_PKT_RESERVED_TEMP pSendResvdTemp;
    PLIST_ENTRY                     pEntry;
    NDIS_STATUS                     Status;
    ULONG                           NumPkts;
    ULONG                           CurPkts;
#define MAX_MULTI_SEND  20
    PNDIS_PACKET                    PacketArray[MAX_MULTI_SEND];

    pAdapter = (PRNDISMP_ADAPTER)Context;
    CHECK_VALID_ADAPTER(pAdapter);

    ASSERT(pAdapter->SendProcessInProgress == TRUE);

    SndTimerCount++;

    NumPkts = 0;
    CurPkts = 0;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    while (!IsListEmpty(&pAdapter->PendingSendProcessList))
    {
        pEntry = RemoveHeadList(&pAdapter->PendingSendProcessList);

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

        SndPacketCount++;
        CurPkts++;

        pSendResvdTemp = CONTAINING_RECORD(pEntry, RNDISMP_SEND_PKT_RESERVED_TEMP, Link);
        pNdisPacket = CONTAINING_RECORD(pSendResvdTemp, NDIS_PACKET, MiniportReserved);
        PacketArray[NumPkts] = pNdisPacket;

        NumPkts++;

        if (NumPkts == MAX_MULTI_SEND)
        {
            pAdapter->MultipleSendFunc(pAdapter, NULL, PacketArray, NumPkts);
            NumPkts = 0;
        }

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);
    }

    pAdapter->SendProcessInProgress = FALSE;

    SndMaxPackets = MAX(SndMaxPackets, CurPkts);

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

    if (NumPkts != 0)
    {
        pAdapter->MultipleSendFunc(pAdapter, NULL, PacketArray, NumPkts);
    }


} // SendProcessTimeout
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\rndismp.h ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDISMP.H

Abstract:

    Header file for Remote NDIS Miniport driver. Sits on top of Remote 
    NDIS bus specific layers.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/6/99 : created

Author:

    Tom Green

    
****************************************************************************/

#ifndef _RNDISMP_H_
#define _RNDISMP_H_

#ifndef OID_GEN_RNDIS_CONFIG_PARAMETER
#define OID_GEN_RNDIS_CONFIG_PARAMETER          0x0001021B  // Set only
#endif


//
// DEBUG stuff
//

#if DBG


//
// Definitions for all of the Debug macros.  If we're in a debug (DBG) mode,
// these macros will print information to the debug terminal.  If the
// driver is compiled in a free (non-debug) environment the macros become
// NOPs.
//

VOID
NTAPI
DbgBreakPoint(VOID);

//
// DEBUG enable bit definitions
//
#define DBG_LEVEL0          0x1000      // Display TRACE0 messages
#define DBG_LEVEL1          0x0001      // Display TRACE1 messages
#define DBG_LEVEL2          0x0002      // Display TRACE2 messages
#define DBG_LEVEL3          0x0004      // Display TRACE3 messages
#define DBG_OID_LIST        0x0008      // display OID list
#define DBG_OID_NAME        0x0010      // display name of OID in query and set routines
#define DBG_DUMP            0x0020      // Display buffer dumps
#define DBG_LOG_SENDS       0x0100      // Log sent messages.

#define TRACE0(S)     {if(RndismpDebugFlags & DBG_LEVEL0) {DbgPrint("RNDISMP: "); DbgPrint S;}}
#define TRACE1(S)     {if(RndismpDebugFlags & DBG_LEVEL1) {DbgPrint("RNDISMP: "); DbgPrint S;}}
#define TRACE2(S)     {if(RndismpDebugFlags & DBG_LEVEL2) {DbgPrint("RNDISMP: "); DbgPrint S;}}
#define TRACE3(S)     {if(RndismpDebugFlags & DBG_LEVEL3) {DbgPrint("RNDISMP: "); DbgPrint S;}}

#define TRACEDUMP(_s, _buf, _len)     {if(RndismpDebugFlags & DBG_DUMP) {DbgPrint("RNDISMP: "); DbgPrint _s; RndisPrintHexDump(_buf, _len);}}

#define DISPLAY_OID_LIST(Adapter)   DisplayOidList(Adapter)

#define GET_OID_NAME(Oid)           GetOidName(Oid)

#define OID_NAME_TRACE(Oid, s)                                 \
{                                                               \
    if(RndismpDebugFlags & DBG_OID_NAME)                        \
        DbgPrint("RNDISMP: %s: (%s)  (%08X)\n", s, GET_OID_NAME(Oid), Oid);     \
}

#undef ASSERT
#define ASSERT(exp)                                             \
{                                                               \
    if(!(exp))                                                  \
    {                                                           \
        DbgPrint("Assertion Failed: %s:%d %s\n",                \
                 __FILE__,__LINE__,#exp);                       \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define DBGINT(S)                                               \
{                                                               \
    DbgPrint("%s:%d - ", __FILE__, __LINE__);                   \
    DbgPrint S;                                                 \
    DbgBreakPoint();                                            \
}


// check frame for problems
#define CHECK_VALID_FRAME(Frame)                                \
{                                                               \
    ASSERT(Frame);                                              \
    if(Frame)                                                   \
    {                                                           \
        if(Frame->Signature != FRAME_SIGNATURE)                 \
        {                                                       \
            DbgPrint("RNDISMP: Invalid Frame (%p) Signature: %s:%d\n",\
                    Frame, __FILE__,__LINE__);                  \
            DbgBreakPoint();                                    \
        }                                                       \
    }                                                           \
}

// check adapter for problems
#define CHECK_VALID_ADAPTER(Adapter)                            \
{                                                               \
    ASSERT(Adapter);                                            \
    if(Adapter)                                                 \
    {                                                           \
        if(Adapter->Signature != ADAPTER_SIGNATURE)             \
        {                                                       \
            DbgPrint("RNDISMP: Invalid Adapter Signature: %s:%d\n",\
                     __FILE__,__LINE__);                        \
            DbgBreakPoint();                                    \
        }                                                       \
    }                                                           \
}

// check block for problems
#define CHECK_VALID_BLOCK(Block)                                \
{                                                               \
    ASSERT(Block);                                              \
    if(Block)                                                   \
    {                                                           \
        if(Block->Signature != BLOCK_SIGNATURE)                 \
        {                                                       \
            DbgPrint("RNDISMP: Invalid Block Signature: %s:%d\n",\
                     __FILE__,__LINE__);                        \
            DbgBreakPoint();                                    \
        }                                                       \
    }                                                           \
}


#define RNDISMP_ASSERT_AT_PASSIVE()                             \
{                                                               \
    KIRQL Irql = KeGetCurrentIrql();                            \
    if (Irql != PASSIVE_LEVEL)                                  \
    {                                                           \
        DbgPrint("RNDISMP: found IRQL %d instead of passive!\n", Irql); \
        DbgPrint("RNDISMP: at line %d, file %s\n", __LINE__, __FILE__); \
        DbgBreakPoint();                                        \
    }                                                           \
}


#define RNDISMP_ASSERT_AT_DISPATCH()                            \
{                                                               \
    KIRQL Irql = KeGetCurrentIrql();                            \
    if (Irql != DISPATCH_LEVEL)                                 \
    {                                                           \
        DbgPrint("RNDISMP: found IRQL %d instead of dispatch!\n", Irql); \
        DbgPrint("RNDISMP: at line %d, file %s\n", __LINE__, __FILE__); \
        DbgBreakPoint();                                        \
    }                                                           \
}


#define DBG_LOG_SEND_MSG(_pAdapter, _pMsgFrame)                 \
{                                                               \
    if (RndismpDebugFlags & DBG_LOG_SENDS)                      \
    {                                                           \
        RndisLogSendMessage(_pAdapter, _pMsgFrame);             \
    }                                                           \
}

#else // !DBG


#define TRACE0(S)
#define TRACE1(S)
#define TRACE2(S)
#define TRACE3(S)
#define TRACEDUMP(_s, _buf, _len)

#undef ASSERT
#define ASSERT(exp)

#define DBGINT(S)

#define CHECK_VALID_FRAME(Frame)
#define CHECK_VALID_ADAPTER(Adapter)
#define CHECK_VALID_BLOCK(Block)
#define DISPLAY_OID_LIST(Adapter)
#define OID_NAME_TRACE(Oid, s)

#define RNDISMP_ASSERT_AT_PASSIVE()
#define RNDISMP_ASSERT_AT_DISPATCH()

#define DBG_LOG_SEND_MSG(_pAdapter, _pMsgFrame)
#endif //DBG


//
// Defines
//

#define MINIMUM_ETHERNET_PACKET_SIZE            60
#define MAXIMUM_ETHERNET_PACKET_SIZE            1514
#define NUM_BYTES_PROTOCOL_RESERVED_SECTION     (4*sizeof(PVOID))
#define ETHERNET_HEADER_SIZE                    14

#define INITIAL_RECEIVE_FRAMES                  20
#define MAX_RECEIVE_FRAMES                      400

// this is the size of the buffer we will use to pass Data packet header data
// to the remote device.
#define RNDIS_PACKET_MESSAGE_HEADER_SIZE        128

// align all RNDIS packets on 4 byte boundaries
#define RNDIS_PACKET_MESSAGE_BOUNDARY           (4)

#define ONE_SECOND                              1000 // in milliseconds

#define KEEP_ALIVE_TIMER                        (5 * ONE_SECOND)

#define REQUEST_TIMEOUT                         (10 * ONE_SECOND)

#define FRAME_SIGNATURE                         ((ULONG)('GSRF'))
#define ADAPTER_SIGNATURE                       ((ULONG)('GSDA'))
#define BLOCK_SIGNATURE                         ((ULONG)('GSLB'))

#define RNDISMP_TAG_GEN_ALLOC                   ((ULONG)(' MNR'))
#define RNDISMP_TAG_SEND_FRAME                  ((ULONG)('sMNR'))
#define RNDISMP_TAG_RECV_DATA_FRAME             ((ULONG)('rMNR'))

#if DBG
#define MINIPORT_INIT_TIMEOUT                   (10 * ONE_SECOND)
#define MINIPORT_HALT_TIMEOUT                   (5 * ONE_SECOND)
#else
#define MINIPORT_INIT_TIMEOUT                   (5 * ONE_SECOND)
#define MINIPORT_HALT_TIMEOUT                   (2 * ONE_SECOND)
#endif

#ifndef MAX
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))
#endif

// flags for driver and device supported OIDs
#define OID_NOT_SUPPORTED       0x0000
#define DRIVER_SUPPORTED_OID    0x0001
#define DEVICE_SUPPORTED_OID    0x0002


//
// Defines for OID_GEN_MAC_OPTIONS - most of the bits returned
// in response to this query are driver-specific, however some
// are device-specific.
//
#define RNDIS_DRIVER_MAC_OPTIONS        (NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA  | \
                                         NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |   \
                                         NDIS_MAC_OPTION_NO_LOOPBACK)

#define RNDIS_DEVICE_MAC_OPTIONS_MASK   NDIS_MAC_OPTION_8021P_PRIORITY

//
// Data structures
//

typedef NDIS_SPIN_LOCK          RNDISMP_SPIN_LOCK;


#ifdef BUILD_WIN9X

//
//  Equivalents of types defined for Win9X config mgr.
//
typedef ULONG           MY_CONFIGRET;
typedef ULONG           MY_DEVNODE;
typedef ULONG           MY_CONFIGFUNC;
typedef ULONG           MY_SUBCONFIGFUNC;
typedef MY_CONFIGRET    (_cdecl *MY_CMCONFIGHANDLER)(MY_CONFIGFUNC, MY_SUBCONFIGFUNC, MY_DEVNODE, ULONG, ULONG);

#define MY_CR_SUCCESS           0x00000000
#define MY_CONFIG_PREREMOVE     0x0000000C
#define MY_CONFIG_PRESHUTDOWN   0x00000012

#endif

//
// This structure contains information about a specific
// microport the miniport sits on top of. One of these
// per microport
//
typedef struct _DRIVER_BLOCK 
{
    // NDIS wrapper handle from NdisInitializeWrapper
    NDIS_HANDLE                 NdisWrapperHandle;

    // The NDIS version we manage to register this miniport instance as.
    UCHAR                       MajorNdisVersion;
    UCHAR                       MinorNdisVersion;

    struct _DRIVER_BLOCK       *NextDriverBlock;

    // pointer to driver object this block is associated with
    PDRIVER_OBJECT              DriverObject;
    // intercepted dispatch function for IRP_MJ_PNP
    PDRIVER_DISPATCH            SavedPnPDispatch;

    // Handlers registered by Remote NDIS microport
    RM_DEVICE_INIT_HANDLER      RmInitializeHandler;
    RM_DEVICE_INIT_CMPLT_NOTIFY_HANDLER RmInitCompleteNotifyHandler;
    RM_DEVICE_HALT_HANDLER      RmHaltHandler;
    RM_SHUTDOWN_HANDLER         RmShutdownHandler;
    RM_UNLOAD_HANDLER           RmUnloadHandler;
    RM_SEND_MESSAGE_HANDLER     RmSendMessageHandler;
    RM_RETURN_MESSAGE_HANDLER   RmReturnMessageHandler;

    // "Global" context for Microport
    PVOID                       MicroportContext;
    
    // list of adapters registered for this Miniport driver.
    struct _RNDISMP_ADAPTER    *AdapterList;

    // number of adapters in use with this driver block
    ULONG                       NumberAdapters;

    // sanity check
    ULONG                       Signature;
} DRIVER_BLOCK, *PDRIVER_BLOCK;



typedef
VOID
(*PRNDISMP_MSG_COMPLETE_HANDLER) (
    IN  struct _RNDISMP_MESSAGE_FRAME *     pMsgFrame,
    IN  NDIS_STATUS                         Status
    );



typedef
BOOLEAN
(*PRNDISMP_MSG_HANDLER_FUNC) (
    IN  struct _RNDISMP_ADAPTER *   pAdapter,
    IN  PRNDIS_MESSAGE              pMessage,
    IN  PMDL                        pMdl,
    IN  ULONG                       TotalLength,
    IN  NDIS_HANDLE                 MicroportMessageContext,
    IN  NDIS_STATUS                 ReceiveStatus,
    IN  BOOLEAN                     bMessageCopied
    );

//
// One of these structures for each NDIS_PACKET that we send.
//
typedef struct _RNDISMP_PACKET_WRAPPER
{
    struct _RNDISMP_MESSAGE_FRAME * pMsgFrame;
    PNDIS_PACKET                    pNdisPacket;
    struct _RNDISMP_VC *            pVc;

    // MDL to describe the RNDIS NdisPacket header:
    PMDL                            pHeaderMdl;

    // Last MDL in the list of MDLs describing this RNDIS packet.
    PMDL                            pTailMdl;

    // Space for the RNDIS Packet header:
    UCHAR                           Packet[sizeof(PVOID)];
} RNDISMP_PACKET_WRAPPER, *PRNDISMP_PACKET_WRAPPER;


//
// Structure used to overlay the MiniportReserved field
// of outgoing (sent) packets. 
//
typedef struct _RNDISMP_SEND_PKT_RESERVED 
{
    // Points to the next packet for multi-packet sends.
    PNDIS_PACKET                    pNext;

    // Points to more detailed information about this packet, too much
    // to fit into one PVOID.
    PRNDISMP_PACKET_WRAPPER         pPktWrapper;
} RNDISMP_SEND_PKT_RESERVED, *PRNDISMP_SEND_PKT_RESERVED;


//
// Structure used to TEMPORARILY overlay the MiniportReserved field
// of sent packets -- this is used to link packets in a list pending
// actual transmission from a timeout routine.
//
typedef struct _RNDISMP_SEND_PKT_RESERVED_TEMP
{
    LIST_ENTRY                      Link;
} RNDISMP_SEND_PKT_RESERVED_TEMP, *PRNDISMP_SEND_PKT_RESERVED_TEMP;


//
// Request context - holds information about a pended request (Set or Query)
//
typedef struct _RNDISMP_REQUEST_CONTEXT
{
    PNDIS_REQUEST                   pNdisRequest;
    struct _RNDISMP_VC *            pVc;
    NDIS_OID                        Oid;
    PVOID                           InformationBuffer;
    UINT                            InformationBufferLength;
    PUINT                           pBytesRead;     // for Set
    PUINT                           pBytesWritten;  // for Query
    PUINT                           pBytesNeeded;
    BOOLEAN                         bInternal;
    NDIS_STATUS                     CompletionStatus;
    ULONG                           RetryCount;
    PNDIS_EVENT                     pEvent;
} RNDISMP_REQUEST_CONTEXT, *PRNDISMP_REQUEST_CONTEXT;

//
// Message Frame - generic structure to hold context about all
// messages sent via the microport.
//
typedef struct _RNDISMP_MESSAGE_FRAME
{
    LIST_ENTRY                      Link;           // used to queue this if
                                                    // a response is expected
                                                    // from the device.
    ULONG                           RefCount;       // Determines when to free
                                                    // this message frame.
    struct _RNDISMP_ADAPTER *       pAdapter;
    struct _RNDISMP_VC *            pVc;
    union
    {
        PNDIS_PACKET                pNdisPacket;    // if DATA message
        PRNDISMP_REQUEST_CONTEXT    pReqContext;    // if Request message
    };
    PMDL                            pMessageMdl;    // what goes to the microport
    UINT32                          NdisMessageType;// copied from the RNDIS message
    UINT32                          RequestId;      // to match requests/responses

    PRNDISMP_MSG_COMPLETE_HANDLER   pCallback;      // called on completion of message send

    ULONG                           TicksOnQueue;
    ULONG                           TimeSent;
#if THROTTLE_MESSAGES
    LIST_ENTRY                      PendLink;       // used to queue this
                                                    // pending send to microport
#endif
    ULONG                           Signature;
} RNDISMP_MESSAGE_FRAME, *PRNDISMP_MESSAGE_FRAME;



//
// linked list entry for transport frames (transmit, receive, request)
//
typedef struct _RNDISMP_LIST_ENTRY 
{
    LIST_ENTRY  Link;
} RNDISMP_LIST_ENTRY, *PRNDISMP_LIST_ENTRY;


//
//  RNDIS VC states.
//
typedef enum
{
    RNDISMP_VC_ALLOCATED = 0,
    RNDISMP_VC_CREATING,
    RNDISMP_VC_CREATING_ACTIVATE_PENDING,
    RNDISMP_VC_CREATING_DELETE_PENDING,
    RNDISMP_VC_CREATE_FAILURE,
    RNDISMP_VC_CREATED,
    RNDISMP_VC_ACTIVATING,
    RNDISMP_VC_ACTIVATED,
    RNDISMP_VC_DEACTIVATING,
    RNDISMP_VC_DEACTIVATED,
    RNDISMP_VC_DELETING,
    RNDISMP_VC_DELETE_FAIL

} RNDISMP_VC_STATE;


//
//  RNDIS Call states.
//
typedef enum
{
    RNDISMP_CALL_IDLE
    // others TBD

} RNDISMP_CALL_STATE;


#define NULL_DEVICE_CONTEXT                 0


//
//  All information about a single VC/call.
//
typedef struct _RNDISMP_VC
{
    //  link to list of VCs on adapter.
    LIST_ENTRY                      VcList;

    //  owning adapter
    struct _RNDISMP_ADAPTER *       pAdapter;

    //  VC handle sent to the device, also our hash lookup key.
    UINT32                          VcId;

    //  base VC state
    RNDISMP_VC_STATE                VcState;

    //  call state, relevant only for devices that are call managers.
    RNDISMP_CALL_STATE              CallState;

    ULONG                           RefCount;

    //  NDIS Wrapper's handle for this Vc
    NDIS_HANDLE                     NdisVcHandle;

    //  remote device's context for this VC
    RNDIS_HANDLE                    DeviceVcContext;

    RNDISMP_SPIN_LOCK               Lock;

    //  sends on this VC that haven't been completed.
    ULONG                           PendingSends;

    //  receive indications that haven't been returned to us.
    ULONG                           PendingReceives;

    //  NDIS requests that haven't been completed.
    ULONG                           PendingRequests;

    //  VC activation (or call setup) parameters.
    PCO_CALL_PARAMETERS             pCallParameters;
} RNDISMP_VC, *PRNDISMP_VC;


//
//  VC hash table.
//
#define RNDISMP_VC_HASH_TABLE_SIZE  41

typedef struct _RNDISMP_VC_HASH_TABLE
{
    ULONG                           NumEntries;
    LIST_ENTRY                      HashEntry[RNDISMP_VC_HASH_TABLE_SIZE];

} RNDISMP_VC_HASH_TABLE, *PRNDISMP_VC_HASH_TABLE;


#define RNDISMP_HASH_VCID(_VcId)    ((_VcId) % RNDISMP_VC_HASH_TABLE_SIZE)


//
// High and low watermarks for messages pending
// at the microport
//
#define RNDISMP_PENDED_SEND_HIWAT       0xffff
#define RNDISMP_PENDED_SEND_LOWAT       0xfff


typedef VOID (*RM_MULTIPLE_SEND_HANDLER) ();

//
// This structure contains all the information about a single
// adapter that this driver is controlling
//
typedef struct _RNDISMP_ADAPTER
{
    // This is the handle given by the wrapper for calling NDIS functions.
    NDIS_HANDLE                 MiniportAdapterHandle;

    // pointer to next adapter in list hanging off driver block
    struct _RNDISMP_ADAPTER    *NextAdapter;

    // pointer to driver block for this adapter
    PDRIVER_BLOCK               DriverBlock;

    // Friendly name:
    ANSI_STRING                 FriendlyNameAnsi;
    UNICODE_STRING              FriendlyNameUnicode;

#if THROTTLE_MESSAGES
    // Counters for messages pending at the microport
    ULONG                       HiWatPendedMessages;
    ULONG                       LoWatPendedMessages;
    ULONG                       CurPendedMessages;

    // Messages not yet sent to microport.
    LIST_ENTRY                  WaitingMessageList;
    BOOLEAN                     SendInProgress;
#endif // THROTTLE_MESSAGES
    // Messages sent to microport, awaiting completion
    LIST_ENTRY                  PendingAtMicroportList;
    BOOLEAN                     SendProcessInProgress;
    LIST_ENTRY                  PendingSendProcessList;
    NDIS_TIMER                  SendProcessTimer;

    // Pool of RNDISMP_MESSAGE_FRAME structures
    NPAGED_LOOKASIDE_LIST       MsgFramePool;
    BOOLEAN                     MsgFramePoolAlloced;

    RNDIS_REQUEST_ID            RequestId;

    // Receive Routine Data Area
    NDIS_HANDLE                 ReceivePacketPool;
    NDIS_HANDLE                 ReceiveBufferPool;
    ULONG                       InitialReceiveFrames;
    ULONG                       MaxReceiveFrames;
    NPAGED_LOOKASIDE_LIST       RcvFramePool;
    BOOLEAN                     RcvFramePoolAlloced;
    BOOLEAN                     IndicatingReceives;
    // Messages to be processed.
    LIST_ENTRY                  PendingRcvMessageList;
    NDIS_TIMER                  IndicateTimer;

    // handlers registered by Remote NDIS microport
    RM_DEVICE_INIT_HANDLER      RmInitializeHandler;
    RM_DEVICE_INIT_CMPLT_NOTIFY_HANDLER RmInitCompleteNotifyHandler;
    RM_DEVICE_HALT_HANDLER      RmHaltHandler;
    RM_SHUTDOWN_HANDLER         RmShutdownHandler;
    RM_SEND_MESSAGE_HANDLER     RmSendMessageHandler;
    RM_RETURN_MESSAGE_HANDLER   RmReturnMessageHandler;

    // handler for DoMultipleSend
    RM_MULTIPLE_SEND_HANDLER    MultipleSendFunc;

    // context for microport adapter
    NDIS_HANDLE                 MicroportAdapterContext;

    // pointer to list of OIDs supported
    PNDIS_OID                   SupportedOIDList;

    // size of OID list
    UINT                        SupportedOIDListSize;

    // pointer to list of flags indicating whether the OID is driver or device supported
    PUINT                       OIDHandlerList;

    // size of OID handler list
    UINT                        OIDHandlerListSize;

    // pointer to list of Driver OIDs
    PNDIS_OID                   DriverOIDList;

    // size of Driver OID list, in OIDs
    UINT                        NumDriverOIDs;

    // total number of OIDs we support
    UINT                        NumOIDSupported;

    // medium type supported by the device.
    NDIS_MEDIUM                 Medium;

    // device flags reported by the device.
    ULONG                       DeviceFlags;

    // max NDIS_PACKETs that can be sent in one RNDIS message
    ULONG                       MaxPacketsPerMessage;
    BOOLEAN                     bMultiPacketSupported;

    // max message size supported for receive by the microport
    ULONG                       MaxReceiveSize;

    // max message size supported by the device
    ULONG                       MaxTransferSize;

    // alignment required by the device
    ULONG                       AlignmentIncr;
    ULONG                       AlignmentMask;

    // list of message frames pending completion by the device
    LIST_ENTRY                  PendingFrameList;

    // synchronization
    NDIS_SPIN_LOCK              Lock;

    // timer to see if we need to send a keep alive message
    NDIS_TIMER                  KeepAliveTimer;

    BOOLEAN                     TimerCancelled;

    // timer tick saved last time a message was received from device
    ULONG                       LastMessageFromDevice;

    // used by check for hang handler to determine if the device is in trouble
    BOOLEAN                     NeedReset;

    // are we waiting for a response to NdisReset?
    BOOLEAN                     ResetPending;

    // used by check for hang handler to determine if the device is in trouble
    BOOLEAN                     KeepAliveMessagePending;

    // are we initializing?
    BOOLEAN                     Initing;

    // are we halting?
    BOOLEAN                     Halting;

    // to wait until we complete sending the Halt message
    NDIS_EVENT                  HaltWaitEvent;

    // request ID of last Keepalive message we have sent
    RNDIS_REQUEST_ID            KeepAliveMessagePendingId;

    PRNDIS_INITIALIZE_COMPLETE  pInitCompleteMessage;

    // are we running on Win9x (WinMe)?
    BOOLEAN                     bRunningOnWin9x;

    // are we running on Win98 Gold?
    BOOLEAN                     bRunningOnWin98Gold;

    // CONDIS - Vc hash table
    PRNDISMP_VC_HASH_TABLE      pVcHashTable;
    ULONG                       LastVcId;

    // Statistics
    RNDISMP_ADAPTER_STATS       Statistics;
    ULONG                       MaxSendCompleteTime;

    // FDO for this device.
    PVOID                       pDeviceObject;

    // PDO for this device.
    PVOID                       pPhysDeviceObject;

    // MAC options
    ULONG                       MacOptions;

    // Max frame size
    ULONG                       MaximumFrameSize;

    // Max multicast list size
    ULONG                       MaxMulticastListSize;

    // Current 802.3 address
    UCHAR                       MacAddress[ETH_LENGTH_OF_ADDRESS];

    // sanity check
    ULONG                       Signature;

#ifdef BUILD_WIN9X
    MY_CMCONFIGHANDLER          NdisCmConfigHandler;
    MY_DEVNODE                  DevNode;
    ULONG                       WrapContextOffset;
#endif
#if DBG
    ULONG                       MicroportReceivesOutstanding;
    PUCHAR                      pSendLogBuffer;
    ULONG                       LogBufferSize;
    PUCHAR                      pSendLogWrite;
#endif // DBG


} RNDISMP_ADAPTER, *PRNDISMP_ADAPTER;

typedef
VOID
(*RM_MULTIPLE_SEND_HANDLER) (
     IN PRNDISMP_ADAPTER pAdapter,
     IN PRNDISMP_VC      pVc  OPTIONAL,
     IN PPNDIS_PACKET    PacketArray,
     IN UINT             NumberofPackets);

//
// Structure to keep context about a single received RNDIS message.
//
typedef struct _RNDISMP_RECV_MSG_CONTEXT
{
    LIST_ENTRY                      Link;
    NDIS_HANDLE                     MicroportMessageContext;
    PMDL                            pMdl;
    ULONG                           TotalLength;
    PRNDIS_MESSAGE                  pMessage;
    NDIS_STATUS                     ReceiveStatus;
    BOOLEAN                         bMessageCopied;
    RM_CHANNEL_TYPE                 ChannelType;

} RNDISMP_RECV_MSG_CONTEXT, *PRNDISMP_RECV_MSG_CONTEXT;


//
// Structure to keep context about a single received RNDIS_PACKET -message-.
// Note that this can contain more than one packet. We store a pointer to
// this structure in our reserved section of each received NDIS_PACKET.
//
typedef struct _RNDISMP_RECV_DATA_FRAME
{
    NDIS_HANDLE                     MicroportMessageContext;
    union {
        PMDL                        pMicroportMdl;
        PRNDIS_MESSAGE              pLocalMessageCopy;
    };
    ULONG                           ReturnsPending;
    BOOLEAN                         bMessageCopy;       // did we make a copy?
} RNDISMP_RECV_DATA_FRAME, *PRNDISMP_RECV_DATA_FRAME;


//
// Per NDIS_PACKET context for received packets. This goes into MiniportReserved.
//
typedef struct _RNDISMP_RECV_PKT_RESERVED
{
    PRNDISMP_RECV_DATA_FRAME        pRcvFrame;
    PRNDISMP_VC                     pVc;
} RNDISMP_RECV_PKT_RESERVED, *PRNDISMP_RECV_PKT_RESERVED;


//
// Used to overlay ProtocolReserved in a packet queued for indicating up.
//
typedef struct _RNDISMP_RECV_PKT_LINKAGE
{
    LIST_ENTRY                      Link;
} RNDISMP_RECV_PKT_LINKAGE, *PRNDISMP_RECV_PKT_LINKAGE;
    

//
// Global Data
//
extern DRIVER_BLOCK             RndismpMiniportBlockListHead;

extern UINT                     RndismpNumMicroports;

extern NDIS_SPIN_LOCK           RndismpGlobalLock;

extern NDIS_OID                 RndismpSupportedOids[];

extern UINT                     RndismpSupportedOidsNum;

extern NDIS_PHYSICAL_ADDRESS    HighestAcceptableMax;

#if DBG

extern UINT                     RndismpDebugFlags;

#endif


//
// Macros
//

// Given a request message type value, return its completion message type
#define RNDIS_COMPLETION(_Type) ((_Type) | 0x80000000)


// Convert an RNdisMediumXXX value to its NdisMediumXXX equivalent
#define RNDIS_TO_NDIS_MEDIUM(_RndisMedium)  ((NDIS_MEDIUM)(_RndisMedium))

#define RNDISMP_GET_ALIGNED_LENGTH(_AlignedLength, _InputLen, _pAdapter)    \
{                                                                           \
    ULONG       _Length = _InputLen;                                        \
    if (_Length == 0)                                                       \
        (_AlignedLength) = 0;                                               \
    else                                                                    \
        (_AlignedLength) = ((_Length + (_pAdapter)->AlignmentIncr) &        \
                            (_pAdapter)->AlignmentMask);                    \
}

// The minimum MessageLength expected in an RNDIS message of a given type.
#define RNDISMP_MIN_MESSAGE_LENGTH(_MsgTypeField)                           \
    FIELD_OFFSET(RNDIS_MESSAGE, Message) + sizeof(((PRNDIS_MESSAGE)0)->Message._MsgTypeField##)

// memory move macro
#define RNDISMP_MOVE_MEM(dest,src,size) NdisMoveMemory(dest,src,size)

// Macros to extract high and low bytes of a word.
#define MSB(Value) ((UCHAR)((((ULONG)Value) >> 8) & 0xff))
#define LSB(Value) ((UCHAR)(((ULONG)Value) & 0xff))


// Acquire the adapter lock
#define RNDISMP_ACQUIRE_ADAPTER_LOCK(_pAdapter) \
    NdisAcquireSpinLock(&(_pAdapter)->Lock);

// Release the adapter lock
#define RNDISMP_RELEASE_ADAPTER_LOCK(_pAdapter) \
    NdisReleaseSpinLock(&(_pAdapter)->Lock);

// Increment adapter statistics.
#define RNDISMP_INCR_STAT(_pAdapter, _StatsCount)               \
    NdisInterlockedIncrement(&(_pAdapter)->Statistics._StatsCount)

// Get adapter statistics
#define RNDISMP_GET_ADAPTER_STATS(_pAdapter, _StatsCount)           \
    ((_pAdapter)->Statistics._StatsCount)

// Get the send packet reserved field
#define PRNDISMP_RESERVED_FROM_SEND_PACKET(_Packet)             \
    ((PRNDISMP_SEND_PKT_RESERVED)((_Packet)->MiniportReserved))

#define PRNDISMP_RESERVED_TEMP_FROM_SEND_PACKET(_Packet)        \
    ((PRNDISMP_SEND_PKT_RESERVED_TEMP)((_Packet)->MiniportReserved))

#define PRNDISMP_RESERVED_FROM_RECV_PACKET(_Packet)             \
    ((PRNDISMP_RECV_PKT_RESERVED)((_Packet)->MiniportReserved))

// store receive frame context in miniport reserved field
#define RECEIVE_FRAME_TO_NDIS_PACKET(_Packet, _ReceiveFrame)    \
{                                                               \
    PRNDISMP_RECEIVE_FRAME  *TmpPtr;                            \
    TmpPtr  = (PRNDISMP_RECEIVE_FRAME *)                        \
              &(_Packet->MiniportReserved);                     \
    *TmpPtr = _ReceiveFrame;                                    \
}


// Get adapter context from handle passed in NDIS routines
#define PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(_Handle)           \
    ((PRNDISMP_ADAPTER)(_Handle))

// Get miniport context handle from adapter context
#define CONTEXT_HANDLE_FROM_PRNDISMP_ADAPTER(_Ptr)              \
    ((NDIS_HANDLE)(_Ptr))

// Get VC context from handle passed in from NDIS
#define PRNDISMP_VC_FROM_CONTEXT_HANDLE(_Handle)                   \
    ((PRNDISMP_VC)(_Handle))

// Get miniport context from VC
#define CONTEXT_HANDLE_FROM_PRNDISMP_VC(_pVc)                   \
    ((NDIS_HANDLE)(_Vc))

// Get message frame from message handle
#define MESSAGE_FRAME_FROM_HANDLE(_Handle)                      \
    ((PRNDISMP_MESSAGE_FRAME)(_Handle))

// Get a pointer to the data buff in an RNDIS_PACKET
#define GET_PTR_TO_RNDIS_DATA_BUFF(_Message)                    \
    ((PVOID) ((PUCHAR)(_Message) +  _Message->DataOffset))

// Get a pointer to the OOBD data in an RNDIS_PACKET
#define GET_PTR_TO_OOB_DATA(_Message)                           \
    ((PVOID) ((PUCHAR)(_Message) +  _Message->OOBDataOffset))

// Get a pointer to the per packet info in an RNDIS_PACKET
#define GET_PTR_TO_PER_PACKET_INFO(_Message)                    \
    ((PVOID) ((PUCHAR)(_Message) +  _Message->PerPacketInfoOffset))

// Get an offset to the data buff in an RNDIS_PACKET
#define GET_OFFSET_TO_RNDIS_DATA_BUFF(_Message)                 \
    (sizeof(RNDIS_PACKET))

// Get an offset to the OOBD data in an RNDIS_PACKET
#define GET_OFFSET_TO_OOB_DATA(_Message)                        \
    (sizeof(RNDIS_PACKET) +  Message->DataLength)

// Get an offset to the per packet info in an RNDIS_PACKET
#define GET_OFFSET_TO_PER_PACKET_INFO(_Message)                 \
    (sizeof(RNDIS_PACKET) + _Message->DataLength + _Message->OOBDataLength)

#define RNDISMP_GET_INFO_BUFFER_FROM_QUERY_MSG(_Message)        \
    ((PUCHAR)(_Message) + (_Message)->InformationBufferOffset)

#define MIN(x,y) ((x > y) ? y : x)


// Return the virtual address for a received message MDL.
#if defined(BUILD_WIN9X) || defined(BUILD_WIN2K)
#define RNDISMP_GET_MDL_ADDRESS(_pMdl)  MmGetSystemAddressForMdl(_pMdl)
#else
#define RNDISMP_GET_MDL_ADDRESS(_pMdl)  MmGetSystemAddressForMdlSafe(_pMdl, NormalPagePriority)
#endif

// Return the MDL chained to this MDL
#define RNDISMP_GET_MDL_NEXT(_pMdl) ((_pMdl)->Next)

// Return the MDL length
#define RNDISMP_GET_MDL_LENGTH(_pMdl)   MmGetMdlByteCount(_pMdl)

// Access the RNDIS message from our Message Frame structure.
#define RNDISMP_GET_MSG_FROM_FRAME(_pMsgFrame)                  \
    RNDISMP_GET_MDL_ADDRESS(_pMsgFrame->pMessageMdl)

// Return an RNDIS message back to the microport.
#if DBG

#define RNDISMP_RETURN_TO_MICROPORT(_pAdapter, _pMdl, _MicroportMsgContext) \
{                                                                           \
    NdisInterlockedDecrement(&(_pAdapter)->MicroportReceivesOutstanding);   \
    (_pAdapter)->RmReturnMessageHandler((_pAdapter)->MicroportAdapterContext,\
                                        (_pMdl),                            \
                                        (_MicroportMsgContext));            \
}

#else

#define RNDISMP_RETURN_TO_MICROPORT(_pAdapter, _pMdl, _MicroportMsgContext) \
    (_pAdapter)->RmReturnMessageHandler((_pAdapter)->MicroportAdapterContext,\
                                        (_pMdl),                            \
                                        (_MicroportMsgContext))
#endif // DBG

// Send an RNDIS message to the microport.
#if THROTTLE_MESSAGES
#define RNDISMP_SEND_TO_MICROPORT(_pAdapter, _pMsgFrame, _bQueueForResponse, _CallbackFunc)     \
{                                                                           \
    TRACE2(("Send: Adapter %x, MsgFrame %x, Mdl %x\n",                      \
                _pAdapter, _pMsgFrame, _pMsgFrame->pMessageMdl));           \
    (_pMsgFrame)->pCallback = _CallbackFunc;                                \
    QueueMessageToMicroport(_pAdapter, _pMsgFrame, _bQueueForResponse);     \
}
#else
#define RNDISMP_SEND_TO_MICROPORT(_pAdapter, _pMsgFrame, _bQueueForResponse, _CallbackFunc)     \
{                                                                           \
    (_pMsgFrame)->pCallback = _CallbackFunc;                                \
    if (_bQueueForResponse)                                                 \
    {                                                                       \
        RNDISMP_ACQUIRE_ADAPTER_LOCK(_pAdapter);                            \
        InsertTailList(&(_pAdapter)->PendingFrameList, &(_pMsgFrame)->Link);\
        RNDISMP_RELEASE_ADAPTER_LOCK(_pAdapter);                            \
    }                                                                       \
    (_pAdapter)->RmSendMessageHandler((_pAdapter)->MicroportAdapterContext, \
                                              (_pMsgFrame)->pMessageMdl,    \
                                              (_pMsgFrame));                \
}
#endif // THROTTLE_MESSAGES

// Return the handler function for a given message type.
#define RNDISMP_GET_MSG_HANDLER(_pMsgHandlerFunc, _MessageType) \
{                                                               \
    switch (_MessageType)                                       \
    {                                                           \
        case REMOTE_NDIS_HALT_MSG:                              \
            _pMsgHandlerFunc = HaltMessage;                     \
            break;                                              \
        case REMOTE_NDIS_PACKET_MSG:                            \
            _pMsgHandlerFunc = ReceivePacketMessage;            \
            break;                                              \
        case REMOTE_NDIS_INDICATE_STATUS_MSG:                   \
            _pMsgHandlerFunc = IndicateStatusMessage;           \
            break;                                              \
        case REMOTE_NDIS_QUERY_CMPLT:                           \
        case REMOTE_NDIS_SET_CMPLT:                             \
            _pMsgHandlerFunc = QuerySetCompletionMessage;       \
            break;                                              \
        case REMOTE_NDIS_KEEPALIVE_MSG:                         \
            _pMsgHandlerFunc = KeepAliveMessage;                \
            break;                                              \
        case REMOTE_NDIS_KEEPALIVE_CMPLT:                       \
            _pMsgHandlerFunc = KeepAliveCompletionMessage;      \
            break;                                              \
        case REMOTE_NDIS_RESET_CMPLT:                           \
            _pMsgHandlerFunc = ResetCompletionMessage;          \
            break;                                              \
        case REMOTE_NDIS_INITIALIZE_CMPLT:                      \
            _pMsgHandlerFunc = InitCompletionMessage;           \
            break;                                              \
        case REMOTE_CONDIS_MP_CREATE_VC_CMPLT:                  \
            _pMsgHandlerFunc = ReceiveCreateVcComplete;         \
            break;                                              \
        case REMOTE_CONDIS_MP_DELETE_VC_CMPLT:                  \
            _pMsgHandlerFunc = ReceiveDeleteVcComplete;         \
            break;                                              \
        case REMOTE_CONDIS_MP_ACTIVATE_VC_CMPLT:                \
            _pMsgHandlerFunc = ReceiveActivateVcComplete;       \
            break;                                              \
        case REMOTE_CONDIS_MP_DEACTIVATE_VC_CMPLT:              \
            _pMsgHandlerFunc = ReceiveDeactivateVcComplete;     \
            break;                                              \
        default:                                                \
            _pMsgHandlerFunc = UnknownMessage;                  \
            break;                                              \
    }                                                           \
}



//
// Look up a message frame on the adapter given a request ID. If found,
// remove it from the pending list and return it.
//
#define RNDISMP_LOOKUP_PENDING_MESSAGE(_pMsgFrame, _pAdapter, _ReqId)       \
{                                                                           \
    PLIST_ENTRY             _pEnt;                                          \
    PRNDISMP_MESSAGE_FRAME  _pFrame;                                        \
                                                                            \
    (_pMsgFrame) = NULL;                                                    \
    RNDISMP_ACQUIRE_ADAPTER_LOCK(_pAdapter);                                \
    for (_pEnt = (_pAdapter)->PendingFrameList.Flink;                       \
         _pEnt != &(_pAdapter)->PendingFrameList;                           \
         _pEnt = _pEnt->Flink)                                              \
    {                                                                       \
        _pFrame = CONTAINING_RECORD(_pEnt, RNDISMP_MESSAGE_FRAME, Link);    \
        if (_pFrame->RequestId == (_ReqId))                                 \
        {                                                                   \
            RemoveEntryList(_pEnt);                                         \
            (_pMsgFrame) = _pFrame;                                         \
            break;                                                          \
        }                                                                   \
    }                                                                       \
    RNDISMP_RELEASE_ADAPTER_LOCK(_pAdapter);                                \
}


#if DBG_TIME_STAMPS
#define RNDISMP_GET_TIME_STAMP(_pTs)                                        \
{                                                                           \
    LONGLONG systime_usec;                                                  \
    NdisGetCurrentSystemTime((PVOID)&systime_usec);                         \
    *_pTs = (ULONG)((*(PULONG)&systime_usec)/1000);                         \
}
#else
#define RNDISMP_GET_TIME_STAMP(_pTs)
#endif

#define RNDISMP_INIT_LOCK(_pLock)                                           \
    NdisAllocateSpinLock((_pLock));

#define RNDISMP_ACQUIRE_LOCK(_pLock)                                        \
    NdisAcquireSpinLock((_pLock));

#define RNDISMP_RELEASE_LOCK(_pLock)                                        \
    NdisReleaseSpinLock((_pLock));

#define RNDISMP_ACQUIRE_LOCK_DPC(_pLock)                                    \
    NdisDprAcquireSpinLock((_pLock));

#define RNDISMP_RELEASE_LOCK_DPC(_pLock)                                    \
    NdisDprReleaseSpinLock((_pLock));


#define RNDISMP_INIT_VC_LOCK(_pVc)                                          \
    RNDISMP_INIT_LOCK(&((_pVc)->Lock))

#define RNDISMP_ACQUIRE_VC_LOCK(_pVc)                                       \
    RNDISMP_ACQUIRE_LOCK(&((_pVc))->Lock)

#define RNDISMP_RELEASE_VC_LOCK(_pVc)                                       \
    RNDISMP_RELEASE_LOCK(&((_pVc))->Lock)
   
#define RNDISMP_ACQUIRE_VC_LOCK_DPC(_pVc)                                   \
    RNDISMP_ACQUIRE_LOCK_DPC(&((_pVc))->Lock)

#define RNDISMP_RELEASE_VC_LOCK_DPC(_pVc)                                   \
    RNDISMP_RELEASE_LOCK_DPC(&((_pVc))->Lock)


#define RNDISMP_REF_VC(_pVc)                                                \
    NdisInterlockedIncrement(&(_pVc)->RefCount);

#define RNDISMP_DEREF_VC(_pVc, _pRefCount)                                  \
    {                                                                       \
        ULONG       _RefCount;                                              \
                                                                            \
        RNDISMP_ACQUIRE_VC_LOCK(_pVc);                                      \
                                                                            \
        RNDISMP_DEREF_VC_LOCKED(_pVc, &_RefCount);                          \
        *(_pRefCount) = _RefCount;                                          \
        if (_RefCount != 0)                                                 \
        {                                                                   \
            RNDISMP_RELEASE_VC_LOCK(_pVc);                                  \
        }                                                                   \
    }

#define RNDISMP_DEREF_VC_LOCKED(_pVc, _pRefCount)                           \
    {                                                                       \
        ULONG       __RefCount;                                             \
        NDIS_HANDLE __NdisVcHandle;                                         \
                                                                            \
        __RefCount = NdisInterlockedDecrement(&(_pVc)->RefCount);           \
        *(_pRefCount) = __RefCount;                                         \
        if (__RefCount == 0)                                                \
        {                                                                   \
            RNDISMP_RELEASE_VC_LOCK(_pVc);                                  \
            DeallocateVc(_pVc);                                             \
        }                                                                   \
        else                                                                \
        {                                                                   \
            if ((__RefCount == 1) &&                                        \
                ((_pVc)->VcState == RNDISMP_VC_DEACTIVATED))                \
            {                                                               \
                __NdisVcHandle = (_pVc)->NdisVcHandle;                      \
                (_pVc)->VcState = RNDISMP_VC_CREATED;                       \
                NdisInterlockedIncrement(&(_pVc)->RefCount);                \
                                                                            \
                RNDISMP_RELEASE_VC_LOCK(_pVc);                              \
                                                                            \
                NdisMCoDeactivateVcComplete(NDIS_STATUS_SUCCESS,            \
                                            __NdisVcHandle);                \
                                                                            \
                RNDISMP_ACQUIRE_VC_LOCK(_pVc);                              \
                                                                            \
                __RefCount = NdisInterlockedDecrement(&(_pVc)->RefCount);   \
                *(_pRefCount) = __RefCount;                                 \
                if (__RefCount == 0)                                        \
                {                                                           \
                    RNDISMP_RELEASE_VC_LOCK(_pVc);                          \
                    DeallocateVc(_pVc);                                     \
                }                                                           \
            }                                                               \
        }                                                                   \
    }
           
//
// Prototypes for functions in rndismp.c
//

NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);


NDIS_STATUS
RndisMInitializeWrapper(OUT PNDIS_HANDLE                      pNdisWrapperHandle,
                        IN  PVOID                             MicroportContext,
                        IN  PVOID                             DriverObject,
                        IN  PVOID                             RegistryPath,
                        IN  PRNDIS_MICROPORT_CHARACTERISTICS  pCharacteristics);

VOID
RndismpUnload(IN PDRIVER_OBJECT pDriverObject);

NTSTATUS
DllUnload(VOID);

VOID
RndismpHalt(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpInternalHalt(IN NDIS_HANDLE MiniportAdapterContext,
                    IN BOOLEAN bCalledFromHalt);

NDIS_STATUS
RndismpReconfigure(OUT PNDIS_STATUS pStatus,
                   IN NDIS_HANDLE MiniportAdapterContext,
                   IN NDIS_HANDLE ConfigContext);

NDIS_STATUS
RndismpReset(OUT PBOOLEAN    AddressingReset,
             IN  NDIS_HANDLE MiniportAdapterContext);

BOOLEAN
RndismpCheckForHang(IN NDIS_HANDLE MiniportAdapterContext);

NDIS_STATUS
RndismpInitialize(OUT PNDIS_STATUS  OpenErrorStatus,
                  OUT PUINT         SelectedMediumIndex,
                  IN  PNDIS_MEDIUM  MediumArray,
                  IN  UINT          MediumArraySize,
                  IN  NDIS_HANDLE   MiniportAdapterHandle,
                  IN  NDIS_HANDLE   ConfigurationHandle);

VOID
RndisMSendComplete(IN  NDIS_HANDLE    MiniportAdapterContext,
                   IN  NDIS_HANDLE    RndisMessageHandle,
                   IN  NDIS_STATUS    SendStatus);


BOOLEAN
InitCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDIS_MESSAGE     pMessage,
                      IN PMDL               pMdl,
                      IN ULONG              TotalLength,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN NDIS_STATUS        ReceiveStatus,
                      IN BOOLEAN            bMessageCopied);

BOOLEAN
HaltMessage(IN PRNDISMP_ADAPTER   pAdapter,
            IN PRNDIS_MESSAGE     pMessage,
            IN PMDL               pMdl,
            IN ULONG              TotalLength,
            IN NDIS_HANDLE        MicroportMessageContext,
            IN NDIS_STATUS        ReceiveStatus,
            IN BOOLEAN            bMessageCopied);

BOOLEAN
ResetCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                       IN PRNDIS_MESSAGE     pMessage,
                       IN PMDL               pMdl,
                       IN ULONG              TotalLength,
                       IN NDIS_HANDLE        MicroportMessageContext,
                       IN NDIS_STATUS        ReceiveStatus,
                       IN BOOLEAN            bMessageCopied);

BOOLEAN
KeepAliveCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                           IN PRNDIS_MESSAGE     pMessage,
                           IN PMDL               pMdl,
                           IN ULONG              TotalLength,
                           IN NDIS_HANDLE        MicroportMessageContext,
                           IN NDIS_STATUS        ReceiveStatus,
                           IN BOOLEAN            bMessageCopied);


BOOLEAN
KeepAliveMessage(IN PRNDISMP_ADAPTER   pAdapter,
                 IN PRNDIS_MESSAGE     pMessage,
                 IN PMDL               pMdl,
                 IN ULONG              TotalLength,
                 IN NDIS_HANDLE        MicroportMessageContext,
                 IN NDIS_STATUS        ReceiveStatus,
                 IN BOOLEAN            bMessageCopied);

VOID
RndismpShutdownHandler(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpDisableInterrupt(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpEnableInterrupt(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpHandleInterrupt(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpIsr(OUT PBOOLEAN InterruptRecognized,
           OUT PBOOLEAN QueueDpc,
           IN  PVOID    Context);
VOID
CompleteSendInit(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN NDIS_STATUS SendStatus);

VOID
CompleteSendHalt(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN NDIS_STATUS SendStatus);

VOID
CompleteSendReset(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                  IN NDIS_STATUS SendStatus);

VOID
CompleteMiniportReset(IN PRNDISMP_ADAPTER pAdapter,
                      IN NDIS_STATUS ResetStatus,
                      IN BOOLEAN AddressingReset);

NDIS_STATUS
ReadAndSetRegistryParameters(IN PRNDISMP_ADAPTER pAdapter,
                             IN NDIS_HANDLE ConfigurationContext);

NDIS_STATUS
SendConfiguredParameter(IN PRNDISMP_ADAPTER     pAdapter,
                        IN NDIS_HANDLE          ConfigHandle,
                        IN PNDIS_STRING         pParameterName,
                        IN PNDIS_STRING         pParameterType);

VOID
RndismpPnPEventNotify(IN NDIS_HANDLE MiniportAdapterContext,
                      IN NDIS_DEVICE_PNP_EVENT EventCode,
                      IN PVOID InformationBuffer,
                      IN ULONG InformationBufferLength);

//
// Prototypes for functions in init.c
//

NDIS_STATUS
SetupSendQueues(IN PRNDISMP_ADAPTER Adapter);

NDIS_STATUS
SetupReceiveQueues(IN PRNDISMP_ADAPTER Adapter);

NDIS_STATUS
AllocateTransportResources(IN PRNDISMP_ADAPTER Adapter);

VOID
FreeTransportResources(IN PRNDISMP_ADAPTER Adapter);

VOID
FreeSendResources(IN PRNDISMP_ADAPTER Adapter);

VOID
FreeReceiveResources(IN PRNDISMP_ADAPTER Adapter);


//
// Prototypes for functions in receive.c
//

VOID
RndismpReturnPacket(IN NDIS_HANDLE    MiniportAdapterContext,
                    IN PNDIS_PACKET   Packet);

VOID
DereferenceRcvFrame(IN PRNDISMP_RECV_DATA_FRAME pRcvFrame,
                    IN PRNDISMP_ADAPTER         pAdapter);

VOID
RndisMIndicateReceive(IN NDIS_HANDLE        MiniportAdapterContext,
                      IN PMDL               pMessageHead,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN RM_CHANNEL_TYPE    ChannelType,
                      IN NDIS_STATUS        ReceiveStatus);
VOID
IndicateReceive(IN PRNDISMP_ADAPTER         pAdapter,
                IN PRNDISMP_VC              pVc OPTIONAL,
                IN PRNDISMP_RECV_DATA_FRAME pRcvFrame,
                IN PPNDIS_PACKET            PacketArray,
                IN ULONG                    NumberOfPackets,
                IN NDIS_STATUS              ReceiveStatus);

PRNDIS_MESSAGE
CoalesceMultiMdlMessage(IN PMDL         pMdl,
                        IN ULONG        TotalLength);

VOID
FreeRcvMessageCopy(IN PRNDIS_MESSAGE    pMessage);

BOOLEAN
ReceivePacketMessage(IN PRNDISMP_ADAPTER    pAdapter,
                     IN PRNDIS_MESSAGE      pMessage,
                     IN PMDL                pMdl,
                     IN ULONG               TotalLength,
                     IN NDIS_HANDLE         MicroportMessageContext,
                     IN NDIS_STATUS         ReceiveStatus,
                     IN BOOLEAN             bMessageCopied);

BOOLEAN
ReceivePacketMessageRaw(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied);

BOOLEAN
IndicateStatusMessage(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDIS_MESSAGE     pMessage,
                      IN PMDL               pMdl,
                      IN ULONG              TotalLength,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN NDIS_STATUS        ReceiveStatus,
                      IN BOOLEAN            bMessageCopied);

BOOLEAN
UnknownMessage(IN PRNDISMP_ADAPTER   pAdapter,
               IN PRNDIS_MESSAGE     pMessage,
               IN PMDL               pMdl,
               IN ULONG              TotalLength,
               IN NDIS_HANDLE        MicroportMessageContext,
               IN NDIS_STATUS        ReceiveStatus,
               IN BOOLEAN            bMessageCopied);

PRNDISMP_RECV_DATA_FRAME
AllocateReceiveFrame(IN PRNDISMP_ADAPTER    pAdapter);

VOID
FreeReceiveFrame(IN PRNDISMP_RECV_DATA_FRAME    pRcvFrame,
                 IN PRNDISMP_ADAPTER            pAdapter);

VOID
IndicateTimeout(IN PVOID SystemSpecific1,
                IN PVOID Context,
                IN PVOID SystemSpecific2,
                IN PVOID SystemSpecific3);

//
// Prototypes for functions in send.c
//

VOID
RndismpMultipleSend(IN NDIS_HANDLE   MiniportAdapterContext,
                    IN PPNDIS_PACKET PacketArray,
                    IN UINT          NumberOfPackets);

VOID
DoMultipleSend(IN PRNDISMP_ADAPTER  pAdapter,
               IN PRNDISMP_VC       pVc OPTIONAL,
               IN PPNDIS_PACKET     PacketArray,
               IN UINT              NumberOfPackets);

VOID
DoMultipleSendRaw(IN PRNDISMP_ADAPTER  pAdapter,
                  IN PRNDISMP_VC       pVc OPTIONAL,
                  IN PPNDIS_PACKET     PacketArray,
                  IN UINT              NumberOfPackets);

PRNDISMP_PACKET_WRAPPER
PrepareDataMessage(IN   PNDIS_PACKET            pNdisPacket,
                   IN   PRNDISMP_ADAPTER        pAdapter,
                   IN   PRNDISMP_VC             pVc         OPTIONAL,
                   IN OUT PULONG                pTotalMessageLength);

PRNDISMP_PACKET_WRAPPER
PrepareDataMessageRaw(IN   PNDIS_PACKET            pNdisPacket,
                      IN   PRNDISMP_ADAPTER        pAdapter,
                      IN OUT PULONG                pTotalMessageLength);

PRNDISMP_PACKET_WRAPPER
AllocatePacketMsgWrapper(IN PRNDISMP_ADAPTER        pAdapter,
                         IN ULONG                   MsgHeaderLength);

VOID
FreePacketMsgWrapper(IN PRNDISMP_PACKET_WRAPPER     pPktWrapper);

VOID
CompleteSendData(IN  PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN  NDIS_STATUS            SendStatus);

VOID
FreeMsgAfterSend(IN  PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN  NDIS_STATUS            SendStatus);

#if THROTTLE_MESSAGES
VOID
QueueMessageToMicroport(IN PRNDISMP_ADAPTER pAdapter,
                        IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                        IN BOOLEAN          bQueueMessageForResponse);
VOID
FlushPendingMessages(IN  PRNDISMP_ADAPTER        pAdapter);
#endif

VOID
SendProcessTimeout(IN PVOID SystemSpecific1,
                  IN PVOID Context,
                  IN PVOID SystemSpecific2,
                  IN PVOID SystemSpecific3);

//
// Prototypes for functions in request.c
//

NDIS_STATUS
RndismpQueryInformation(IN  NDIS_HANDLE MiniportAdapterContext,
                        IN  NDIS_OID    Oid,
                        IN  PVOID       InformationBuffer,
                        IN  ULONG       InformationBufferLength,
                        OUT PULONG      pBytesWritten,
                        OUT PULONG      pBytesNeeded);
NDIS_STATUS
ProcessQueryInformation(IN  PRNDISMP_ADAPTER    pAdapter,
                        IN  PRNDISMP_VC         pVc,
                        IN  PNDIS_REQUEST       pRequest,
                        IN  NDIS_OID            Oid,
                        IN  PVOID               InformationBuffer,
                        IN  ULONG               InformationBufferLength,
                        OUT PULONG              pBytesWritten,
                        OUT PULONG              pBytesNeeded);

NDIS_STATUS
RndismpSetInformation(IN  NDIS_HANDLE   MiniportAdapterContext,
                      IN  NDIS_OID      Oid,
                      IN  PVOID         InformationBuffer,
                      IN  ULONG         InformationBufferLength,
                      OUT PULONG        pBytesRead,
                      OUT PULONG        pBytesNeeded);

NDIS_STATUS
ProcessSetInformation(IN  PRNDISMP_ADAPTER    pAdapter,
                      IN  PRNDISMP_VC         pVc OPTIONAL,
                      IN  PNDIS_REQUEST       pRequest OPTIONAL,
                      IN  NDIS_OID            Oid,
                      IN  PVOID               InformationBuffer,
                      IN  ULONG               InformationBufferLength,
                      OUT PULONG              pBytesRead,
                      OUT PULONG              pBytesNeeded);

NDIS_STATUS
DriverQueryInformation(IN  PRNDISMP_ADAPTER pAdapter,
                       IN  PRNDISMP_VC      pVc OPTIONAL,
                       IN  PNDIS_REQUEST    pRequest OPTIONAL,
                       IN  NDIS_OID         Oid,
                       IN  PVOID            InformationBuffer,
                       IN  ULONG            InformationBufferLength,
                       OUT PULONG           pBytesWritten,
                       OUT PULONG           pBytesNeeded);

NDIS_STATUS
DeviceQueryInformation(IN  PRNDISMP_ADAPTER pAdapter,
                       IN  PRNDISMP_VC      pVc OPTIONAL,
                       IN  PNDIS_REQUEST    pRequest OPTIONAL,
                       IN  NDIS_OID         Oid,
                       IN  PVOID            InformationBuffer,
                       IN  ULONG            InformationBufferLength,
                       OUT PULONG           pBytesWritten,
                       OUT PULONG           pBytesNeeded);

NDIS_STATUS
DriverSetInformation(IN  PRNDISMP_ADAPTER   pAdapter,
                     IN  PRNDISMP_VC        pVc OPTIONAL,
                     IN  PNDIS_REQUEST      pRequest OPTIONAL,
                     IN  NDIS_OID           Oid,
                     IN  PVOID              InformationBuffer,
                     IN  ULONG              InformationBufferLength,
                     OUT PULONG             pBytesRead,
                     OUT PULONG             pBytesNeeded);

NDIS_STATUS
DeviceSetInformation(IN  PRNDISMP_ADAPTER   pAdapter,
                     IN  PRNDISMP_VC        pVc OPTIONAL,
                     IN  PNDIS_REQUEST      pRequest OPTIONAL,
                     IN  NDIS_OID           Oid,
                     IN  PVOID              InformationBuffer,
                     IN  ULONG              InformationBufferLength,
                     OUT PULONG             pBytesRead,
                     OUT PULONG             pBytesNeeded);

BOOLEAN
QuerySetCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                          IN PRNDIS_MESSAGE     pMessage,
                          IN PMDL               pMdl,
                          IN ULONG              TotalLength,
                          IN NDIS_HANDLE        MicroportMessageContext,
                          IN NDIS_STATUS        ReceiveStatus,
                          IN BOOLEAN            bMessageCopied);

VOID
CompleteSendDeviceRequest(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                          IN NDIS_STATUS            SendStatus);

#ifdef BUILD_WIN9X

VOID
CompleteSendDiscardDeviceRequest(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                                 IN NDIS_STATUS            SendStatus);

#endif // BUILD_WIN9X


NDIS_STATUS
BuildOIDLists(IN PRNDISMP_ADAPTER  Adapter, 
              IN PNDIS_OID         DeviceOIDList,
              IN UINT              NumDeviceOID,
              IN PNDIS_OID         DriverOIDList,
              IN UINT              NumDriverOID);

UINT
GetOIDSupport(IN PRNDISMP_ADAPTER Adapter, IN NDIS_OID Oid);

VOID
FreeOIDLists(IN PRNDISMP_ADAPTER Adapter);

PRNDISMP_REQUEST_CONTEXT
AllocateRequestContext(IN PRNDISMP_ADAPTER pAdapter);

VOID
FreeRequestContext(IN PRNDISMP_ADAPTER pAdapter,
                   IN PRNDISMP_REQUEST_CONTEXT pReqContext);

NDIS_STATUS
SyncQueryDevice(IN PRNDISMP_ADAPTER pAdapter,
                IN NDIS_OID Oid,
                IN OUT PUCHAR InformationBuffer,
                IN ULONG InformationBufferLength);

//
// Prototypes for functions in util.c
//

NDIS_STATUS
MemAlloc(OUT PVOID *Buffer, IN UINT Length);

VOID
MemFree(IN PVOID Buffer, IN UINT Length);

VOID
AddAdapter(IN PRNDISMP_ADAPTER Adapter);

VOID
RemoveAdapter(IN PRNDISMP_ADAPTER Adapter);

VOID
DeviceObjectToAdapterAndDriverBlock(IN PDEVICE_OBJECT pDeviceObject,
                                    OUT PRNDISMP_ADAPTER * ppAdapter,
                                    OUT PDRIVER_BLOCK * ppDriverBlock);

VOID
AddDriverBlock(IN PDRIVER_BLOCK Head, IN PDRIVER_BLOCK Item);

VOID
RemoveDriverBlock(IN PDRIVER_BLOCK BlockHead, IN PDRIVER_BLOCK Item);

PDRIVER_BLOCK
DeviceObjectToDriverBlock(IN PDRIVER_BLOCK Head, 
                          IN PDEVICE_OBJECT DeviceObject);

PDRIVER_BLOCK
DriverObjectToDriverBlock(IN PDRIVER_BLOCK Head,
                          IN PDRIVER_OBJECT DriverObject);

PRNDISMP_MESSAGE_FRAME
AllocateMsgFrame(IN PRNDISMP_ADAPTER pAdapter);

VOID
DereferenceMsgFrame(IN PRNDISMP_MESSAGE_FRAME pMsgFrame);

VOID
ReferenceMsgFrame(IN PRNDISMP_MESSAGE_FRAME pMsgFrame);

VOID
EnqueueNDISPacket(IN PRNDISMP_ADAPTER Adapter, IN PNDIS_PACKET Packet);

PNDIS_PACKET
DequeueNDISPacket(IN PRNDISMP_ADAPTER Adapter);

VOID
KeepAliveTimerHandler(IN PVOID SystemSpecific1,
                      IN PVOID Context,
                      IN PVOID SystemSpecific2,
                      IN PVOID SystemSpecific3);

VOID
CompleteSendKeepAlive(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                      IN NDIS_STATUS SendStatus);

PRNDISMP_MESSAGE_FRAME
BuildRndisMessageCommon(IN  PRNDISMP_ADAPTER  Adapter, 
                        IN  PRNDISMP_VC       pVc,
                        IN  UINT              NdisMessageType,
                        IN  NDIS_OID          Oid,
                        IN  PVOID             InformationBuffer,
                        IN  ULONG             InformationBufferLength);


PRNDISMP_MESSAGE_FRAME
AllocateMessageAndFrame(IN PRNDISMP_ADAPTER Adapter,
                        IN UINT MessageSize);

VOID
FreeAdapter(IN PRNDISMP_ADAPTER pAdapter);

PRNDISMP_VC
AllocateVc(IN PRNDISMP_ADAPTER      pAdapter);

VOID
DeallocateVc(IN PRNDISMP_VC         pVc);

PRNDISMP_VC
LookupVcId(IN PRNDISMP_ADAPTER  pAdapter,
           IN UINT32            VcId);

VOID
EnterVcIntoHashTable(IN PRNDISMP_ADAPTER    pAdapter,
                     IN PRNDISMP_VC         pVc);

VOID
RemoveVcFromHashTable(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDISMP_VC        pVc);

//
// Prototypes for functions in comini.c
//
NDIS_STATUS
RndismpCoCreateVc(IN NDIS_HANDLE    MiniportAdapterContext,
                  IN NDIS_HANDLE    NdisVcHandle,
                  IN PNDIS_HANDLE   pMiniportVcContext);

VOID
CompleteSendCoCreateVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                       IN NDIS_STATUS               SendStatus);

VOID
HandleCoCreateVcFailure(IN PRNDISMP_VC      pVc,
                        IN NDIS_STATUS      Status);

NDIS_STATUS
RndismpCoDeleteVc(IN NDIS_HANDLE    MiniportVcContext);

NDIS_STATUS
StartVcDeletion(IN PRNDISMP_VC      pVc);

VOID
CompleteSendCoDeleteVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                       IN NDIS_STATUS               SendStatus);

VOID
HandleCoDeleteVcFailure(IN PRNDISMP_VC      pVc,
                        IN NDIS_STATUS      Status);

NDIS_STATUS
RndismpCoActivateVc(IN NDIS_HANDLE          MiniportVcContext,
                    IN PCO_CALL_PARAMETERS  pCallParameters);

NDIS_STATUS
StartVcActivation(IN PRNDISMP_VC            pVc);

VOID
CompleteSendCoActivateVc(IN PRNDISMP_MESSAGE_FRAME      pMsgFrame,
                         IN NDIS_STATUS                 SendStatus);

NDIS_STATUS
RndismpCoDeactivateVc(IN NDIS_HANDLE          MiniportVcContext);

VOID
CompleteSendCoDeactivateVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                           IN NDIS_STATUS               SendStatus);

NDIS_STATUS
RndismpCoRequest(IN NDIS_HANDLE          MiniportAdapterContext,
                 IN NDIS_HANDLE          MiniportVcContext,
                 IN OUT PNDIS_REQUEST    pRequest);

VOID
RndismpCoSendPackets(IN NDIS_HANDLE          MiniportVcContext,
                     IN PNDIS_PACKET *       PacketArray,
                     IN UINT                 NumberOfPackets);

BOOLEAN
ReceiveCreateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied);

BOOLEAN
ReceiveActivateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                          IN PRNDIS_MESSAGE      pMessage,
                          IN PMDL                pMdl,
                          IN ULONG               TotalLength,
                          IN NDIS_HANDLE         MicroportMessageContext,
                          IN NDIS_STATUS         ReceiveStatus,
                          IN BOOLEAN             bMessageCopied);

BOOLEAN
ReceiveDeleteVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied);

BOOLEAN
ReceiveDeactivateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                            IN PRNDIS_MESSAGE      pMessage,
                            IN PMDL                pMdl,
                            IN ULONG               TotalLength,
                            IN NDIS_HANDLE         MicroportMessageContext,
                            IN NDIS_STATUS         ReceiveStatus,
                            IN BOOLEAN             bMessageCopied);

PRNDISMP_MESSAGE_FRAME
BuildRndisMessageCoMiniport(IN  PRNDISMP_ADAPTER    pAdapter,
                            IN  PRNDISMP_VC         pVc,
                            IN  UINT                NdisMessageType,
                            IN  PCO_CALL_PARAMETERS pCallParameters OPTIONAL);

VOID
CompleteSendDataOnVc(IN PRNDISMP_VC         pVc,
                     IN PNDIS_PACKET        pNdisPacket,
                     IN NDIS_STATUS         Status);

VOID
IndicateReceiveDataOnVc(IN PRNDISMP_VC         pVc,
                        IN PNDIS_PACKET *      PacketArray,
                        IN UINT                NumberOfPackets);

//
// Prototypes for functions in wdmutil.c
//

PDRIVER_OBJECT
DeviceObjectToDriverObject(IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
GetDeviceFriendlyName(IN PDEVICE_OBJECT pDeviceObject,
                      OUT PANSI_STRING pAnsiString,
                      OUT PUNICODE_STRING pUnicodeString);

VOID
HookPnpDispatchRoutine(IN PDRIVER_BLOCK    DriverBlock);

NTSTATUS
PnPDispatch(IN PDEVICE_OBJECT       pDeviceObject,
            IN PIRP                 pIrp);

#ifdef BUILD_WIN9X

VOID
HookNtKernCMHandler(IN PRNDISMP_ADAPTER     pAdapter);

VOID
UnHookNtKernCMHandler(IN PRNDISMP_ADAPTER     pAdapter);
MY_CONFIGRET __cdecl
RndisCMHandler(IN MY_CONFIGFUNC         cfFuncName,
               IN MY_SUBCONFIGFUNC      cfSubFuncName,
               IN MY_DEVNODE            cfDevNode,
               IN ULONG                 dwRefData,
               IN ULONG                 ulFlags);

#endif

#if DBG

//
// Prototypes for functions in debug.c
//

PCHAR
GetOidName(IN NDIS_OID Oid);

VOID
DisplayOidList(IN PRNDISMP_ADAPTER Adapter);

VOID
RndisPrintHexDump(PVOID            Pointer,
                  ULONG            Length);

VOID
RndisLogSendMessage(
    IN  PRNDISMP_ADAPTER        pAdapter,
    IN  PRNDISMP_MESSAGE_FRAME  pMsgFrame);

#endif


#endif // _RNDISMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\rndismp.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RNDISMP.C

Abstract:

    Remote NDIS Miniport driver. Sits on top of Remote NDIS bus specific
    layers.

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/6/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"



//
// miniport driver block list (miniport layer may support several microports)
//
DRIVER_BLOCK        RndismpMiniportBlockListHead = {0};

UINT                RndismpNumMicroports = 0;

NDIS_SPIN_LOCK      RndismpGlobalLock;

ULONG               RndisForceReset = FALSE;

#ifdef TESTING
UCHAR               OffloadBuffer[sizeof(NDIS_TASK_OFFLOAD_HEADER) +
                                  sizeof(NDIS_TASK_OFFLOAD) +
                                  sizeof(NDIS_TASK_TCP_IP_CHECKSUM)];
PUCHAR              pOffloadBuffer = OffloadBuffer;
ULONG               OffloadSize = sizeof(OffloadBuffer);
#endif

#ifdef RAW_ENCAP
ULONG               gRawEncap = TRUE;
#else
ULONG               gRawEncap = FALSE;
#endif

//
//  A list of NDIS versions we cycle through, trying to register the
//  highest version we can with NDIS. This is so that we can run on
//  earlier platforms.
//
//  To support a newer version, add an entry at the TOP of the list.
//
struct _RNDISMP_NDIS_VERSION_TABLE
{
    UCHAR           MajorVersion;
    UCHAR           MinorVersion;
    ULONG           CharsSize;
} RndismpNdisVersionTable[] =

{
#ifdef NDIS51_MINIPORT
    {5, 1, sizeof(NDIS51_MINIPORT_CHARACTERISTICS)},
#endif

    {5, 0, sizeof(NDIS50_MINIPORT_CHARACTERISTICS)}
};

ULONG   RndismpNdisVersions = sizeof(RndismpNdisVersionTable) /
                              sizeof(struct _RNDISMP_NDIS_VERSION_TABLE);


/****************************************************************************/
/*                          DriverEntry                                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*   Driver entry routine. Never called, Microport driver entry is used     */
/*                                                                          */
/****************************************************************************/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    // this is never called. Driver entry in Microport is entry.
    TRACE1(("DriverEntry\n"));

    return NDIS_STATUS_SUCCESS;
} // DriverEntry

/****************************************************************************/
/*                          RndisMInitializeWrapper                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*   RndisMInitializeWrapper is called from the microport to init driver    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*   pNdisWrapperHandle    - Pass NDIS wrapper handle back to microport     */
/*   MicroportContext      - Microport "Global" context                     */
/*   DriverObject          - Driver object                                  */
/*   RegistryPath          - Registry path                                  */
/*   pCharacteristics      - Characteristics of RNDIS microport             */
/*                                                                          */
/* Return Value:                                                            */
/*                                                                          */
/*   NDIS_STATUS_SUCCESS                                                    */
/*   NDIS_STATUS_PENDING                                                    */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndisMInitializeWrapper(OUT PNDIS_HANDLE                      pNdisWrapperHandle,
                        IN  PVOID                             MicroportContext,
                        IN  PVOID                             DriverObject,
                        IN  PVOID                             RegistryPath,
                        IN  PRNDIS_MICROPORT_CHARACTERISTICS  pCharacteristics)
{
    // Receives the status of the NdisMRegisterMiniport operation.
    NDIS_STATUS                         Status;

    // Characteristics table for this driver
    NDIS_MINIPORT_CHARACTERISTICS       RndismpChar;

    // Pointer to the global information for this driver
    PDRIVER_BLOCK                       NewDriver;

    // Handle for referring to the wrapper about this driver.
    NDIS_HANDLE                         NdisWrapperHandle;

    ULONG                               i;

    TRACE3(("RndisMInitializeWrapper\n"));

    // allocate the driver block object, exit if error occurs
    Status = MemAlloc(&NewDriver, sizeof(DRIVER_BLOCK));

    if(Status != NDIS_STATUS_SUCCESS)
    {
        TRACE2(("Block Allocate Memory failed (%08X)\n", Status));
        return Status;
    }

    // Initialize the wrapper.
    NdisMInitializeWrapper(&NdisWrapperHandle,
                           (PDRIVER_OBJECT)DriverObject,
                           RegistryPath,
                           NULL);

    // Save the global information about this driver.
    NewDriver->NdisWrapperHandle        = NdisWrapperHandle;
    NewDriver->AdapterList              = (PRNDISMP_ADAPTER) NULL;
    NewDriver->DriverObject             = DriverObject;
    NewDriver->Signature                = BLOCK_SIGNATURE;

    // get handlers passed in from microport
    NewDriver->RmInitializeHandler      = pCharacteristics->RmInitializeHandler;
    NewDriver->RmInitCompleteNotifyHandler  = pCharacteristics->RmInitCompleteNotifyHandler;
    NewDriver->RmHaltHandler            = pCharacteristics->RmHaltHandler;
    NewDriver->RmShutdownHandler        = pCharacteristics->RmShutdownHandler;
    NewDriver->RmUnloadHandler          = pCharacteristics->RmUnloadHandler;
    NewDriver->RmSendMessageHandler     = pCharacteristics->RmSendMessageHandler;
    NewDriver->RmReturnMessageHandler   = pCharacteristics->RmReturnMessageHandler;

    // save microport "Global" context
    NewDriver->MicroportContext         = MicroportContext;

    // pass the microport the wrapper handle
    *pNdisWrapperHandle                 = (NDIS_HANDLE) NdisWrapperHandle;

    // initialize the Miniport characteristics for the call to NdisMRegisterMiniport.
    NdisZeroMemory(&RndismpChar, sizeof(RndismpChar));
    
    RndismpChar.HaltHandler             = RndismpHalt;
    RndismpChar.InitializeHandler       = RndismpInitialize;
    RndismpChar.QueryInformationHandler = RndismpQueryInformation;
    RndismpChar.ReconfigureHandler      = RndismpReconfigure;
    RndismpChar.ResetHandler            = RndismpReset;
    RndismpChar.SendPacketsHandler      = RndismpMultipleSend;
    RndismpChar.SetInformationHandler   = RndismpSetInformation;
    RndismpChar.ReturnPacketHandler     = RndismpReturnPacket;
    RndismpChar.CheckForHangHandler     = RndismpCheckForHang;
    RndismpChar.DisableInterruptHandler = NULL;
    RndismpChar.EnableInterruptHandler  = NULL;
    RndismpChar.HandleInterruptHandler  = NULL;
    RndismpChar.ISRHandler              = NULL;
    RndismpChar.SendHandler             = NULL;
    RndismpChar.TransferDataHandler     = NULL;
#if CO_RNDIS
    RndismpChar.CoSendPacketsHandler    = RndismpCoSendPackets;
    RndismpChar.CoCreateVcHandler       = RndismpCoCreateVc;
    RndismpChar.CoDeleteVcHandler       = RndismpCoDeleteVc;
    RndismpChar.CoActivateVcHandler     = RndismpCoActivateVc;
    RndismpChar.CoDeactivateVcHandler   = RndismpCoDeactivateVc;
    RndismpChar.CoRequestHandler        = RndismpCoRequest;
#endif // CO_RNDIS

#ifdef NDIS51_MINIPORT
    RndismpChar.PnPEventNotifyHandler   = RndismpPnPEventNotify;
    RndismpChar.AdapterShutdownHandler  = RndismpShutdownHandler;
#endif

    for (i = 0; i < RndismpNdisVersions; i++)
    {
        RndismpChar.MajorNdisVersion = RndismpNdisVersionTable[i].MajorVersion;
        RndismpChar.MinorNdisVersion = RndismpNdisVersionTable[i].MinorVersion;

        Status = NdisMRegisterMiniport(NdisWrapperHandle,
                                       &RndismpChar,
                                       RndismpNdisVersionTable[i].CharsSize);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            TRACE1(("InitializeWrapper: successfully registered as a %d.%d miniport\n",
                RndismpNdisVersionTable[i].MajorVersion,
                RndismpNdisVersionTable[i].MinorVersion));

            NewDriver->MajorNdisVersion = RndismpNdisVersionTable[i].MajorVersion;
            NewDriver->MinorNdisVersion = RndismpNdisVersionTable[i].MinorVersion;

            break;
        }
    }

    if(Status != NDIS_STATUS_SUCCESS)
    {
        Status = STATUS_UNSUCCESSFUL;

        // free up memory allocated for block
        MemFree(NewDriver, sizeof(DRIVER_BLOCK));
    }
    else
    {
        // everything went fine, so add the driver block to the list
        AddDriverBlock(&RndismpMiniportBlockListHead, NewDriver);

#ifndef BUILD_WIN9X
        // if we are running on a platform < NDIS 5.1, attempt to support
        // surprise removal.
        HookPnpDispatchRoutine(NewDriver);
#endif

#ifndef BUILD_WIN9X
        // Not supported on Win98 Gold:
        NdisMRegisterUnloadHandler(NdisWrapperHandle, RndismpUnload);
#endif
    }

    return (NDIS_STATUS) Status;

} // RndisMInitializeWrapper


/****************************************************************************/
/*                          RndismpUnload                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by NDIS when this driver is unloaded.                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pDriverObject - Pointer to driver object.                               */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpUnload(IN PDRIVER_OBJECT pDriverObject)
{
    PDRIVER_BLOCK       DriverBlock;

    // Find our Driver block for this driver object.
    DriverBlock = DriverObjectToDriverBlock(&RndismpMiniportBlockListHead, pDriverObject);

    TRACE1(("RndismpUnload: DriverObj %x, DriverBlock %x\n", pDriverObject, DriverBlock));

    if (DriverBlock)
    {
        if (DriverBlock->RmUnloadHandler)
        {
            (DriverBlock->RmUnloadHandler)(DriverBlock->MicroportContext);
        }

        RemoveDriverBlock(&RndismpMiniportBlockListHead, DriverBlock);

        MemFree(DriverBlock, sizeof(*DriverBlock));
    }

    TRACE1(("RndismpUnload: Done\n"));

}

#ifndef BUILD_WIN9X

/****************************************************************************/
/*                          DllInitialize                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by the system when this driver is loaded.                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pRegistryPath - Pointer to registry path for this service.              */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NTSTATUS - success always                                              */
/*                                                                          */
/****************************************************************************/
NTSTATUS
DllInitialize(IN PUNICODE_STRING    pRegistryPath)
{
#if DBG
    DbgPrint("RNDISMP: RndismpDebugFlags set to %x, &RndismpDebugFlags is %p\n",
                RndismpDebugFlags, &RndismpDebugFlags);
#endif

    TRACE1(("DllInitialize\n"));
#ifdef TESTING
    {
        PNDIS_TASK_OFFLOAD_HEADER   pOffloadHdr = (PNDIS_TASK_OFFLOAD_HEADER)pOffloadBuffer;
        PNDIS_TASK_OFFLOAD  pTask;
        PNDIS_TASK_TCP_IP_CHECKSUM pChksum;

        pOffloadHdr->Version = NDIS_TASK_OFFLOAD_VERSION;
        pOffloadHdr->Size = sizeof(NDIS_TASK_OFFLOAD_HEADER);
        pOffloadHdr->EncapsulationFormat.Encapsulation = IEEE_802_3_Encapsulation;
        pOffloadHdr->EncapsulationFormat.EncapsulationHeaderSize = 0; // ?
        pOffloadHdr->EncapsulationFormat.Flags.FixedHeaderSize = 0;
        pOffloadHdr->OffsetFirstTask = sizeof(NDIS_TASK_OFFLOAD_HEADER);

        pTask = (PNDIS_TASK_OFFLOAD)(pOffloadHdr + 1);
        pTask->Version = NDIS_TASK_OFFLOAD_VERSION;
        pTask->Size = sizeof(NDIS_TASK_OFFLOAD);
        pTask->Task = TcpIpChecksumNdisTask;
        pTask->OffsetNextTask = 0;
        pTask->TaskBufferLength = sizeof(NDIS_TASK_TCP_IP_CHECKSUM);

        pChksum = (PNDIS_TASK_TCP_IP_CHECKSUM)&pTask->TaskBuffer[0];
        *(PULONG)pChksum = 0;
        pChksum->V4Transmit.TcpChecksum = 1;
        pChksum->V4Transmit.UdpChecksum = 1;
    }
#endif

    return STATUS_SUCCESS;
}

#endif // !BUILD_WIN9X

/****************************************************************************/
/*                          DllUnload                                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by the system when this driver is unloaded.                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  None                                                                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NTSTATUS - success always                                              */
/*                                                                          */
/****************************************************************************/
NTSTATUS
DllUnload(VOID)
{
#if DBG
    DbgPrint("RNDISMP: DllUnload called!\n");
#endif

    return STATUS_SUCCESS;
}

/****************************************************************************/
/*                          RndismpHalt                                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Stop the adapter and release resources                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpHalt(IN NDIS_HANDLE MiniportAdapterContext)
{

#ifdef BUILD_WIN9X
    //
    //  On Win98/SE, we would have intercepted the config mgr handler.
    //  Put it back the way it was.
    //
    UnHookNtKernCMHandler((PRNDISMP_ADAPTER)MiniportAdapterContext);
#endif

    RndismpInternalHalt(MiniportAdapterContext, TRUE);
}

/****************************************************************************/
/*                          RndismpInternalHalt                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Internal Halt routine. This is usually called from the MiniportHalt     */
/*  entry point, but it may also be called when we are notified of surprise */
/*  removal by NDIS. Do all work atmost once.                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  bCalledFromHalt - Is this called from the MiniportHalt entry point?     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
RndismpInternalHalt(IN NDIS_HANDLE MiniportAdapterContext,
                    IN BOOLEAN bCalledFromHalt)
{
    PRNDISMP_ADAPTER            Adapter;
    PDRIVER_BLOCK               DriverBlock;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    BOOLEAN                     bWokenUp;
    UINT                        Count, LoopCount;

    // get adapter context
    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(Adapter);

    TRACE1(("RndismpInternalHalt: Adapter %x, Halting %d, CalledFromHalt %d\n", Adapter, Adapter->Halting, bCalledFromHalt));

    FlushPendingMessages(Adapter);

    if (!Adapter->Halting)
    {
        pMsgFrame = BuildRndisMessageCommon(Adapter, 
                                            NULL,
                                            REMOTE_NDIS_HALT_MSG,
                                            0,
                                            NULL,
                                            0);

        if(pMsgFrame)
        {
            RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

            Adapter->Halting = TRUE;
            NdisInitializeEvent(&Adapter->HaltWaitEvent);

            RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);

            // send the message to the microport
            RNDISMP_SEND_TO_MICROPORT(Adapter, pMsgFrame, FALSE, CompleteSendHalt);

            // wait for the -Send- to complete
            bWokenUp = NdisWaitEvent(&Adapter->HaltWaitEvent, MINIPORT_HALT_TIMEOUT);
        }
        else
        {
            ASSERT(FALSE);
            // Consider allocating the Halt message during Init time.
        }

        //
        // Wait for any outstanding receives to finish before halting
        // the microport.
        //
        LoopCount = 0;
        while ((Count = NdisPacketPoolUsage(Adapter->ReceivePacketPool)) != 0)
        {
            TRACE1(("RndismpInternalHalt: Adapter %p, Pkt pool %x has "
                "%d outstanding\n",
                Adapter, Adapter->ReceivePacketPool, Count));

            NdisMSleep(200);

            if (LoopCount++ > 30)
            {
                TRACE1(("RndismpInternalHalt: Adapter %p, cant reclaim packet pool %x\n",
                        Adapter, Adapter->ReceivePacketPool));
                break;
            }
        }

        //
        // Wait for send-messages pending at the microport to finish.
        // Since we have set Halting to TRUE, no -new- messages will
        // be sent down, however there may be running threads that
        // have gone past the check for Halting - allow those
        // threads to finish now.
        //
        LoopCount = 0;
        while (Adapter->CurPendedMessages)
        {
            TRACE1(("RndismpInternalHalt: Adapter %p, %d msgs at microport\n",
                Adapter, Adapter->CurPendedMessages));

            NdisMSleep(200);

            if (LoopCount++ > 30)
            {
                TRACE1(("RndismpInternalHalt: Adapter %p, %d messages not send-completed!\n",
                        Adapter, Adapter->CurPendedMessages));
                break;
            }
        }

        // cancel our keep alive timer
        NdisCancelTimer(&Adapter->KeepAliveTimer, &Adapter->TimerCancelled);

        // call the microport halt handler
        Adapter->RmHaltHandler(Adapter->MicroportAdapterContext);
    }

    if (bCalledFromHalt)
    {
        // free lists associated with OID support
        FreeOIDLists(Adapter);

        // free the adapter spinlock
        NdisFreeSpinLock(&Adapter->Lock);

        // save driver block pointer
        DriverBlock = Adapter->DriverBlock;

        // remove adapter from list
        RemoveAdapter(Adapter);

        // Free the Adapter and associated memory resources
        FreeAdapter(Adapter);
    }

} // RndismpInternalHalt


/****************************************************************************/
/*                          RndismpReconfigure                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  NDIS calls this when the device is pulled. Note: only on WinMe!         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpReconfigure(OUT PNDIS_STATUS pStatus,
                   IN NDIS_HANDLE MiniportAdapterContext,
                   IN NDIS_HANDLE ConfigContext)
{
    PRNDISMP_ADAPTER        pAdapter;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE1(("Reconfig: Adapter %x\n", pAdapter));

    RndismpInternalHalt(pAdapter, FALSE);

    *pStatus = NDIS_STATUS_SUCCESS;

    return (NDIS_STATUS_SUCCESS);
}
    

/****************************************************************************/
/*                          RndismpReset                                    */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  The RndismpReset request instructs the Miniport to issue a hardware     */
/*  reset to the network adapter.  The driver also resets its software      */
/*  state.  See the description of NdisMReset for a detailed description    */
/*  of this request.                                                        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  AddressingReset - Does the adapter need the addressing information      */
/*   reloaded.                                                              */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
RndismpReset(OUT PBOOLEAN    AddressingReset,
             IN  NDIS_HANDLE MiniportAdapterContext)
{
    PRNDISMP_ADAPTER        Adapter;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    NDIS_STATUS             Status;

    // get adapter context
    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(Adapter);
    ASSERT(Adapter->ResetPending == FALSE);

    TRACE1(("RndismpReset: Adapter %x\n", Adapter));

    Adapter->ResetPending = TRUE;

    FlushPendingMessages(Adapter);

    pMsgFrame = BuildRndisMessageCommon(Adapter, 
                                        NULL,
                                        REMOTE_NDIS_RESET_MSG,
                                        0,
                                        NULL,
                                        0);

    if (pMsgFrame)
    {
        RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

        Adapter->NeedReset = FALSE;

        //
        // Fix water mark so that the reset gets sent down.
        //
        Adapter->HiWatPendedMessages = RNDISMP_PENDED_SEND_HIWAT + 1;

        RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);

        // send the message to the microport
        RNDISMP_SEND_TO_MICROPORT(Adapter, pMsgFrame, FALSE, CompleteSendReset);
        Status = NDIS_STATUS_PENDING;

        RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

        Adapter->HiWatPendedMessages--;

        RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
    }
    else
    {
        CompleteMiniportReset(Adapter, NDIS_STATUS_RESOURCES, FALSE);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
} // RndismpReset

/****************************************************************************/
/*                          RndismpCheckForHang                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Check and see if device is "hung"                                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   BOOLEAN                                                                */
/*                                                                          */
/****************************************************************************/
BOOLEAN
RndismpCheckForHang(IN NDIS_HANDLE MiniportAdapterContext)
{
    PRNDISMP_ADAPTER        Adapter;
    BOOLEAN                 bReturnHung;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;
    PLIST_ENTRY             pEnt;

    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    TRACE2(("RndismpCheckForHang: Adapter %x\n", Adapter));

    CHECK_VALID_ADAPTER(Adapter);

    RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

    bReturnHung = (Adapter->NeedReset && !Adapter->ResetPending);

#if THROTTLE_MESSAGES
    // Try to grow the pending send window, if we can.
    //
    if (!Adapter->SendInProgress)
    {
        if (Adapter->CurPendedMessages == 0)
        {
            Adapter->HiWatPendedMessages = RNDISMP_PENDED_SEND_HIWAT;
            Adapter->LoWatPendedMessages = RNDISMP_PENDED_SEND_LOWAT;
        }
    }

    if (!bReturnHung && !Adapter->ResetPending)
    {
        //
        //  Check if the microport isn't completing messages.
        //
        if (!IsListEmpty(&Adapter->PendingAtMicroportList))
        {
            pEnt = Adapter->PendingAtMicroportList.Flink;
            pMsgFrame = CONTAINING_RECORD(pEnt, RNDISMP_MESSAGE_FRAME, PendLink);

            if (pMsgFrame->TicksOnQueue > 4)
            {
                TRACE1(("CheckForHang: Adapter %x, Msg %x has timed out!\n",
                        Adapter, pMsgFrame));
                bReturnHung = TRUE;
            }
            else
            {
                pMsgFrame->TicksOnQueue++;
            }
        }
    }

#endif // THROTTLE_MESSAGES

    if (RndisForceReset)
    {
        RndisForceReset = FALSE;
        Adapter->NeedReset = TRUE;
        Adapter->ResetPending = FALSE;
        bReturnHung = TRUE;
    }

    RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);

    return (bReturnHung);


} // RndismpCheckForHang


/****************************************************************************/
/*                          RndismpInitialize                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*   RndismpInitialize starts an adapter and registers resources with the   */
/*   wrapper.                                                               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    OpenErrorStatus - Extra status bytes for opening token ring adapters. */
/*    SelectedMediumIndex - Index of the media type chosen by the driver.   */
/*    MediumArray - Array of media types for the driver to chose from.      */
/*    MediumArraySize - Number of entries in the array.                     */
/*    MiniportAdapterHandle - Handle for passing to the wrapper when        */
/*       referring to this adapter.                                         */
/*    ConfigurationHandle - A handle to pass to NdisOpenConfiguration.      */
/*                                                                          */
/* Return Value:                                                            */
/*                                                                          */
/*    NDIS_STATUS_SUCCESS                                                   */
/*    NDIS_STATUS_PENDING                                                   */
/*                                                                          */
/****************************************************************************/

NDIS_STATUS
RndismpInitialize(OUT PNDIS_STATUS  OpenErrorStatus,
                  OUT PUINT         SelectedMediumIndex,
                  IN  PNDIS_MEDIUM  MediumArray,
                  IN  UINT          MediumArraySize,
                  IN  NDIS_HANDLE   MiniportAdapterHandle,
                  IN  NDIS_HANDLE   ConfigurationHandle)
{
    ULONG                       Index;
    NDIS_STATUS                 Status;
    PRNDISMP_ADAPTER            Adapter;
    NDIS_INTERFACE_TYPE         IfType;
    PDEVICE_OBJECT              Pdo, Fdo, Ndo;
    PDRIVER_BLOCK               DriverBlock;
    PRNDIS_INITIALIZE_COMPLETE  pInitCompleteMessage;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame = NULL;
    PRNDISMP_MESSAGE_FRAME      pPendingMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext = NULL;
    RNDIS_REQUEST_ID            RequestId;
    ULONG                       PacketAlignmentFactor;
    NDIS_EVENT                  Event;
    BOOLEAN                     bWokenUp;
    BOOLEAN                     bLinkedAdapter;
    BOOLEAN                     bMicroportInitialized;

    TRACE2(("RndismpInitialize\n"));
    Adapter = NULL;
    Status = NDIS_STATUS_SUCCESS;
    bLinkedAdapter = FALSE;
    bMicroportInitialized = FALSE;

    do
    {
        // allocate the adapter object, exit if error occurs
        Status = MemAlloc(&Adapter, sizeof(RNDISMP_ADAPTER));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            TRACE2(("Adapter Allocate Memory failed (%08X)\n", Status));
            break;
        }

        // allocate space for list of driver-supported OIDs
        Status = MemAlloc(&Adapter->DriverOIDList,
                           RndismpSupportedOidsNum*sizeof(NDIS_OID));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }
            
        RNDISMP_MOVE_MEM(Adapter->DriverOIDList, RndismpSupportedOids, RndismpSupportedOidsNum*sizeof(NDIS_OID));

        Adapter->NumDriverOIDs = RndismpSupportedOidsNum;

        Adapter->MiniportAdapterHandle = MiniportAdapterHandle;

        InitializeListHead(&Adapter->PendingFrameList);
        Adapter->Initing = TRUE;
        Adapter->MacOptions = RNDIS_DRIVER_MAC_OPTIONS;
        Adapter->RequestId = 1;

#if THROTTLE_MESSAGES
        Adapter->HiWatPendedMessages = RNDISMP_PENDED_SEND_HIWAT;
        Adapter->LoWatPendedMessages = RNDISMP_PENDED_SEND_LOWAT;
        Adapter->CurPendedMessages = 0;
        Adapter->SendInProgress = FALSE;
        InitializeListHead(&Adapter->WaitingMessageList);
#endif
        InitializeListHead(&Adapter->PendingAtMicroportList);

        Adapter->IndicatingReceives = FALSE;
        InitializeListHead(&Adapter->PendingRcvMessageList);
        NdisInitializeTimer(&Adapter->IndicateTimer, IndicateTimeout, (PVOID)Adapter);

        Adapter->SendProcessInProgress = FALSE;
        InitializeListHead(&Adapter->PendingSendProcessList);
        NdisInitializeTimer(&Adapter->SendProcessTimer, SendProcessTimeout, (PVOID)Adapter);


        TRACE2(("Adapter structure pointer is (%08X)\n", Adapter));

        NdisAllocateSpinLock(&Adapter->Lock);

        // get PDO to pass to microport
        NdisMGetDeviceProperty(MiniportAdapterHandle,
                               &Pdo,
                               &Fdo,
                               &Ndo,
                               NULL,
                               NULL);

#if NEW_NDIS_API_IN_MILLENNIUM
        {
            NDIS_STRING        UnicodeString;
            Status = NdisMQueryAdapterInstanceName(&UnicodeString,
                                                   Adapter->MiniportAdapterHandle);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                TRACE1(("Init: NDIS returned len %d [%ws]\n",
                        UnicodeString.Length, UnicodeString.Buffer));
                NdisFreeString(UnicodeString);
            }
        }
#endif

        Adapter->pDeviceObject = Fdo;
        Adapter->pPhysDeviceObject = Pdo;

        Status = GetDeviceFriendlyName(Pdo,
                                       &Adapter->FriendlyNameAnsi,
                                       &Adapter->FriendlyNameUnicode);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            TRACE1(("Init: Pdo %x, Ndo %x: Adapter %x: [%s]\n",
                Pdo, Ndo, Adapter, Adapter->FriendlyNameAnsi.Buffer));
        }
        else
        {
            Status = NDIS_STATUS_SUCCESS;
        }

        // Determine the platform we are running on. Ideally we would
        // like to do this from DriverEntry, but the NDIS API isn't
        // available until MiniportInit time.
        {
            NDIS_STATUS                     NdisStatus;
            PNDIS_CONFIGURATION_PARAMETER   pParameter;
            NDIS_STRING                     VersionKey = NDIS_STRING_CONST("Environment");

            NdisReadConfiguration(
                &NdisStatus,
                &pParameter,
                ConfigurationHandle,
                &VersionKey,
                NdisParameterInteger);
           
            if ((NdisStatus == NDIS_STATUS_SUCCESS) &&
                ((pParameter->ParameterType == NdisParameterInteger) ||
                 (pParameter->ParameterType == NdisParameterHexInteger)))
            {
                Adapter->bRunningOnWin9x =
                    (pParameter->ParameterData.IntegerData == NdisEnvironmentWindows);

                TRACE1(("Init: Adapter %p, running on %s\n",
                        Adapter,
                        ((Adapter->bRunningOnWin9x)? "Win9X": "NT")));
            }
            else
            {
                TRACE1(("Init: ReadConfig: NdisStatus %x\n", NdisStatus));
#if DBG
                if (NdisStatus == NDIS_STATUS_SUCCESS)
                {
                    TRACE1(("Init: ReadConfig: parametertype %x\n",
                        pParameter->ParameterType));
                }
#endif // DBG
                Adapter->bRunningOnWin9x = TRUE;
            }
        }

        // find the driver block associated with this adapter
        DriverBlock = DeviceObjectToDriverBlock(&RndismpMiniportBlockListHead, Fdo);

        if (DriverBlock == NULL)
        {
            TRACE1(("Init: Can't find driver block for FDO %x!\n", Fdo));
            Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            break;
        }

        // save the associated driver block in the adapter
        Adapter->DriverBlock            = DriverBlock;

        Adapter->Signature              = ADAPTER_SIGNATURE;

        // get handlers passed in from microport
        Adapter->RmInitializeHandler    = DriverBlock->RmInitializeHandler;
        Adapter->RmInitCompleteNotifyHandler = DriverBlock->RmInitCompleteNotifyHandler;
        Adapter->RmHaltHandler          = DriverBlock->RmHaltHandler;
        Adapter->RmShutdownHandler      = DriverBlock->RmShutdownHandler;
        Adapter->RmSendMessageHandler   = DriverBlock->RmSendMessageHandler;
        Adapter->RmReturnMessageHandler = DriverBlock->RmReturnMessageHandler;

        // call microport initialize handler
        //
        // Microport returns context
        // Pass in Miniport context
        // Pass in NDIS adapter handle
        // Pass in NDIS configuration handle
        // Pass in PDO for this adapter
        Status = Adapter->RmInitializeHandler(&Adapter->MicroportAdapterContext,
                                              &Adapter->MaxReceiveSize,
                                              (NDIS_HANDLE) Adapter,
                                              (NDIS_HANDLE) MiniportAdapterHandle,
                                              (NDIS_HANDLE) ConfigurationHandle,
                                              Ndo);


        if (Status != NDIS_STATUS_SUCCESS)
        {
            TRACE2(("Microport initialize handler failed (%08X)\n", Status));
            break;
        }

        bMicroportInitialized = TRUE;

        // everything looks good, so finish up
        Status = AllocateTransportResources(Adapter);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_RESOURCES; 
            break;
        }

        // allocate space to receive a copy of the Initialize complete message in
        Status = MemAlloc(&Adapter->pInitCompleteMessage, sizeof(RNDIS_INITIALIZE_COMPLETE));
        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    

        // now we send down a RNDIS initialize message to the device
        pMsgFrame = BuildRndisMessageCommon(Adapter, 
                                            NULL,
                                            REMOTE_NDIS_INITIALIZE_MSG,
                                            0,
                                            (PVOID) NULL,
                                            0);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        RequestId = pMsgFrame->RequestId;

        pReqContext = AllocateRequestContext(Adapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pReqContext->pNdisRequest = NULL;

        NdisInitializeEvent(&Event);
        pReqContext->pEvent = &Event;

        pMsgFrame->pVc = NULL;
        pMsgFrame->pReqContext = pReqContext;

        RNDISMP_ASSERT_AT_PASSIVE();

        // Keep the message frame around until send-completion.
        ReferenceMsgFrame(pMsgFrame);

        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(Adapter, pMsgFrame, TRUE, CompleteSendInit);

        RNDISMP_ASSERT_AT_PASSIVE();
        // wait for message to complete
        bWokenUp = NdisWaitEvent(&Event, MINIPORT_INIT_TIMEOUT);

        // remove the message from the pending queue - it may or may not be there.
        RNDISMP_LOOKUP_PENDING_MESSAGE(pPendingMsgFrame, Adapter, RequestId);

        DereferenceMsgFrame(pMsgFrame);

        if (!bWokenUp)
        {
            // Failed to receive an Init complete within a reasonable time.
            TRACE1(("Init: Adapter %x, failed to receive Init complete\n", Adapter));
            Status = NDIS_STATUS_DEVICE_FAILED; 
            break;
        }

        //
        // the init complete message from the device is now
        // copied over to our local structure
        //
        pInitCompleteMessage = Adapter->pInitCompleteMessage;

        if (pInitCompleteMessage->Status != NDIS_STATUS_SUCCESS)
        {
            Status = pInitCompleteMessage->Status;
            break;
        }

        // make sure this is a supported device.
        if (!(pInitCompleteMessage->DeviceFlags & (RNDIS_DF_CONNECTIONLESS | RNDIS_DF_RAW_DATA)) ||
             (pInitCompleteMessage->Medium != RNdisMedium802_3))
        {
            TRACE1(("Init: Complete: unknown DeviceFlags %x or Medium %d\n",
                    pInitCompleteMessage->DeviceFlags,
                    pInitCompleteMessage->Medium));
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        if ((pInitCompleteMessage->DeviceFlags & RNDIS_DF_RAW_DATA)
            || (gRawEncap))
        {
            Adapter->MultipleSendFunc = DoMultipleSendRaw;
        } else
        {
            Adapter->MultipleSendFunc = DoMultipleSend;
        }

        Adapter->Medium = RNDIS_TO_NDIS_MEDIUM(pInitCompleteMessage->Medium);

        // get device parameters.
        Adapter->MaxPacketsPerMessage = pInitCompleteMessage->MaxPacketsPerMessage;
        if (Adapter->MaxPacketsPerMessage == 0)
        {
            Adapter->MaxPacketsPerMessage = 1;
        }

#if HACK
        if (Adapter->MaxPacketsPerMessage > 1)
        {
            Adapter->MaxPacketsPerMessage = 2;
        }
#endif // HACK

        Adapter->bMultiPacketSupported = (Adapter->MaxPacketsPerMessage > 1);

        Adapter->MaxTransferSize = pInitCompleteMessage->MaxTransferSize;

        PacketAlignmentFactor = pInitCompleteMessage->PacketAlignmentFactor;

        if (PacketAlignmentFactor > 7)
        {
            PacketAlignmentFactor = 7;
        }

        Adapter->AlignmentIncr = (1 << PacketAlignmentFactor);
        Adapter->AlignmentMask = ~((1 << PacketAlignmentFactor) - 1);

#if DBG
        DbgPrint("RNDISMP: InitComp: Adapter %x, Version %d.%d, MaxPkt %d, AlignIncr %d, AlignMask %x, MaxXferSize %d\n",
                Adapter,
                pInitCompleteMessage->MajorVersion,
                pInitCompleteMessage->MinorVersion,
                Adapter->MaxPacketsPerMessage,
                Adapter->AlignmentIncr,
                Adapter->AlignmentMask,
                Adapter->MaxTransferSize);
#endif // DBG

        // Get the medium type.
        for (Index = 0; Index < MediumArraySize; Index++)
        {
            if (MediumArray[Index] == Adapter->Medium)
            {
                break;
            }
        }

        if (Index == MediumArraySize)
        {
            TRACE1(("InitComp: Adapter %x, device returned unsupported medium %d\n",
                Adapter, pInitCompleteMessage->Medium));
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            break;
        }

        *SelectedMediumIndex = Index;

        Adapter->DeviceFlags = pInitCompleteMessage->DeviceFlags;

        // call NdisMSetAttributesEx in order to let NDIS know
        // what kind of driver and features we support

        // interface type
        IfType = NdisInterfaceInternal;

        if (Adapter->bRunningOnWin9x)
        {
            //
            //  NOTE! The 0x80000000 bit is set to let NDIS know
            //  (Millennium only!) that our reconfig handler should
            //  be called when the device is surprise-removed.
            //
            NdisMSetAttributesEx(Adapter->MiniportAdapterHandle,
                                (NDIS_HANDLE) Adapter,
                                4,
                                (ULONG) NDIS_ATTRIBUTE_DESERIALIZE | 0x80000000,
                                IfType);
        }
        else
        {
            ULONG       AttrFlags;

            AttrFlags = NDIS_ATTRIBUTE_DESERIALIZE |
                        NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK;

            if (Adapter->DeviceFlags & RNDIS_DF_CONNECTIONLESS)
            {
                AttrFlags |= NDIS_ATTRIBUTE_NOT_CO_NDIS;
            }

            NdisMSetAttributesEx(Adapter->MiniportAdapterHandle,
                                (NDIS_HANDLE) Adapter,
                                4,
                                AttrFlags,
                                IfType);
        }

        // Tell the microport that the device completed Init
        // successfully:
        if (Adapter->RmInitCompleteNotifyHandler)
        {
            Status = Adapter->RmInitCompleteNotifyHandler(
                                Adapter->MicroportAdapterContext,
                                Adapter->DeviceFlags,
                                &Adapter->MaxTransferSize);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        // get the list of supported OIDs from the device
        pMsgFrame = BuildRndisMessageCommon(Adapter, 
                                            NULL,
                                            REMOTE_NDIS_QUERY_MSG,
                                            OID_GEN_SUPPORTED_LIST,
                                            (PVOID) NULL,
                                            0);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // The message frame will be deref'ed once when we receive
        // a reply to the query, and once below, when this thread
        // is done with the frame. Make sure that it doesn't go away
        // until this thread is done with it.
        //
        ReferenceMsgFrame(pMsgFrame);

        // link us on to the list of adapters for this driver block
        AddAdapter(Adapter);
        bLinkedAdapter = TRUE;

        pReqContext->pNdisRequest = NULL;
        pReqContext->Oid = OID_GEN_SUPPORTED_LIST;
        pReqContext->CompletionStatus = NDIS_STATUS_SUCCESS;
        pReqContext->bInternal = TRUE;

        NdisInitializeEvent(&Event);
        pReqContext->pEvent = &Event;

        pMsgFrame->pVc = NULL;
        pMsgFrame->pReqContext = pReqContext;
        RequestId = pMsgFrame->RequestId;

        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(Adapter, pMsgFrame, TRUE, NULL);

        RNDISMP_ASSERT_AT_PASSIVE();
        bWokenUp = NdisWaitEvent(&Event, MINIPORT_INIT_TIMEOUT);

        // remove the message from the pending queue - it may or may not be there.
        RNDISMP_LOOKUP_PENDING_MESSAGE(pPendingMsgFrame, Adapter, RequestId);

        DereferenceMsgFrame(pMsgFrame);

        if (!bWokenUp || (Adapter->DriverOIDList == NULL))
        {
            // Failed to receive a response within a reasonable time,
            // or the device failed this query.
            //
            TRACE1(("Init: Adapter %x, failed to receive response to OID_GEN_SUPPORTED_LIST\n", Adapter));
            Status = NDIS_STATUS_DEVICE_FAILED; 
            ASSERT(FALSE);
            break;
        }

        // Successfully queried the supported OID list.

#ifdef BUILD_WIN9X
        //
        // Attempt to support surprise removal of this device (Win98/SE)
        // by intercepting config mgr messages forwarded by NDIS.
        //
        HookNtKernCMHandler(Adapter);
#endif // BUILD_WIN9X

        if (Adapter->bRunningOnWin9x)
        {
            //
            // Query and cache the values of certain OIDs that NDIS queries
            // us for, so that when we get those queries, we can complete
            // them immediately (synchronously). This is to work around
            // a problem where NDIS (98/SE only) times out too soon on
            // internally generated queries.
            //
            Status = SyncQueryDevice(Adapter,
                                     OID_GEN_MAXIMUM_FRAME_SIZE,
                                     (PUCHAR)&Adapter->MaximumFrameSize,
                                     sizeof(Adapter->MaximumFrameSize));

            if (Status != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("Init: Adapter %x, failed to query MAXIMUM_FRAME_SIZE\n", Adapter));
                Status = NDIS_STATUS_DEVICE_FAILED;
                break;
            }

            Status = SyncQueryDevice(Adapter,
                                     OID_GEN_MAC_OPTIONS,
                                     (PUCHAR)&Adapter->MacOptions,
                                     sizeof(Adapter->MacOptions));

            if (Status != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("Init: Adapter %x, failed to query MAC_OPTIONS\n", Adapter));
                Status = NDIS_STATUS_DEVICE_FAILED;
                break;
            }

            Status = SyncQueryDevice(Adapter,
                                     OID_802_3_MAXIMUM_LIST_SIZE,
                                     (PUCHAR)&Adapter->MaxMulticastListSize,
                                     sizeof(Adapter->MaxMulticastListSize));

            if (Status != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("Init: Adapter %x, failed to query MAX_LIST_SIZE\n", Adapter));
                Status = NDIS_STATUS_DEVICE_FAILED;
                break;
            }

            Status = SyncQueryDevice(Adapter,
                                     OID_802_3_CURRENT_ADDRESS,
                                     (PUCHAR)Adapter->MacAddress,
                                     ETH_LENGTH_OF_ADDRESS);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                TRACE1(("Init: Adapter %x, failed to query CURRENT_ADDR\n", Adapter));
                Status = NDIS_STATUS_DEVICE_FAILED;
                break;
            }

            TRACE1(("Init: Adapter %p, OID caching done!\n", Adapter));
        }

        // send any registry parameters down to the device, if it supports them.

        if (GetOIDSupport(Adapter, OID_GEN_RNDIS_CONFIG_PARAMETER) == DEVICE_SUPPORTED_OID)
        {
            Status = ReadAndSetRegistryParameters(Adapter, ConfigurationHandle);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        // register a shutdown handler
        NdisMRegisterAdapterShutdownHandler(Adapter->MiniportAdapterHandle,
                                            (PVOID) Adapter,
                                            RndismpShutdownHandler);

        Adapter->TimerCancelled = FALSE;

        Adapter->Initing = FALSE;

        // initialize "KeepAlive" timer
        NdisInitializeTimer(&Adapter->KeepAliveTimer,
                            KeepAliveTimerHandler,
                            (PVOID) Adapter);

        NdisSetTimer(&Adapter->KeepAliveTimer, KEEP_ALIVE_TIMER / 2);

        Status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (Adapter)
    {
        if (Adapter->pInitCompleteMessage)
        {
            MemFree(Adapter->pInitCompleteMessage, sizeof(*Adapter->pInitCompleteMessage));
        }
    }

    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("Failed to init adapter %x, status %x\n", Adapter, Status));

        if (bMicroportInitialized)
        {
            ASSERT(Adapter);

            Adapter->RmHaltHandler(Adapter->MicroportAdapterContext);
        }

        if (Adapter)
        {
            if (bLinkedAdapter)
            {
                RemoveAdapter(Adapter);
            }

            FreeAdapter(Adapter);
        }
    }
        
    return Status;
} // RndismpInitialize

/****************************************************************************/
/*                          RndisMSendComplete                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Called by microport to indicate a message miniport sent is completed    */
/*  by microport                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*  RndisMessageHandle - context used by miniport                           */
/*  SendStatus - indicate status of send message                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RndisMSendComplete(IN  NDIS_HANDLE     MiniportAdapterContext,
                   IN  NDIS_HANDLE     RndisMessageHandle,
                   IN  NDIS_STATUS     SendStatus)
{
    PRNDISMP_ADAPTER        Adapter;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;

    // get adapter context
    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(Adapter);

    pMsgFrame = MESSAGE_FRAME_FROM_HANDLE(RndisMessageHandle);

    CHECK_VALID_FRAME(pMsgFrame);

    ASSERT(pMsgFrame->pAdapter == Adapter);

    TRACE2(("RndisMSendComplete: Adapter %x, MsgFrame %x, MDL %x\n", Adapter, pMsgFrame, pMsgFrame->pMessageMdl));

    if ((SendStatus != NDIS_STATUS_SUCCESS) &&
        (SendStatus != NDIS_STATUS_RESOURCES))
    {
        RNDISMP_INCR_STAT(Adapter, MicroportSendError);
        TRACE0(("RndisMSendComplete: Adapter %x, MsgFrame %x, MDL %x, ERROR %x\n",
                    Adapter,
                    pMsgFrame,
                    pMsgFrame->pMessageMdl,
                    SendStatus));
    }

#if THROTTLE_MESSAGES
    RNDISMP_ACQUIRE_ADAPTER_LOCK(Adapter);

    Adapter->CurPendedMessages--;
    RemoveEntryList(&pMsgFrame->PendLink);

    if (SendStatus == NDIS_STATUS_RESOURCES)
    {
        RNDISMP_INCR_STAT(Adapter, SendMsgLowRes);
    }

    if ((SendStatus != NDIS_STATUS_RESOURCES) ||
        (Adapter->CurPendedMessages < 2))
    {
        if (Adapter->CurPendedMessages == Adapter->LoWatPendedMessages)
        {
            RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
            QueueMessageToMicroport(Adapter, NULL, FALSE);
        }
        else
        {
            RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
        }

        if (SendStatus == NDIS_STATUS_RESOURCES)
        {
            TRACE1(("RndisMSendComplete: Adapter %x, got resources\n", Adapter));
            SendStatus = NDIS_STATUS_SUCCESS;
        }

        if (pMsgFrame->pCallback)
        {
            (*pMsgFrame->pCallback)(pMsgFrame, SendStatus);
        }
        else
        {
            //
            //  Do nothing. The sender will take care of freeing
            //  this.
            //
        }
    }
    else
    {
        //
        //  The microport is out of send resources. Requeue this
        //  and adjust water marks.
        //
        InsertHeadList(&Adapter->WaitingMessageList, &pMsgFrame->PendLink);

        Adapter->HiWatPendedMessages = Adapter->CurPendedMessages;
        Adapter->LoWatPendedMessages = Adapter->CurPendedMessages / 2;

        TRACE1(("RndisMSendComplete: Adapter %x, new Hiwat %d, Lowat %d\n",
                Adapter, Adapter->HiWatPendedMessages, Adapter->LoWatPendedMessages));
        RNDISMP_RELEASE_ADAPTER_LOCK(Adapter);
    }
#else
    if (pMsgFrame->pCallback)
    {
        (*pMsgFrame->pCallback)(pMsgFrame, SendStatus);
    }
    else
    {
        //
        //  Do nothing. The sender will take care of freeing
        //  this.
        //
    }
#endif // THROTTLE_MESSAGES

} // RndisMSendComplete

/****************************************************************************/
/*                          InitCompletionMessage                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion message from microport in response to init message miniport  */
/*  sent. The init message was sent  from the adapter init routine which is */
/*  waiting for this event to unblock                                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  pMessage - Pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL received from microport                           */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from micorport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
InitCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDIS_MESSAGE     pMessage,
                      IN PMDL               pMdl,
                      IN ULONG              TotalLength,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN NDIS_STATUS        ReceiveStatus,
                      IN BOOLEAN            bMessageCopied)
{
    PRNDIS_INITIALIZE_COMPLETE  pInitCompleteMessage;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    PRNDISMP_REQUEST_CONTEXT    pReqContext;
    BOOLEAN                     bDiscardMsg = TRUE;

    TRACE2(("InitCompletionMessage\n"));

    do
    {
        if (pMessage->MessageLength < RNDISMP_MIN_MESSAGE_LENGTH(InitializeComplete))
        {
            TRACE1(("InitCompletion: Message length (%d) too short, expect at least (%d)\n",
                    pMessage->MessageLength,
                    RNDISMP_MIN_MESSAGE_LENGTH(InitializeComplete)));
            break;
        }

        if (pAdapter->pInitCompleteMessage == NULL)
        {
            TRACE1(("InitCompletion: multiple InitComplete from device, ignored\n"));
            break;
        }

        pInitCompleteMessage = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

        // get request frame from request ID in message
        RNDISMP_LOOKUP_PENDING_MESSAGE(pMsgFrame, pAdapter, pInitCompleteMessage->RequestId);

        if (pMsgFrame == NULL)
        {
            // invalid request ID or aborted request.
            TRACE1(("Invalid request ID %d in Init Complete\n",
                    pInitCompleteMessage->RequestId));
            break;
        }

        pReqContext = pMsgFrame->pReqContext;

        RNDISMP_MOVE_MEM(pAdapter->pInitCompleteMessage,
                         pInitCompleteMessage,
                         sizeof(*pInitCompleteMessage));

        // signal the adapter init routine we are done
        NdisSetEvent(pReqContext->pEvent);

    }
    while (FALSE);

    return (bDiscardMsg);

} // InitCompletionMessage

/****************************************************************************/
/*                               HaltMessage                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a HALT message from the device.                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
HaltMessage(IN PRNDISMP_ADAPTER   pAdapter,
            IN PRNDIS_MESSAGE     pMessage,
            IN PMDL               pMdl,
            IN ULONG              TotalLength,
            IN NDIS_HANDLE        MicroportMessageContext,
            IN NDIS_STATUS        ReceiveStatus,
            IN BOOLEAN            bMessageCopied)
{
    TRACE1(("HaltMessage: Adapter %x\n", pAdapter));

#ifndef BUILD_WIN9X
	// Not supported on Win98 Gold:
    NdisMRemoveMiniport(pAdapter->MiniportAdapterHandle);
#endif

    return TRUE;

} // HaltMessage

/****************************************************************************/
/*                          ResetCompletionMessage                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion message from microport in response to reset message miniport */
/*  sent. Indicate this completion message to the upper layers since        */
/*  the miniport reset routine indicated STATUS_PENDING to the upper layers */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
ResetCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                       IN PRNDIS_MESSAGE     pMessage,
                       IN PMDL               pMdl,
                       IN ULONG              TotalLength,
                       IN NDIS_HANDLE        MicroportMessageContext,
                       IN NDIS_STATUS        ReceiveStatus,
                       IN BOOLEAN            bMessageCopied)
{
    PRNDIS_RESET_COMPLETE   pResetMessage;
    BOOLEAN                 AddressingReset;
    NDIS_STATUS             Status;
    
    TRACE2(("ResetCompletionMessage\n"));

    pResetMessage = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

    // save these parameters to call to upper layers
    Status = pResetMessage->Status;
    AddressingReset = (BOOLEAN)pResetMessage->AddressingReset;

    CompleteMiniportReset(pAdapter, Status, AddressingReset);

    return TRUE;

} // ResetCompletionMessage


/****************************************************************************/
/*                          KeepAliveCompletionMessage                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Completion message for a keep alive request send down by miniport       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
KeepAliveCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                           IN PRNDIS_MESSAGE     pMessage,
                           IN PMDL               pMdl,
                           IN ULONG              TotalLength,
                           IN NDIS_HANDLE        MicroportMessageContext,
                           IN NDIS_STATUS        ReceiveStatus,
                           IN BOOLEAN            bMessageCopied)
{
    PRNDIS_KEEPALIVE_COMPLETE   pKeepaliveComplete;
    NDIS_STATUS                 Status;

    pKeepaliveComplete = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

    // save off status
    Status = pKeepaliveComplete->Status;

    TRACE2(("KeepAliveCompletionMessage (%d) on adapter %p\n", 
                pKeepaliveComplete->RequestId, pAdapter));

    // grab the spinlock
    NdisAcquireSpinLock(&pAdapter->Lock);

    if (pKeepaliveComplete->RequestId != pAdapter->KeepAliveMessagePendingId)
    {
        TRACE0(("KeepAliveCompletion: Adapter %x, expected ID %x, got %x\n",
                pAdapter,
                pAdapter->KeepAliveMessagePendingId,
                pKeepaliveComplete->RequestId));
        //
        // TBD - should we set NeedReset?
    }

    pAdapter->KeepAliveMessagePending = FALSE;

    // if there are problems, tell the check for hang handler we need a reset
    if (Status != NDIS_STATUS_SUCCESS)
    {
        TRACE0(("KeepAliveCompletion: Adapter %x, err status %x from device\n",
                   pAdapter, Status));

        // indicate later from check for hang handler
        pAdapter->NeedReset = TRUE;
    }

    // release spinlock
    NdisReleaseSpinLock(&pAdapter->Lock);

    return TRUE;

} // KeepAliveCompletionMessage


/****************************************************************************/
/*                          KeepAliveMessage                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Process a keepalive message sent by the device. Send back a completion. */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our Adapter structure                             */
/*  pMessage - pointer to RNDIS message                                     */
/*  pMdl - Pointer to MDL from microport                                    */
/*  TotalLength - length of complete message                                */
/*  MicroportMessageContext - context for message from microport            */
/*  ReceiveStatus - used by microport to indicate it is low on resource     */
/*  bMessageCopied - is this a copy of the original message?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  BOOLEAN - should the message be returned to the microport?              */
/*                                                                          */
/****************************************************************************/
BOOLEAN
KeepAliveMessage(IN PRNDISMP_ADAPTER   pAdapter,
                 IN PRNDIS_MESSAGE     pMessage,
                 IN PMDL               pMdl,
                 IN ULONG              TotalLength,
                 IN NDIS_HANDLE        MicroportMessageContext,
                 IN NDIS_STATUS        ReceiveStatus,
                 IN BOOLEAN            bMessageCopied)
{
    PRNDIS_KEEPALIVE_REQUEST    pKeepalive;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;

    TRACE2(("KeepAliveMessage\n"));

    pKeepalive = RNDIS_MESSAGE_PTR_TO_MESSAGE_PTR(pMessage);

    //
    //  Send a response if we can.
    //
    pMsgFrame = BuildRndisMessageCommon(pAdapter,
                                        NULL,
                                        REMOTE_NDIS_KEEPALIVE_CMPLT,
                                        0,
                                        &pKeepalive->RequestId,
                                        sizeof(pKeepalive->RequestId));
    if (pMsgFrame != NULL)
    {
        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, FALSE, NULL);
    }
    else
    {
        TRACE1(("KeepAlive: Adapter %x: failed to alloc response!\n", pAdapter));
    }

    return TRUE;

} // KeepAliveMessage
                      

/****************************************************************************/
/*                          RndismpShutdownHandler                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Removes an adapter instance that was previously initialized. Since the  */
/*  system is shutting down there is no need to release resources, just     */
/*  shutdown receive.                                                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RndismpShutdownHandler(IN NDIS_HANDLE MiniportAdapterContext)
{
    PRNDISMP_ADAPTER            Adapter;

    // get adapter context
    Adapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    TRACE1(("RndismpShutdownHandler\n"));
} // RndismpShutdownHandler


//
// Interrupt routines, stubbed up for now, we don't need them
//

/****************************************************************************/
/*                          RndismpDisableInterrupt                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpDisableInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{

    // NOP

} // RndismpDisableInterrupt


/****************************************************************************/
/*                          RndismpEnableInterrupt                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpEnableInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{

    // NOP

} // RndismpEnableInterrupt

/****************************************************************************/
/*                          RndismpHandleInterrupt                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  MiniportAdapterContext - a context version of our Adapter pointer       */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpHandleInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{

    // NOP

} // RndismpHandleInterrupt

/****************************************************************************/
/*                          RndismpIsr                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  This is the interrupt handler which is registered with the operating    */
/*  system. If several are pending (i.e. transmit complete and receive),    */
/*  handle them all.  Block new interrupts until all pending interrupts     */
/*  are handled.                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  InterruptRecognized - Boolean value which returns TRUE if the           */
/*      ISR recognizes the interrupt as coming from this adapter.           */
/*                                                                          */
/*  QueueDpc - TRUE if a DPC should be queued.                              */
/*                                                                          */
/*  Context - pointer to the adapter object                                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
RndismpIsr(OUT PBOOLEAN InterruptRecognized,
           OUT PBOOLEAN QueueDpc,
           IN  PVOID    Context)
{

    ASSERT(FALSE); // don't expect to be called here.

} // RndismpIsr

/****************************************************************************/
/*                          CompleteSendInit                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility function to handle completion of sending of an INIT message.    */
/*  We simply free up the message frame.                                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Frame structure describing the INIT message                 */
/*  SendStatus - outcome of sending this message.                           */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendInit(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN NDIS_STATUS SendStatus)
{
    PRNDISMP_ADAPTER        pAdapter;

    pAdapter = pMsgFrame->pAdapter;

    TRACE1(("CompleteSendInit: Adapter %x, SendStatus %x\n", pAdapter, SendStatus));

    DereferenceMsgFrame(pMsgFrame);

} // CompleteSendInit

/****************************************************************************/
/*                          CompleteSendHalt                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility function to handle completion of sending of a HALT message.     */
/*  We simply wake up the thread waiting for this.                          */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Frame structure describing the HALT message                 */
/*  SendStatus - outcome of sending this message.                           */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendHalt(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN NDIS_STATUS SendStatus)
{
    PRNDISMP_ADAPTER        pAdapter;

    pAdapter = pMsgFrame->pAdapter;

    TRACE1(("CompleteSendHalt: Adapter %x, SendStatus %x\n", pAdapter, SendStatus));

    ASSERT(pAdapter->Halting);

    DereferenceMsgFrame(pMsgFrame);

    NdisSetEvent(&pAdapter->HaltWaitEvent);
} // CompleteSendHalt


/****************************************************************************/
/*                          CompleteSendReset                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine to handle send-completion of a reset message by the    */
/*  microport.                                                              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame for the Reset.                     */
/*  SendStatus - Status of send                                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendReset(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                  IN NDIS_STATUS SendStatus)
{
    PRNDISMP_ADAPTER        pAdapter;

    pAdapter = pMsgFrame->pAdapter;

    TRACE1(("CompleteSendReset: Adapter %x, SendStatus %x\n",
            pAdapter, SendStatus));

    DereferenceMsgFrame(pMsgFrame);

    if (SendStatus != NDIS_STATUS_SUCCESS)
    {
        CompleteMiniportReset(pAdapter, SendStatus, FALSE);
    }
}


/****************************************************************************/
/*                          CompleteMiniportReset                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Utility function to complete a pending NDIS Reset. We complete any      */
/*  pending requests/sets before indicating reset complete to NDIS.         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to our adapter structure                             */
/*  ResetStatus - to be used for completing reset                           */
/*  AddressingReset - Do we need filters to be resent to us?                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   VOID                                                                   */
/*                                                                          */
/****************************************************************************/
VOID
CompleteMiniportReset(IN PRNDISMP_ADAPTER pAdapter,
                      IN NDIS_STATUS ResetStatus,
                      IN BOOLEAN AddressingReset)
{
    LIST_ENTRY              PendingRequests;
    PLIST_ENTRY             pEntry, pNext;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;

    do
    {
        if (!pAdapter->ResetPending)
        {
            break;
        }

        pAdapter->ResetPending = FALSE;
        
        //
        //  Take out all pending requests/sets queued on the adapter.
        //
        InitializeListHead(&PendingRequests);

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

        for (pEntry = pAdapter->PendingFrameList.Flink;
             pEntry != &pAdapter->PendingFrameList;
             pEntry = pNext)
        {
            pNext = pEntry->Flink;
            pMsgFrame = CONTAINING_RECORD(pEntry, RNDISMP_MESSAGE_FRAME, Link);
            if (pMsgFrame->NdisMessageType == REMOTE_NDIS_QUERY_MSG ||
                pMsgFrame->NdisMessageType == REMOTE_NDIS_SET_MSG)
            {
                RemoveEntryList(pEntry);
                InsertTailList(&PendingRequests, pEntry);

                TRACE0(("RNDISMP: ResetComplete: taking out MsgFrame %x, msg type %x\n",
                        pMsgFrame, pMsgFrame->NdisMessageType));

            }
        }

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

        //
        //  Complete all these requests.
        //
        for (pEntry = PendingRequests.Flink;
             pEntry != &PendingRequests;
             pEntry = pNext)
        {
            pNext = pEntry->Flink;
            pMsgFrame = CONTAINING_RECORD(pEntry, RNDISMP_MESSAGE_FRAME, Link);

            TRACE0(("RNDISMP: ResetComplete: completing MsgFrame %x, msg type %x\n",
                    pMsgFrame, pMsgFrame->NdisMessageType));

            ASSERT(pMsgFrame->pReqContext != NULL);

            if (pMsgFrame->pReqContext->pNdisRequest != NULL)
            {
                //
                //  This request came down thru our MiniportCoRequest handler.
                //
                NdisMCoRequestComplete(NDIS_STATUS_REQUEST_ABORTED,
                                       pAdapter->MiniportAdapterHandle,
                                       pMsgFrame->pReqContext->pNdisRequest);
            }
            else
            {
                //
                //  This request came thru our connectionless query/set handler.
                //
                if (pMsgFrame->NdisMessageType == REMOTE_NDIS_QUERY_MSG)
                {
                    NdisMQueryInformationComplete(pAdapter->MiniportAdapterHandle,
                                                  NDIS_STATUS_REQUEST_ABORTED);
                }
                else
                {
                    ASSERT(pMsgFrame->NdisMessageType == REMOTE_NDIS_SET_MSG);
                    NdisMSetInformationComplete(pAdapter->MiniportAdapterHandle,
                                                NDIS_STATUS_REQUEST_ABORTED);
                }
            }

            FreeRequestContext(pAdapter, pMsgFrame->pReqContext);
            pMsgFrame->pReqContext = (PRNDISMP_REQUEST_CONTEXT)UlongToPtr(0xabababab);
            DereferenceMsgFrame(pMsgFrame);
        }

        TRACE0(("Completing reset on Adapter %x, Status %x, AddressingReset %d\n",
                    pAdapter, ResetStatus, AddressingReset));

        RNDISMP_INCR_STAT(pAdapter, Resets);

        //
        //  Complete the reset now.
        //
        NdisMResetComplete(pAdapter->MiniportAdapterHandle,
                           ResetStatus,
                           AddressingReset);
    }
    while (FALSE);
}



/****************************************************************************/
/*                     ReadAndSetRegistryParameters                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  This is called when initializing a device, to read and send any         */
/*  registry parameters applicable to this device.                          */
/*                                                                          */
/*  We go through the entire list of configurable parameters by walking     */
/*  subkeys under the "ndi\Params" key. Each subkey represents one          */
/*  parameter. Using information about this parameter (specifically, its    */
/*  name and type), we query its value, and send a SetRequest to the        */
/*  device.                                                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to adapter structure for the device                  */
/*  ConfigurationContext - NDIS handle to access registry for this device   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
ReadAndSetRegistryParameters(IN PRNDISMP_ADAPTER pAdapter,
                             IN NDIS_HANDLE ConfigurationContext)
{
    NDIS_STATUS                 Status;
    NDIS_HANDLE                 ConfigHandle;
    NDIS_STRING                 NdiKeyName = NDIS_STRING_CONST("Ndi");
    NDIS_HANDLE                 NdiKeyHandle = NULL;

    Status = NDIS_STATUS_SUCCESS;
    ConfigHandle = NULL;

    do
    {
        NdisOpenConfiguration(&Status,
                              &ConfigHandle,
                              ConfigurationContext);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        NdisOpenConfigurationKeyByName(
            &Status,
            ConfigHandle,
            &NdiKeyName,
            &NdiKeyHandle);
        
        if (Status == NDIS_STATUS_SUCCESS)
        {
            NDIS_STRING     ParamsKeyName = NDIS_STRING_CONST("Params");
            NDIS_HANDLE     ParamsKeyHandle = NULL;

            NdisOpenConfigurationKeyByName(
                &Status,
                NdiKeyHandle,
                &ParamsKeyName,
                &ParamsKeyHandle);
            
            if (Status == NDIS_STATUS_SUCCESS)
            {
                ULONG   i;
                BOOLEAN bDone = FALSE;

                //
                //  Iterate through all subkeys under ndi\Params:
                //
                for (i = 0; !bDone; i++)
                {
                    NDIS_STRING     ParamSubKeyName;
                    NDIS_HANDLE     ParamSubKeyHandle;
                    NDIS_STRING     ParamTypeName = NDIS_STRING_CONST("type");
                    PNDIS_CONFIGURATION_PARAMETER    pConfigParameter;

                    ParamSubKeyName.Length =
                    ParamSubKeyName.MaximumLength = 0;
                    ParamSubKeyName.Buffer = NULL;

                    NdisOpenConfigurationKeyByIndex(
                        &Status,
                        ParamsKeyHandle,
                        i,
                        &ParamSubKeyName,
                        &ParamSubKeyHandle);
                   
                    if (Status != NDIS_STATUS_SUCCESS)
                    {
                        //
                        //  Done with parameters. Cook return value.
                        //
                        Status = NDIS_STATUS_SUCCESS;
                        break;
                    }

                    //
                    //  Got the handle to a subkey under ndi\Params,
                    //  now read the type information for this parameter.
                    //

#ifndef BUILD_WIN9X
                    TRACE3(("ReadAndSetRegParams: subkey %d under ndi\\params: %ws\n",
                        i, ParamSubKeyName.Buffer));
#else
                    //
                    //  Handle Win98Gold behavior.
                    //
                    if (ParamSubKeyName.Buffer == NULL)
                    {
                        PNDIS_STRING    pNdisString;

                        pNdisString = *(PNDIS_STRING *)&ParamSubKeyName;
                        ParamSubKeyName = *pNdisString;
                    }

                    TRACE2(("ReadAndSetRegParams: subkey %d under ndi\\params: %ws\n",
                        i, ParamSubKeyName.Buffer));
#endif

                    //
                    //  We have a parameter name now, in ParamSubKeyName.
                    //  Get its type information.
                    //
                    NdisReadConfiguration(
                        &Status,
                        &pConfigParameter,
                        ParamSubKeyHandle,
                        &ParamTypeName,
                        NdisParameterString);
                    
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        TRACE2(("ReadAndSetRegParams: Adapter %p, type is %ws\n",
                            pAdapter,
                            pConfigParameter->ParameterData.StringData.Buffer));

                        //
                        //  Send off a Set Request for this
                        //  parameter to the device.
                        //

                        Status = SendConfiguredParameter(
                                        pAdapter,
                                        ConfigHandle,
                                        &ParamSubKeyName,
                                        &pConfigParameter->ParameterData.StringData);

                        if (Status != NDIS_STATUS_SUCCESS)
                        {
                            TRACE0(("ReadAndSetRegParams: Adapter %p, failed %x\n",
                                pAdapter, Status));
                            bDone = TRUE;
                        }
                        else
                        {
                            NDIS_STRING     NetworkAddressName =
                                        NDIS_STRING_CONST("NetworkAddress");

                            //
                            //  Special case for the "NetworkAddress"
                            //  parameter - if we just set this successfully,
                            //  make note of the fact.
                            //
                            if (NdisEqualString(&ParamSubKeyName,
                                                &NetworkAddressName,
                                                TRUE))
                            {
                                TRACE1(("ReadAndSetRegParams: Adapter %p,"
                                        " supports MAC address overwrite\n",
                                        pAdapter));

                                pAdapter->MacOptions |=
                                    NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE;
                            }
                        }
    
                    }

                    //
                    //  Done with this subkey under ndi\Params.
                    //
                    NdisCloseConfiguration(ParamSubKeyHandle);

                } // for each subkey under ndi\Params

                //
                //  Done with "ndi\Params"
                //
                NdisCloseConfiguration(ParamsKeyHandle);
            }

            //
            //  Done with "ndi"
            //
            NdisCloseConfiguration(NdiKeyHandle);
        }

        //
        //  Done with configuration section for this device.
        //
        NdisCloseConfiguration(ConfigHandle);
    }
    while (FALSE);
   
    return (Status);
}


/****************************************************************************/
/*                     SendConfiguredParameter                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Read the value of the specified config parameter, format a SetRequest,  */
/*  send it to the device, and wait for a response.                         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to adapter structure for the device                  */
/*  ConfigHandle - handle to configuration section for this device          */
/*  pParameterName - parameter key name                                     */
/*  pParameterType - parameter type                                         */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*   NDIS_STATUS                                                            */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
SendConfiguredParameter(IN PRNDISMP_ADAPTER     pAdapter,
                        IN NDIS_HANDLE          ConfigHandle,
                        IN PNDIS_STRING         pParameterName,
                        IN PNDIS_STRING         pParameterType)
{
    PRNDISMP_MESSAGE_FRAME          pMsgFrame = NULL;
    PRNDISMP_MESSAGE_FRAME          pPendingMsgFrame = NULL;
    PRNDISMP_REQUEST_CONTEXT        pReqContext = NULL;
    NDIS_PARAMETER_TYPE             NdisParameterType;
    PNDIS_CONFIGURATION_PARAMETER   pConfigParameter;
    ULONG                           ParameterValueLength;
    PUCHAR                          pParameterValue;
    UINT32                          ParameterType;
    NDIS_EVENT                      Event;
    UINT                            BytesRead;
    BOOLEAN                         bWokenUp;
    RNDIS_REQUEST_ID                RequestId;

    PRNDIS_CONFIG_PARAMETER_INFO    pRndisConfigInfo = NULL;
    ULONG                           RndisConfigInfoLength;
    PUCHAR                          pConfigInfoBuf;
    NDIS_STATUS                     Status;

    struct {
        NDIS_STRING         TypeName;
        NDIS_PARAMETER_TYPE NdisType;
    } StringToNdisType[] =
        {
            {NDIS_STRING_CONST("int"), NdisParameterInteger},
            {NDIS_STRING_CONST("long"), NdisParameterInteger},
            {NDIS_STRING_CONST("word"), NdisParameterInteger},
            {NDIS_STRING_CONST("dword"), NdisParameterInteger},
            {NDIS_STRING_CONST("edit"), NdisParameterString},
            {NDIS_STRING_CONST("enum"), NdisParameterString}
        };

    ULONG                       NumTypes = sizeof(StringToNdisType);
    ULONG                       i;

    do
    {
        //
        //  Determine the parameter type.
        //
        for (i = 0; i < NumTypes; i++)
        {
            if (NdisEqualString(&StringToNdisType[i].TypeName,
                                pParameterType,
                                TRUE))
            {
                NdisParameterType = StringToNdisType[i].NdisType;
                break;
            }
        }

        if (i == NumTypes)
        {
            TRACE1(("SendConfiguredParam: Adapter %p, Param %ws, invalid type %ws\n",
                pAdapter,
                pParameterName->Buffer,
                pParameterType->Buffer));
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        NdisReadConfiguration(
            &Status,
            &pConfigParameter,
            ConfigHandle,
            pParameterName,
            NdisParameterType
            );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            //
            //  It is okay for a parameter to not be configured.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        if (NdisParameterType == NdisParameterInteger)
        {
            ParameterValueLength = sizeof(UINT32);
            pParameterValue = (PUCHAR)&pConfigParameter->ParameterData.IntegerData;
            ParameterType = RNDIS_CONFIG_PARAM_TYPE_INTEGER;
        }
        else
        {
            ASSERT(NdisParameterType == NdisParameterString);
            ParameterValueLength = pConfigParameter->ParameterData.StringData.Length;
            pParameterValue = (PUCHAR)pConfigParameter->ParameterData.StringData.Buffer;
            ParameterType = RNDIS_CONFIG_PARAM_TYPE_STRING;
        }

        RndisConfigInfoLength = sizeof(RNDIS_CONFIG_PARAMETER_INFO) +
                                pParameterName->Length +
                                ParameterValueLength;

        Status = MemAlloc(&pRndisConfigInfo, RndisConfigInfoLength);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pRndisConfigInfo->ParameterNameOffset = sizeof(RNDIS_CONFIG_PARAMETER_INFO);
        pRndisConfigInfo->ParameterNameLength = pParameterName->Length;
        pRndisConfigInfo->ParameterType = ParameterType;
        pRndisConfigInfo->ParameterValueOffset =
                    pRndisConfigInfo->ParameterNameOffset +
                    pRndisConfigInfo->ParameterNameLength;
        pRndisConfigInfo->ParameterValueLength = ParameterValueLength;

        //
        //  Copy in the parameter name.
        //
        pConfigInfoBuf = (PUCHAR)pRndisConfigInfo +
                          pRndisConfigInfo->ParameterNameOffset;
        
        RNDISMP_MOVE_MEM(pConfigInfoBuf, pParameterName->Buffer, pParameterName->Length);

        //
        //  Copy in the parameter value.
        //
        pConfigInfoBuf = (PUCHAR)pRndisConfigInfo +
                          pRndisConfigInfo->ParameterValueOffset;
        RNDISMP_MOVE_MEM(pConfigInfoBuf, pParameterValue, ParameterValueLength);

        //
        //  Build a Set Request
        //
        pMsgFrame = BuildRndisMessageCommon(pAdapter,
                                            NULL,
                                            REMOTE_NDIS_SET_MSG,
                                            OID_GEN_RNDIS_CONFIG_PARAMETER,
                                            pRndisConfigInfo,
                                            RndisConfigInfoLength);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

#if DBG
        {
            PMDL    pTmpMdl = pMsgFrame->pMessageMdl;
            ULONG   Length;
            PUCHAR  pBuf;
            ULONG   OldDebugFlags = RndismpDebugFlags;

            Length = RNDISMP_GET_MDL_LENGTH(pTmpMdl);
            pBuf = RNDISMP_GET_MDL_ADDRESS(pTmpMdl);

            if (pBuf != NULL)
            {
                RndismpDebugFlags |= DBG_DUMP;
                TRACEDUMP(("SetRequest (OID_GEN_RNDIS_CONFIG_PARAMETER):"
                    " Adapter %p, Param %ws\n", pAdapter, pParameterName->Buffer), pBuf, Length);
            }

            RndismpDebugFlags = OldDebugFlags;
        }
#endif

        pReqContext = AllocateRequestContext(pAdapter);
        if (pReqContext == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        // Fill up the request context.

        pReqContext->pNdisRequest = NULL;
        pReqContext->Oid = OID_GEN_RNDIS_CONFIG_PARAMETER;

        NdisInitializeEvent(&Event);
        pReqContext->pEvent = &Event;
        pReqContext->bInternal = TRUE;
        pReqContext->pBytesRead = &BytesRead;
        pReqContext->InformationBufferLength = RndisConfigInfoLength;

        pMsgFrame->pVc = NULL;
        pMsgFrame->pReqContext = pReqContext;

        // save off the request Id.
        RequestId = pMsgFrame->RequestId;

        // send the message to the microport.
        RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, TRUE, NULL);

        RNDISMP_ASSERT_AT_PASSIVE();
        bWokenUp = NdisWaitEvent(&Event, MINIPORT_INIT_TIMEOUT);

        // remove the message from the pending queue - it may or may not be there.
        RNDISMP_LOOKUP_PENDING_MESSAGE(pPendingMsgFrame, pAdapter, RequestId);


        if (!bWokenUp)
        {
            TRACE1(("No response to set parameter, Adapter %x\n", pAdapter));
            Status = NDIS_STATUS_DEVICE_FAILED; 
        }
        else
        {
            Status = pReqContext->CompletionStatus;
            TRACE1(("Got response to set config param, Status %x, %d bytes read\n",
                        Status, BytesRead));
        }

    }
    while (FALSE);

    if (pRndisConfigInfo)
    {
        MemFree(pRndisConfigInfo, RndisConfigInfoLength);
    }

    if (pMsgFrame)
    {
        DereferenceMsgFrame(pMsgFrame);
    }

    if (pReqContext)
    {
        FreeRequestContext(pAdapter, pReqContext);
    }

    return (Status);
}


#ifdef NDIS51_MINIPORT
/****************************************************************************/
/*                          RndismpPnPEventNotify                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Entry point called by NDIS to notify us of PnP events affecting our     */
/*  device. The main event of importance to us is surprise removal.         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Pointer to adapter structure                                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  NDIS_STATUS                                                             */
/*                                                                          */
/****************************************************************************/
VOID
RndismpPnPEventNotify(IN NDIS_HANDLE MiniportAdapterContext,
                      IN NDIS_DEVICE_PNP_EVENT EventCode,
                      IN PVOID InformationBuffer,
                      IN ULONG InformationBufferLength)
{
    PRNDISMP_ADAPTER        pAdapter;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    CHECK_VALID_ADAPTER(pAdapter);

    TRACE3(("PnPEventNotify: Adapter %x\n", pAdapter));


    switch (EventCode)
    {
        case NdisDevicePnPEventSurpriseRemoved:
            TRACE1(("PnPEventNotify: Adapter %p, surprise remove\n", pAdapter));
            RndismpInternalHalt(pAdapter, FALSE);
            break;

        default:
            break;
    }

} // RndismpPnPEventNotify

#endif // NDIS51_MINIPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\sys\makefile.inc ===
clean: 
    del $(O)\rmdat.h $(O)\rndismp.bmf

$(O)\rndismp.mof: ..\rndismp.mof

$(O)\rmdat.h: $(O)\rndismp.bmf
    wmimofck -h$(O)\rmdat.h $(O)\rndismp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\util.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    UTIL.C

Abstract:

    Utility routines for Remote NDIS Miniport driver

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/17/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"


ULONG   MsgFrameAllocs = 0;

/****************************************************************************/
/*                          MemAlloc                                        */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate memory                                                         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Buffer - pointer to buffer pointer                                      */
/*  Length - length of buffer to allocate                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
MemAlloc(OUT PVOID *Buffer, IN UINT Length)
{
    NDIS_STATUS Status;

    TRACE3(("MemAlloc\n"));
    ASSERT(Length != 0);

    Status = NdisAllocateMemoryWithTag(Buffer, 
                                       Length,
                                       RNDISMP_TAG_GEN_ALLOC);

    // zero out allocation
    if(Status == NDIS_STATUS_SUCCESS)
        NdisZeroMemory(*Buffer, Length);

    return Status;
} // MemAlloc

/****************************************************************************/
/*                          MemFree                                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free memory                                                             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Buffer - pointer to buffer                                              */
/*  Length - length of buffer to allocate                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
MemFree(IN PVOID Buffer, IN UINT Length)
{
    TRACE3(("MemFree\n"));

    NdisFreeMemory(Buffer, Length, 0);
} // MemFree


/****************************************************************************/
/*                          AddAdapter                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Add an adapter to the list of adapters associated with this driver      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Adapter object, contains pointer to associated driver block  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
AddAdapter(IN PRNDISMP_ADAPTER pAdapter)
{
    PDRIVER_BLOCK   DriverBlock = pAdapter->DriverBlock;

    TRACE3(("AddpAdapter\n"));

    CHECK_VALID_ADAPTER(pAdapter);

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    pAdapter->NextAdapter        = DriverBlock->AdapterList;
    DriverBlock->AdapterList    = pAdapter;

    // keep track of number of adapters associated with this driver block
    DriverBlock->NumberAdapters++;

    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

} // AddAdapter


/****************************************************************************/
/*                          RemoveAdapter                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Remove an adapter from the list of adapters associated with this driver */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Adapter object, contains pointer to associated driver block  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RemoveAdapter(IN PRNDISMP_ADAPTER pAdapter)
{
    PDRIVER_BLOCK   DriverBlock = pAdapter->DriverBlock;

    TRACE3(("RemoveAdapter\n"));

    CHECK_VALID_ADAPTER(pAdapter);

    // remove the adapter from the driver block list of adapters.

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    // see if it is the first one
    if (DriverBlock->AdapterList == pAdapter) 
    {
        DriverBlock->AdapterList = pAdapter->NextAdapter;

    }
    // not the first one, so walk the list
    else 
    {
        PRNDISMP_ADAPTER * ppAdapter = &DriverBlock->AdapterList;

        while (*ppAdapter != pAdapter)
        {
            ASSERT(*ppAdapter != NULL);
            ppAdapter = &((*ppAdapter)->NextAdapter);
        }

        *ppAdapter = pAdapter->NextAdapter;
    }

    // removing this adapter
    DriverBlock->NumberAdapters--;

    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

} // RemoveAdapter


/****************************************************************************/
/*                       DeviceObjectToAdapter                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Given a pointer to an FDO, return the corresponding Adapter structure,  */
/*  if it exists, and the driver block.                                     */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pDeviceObject - pointer to the device object to search for.             */
/*  ppAdapter - place to return pointer to the adapter structure.           */
/*  ppDriverBlock - place to return pointer to driver block.                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
DeviceObjectToAdapterAndDriverBlock(IN PDEVICE_OBJECT pDeviceObject,
                                    OUT PRNDISMP_ADAPTER * ppAdapter,
                                    OUT PDRIVER_BLOCK * ppDriverBlock)
{
    PDRIVER_BLOCK       pDriverBlock;
    PRNDISMP_ADAPTER    pAdapter;

    pAdapter = NULL;
    pDriverBlock = DeviceObjectToDriverBlock(&RndismpMiniportBlockListHead, pDeviceObject);
    if (pDriverBlock != NULL)
    {
        NdisAcquireSpinLock(&RndismpGlobalLock);

        for (pAdapter = pDriverBlock->AdapterList;
             pAdapter != NULL;
             pAdapter = pAdapter->NextAdapter)
        {
            if (pAdapter->pDeviceObject == pDeviceObject)
            {
                break;
            }
        }

        NdisReleaseSpinLock(&RndismpGlobalLock);
    }

    *ppAdapter = pAdapter;
    *ppDriverBlock = pDriverBlock;

} // DeviceObjectToAdapter

/****************************************************************************/
/*                          AddDriverBlock                                  */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Add driver block to list of drivers (microports) associated with this   */
/*  driver                                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Head - head of list                                                     */
/*  Item - driver block to add to list                                      */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
AddDriverBlock(IN PDRIVER_BLOCK Head, IN PDRIVER_BLOCK Item)
{
    TRACE3(("AddDriverBlock\n"));

    CHECK_VALID_BLOCK(Item);

    // first time through, so allocate global spinlock
    if(!RndismpNumMicroports)
        NdisAllocateSpinLock(&RndismpGlobalLock);

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    // Link the driver block on the global list of driver blocks
    Item->NextDriverBlock   = Head->NextDriverBlock;
    Head->NextDriverBlock   = Item;

    // keep track of how many microports we support so we can free
    // global resources
    RndismpNumMicroports++;
    
    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

} // AddDriverBlock



/****************************************************************************/
/*                          RemoveDriverBlock                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Remove driver block from list of drivers (microports) associated with   */
/*  this driver                                                             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Head - head of list                                                     */
/*  Item - driver block to remove from list                                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RemoveDriverBlock(IN PDRIVER_BLOCK BlockHead, IN PDRIVER_BLOCK Item)
{
    UINT    NumMicroports;

    PDRIVER_BLOCK   Head = BlockHead;

    TRACE1(("RemoveDriverBlock\n"));

    CHECK_VALID_BLOCK(Item);

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    // Remove the driver block from the global list of driver blocks
    while(Head->NextDriverBlock != Item) 
    {
        Head = Head->NextDriverBlock;

        // make sure this is valid
        if(!Head)
            break;
    }

    if(Head)
        Head->NextDriverBlock = Head->NextDriverBlock->NextDriverBlock;

    // keep track of how many microports we support so we can free
    // global resources
    RndismpNumMicroports--;

    NumMicroports = RndismpNumMicroports;
    
    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

    // see if we need to free global spinlock
    if(!RndismpNumMicroports)
        NdisFreeSpinLock(&RndismpGlobalLock);

    ASSERT(Head);

} // RemoveDriverBlock


/****************************************************************************/
/*                          DeviceObjectToDriverBlock                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Get driver block pointer associated with the PDO passed in              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Head - head of driver block list                                        */
/*  DeviceObject - device object we want to get associated driver block for */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PDRIVER_BLOCK                                                         */
/*                                                                          */
/****************************************************************************/
PDRIVER_BLOCK
DeviceObjectToDriverBlock(IN PDRIVER_BLOCK Head, 
                          IN PDEVICE_OBJECT DeviceObject)
{
    PDRIVER_OBJECT  DriverObject;

    TRACE3(("DeviceObjectToDriverBlock\n"));

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    // get the driver object for this adapter
    DriverObject = DeviceObjectToDriverObject(DeviceObject);

    Head = Head->NextDriverBlock;

    // walk the list of driver blocks to find a match with driver object
    while(Head->DriverObject != DriverObject)
    {
        Head = Head->NextDriverBlock;

        // break out if we are at the end of the list
        if(!Head)
            break;
    }

    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

    CHECK_VALID_BLOCK(Head);

    return Head;

} // DeviceObjectToDriverBlock


/****************************************************************************/
/*                          DriverObjectToDriverBlock                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Get driver block pointer associated with the Driver Object passed in    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Head - head of driver block list                                        */
/*  DriverObject - Driver object we want to get associated driver block for */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PDRIVER_BLOCK                                                         */
/*                                                                          */
/****************************************************************************/
PDRIVER_BLOCK
DriverObjectToDriverBlock(IN PDRIVER_BLOCK Head, 
                          IN PDRIVER_OBJECT DriverObject)
{
    TRACE3(("DriverObjectToDriverBlock\n"));

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    Head = Head->NextDriverBlock;

    // walk the list of driver blocks to find a match with driver object
    while(Head->DriverObject != DriverObject)
    {
        Head = Head->NextDriverBlock;

        // break out if we are at the end of the list
        if(!Head)
            break;
    }

    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

    CHECK_VALID_BLOCK(Head);

    return Head;

} // DriverObjectToDriverBlock


/****************************************************************************/
/*                          AllocateMsgFrame                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a frame that holds context about a message we are about to     */
/*  send.                                                                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Adapter object                                               */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_MESSAGE_FRAME                                                */
/*                                                                          */
/****************************************************************************/
PRNDISMP_MESSAGE_FRAME
AllocateMsgFrame(IN PRNDISMP_ADAPTER pAdapter)
{
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;

#ifndef DONT_USE_LOOKASIDE_LIST
    pMsgFrame = (PRNDISMP_MESSAGE_FRAME)
                    NdisAllocateFromNPagedLookasideList(&pAdapter->MsgFramePool);

#else
    {
        NDIS_STATUS Status;
        Status = MemAlloc(&pMsgFrame, sizeof(RNDISMP_MESSAGE_FRAME));
        if (Status != NDIS_STATUS_SUCCESS)
        {
            pMsgFrame = NULL;
        }
    }
#endif // DONT_USE_LOOKASIDE_LIST

    if (pMsgFrame)
    {
        NdisZeroMemory(pMsgFrame, sizeof(*pMsgFrame));
        pMsgFrame->pAdapter = pAdapter;
        pMsgFrame->RequestId = NdisInterlockedIncrement(&pAdapter->RequestId);
        pMsgFrame->Signature = FRAME_SIGNATURE;

        pMsgFrame->RefCount = 1;
        NdisInterlockedIncrement(&MsgFrameAllocs);
    }
#if DBG
    else
    {
        TRACE1(("AllocateMsgFrame: pAdapter %x, MsgFramePool at %x, alloc failed, count %d\n",
            pAdapter, &pAdapter->MsgFramePool, MsgFrameAllocs));
        DbgBreakPoint();
    }
#endif // DBG

    return (pMsgFrame);
}

/****************************************************************************/
/*                          DereferenceMsgFrame                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free a message frame and any associated resources.                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Frame - pointer to frame                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
DereferenceMsgFrame(IN PRNDISMP_MESSAGE_FRAME pMsgFrame)
{
    PRNDISMP_ADAPTER        pAdapter;
    PMDL                    pMdl;
    PUCHAR                  pMessage;

    CHECK_VALID_FRAME(pMsgFrame);

    if (NdisInterlockedDecrement(&pMsgFrame->RefCount) == 0)
    {
        //
        // Mess up the contents slightly to catch bugs resulting from
        // improper reuse of this frame after it is freed.
        //
        pMsgFrame->Signature++;

        pMdl = pMsgFrame->pMessageMdl;
        pMsgFrame->pMessageMdl = NULL;
    
        if (pMdl)
        {
            pMessage = RNDISMP_GET_MDL_ADDRESS(pMdl);
        }
        else
        {
            pMessage = NULL;
        }
    
        if (pMessage)
        {
            MemFree(pMessage, -1);
            IoFreeMdl(pMdl);
        }

        pAdapter = pMsgFrame->pAdapter;

#ifndef DONT_USE_LOOKASIDE_LIST
        NdisFreeToNPagedLookasideList(&pAdapter->MsgFramePool, pMsgFrame);
#else
        MemFree(pMsgFrame, sizeof(RNDISMP_MESSAGE_FRAME));
#endif
        NdisInterlockedDecrement(&MsgFrameAllocs);
    }

} // DereferenceMsgFrame


/****************************************************************************/
/*                          ReferenceMsgFrame                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Add a ref count to a message frame                                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Frame - pointer to frame                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
ReferenceMsgFrame(IN PRNDISMP_MESSAGE_FRAME pMsgFrame)
{
    NdisInterlockedIncrement(&pMsgFrame->RefCount);
}

/****************************************************************************/
/*                          KeepAliveTimerHandler                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Timer that keeps tabs on messages coming up from the device and         */
/*  sends a "KeepAlive" message if the device has been inactive too long    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  SystemSpecific1 - Don't care                                            */
/*  Context - pAdapter object                                               */
/*  SystemSpecific2 - Don't care                                            */
/*  SystemSpecific3 - Don't care                                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PNDIS_PACKET                                                            */
/*                                                                          */
/****************************************************************************/
VOID
KeepAliveTimerHandler(IN PVOID SystemSpecific1,
                      IN PVOID Context,
                      IN PVOID SystemSpecific2,
                      IN PVOID SystemSpecific3)
{
    PRNDISMP_ADAPTER            pAdapter;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    ULONG                       CurrentTime;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(Context);

    TRACE2(("KeepAliveTimerHandler\n"));

    do
    {
        // get current tick (in milliseconds)
        NdisGetSystemUpTime(&CurrentTime);

        // check and see if too much time has elapsed since we
        // got the last message from the device

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

        if (((CurrentTime - pAdapter->LastMessageFromDevice) > KEEP_ALIVE_TIMER))
        {
            // see if we have a keep alive message pending, so let's bong this
            if (pAdapter->KeepAliveMessagePending)
            {
                TRACE1(("KeepAliveTimer: Adapter %p, message pending: last msg %d, cur %d\n",
                    pAdapter, pAdapter->LastMessageFromDevice, CurrentTime));

                // indicate later from check for hang handler
                pAdapter->NeedReset = TRUE;

                RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

                RNDISMP_INCR_STAT(pAdapter, KeepAliveTimeout);

                break;
            }

            RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);


            // too much time has elapsed, send down a keep alive message
                
            pMsgFrame = BuildRndisMessageCommon(pAdapter, 
                                                NULL,
                                                REMOTE_NDIS_KEEPALIVE_MSG,
                                                0,
                                                NULL,
                                                0);

            if (pMsgFrame)
            {
                RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

                pAdapter->KeepAliveMessagePending = TRUE;
                pAdapter->KeepAliveMessagePendingId = pMsgFrame->RequestId;

                RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

                TRACE2(("Sending Keepalive(%d) on Adapter %p: last rcv %d, cur %d\n",
                        pMsgFrame->RequestId, pAdapter, pAdapter->LastMessageFromDevice, CurrentTime ));

                // send the message to the microport
                RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, FALSE, CompleteSendKeepAlive);
            }
        }
        else
        {
            RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
        }
    }
    while (FALSE);

    // see if the timer was cancelled somewhere
    if (!pAdapter->TimerCancelled)
    {
        // restart timer
        NdisSetTimer(&pAdapter->KeepAliveTimer, KEEP_ALIVE_TIMER / 2);
    }
} // KeepAliveTimerHandler


/****************************************************************************/
/*                          CompleteSendKeepAlive                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine to handle completion of send by the microport, for     */
/*  a keepalive message.                                                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame describing the message             */
/*  SendStatus - Status returned by microport                               */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendKeepAlive(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                      IN NDIS_STATUS SendStatus)
{
    PRNDISMP_ADAPTER    pAdapter;

    pAdapter = pMsgFrame->pAdapter;

    DereferenceMsgFrame(pMsgFrame);

    if (SendStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("KeepAlive send failure %x on Adapter %x\n",
                SendStatus, pAdapter));

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

        pAdapter->KeepAliveMessagePending = FALSE;
        pAdapter->NeedReset = FALSE;

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
    }

} // CompleteSendKeepAlive


/****************************************************************************/
/*                          BuildRndisMessageCommon                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    Allocate resources for meesage and frame and build RNDIS message      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - adapter object                                             */
/*    pVc - optionally, VC on which this message is sent.                   */
/*    NdisMessageType - RNDIS message type                                  */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - Holds the data to be set.                         */
/*    InformationBufferLength - The length of InformationBuffer.            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_MESSAGE_FRAME                                                */
/*                                                                          */
/****************************************************************************/
PRNDISMP_MESSAGE_FRAME
BuildRndisMessageCommon(IN  PRNDISMP_ADAPTER  pAdapter, 
                        IN  PRNDISMP_VC       pVc OPTIONAL,
                        IN  UINT              NdisMessageType,
                        IN  NDIS_OID          Oid,
                        IN  PVOID             InformationBuffer,
                        IN  ULONG             InformationBufferLength)
{
    PRNDIS_MESSAGE              pMessage;
    UINT                        MessageSize;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;

    TRACE2(("BuildRndisMessageCommon\n"));

    pMsgFrame = NULL;

    switch(NdisMessageType)
    {
        case REMOTE_NDIS_INITIALIZE_MSG:
        {
            PRNDIS_INITIALIZE_REQUEST   pInitRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_INITIALIZE_REQUEST);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;
            TRACE1(("RNDISMP: Init Req message %x, Type %d, Length %d, MaxRcv %d\n",
                    pMessage, pMessage->NdisMessageType, pMessage->MessageLength, pAdapter->MaxReceiveSize));

            pInitRequest = &pMessage->Message.InitializeRequest;
            pInitRequest->RequestId = pMsgFrame->RequestId;
            pInitRequest->MajorVersion = RNDIS_MAJOR_VERSION;
            pInitRequest->MinorVersion = RNDIS_MINOR_VERSION;
            pInitRequest->MaxTransferSize = pAdapter->MaxReceiveSize;

            break;
        }
        case REMOTE_NDIS_HALT_MSG:
        {
            PRNDIS_HALT_REQUEST   pHaltRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_HALT_REQUEST);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;
            pHaltRequest = &pMessage->Message.HaltRequest;
            pHaltRequest->RequestId = pMsgFrame->RequestId;

            break;
        }
        case REMOTE_NDIS_QUERY_MSG:
        {
            PRNDIS_QUERY_REQUEST   pQueryRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_QUERY_REQUEST) + InformationBufferLength;

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pQueryRequest = &pMessage->Message.QueryRequest;
            pQueryRequest->RequestId = pMsgFrame->RequestId;
            pQueryRequest->Oid = Oid;
            pQueryRequest->InformationBufferLength = InformationBufferLength;
            pQueryRequest->InformationBufferOffset = sizeof(RNDIS_QUERY_REQUEST);

            if (pVc == NULL)
            {
                pQueryRequest->DeviceVcHandle = NULL_DEVICE_CONTEXT;
            }
            else
            {
                pQueryRequest->DeviceVcHandle = pVc->DeviceVcContext;
            }

            TRACE2(("Query OID %x, Len %d, RequestId %08X\n",
                    Oid, InformationBufferLength, pQueryRequest->RequestId));

            // copy information buffer
            RNDISMP_MOVE_MEM(RNDISMP_GET_INFO_BUFFER_FROM_QUERY_MSG(pQueryRequest),
                             InformationBuffer,
                             InformationBufferLength);
            break;
        }
        case REMOTE_NDIS_SET_MSG:
        {
            PRNDIS_SET_REQUEST   pSetRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_SET_REQUEST) + InformationBufferLength;

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pSetRequest = &pMessage->Message.SetRequest;
            pSetRequest->RequestId = pMsgFrame->RequestId;
            pSetRequest->Oid = Oid;
            pSetRequest->InformationBufferLength = InformationBufferLength;
            pSetRequest->InformationBufferOffset = sizeof(RNDIS_SET_REQUEST);

            if (pVc == NULL)
            {
                pSetRequest->DeviceVcHandle = NULL_DEVICE_CONTEXT;
            }
            else
            {
                pSetRequest->DeviceVcHandle = pVc->DeviceVcContext;
            }

            // copy information buffer
            RNDISMP_MOVE_MEM(RNDISMP_GET_INFO_BUFFER_FROM_QUERY_MSG(pSetRequest),
                             InformationBuffer,
                             InformationBufferLength);
            break;
        }
        case REMOTE_NDIS_RESET_MSG:
        {
            PRNDIS_RESET_REQUEST   pResetRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_RESET_REQUEST);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pResetRequest = &pMessage->Message.ResetRequest;
            pResetRequest->Reserved = 0;
            break;
        }
        case REMOTE_NDIS_KEEPALIVE_MSG:
        {
            PRNDIS_KEEPALIVE_REQUEST   pKeepAliveRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_KEEPALIVE_REQUEST);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pKeepAliveRequest = &pMessage->Message.KeepaliveRequest;
            pKeepAliveRequest->RequestId = pMsgFrame->RequestId;
            break;
        }
        case REMOTE_NDIS_KEEPALIVE_CMPLT:
        {
            PRNDIS_KEEPALIVE_COMPLETE   pKeepAliveComplete;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_KEEPALIVE_COMPLETE);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pKeepAliveComplete = &pMessage->Message.KeepaliveComplete;
            pKeepAliveComplete->RequestId = *(RNDIS_REQUEST_ID *)InformationBuffer;
            pKeepAliveComplete->Status = NDIS_STATUS_SUCCESS;
            break;
        }

        default:
            TRACE2(("Invalid NdisMessageType (%08X)\n", NdisMessageType));
            ASSERT(FALSE);
            break;
    }

    return pMsgFrame;
} // BuildRndisMessageCommon


/****************************************************************************/
/*                          AllocateMessageAndFrame                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a message and frame for an RNDIS message                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pAdapter object                                              */
/*  MessageSize - size of RNDIS message                                     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_MESSAGE_FRAME                                                  */
/*                                                                          */
/****************************************************************************/
PRNDISMP_MESSAGE_FRAME
AllocateMessageAndFrame(IN PRNDISMP_ADAPTER pAdapter, 
                        IN UINT MessageSize)
{
    PRNDIS_MESSAGE          pMessage = NULL;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PMDL                    pMdl = NULL;

    TRACE3(("AllocateMessageAndFrame\n"));

    do
    {
        // allocate a buffer for RNDIS message
        Status = MemAlloc(&pMessage, MessageSize);

        // see if we got our buffer
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // allocate an MDL to describe this message.
        pMdl = IoAllocateMdl(
                    pMessage,
                    MessageSize,
                    FALSE,
                    FALSE,
                    NULL);

        if (pMdl == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        MmBuildMdlForNonPagedPool(pMdl);

        // got the message buffer, now allocate a frame
        pMsgFrame = AllocateMsgFrame(pAdapter);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        // got everything, so fill in some frame things
        pMsgFrame->pMessageMdl = pMdl;

        pMessage->MessageLength = MessageSize;

    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pMdl)
        {
            IoFreeMdl(pMdl);
        }

        if (pMessage)
        {
            MemFree(pMessage, MessageSize);
        }
    }

    return pMsgFrame;

} // AllocateMessageAndFrame


/****************************************************************************/
/*                          FreeAdapter                                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free all memory allocations to do with an Adapter structure             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to the adapter to be freed.                          */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/****************************************************************************/
VOID
FreeAdapter(IN PRNDISMP_ADAPTER Adapter)
{
    // free up transport resources
    FreeTransportResources(Adapter);

    if (Adapter->DriverOIDList)
    {
        MemFree(Adapter->DriverOIDList, RndismpSupportedOidsNum*sizeof(NDIS_OID));
    }

    if (Adapter->FriendlyNameAnsi.Buffer)
    {
        MemFree(Adapter->FriendlyNameAnsi.Buffer, Adapter->FriendlyNameAnsi.MaximumLength);
    }

    if (Adapter->FriendlyNameUnicode.Buffer)
    {
        MemFree(Adapter->FriendlyNameUnicode.Buffer, Adapter->FriendlyNameUnicode.MaximumLength);
    }

#if DBG
    if (Adapter->pSendLogBuffer)
    {
        MemFree(Adapter->pSendLogBuffer, Adapter->LogBufferSize);
        Adapter->pSendLogBuffer = NULL;
    }
#endif // DBG

    MemFree(Adapter, sizeof(RNDISMP_ADAPTER));
}


/****************************************************************************/
/*                          AllocateVc                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a VC structure                                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - adapter object                                               */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_VC                                                             */
/*                                                                          */
/****************************************************************************/
PRNDISMP_VC
AllocateVc(IN PRNDISMP_ADAPTER      pAdapter)
{
    PRNDISMP_VC     pVc;
    NDIS_STATUS     Status;

    Status = MemAlloc(&pVc, sizeof(RNDISMP_VC));
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pVc->pAdapter = pAdapter;
        pVc->VcState = RNDISMP_VC_ALLOCATED;
        pVc->CallState = RNDISMP_CALL_IDLE;
        pVc->RefCount = 0;
        RNDISMP_INIT_LOCK(&pVc->Lock);

        EnterVcIntoHashTable(pAdapter, pVc);
    }
    else
    {
        pVc = NULL;
    }

    return pVc;
}

/****************************************************************************/
/*                          DeallocateVc                                    */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Deallocate a VC structure.                                              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC being deallocated.                                  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
DeallocateVc(IN PRNDISMP_VC         pVc)
{
    ASSERT(pVc->RefCount == 0);
    ASSERT(pVc->VcState == RNDISMP_VC_ALLOCATED);

    RemoveVcFromHashTable(pVc->pAdapter, pVc);

    MemFree(pVc, sizeof(RNDISMP_VC));
}
    
/****************************************************************************/
/*                          LookupVcId                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Search for a VC structure that matches a given VC Id.                   */
/*  If we find the VC, we reference it and return it.                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*  VcId - Id to search for                                                 */
/*                                                                          */
/* Notes:                                                                   */
/*                                                                          */
/*  This routine is called with the adapter lock held!                      */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_VC - pointer to VC, if one exists                              */
/*                                                                          */
/****************************************************************************/
PRNDISMP_VC
LookupVcId(IN PRNDISMP_ADAPTER  pAdapter,
           IN UINT32            VcId)
{
    PLIST_ENTRY             pVcEnt;
    PRNDISMP_VC             pVc;
    ULONG                   VcIdHash;
    PRNDISMP_VC_HASH_TABLE  pVcHashTable;
    BOOLEAN                 bFound = FALSE;

    VcIdHash = RNDISMP_HASH_VCID(VcId);

    pVcHashTable = pAdapter->pVcHashTable;

    do
    {
        if (pVcHashTable == NULL)
        {
            pVc = NULL;
            break;
        }

        for (pVcEnt = pVcHashTable->HashEntry[VcIdHash].Flink;
             pVcEnt != &pVcHashTable->HashEntry[VcIdHash];
             pVcEnt = pVcEnt->Flink)
        {
            pVc = CONTAINING_RECORD(pVcEnt, RNDISMP_VC, VcList);
            if (pVc->VcId == VcId)
            {
                bFound = TRUE;

                RNDISMP_REF_VC(pVc);

                break;
            }
        }

        if (!bFound)
        {
            pVc = NULL;
        }
    }
    while (FALSE);

    return pVc;
}


/****************************************************************************/
/*                          EnterVcIntoHashTable                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Link a VC into the hash table after assigning it a VC Id.               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - adapter object                                               */
/*  pVc - VC to link to the above adapter                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
EnterVcIntoHashTable(IN PRNDISMP_ADAPTER    pAdapter,
                     IN PRNDISMP_VC         pVc)
{
    PRNDISMP_VC             pExistingVc;
    PRNDISMP_VC_HASH_TABLE  pVcHashTable;
    UINT32                  VcId;
    ULONG                   VcIdHash;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    //
    //  We pick the next sequentially higher Vc Id value for this VC,
    //  but check to see if it is already in use...
    //
    do
    {
        pAdapter->LastVcId++;

        // Never allocate the value 0.
        if (pAdapter->LastVcId == 0)
        {
            pAdapter->LastVcId++;
        }

        VcId = pAdapter->LastVcId;

        pExistingVc = LookupVcId(pAdapter, VcId);
    }
    while (pExistingVc != NULL);

    pVcHashTable = pAdapter->pVcHashTable;
    pVc->VcId = VcId;
    VcIdHash = RNDISMP_HASH_VCID(VcId);

    InsertTailList(&pVcHashTable->HashEntry[VcIdHash], &pVc->VcList);
    pVcHashTable->NumEntries++;

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
}


/****************************************************************************/
/*                        RemoveVcFromHashTable                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Unlink a VC from the adapter hash table.                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - adapter object                                               */
/*  pVc - VC to be unlinked.                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
RemoveVcFromHashTable(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDISMP_VC        pVc)
{
    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    RemoveEntryList(&pVc->VcList);

    pAdapter->pVcHashTable->NumEntries--;

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\win9x\makefile.inc ===
clean: 
    del $(O)\rmdat.h $(O)\rndismp.bmf

$(O)\rndismp.mof: ..\rndismp.mof

$(O)\rmdat.h: $(O)\rndismp.bmf
    wmimofck -h$(O)\rmdat.h $(O)\rndismp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\wdmutil.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    WDMUTIL.C

Abstract:

    Stuff that does not fit well with NDIS header files
    
Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/17/99 : created

Author:

    Tom Green

    
****************************************************************************/


#include "precomp.h"


/****************************************************************************/
/*                          DeviceObjectToDriverObject                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Get driver object associated with device object. NDIS has no notion     */
/*  of the shape of a device object, so we put this here for ease of        */
/*  building                                                                *
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  DeviceObject - device object we to get associated driver object for     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PDRIVER_OBJECT                                                        */
/*                                                                          */
/****************************************************************************/
PDRIVER_OBJECT
DeviceObjectToDriverObject(IN PDEVICE_OBJECT DeviceObject)
{
    return DeviceObject->DriverObject;
} // DeviceObjectToDriverObject


/****************************************************************************/
/*                          GetDeviceFriendlyName                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Return the friendly name associated with the given device object.       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pDeviceObject - device object we to get associated driver object for    */
/*  ppName - Place to return a pointer to an ANSI string containing name    */
/*  pNameLength - Place to return length of above string                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NTSTATUS                                                              */
/*                                                                          */
/****************************************************************************/
NTSTATUS
GetDeviceFriendlyName(IN PDEVICE_OBJECT pDeviceObject,
                      OUT PANSI_STRING pAnsiName,
                      OUT PUNICODE_STRING pUnicodeName)
{
    NTSTATUS                    NtStatus;
    NDIS_STATUS                 Status;
    ULONG                       ResultLength;
    DEVICE_REGISTRY_PROPERTY    Property;
    UNICODE_STRING              UnicodeString;
    ANSI_STRING                 AnsiString;
    USHORT                      AnsiMaxLength;
    PWCHAR                      pValueInfo;
    ULONG                       i;

    pValueInfo = NULL;
    AnsiString.Buffer = NULL;

    do
    {
        Property = DevicePropertyFriendlyName;

        for (i = 0; i < 2; i++)
        {
            NtStatus = IoGetDeviceProperty(pDeviceObject,
                                           Property,
                                           0,
                                           NULL,
                                           &ResultLength);

            if (NtStatus != STATUS_BUFFER_TOO_SMALL)
            {
                ASSERT(!NT_SUCCESS(NtStatus));
                Property = DevicePropertyDeviceDescription;
            }
        }

        Status = MemAlloc(&pValueInfo, ResultLength);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        NtStatus = IoGetDeviceProperty(pDeviceObject,
                                       Property,
                                       ResultLength,
                                       pValueInfo,
                                       &ResultLength);

        if (NtStatus != STATUS_SUCCESS)
        {
            TRACE1(("IoGetDeviceProperty returned %x\n", NtStatus));
            break;
        }

        RtlInitUnicodeString(&UnicodeString, pValueInfo);

        //
        //  Allocate space for ANSI version.
        //
        AnsiMaxLength = UnicodeString.MaximumLength / sizeof(WCHAR);
        Status = MemAlloc(&AnsiString.Buffer, AnsiMaxLength);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlFillMemory(AnsiString.Buffer, AnsiMaxLength, 0);
        AnsiString.MaximumLength = AnsiMaxLength;
        AnsiString.Length = 0;

        NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

        if (!NT_SUCCESS(NtStatus))
        {
            ASSERT(FALSE);
            break;
        }

        *pAnsiName = AnsiString;
        *pUnicodeName = UnicodeString;
        break;
    }
    while (FALSE);

    if (!NT_SUCCESS(NtStatus))
    {
        if (pValueInfo)
        {
            MemFree(pValueInfo, -1);
        }

        if (AnsiString.Buffer)
        {
            MemFree(AnsiString.Buffer, AnsiString.MaximumLength);
        }
    }

    return (NtStatus);
}


/****************************************************************************/
/*                          HookPnpDispatchRoutine                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Set up the driver object for the specified microport driver to          */
/*  intercept the IRP_MJ_PNP dispatch routine before it gets to NDIS.       */
/*  This is in order to support surprise removal on platforms where we      */
/*  don't have NDIS 5.1 support. If we are running on >= NDIS 5.1, don't    */
/*  do anything.                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  DriverBlock - pointer to driver block structure for this microport.     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
HookPnpDispatchRoutine(IN PDRIVER_BLOCK    DriverBlock)
{
    if ((DriverBlock->MajorNdisVersion < 5) ||
        ((DriverBlock->MajorNdisVersion == 5) && (DriverBlock->MinorNdisVersion < 1)))
    {
        DriverBlock->SavedPnPDispatch =
            DriverBlock->DriverObject->MajorFunction[IRP_MJ_PNP];
        DriverBlock->DriverObject->MajorFunction[IRP_MJ_PNP] = PnPDispatch;
    }
}

/****************************************************************************/
/*                          PnPDispatch                                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Dispatch routine for IRP_MJ_PNP that is called by the I/O system.       */
/*  We process surprise removal and query capabilities.                     */
/*  In all cases, we pass on the IRP to NDIS for further processing.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pDeviceObject - pointer to Device Object                                */
/*  pIrp - pointer to IRP                                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
NTSTATUS
PnPDispatch(IN PDEVICE_OBJECT       pDeviceObject,
            IN PIRP                 pIrp)
{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                Status;
    PDRIVER_BLOCK           DriverBlock;
    PRNDISMP_ADAPTER        pAdapter;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    DeviceObjectToAdapterAndDriverBlock(pDeviceObject, &pAdapter, &DriverBlock);

    TRACE3(("PnPDispatch: Adapter %x, MinorFunction %x\n",
            pAdapter, pIrpSp->MinorFunction));

    switch (pIrpSp->MinorFunction)
    {
        case IRP_MN_QUERY_CAPABILITIES:
            pIrpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = 1;
            break;
        
        case IRP_MN_SURPRISE_REMOVAL:
            TRACE1(("PnPDispatch: PDO %p, Adapter %p, surprise removal!\n",
                    pDeviceObject, pAdapter));
            if (pAdapter)
            {
                RndismpInternalHalt((NDIS_HANDLE)pAdapter, FALSE);
            }
            break;

        default:
            break;
    }

    Status = (DriverBlock->SavedPnPDispatch)(
                    pDeviceObject,
                    pIrp);

    return (Status);
}


#ifdef BUILD_WIN9X

/****************************************************************************/
/*                          HookNtKernCMHandler                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Swap the CM handler routine within NDIS' data structures such that      */
/*  we get called when NDIS forwards a CM message. This can only work on    */
/*  Win98 and Win98SE.                                                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - pointer to our adapter block                                  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
HookNtKernCMHandler(IN PRNDISMP_ADAPTER     pAdapter)
{
    PVOID   pNdisWrapperAdapterBlock;
    PVOID   pDetect;
    ULONG   WrapContextOffset;

    pDetect = (PVOID)((ULONG_PTR)pAdapter->MiniportAdapterHandle + 0x29c);

    if (*(PVOID *)pDetect == (PVOID)pAdapter->pPhysDeviceObject)
    {
        // Win98Gold
        WrapContextOffset = 0xf8;
        pAdapter->bRunningOnWin98Gold = TRUE;
    }
    else
    {
        // Win98SE
        WrapContextOffset = 0x60;
        pAdapter->bRunningOnWin98Gold = FALSE;
    }
    pAdapter->WrapContextOffset = WrapContextOffset;

    pNdisWrapperAdapterBlock = *(PVOID *)((ULONG_PTR)pAdapter->MiniportAdapterHandle + WrapContextOffset);

    // Save away the old handler:
    pAdapter->NdisCmConfigHandler = (MY_CMCONFIGHANDLER)
            (*(PVOID *)((ULONG_PTR)pNdisWrapperAdapterBlock + 0x78));

    // Insert our routine:
    (*(PVOID *)((ULONG_PTR)pNdisWrapperAdapterBlock + 0x78)) =
        (PVOID)RndisCMHandler;

    // Save the devnode to use on lookups based on devnode:
    pAdapter->DevNode = (MY_DEVNODE)
            (*(PVOID *)((ULONG_PTR)pNdisWrapperAdapterBlock + 0x38));

    TRACE1(("HookNtKernCMHandler: Adapter %p, NdisHandler %p, DevNode %x\n",
            pAdapter, pAdapter->NdisCmConfigHandler, pAdapter->DevNode));
}

/****************************************************************************/
/*                          UnHookNtKernCMHandler                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Put back the swapped Config Mgr handler in NDIS' data structures        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - pointer to our adapter block                                  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
UnHookNtKernCMHandler(IN PRNDISMP_ADAPTER     pAdapter)
{
    PVOID   pNdisWrapperAdapterBlock;

    if (pAdapter->NdisCmConfigHandler)
    {
        pNdisWrapperAdapterBlock = *(PVOID *)((ULONG_PTR)pAdapter->MiniportAdapterHandle + pAdapter->WrapContextOffset);
        (*(PVOID *)((ULONG_PTR)pNdisWrapperAdapterBlock + 0x78)) =
            (PVOID)pAdapter->NdisCmConfigHandler;
    }

    TRACE1(("UnhookNtKernCMHandler: Adapter %p, NdisHandler %p, DevNode %x\n",
            pAdapter, pAdapter->NdisCmConfigHandler, pAdapter->DevNode));
}

/****************************************************************************/
/*                             RndisCMHandler                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Handler to intercept Config Mgr messages forwarded by NDIS. The only    */
/*  message of interest is a CONFIG_PREREMOVE, which is our only indication */
/*  on Win98 and Win98SE that the device is being removed.                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Various - documented in Win9x CFmgr header.                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    MY_CONFIGRET                                                          */
/*                                                                          */
/****************************************************************************/
MY_CONFIGRET __cdecl
RndisCMHandler(IN MY_CONFIGFUNC         cfFuncName,
               IN MY_SUBCONFIGFUNC      cfSubFuncName,
               IN MY_DEVNODE            cfDevNode,
               IN ULONG                 dwRefData,
               IN ULONG                 ulFlags)
{
    PRNDISMP_ADAPTER        pAdapter, pTmpAdapter;
    PDRIVER_BLOCK           pDriverBlock;
    MY_CONFIGRET            crRetCode;

    do
    {
        //
        // Find the adapter to which this is addressed.
        //
        pAdapter = NULL;
        NdisAcquireSpinLock(&RndismpGlobalLock);

        for (pDriverBlock = RndismpMiniportBlockListHead.NextDriverBlock;
             (pDriverBlock != NULL) && (pAdapter == NULL);
             pDriverBlock = pDriverBlock->NextDriverBlock)
        {
            for (pTmpAdapter = pDriverBlock->AdapterList;
                 pTmpAdapter != NULL;
                 pTmpAdapter = pTmpAdapter->NextAdapter)
            {
                if (pTmpAdapter->DevNode == cfDevNode)
                {
                    pAdapter = pTmpAdapter;
                    break;
                }
            }
        }

        NdisReleaseSpinLock(&RndismpGlobalLock);

        ASSERT(pAdapter != NULL);

        TRACE1(("CMHandler: Adapter %p, CfFuncName %x\n",
                pAdapter, cfFuncName));

        //
        //  Forward this on before acting on it.
        //
        if (pAdapter &&
            (pAdapter->NdisCmConfigHandler != NULL))
        {
            crRetCode = pAdapter->NdisCmConfigHandler(
                                    cfFuncName,
                                    cfSubFuncName,
                                    cfDevNode,
                                    dwRefData,
                                    ulFlags);

            if ((cfFuncName == MY_CONFIG_PREREMOVE) ||
                ((cfFuncName == MY_CONFIG_PRESHUTDOWN) &&
                 (pAdapter->bRunningOnWin98Gold)))
            {
                RndismpInternalHalt((NDIS_HANDLE)pAdapter, FALSE);
            }
        }
        else
        {
            crRetCode = MY_CR_SUCCESS;
        }
    }
    while (FALSE);

    return (crRetCode);
}

#endif // BUILD_WIN9X
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\win2k\makefile.inc ===
clean: 
    del $(O)\rmdat.h $(O)\rndismp.bmf

$(O)\rndismp.mof: ..\rndismp.mof

$(O)\rmdat.h: $(O)\rndismp.bmf
    wmimofck -h$(O)\rmdat.h $(O)\rndismp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\rndismp\winme\makefile.inc ===
clean: 
    del $(O)\rmdat.h $(O)\rndismp.bmf

$(O)\rndismp.mof: ..\rndismp.mof

$(O)\rmdat.h: $(O)\rndismp.bmf
    wmimofck -h$(O)\rmdat.h $(O)\rndismp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\adapter.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    adapter.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


LIST_ENTRY allAdaptersList;

KSPIN_LOCK globalSpinLock;  

#ifdef RAW_TEST
BOOLEAN rawTest = TRUE;
#endif

ADAPTEREXT *NewAdapter(PDEVICE_OBJECT pdo)
{
    ADAPTEREXT *adapter;

    adapter = AllocPool(sizeof(ADAPTEREXT));
    if (adapter){

        adapter->sig = DRIVER_SIG;

        adapter->nextDevObj = pdo; 
        adapter->physDevObj = pdo;

        InitializeListHead(&adapter->adaptersListEntry);
        KeInitializeSpinLock(&adapter->adapterSpinLock);

        InitializeListHead(&adapter->usbFreePacketPool);
        InitializeListHead(&adapter->usbPendingReadPackets);
        InitializeListHead(&adapter->usbPendingWritePackets);
        InitializeListHead(&adapter->usbCompletedReadPackets);

        adapter->initialized = FALSE;
        adapter->halting = FALSE;
        adapter->gotPacketFilterIndication = FALSE;
        adapter->readReentrancyCount = 0;

        #ifdef RAW_TEST
        adapter->rawTest = rawTest;
        #endif

        /*
         *  Do all internal allocations.  
         *  If any of them fail, FreeAdapter will free the others.
         */
        adapter->deviceDesc = AllocPool(sizeof(USB_DEVICE_DESCRIPTOR));

        #if SPECIAL_WIN98SE_BUILD
            adapter->ioWorkItem = MyIoAllocateWorkItem(adapter->physDevObj);
        #else
            adapter->ioWorkItem = IoAllocateWorkItem(adapter->physDevObj);
        #endif

        if (adapter->deviceDesc && adapter->ioWorkItem){
        }
        else {
            FreeAdapter(adapter);
            adapter = NULL;
        }
    }

    return adapter;
}

VOID FreeAdapter(ADAPTEREXT *adapter)
{
    USBPACKET *packet;

    ASSERT(adapter->sig == DRIVER_SIG);
    adapter->sig = 0xDEADDEAD;
    
    /*
     *  All the read and write packets should have been returned to the free list.
     */
    ASSERT(IsListEmpty(&adapter->usbPendingReadPackets));
    ASSERT(IsListEmpty(&adapter->usbPendingWritePackets));
    ASSERT(IsListEmpty(&adapter->usbCompletedReadPackets));


    /*
     *  Free all the packets in the free list.
     */
    while (packet = DequeueFreePacket(adapter)){
        FreePacket(packet);
    }

    /*
     *  FreeAdapter can be called after a failed start,
     *  so check that each pointer was actually allocated before freeing it.
     */
    if (adapter->deviceDesc) FreePool(adapter->deviceDesc);
    if (adapter->configDesc) FreePool(adapter->configDesc);
    if (adapter->notifyBuffer) FreePool(adapter->notifyBuffer);
    if (adapter->notifyIrpPtr) IoFreeIrp(adapter->notifyIrpPtr);
    if (adapter->notifyUrbPtr) FreePool(adapter->notifyUrbPtr);
    if (adapter->interfaceInfo) FreePool(adapter->interfaceInfo);
    if (adapter->interfaceInfoMaster) FreePool(adapter->interfaceInfoMaster);

    if (adapter->ioWorkItem){
        #if SPECIAL_WIN98SE_BUILD
            MyIoFreeWorkItem(adapter->ioWorkItem);
        #else
            IoFreeWorkItem(adapter->ioWorkItem);
        #endif
    }

    FreePool(adapter);
}

VOID EnqueueAdapter(ADAPTEREXT *adapter)
{
    KIRQL oldIrql;

    ASSERT(adapter->sig == DRIVER_SIG);

    KeAcquireSpinLock(&globalSpinLock, &oldIrql);
    InsertTailList(&allAdaptersList, &adapter->adaptersListEntry);
    KeReleaseSpinLock(&globalSpinLock, oldIrql);
}

VOID DequeueAdapter(ADAPTEREXT *adapter)
{
    KIRQL oldIrql;

    ASSERT(adapter->sig == DRIVER_SIG);

    KeAcquireSpinLock(&globalSpinLock, &oldIrql);
    ASSERT(!IsListEmpty(&allAdaptersList));
    RemoveEntryList(&adapter->adaptersListEntry);
    InitializeListHead(&adapter->adaptersListEntry);
    KeReleaseSpinLock(&globalSpinLock, oldIrql);
}


VOID HaltAdapter(ADAPTEREXT *adapter)
{
    ASSERT(!adapter->halting);

    adapter->halting = TRUE;

    ASSERT(IsListEmpty(&adapter->usbCompletedReadPackets));

    CancelAllPendingPackets(adapter);

    adapter->initialized = FALSE;
}


VOID QueueAdapterWorkItem(ADAPTEREXT *adapter)
{
    BOOLEAN queueNow;
    KIRQL oldIrql;
    BOOLEAN useTimer;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    if (adapter->workItemOrTimerPending || adapter->halting || adapter->resetting){
        queueNow = FALSE;
    }
    else {
        adapter->workItemOrTimerPending = queueNow = TRUE;
        useTimer = (adapter->numConsecutiveReadFailures >= 8);
    }
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    if (queueNow){

        KeInitializeEvent(&adapter->workItemOrTimerEvent, NotificationEvent, FALSE);

        if (useTimer){
            /*
             *  If we're experiencing a large number of read failures,
             *  then possibly the hardware needs more time to recover
             *  than allowed by the workItem delay.
             *  This happens specifically on a surprise remove: the reads
             *  start failing, and the flurry of workItems hold off the
             *  actual remove forever.
             *  So in this case, we use a long timer instead of a workItem
             *  in order to allow a large gap before the next attempted read.
             */
            LARGE_INTEGER timerPeriod;
            const ULONG numSeconds = 10;

            DBGWARN(("Large number of READ FAILURES (%d), scheduling %d-second backoff timer ...", adapter->numConsecutiveReadFailures, numSeconds));

            /*
             *  Set the timer for 10 seconds (in negative 100 nsec units).
             */
            timerPeriod.HighPart = -1;
            timerPeriod.LowPart = numSeconds * -10000000;
            KeInitializeTimer(&adapter->backoffTimer);
            KeInitializeDpc(&adapter->backoffTimerDPC, BackoffTimerDpc, adapter);
            KeSetTimer(&adapter->backoffTimer, timerPeriod, &adapter->backoffTimerDPC);
        }
        else {

            #if SPECIAL_WIN98SE_BUILD
                MyIoQueueWorkItem(  adapter->ioWorkItem, 
                                    AdapterWorkItemCallback, 
                                    DelayedWorkQueue,
                                    adapter);
            #else
                IoQueueWorkItem(    adapter->ioWorkItem, 
                                    AdapterWorkItemCallback, 
                                    DelayedWorkQueue,
                                    adapter);
            #endif
        }
    }
}


VOID AdapterWorkItemCallback(IN PDEVICE_OBJECT devObj, IN PVOID context)
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)context;
    
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(adapter->physDevObj == devObj);

    ProcessWorkItemOrTimerCallback(adapter);
}


VOID BackoffTimerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)DeferredContext;
    ASSERT(adapter->sig == DRIVER_SIG);

    DBGWARN((" ... Backoff timer CALLBACK: (halting=%d, readDeficit=%d)", adapter->halting, adapter->readDeficit));
    ProcessWorkItemOrTimerCallback(adapter);
}


VOID ProcessWorkItemOrTimerCallback(ADAPTEREXT *adapter)
{
    BOOLEAN stillHaveReadDeficit;
    KIRQL oldIrql;
    
    if (adapter->initialized && !adapter->halting){
        /*
         *  Attempt to service any read deficit.
         *  If read packets are still not available, then this
         *  will NOT queue another workItem in TryReadUSB 
         *  because adapter->workItemOrTimerPending is STILL SET.
         */
        ServiceReadDeficit(adapter);

        #if DO_FULL_RESET
            if (adapter->needFullReset){
                /*
                 *  We can only do a full reset if we are not at DPC level,
                 *  so skip it if we are called from the timer DPC.
                 */
                if (KeGetCurrentIrql() <= APC_LEVEL){
                    AdapterFullResetAndRestore(adapter);
                }
            }
        #endif
    }

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    ASSERT(adapter->workItemOrTimerPending);
    adapter->workItemOrTimerPending = FALSE;
    KeSetEvent(&adapter->workItemOrTimerEvent, 0, FALSE);
    stillHaveReadDeficit = (adapter->readDeficit > 0);
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    /*
     *  If we were not able to service the entire read deficit,
     *  (e.g. because no free packets have become available)
     *  then schedule another workItem so that we try again later.
     */
    if (stillHaveReadDeficit && !adapter->halting){
        QueueAdapterWorkItem(adapter);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\debugn.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debugn.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <ndis.h>      
#include <ntddndis.h>  // defines OID's

#include "..\inc\rndis.h"
#include "..\inc\rndisapi.h"   

#include "usb8023.h"
#include "debug.h"

#if DBG

    PUCHAR DbgGetOidName(ULONG oid)
    {
        PCHAR oidName;

        switch (oid){

            #undef MAKECASE
            #define MAKECASE(oidx) case oidx: oidName = #oidx; break;

            MAKECASE(OID_GEN_SUPPORTED_LIST)
            MAKECASE(OID_GEN_HARDWARE_STATUS)
            MAKECASE(OID_GEN_MEDIA_SUPPORTED)
            MAKECASE(OID_GEN_MEDIA_IN_USE)
            MAKECASE(OID_GEN_MAXIMUM_LOOKAHEAD)
            MAKECASE(OID_GEN_MAXIMUM_FRAME_SIZE)
            MAKECASE(OID_GEN_LINK_SPEED)
            MAKECASE(OID_GEN_TRANSMIT_BUFFER_SPACE)
            MAKECASE(OID_GEN_RECEIVE_BUFFER_SPACE)
            MAKECASE(OID_GEN_TRANSMIT_BLOCK_SIZE)
            MAKECASE(OID_GEN_RECEIVE_BLOCK_SIZE)
            MAKECASE(OID_GEN_VENDOR_ID)
            MAKECASE(OID_GEN_VENDOR_DESCRIPTION)
            MAKECASE(OID_GEN_CURRENT_PACKET_FILTER)
            MAKECASE(OID_GEN_CURRENT_LOOKAHEAD)
            MAKECASE(OID_GEN_DRIVER_VERSION)
            MAKECASE(OID_GEN_MAXIMUM_TOTAL_SIZE)
            MAKECASE(OID_GEN_PROTOCOL_OPTIONS)
            MAKECASE(OID_GEN_MAC_OPTIONS)
            MAKECASE(OID_GEN_MEDIA_CONNECT_STATUS)
            MAKECASE(OID_GEN_MAXIMUM_SEND_PACKETS)
            MAKECASE(OID_GEN_VENDOR_DRIVER_VERSION)
            MAKECASE(OID_GEN_SUPPORTED_GUIDS)
            MAKECASE(OID_GEN_NETWORK_LAYER_ADDRESSES)
            MAKECASE(OID_GEN_TRANSPORT_HEADER_OFFSET)
            MAKECASE(OID_GEN_MEDIA_CAPABILITIES)
            MAKECASE(OID_GEN_PHYSICAL_MEDIUM)
            MAKECASE(OID_GEN_XMIT_OK)
            MAKECASE(OID_GEN_RCV_OK)
            MAKECASE(OID_GEN_XMIT_ERROR)
            MAKECASE(OID_GEN_RCV_ERROR)
            MAKECASE(OID_GEN_RCV_NO_BUFFER)
            MAKECASE(OID_GEN_DIRECTED_BYTES_XMIT)
            MAKECASE(OID_GEN_DIRECTED_FRAMES_XMIT)
            MAKECASE(OID_GEN_MULTICAST_BYTES_XMIT)
            MAKECASE(OID_GEN_MULTICAST_FRAMES_XMIT)
            MAKECASE(OID_GEN_BROADCAST_BYTES_XMIT)
            MAKECASE(OID_GEN_BROADCAST_FRAMES_XMIT)
            MAKECASE(OID_GEN_DIRECTED_BYTES_RCV)
            MAKECASE(OID_GEN_DIRECTED_FRAMES_RCV)
            MAKECASE(OID_GEN_MULTICAST_BYTES_RCV)
            MAKECASE(OID_GEN_MULTICAST_FRAMES_RCV)
            MAKECASE(OID_GEN_BROADCAST_BYTES_RCV)
            MAKECASE(OID_GEN_BROADCAST_FRAMES_RCV)
            MAKECASE(OID_GEN_RCV_CRC_ERROR)
            MAKECASE(OID_GEN_TRANSMIT_QUEUE_LENGTH)
            MAKECASE(OID_GEN_GET_TIME_CAPS)
            MAKECASE(OID_GEN_GET_NETCARD_TIME)
            MAKECASE(OID_GEN_NETCARD_LOAD)
            MAKECASE(OID_GEN_DEVICE_PROFILE)
            MAKECASE(OID_GEN_INIT_TIME_MS)
            MAKECASE(OID_GEN_RESET_COUNTS)
            MAKECASE(OID_GEN_MEDIA_SENSE_COUNTS)

            MAKECASE(OID_802_3_PERMANENT_ADDRESS)
            MAKECASE(OID_802_3_CURRENT_ADDRESS)
            MAKECASE(OID_802_3_MULTICAST_LIST)
            MAKECASE(OID_802_3_MAXIMUM_LIST_SIZE)
            MAKECASE(OID_802_3_MAC_OPTIONS)
            MAKECASE(OID_802_3_RCV_ERROR_ALIGNMENT)
            MAKECASE(OID_802_3_XMIT_ONE_COLLISION)
            MAKECASE(OID_802_3_XMIT_MORE_COLLISIONS)
            MAKECASE(OID_802_3_XMIT_DEFERRED)
            MAKECASE(OID_802_3_XMIT_MAX_COLLISIONS)
            MAKECASE(OID_802_3_RCV_OVERRUN)
            MAKECASE(OID_802_3_XMIT_UNDERRUN)
            MAKECASE(OID_802_3_XMIT_HEARTBEAT_FAILURE)
            MAKECASE(OID_802_3_XMIT_TIMES_CRS_LOST)
            MAKECASE(OID_802_3_XMIT_LATE_COLLISIONS)

            default: 
                oidName = "<** UNKNOWN OID **>";
                break;
        }

        return oidName;
    }


    void DbgStallExecution(ULONG usec)
    {
	    NdisStallExecution(usec);
    }

    ULONG DbgGetSystemTime_msec()
    {
	    LONGLONG systime_usec;
	    NdisGetCurrentSystemTime((PVOID)&systime_usec);  
	    return (ULONG)((*(PULONG)&systime_usec)/1000);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\rndissim.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rndissim.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


#include <ndis.h>      
#include <ntddndis.h>  // defines OID's

#include "..\inc\rndis.h"
#include "..\inc\rndisapi.h"   

#include "usb8023.h"
#include "debug.h"


#if DO_FULL_RESET

    NTSTATUS SimulateRNDISHalt(ADAPTEREXT *adapter)
    {
        USBPACKET *packet;
        NTSTATUS status;
        
        packet = DequeueFreePacket(adapter);
        if (packet){
            PRNDIS_MESSAGE haltMsg;
            ULONG haltMsgSize;

            haltMsgSize = FIELD_OFFSET(RNDIS_MESSAGE, Message) + 
                          sizeof(RNDIS_HALT_REQUEST);

            haltMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
            haltMsg->NdisMessageType = REMOTE_NDIS_HALT_MSG;
            haltMsg->MessageLength = haltMsgSize;
            haltMsg->Message.HaltRequest.RequestId = 1;

            packet->dataBufferCurrentLength = haltMsgSize;

            status = SubmitPacketToControlPipe(packet, TRUE, TRUE);
            EnqueueFreePacket(packet);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }


    NTSTATUS SimulateRNDISInit(ADAPTEREXT *adapter)
    {
        USBPACKET *packet;
        NTSTATUS status;
        
        packet = DequeueFreePacket(adapter);
        if (packet){
            PRNDIS_MESSAGE initMsg;
            ULONG initMsgSize;

            initMsgSize = FIELD_OFFSET(RNDIS_MESSAGE, Message) + 
                          sizeof(RNDIS_INITIALIZE_REQUEST);

            initMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
            initMsg->NdisMessageType = REMOTE_NDIS_INITIALIZE_MSG;
            initMsg->MessageLength = initMsgSize;
            initMsg->Message.InitializeRequest.RequestId = 1;
            initMsg->Message.InitializeRequest.MajorVersion = adapter->rndismpMajorVersion;
            initMsg->Message.InitializeRequest.MinorVersion = adapter->rndismpMinorVersion;
            initMsg->Message.InitializeRequest.MaxTransferSize = adapter->rndismpMaxTransferSize;

            packet->dataBufferCurrentLength = initMsgSize;

            status = SubmitPacketToControlPipe(packet, TRUE, TRUE);
            if (NT_SUCCESS(status)){
                /*
                 *  The adapter will now return a notification to indicate
                 *  that it has the init-complete response.
                 *  Read the notify pipe synchronously so as not to
                 *  restart the notify read loop.
                 */
                status = SubmitNotificationRead(adapter, TRUE);
                if (NT_SUCCESS(status)){
                    /*
                     *  Now read the init-complete message
                     *  from the control pipe and throw it away.
                     *  Do a synchronous read so the result doesn't
                     *  propagate up to RNDISMP.
                     */
                    status = ReadPacketFromControlPipe(packet, TRUE);  
                    if (NT_SUCCESS(status)){
                        PRNDIS_MESSAGE initCmpltMessage;

                        initCmpltMessage = (PRNDIS_MESSAGE)packet->dataBuffer;
                        status = initCmpltMessage->Message.InitializeComplete.Status;
                        if (NT_SUCCESS(status)){
                        }
                        else {
                            DBGERR(("SimulateRNDISInit: init-complete failed with %xh.", status));
                        }
                    }
                    else {
                        DBGERR(("SimulateRNDISInit: read for init-complete failed with %xh.", status));
                    }
                }
                else {
                    DBGERR(("SimulateRNDISInit: notification read failed with %xh.", status));
                }
            }
            else {
                DBGWARN(("SimulateRNDISInit: simulated init failed with %xh.", status));
            }

            EnqueueFreePacket(packet);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return status;
    }


    NTSTATUS SimulateRNDISSetPacketFilter(ADAPTEREXT *adapter)
    {
        USBPACKET *packet;
        NTSTATUS status;
        
        packet = DequeueFreePacket(adapter);
        if (packet){
            PRNDIS_MESSAGE setMsg;
            ULONG setMsgSize;

            setMsgSize = FIELD_OFFSET(RNDIS_MESSAGE, Message) + 
                         sizeof(RNDIS_SET_REQUEST) +
                         sizeof(ULONG);

            setMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
            setMsg->NdisMessageType = REMOTE_NDIS_SET_MSG;
            setMsg->MessageLength = setMsgSize;
            setMsg->Message.SetRequest.RequestId = 1;
            setMsg->Message.SetRequest.Oid = OID_GEN_CURRENT_PACKET_FILTER;
            setMsg->Message.SetRequest.InformationBufferLength = sizeof(ULONG);
            setMsg->Message.SetRequest.InformationBufferOffset = sizeof(RNDIS_SET_REQUEST);
            *(PULONG)((PUCHAR)&setMsg->Message.SetRequest+sizeof(RNDIS_SET_REQUEST)) = adapter->currentPacketFilter;

            packet->dataBufferCurrentLength = setMsgSize;

            status = SubmitPacketToControlPipe(packet, TRUE, TRUE);
            if (NT_SUCCESS(status)){
                /*
                 *  The adapter will now return a notification to indicate
                 *  that it has the init-complete response.
                 *  Read the notify pipe synchronously so as not to
                 *  restart the notify read loop.
                 */
                status = SubmitNotificationRead(adapter, TRUE);
                if (NT_SUCCESS(status)){
                    /*
                     *  Now read the init-complete message
                     *  from the control pipe and throw it away.
                     *  Do a synchronous read so the result doesn't
                     *  propagate up to RNDISMP.
                     */
                    status = ReadPacketFromControlPipe(packet, TRUE);  
                    if (NT_SUCCESS(status)){
                        PRNDIS_MESSAGE setCmpltMessage;

                        setCmpltMessage = (PRNDIS_MESSAGE)packet->dataBuffer;
                        status = setCmpltMessage->Message.SetComplete.Status;
                        if (NT_SUCCESS(status)){
                        }
                        else {
                            DBGERR(("SimulateRNDISSetPacketFilter: init-complete failed with %xh.", status));
                        }
                    }
                    else {
                        DBGERR(("SimulateRNDISSetPacketFilter: read for init-complete failed with %xh.", status));
                    }
                }
                else {
                    DBGERR(("SimulateRNDISSetPacketFilter: notification read failed with %xh.", status));
                }
            }
            else {
                DBGERR(("SimulateRNDISSetPacketFilter: oid returned %xh.", status));
            }

            EnqueueFreePacket(packet);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }


    NTSTATUS SimulateRNDISSetCurrentAddress(ADAPTEREXT *adapter)
    {
        NTSTATUS status;
        
        if (RtlEqualMemory(adapter->MAC_Address, "\0\0\0\0\0\0", ETHERNET_ADDRESS_LENGTH)){
            /*
             *  A 'software' MAC address was never assigned.
             *  So no need to resend it.
             */
            status = STATUS_SUCCESS;
        }
        else {
            USBPACKET *packet = DequeueFreePacket(adapter);
            if (packet){
                PRNDIS_MESSAGE setMsg;
                ULONG setMsgSize;

                setMsgSize = FIELD_OFFSET(RNDIS_MESSAGE, Message) + 
                             sizeof(RNDIS_SET_REQUEST) +
                             ETHERNET_ADDRESS_LENGTH;

                setMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
                setMsg->NdisMessageType = REMOTE_NDIS_SET_MSG;
                setMsg->MessageLength = setMsgSize;
                setMsg->Message.SetRequest.RequestId = 1;
                setMsg->Message.SetRequest.Oid = OID_802_3_CURRENT_ADDRESS;
                setMsg->Message.SetRequest.InformationBufferLength = ETHERNET_ADDRESS_LENGTH;
                setMsg->Message.SetRequest.InformationBufferOffset = sizeof(RNDIS_SET_REQUEST);
                RtlMoveMemory(  (PUCHAR)&setMsg->Message.SetRequest+sizeof(RNDIS_SET_REQUEST),
                                adapter->MAC_Address,
                                ETHERNET_ADDRESS_LENGTH);

                packet->dataBufferCurrentLength = setMsgSize;

                status = SubmitPacketToControlPipe(packet, TRUE, TRUE);
                if (NT_SUCCESS(status)){
                    /*
                     *  The adapter will now return a notification to indicate
                     *  that it has the init-complete response.
                     *  Read the notify pipe synchronously so as not to
                     *  restart the notify read loop.
                     */
                    status = SubmitNotificationRead(adapter, TRUE);
                    if (NT_SUCCESS(status)){
                        /*
                         *  Now read the init-complete message
                         *  from the control pipe and throw it away.
                         *  Do a synchronous read so the result doesn't
                         *  propagate up to RNDISMP.
                         */
                        status = ReadPacketFromControlPipe(packet, TRUE);  
                        if (NT_SUCCESS(status)){
                            PRNDIS_MESSAGE setCmpltMessage;

                            setCmpltMessage = (PRNDIS_MESSAGE)packet->dataBuffer;
                            status = setCmpltMessage->Message.SetComplete.Status;
                            if (NT_SUCCESS(status)){
                            }
                            else {
                                DBGERR(("SimulateRNDISSetPacketFilter: init-complete failed with %xh.", status));
                            }
                        }
                        else {
                            DBGERR(("SimulateRNDISSetCurrentAddress: read for init-complete failed with %xh.", status));
                        }
                    }
                    else {
                        DBGERR(("SimulateRNDISSetCurrentAddress: notification read failed with %xh.", status));
                    }
                }
                else {
                    DBGERR(("SimulateRNDISSetCurrentAddress: oid returned %xh.", status));
                }

                EnqueueFreePacket(packet);
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\debug.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"

#if DBG

    BOOLEAN dbgTrapOnWarn = FALSE;   
    BOOLEAN dbgVerbose = FALSE;  
    BOOLEAN dbgDumpBytes = FALSE;   // show all packets; slows us down too much to run
    BOOLEAN dbgDumpPktStatesOnEmpty = TRUE; 


    VOID InitDebug()
    {
        #if DBG_WRAP_MEMORY
            InitializeListHead(&dbgAllMemoryList);
        #endif
    }

	VOID DbgShowBytes(PUCHAR msg, PUCHAR buf, ULONG len)
	{

        #define PRNT(ch) ((((ch) < ' ') || ((ch) > '~')) ? '.' : (ch))

		if (dbgDumpBytes){
			ULONG i;
			DbgPrint("%s (len %xh @ %p): \r\n", msg, len, buf);
			
			for (i = 0; i < len; i += 16){
				DbgPrint("    ");

                if (len-i >= 16){
                    PUCHAR ptr = buf+i;
                    DbgPrint("%02x %02x %02x %02x %02x %02x %02x %02x  "
                             "%02x %02x %02x %02x %02x %02x %02x %02x "
                             "  "
                             "%c%c%c%c%c%c%c%c %c%c%c%c%c%c%c%c",
                             ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7], 
                             ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15], 
                             PRNT(ptr[0]), PRNT(ptr[1]), PRNT(ptr[2]), PRNT(ptr[3]), 
                             PRNT(ptr[4]), PRNT(ptr[5]), PRNT(ptr[6]), PRNT(ptr[7]), 
                             PRNT(ptr[8]), PRNT(ptr[9]), PRNT(ptr[10]), PRNT(ptr[11]), 
                             PRNT(ptr[12]), PRNT(ptr[13]), PRNT(ptr[14]), PRNT(ptr[15])
                            );
                }
                else {
                    ULONG j;
				    for (j = 0; j < 16; j++){
                        if (j == 8) DbgPrint(" ");
					    if (i+j < len){
						    DbgPrint("%02x ", (ULONG)buf[i+j]);
					    }
					    else {
						    DbgPrint("   ");
					    }
				    }
				    DbgPrint("  ");
				    for (j = 0; j < 16; j++){
                        if (j == 8) DbgPrint(" ");
					    if (i+j < len){
						    UCHAR ch = buf[i+j];
						    DbgPrint("%c", PRNT(ch));
					    }
					    else {
						    // DbgPrint(" ");
					    }
				    }
                }

				DbgPrint("\r\n");
			}
		}
	}

    VOID DbgShowMdlBytes(PUCHAR msg, PMDL mdl)
    {

        if (dbgDumpBytes){
			DbgPrint("\n %s (MDL @ %p): \r\n", msg, mdl);
            while (mdl){
#if defined(SPECIAL_WIN98SE_BUILD) || defined(SPECIAL_WINME_BUILD)
                PVOID thisBuf = MmGetSystemAddressForMdl(mdl);
#else
                PVOID thisBuf = MmGetSystemAddressForMdlSafe(mdl, NormalPoolPriority);
#endif
                ULONG thisBufLen = MmGetMdlByteCount(mdl);
                if (thisBuf) {
                    DbgShowBytes("    <MDL buffer>", thisBuf, thisBufLen);
                }
                mdl = mdl->Next;
            }
        }
    }

    DbgDumpPacketList(PUCHAR msg, PLIST_ENTRY listHead)
    {
        PLIST_ENTRY listEntry;
        USBPACKET *packet;
        ULONG timeNow = DbgGetSystemTime_msec();

        DbgPrint("\n  %s: ", msg);
        for (listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink){
            packet = CONTAINING_RECORD(listEntry, USBPACKET, listEntry);
            DbgPrint("\n    packet #%d @%p - buf @%p, len=%xh, (msg:%xh), age=%d msec", packet->packetId, packet, packet->dataBuffer, packet->dataBufferCurrentLength, *(PULONG)packet->dataBuffer, timeNow-packet->timeStamp);
        }

    }

    VOID DbgDumpPacketStates(ADAPTEREXT *adapter)
    {
        if (dbgDumpPktStatesOnEmpty){
            KIRQL oldIrql;

            KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

            DbgPrint("\n  *** USB8023 RAN OUT OF PACKETS, dumping packet states: *** ");

            DbgDumpPacketList("PENDING READ packets", &adapter->usbPendingReadPackets);
            DbgDumpPacketList("PENDING WRITE packets", &adapter->usbPendingWritePackets);
            DbgDumpPacketList("COMPLETED READ packets", &adapter->usbCompletedReadPackets);
            DbgDumpPacketList("FREE packets", &adapter->usbFreePacketPool);

            DbgPrint("\n hit 'g' to continue ...");
            DbgBreakPoint();

            KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
        }
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\rndis.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rndis.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


#include <ndis.h>      
#include <ntddndis.h>  // defines OID's

#include "..\inc\rndis.h"
#include "..\inc\rndisapi.h"   

#include "usb8023.h"
#include "debug.h"


      
NDIS_STATUS RndisInitializeHandler(     OUT PNDIS_HANDLE pMiniportAdapterContext,
                                        OUT PULONG pMaxReceiveSize, 
                                        IN NDIS_HANDLE RndisMiniportHandle,
                                        IN NDIS_HANDLE NdisMiniportHandle,
                                        IN NDIS_HANDLE WrapperConfigurationContext,
                                        IN PDEVICE_OBJECT Pdo)
{
    NDIS_STATUS rndisStat;
    ADAPTEREXT *adapter;	

    DBGVERBOSE(("RndisInitializeHandler"));  

    /*
     *  Allocate a new device object to represent this connection.
     */
    adapter = NewAdapter(Pdo);
    if (adapter){

        adapter->ndisAdapterHandle = (PVOID)NdisMiniportHandle;
        adapter->rndisAdapterHandle = (PVOID)RndisMiniportHandle;


        if (InitUSB(adapter)){

            /*
             *  Figure out the buffer size required for each packet.
             *
             *  For native RNDIS, the buffer must include the rndis message and RNDIS_PACKET.
             *  For KLSI, we have to prepend a two-byte size field to each packet.
             *  For other prototypes, we have to append zeroes to round the length 
             *  up to the next multiple of the endpoint packet size.
             *
             *  We must also need one extra byte for the one-byte short packet that
             *  must follow a full-sized frame.
             */
            ASSERT(adapter->writePipeLength);
            ASSERT(adapter->readPipeLength);

            /*
             *  Allocate common resources before miniport-specific resources
             *  because we need to allocate the packet pool first.
             */
            if (AllocateCommonResources(adapter)){

                EnqueueAdapter(adapter);

                /*
                 *  Give RNDIS our adapter context, which it will use to call us.
                 */
                *pMiniportAdapterContext = (NDIS_HANDLE)adapter;

                *pMaxReceiveSize = PACKET_BUFFER_SIZE;  

                rndisStat = NDIS_STATUS_SUCCESS;
            }
            else {
                rndisStat = NDIS_STATUS_NOT_ACCEPTED;
            }
        }
        else {
            rndisStat = NDIS_STATUS_NOT_ACCEPTED;
        }

        if (rndisStat != NDIS_STATUS_SUCCESS){
            FreeAdapter(adapter);
        }
    }
    else {
	    rndisStat = NDIS_STATUS_NOT_ACCEPTED;
    }

    return rndisStat;
}


NDIS_STATUS RndisInitCompleteNotify(IN NDIS_HANDLE MicroportAdapterContext,
                                    IN ULONG DeviceFlags,
                                    IN OUT PULONG pMaxTransferSize)
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)MicroportAdapterContext;

    if (*pMaxTransferSize > PACKET_BUFFER_SIZE) {

        DBGWARN(("Reducing adapter MaxTransferSize from %xh to %xh.",
            *pMaxTransferSize, PACKET_BUFFER_SIZE));

        *pMaxTransferSize = PACKET_BUFFER_SIZE;
    }

    StartUSBReadLoop(adapter);

    return NDIS_STATUS_SUCCESS;
}


VOID RndisHalt(IN NDIS_HANDLE MicroportAdapterContext)
{
    BOOLEAN workItemOrTimerPending;
    KIRQL oldIrql;
    ADAPTEREXT *adapter = (ADAPTEREXT *)MicroportAdapterContext;

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    DBGOUT(("> RndisHalt(%ph)", adapter));  

    ASSERT(adapter->sig == DRIVER_SIG);

    HaltAdapter(adapter);

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    workItemOrTimerPending = adapter->workItemOrTimerPending;
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    if (workItemOrTimerPending){
        /*
         *  Wait until workItem fires back to us before freeing the adapter context.
         */
        KeWaitForSingleObject(&adapter->workItemOrTimerEvent, Executive, KernelMode, FALSE, NULL);
    }

    DequeueAdapter(adapter);

    FreeAdapter(adapter);

    #if DBG_WRAP_MEMORY
        if (dbgTotalMemCount != 0){
            DBGERR(("RndisHalt: unloading with %xh bytes still allocated !!", dbgTotalMemCount));
        }
    #endif

    DBGOUT(("< RndisHalt")); 
}


VOID RndisShutdown(IN NDIS_HANDLE MicroportAdapterContext)
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)MicroportAdapterContext;

    DBGOUT(("RndisShutdown(%ph)", adapter)); 

    #if DBG_WRAP_MEMORY
        if (dbgTotalMemCount != 0){
            DBGERR(("RndisShutdown: unloading with %xh bytes still allocated !!", dbgTotalMemCount));
        }
    #endif
}


VOID RndisSendMessageHandler(   IN NDIS_HANDLE MicroportAdapterContext, 
                                IN PMDL pMessageMdl, 
                                IN NDIS_HANDLE RndisMessageHandle,
                                IN RM_CHANNEL_TYPE ChannelType)
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)MicroportAdapterContext;

    ASSERT(adapter->sig == DRIVER_SIG);

    if (!adapter->resetting){
        /*
         *  The message header is guaranteed to be contained in the first buffer of the MDL.
         */
        PRNDIS_MESSAGE pMsg = GetSystemAddressForMdlSafe(pMessageMdl);
        if (pMsg){

            ASSERT(!adapter->halting);

            if (adapter->numActiveWritePackets <= USB_PACKET_POOL_SIZE*3/4){

                USBPACKET *packet = DequeueFreePacket(adapter);
                if (packet){

                    packet->rndisMessageHandle = (PVOID)RndisMessageHandle;

                    /*
                     *  Move our packet to the usbPendingWritePackets queue
                     *  and send it down the USB pipe.
                     *  Native RNDIS packet messages go intact to the write pipe.
                     *  All other encapsulated commands go to the control pipe.
                     */
                    EnqueuePendingWritePacket(packet);

                    if (ChannelType == RMC_DATA) {
                        ASSERT(!packet->ndisSendPktMdl);

                        #ifdef RAW_TEST
                        if (adapter->rawTest) {
                            pMessageMdl = AddDataHeader(pMessageMdl);
                            if (pMessageMdl == NULL) {
                                DequeuePendingWritePacket(packet);
                                RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                                                    RndisMessageHandle,
                                                    NDIS_STATUS_RESOURCES);
                                return;
                            }
                            packet->dataPacket = TRUE;
                        }
                        #endif // RAW_TEST

                        packet->ndisSendPktMdl = pMessageMdl;
                        packet->dataBufferCurrentLength = CopyMdlToBuffer(packet->dataBuffer, pMessageMdl, packet->dataBufferMaxLength);

                        SubmitUSBWritePacket(packet);
                    }
                    else {
                        NTSTATUS status;
                        ULONG msgType = pMsg->NdisMessageType;
                        BOOLEAN synchronizeUSBcall = FALSE;
                        ULONG oid;
                        RNDIS_REQUEST_ID reqId;

                        switch (msgType){

                            case REMOTE_NDIS_INITIALIZE_MSG:
                                {
                                    ULONG maxXferSize = pMsg->Message.InitializeRequest.MaxTransferSize;
                                    DBGOUT(("---- REMOTE_NDIS_INITIALIZE_MSG (MaxTransferSize = %xh) ----", maxXferSize));
                                    ASSERT(maxXferSize <= PACKET_BUFFER_SIZE);
                                    adapter->rndismpMajorVersion = pMsg->Message.InitializeRequest.MajorVersion;
                                    adapter->rndismpMinorVersion = pMsg->Message.InitializeRequest.MinorVersion;
                                    adapter->rndismpMaxTransferSize = maxXferSize;
                                    synchronizeUSBcall = TRUE;
                                }
                                break;

                            case REMOTE_NDIS_SET_MSG:
                            case REMOTE_NDIS_QUERY_MSG:
                                oid = pMsg->Message.SetRequest.Oid;
                                reqId = pMsg->Message.SetRequest.RequestId;

                                DBGVERBOSE(("> %s (req#%d)", DbgGetOidName(oid), reqId));

                                if (oid == OID_GEN_CURRENT_PACKET_FILTER){
                                    ULONG pktFilter = *(PULONG)((PUCHAR)&pMsg->Message.SetRequest+pMsg->Message.SetRequest.InformationBufferOffset);
                                    adapter->currentPacketFilter = pktFilter;
                                    adapter->gotPacketFilterIndication = TRUE;
                                    DBGOUT(("---- Got OID_GEN_CURRENT_PACKET_FILTER (%xh) ----", pktFilter));
                                }
                                else if (oid == OID_802_3_CURRENT_ADDRESS){
                                    /*
                                     *  This oid can be a query or a set.
                                     *  If it's a set, save the assigned
                                     *  MAC address in case we need to simulate
                                     *  it later on a reset.
                                     */
                                    if (msgType == REMOTE_NDIS_SET_MSG){
                                        ASSERT(pMsg->Message.SetRequest.InformationBufferLength == ETHERNET_ADDRESS_LENGTH);
                                        DBGVERBOSE(("COVERAGE - OID_802_3_CURRENT_ADDRESS (SET), msg=%xh.", pMsg));
                                        RtlMoveMemory(  adapter->MAC_Address, 
                                                        ((PUCHAR)&pMsg->Message.SetRequest+pMsg->Message.SetRequest.InformationBufferOffset), 
                                                        ETHERNET_ADDRESS_LENGTH);
                                    }
                                }

                                adapter->dbgCurrentOid = oid;

                                break;
        
                            case REMOTE_NDIS_RESET_MSG:
                                DBGWARN(("---- REMOTE_NDIS_RESET_MSG ----"));
                                adapter->numSoftResets++;
                                break;

                            case REMOTE_NDIS_HALT_MSG:
                                DBGWARN(("---- REMOTE_NDIS_HALT_MSG ----"));
                                break;
                        }


                        packet->dataBufferCurrentLength = CopyMdlToBuffer(  packet->dataBuffer,
                                                                            pMessageMdl,
                                                                            packet->dataBufferMaxLength);

                        #ifdef RAW_TEST
                        packet->dataPacket = FALSE;
                        #endif
                        status = SubmitPacketToControlPipe(packet, synchronizeUSBcall, FALSE);

                        /*
                         *  If this is an init message, then start reading the notify pipe.
                         */
                        switch (msgType){

                            case REMOTE_NDIS_INITIALIZE_MSG:
                                if (NT_SUCCESS(status)){
                                    adapter->initialized = TRUE;
                                    SubmitNotificationRead(adapter, FALSE);
                                }
                                else {
                                    DBGERR(("Device failed REMOTE_NDIS_INITIALIZE_MSG with %xh.", status));
                                }
                                break;

                        }
                    }
                }
                else {
                    RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                                        RndisMessageHandle,
                                        NDIS_STATUS_RESOURCES);
                }
            }
            else {
                DBGWARN(("RndisSendMessageHandler: throttling sends because only %d packets available for rcv ", USB_PACKET_POOL_SIZE-adapter->numActiveWritePackets));
                RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                                    RndisMessageHandle,
                                    NDIS_STATUS_RESOURCES);
            }
        }
        else {
            DBGERR(("GetSystemAddressForMdlSafe failed"));
            RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                                RndisMessageHandle,
                                NDIS_STATUS_INVALID_PACKET);
        }
    }
    else {
        DBGWARN(("RndisSendMessageHandler - failing send because adapter is resetting"));
        RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                            RndisMessageHandle,
                            NDIS_STATUS_MEDIA_BUSY);
    }
}





/*
 *  RndisReturnMessageHandler
 * 
 *  This is the completion of a received packet indication call.
 */
VOID RndisReturnMessageHandler(     IN NDIS_HANDLE MicroportAdapterContext,
                                    IN PMDL pMessageMdl,
                                    IN NDIS_HANDLE MicroportMessageContext)
{
    USBPACKET *packet;

    DBGVERBOSE(("RndisReturnMessageHandler: msgMdl=%ph, msg context = %ph.", pMessageMdl, MicroportMessageContext));

    ASSERT(MicroportMessageContext);
    packet = (USBPACKET *)MicroportMessageContext;
    ASSERT(packet->sig == DRIVER_SIG);

    #ifdef RAW_TEST
    {
        ADAPTEREXT * adapter = (ADAPTEREXT *)MicroportAdapterContext;
        if (adapter->rawTest) {
            if (packet->dataPacket) {
                UnskipRcvRndisPacketHeader(packet);
            }
        }
    }
    #endif // RAW_TEST

    /*
     *  The receive indication is done.
     *  Put our packet back in the free list.
     */
    DequeueCompletedReadPacket(packet);
    EnqueueFreePacket(packet);
}



BOOLEAN RegisterRNDISMicroport(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    RNDIS_MICROPORT_CHARACTERISTICS rndisAttribs;
    NDIS_HANDLE ndisWrapperHandle;    

    DBGVERBOSE(("RegisterRNDISMicroport"));

    RtlZeroMemory(&rndisAttribs, sizeof(rndisAttribs));
    rndisAttribs.RndisVersion = RNDIS_VERSION;
    rndisAttribs.Reserved = 0;
    rndisAttribs.RmInitializeHandler = RndisInitializeHandler;
    rndisAttribs.RmInitCompleteNotifyHandler = RndisInitCompleteNotify;
    rndisAttribs.RmHaltHandler = RndisHalt;
    rndisAttribs.RmShutdownHandler = RndisShutdown;
    rndisAttribs.RmSendMessageHandler = RndisSendMessageHandler;
    rndisAttribs.RmReturnMessageHandler = RndisReturnMessageHandler;

    RndisMInitializeWrapper(    &ndisWrapperHandle, 
                                NULL, 
                                DriverObject, 
                                RegistryPath, 
                                &rndisAttribs);

    return TRUE;
}



VOID IndicateSendStatusToRNdis(USBPACKET *packet, NTSTATUS status)
{
#ifdef RAW_TEST
    ADAPTEREXT *adapter = packet->adapter;

    if (adapter->rawTest && packet->dataPacket) {
        FreeDataHeader(packet);
    }
#endif /? RAW_TEST

    packet->ndisSendPktMdl = NULL;

    ASSERT(packet->rndisMessageHandle);

    RndisMSendComplete( (NDIS_HANDLE)packet->adapter->rndisAdapterHandle, 
                        (NDIS_HANDLE)packet->rndisMessageHandle,
                        (NDIS_STATUS)status);
}


VOID RNDISProcessNotification(ADAPTEREXT *adapter)
{
    UCHAR notification = *(PUCHAR)adapter->notifyBuffer;
    UCHAR notificationCode = *((PUCHAR)adapter->notifyBuffer + 1);

    if ((notification == NATIVE_RNDIS_RESPONSE_AVAILABLE) ||
        ((notification == CDC_RNDIS_NOTIFICATION) &&
         (notificationCode == CDC_RNDIS_RESPONSE_AVAILABLE)))
    {
            /*
             *  Try to read a native RNDIS encapsulated command from the control pipe.
             */
            DBGVERBOSE(("NativeRNDISProcessNotification: NATIVE_RNDIS_RESPONSE_AVAILABLE"));
            {
                USBPACKET *packet = DequeueFreePacket(adapter);
                if (packet){
                    EnqueuePendingReadPacket(packet);
                    ReadPacketFromControlPipe(packet, FALSE);  
                }
                else {
                    DBGWARN(("couldn't get free packet in NativeRNDISProcessNotification"));
                }
            }
    }
    else {
            DBGERR(("NativeRNDISProcessNotification: unknown notification %xh.", notification));
    }
}


NTSTATUS IndicateRndisMessage(  IN USBPACKET *packet,
                                IN BOOLEAN bIsData)
{
    ADAPTEREXT *adapter = packet->adapter;
    PRNDIS_MESSAGE rndisMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
    NDIS_STATUS rcvStat;

    ASSERT(packet->dataBufferCurrentLength <= packet->dataBufferMaxLength);

    /*
     *  Indicate the packet to RNDIS, and pass a pointer to our usb packet
     *  as the MicroportMessageContext.
     *  The packet/message will be returned to us via RndisReturnMessageHandler.
     */
    MyInitializeMdl(packet->dataBufferMdl, packet->dataBuffer, packet->dataBufferCurrentLength);
    if (adapter->numFreePackets < USB_PACKET_POOL_SIZE/8){
        rcvStat = NDIS_STATUS_RESOURCES;
    }
    else {
        rcvStat = NDIS_STATUS_SUCCESS;
    }

    #ifdef RAW_TEST
    if (adapter->rawTest) {
        packet->dataPacket = bIsData;
        if (bIsData) {
            SkipRcvRndisPacketHeader(packet);
        }
    }
    #endif // RAW_TEST

    RndisMIndicateReceive(  (NDIS_HANDLE)packet->adapter->rndisAdapterHandle,
                            packet->dataBufferMdl,
                            (NDIS_HANDLE)packet,
                            (bIsData? RMC_DATA: RMC_CONTROL),
                            rcvStat);

    return STATUS_PENDING;

}


#ifdef RAW_TEST

//
// Add an RNDIS_PACKET header to a sent "raw" encapsulated Ethernet frame.
//
PMDL AddDataHeader(IN PMDL pMessageMdl)
{
    PMDL pHeaderMdl, pTmpMdl;
    PRNDIS_MESSAGE	pRndisMessage;
    PRNDIS_PACKET pRndisPacket;
    ULONG TotalLength;

    //
    // Compute the total length.
    //
    TotalLength = 0;
    for (pTmpMdl = pMessageMdl; pTmpMdl != NULL; pTmpMdl = pTmpMdl->Next)
    {
        TotalLength += MmGetMdlByteCount(pTmpMdl);
    }

    //
    // Allocate an RNDIS packet header:
    //
    pRndisMessage = AllocPool(RNDIS_MESSAGE_SIZE(RNDIS_PACKET));
    if (pRndisMessage != NULL) {

        pHeaderMdl = IoAllocateMdl(pRndisMessage,
                                   RNDIS_MESSAGE_SIZE(RNDIS_PACKET),
                                   FALSE,
                                   FALSE,
                                   NULL);

        if (pHeaderMdl != NULL) {
            MmBuildMdlForNonPagedPool(pHeaderMdl);

            //
            // Fill in the RNDIS message generic header:
            //
            pRndisMessage->NdisMessageType = REMOTE_NDIS_PACKET_MSG;
            pRndisMessage->MessageLength = RNDIS_MESSAGE_SIZE(RNDIS_PACKET) + TotalLength;

            //
            // Fill in the RNDIS_PACKET structure:
            //
            pRndisPacket = (PRNDIS_PACKET)&pRndisMessage->Message;
            pRndisPacket->DataOffset = sizeof(RNDIS_PACKET);
            pRndisPacket->DataLength = TotalLength;
            pRndisPacket->OOBDataOffset = 0;
            pRndisPacket->OOBDataLength = 0;
            pRndisPacket->NumOOBDataElements = 0;
            pRndisPacket->PerPacketInfoOffset = 0;
            pRndisPacket->PerPacketInfoLength = 0;
            pRndisPacket->VcHandle = 0;
            pRndisPacket->Reserved = 0;

            //
            // Link it to the raw data frame:
            //
            pHeaderMdl->Next = pMessageMdl;
        }
        else {
            FreePool(pRndisMessage);
            pHeaderMdl = NULL;
        }
    }
    else {
        pHeaderMdl = NULL;
    }

    return (pHeaderMdl);
}

//
// Remove an RNDIS_PACKET header that we had added to a raw encapsulated
// Ethernet frame.
//
VOID FreeDataHeader(IN USBPACKET * packet)
{
    PMDL pHeaderMdl;
    PRNDIS_MESSAGE pRndisMessage;

    ASSERT(packet->dataPacket == TRUE);

    //
    // Take out the MDL we had pre-pended
    //
    pHeaderMdl = packet->ndisSendPktMdl;
    packet->ndisSendPktMdl = pHeaderMdl->Next;

    //
    // Free the RNDIS_PACKET header:
    //
    pRndisMessage = MmGetMdlVirtualAddress(pHeaderMdl);
    FreePool(pRndisMessage);

    //
    // ... and the MDL itself.
    //
    IoFreeMdl(pHeaderMdl);
}


//
// Modify a received message to skip the RNDIS_PACKET header
// before indicating this up to RNDISMP, to test raw encapsulation.
//
VOID SkipRcvRndisPacketHeader(IN USBPACKET * packet)
{
    PMDL pHeaderMdl;
    RNDIS_MESSAGE UNALIGNED * pRndisMessage;
    RNDIS_PACKET UNALIGNED * pRndisPacket;
    ULONG DataLength;
    ULONG DataOffset;

    //
    // Get some info from the received RNDIS_PACKET message.
    // Note that this may contain multiple data packets, in which
    // case we only pass up the first one.
    //
    pHeaderMdl = packet->dataBufferMdl;
    pRndisMessage = MmGetMdlVirtualAddress(pHeaderMdl);
    pRndisPacket = (RNDIS_PACKET UNALIGNED *)&pRndisMessage->Message;
    DataLength = pRndisPacket->DataLength;
    DataOffset = FIELD_OFFSET(RNDIS_MESSAGE, Message) + pRndisPacket->DataOffset;

    //
    // Save away some existing values to restore later.
    //
    packet->rcvDataOffset = DataOffset;
    packet->rcvByteCount = pHeaderMdl->ByteCount;


    //
    // This is ONLY for test purposes. Simply modify the MDL to reflect
    // a single "raw" encapsulated frame.
    //
    pHeaderMdl->ByteOffset += DataOffset;
    (ULONG_PTR)pHeaderMdl->MappedSystemVa += DataOffset;
    pHeaderMdl->ByteCount = DataLength;
}


//
// Undo for the above function.
// 
VOID UnskipRcvRndisPacketHeader(IN USBPACKET * packet)
{
    PMDL pHeaderMdl;

    ASSERT(packet->dataPacket == TRUE);

    //
    // Undo everything we did in the SkipRcv... function.
    //
    pHeaderMdl = packet->dataBufferMdl;

    pHeaderMdl->ByteOffset -= packet->rcvDataOffset;
    (ULONG_PTR)pHeaderMdl->MappedSystemVa -= packet->rcvDataOffset;
    pHeaderMdl->ByteCount = packet->rcvByteCount;

}

#endif // RAW_TEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#define BAD_POINTER ((PVOID)0xDEADDEAD)
#define ISPTR(ptr) ((ptr) && ((ptr) != BAD_POINTER))


/*
 *  For X86 debug, wrap memory allocations so we can find leaks
 *  (causes runtime alignment errors on IA64).
 */
#define DBG_WRAP_MEMORY 0
#if DBG 
    #ifdef _X86_
        #undef DBG_WRAP_MEMORY
        #define DBG_WRAP_MEMORY 1
    #endif
#endif


#if DBG

    extern BOOLEAN dbgTrapOnWarn;
    extern BOOLEAN dbgVerbose;
    extern BOOLEAN dbgSkipSecurity;
    extern BOOLEAN dbgDumpBytes;

    #if DBG_WRAP_MEMORY
        extern ULONG dbgTotalMemCount;
        extern LIST_ENTRY dbgAllMemoryList;
    #endif

    #define DRIVERNAME "USB8023"

    #if WIN9X_BUILD
        #define DBG_LEADCHAR ' '
    #else
        #define DBG_LEADCHAR '\''
    #endif
    
    #define TRAP(msg)                                        \
        {                                               \
            DbgPrint("%c"DRIVERNAME"> Code coverage trap: '%s' file %s, line %d \n",  DBG_LEADCHAR, (msg), __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }

    #undef ASSERT
    #define ASSERT(fact)                                        \
        if (!(fact)){                                               \
            DbgPrint("%c"DRIVERNAME"> Assertion '%s' failed: file %s, line %d \n",  DBG_LEADCHAR, #fact, __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }

    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("%c"DRIVERNAME"> *** WARNING *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (dbgTrapOnWarn){ \
                DbgBreakPoint();                            \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("%c"DRIVERNAME"> *** ERROR *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGOUT(args_in_parens)                                \
        {                                               \
            DbgPrint("%c"DRIVERNAME"> ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }
    #define DBGVERBOSE(args_in_parens)                                \
        if (dbgVerbose){                                               \
            DbgPrint("%c"DRIVERNAME"> ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }


    VOID InitDebug();
	VOID DbgShowBytes(PUCHAR msg, PUCHAR buf, ULONG len);
    VOID DbgShowMdlBytes(PUCHAR msg, PMDL mdl);
    PUCHAR DbgGetOidName(ULONG oid);
    VOID DbgDumpPacketStates(ADAPTEREXT *adapter);
    void DbgStallExecution(ULONG usec);
    ULONG DbgGetSystemTime_msec();

    #define INITDEBUG() InitDebug()
	#define DBGSHOWBYTES(msg, buf, len) DbgShowBytes(msg, buf, len)
    #define DBGSHOWMDLBYTES(msg, mdl) DbgShowMdlBytes(msg, mdl)
    #define DBGDUMPPACKETSTATES(adapterx) DbgDumpPacketStates(adapterx)
#else
    #define DBGWARN(args_in_parens)                               
    #define DBGERR(args_in_parens)                               
    #define DBGOUT(args_in_parens)                               
    #define DBGVERBOSE(args_in_parens)                               
    #define TRAP(msg)         

    #define INITDEBUG()
	#define DBGSHOWBYTES(msg, buf, len)
    #define DBGSHOWMDLBYTES(msg, mdl)
    #define DBGDUMPPACKETSTATES(adapterx) 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\packet.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    packet.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


ULONG uniquePacketId = 0;


USBPACKET *NewPacket(ADAPTEREXT *adapter)
{
    USBPACKET *packet = AllocPool(sizeof(USBPACKET));
    if (packet){
        BOOLEAN allAllocsOk;

        packet->sig = DRIVER_SIG;
        packet->adapter = adapter;
        packet->cancelled = FALSE;

        InitializeListHead(&packet->listEntry);

        packet->irpPtr = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
        packet->urbPtr = AllocPool(sizeof(URB));

        packet->dataBuffer = AllocPool(PACKET_BUFFER_SIZE);
        packet->dataBufferMaxLength = PACKET_BUFFER_SIZE;
        if (packet->dataBuffer){
            packet->dataBufferMdl = IoAllocateMdl(packet->dataBuffer, PACKET_BUFFER_SIZE, FALSE, FALSE, NULL);
        }

        packet->dataBufferCurrentLength = 0;

        allAllocsOk = (packet->irpPtr && packet->urbPtr && packet->dataBuffer && packet->dataBufferMdl);

        if (allAllocsOk){
            packet->packetId = ++uniquePacketId;
        }
        else {

            if (packet->irpPtr) IoFreeIrp(packet->irpPtr);
            if (packet->urbPtr) FreePool(packet->urbPtr);
            if (packet->dataBuffer) FreePool(packet->dataBuffer);
            if (packet->dataBufferMdl) IoFreeMdl(packet->dataBufferMdl);

            FreePool(packet);
            packet = NULL;
        }
    }

    return packet;
}

VOID FreePacket(USBPACKET *packet)
{
    PIRP irp = packet->irpPtr;

    ASSERT(packet->sig == DRIVER_SIG);
    packet->sig = 0xDEADDEAD;

    ASSERT(!irp->CancelRoutine);
    IoFreeIrp(irp);

    FreePool(packet->urbPtr);

    ASSERT(packet->dataBufferMdl);
    IoFreeMdl(packet->dataBufferMdl);

    ASSERT(packet->dataBuffer);
    FreePool(packet->dataBuffer);

    FreePool(packet);
}

VOID EnqueueFreePacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(IsListEmpty(&packet->listEntry));
    InsertTailList(&adapter->usbFreePacketPool, &packet->listEntry);

    adapter->numFreePackets++;
    ASSERT(adapter->numFreePackets <= USB_PACKET_POOL_SIZE);

    #if DBG
        packet->timeStamp = DbgGetSystemTime_msec();

        if (adapter->dbgInLowPacketStress){
            if (adapter->numFreePackets > USB_PACKET_POOL_SIZE/2){
                adapter->dbgInLowPacketStress = FALSE;
                DBGWARN(("recovered from low-packet stress"));
            }
        }
    #endif

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}

USBPACKET *DequeueFreePacket(ADAPTEREXT *adapter)
{
    USBPACKET *packet;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    if (IsListEmpty(&adapter->usbFreePacketPool)){
        packet = NULL;
    }
    else {
        PLIST_ENTRY listEntry = RemoveHeadList(&adapter->usbFreePacketPool);
        packet = CONTAINING_RECORD(listEntry, USBPACKET, listEntry);
        ASSERT(packet->sig == DRIVER_SIG);
        InitializeListHead(&packet->listEntry);

        ASSERT(adapter->numFreePackets > 0);
        adapter->numFreePackets--;
    }

    #if DBG
        if (adapter->numFreePackets < USB_PACKET_POOL_SIZE/8){
            if (!adapter->dbgInLowPacketStress){
                /*
                 *  We are entering low-packet stress.
                 *  Repeated debug spew can slow the system and actually
                 *  keep the system from recovering the packets.  
                 *  So only spew a warning once.
                 */
                DBGWARN(("low on free packets (%d free, %d reads, %d writes, %d indicated)", adapter->numFreePackets, adapter->numActiveReadPackets, adapter->numActiveWritePackets, adapter->numIndicatedReadPackets));
                adapter->dbgInLowPacketStress = TRUE;
            }
        }
    #endif

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    return packet;
}

VOID EnqueuePendingReadPacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(IsListEmpty(&packet->listEntry));
    InsertTailList(&adapter->usbPendingReadPackets, &packet->listEntry);

    #if DBG
        packet->timeStamp = DbgGetSystemTime_msec();
    #endif

    adapter->numActiveReadPackets++;

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


/*
 *  DequeuePendingReadPacket
 *
 */
VOID DequeuePendingReadPacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(!IsListEmpty(&adapter->usbPendingReadPackets));
    ASSERT(!IsListEmpty(&packet->listEntry));

    RemoveEntryList(&packet->listEntry);
    ASSERT(packet->sig == DRIVER_SIG);
    InitializeListHead(&packet->listEntry);

    ASSERT(adapter->numActiveReadPackets > 0);
    adapter->numActiveReadPackets--;

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


VOID EnqueuePendingWritePacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(IsListEmpty(&packet->listEntry));
    InsertTailList(&adapter->usbPendingWritePackets, &packet->listEntry);

    adapter->numActiveWritePackets++;
    ASSERT(adapter->numActiveWritePackets <= USB_PACKET_POOL_SIZE);

    #if DBG
        packet->timeStamp = DbgGetSystemTime_msec();
    #endif

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


/*
 *  DequeuePendingWritePacket
 *
 *      Return either the indicated packet or the first packet in the pending queue.
 */
VOID DequeuePendingWritePacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(!IsListEmpty(&adapter->usbPendingWritePackets));
    ASSERT(!IsListEmpty(&packet->listEntry));

    RemoveEntryList(&packet->listEntry);

    ASSERT(adapter->numActiveWritePackets > 0);
    adapter->numActiveWritePackets--;

    ASSERT(packet->sig == DRIVER_SIG);
    InitializeListHead(&packet->listEntry);

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


VOID EnqueueCompletedReadPacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(IsListEmpty(&packet->listEntry));
    InsertTailList(&adapter->usbCompletedReadPackets, &packet->listEntry);

    #if DBG
        packet->timeStamp = DbgGetSystemTime_msec();
    #endif

    adapter->numIndicatedReadPackets++;

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}

VOID DequeueCompletedReadPacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(!IsListEmpty(&adapter->usbCompletedReadPackets));
    ASSERT(!IsListEmpty(&packet->listEntry));

    RemoveEntryList(&packet->listEntry);
    InitializeListHead(&packet->listEntry);

    ASSERT(adapter->numIndicatedReadPackets > 0);
    adapter->numIndicatedReadPackets--;

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}



VOID CancelAllPendingPackets(ADAPTEREXT *adapter)
{
    PLIST_ENTRY listEntry;
    USBPACKET *packet;
    PIRP irp;
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    /*
     *  Cancel all pending READs.
     */
    while (!IsListEmpty(&adapter->usbPendingReadPackets)){

        listEntry = RemoveHeadList(&adapter->usbPendingReadPackets);
        packet = CONTAINING_RECORD(listEntry, USBPACKET, listEntry);
        irp = packet->irpPtr;

        ASSERT(packet->sig == DRIVER_SIG);

        /*
         *  Leave the IRP in the list when we cancel it so that completion routine
         *  can move it to the free list.
         */
        InsertTailList(&adapter->usbPendingReadPackets, &packet->listEntry);

        KeInitializeEvent(&packet->cancelEvent, NotificationEvent, FALSE);

        ASSERT(!packet->cancelled);
        packet->cancelled = TRUE;

        KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

        DBGVERBOSE((" - cancelling pending read packet #%xh @ %ph, irp=%ph ...", packet->packetId, packet, irp));
        IoCancelIrp(irp);

        /*
         *  Wait for the completion routine to run and set the cancelEvent.
         *  By the time we get done waiting, the packet should be back in the free list. 
         */
        KeWaitForSingleObject(&packet->cancelEvent, Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    }

    ASSERT(IsListEmpty(&adapter->usbPendingReadPackets));

    /*
     *  Cancel all pending WRITEs.
     */
    while (!IsListEmpty(&adapter->usbPendingWritePackets)){

        listEntry = RemoveHeadList(&adapter->usbPendingWritePackets);
        packet = CONTAINING_RECORD(listEntry, USBPACKET, listEntry);
        irp = packet->irpPtr;

        ASSERT(packet->sig == DRIVER_SIG);

        /*
         *  Leave the IRP in the list when we cancel it so that completion routine
         *  can move it to the free list.
         */
        InsertTailList(&adapter->usbPendingWritePackets, &packet->listEntry);

        KeInitializeEvent(&packet->cancelEvent, NotificationEvent, FALSE);

        ASSERT(!packet->cancelled);
        packet->cancelled = TRUE;

        KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

        DBGVERBOSE((" - cancelling pending write packet #%xh @ %ph, irp=%ph ...", packet->packetId, packet, irp));
        IoCancelIrp(irp);

        /*
         *  Wait for the completion routine to run and set the cancelEvent.
         *  By the time we get done waiting, the packet should be back in the free list. 
         */
        KeWaitForSingleObject(&packet->cancelEvent, Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    }

    ASSERT(IsListEmpty(&adapter->usbPendingWritePackets));


    /*
     *  Cancel the read on the NOTIFY pipe.
     */
    if (adapter->notifyPipeHandle){

        /*
         *  Make sure we've actually sent the notify irp before trying
         *  to cancel it; otherwise, we hang forever waiting for it to complete.
         */
        if (adapter->initialized){
            if (adapter->notifyStopped){
                /*
                 *  The notify irp has already stopped looping because it returned with error
                 *  in NotificationCompletion.  Don't cancel it because we'll hang forever
                 *  waiting for it to complete.
                 */
                DBGVERBOSE(("CancelAllPendingPackets: notify irp already stopped, no need to cancel"));
            }
            else {
                KeInitializeEvent(&adapter->notifyCancelEvent, NotificationEvent, FALSE);
                adapter->cancellingNotify = TRUE;

                KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
                DBGVERBOSE((" - cancelling notify irp = %ph ...", adapter->notifyIrpPtr));
                IoCancelIrp(adapter->notifyIrpPtr);
                KeWaitForSingleObject(&adapter->notifyCancelEvent, Executive, KernelMode, FALSE, NULL);
                KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

                adapter->cancellingNotify = FALSE;
            }
        }
    }

    adapter->readDeficit = 0;
    
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\usb.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <wdm.h>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


/*
 *  USB- and WDM- specific prototypes (won't compile in common header)
 */
NTSTATUS SubmitUrb(PDEVICE_OBJECT pdo, PURB urb, BOOLEAN synchronous, PVOID completionRoutine, PVOID completionContext);
NTSTATUS SubmitUrbIrp(PDEVICE_OBJECT pdo, PIRP irp, PURB urb, BOOLEAN synchronous, PVOID completionRoutine, PVOID completionContext);
NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS CallDriverSyncCompletion(IN PDEVICE_OBJECT devObjOrNULL, IN PIRP irp, IN PVOID context);
NTSTATUS ReadPipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS WritePipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS NotificationCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS ControlPipeWriteCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS ControlPipeReadCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);



BOOLEAN InitUSB(ADAPTEREXT *adapter)
/*++

Routine Description:

    Intialize USB-related data

Arguments:

    adapter - adapter context

Return Value:

    TRUE iff successful

--*/
{
	NTSTATUS status;
    BOOLEAN result = FALSE;

	status = GetDeviceDescriptor(adapter);
	if (NT_SUCCESS(status)){
        PUSB_DEVICE_DESCRIPTOR deviceDesc = adapter->deviceDesc;
      
        if (deviceDesc->bDeviceClass == USB_DEVICE_CLASS_CDC){

		    status = GetConfigDescriptor(adapter);
		    if (NT_SUCCESS(status)){

			    status = SelectConfiguration(adapter);
                if (NT_SUCCESS(status)){

                    /* 
                     *  Find the read and write pipe handles.
                     */
                    status = FindUSBPipeHandles(adapter);
                    if (NT_SUCCESS(status)){

                        /*
                         *  Now that we know the notify length,
                         *  initialize structures for reading the notify pipe.
                         *  Add some buffer space for a guard word.
                         */
                        adapter->notifyBuffer = AllocPool(adapter->notifyPipeLength+sizeof(ULONG));
                        adapter->notifyIrpPtr = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
                        adapter->notifyUrbPtr = AllocPool(sizeof(URB));
                        if (adapter->notifyBuffer && adapter->notifyIrpPtr && adapter->notifyUrbPtr){
                            KeInitializeEvent(&adapter->notifyCancelEvent, NotificationEvent, FALSE);
                            adapter->cancellingNotify = FALSE;
                        }
                        else {
                            /*
                             *  Alloc failure. Memory will be cleaned up by FreeAdapter().
                             */
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }

                        if (NT_SUCCESS(status)){
                            result = TRUE;
                        }
                        else {
                            /*
                             *  Alloc failure. Memory will be cleaned up by FreeAdapter().
                             */
                            DBGERR(("Couldn't allocate notify structs"));
                        }
                    }
                }
		    }
        }
        else {
            DBGERR(("InitUSB: device descriptor has wrong bDeviceClass==%xh.", (ULONG)deviceDesc->bDeviceClass));
            status = STATUS_DEVICE_DATA_ERROR;
        }
	}

	return result;
}


VOID StartUSBReadLoop(ADAPTEREXT *adapter)
{
    ULONG i;

    for (i = 0; i < NUM_READ_PACKETS; i++){
        TryReadUSB(adapter);
    }
}



VOID TryReadUSB(ADAPTEREXT *adapter)
{
    KIRQL oldIrql;

    /*
     *  ReadPipeCompletion re-issues a read irp directly via this function.
     *  Ordinarily the hardware can't keep up fast enough to
     *  make us loop, but this check forces an unwind in extenuating circumstances.
     */
    if (InterlockedIncrement(&adapter->readReentrancyCount) > 3){
        KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
        adapter->readDeficit++;
        KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
        QueueAdapterWorkItem(adapter);
        DBGWARN(("TryReadUSB: reentered %d times, aborting to prevent stack overflow", adapter->readReentrancyCount));
    }
    else {
        USBPACKET *packet = DequeueFreePacket(adapter);
        if (packet){
            NTSTATUS status;

            EnqueuePendingReadPacket(packet);

            status = SubmitUSBReadPacket(packet);
        }
        else {
            KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
            adapter->readDeficit++;
            KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
            QueueAdapterWorkItem(adapter);
        }
    }

    InterlockedDecrement(&adapter->readReentrancyCount);

}




NTSTATUS GetDeviceDescriptor(ADAPTEREXT *adapter)
/*++

Routine Description:

    Function retrieves the device descriptor from the device

Arguments:

    adapter - adapter context

Return Value:

    NT status code

--*/
{
    URB urb;
    NTSTATUS status;

    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_DEVICE_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 adapter->deviceDesc,
                                 NULL,
                                 sizeof(USB_DEVICE_DESCRIPTOR),
                                 NULL);

    status = SubmitUrb(adapter->nextDevObj, &urb, TRUE, NULL, NULL);

    if (NT_SUCCESS(status)){
        ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength == sizeof(USB_DEVICE_DESCRIPTOR));
        DBGVERBOSE(("Got device desc @ %ph.", (PVOID)&adapter->deviceDesc));
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}


NTSTATUS GetConfigDescriptor(ADAPTEREXT *adapter)
/*++

Routine Description:

    Function retrieves the configuration descriptor from the device

Arguments:

    adapter - adapter context

Return Value:

    NT status code

--*/
{
    URB urb = { 0 };
    NTSTATUS status;
    USB_CONFIGURATION_DESCRIPTOR tmpConfigDesc = { 0 };


    /*
     *  First get the initial part of the config descriptor
     *  to find out how long the entire descriptor is.
     */
    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 (PVOID)&tmpConfigDesc,
                                 NULL,
                                 sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                 NULL);
    status = SubmitUrb(adapter->nextDevObj, &urb, TRUE, NULL, NULL);
    if (NT_SUCCESS(status)){

        ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength == sizeof(USB_CONFIGURATION_DESCRIPTOR));
        ASSERT(tmpConfigDesc.wTotalLength > sizeof(USB_CONFIGURATION_DESCRIPTOR));

        adapter->configDesc = AllocPool((ULONG)tmpConfigDesc.wTotalLength);
        if (adapter->configDesc){
            RtlZeroMemory(adapter->configDesc, (ULONG)tmpConfigDesc.wTotalLength);
            UsbBuildGetDescriptorRequest(&urb,
                                         (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         adapter->configDesc,
                                         NULL,
                                         tmpConfigDesc.wTotalLength,
                                         NULL);
            status = SubmitUrb(adapter->nextDevObj, &urb, TRUE, NULL, NULL);
            if (NT_SUCCESS(status)){
                ASSERT(((PUSB_CONFIGURATION_DESCRIPTOR)adapter->configDesc)->wTotalLength == tmpConfigDesc.wTotalLength);
                ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength == (ULONG)tmpConfigDesc.wTotalLength);
                DBGVERBOSE(("Got config desc @ %ph, len=%xh.", adapter->configDesc, urb.UrbControlDescriptorRequest.TransferBufferLength)); 
            }
            else {
                ASSERT(NT_SUCCESS(status));
                FreePool(adapter->configDesc);
                adapter->configDesc = NULL;
            }
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}



/*
 *  SelectConfiguration
 *
 *
 */
NTSTATUS SelectConfiguration(ADAPTEREXT *adapter)
{
	PUSB_CONFIGURATION_DESCRIPTOR configDesc = (PUSB_CONFIGURATION_DESCRIPTOR)adapter->configDesc;
	NTSTATUS status;
    PURB urb = NULL;
    ULONG i;

    ASSERT(configDesc->bNumInterfaces > 0);

    #if SPECIAL_WIN98SE_BUILD
        /*
         *  Hack to load on Win98 gold
         */
        {
            USHORT dummySize = 0;
            ASSERT(configDesc->bNumInterfaces >= 2);
            urb = USBD_CreateConfigurationRequest(configDesc, &dummySize);
        }
    #else
        if (configDesc->bNumInterfaces >= 2){
    	    PUSBD_INTERFACE_LIST_ENTRY interfaceList;
            interfaceList = AllocPool((configDesc->bNumInterfaces+1)*sizeof(USBD_INTERFACE_LIST_ENTRY));
            if (interfaceList){

                for (i = 0; i < configDesc->bNumInterfaces; i++){

                    /*
                     *  Note: try to use USBD_ParseConfigurationDescriptor instead of
                     *        USBD_ParseConfigurationDescriptorEx so that we work
                     *        on Win98 gold.
                     */
	                interfaceList[i].InterfaceDescriptor = USBD_ParseConfigurationDescriptor(
                                configDesc,
                                (UCHAR)i,      
                                (UCHAR)0);
                    if (!interfaceList[i].InterfaceDescriptor){
                        break;
                    }
                }
                interfaceList[i].InterfaceDescriptor = NULL;
                ASSERT(i == configDesc->bNumInterfaces);

		        urb = USBD_CreateConfigurationRequestEx(configDesc, interfaceList);

                FreePool(interfaceList);
            }
        }
        else {
            ASSERT(configDesc->bNumInterfaces >= 2);
        }
    #endif

	if (urb){
        PUSBD_INTERFACE_INFORMATION interfaceInfo;

        /*
         *  Fill in the interfaceInfo Class fields, 
         *  since USBD_CreateConfigurationRequestEx doesn't do that.
         */
        interfaceInfo = &urb->UrbSelectConfiguration.Interface;
        for (i = 0; i < configDesc->bNumInterfaces; i++){
            PUSB_INTERFACE_DESCRIPTOR ifaceDesc;
            ifaceDesc = USBD_ParseConfigurationDescriptor(configDesc, (UCHAR)i, (UCHAR)0);
            interfaceInfo->Class = ifaceDesc->bInterfaceClass;
            interfaceInfo = (PUSBD_INTERFACE_INFORMATION)((PUCHAR)interfaceInfo+interfaceInfo->Length);
        }

        /*
         *  Increase the transfer size for all data endpoints up to the maximum.
         *  The data interface follows the master interface.
         */
        interfaceInfo = &urb->UrbSelectConfiguration.Interface;
        if (interfaceInfo->Class != USB_DEVICE_CLASS_DATA){
            interfaceInfo = (PUSBD_INTERFACE_INFORMATION)((PUCHAR)interfaceInfo+interfaceInfo->Length);
        }
        if (interfaceInfo->Class == USB_DEVICE_CLASS_DATA){
            for (i = 0; i < interfaceInfo->NumberOfPipes; i++){
                interfaceInfo->Pipes[i].MaximumTransferSize = PACKET_BUFFER_SIZE;
            }
            status = SubmitUrb(adapter->nextDevObj, urb, TRUE, NULL, NULL);
        }
        else {
            ASSERT(interfaceInfo->Class == USB_DEVICE_CLASS_DATA);
            status = STATUS_DEVICE_DATA_ERROR;
        }

        if (NT_SUCCESS(status)){
            PUSBD_INTERFACE_INFORMATION interfaceInfo2;

            adapter->configHandle = (PVOID)urb->UrbSelectConfiguration.ConfigurationHandle;

            /*
             *  A USB RNDIS device has two interfaces:
             *      - a 'master' CDC class interface with one interrupt endpoint for notification
             *      - a Data class interface with two bulk endpoints
             *
             *  They may be in either order, so check class fields to assign
             *  pointers correctly.
             */

            interfaceInfo = &urb->UrbSelectConfiguration.Interface;
            interfaceInfo2 = (PUSBD_INTERFACE_INFORMATION)((PUCHAR)interfaceInfo+interfaceInfo->Length);

            if ((interfaceInfo->Class == USB_DEVICE_CLASS_CDC) &&
                (interfaceInfo2->Class == USB_DEVICE_CLASS_DATA)){
                adapter->interfaceInfoMaster = MemDup(interfaceInfo, interfaceInfo->Length);
                adapter->interfaceInfo = MemDup(interfaceInfo2, interfaceInfo2->Length);
            }
            else if ((interfaceInfo->Class == USB_DEVICE_CLASS_DATA) &&
                     (interfaceInfo2->Class == USB_DEVICE_CLASS_CDC)){
                DBGWARN(("COVERAGE - Data interface precedes master CDC interface"));
                adapter->interfaceInfo = MemDup(interfaceInfo, interfaceInfo->Length);
                adapter->interfaceInfoMaster = MemDup(interfaceInfo2, interfaceInfo2->Length);
            }
            else {
                DBGERR(("improper interface classes"));
                adapter->interfaceInfo = NULL;
                adapter->interfaceInfoMaster = NULL;
            }

            if (adapter->interfaceInfo && adapter->interfaceInfoMaster){
                DBGVERBOSE(("SelectConfiguration: interfaceInfo @ %ph, interfaceInfoMaster @ %ph.", adapter->interfaceInfo, adapter->interfaceInfoMaster));
            }
            else {
                if (adapter->interfaceInfoMaster) FreePool(adapter->interfaceInfoMaster);
                if (adapter->interfaceInfo) FreePool(adapter->interfaceInfo);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            DBGERR(("SelectConfiguration: selectConfig URB failed w/ %xh.", status));
        }

        ExFreePool(urb);
	}
	else {
		status = STATUS_INSUFFICIENT_RESOURCES;
	}

    ASSERT(NT_SUCCESS(status));
	return status;
}



NTSTATUS FindUSBPipeHandles(ADAPTEREXT *adapter)
{

    /*
     *  Algorithm for identifying the endpoints:
     *      The longest interrupt or bulk IN endpoint on the data interface
     *          is the read endpoint;
     *      The longest interrupt or bulk OUT endpoint on the data interface
     *          is the write endpoint;
     *      The first interrupt IN endpoint on the master interface
     *          is the notification endpoint.
     */
    
    PUSBD_INTERFACE_INFORMATION interfaceInfo = adapter->interfaceInfo;
    PUSBD_INTERFACE_INFORMATION notifyInterfaceInfo = adapter->interfaceInfoMaster;
    LONG pipeIndex;
    LONG longestInputPipeIndex = -1, longestOutputPipeIndex = -1, notifyPipeIndex = -1;
    ULONG longestInputPipeLength = 0, longestOutputPipeLength = 0, notifyPipeLength;
    NTSTATUS status;

    /*
     *  Find the IN and OUT endpoints.
     */
	for (pipeIndex = 0; pipeIndex < (LONG)interfaceInfo->NumberOfPipes; pipeIndex++){
		PUSBD_PIPE_INFORMATION pipeInfo = &interfaceInfo->Pipes[pipeIndex];

		if ((pipeInfo->PipeType == UsbdPipeTypeInterrupt) || 
            (pipeInfo->PipeType == UsbdPipeTypeBulk)){

    		if (pipeInfo->EndpointAddress & USB_ENDPOINT_DIRECTION_MASK){
                if (pipeInfo->MaximumPacketSize > longestInputPipeLength){
                    longestInputPipeIndex = pipeIndex;
                    longestInputPipeLength = pipeInfo->MaximumPacketSize;
                }
            }
            else {
                if (pipeInfo->MaximumPacketSize > longestOutputPipeLength){
                    longestOutputPipeIndex = pipeIndex;
                    longestOutputPipeLength = pipeInfo->MaximumPacketSize;
                }
            }
        }
    }

    /*
     *  Find the Notify endpoint.
     */
	for (pipeIndex = 0; pipeIndex < (LONG)notifyInterfaceInfo->NumberOfPipes; pipeIndex++){
		PUSBD_PIPE_INFORMATION pipeInfo = &notifyInterfaceInfo->Pipes[pipeIndex];

        if ((pipeInfo->PipeType == UsbdPipeTypeInterrupt)               &&
    		(pipeInfo->EndpointAddress & USB_ENDPOINT_DIRECTION_MASK)   &&
            ((notifyInterfaceInfo != interfaceInfo) || 
             (pipeIndex != longestInputPipeIndex))){

                notifyPipeIndex = pipeIndex;
                notifyPipeLength = pipeInfo->MaximumPacketSize;
                break;
        }
    }

    if ((longestInputPipeIndex >= 0)     && 
        (longestOutputPipeIndex >= 0)    &&
        (notifyPipeIndex >= 0)){

        adapter->readPipeHandle = interfaceInfo->Pipes[longestInputPipeIndex].PipeHandle;
        adapter->writePipeHandle = interfaceInfo->Pipes[longestOutputPipeIndex].PipeHandle;
        adapter->notifyPipeHandle = notifyInterfaceInfo->Pipes[notifyPipeIndex].PipeHandle;

        adapter->readPipeLength = longestInputPipeLength;
        adapter->writePipeLength = longestOutputPipeLength;
        adapter->notifyPipeLength = notifyPipeLength;

        adapter->readPipeEndpointAddr = interfaceInfo->Pipes[longestInputPipeIndex].EndpointAddress;
        adapter->writePipeEndpointAddr = interfaceInfo->Pipes[longestOutputPipeIndex].EndpointAddress;
        adapter->notifyPipeEndpointAddr = notifyInterfaceInfo->Pipes[notifyPipeIndex].EndpointAddress;

        DBGVERBOSE(("FindUSBPipeHandles: got readPipe %ph,len=%xh; writePipe %ph,len=%xh; notifyPipe %ph,len=%xh.",
                    adapter->readPipeHandle, adapter->readPipeLength, adapter->writePipeHandle, adapter->writePipeLength, adapter->notifyPipeHandle, adapter->notifyPipeLength));
        status = STATUS_SUCCESS;
    }
    else {
        DBGERR(("FindUSBPipeHandles: couldn't find right set of pipe handles (indices: %xh,%xh,%xh).", longestInputPipeIndex, longestOutputPipeIndex, notifyPipeIndex));
        status = STATUS_DEVICE_DATA_ERROR;
    }

    return status;
}


NTSTATUS SubmitUrb( PDEVICE_OBJECT pdo, 
                    PURB urb, 
                    BOOLEAN synchronous, 
                    PVOID completionRoutine,
                    PVOID completionContext)
/*++

Routine Description:

    Send the URB to the USB device.
	If synchronous is TRUE, ignore the completion info and synchonize the IRP;
    otherwise, don't synchronize and set the provided completion routine for the IRP.

Arguments:

    
Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;


    /*
     *  Allocate the IRP to send the buffer down the USB stack.
     *
     *  Don't use IoBuildDeviceIoControlRequest (because it queues
     *  the IRP on the current thread's irp list and may
     *  cause the calling process to hang if the IopCompleteRequest APC
     *  does not fire and dequeue the IRP).
     */
    irp = IoAllocateIrp(pdo->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp;

	    DBGVERBOSE(("SubmitUrb: submitting URB %ph on IRP %ph (sync=%d)", urb, irp, synchronous));

        nextSp = IoGetNextIrpStackLocation(irp);
	    nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	    nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	    /*
	     *  Attach the URB to this IRP.
	     */
        nextSp->Parameters.Others.Argument1 = urb;

        if (synchronous){

            status = CallDriverSync(pdo, irp);

		    IoFreeIrp(irp);
        }
        else {
            /*
             *  Caller's completion routine will free the irp 
             *  when it completes.
             */
            ASSERT(completionRoutine);
            ASSERT(completionContext);

            irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            IoSetCompletionRoutine( irp, 
                                    completionRoutine, 
                                    completionContext,
                                    TRUE, TRUE, TRUE);
            status = IoCallDriver(pdo, irp);
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return status;
}


NTSTATUS SubmitUrbIrp(  PDEVICE_OBJECT pdo, 
                        PIRP irp,
                        PURB urb, 
                        BOOLEAN synchronous, 
                        PVOID completionRoutine,
                        PVOID completionContext)
/*++

Routine Description:

    Send the URB to the USB device.
	If synchronous is TRUE, ignore the completion info and synchonize the IRP;
    otherwise, don't synchronize and set the provided completion routine for the IRP.

Arguments:

    
Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION nextSp;

	DBGVERBOSE(("SubmitUrb: submitting URB %ph on IRP %ph (sync=%d)", urb, irp, synchronous));

    nextSp = IoGetNextIrpStackLocation(irp);
	nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    irp->Cancel = FALSE;

	/*
	 *  Attach the URB to this IRP.
	 */
    nextSp->Parameters.Others.Argument1 = urb;

    if (synchronous){
        status = CallDriverSync(pdo, irp);
        ASSERT(!irp->CancelRoutine);
    }
    else {
        ASSERT(completionRoutine);
        ASSERT(completionContext);

        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoSetCompletionRoutine( irp, 
                                completionRoutine, 
                                completionContext,
                                TRUE, TRUE, TRUE);
        status = IoCallDriver(pdo, irp);
    }

    return status;
}


NTSTATUS SubmitUSBReadPacket(USBPACKET *packet)
{
    NTSTATUS status;
    PURB urb = packet->urbPtr;
    PIRP irp = packet->irpPtr;
    ULONG readLength;

    readLength = packet->dataBufferMaxLength;

    DBGVERBOSE(("SubmitUSBReadPacket: read %xh bytes, packet # %xh.", readLength, packet->packetId));

	urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
	urb->UrbBulkOrInterruptTransfer.PipeHandle = packet->adapter->readPipeHandle;
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength = readLength;
	urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
	urb->UrbBulkOrInterruptTransfer.TransferBuffer = packet->dataBuffer;
	urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
	urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    status = SubmitUrbIrp(  packet->adapter->nextDevObj, 
                            irp,
							urb, 
							FALSE,					// asynchronous
							ReadPipeCompletion,		// completion routine
							packet				    // completion context
				            );
    return status;
}



NTSTATUS ReadPipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
	USBPACKET *packet = (USBPACKET *)context;
    ADAPTEREXT *adapter = packet->adapter;
	NTSTATUS status = irp->IoStatus.Status;

	ASSERT(packet->sig == DRIVER_SIG);
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(packet->irpPtr == irp);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    /*
     *  Dequeue the packet from the usbPendingReadPackets queue 
     *  BEFORE checking if it was cancelled to avoid race with CancelAllPendingPackets.
     */
    DequeuePendingReadPacket(packet);

    if (packet->cancelled){
        /*
         *  This packet was cancelled because of a halt or reset.
         *  Get the packet is back in the free list first, then
         *  set the event so CancelAllPendingPackets can proceed.
         */
        DBGVERBOSE(("    ... read packet #%xh cancelled.", packet->packetId));
        packet->cancelled = FALSE;

        EnqueueFreePacket(packet);
        KeSetEvent(&packet->cancelEvent, 0, FALSE);
    }
    else if (adapter->halting){
        EnqueueFreePacket(packet);
    }
    else {
        PURB urb = packet->urbPtr;

        if (NT_SUCCESS(status)){
            BOOLEAN ethernetPacketComplete;

            adapter->numConsecutiveReadFailures = 0;

            /*
             *  Fix the packet's dataBufferCurrentLength to indicate the actual length
             *  of the returned data.
             *  Note:  the KLSI device rounds this up to a multiple of the endpoint
             *         packet size, so the returned length may actually be larger than
             *         the actual data.
             */
            packet->dataBufferCurrentLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
            ASSERT(packet->dataBufferCurrentLength);
            ASSERT(packet->dataBufferCurrentLength <= packet->dataBufferMaxLength);

            DBGVERBOSE(("ReadPipeCompletion: %xh bytes, packet # %xh.", packet->dataBufferCurrentLength, packet->packetId));

            ethernetPacketComplete = (packet->dataBufferCurrentLength >= MINIMUM_ETHERNET_PACKET_SIZE);

            if (ethernetPacketComplete){
                /*
                 *  A complete ethernet packet has been received.
                 *  The entire ethernet packet is now in the current (final) USB packet.
                 *  Put our USB packet on the completed list and indicate it to RNDIS.
                 */
                DBGSHOWBYTES("ReadPipeCompletion (COMPLETE packet)", packet->dataBuffer, packet->dataBufferCurrentLength);

                EnqueueCompletedReadPacket(packet);

                status = IndicateRndisMessage(packet, TRUE);
                if (status != STATUS_PENDING){
                    DequeueCompletedReadPacket(packet);
                    EnqueueFreePacket(packet);
                }
            }
            else {
                DBGWARN(("Device returned %xh-length packet @ %ph.", packet->dataBufferCurrentLength, packet->dataBuffer));
                DBGSHOWBYTES("ReadPipeCompletion (partial packet)", packet->dataBuffer, packet->dataBufferCurrentLength);
                EnqueueFreePacket(packet);
            }

            TryReadUSB(adapter);
        }
        else {
            KIRQL oldIrql;

            /*
             *  The read failed.  Put the packet back in the free list.
             */
            DBGWARN(("ReadPipeCompletion: read failed with status %xh on adapter %xh (urb status = %xh).", status, adapter, urb->UrbHeader.Status));
            #if DO_FULL_RESET
                switch (USBD_STATUS(urb->UrbBulkOrInterruptTransfer.Hdr.Status)){
                    case USBD_STATUS(USBD_STATUS_STALL_PID):
                    case USBD_STATUS(USBD_STATUS_DEV_NOT_RESPONDING):
                    case USBD_STATUS(USBD_STATUS_ENDPOINT_HALTED):
                        /*
                         *  Set a flag so we do a full reset in the workItem
                         *  (QueueAdapterWorkItem is called below)
                         */
                        adapter->needFullReset = TRUE;
                        break;
                }
            #endif

            EnqueueFreePacket(packet);

            /*
             *  We're probably halting or resetting.
             *  Don't reissue a read synchronously here because it will probably
             *  keep failing on the same thread and cause us to blow the stack.
             */
            KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
            adapter->numConsecutiveReadFailures++;
            adapter->readDeficit++;
            KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
            QueueAdapterWorkItem(adapter);
        }

    }

	return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS SubmitUSBWritePacket(USBPACKET *packet)
{
    NTSTATUS status;
    ADAPTEREXT *adapter = packet->adapter;
    PURB urb = packet->urbPtr;
    PIRP irp = packet->irpPtr;

    /*
     *  Some device USB controllers cannot detect the end of a transfer unless there
     *  is a short packet at the end.  So if the transfer is a multiple of the
     *  endpoint's wMaxPacketSize, add a byte to force a short packet at the end.
     */
    if ((packet->dataBufferCurrentLength % adapter->writePipeLength) == 0){
        packet->dataBuffer[packet->dataBufferCurrentLength++] = 0x00;
    }

    ASSERT(packet->dataBufferCurrentLength <= PACKET_BUFFER_SIZE);
    DBGVERBOSE(("SubmitUSBWritePacket: %xh bytes, packet # %xh.", packet->dataBufferCurrentLength, packet->packetId));
    DBGSHOWBYTES("SubmitUSBWritePacket", packet->dataBuffer, packet->dataBufferCurrentLength);

    urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb->UrbBulkOrInterruptTransfer.PipeHandle = adapter->writePipeHandle;
    urb->UrbBulkOrInterruptTransfer.TransferBufferLength = packet->dataBufferCurrentLength; 
    urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;   
    urb->UrbBulkOrInterruptTransfer.TransferBuffer = packet->dataBuffer; 
    urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_OUT;
    urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    status = SubmitUrbIrp(  adapter->nextDevObj, 
                            irp,
							urb, 
							FALSE,					// asynchronous
							WritePipeCompletion,    // completion routine
							packet				    // completion context
				            );

    if (!NT_SUCCESS(status)){
        DBGERR(("SubmitUSBWritePacket: packet @ %ph status %xh.", packet, status));
    }

    return status;
}



NTSTATUS WritePipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
	USBPACKET *packet = (USBPACKET *)context;
    ADAPTEREXT *adapter = packet->adapter;
	NTSTATUS status = irp->IoStatus.Status;
	KIRQL oldIrql;

	ASSERT(packet->sig == DRIVER_SIG);
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(packet->irpPtr == irp);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    if (NT_SUCCESS(status)){
        DBGVERBOSE(("WritePipeCompletion: packet # %xh completed.", packet->packetId));
    }
    else {
        DBGWARN(("WritePipeCompletion: packet # %xh failed with status %xh on adapter %xh.", packet->packetId, status, adapter));
    }

    IndicateSendStatusToRNdis(packet, status);

    /*
     *  Dequeue the packet from the usbPendingWritePackets queue 
     *  BEFORE checking if it was cancelled to avoid race with CancelAllPendingPackets.
     */
    DequeuePendingWritePacket(packet);

    if (packet->cancelled){
        /*
         *  This packet was cancelled because of a halt or reset.
         *  Put the packet back in the free list first, then 
         *  set the event so CancelAllPendingPackets can proceed.
         */
        DBGVERBOSE(("    ... write packet #%xh cancelled.", packet->packetId));
        packet->cancelled = FALSE;

        EnqueueFreePacket(packet);
        KeSetEvent(&packet->cancelEvent, 0, FALSE);
    }
    else {
        EnqueueFreePacket(packet);
    }


	return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS SubmitNotificationRead(ADAPTEREXT *adapter, BOOLEAN synchronous)
{
    NTSTATUS status;
    PURB urb = adapter->notifyUrbPtr;
    PIRP irp = adapter->notifyIrpPtr;
    ULONG guardWord = GUARD_WORD;
    KIRQL oldIrql;

    ASSERT(adapter->notifyPipeHandle);
    DBGVERBOSE(("SubmitNotificationRead: read %xh bytes.", adapter->notifyPipeLength));
    /*
     * Fill the notify buffer with invalid data just in case a device replies with
     * no data at all. A previously received valid message may still be there.
     * Apparently it won't be overwritten by the USB stack unless the device
     * supplies data.
     */
    RtlFillMemory(adapter->notifyBuffer, adapter->notifyPipeLength, 0xfe);

    /*
     *  Place a guard word at the end of the notify buffer
     *  to catch overwrites by the host controller (which we've seen).
     *  Use RtlCopyMemory in case pointer is unaligned.
     */
    RtlCopyMemory(adapter->notifyBuffer+adapter->notifyPipeLength, &guardWord, sizeof(ULONG));

    /*
     *  The notify pipe actually fills out a buffer with the fields given
     *  in the spec as URB fields.  Read the notify pipe like any interrupt pipe.
     */
	urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
	urb->UrbBulkOrInterruptTransfer.PipeHandle = adapter->notifyPipeHandle;
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength = adapter->notifyPipeLength;
	urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
	urb->UrbBulkOrInterruptTransfer.TransferBuffer = adapter->notifyBuffer;
	urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
	urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    adapter->notifyBufferCurrentLength = 0;
    adapter->notifyStopped = FALSE;
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    if (synchronous){
        status = SubmitUrbIrp(adapter->nextDevObj, irp, urb, TRUE, NULL, NULL);
    }
    else {
        status = SubmitUrbIrp(  adapter->nextDevObj, 
                                irp,
							    urb, 
							    FALSE,					    // asynchronous
							    NotificationCompletion,     // completion routine
							    adapter				        // completion context
                            );
    }

    return status;
}


NTSTATUS NotificationCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
    ADAPTEREXT *adapter = context;
    PURB urb = adapter->notifyUrbPtr;
	NTSTATUS status = irp->IoStatus.Status;
    BOOLEAN notifyStopped = FALSE;
    BOOLEAN setCancelEvent = FALSE;
    ULONG guardWord;
    KIRQL oldIrql;

    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(irp == adapter->notifyIrpPtr);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    /*
     *  Check the guard word at the end of the notify buffer
     *  to catch overwrites by the host controller
     *  (we've seen this on VIA host controllers).
     *  Use RtlCopyMemory in case pointer is unaligned.
     */
    RtlCopyMemory(&guardWord, adapter->notifyBuffer+adapter->notifyPipeLength, sizeof(ULONG));
    if (guardWord != GUARD_WORD){
        ASSERT(guardWord == GUARD_WORD);
        DBGERR(("NotificationCompletion: adapter %p, bad guard word 0x%x\n",
            adapter, guardWord));
#if DBG
        DbgBreakPoint();
#endif // DBG

    }

    /*
     *  In order to synchronize with CancelAllPendingPackets,
     *  we need to either send the irp down again, mark the notifyIrp as stopped,
     *  or set the notifyCancelEvent.
     */
    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    if (adapter->cancellingNotify){
        /*
         *  This irp was cancelled by CancelAllPendingPackets.
         *  After dropping the spinlock, we'll set the cancel event 
         *  so that CancelAllPendingPackets stops waiting.
         */
        notifyStopped = TRUE;
        setCancelEvent = TRUE;
    }
    else if (!NT_SUCCESS(status)){
        /*
         *  The notify irp can get failed on an unplug BEFORE we get the halted.
         *  Since we're not going to send the notify IRP down again, we need to 
         *  make sure that we don't wait for it forever in CancelAllPendingPackets.
         *  We do this by synchronously setting notifyStopped  
         *  as an indication that this irp doesn't need to be cancelled.
         */
        DBGWARN(("NotificationCompletion: read failed with status %xh on adapter %xh (urb status = %xh).", status, adapter, urb->UrbHeader.Status));
        notifyStopped = adapter->notifyStopped = TRUE;
    }
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);


    if (!notifyStopped){
        ULONG notifyLen = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

        ASSERT(notifyLen <= adapter->notifyPipeLength);
        adapter->notifyBufferCurrentLength = MIN(notifyLen, adapter->notifyPipeLength);

        RNDISProcessNotification(adapter);

        SubmitNotificationRead(adapter, FALSE);
    }

    if (setCancelEvent){
        DBGVERBOSE(("    ... notify read packet cancelled."));
        KeSetEvent(&adapter->notifyCancelEvent, 0, FALSE);
    }

	return STATUS_MORE_PROCESSING_REQUIRED;
}




NTSTATUS SubmitPacketToControlPipe( USBPACKET *packet,
                                    BOOLEAN synchronous,
                                    BOOLEAN simulated)
{
    NTSTATUS status;
    ADAPTEREXT *adapter = packet->adapter;
    PURB urb = packet->urbPtr;
    PIRP irp = packet->irpPtr;
    PUSBD_INTERFACE_INFORMATION interfaceInfoControl;

    DBGVERBOSE(("SubmitPacketToControlPipe: packet # %xh.", packet->packetId));
    DBGSHOWBYTES("SubmitPacketToControlPipe", packet->dataBuffer, packet->dataBufferCurrentLength);

    ASSERT(adapter->interfaceInfoMaster);
    interfaceInfoControl = adapter->interfaceInfoMaster;

    urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_CLASS_INTERFACE;  
    urb->UrbControlVendorClassRequest.Reserved = 0;
    urb->UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_OUT;
    urb->UrbControlVendorClassRequest.TransferBufferLength = packet->dataBufferCurrentLength;
    urb->UrbControlVendorClassRequest.TransferBuffer = packet->dataBuffer;
    urb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    urb->UrbControlVendorClassRequest.UrbLink = NULL;
    urb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
    urb->UrbControlVendorClassRequest.Request = NATIVE_RNDIS_SEND_ENCAPSULATED_COMMAND;
    urb->UrbControlVendorClassRequest.Value = 0;
    urb->UrbControlVendorClassRequest.Index = interfaceInfoControl->InterfaceNumber; 
    urb->UrbControlVendorClassRequest.Reserved1 = 0;

    if (synchronous){
        /*
         *  Send the URB down synchronously,
         *  then call the completion routine to clean up ourselves.
         */
        status = SubmitUrbIrp(adapter->nextDevObj, irp, urb, TRUE, NULL, NULL);
        if (!simulated){
            ControlPipeWriteCompletion(adapter->nextDevObj, irp, packet);
        }
    }
    else {
        status = SubmitUrbIrp(  adapter->nextDevObj,
                                irp,
							    urb,
							    FALSE,					// asynchronous
							    ControlPipeWriteCompletion,  // completion routine
							    packet				    // completion context
				                );
    }

    return status;
}


NTSTATUS ControlPipeWriteCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
	USBPACKET *packet = (USBPACKET *)context;
    ADAPTEREXT *adapter = packet->adapter;
	NTSTATUS status = irp->IoStatus.Status;
	KIRQL oldIrql;

	ASSERT(packet->sig == DRIVER_SIG);
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(packet->irpPtr == irp);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    if (NT_SUCCESS(status)){
        DBGVERBOSE(("ControlPipeWriteCompletion: packet # %xh completed.", packet->packetId));
    }
    else {
        DBGWARN(("ControlPipeWriteCompletion: packet # %xh failed with status %xh on adapter %xh.", packet->packetId, status, adapter));
    }

    IndicateSendStatusToRNdis(packet, status);

    /*
     *  Dequeue the packet from the usbPendingWritePackets queue 
     *  BEFORE checking if it was cancelled to avoid race with CancelAllPendingPackets.
     */
    DequeuePendingWritePacket(packet);

    if (packet->cancelled){
        /*
         *  This packet was cancelled because of a halt or reset.
         *  Put the packet back in the free list first, then 
         *  set the event so CancelAllPendingPackets can proceed.
         */
        DBGVERBOSE(("    ... write packet #%xh cancelled.", packet->packetId));
        packet->cancelled = FALSE;

        EnqueueFreePacket(packet);
        KeSetEvent(&packet->cancelEvent, 0, FALSE);
    }
    else {
        EnqueueFreePacket(packet);
    }

    if (NT_SUCCESS(status)){
    }
    else {
        #if DO_FULL_RESET
            adapter->needFullReset = TRUE;
            QueueAdapterWorkItem(adapter);
        #endif
    }

	return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS ReadPacketFromControlPipe(USBPACKET *packet, BOOLEAN synchronous)
{
    NTSTATUS status;
    ADAPTEREXT *adapter = packet->adapter;
    PURB urb = packet->urbPtr;
    PIRP irp = packet->irpPtr;
    PUSBD_INTERFACE_INFORMATION interfaceInfoControl;
    ULONG bytesToRead = MAXIMUM_DEVICE_MESSAGE_SIZE+1;

    DBGVERBOSE(("ReadPacketFromControlPipe: read %xh bytes, packet #%xh.", bytesToRead, packet->packetId));

    ASSERT(adapter->interfaceInfoMaster);
    interfaceInfoControl = adapter->interfaceInfoMaster;
  
    urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_CLASS_INTERFACE; 
    urb->UrbControlVendorClassRequest.Reserved = 0;
    urb->UrbControlVendorClassRequest.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
    urb->UrbControlVendorClassRequest.TransferBufferLength = bytesToRead;
    urb->UrbControlVendorClassRequest.TransferBuffer = packet->dataBuffer;
    urb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    urb->UrbControlVendorClassRequest.UrbLink = NULL;
    urb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
    urb->UrbControlVendorClassRequest.Request = NATIVE_RNDIS_GET_ENCAPSULATED_RESPONSE;
    urb->UrbControlVendorClassRequest.Value = 0;
    urb->UrbControlVendorClassRequest.Index = interfaceInfoControl->InterfaceNumber; 
    urb->UrbControlVendorClassRequest.Reserved1 = 0;

    if (synchronous){
        status = SubmitUrbIrp(adapter->nextDevObj, irp, urb, TRUE, NULL, NULL);
    }
    else {
        status = SubmitUrbIrp(  adapter->nextDevObj, 
                                irp,
							    urb, 
							    FALSE,					    // asynchronous
							    ControlPipeReadCompletion,  // completion routine
							    packet				        // completion context
				                );
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}



NTSTATUS ControlPipeReadCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
	USBPACKET *packet = (USBPACKET *)context;
    ADAPTEREXT *adapter = packet->adapter;
	NTSTATUS status = irp->IoStatus.Status;
	KIRQL oldIrql;

	ASSERT(packet->sig == DRIVER_SIG);
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(packet->irpPtr == irp);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    /*
     *  Dequeue the packet from the usbPendingReadPackets queue 
     *  BEFORE checking if it was cancelled to avoid race with CancelAllPendingPackets.
     */
    DequeuePendingReadPacket(packet);

    if (packet->cancelled){
        /*
         *  This packet was cancelled because of a halt or reset.
         *  Get the packet is back in the free list first, then
         *  set the event so CancelAllPendingPackets can proceed.
         */
        DBGVERBOSE(("    ... read packet #%xh cancelled.", packet->packetId));
        packet->cancelled = FALSE;

        EnqueueFreePacket(packet);
        KeSetEvent(&packet->cancelEvent, 0, FALSE);
    }
    else if (adapter->halting){
        EnqueueFreePacket(packet);
    }
    else {
        if (NT_SUCCESS(status)){
            PURB urb = packet->urbPtr;
            
            /*
             *  Fix the packet's dataBufferCurrentLength to indicate the actual length
             *  of the returned data.
             *  Note:  the KLSI device rounds this up to a multiple of the endpoint
             *         packet size, so the returned length may actually be larger than
             *         the actual data.
             */
            packet->dataBufferCurrentLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
            ASSERT(packet->dataBufferCurrentLength);
            ASSERT(packet->dataBufferCurrentLength <= packet->dataBufferMaxLength);

            DBGVERBOSE(("ControlPipeReadCompletion: packet # %xh.", packet->packetId));
            DBGSHOWBYTES("ControlPipeReadCompletion", packet->dataBuffer, packet->dataBufferCurrentLength);

            EnqueueCompletedReadPacket(packet);

            status = IndicateRndisMessage(packet, FALSE);

            if (status != STATUS_PENDING){
                DequeueCompletedReadPacket(packet);
                EnqueueFreePacket(packet);
            }
        }
        else {
            /*
             *  The read failed.  Put the packet back in the free list.
             */
            DBGWARN(("ControlPipeReadCompletion: read failed with status %xh on adapter %xh.", status, adapter));
            EnqueueFreePacket(packet);

            #if DO_FULL_RESET
                adapter->needFullReset = TRUE;
                QueueAdapterWorkItem(adapter);
            #endif
        }

    }


	return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(status != STATUS_PENDING);
    if (!NT_SUCCESS(status)){
        DBGWARN(("CallDriverSync: irp failed w/ status %xh.", status));
    }

    return status;
}


NTSTATUS CallDriverSyncCompletion(IN PDEVICE_OBJECT devObjOrNULL, IN PIRP irp, IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(!irp->CancelRoutine);

    if (!NT_SUCCESS(irp->IoStatus.Status)){
        DBGWARN(("CallDriverSyncCompletion: irp failed w/ status %xh.", irp->IoStatus.Status));
    }

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


#if 0
    NTSTATUS GetStringDescriptor(   ADAPTEREXT *adapter, 
                                    UCHAR stringIndex, 
                                    PUCHAR buffer, 
                                    ULONG bufferLen)
    /*++

    Routine Description:

        Function retrieves a string descriptor from the device

    Arguments:

        adapter - adapter context

    Return Value:

        NT status code

    --*/
    {
        URB urb;
        NTSTATUS status;

        UsbBuildGetDescriptorRequest(&urb,
                                     (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     stringIndex,
                                     0x0409,    // language = US English
                                     buffer,
                                     NULL,
                                     bufferLen,
                                     NULL);

        status = SubmitUrb(adapter->nextDevObj, &urb, TRUE, NULL, NULL);

        if (NT_SUCCESS(status)){
            DBGVERBOSE(("Got string desc (index %xh) @ %ph, len = %xh.", (ULONG)stringIndex, buffer, urb.UrbControlDescriptorRequest.TransferBufferLength));
            ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength <= bufferLen);
        }
        else {
            DBGERR(("GetStringDescriptor: failed to get string (index %xh) with status %xh on adapter %xh.", (ULONG)stringIndex, status, adapter));
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }


    /*
     *  CreateSingleInterfaceConfigDesc
     *
     *      Allocate a configuration descriptor that excludes all interfaces
     *  but the given interface
     *  (e.g. for multiple-interface devices like the Intel cable modem,
     *        for which we don't load on top of the generic parent).
     *
     *  Note:  interfaceDesc must point inside configDesc.
     *
     */
    PUSB_CONFIGURATION_DESCRIPTOR CreateSingleInterfaceConfigDesc(
                                    PUSB_CONFIGURATION_DESCRIPTOR configDesc, 
                                    PUSB_INTERFACE_DESCRIPTOR interfaceDesc)
    {
        PUSB_CONFIGURATION_DESCRIPTOR ifaceConfigDesc;
    
        ASSERT(interfaceDesc);
        ASSERT((PVOID)interfaceDesc > (PVOID)configDesc);
        ASSERT((PUCHAR)interfaceDesc - (PUCHAR)configDesc < configDesc->wTotalLength);

        ifaceConfigDesc = AllocPool(configDesc->wTotalLength);
        if (ifaceConfigDesc){
            PUSB_COMMON_DESCRIPTOR srcDesc, newDesc;
            USHORT totalLen;

            /*
             *  Copy the configuration descriptor itself.
             */
            RtlCopyMemory(ifaceConfigDesc, configDesc, configDesc->bLength);
            totalLen = configDesc->bLength;

            /*
             *  Copy the given interface descriptor.
             */
            srcDesc = (PUSB_COMMON_DESCRIPTOR)interfaceDesc;
            newDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)ifaceConfigDesc + ifaceConfigDesc->bLength);
            RtlCopyMemory(newDesc, srcDesc, srcDesc->bLength);
            totalLen += srcDesc->bLength;
            srcDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)srcDesc + srcDesc->bLength);
            newDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)newDesc + newDesc->bLength);

            /*
             *  Copy the given interface descriptors and all following descriptors
             *  up to either the next interface descriptor or the end of the original
             *  configuration descriptor.
             */
            while ((PUCHAR)srcDesc - (PUCHAR)configDesc < configDesc->wTotalLength){
                if (srcDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE){
                    break;
                }
                else {
                    RtlCopyMemory(newDesc, srcDesc, srcDesc->bLength);
                    totalLen += srcDesc->bLength;
                    srcDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)srcDesc + srcDesc->bLength);
                    newDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)newDesc + newDesc->bLength);
                }
            }

            ifaceConfigDesc->bNumInterfaces = 1;
            ifaceConfigDesc->wTotalLength = totalLen;
            DBGVERBOSE(("CreateSingleInterfaceConfigDesc: build partial configDesc @ %ph, len=%xh.", ifaceConfigDesc, ifaceConfigDesc->wTotalLength));
        }
    
        return ifaceConfigDesc;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\recovery.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    recovery.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


/*
 *  USB- and WDM- specific prototypes (won't compile in common header)
 */
NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);


/*
 *  ServiceReadDeficit
 *
 *      If we "owe" the BULK IN pipe some read packets, send them down now.
 */
VOID ServiceReadDeficit(ADAPTEREXT *adapter)
{
    ULONG numReadsToTry;
    KIRQL oldIrql;

    ASSERT(adapter->sig == DRIVER_SIG);

    /*
     *  If there is a read deficit, try to fulfill it now.
     *  Careful not to get into an infinite loop, since TryReadUSB
     *  will re-increment readDeficit if there are still no packets.
     */
    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    ASSERT(adapter->readDeficit <= NUM_READ_PACKETS);
    numReadsToTry = adapter->readDeficit;
    while ((adapter->readDeficit > 0) && (numReadsToTry > 0) && !adapter->halting){
        DBGWARN(("RndisReturnMessageHandler attempting to fill read DEFICIT (=%d)", adapter->readDeficit));

        adapter->readDeficit--;
        numReadsToTry--;

        KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
        TryReadUSB(adapter);
        KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    }
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


#if DO_FULL_RESET

    VOID AdapterFullResetAndRestore(ADAPTEREXT *adapter)
    {
        NTSTATUS status;

        DBGWARN(("AdapterFullResetAndRestore")); 

        adapter->numHardResets++;
        adapter->needFullReset = FALSE;

        if (adapter->halting){
            DBGWARN(("AdapterFullResetAndRestore - skipping since device is halting"));
        }
        else {
            ULONG portStatus;

            ASSERT(!adapter->resetting);
            adapter->resetting = TRUE;

            status = GetUSBPortStatus(adapter, &portStatus);
            if (NT_SUCCESS(status) && (portStatus & USBD_PORT_CONNECTED)){

                CancelAllPendingPackets(adapter);
           
                // RNDIS Halt seems to put the device out of whack until power cycle
                // SimulateRNDISHalt(adapter);

                AbortPipe(adapter, adapter->readPipeHandle);
                ResetPipe(adapter, adapter->readPipeHandle);

                AbortPipe(adapter, adapter->writePipeHandle);
                ResetPipe(adapter, adapter->writePipeHandle);

                if (adapter->notifyPipeHandle){
                    AbortPipe(adapter, adapter->notifyPipeHandle);
                    ResetPipe(adapter, adapter->notifyPipeHandle);
                }

                /*
                 *  Now, bring the adapter back to the run state 
                 *  if it was previously.
                 */
                if (adapter->initialized){

                    /*
                     *  Simulate RNDIS messages for INIT and set-packet-filter.
                     *  These simulation functions need to read and throw away
                     *  the response on the notify and control pipes, so do
                     *  this before starting the read loop on the notify pipe.
                     */
                    status = SimulateRNDISInit(adapter);
                    if (NT_SUCCESS(status)){
                        SimulateRNDISSetPacketFilter(adapter);
                        SimulateRNDISSetCurrentAddress(adapter);

                        /*
                         *  Restart the read loops.
                         */
                        if (adapter->notifyPipeHandle){
                            SubmitNotificationRead(adapter, FALSE);
                        }
                        StartUSBReadLoop(adapter);
                    }
                    else {
                        adapter->initialized = FALSE;
                    }
                }
            }
            else {
                DBGWARN(("AdapterFullResetAndRestore - skipping since device is no longer connected"));
            }

            adapter->resetting = FALSE;
        }

    }


    NTSTATUS GetUSBPortStatus(ADAPTEREXT *adapter, PULONG portStatus)
    {
        NTSTATUS status;
        PIRP irp;

        *portStatus = 0;

        irp = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
        if (irp){
            PIO_STACK_LOCATION nextSp;

            nextSp = IoGetNextIrpStackLocation(irp);
	        nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	        nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_GET_PORT_STATUS;
            nextSp->Parameters.Others.Argument1 = portStatus;
        
            status = CallDriverSync(adapter->nextDevObj, irp);

            IoFreeIrp(irp);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return status;
    }


    NTSTATUS AbortPipe(ADAPTEREXT *adapter, PVOID pipeHandle)
    {
        NTSTATUS status;
        PIRP irp;
        ULONG portStatus;

        status = GetUSBPortStatus(adapter, &portStatus);
        if (NT_SUCCESS(status) && (portStatus & USBD_PORT_CONNECTED)){

            irp = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
            if (irp){
                PIO_STACK_LOCATION nextSp;
                URB urb = {0};

                urb.UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
                urb.UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
                urb.UrbPipeRequest.PipeHandle = pipeHandle;

                nextSp = IoGetNextIrpStackLocation(irp);
	            nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	            nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
                nextSp->Parameters.Others.Argument1 = &urb;

                status = CallDriverSync(adapter->nextDevObj, irp);
                if (NT_SUCCESS(status)){
                }
                else {
                    DBGWARN(("AbortPipe failed with %xh (urb status %xh).", status, urb.UrbHeader.Status));
                }

                IoFreeIrp(irp);
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            DBGWARN(("AbortPipe - skipping abort because device not connected (status=%xh)", status));
            status = STATUS_SUCCESS;
        }

        return status;
    }


    NTSTATUS ResetPipe(ADAPTEREXT *adapter, PVOID pipeHandle)
    {
        NTSTATUS status;
        PIRP irp;
        ULONG portStatus;

        status = GetUSBPortStatus(adapter, &portStatus);
        if (NT_SUCCESS(status) && (portStatus & USBD_PORT_CONNECTED)){

            irp = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
            if (irp){
                PIO_STACK_LOCATION nextSp;
                URB urb = {0};

                urb.UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
                urb.UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
                urb.UrbPipeRequest.PipeHandle = pipeHandle;

                nextSp = IoGetNextIrpStackLocation(irp);
	            nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	            nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
                nextSp->Parameters.Others.Argument1 = &urb;

                status = CallDriverSync(adapter->nextDevObj, irp);
                if (NT_SUCCESS(status)){
                }
                else {
                    DBGWARN(("ResetPipe failed with %xh (urb status %xh).", status, urb.UrbHeader.Status));
                }

                IoFreeIrp(irp);
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            DBGWARN(("ResetPipe - skipping reset because device not connected (status=%xh)", status));
            status = STATUS_SUCCESS;
        }

        return status;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\usb8023.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb8023.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>


#include "usb8023.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
#endif



NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    BOOLEAN registered;
    PAGED_CODE();

    DBGVERBOSE(("DriverEntry")); 

    KeInitializeSpinLock(&globalSpinLock);
    InitializeListHead(&allAdaptersList);

    INITDEBUG();


	/*
	 *  Kernel drivers register themselves as the handler for 
	 *  AddDevice, UnloadDriver, and IRPs at this point.
     *  But instead, we'll register with RNDIS, so NDIS becomes the owner of all
     *  PDOs for which this driver is loaded.
	 */
    registered = RegisterRNDISMicroport(DriverObject, RegistryPath);

    ASSERT(registered);
    return (registered) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\callout.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CALLOUT.C - Functions to call out to external components to install
//        devices
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"

/*******************************************************************

  NAME:    InstallTCPIP

  SYNOPSIS:  Installs MS TCP/IP 

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    calls through thunk layer to 16-bit side which calls
        Device Manager

********************************************************************/
UINT InstallTCPIP(HWND hwndParent)
{
  WAITCURSOR WaitCursor;  // waitcursor object for hourglassing

  // call down to 16-bit dll to do this
  return InstallComponent(hwndParent,IC_TCPIP,0);
}

/*******************************************************************

  NAME:    InstallPPPMAC

  SYNOPSIS:  Installs PPPMAC (PPP driver)

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    calls through thunk layer to 16-bit side which calls
        Device Manager

********************************************************************/
UINT InstallPPPMAC(HWND hwndParent)
{
  WAITCURSOR WaitCursor;  // waitcursor object for hourglassing

  // call down to 16-bit dll to do this
  return InstallComponent(hwndParent,IC_PPPMAC,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\sources.inc ===
CM_BUILD_ROOT=$(CM_ROOT)\build\$(_OBJ_DIR)

INCLUDES=$(CM_ROOT)\inc;\
    $(CM_ROOT)\common\inc;\
    $(CM_ROOT)\common\source;\
    $(CM_ROOT)\common\strings;\
    $(CM_ROOT)\common\rc

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!endif

!if "$(DEBUG_MEM)" == "1"
DEBUG_MEM=1
C_DEFINES=$(C_DEFINES) -DDEBUG_MEM
!endif

!if "$(DEBUG_TRACETIME)" == "1"
DEBUG_TRACETIME=1
C_DEFINES=$(C_DEFINES) -DDEBUG_TRACETIME
!endif

!if "$(EMULATE9x)" == "1"
C_DEFINES=$(C_DEFINES) -DEMULATE9x
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\cfgapi.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************

//
//  CFGAPI.C - Functions for exported config API.
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Added lpGetLastInstallErrorText.
//

#include "pch.hpp"

UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,BOOL fRemove,BOOL * pfBound);


//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

extern "C" DWORD IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc)
{
  if (lpszErrorDesc)
  {
    lstrcpyn(lpszErrorDesc, gpszLastErrorText, cbErrorDesc);
    return lstrlen(lpszErrorDesc);
  }
  else
  {
    return 0;
  }
}


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  History:	5/8/97 ChrisK Added INSTALLLAN,INSTALLDIALUP,INSTALLTCPONLY
//
//*******************************************************************

extern "C" HRESULT IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents)
{
  CLIENTCONFIG  ClientConfig;

  DEBUGMSG("cfgapi.c::IcfgNeedInetComponents()");

  ASSERT(lpfNeedComponents);

  // read client configuration
  ZeroMemory(&ClientConfig,sizeof(CLIENTCONFIG));
  DWORD dwErrCls;
  UINT err=GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    PrepareErrorMessage(IDS_ERRReadConfig,(UINT) err,
      dwErrCls,MB_ICONEXCLAMATION);
    return err;
  }

  // check if we are allowed to install TCP/IP
  if (dwfOptions & ICFG_INSTALLTCP)
  {
    // need TCP/IP present and bound to PPP driver
    if (!ClientConfig.fPPPBoundTCP)
    {
      if (lpfNeedComponents)
      {
        *lpfNeedComponents = TRUE;
      }
      return ERROR_SUCCESS;
    }
  }

  // check if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // need PPPMAC and RNA files if using modem
    if (!ClientConfig.fRNAInstalled ||
      !ClientConfig.fPPPDriver)
    {
      if (lpfNeedComponents)
      {
        *lpfNeedComponents = TRUE;
      }
      return ERROR_SUCCESS;
    }
  }

  // need Exchange if not installed and user wants to install mail
  if ((dwfOptions & ICFG_INSTALLMAIL) &&
    (!ClientConfig.fMailInstalled || !ClientConfig.fInetMailInstalled))
  {
    if (lpfNeedComponents)
    {
      *lpfNeedComponents = TRUE;
    }
    return ERROR_SUCCESS;
  }

  //
  // ChrisK	5/8/97
  // check if we have a bound LAN adapter
  //
  if (dwfOptions & ICFG_INSTALLLAN)
  {
	  if (!ClientConfig.fNetcard ||
		  !ClientConfig.fNetcardBoundTCP)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  //
  // ChrisK	5/8/97
  // Check if we have a bound Dial up adapter
  //
  if (dwfOptions & ICFG_INSTALLDIALUP)
  {
	  if (!ClientConfig.fPPPDriver ||
		  !ClientConfig.fPPPBoundTCP)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  //
  // ChrisK	5/8/97
  // Check if TCP is install at all on this system
  //
  if (dwfOptions & ICFG_INSTALLTCPONLY)
  {
	  if (!ClientConfig.fTcpip)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  // no extra drivers needed
  if (lpfNeedComponents)
  {
    *lpfNeedComponents = FALSE;
  }
  return ERROR_SUCCESS;
}


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//              
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart)
{
  RETERR err;
  DWORD dwFiles = 0;
  BOOL  fInitNetMAC = FALSE;
  BOOL  fNeedTCPIP=FALSE;
  BOOL  fNeedPPPMAC=FALSE;
  BOOL  fNeedToRemoveTCPIP=FALSE;
  BOOL  fNeedReboot = FALSE;
  DWORD dwErrCls;
  CLIENTCONFIG  ClientConfig;

  DEBUGMSG("cfgapi.c::IcfgInstallInetComponents()");

  // read client configuration
  ZeroMemory(&ClientConfig,sizeof(CLIENTCONFIG));
  err=GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    PrepareErrorMessage(IDS_ERRReadConfig,(UINT) err,
      dwErrCls,MB_ICONEXCLAMATION);
    return err;
  }

  // see if we initially have any kind of net card
  fInitNetMAC = (ClientConfig.fNetcard | ClientConfig.fPPPDriver);

  // install files we need

  // install mail if user wants it and not already installed
  if (dwfOptions & ICFG_INSTALLMAIL)
  {
    // need mail files (capone)? 
    if (!ClientConfig.fMailInstalled)
    {
      DEBUGMSG("Installing Exchange files");
      dwFiles |= ICIF_MAIL;
    }

    // need internet mail files (rt 66)?
    if (!ClientConfig.fInetMailInstalled)
    {
      DEBUGMSG("Installing Internet Mail files");
      dwFiles |= ICIF_INET_MAIL;
    }
  }

  // check if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // install RNA if user is connecting over modem and RNA
    // not already installed
    if (!ClientConfig.fRNAInstalled)
    {
      DEBUGMSG("Installing RNA files");
      dwFiles |= ICIF_RNA;
    }
  }

  if (dwFiles)
  {
    {
      WAITCURSOR WaitCursor;  // show hourglass
      // install the component files
      err = InstallComponent(hwndParent,IC_INSTALLFILES,
        dwFiles);
      if (err == NEED_RESTART)
      {
        DEBUGMSG("Setting restart flag");
        // set restart flag so we restart the system at end
        fNeedReboot = TRUE;
        // NEED_REBOOT also implies success, so set ret code to OK
        err = OK;
      }

      // force an update of the dialog
      if (hwndParent)
      {
        HWND hParent = GetParent(hwndParent);
        UpdateWindow(hParent ? hParent : hwndParent);
      }

      // runonce.exe may get run at next boot, twiddle the
      // registry to work around a bug where it trashes the wallpaper
      PrepareForRunOnceApp();
    }

    if (err != OK)
    {
      PrepareErrorMessage(IDS_ERRInstallFiles,(UINT) err,
        ERRCLS_SETUPX,MB_ICONEXCLAMATION);
      return err;
    }

    WAITCURSOR WaitCursor;  // show hourglass

    // do some extra stuff if we just installed mail
    if (dwFiles & ICIF_MAIL)
    {
      // .inf file leaves an entry in the registry to run
      // MS Exchange wizard, which we don't need since we'll be
      // configuring exchange ourselves.  Remove the registry
      // entry.
      RemoveRunOnceEntry(IDS_MAIL_WIZARD_REG_VAL);

      // run mlset32, Exchange setup app that it needs to have run.
      // need to display error if this fails, this is fairly important.
      err=RunMlsetExe(hwndParent);
      if (err != ERROR_SUCCESS)
      {
        PrepareErrorMessage(IDS_ERRInstallFiles,(UINT) err,
          ERRCLS_STANDARD,MB_ICONEXCLAMATION);
        return err;
      }
    }

    // run the group converter to put the Inbox icon on desktop,
    // put Exchange, RNA et al on start menu
    CHAR szExecGrpconv[SMALL_BUF_LEN],szParam[SMALL_BUF_LEN];
    LoadSz(IDS_EXEC_GRPCONV,szExecGrpconv,sizeof(szExecGrpconv));
    LoadSz(IDS_EXEC_GRPCONV_PARAM,szParam,sizeof(szParam));
    ShellExecute(NULL,NULL,szExecGrpconv,szParam,NULL,SW_SHOW);

  }

  // only install PPPMAC if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // install PPPMAC if not already installed
    // Note that we have to install PPPMAC *before* TCP/IP, to work
    // in the case where the user has no net installed to start with.
    // Otherwise when we install TCP/IP, user gets prompted by net setup
    // for their net card; net setup doesn't like the idea of TCP/IP lying
    // around without something to bind it to.
    fNeedPPPMAC = (!ClientConfig.fPPPDriver);
    if (fNeedPPPMAC)
    {
      DEBUGMSG("Installing PPPMAC");

      // make up a computer and workgroup name if not already set, so
      // user doesn't get prompted
      GenerateComputerNameIfNeeded();
      
      err = InstallPPPMAC(hwndParent);

      //  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing PPPMAC.

	  //
	  // ChrisK 5/29/97 Olympus 4692
	  // Even if we just rebind PPPMAC we still need to restart the machine.
	  //
      if (err == NEED_RESTART || err == OK)
      {
        // set restart flag so we restart the system at end
        DEBUGMSG("Setting restart flag");
        fNeedReboot = TRUE;

        // NEED_REBOOT also implies success, so set ret code to OK
        err = OK;
      }

      if (err != OK)
      {
        PrepareErrorMessage(IDS_ERRInstallPPPMAC,(UINT) err,
          ERRCLS_SETUPX,MB_ICONEXCLAMATION);
        return err;
      }

      // when we install PPPMAC, if there is another net card then PPPMAC
      // will automatically "grow" all the protocols that were bound to the
      // net card.  Strip these off... (netbeui and IPX)
      RETERR errTmp = RemoveProtocols(hwndParent,INSTANCE_PPPDRIVER,
        PROT_NETBEUI | PROT_IPX);
      ASSERT(errTmp == OK);
    }
  }

  // check if we are allowed to install TCP/IP
  if (dwfOptions & ICFG_INSTALLTCP)
  {
    // figure out if we need to install TCP/IP
    // we should only put TCP/IP on appropriate type of card (net card
    // or PPP adapter)
    // user is connecting via modem, need TCP if not already present
    // and bound to PPPMAC.  Want to bind to PPP adapters, 

    //
    // As of W98, PPPMAC install also binds TCP/IP to dial-up adapter. Re-read 
    // the config using a temporary instance of the structure to determine if
    // we still need the binding. 
    // nickball - 03/03/99 - Olympus #49008, Memphis #88375, NT #180684.
    //

    CLIENTCONFIG  TmpConfig;
    ZeroMemory(&TmpConfig,sizeof(CLIENTCONFIG));

	err=GetConfig(&TmpConfig,&dwErrCls);

    if (err != OK)
    {
      PrepareErrorMessage(IDS_ERRReadConfig,(UINT) err,
        dwErrCls,MB_ICONEXCLAMATION);
      return err;
    }

    fNeedTCPIP = !TmpConfig.fPPPBoundTCP;
    
    if (fNeedTCPIP && ClientConfig.fNetcard &&
      !ClientConfig.fNetcardBoundTCP)
    {
      // if we have to add TCP to PPP driver, then check if TCP is already
      // on netcard.  If not, then TCP is going to glom on to netcard as
      // well as PPP driver when we install it, need to remove it from
      // netcard later.
      fNeedToRemoveTCPIP= TRUE;
    }

    // special case: if there were any existing instances of TCP/IP and
    // we just added PPPMAC then we don't need to install TCP/IP --
    // when the PPPMAC adapter got added it automatically gets an instance
    // of all installed protocols (incl. TCP/IP) created for it
    if (ClientConfig.fTcpip && fNeedPPPMAC)
    {
      fNeedTCPIP = FALSE;
    }
  } // if (dwfOptions & ICFG_INSTALLTCP)

  // install TCP/IP if necessary
  if (fNeedTCPIP)
  {
    DEBUGMSG("Installing TCP/IP");
    // call out to device manager to install TCP/IP
    err = InstallTCPIP(hwndParent);      

    //  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing TCP/IP.
    if (err == NEED_RESTART)
    {
      // NEED_REBOOT also implies success, so set ret code to OK
      // Reboot flag is set below ALWAYS.  Should really be set here,
      // but we don't want to suddenly stop rebooting in cases
      // where we used to reboot, even if not needed.
      err = OK;
    }

     if (err != OK)
     {
      PrepareErrorMessage(IDS_ERRInstallTCPIP,(UINT) err,
        ERRCLS_SETUPX,MB_ICONEXCLAMATION);
      return err;
    }

    if (fNeedToRemoveTCPIP)
    {
      // remove TCPIP that may have glommed onto net drivers other
      // than the one we intend it for
      UINT uErrTmp;
      uErrTmp=RemoveProtocols(hwndParent,INSTANCE_NETDRIVER,PROT_TCPIP);
      ASSERT(uErrTmp == OK);
    }

    DEBUGMSG("Setting restart flag");
    // set restart flag so we restart the system at end
    fNeedReboot = TRUE;
  }

  // if we just installed TCP/IP or PPPMAC, then adjust bindings 
  if (fNeedPPPMAC || fNeedTCPIP)
  {
    UINT uErrTmp;

    // if file sharing (vserver) is installed, TCP/IP will bind
    // to it by default.  This is bad, user could be sharing
    // files to Internet without knowing it.  Unbind VSERVER
    // from TCP/IP instances that may used to connect to Internet
    // (instances of type INSTANCE_PPPDRIVER)
    uErrTmp = IcfgTurnOffFileSharing(INSTANCE_PPPDRIVER, hwndParent);
    ASSERT (uErrTmp == ERROR_SUCCESS);

    // unbind TCP/IP from VREDIR, if bound on this card type
    BOOL fBound;
    uErrTmp = DetectModifyTCPIPBindings(INSTANCE_PPPDRIVER,szVREDIR,
      TRUE,&fBound);
    ASSERT(uErrTmp == ERROR_SUCCESS);
  }

  // refresh the client configuration info
  err = GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    PrepareErrorMessage(IDS_ERRReadConfig,(UINT) err,
      dwErrCls,MB_ICONEXCLAMATION);
    return err;
  }

  // do some special handling if there were *no* netcard devices
  // (net cards or PPP drivers) initially installed
  if (!fInitNetMAC)
  {
    ASSERT(fNeedPPPMAC);  // should have just installed PPPMAC

    // net setup adds some extra net components "by default" when
    // we add PPPMAC and there are no net card devices, go kill them
    // off.
    RETERR reterr = RemoveUnneededDefaultComponents(hwndParent);
    ASSERT(reterr == OK);

    // since there were no net card devices to begin with, we need
    // to restart the system later.  (the NDIS VxD is a static VxD
    // which needs to run, only gets added when you install a net card.)

    DEBUGMSG("Setting restart flag");
    // set restart flag so we restart the system at end
    fNeedReboot = TRUE;
  }

  // tell caller whether we need to reboot or not
  if (lpfNeedsRestart)
  {
    *lpfNeedsRestart = fNeedReboot;
  }
  return ERROR_SUCCESS;
}


/*******************************************************************

  NAME:    GetConfig

  SYNOPSIS:  Retrieves client configuration

********************************************************************/
UINT GetConfig(CLIENTCONFIG * pClientConfig,DWORD * pdwErrCls)
{
  ASSERT(pClientConfig);
  ASSERT(pdwErrCls);

  // get most the client configuration from 16-bit dll
  UINT uRet = GetClientConfig(pClientConfig);
  if (uRet != OK) {
    // GetClientConfig returns SETUPX error codes
    *pdwErrCls = ERRCLS_SETUPX;
  } 

  return uRet;
}

//*******************************************************************
//
//  FUNCTION:   IcfgStartServices
//
//  PURPOSE:    This is a NOP designed to maintain parity with the NT
//              version (icfgnt.dll).
//
//  PARAMETERS: none
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgStartServices()
{
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\usb8023.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb8023.h


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


/*
 *  If this flag is defined TRUE, then when an endpoint on the device stalls, 
 *  we will do a full USB port reset
 *  and then restore the device to a running state.
 *  Otherwise, we just send the RNDIS Reset message to the control pipe.
 */
#define DO_FULL_RESET TRUE 



#define DRIVER_SIG '208U'
#define GUARD_WORD 'draG'

#define  NUM_BYTES_PROTOCOL_RESERVED_SECTION    16
#define DEFAULT_MULTICAST_SIZE                  16


/*
 *  Total number of our irp/urb packets for sending/receiving 
 *  ethernet frames to/from the device.
 */
#define USB_PACKET_POOL_SIZE                    32

#define PACKET_BUFFER_SIZE                      0x4000  

/*
 *  The USB host controller can typically schedule 2 URBs at a time.
 *  To keep the hardware busy, keep twice this many read URBs in the pipe.
 */
#define NUM_READ_PACKETS                        (2*2)

/*
 *  - Ethernet 14-byte Header
 */
#define ETHERNET_ADDRESS_LENGTH  6
#pragma pack(1)
    typedef struct {
        UCHAR       Destination[ETHERNET_ADDRESS_LENGTH];
        UCHAR       Source[ETHERNET_ADDRESS_LENGTH];
        USHORT      TypeLength;     // note: length appears as big-endian in packet.
    } ETHERNET_HEADER;
#pragma pack()

#define MINIMUM_ETHERNET_PACKET_SIZE    60    // from e100bex driver
#define MAXIMUM_ETHERNET_PACKET_SIZE    (1500+sizeof(ETHERNET_HEADER))  // 1514 == 0x05EA

/*
 *  This is the size of a read on the control pipe.
 *  It needs to be large enough for the init-complete message and response to
 *  OID_GEN_SUPPORTED_LIST.
 */
#define MAXIMUM_DEVICE_MESSAGE_SIZE     0x400



typedef struct {

    ULONG sig;

    LIST_ENTRY adaptersListEntry;
    KSPIN_LOCK adapterSpinLock;  

    PDEVICE_OBJECT physDevObj;
    PDEVICE_OBJECT nextDevObj;

    /*
     *  All USB structures and handles must be declared as neutral types in order
     *  to compile with the NDIS/RNDIS sources.
     */
    PVOID deviceDesc;                       // PUSB_DEVICE_DESCRIPTOR
    PVOID configDesc;                       // PUSB_CONFIGURATION_DESCRIPTOR
    PVOID configHandle;                     // USBD_CONFIGURATION_HANDLE    
    PVOID interfaceInfo;                    // PUSBD_INTERFACE_INFORMATION
    PVOID interfaceInfoMaster;              // PUSBD_INTERFACE_INFORMATION

    BOOLEAN initialized;
    BOOLEAN halting;
    BOOLEAN resetting;
    BOOLEAN gotPacketFilterIndication;

    PVOID readPipeHandle;                   // USBD_PIPE_HANDLE
    PVOID writePipeHandle;                  // USBD_PIPE_HANDLE
    PVOID notifyPipeHandle;                 // USBD_PIPE_HANDLE

    ULONG readPipeLength;
    ULONG writePipeLength;
    ULONG notifyPipeLength;
   
    UCHAR readPipeEndpointAddr;
    UCHAR writePipeEndpointAddr;
    UCHAR notifyPipeEndpointAddr;

    LIST_ENTRY usbFreePacketPool;           // free packet pool
    LIST_ENTRY usbPendingReadPackets;       // reads down in the USB stack
    LIST_ENTRY usbPendingWritePackets;      // writes down in the usb stack
    LIST_ENTRY usbCompletedReadPackets;     // completed read buffers being indicated to NDIS
    
    /*
     *  Keep statistics on packet states for throttling, etc.
     *  Some fields are used only to provide history for debugging, 
     *  and we want these for retail as well as debug version.
     */
    ULONG numFreePackets;
    ULONG numActiveReadPackets;
    ULONG numActiveWritePackets;
    ULONG numIndicatedReadPackets;
    ULONG numHardResets;
    ULONG numSoftResets;
    ULONG numConsecutiveReadFailures;

    PVOID notifyIrpPtr;
    PVOID notifyUrbPtr;
    PUCHAR notifyBuffer;
    ULONG notifyBufferCurrentLength;
    BOOLEAN notifyStopped;
    BOOLEAN cancellingNotify;
    KEVENT notifyCancelEvent;

    
    /*
     *  All NDIS handles must be declared as neutral types
     *  in order to compile with the USB sources.
     */
    PVOID ndisAdapterHandle;
    PVOID rndisAdapterHandle;   // RNDIS_HANDLE

    ULONG rndismpMajorVersion;
    ULONG rndismpMinorVersion;
    ULONG rndismpMaxTransferSize;
    ULONG currentPacketFilter;
    UCHAR MAC_Address[ETHERNET_ADDRESS_LENGTH];

    ULONG dbgCurrentOid;
    ULONG readDeficit;

    PIO_WORKITEM ioWorkItem;
    BOOLEAN workItemOrTimerPending;
    KEVENT workItemOrTimerEvent;
    KTIMER backoffTimer;
    KDPC backoffTimerDPC;

    ULONG readReentrancyCount;  // used to prevent infinite loop in ReadPipeCompletion()
    
    #if DO_FULL_RESET
        BOOLEAN needFullReset;
    #endif

    #if DBG
        BOOLEAN dbgInLowPacketStress;
    #endif

    #ifdef RAW_TEST
    BOOLEAN rawTest;
    #endif

} ADAPTEREXT;


typedef struct {

    ULONG sig;
    LIST_ENTRY listEntry;

    /*
     *  All WDM and USB structures must be declared as neutral types 
     *  in order to compile with the NDIS/RNDIS sources.
     */
    PVOID irpPtr;                  // PIRP
    PVOID urbPtr;                  // PURB

    PUCHAR dataBuffer;                 
    ULONG dataBufferMaxLength;         // Actual size of the data buffer
    ULONG dataBufferCurrentLength;     // Length of data currently in buffer
    PMDL dataBufferMdl;                 // MDL for this packet's dataBuffer

    PMDL ndisSendPktMdl;               // Pointer to NDIS' MDL for a packet being sent. 

    ULONG packetId;
    ADAPTEREXT *adapter;

    BOOLEAN cancelled;
    KEVENT cancelEvent;

    PVOID rndisMessageHandle;       // RNDIS_HANDLE

    #ifdef RAW_TEST
    BOOLEAN dataPacket;
    ULONG rcvDataOffset;
    ULONG rcvByteCount;
    #endif

    #if DBG
        ULONG timeStamp;                // Time placed in current queue.
    #endif

} USBPACKET;




#define USB_DEVICE_CLASS_CDC                                    0x02
#define USB_DEVICE_CLASS_DATA                                   0x0A


/*
 *  Formats of CDC functional descriptors
 */
#pragma pack(1)
    struct cdcFunctionDescriptor_CommonHeader {
        UCHAR bFunctionLength;
        UCHAR bDescriptorType;
        UCHAR bDescriptorSubtype;
        // ...
    };
    struct cdcFunctionDescriptor_Ethernet {
        UCHAR bFunctionLength;
        UCHAR bDescriptorType;
        UCHAR bDescriptorSubtype;
        UCHAR iMACAddress;          // string index of MAC Address string
        ULONG bmEthernetStatistics;
        USHORT wMaxSegmentSize;
        USHORT wNumberMCFilters;
        UCHAR bNumberPowerFilters;
    };
#pragma pack()

#define CDC_REQUEST_SET_ETHERNET_PACKET_FILTER                  0x43

#define CDC_ETHERNET_PACKET_TYPE_PROMISCUOUS                    (1 << 0)
#define CDC_ETHERNET_PACKET_TYPE_ALL_MULTICAST                  (1 << 1)
#define CDC_ETHERNET_PACKET_TYPE_DIRECTED                       (1 << 2)
#define CDC_ETHERNET_PACKET_TYPE_BROADCAST                      (1 << 3)
#define CDC_ETHERNET_PACKET_TYPE_MULTICAST_ENUMERATED           (1 << 4)

enum notifyRequestType {
        CDC_NOTIFICATION_NETWORK_CONNECTION          = 0x00,
        CDC_NOTIFICATION_RESPONSE_AVAILABLE          = 0x01,
        CDC_NOTIFICATION_AUX_JACK_HOOK_STATE         = 0x08,
        CDC_NOTIFICATION_RING_DETECT                 = 0x09,
        CDC_NOTIFICATION_SERIAL_STATE                = 0x20,
        CDC_NOTIFICATION_CALL_STATE_CHANGE           = 0x28,
        CDC_NOTIFICATION_LINE_STATE_CHANGE           = 0x29,
        CDC_NOTIFICATION_CONNECTION_SPEED_CHANGE     = 0x2A
    };

#define CDC_RNDIS_NOTIFICATION              0xA1
#define CDC_RNDIS_RESPONSE_AVAILABLE        0x01

#pragma pack(1)
    struct cdcNotification_CommonHeader {
        UCHAR bmRequestType;
        UCHAR bNotification;
        USHORT wValue;
        USHORT wIndex;
        USHORT wLength;
        UCHAR data[0];
    };
#pragma pack()



/*
 *
 ****************************************************************************
 */



/*
 ****************************************************************************
 *
 *  Native RNDIS codes
 *
 */

#define NATIVE_RNDIS_SEND_ENCAPSULATED_COMMAND      0x00
#define NATIVE_RNDIS_GET_ENCAPSULATED_RESPONSE      0x01

#define NATIVE_RNDIS_RESPONSE_AVAILABLE             0x01

/*
 *
 ****************************************************************************
 */




#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
#define MIN(a, b) (((a) <= (b)) ? (a) : (b))

#ifndef EXCEPTION_NONCONTINUABLE_EXCEPTION
    // from winbase.h
    #define EXCEPTION_NONCONTINUABLE_EXCEPTION  STATUS_NONCONTINUABLE_EXCEPTION
#endif

// from ntos\inc\ex.h
NTKERNELAPI VOID NTAPI ExRaiseException(PEXCEPTION_RECORD ExceptionRecord);

/*
 *  Function prototypes
 */
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
ADAPTEREXT *NewAdapter(PDEVICE_OBJECT pdo);
VOID FreeAdapter(ADAPTEREXT *adapter);
VOID EnqueueAdapter(ADAPTEREXT *adapter);
VOID DequeueAdapter(ADAPTEREXT *adapter);
VOID HaltAdapter(ADAPTEREXT *adapter);
PVOID AllocPool(ULONG size);
VOID FreePool(PVOID ptr);
PVOID MemDup(PVOID dataPtr, ULONG length);
VOID DelayMs(ULONG numMillisec);
BOOLEAN GetRegValue(ADAPTEREXT *adapter, PWCHAR wValueName, OUT PULONG valuePtr, BOOLEAN hwKey);
BOOLEAN SetRegValue(ADAPTEREXT *adapter, PWCHAR wValueName, ULONG newValue, BOOLEAN hwKey);
VOID ByteSwap(PUCHAR buf, ULONG len);
BOOLEAN AllocateCommonResources(ADAPTEREXT *adapter);
VOID MyInitializeMdl(PMDL mdl, PVOID buf, ULONG bufLen);
PVOID GetSystemAddressForMdlSafe(PMDL MdlAddress);
ULONG CopyMdlToBuffer(PUCHAR buf, PMDL mdl, ULONG bufLen);
ULONG GetMdlListTotalByteCount(PMDL mdl);

BOOLEAN InitUSB(ADAPTEREXT *adapter);
NTSTATUS GetDeviceDescriptor(ADAPTEREXT *adapter);
NTSTATUS GetConfigDescriptor(ADAPTEREXT *adapter);
NTSTATUS SelectConfiguration(ADAPTEREXT *adapter);
NTSTATUS FindUSBPipeHandles(ADAPTEREXT *adapter);
VOID StartUSBReadLoop(ADAPTEREXT *adapter);
VOID TryReadUSB(ADAPTEREXT *adapter);

USBPACKET *NewPacket(ADAPTEREXT *adapter);
VOID FreePacket(USBPACKET *packet);
VOID EnqueueFreePacket(USBPACKET *packet);
USBPACKET *DequeueFreePacket(ADAPTEREXT *adapter);
VOID EnqueuePendingReadPacket(USBPACKET *packet);
VOID DequeuePendingReadPacket(USBPACKET *packet);
VOID EnqueuePendingWritePacket(USBPACKET *packet);
VOID DequeuePendingWritePacket(USBPACKET *packet);
VOID EnqueueCompletedReadPacket(USBPACKET *packet);
VOID DequeueCompletedReadPacket(USBPACKET *packet);
VOID CancelAllPendingPackets(ADAPTEREXT *adapter);

NTSTATUS SubmitUSBReadPacket(USBPACKET *packet);
NTSTATUS SubmitUSBWritePacket(USBPACKET *packet);
NTSTATUS SubmitNotificationRead(ADAPTEREXT *adapter, BOOLEAN synchronous);
NTSTATUS SubmitPacketToControlPipe(USBPACKET *packet, BOOLEAN synchronous, BOOLEAN simulated);

BOOLEAN RegisterRNDISMicroport(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
VOID IndicateSendStatusToRNdis(USBPACKET *packet, NTSTATUS status);

NTSTATUS KLSIWeirdInit(ADAPTEREXT *adapter);
BOOLEAN KLSIStagePartialPacket(ADAPTEREXT *adapter, USBPACKET *packet);
NTSTATUS KLSISetEthernetPacketFilter(ADAPTEREXT *adapter, USHORT packetFilterMask);

VOID RNDISProcessNotification(ADAPTEREXT *adapter);
NTSTATUS IndicateRndisMessage(USBPACKET *packet, BOOLEAN bIsData);

#ifdef RAW_TEST
PMDL AddDataHeader(IN PMDL pMessageMdl);
VOID FreeDataHeader(IN USBPACKET * packet);
VOID SkipRcvRndisPacketHeader(IN USBPACKET * packet);
VOID UnskipRcvRndisPacketHeader(IN USBPACKET * packet);
#endif
NTSTATUS ReadPacketFromControlPipe(USBPACKET *packet, BOOLEAN synchronous);

VOID AdapterFullResetAndRestore(ADAPTEREXT *adapter);
NTSTATUS GetUSBPortStatus(ADAPTEREXT *adapter, PULONG portStatus);
NTSTATUS ResetPipe(ADAPTEREXT *adapter, PVOID pipeHandle);
NTSTATUS AbortPipe(ADAPTEREXT *adapter, PVOID pipeHandle);
NTSTATUS SimulateRNDISHalt(ADAPTEREXT *adapter);
NTSTATUS SimulateRNDISInit(ADAPTEREXT *adapter);
NTSTATUS SimulateRNDISSetPacketFilter(ADAPTEREXT *adapter);
NTSTATUS SimulateRNDISSetCurrentAddress(ADAPTEREXT *adapter);
VOID ServiceReadDeficit(ADAPTEREXT *adapter);
VOID QueueAdapterWorkItem(ADAPTEREXT *adapter);
VOID AdapterWorkItemCallback(IN PDEVICE_OBJECT devObj, IN PVOID context);
VOID BackoffTimerDpc(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2);
VOID ProcessWorkItemOrTimerCallback(ADAPTEREXT *adapter);

/*
 *  The Win98SE kernel does not expose IoWorkItems, so implement them internally.
 *  This introduces a slight race condition on unload, but there is no fix without externally-implemented workitems.
 */
#if SPECIAL_WIN98SE_BUILD
    typedef struct _IO_WORKITEM {
        WORK_QUEUE_ITEM WorkItem;
        PIO_WORKITEM_ROUTINE Routine;
        PDEVICE_OBJECT DeviceObject;
        PVOID Context;
        #if DBG
            ULONG Size;
        #endif
    } IO_WORKITEM, *PIO_WORKITEM;
    PIO_WORKITEM MyIoAllocateWorkItem(PDEVICE_OBJECT DeviceObject);
    VOID MyIoFreeWorkItem(PIO_WORKITEM IoWorkItem);
    VOID MyIoQueueWorkItem(IN PIO_WORKITEM IoWorkItem, IN PIO_WORKITEM_ROUTINE WorkerRoutine, IN WORK_QUEUE_TYPE QueueType, IN PVOID Context);
    VOID MyIopProcessWorkItem(IN PVOID Parameter);
#endif 


/*
 *  Externs
 */
extern LIST_ENTRY allAdaptersList;
extern KSPIN_LOCK globalSpinLock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\cfgdll.cpp ===
/*****************************************************************/
/**          Microsoft Windows for Workgroups        **/
/**          Copyright (c) 1991-1998 Microsoft Corporation
/*****************************************************************/ 

//
//  CFGDLL.C - 32-bit stubs for functions that call into 16-bit DLL
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//  96/05/27  markdu  Initialize and destroy gpszLastErrorText.
//

#include "pch.hpp"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE ghInstance=NULL;
LPSTR gpszLastErrorText=NULL;
#pragma data_seg(DATASEG_DEFAULT)

typedef UINT RETERR;

// prototypes for functions we thunk to
#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  extern RETERR __stdcall GetClientConfig16(LPCLIENTCONFIG pClientConfig);
  extern UINT __stdcall InstallComponent16(HWND hwndParent,DWORD dwComponent,DWORD dwParam);
  extern RETERR __stdcall BeginNetcardTCPIPEnum16(VOID);
  extern BOOL __stdcall GetNextNetcardTCPIPNode16(LPSTR pszTcpNode,WORD cbTcpNode,
    DWORD dwFlags);
  extern VOID __stdcall GetSETUPXErrorText16(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
  extern RETERR __stdcall RemoveProtocols16(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols);
  extern RETERR __stdcall RemoveUnneededDefaultComponents16(HWND hwndParent);
  extern RETERR __stdcall DoGenInstall16(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect);
  extern RETERR __stdcall SetInstallSourcePath16(LPCSTR szSourcePath);

  BOOL WINAPI wizthk_ThunkConnect32(LPSTR pszDll16,LPSTR pszDll32,HINSTANCE hInst,
    DWORD dwReason);
  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

#if defined(CMBUILD)
static const CHAR szDll16[] = "CNET16.DLL";
static const CHAR szDll32[] = "CCFG32.DLL";
#else
static const CHAR szDll16[] = "INET16.DLL";
static const CHAR szDll32[] = "ICFG32.DLL";
#endif

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to inet16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
  // initialize thunk layer to inet16.dll
  if (!(wizthk_ThunkConnect32((LPSTR)szDll16,(LPSTR)szDll32,hInstDll,
    fdwReason)))
    return FALSE;

  if( fdwReason == DLL_PROCESS_ATTACH )
  {
    ghInstance = hInstDll;
 
    // Allocate memory for the error message text for GetLastInstallErrorText()
    gpszLastErrorText = (LPSTR)LocalAlloc(LPTR, MAX_ERROR_TEXT);
    if (NULL == gpszLastErrorText)
    {
      return FALSE;
    }
  }


  if( fdwReason == DLL_PROCESS_DETACH )
  {
    LocalFree(gpszLastErrorText);
  }

  return TRUE;
}



/*******************************************************************

  NAME:    GetClientConfig

  SYNOPSIS:  Retrieves client software configration

  ENTRY:    pClientConfig - pointer to struct to fill in with config info

  EXIT:    returns a SETUPX error code

  NOTES:    This is just the 32-bit side wrapper, thunks to GetClientConfig16
        to do real work.  Information needs to be obtained from
        setupx.dll, which is 16-bit.

********************************************************************/
RETERR GetClientConfig(CLIENTCONFIG * pClientConfig)
{
  ASSERT(pClientConfig);
   
  // thunk to GetClientConfig16 to do real work

  return GetClientConfig16(pClientConfig);
}

/*******************************************************************

  NAME:    InstallComponent

  SYNOPSIS:  Installs the specified component

  ENTRY:    dwComponent - ordinal of component to install
        (IC_xxx, defined in wizglob.h)
        dwParam - component-specific parameters, defined in wizglob.h

  EXIT:    returns ERROR_SUCCESS if successful, or a standard error code

  NOTES:    This is just the 32-bit side wrapper, thunks to InstallComponent16
        to do real work.

********************************************************************/
UINT InstallComponent(HWND hwndParent,DWORD dwComponent,DWORD dwParam)
{
  // thunk to InstallComponent16 to do real work

  return InstallComponent16(hwndParent,dwComponent,dwParam);
}


/*******************************************************************

  NAME:    BeginNetcardTCPIPEnum16Enum

  SYNOPSIS:  Begins an enumeration of netcard TCP/IP nodes

  NOTES:    Subsequent calls to GetNextNetcardTCPIPNode16 will
        enumerate TCP/IP nodes

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR BeginNetcardTCPIPEnum(VOID)
{
  return BeginNetcardTCPIPEnum16();
}

/*******************************************************************

  NAME:    GetNextNetcardTCPIPNode16

  SYNOPSIS:  Enumerates the next TCP/IP node of specified type

  ENTRY:    pszTcpNode - pointer to buffer to be filled in with
          node subkey name
        cbTcpNode - size of pszTcpNode buffer
        dwFlags - some combination of INSTANCE_ flags
          indicating what kind of instance to enumerate

  EXIT:    returns TRUE if a TCPIP node was enumerated,
        FALSE if no more nodes to enumerate

  NOTES:    BeginNetcardTCPIPEnum16 must be called before each
        enumeration to start at the beginning of the list.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
BOOL GetNextNetcardTCPIPNode(LPSTR pszTcpNode,WORD cbTcpNode, DWORD dwFlags)
{
  return GetNextNetcardTCPIPNode16(pszTcpNode,cbTcpNode,dwFlags);
}


/*******************************************************************

  NAME:    GetSETUPXErrorText

  SYNOPSIS:  Gets text corresponding to SETUPX error code

  ENTRY:    dwErr - error to get text for
        pszErrorDesc - pointer to buffer to fill in with text
        cbErrorDesc - size of pszErrorDesc buffer

  NOTES:    This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
extern "C" VOID GetSETUPXErrorText(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc)
{
  GetSETUPXErrorText16(dwErr,pszErrorDesc,cbErrorDesc);
}

/*******************************************************************

  NAME:    RemoveUnneededDefaultComponents

  SYNOPSIS:  Removes network components that we don't need which
        are installed by default when an adapter is added
        to a no-net system.

  NOTES:    Removes: vredir, nwredir, netbeui, ipx
        
        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR RemoveUnneededDefaultComponents(HWND hwndParent)
{
  return RemoveUnneededDefaultComponents16(hwndParent);
}

/*******************************************************************

  NAME:    RemoveProtocols

  SYNOPSIS:  Removes specified protocols from card of specified type

  NOTES:    This function is useful because if user has a net card
        and we add PPPMAC, all the protocols that were bound
        to the net card appear on PPPMAC.  We need to go through
        and strip them off.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR RemoveProtocols(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols)
{
  return RemoveProtocols16(hwndParent,dwRemoveFromCardType,dwProtocols);
}

/*******************************************************************

  NAME:    DoGenInstall

  SYNOPSIS:  Calls GenInstall to do file copies, registry entries,
        etc. in specified .inf file and section.

  ENTRY:    hwndParent - parent window
        lpszInfFile - name of .inf file.
        lpszInfSect - name of section in .inf file.

  EXIT:    returns OK, or a SETUPX error code.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR DoGenInstall(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect)
{
  return DoGenInstall16(hwndParent,lpszInfFile,lpszInfSect);
}


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgSetInstallSourcePath(LPCSTR lpszSourcePath)
{
  // thunk to InstallComponent16 to do real work

  return SetInstallSourcePath16(lpszSourcePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rndis\usb8023\util.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    util.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


#if DBG_WRAP_MEMORY
    /*
     *  Memory Allocation:
     *  To catch memory leaks, we will keep a count and list of all allocated memory
     *  and then assert that the memory is all freed when we exit.
     */
    ULONG dbgTotalMemCount = 0;
    LIST_ENTRY dbgAllMemoryList;
    #define ALIGNBYTES 32

    struct memHeader {
        PUCHAR actualPtr;
        ULONG actualSize;
        LIST_ENTRY listEntry;
    };
#endif


PVOID AllocPool(ULONG size)
/*
 *
 *  Return a 32-byte aligned pointer.
 *  Place a guard word at the end of the buffer.
 *  Cache the actual allocated pointer and size before the returned pointer.
 *
 */
{
    PUCHAR resultPtr;
    
    #if DBG_WRAP_MEMORY 
        {
            PUCHAR actualPtr = ExAllocatePoolWithTag(  
                                    NonPagedPool, 
                                    size+ALIGNBYTES+sizeof(struct memHeader)+sizeof(ULONG), 
                                    DRIVER_SIG);
            if (actualPtr){
                struct memHeader *memHdr;
                KIRQL oldIrql;

                RtlZeroMemory(actualPtr, size+32+sizeof(struct memHeader));
                *(PULONG)(actualPtr+size+ALIGNBYTES+sizeof(struct memHeader)) = GUARD_WORD;

                /*
                 *  ExAllocatePoolWithTag returns the 32-byte aligned pointer
                 *  from ExAllocatePool plus 8 bytes for the tag and kernel tracking info
                 *  (but don't depend on this).
                 *  Align the pointer we return, and cache away the actual pointer to free and
                 *  the buffer size.
                 */
                // ASSERT(((ULONG_PTR)actualPtr & 0x1F) == 0x08); NT only
                resultPtr = (PUCHAR)((ULONG_PTR)(actualPtr+ALIGNBYTES+sizeof(struct memHeader)) & ~(ALIGNBYTES-1));

                memHdr = (struct memHeader *)(resultPtr-sizeof(struct memHeader));
                memHdr->actualPtr = actualPtr;
                memHdr->actualSize = size+ALIGNBYTES+sizeof(struct memHeader)+sizeof(ULONG);

                dbgTotalMemCount += memHdr->actualSize;

                KeAcquireSpinLock(&globalSpinLock, &oldIrql);
                InsertTailList(&dbgAllMemoryList, &memHdr->listEntry);
                KeReleaseSpinLock(&globalSpinLock, oldIrql);
            }
            else {
                resultPtr = NULL;
            }
        }
    #else
        resultPtr = ExAllocatePoolWithTag(NonPagedPool, size, DRIVER_SIG);
        if (resultPtr){
            RtlZeroMemory(resultPtr, size);
        }
    #endif

    return resultPtr;
}

VOID FreePool(PVOID ptr)
{
    #if DBG_WRAP_MEMORY 
        {
            KIRQL oldIrql;
            struct memHeader *memHdr;

            ASSERT(ptr);

            memHdr = (struct memHeader *)((PUCHAR)ptr - sizeof(struct memHeader));
            ASSERT(*(PULONG)(memHdr->actualPtr+memHdr->actualSize-sizeof(ULONG)) == GUARD_WORD);
            ASSERT(dbgTotalMemCount >= memHdr->actualSize);

            KeAcquireSpinLock(&globalSpinLock, &oldIrql);
            ASSERT(!IsListEmpty(&dbgAllMemoryList));
            RemoveEntryList(&memHdr->listEntry);
            KeReleaseSpinLock(&globalSpinLock, oldIrql);

            dbgTotalMemCount -= memHdr->actualSize;
            ExFreePool(memHdr->actualPtr);
        }
    #else
        ExFreePool(ptr);
    #endif
}


/*
 ********************************************************************************
 *  MemDup
 ********************************************************************************
 *
 *  Return a fresh copy of the argument.
 *
 */
PVOID MemDup(PVOID dataPtr, ULONG length)
{
    PVOID newPtr;

    newPtr = (PVOID)AllocPool(length); 
    if (newPtr){
        RtlCopyMemory(newPtr, dataPtr, length);
    }

    ASSERT(newPtr);
    return newPtr;
}


VOID DelayMs(ULONG numMillisec)
{
    LARGE_INTEGER deltaTime;

    /*
     *  Get delay time into relative units of 100 nsec.
     */
    deltaTime.QuadPart = -10000 * numMillisec;
    KeDelayExecutionThread(KernelMode, FALSE, &deltaTime);
}


/*
 *  AllocateCommonResources
 *
 *      Allocate adapter resources that are common to RNDIS and NDIS interfaces
 *  but which for some reason can't be allocated by NewAdapter().
 *  These resources will be freed by FreeAdapter().
 */
BOOLEAN AllocateCommonResources(ADAPTEREXT *adapter)
{
    BOOLEAN result = TRUE;
    ULONG i;
                            
    /*
     *  Build the packet pool for this adapter.
     */
    for (i = 0; i < USB_PACKET_POOL_SIZE; i++){
        USBPACKET *packet = NewPacket(adapter);
        if (packet){
            EnqueueFreePacket(packet);
        }
        else {
            ASSERT(packet);
            result = FALSE;
            break;
        }
    }

    ASSERT(result);
    return result;
}



BOOLEAN GetRegValue(ADAPTEREXT *adapter, PWCHAR wValueName, OUT PULONG valuePtr, BOOLEAN hwKey)
{
    BOOLEAN success = FALSE;
    NTSTATUS status;
    HANDLE hRegDevice;
    KIRQL oldIrql;

    *valuePtr = 0;

    status = IoOpenDeviceRegistryKey(   adapter->physDevObj, 
                                        hwKey ? PLUGPLAY_REGKEY_DEVICE : PLUGPLAY_REGKEY_DRIVER, 
                                        KEY_READ, 
                                        &hRegDevice);
    if (NT_SUCCESS(status)){
        UNICODE_STRING uValueName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;

        RtlInitUnicodeString(&uValueName, wValueName); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            uValueName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);
        keyValueInfo = AllocPool(keyValueTotalSize);
        if (keyValueInfo){
            status = ZwQueryValueKey(   hRegDevice,
                                        &uValueName,
                                        KeyValueFullInformation,
                                        keyValueInfo,
                                        keyValueTotalSize,
                                        &actualLength); 
            if (NT_SUCCESS(status)){
                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));
                *valuePtr = *((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                success = TRUE;
            }

            FreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGWARN(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

    return success;
}


BOOLEAN SetRegValue(ADAPTEREXT *adapter, PWCHAR wValueName, ULONG newValue, BOOLEAN hwKey)
{
    BOOLEAN success = FALSE;
    NTSTATUS status;
    HANDLE hRegDevice;
    KIRQL oldIrql;

    status = IoOpenDeviceRegistryKey(   adapter->physDevObj, 
                                        hwKey ? PLUGPLAY_REGKEY_DEVICE : PLUGPLAY_REGKEY_DRIVER, 
                                        KEY_READ, 
                                        &hRegDevice);
    if (NT_SUCCESS(status)){
        UNICODE_STRING uValueName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;

        RtlInitUnicodeString(&uValueName, wValueName); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            uValueName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);
        keyValueInfo = AllocPool(keyValueTotalSize);
        if (keyValueInfo){
            status = ZwSetValueKey( hRegDevice,
                                    &uValueName,
                                    0,  
                                    REG_DWORD,
                                    &newValue,
                                    sizeof(ULONG)); 
            if (NT_SUCCESS(status)){
                success = TRUE;
            }
            else {
                DBGERR(("SetRegValue: ZwSetValueKey failed with %xh.", status));
            }

            FreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGOUT(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

    return success;
}


/*
 *  MyInitializeMdl
 *
 *      Wrapper for MmInitializeMdl, which doesn't compile under NDIS headers.
 */
VOID MyInitializeMdl(PMDL mdl, PVOID buf, ULONG bufLen)
{
    MmInitializeMdl(mdl, buf, bufLen);
    MmBuildMdlForNonPagedPool(mdl);
}


PVOID GetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf;

    /*
     *  Note:  we could use MmGetSystemAddressSafe here
     *         but not for Win98SE
     */

    if (MdlAddress){
        CSHORT oldFlags = MdlAddress->MdlFlags;
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
#if defined(SPECIAL_WIN98SE_BUILD) || defined(SPECIAL_WINME_BUILD)
        buf = MmGetSystemAddressForMdl(MdlAddress);
#else
        buf = MmGetSystemAddressForMdlSafe(MdlAddress, NormalPoolPriority);
#endif
        MdlAddress->MdlFlags &= (oldFlags | ~MDL_MAPPING_CAN_FAIL);
    }
    else {
        ASSERT(MdlAddress);
        buf = NULL;
    }

    return buf;
}


ULONG CopyMdlToBuffer(PUCHAR buf, PMDL mdl, ULONG bufLen)
{
    ULONG totalLen = 0;

    while (mdl){
        ULONG thisBufLen = MmGetMdlByteCount(mdl);
        if (totalLen+thisBufLen <= bufLen){
            PVOID thisBuf = GetSystemAddressForMdlSafe(mdl);
            if (thisBuf){
                RtlCopyMemory(buf+totalLen, thisBuf, thisBufLen);
                totalLen += thisBufLen;
                mdl = mdl->Next;
            }
            else {
                break;
            }
        }
        else {
            DBGERR(("CopyMdlToBuffer: mdl @ %ph is too large for buffer size %xh.", mdl, bufLen));
            break;
        }
    }

    return totalLen;
}

ULONG GetMdlListTotalByteCount(PMDL mdl)
{
    ULONG totalBytes = 0;

    do {
        totalBytes += MmGetMdlByteCount(mdl);
        mdl = mdl->Next;
    } while (mdl);

    return totalBytes;
}

VOID ByteSwap(PUCHAR buf, ULONG len)
{
    while (len >= 2){
        UCHAR tmp = buf[0];
        buf[0] = buf[1];
        buf[1] = tmp;
        buf += 2;
        len -= 2;
    }
}


#if SPECIAL_WIN98SE_BUILD

    PIO_WORKITEM MyIoAllocateWorkItem(PDEVICE_OBJECT DeviceObject)
    {
        PIO_WORKITEM ioWorkItem;
        PWORK_QUEUE_ITEM exWorkItem;

        ioWorkItem = ExAllocatePool(NonPagedPool, sizeof(IO_WORKITEM));
        if (ioWorkItem) {
            ioWorkItem->DeviceObject = DeviceObject;
            exWorkItem = &ioWorkItem->WorkItem;
            #if DBG
                ioWorkItem->Size = sizeof(IO_WORKITEM);
            #endif
            ExInitializeWorkItem(exWorkItem, MyIopProcessWorkItem, ioWorkItem);
        }

        return ioWorkItem;
    }

    VOID MyIoFreeWorkItem(PIO_WORKITEM IoWorkItem)
    {
        ASSERT(IoWorkItem->Size == sizeof(IO_WORKITEM));
        ExFreePool( IoWorkItem );
    }

    VOID MyIoQueueWorkItem(IN PIO_WORKITEM IoWorkItem, IN PIO_WORKITEM_ROUTINE WorkerRoutine, IN WORK_QUEUE_TYPE QueueType, IN PVOID Context)
    {
        PWORK_QUEUE_ITEM exWorkItem;

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
        ASSERT(IoWorkItem->Size == sizeof(IO_WORKITEM));

        ObReferenceObject( IoWorkItem->DeviceObject );

        IoWorkItem->Routine = WorkerRoutine;
        IoWorkItem->Context = Context;

        exWorkItem = &IoWorkItem->WorkItem;
        ExQueueWorkItem( exWorkItem, QueueType );
    }


    VOID MyIopProcessWorkItem(IN PVOID Parameter)
    {
        PIO_WORKITEM ioWorkItem;
        PDEVICE_OBJECT deviceObject;

        PAGED_CODE();

        ioWorkItem = (PIO_WORKITEM)Parameter;
        deviceObject = ioWorkItem->DeviceObject;
        ioWorkItem->Routine(deviceObject, ioWorkItem->Context);
        ObDereferenceObject(deviceObject);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\cfgtcp.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  TCPCFG.C - Functions to read and set TCP/IP configuration
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"
// function prototypes
UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,BOOL fRemove,BOOL * pfBound);

//*******************************************************************
//              
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

extern "C" HRESULT IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS)
{
  CHAR szDNSEnabled[2];    // big enough for "1"
  BOOL fGlobalDNS = FALSE;

  // open the global TCP/IP key
  RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
  HRESULT hr = reTcp.GetError();
  if (hr == ERROR_SUCCESS)
  {
    // read the registry value to see if DNS is enabled
    reTcp.GetString(szRegValEnableDNS,szDNSEnabled,sizeof(szDNSEnabled));
    hr = reTcp.GetError();
    if ((hr == ERROR_SUCCESS) && (!lstrcmpi(szDNSEnabled,sz1)))
    {
      // DNS is enabled
      fGlobalDNS = TRUE;
    }
  }

  if (NULL != lpfGlobalDNS)
  {
    *lpfGlobalDNS = fGlobalDNS;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

extern "C" HRESULT IcfgRemoveGlobalDNS(void)
{
  HRESULT hr = ERROR_SUCCESS;

  // open the global TCP/IP key
  RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
  hr = reTcp.GetError();
  ASSERT(hr == ERROR_SUCCESS);

  if (ERROR_SUCCESS == hr)
  {
    // no name servers; disable DNS.  Set registry switch to "0".
    hr = reTcp.SetValue(szRegValEnableDNS,sz0);
    ASSERT(hr == ERROR_SUCCESS);
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP	- PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn)
{
  BOOL fBound = FALSE;

  ASSERT(lpfSharingOn);

  // call worker function
  HRESULT hr = DetectModifyTCPIPBindings(dwfDriverType,szVSERVER,FALSE,&fBound);

  if (NULL != lpfSharingOn)
  {
    *lpfSharingOn = fBound;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for 
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP	- PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent)
{
  BOOL fBound;

  // call worker function
  return DetectModifyTCPIPBindings(dwfDriverType,szVSERVER,TRUE,&fBound);

}


/*******************************************************************

  NAME:    DetectModifyTCPIPBindings

  SYNOPSIS:  Finds (and optionally removes) bindings between
        VSERVER and TCP/IP for TCP/IP instances on a particular
        card type.

  ENTRY:    dwCardFlags - an INSTANCE_xxx flag to specify what
          card type to find/remove server-TCP/IP bindings for
        pszBoundTo - name of component to look for or modify bindings
          to.  Can be VSERVER or VREDIR
        fRemove - if TRUE, all bindings are removed as we find them.
          If FALSE, bindings are left alone but *pfBound is set
          to TRUE if bindings exist.
        pfBound - pointer to BOOL to be filled in

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    Worker function for TurnOffFileSharing and IsFileSharingTurnedOn

********************************************************************/
UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,
  BOOL fRemove,BOOL * pfBound)
{
  ASSERT(pfBound);
  *pfBound = FALSE;  // assume not bound until proven otherwise

  ENUM_TCP_INSTANCE EnumTcpInstance(dwCardFlags,NT_ENUMNODE);

  UINT err = EnumTcpInstance.GetError();
  if (err != ERROR_SUCCESS)
    return err;

  HKEY hkeyInstance = EnumTcpInstance.Next();

  // for every TCP/IP node in enum branch, look at bindings key.
  // Scan the bindings (values in bindings key), if they begin
  // with the string pszBoundTo ("VSERVER" or "VREDIR") then
  // the binding exists.

  while (hkeyInstance) {
    // open bindings key
    RegEntry reBindings(szRegKeyBindings,hkeyInstance);
    ASSERT(reBindings.GetError() == ERROR_SUCCESS);
    if (reBindings.GetError() == ERROR_SUCCESS) {
      RegEnumValues * preBindingVals = new RegEnumValues(&reBindings);
      ASSERT(preBindingVals);
      if (!preBindingVals)
        return ERROR_NOT_ENOUGH_MEMORY;
  
      // enumerate binding values
      while (preBindingVals->Next() == ERROR_SUCCESS) {
        ASSERT(preBindingVals->GetName()); // should always have a valid ptr
        
        // does this binding begin with the string we were passed in
        // pszBoundTo

        CHAR szBindingVal[SMALL_BUF_LEN+1];
        DWORD dwBoundToLen = lstrlen(pszBoundTo);
        lstrcpy(szBindingVal,preBindingVals->GetName());
        if (((DWORD)lstrlen(szBindingVal)) >= dwBoundToLen) {
          // NULL-terminate the copy at the appropriate place
          // so we can do a strcmp rather than a strncmp, which
          // would involve pulling in C runtime or implementing
          // our own strncmp
          szBindingVal[dwBoundToLen] = '\0';
          if (!lstrcmpi(szBindingVal,pszBoundTo)) {

            *pfBound = TRUE;
            // remove the binding if specified by caller
            if (fRemove) {
              // delete the value
              reBindings.DeleteValue(preBindingVals->GetName());

              // destroy and reconstruct RegEnumValues object, otherwise
              // RegEnumValues api gets confused because we deleted a
              // value during enum
              delete preBindingVals;
              preBindingVals = new RegEnumValues(&reBindings);
              ASSERT(preBindingVals);
              if (!preBindingVals)
                return ERROR_NOT_ENOUGH_MEMORY;
            } else {
              // caller just wants to know if binding exists, we
              // filled in pfBound above so we're done
              return ERROR_SUCCESS;
            }
          }
        }
      }
    }
    hkeyInstance = EnumTcpInstance.Next();
  }

  return ERROR_SUCCESS;
}


/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::ENUM_TCP_INSTANCE

  SYNOPSIS:  Constructor for class to enumerate TCP/IP registry nodes
        according to type of card they are bound to

  ENTRY:    dwCardFlags - combination of INSTANCE_x flags indicating
          what kind of card to enumerate instances for
        dwNodeFlags  - combination of NT_ flags indicating what
          type of node to return (driver node, enum node)

********************************************************************/
ENUM_TCP_INSTANCE::ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags) :
  _dwCardFlags (dwCardFlags), _dwNodeFlags (dwNodeFlags)
{
  _hkeyTcpNode = NULL;
  _error = ERROR_SUCCESS;

  // init/reset netcard enumeration
  BeginNetcardTCPIPEnum();
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::~ENUM_TCP_INSTANCE

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_TCP_INSTANCE::~ENUM_TCP_INSTANCE()
{
  // close current TCP node key, if any
  CloseNode();
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::Next

  SYNOPSIS:  Enumerates next TCP/IP driver node

  EXIT:    Returns an open registry key handle, or NULL if
        no more nodes.

  NOTES:    Caller should not close the HKEY that is returned.  This
        HKEY will be valid until the next time the Next() method
        is called or until the object is destructed.

********************************************************************/
HKEY ENUM_TCP_INSTANCE::Next()
{
  CHAR  szSubkeyName[MAX_PATH+1];

  // close current TCP node key, if any
  CloseNode();

  while (_error == ERROR_SUCCESS) {
    CHAR szInstancePath[SMALL_BUF_LEN+1];
    CHAR szDriverPath[SMALL_BUF_LEN+1];

    if (!GetNextNetcardTCPIPNode(szSubkeyName,sizeof(szSubkeyName),
      _dwCardFlags))
      return NULL;  // no more nodes

    // open the enum branch, find the specified subkey
    RegEntry reEnumNet(szRegPathEnumNet,HKEY_LOCAL_MACHINE);

    // if caller wanted enum node, just open that node

    if (_dwNodeFlags & NT_ENUMNODE) {
    
      _error = RegOpenKey(reEnumNet.GetKey(),szSubkeyName,
        &_hkeyTcpNode);
      // return open key
      return _hkeyTcpNode;

    } else {
      // from enum node, figure out path to driver node
      
      reEnumNet.MoveToSubKey(szSubkeyName);
      if (reEnumNet.GetError() != ERROR_SUCCESS)
        continue;
      // find the driver path to the driver node
      if (!reEnumNet.GetString(szRegValDriver,szDriverPath,
        sizeof(szDriverPath))) {
         ASSERTSZ(FALSE,"No driver path in enum branch for TCP/IP instance");
        continue;  
      }

      // build the path to registry node for this instance
      lstrcpy(szInstancePath,szRegPathClass);
      lstrcat(szInstancePath,szDriverPath);

      _error = RegOpenKey(HKEY_LOCAL_MACHINE,szInstancePath,
        &_hkeyTcpNode);
      // return open key
      return _hkeyTcpNode;
    }
  }

  // ran through all net cards of specified type w/o finding TCP/IP bound
  _error = ERROR_NO_MORE_ITEMS;
  return NULL;
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::CloseNode

  SYNOPSIS:  Private worker function to close TCP/IP node handle

********************************************************************/
VOID ENUM_TCP_INSTANCE::CloseNode()
{
  if (_hkeyTcpNode) {
    RegCloseKey(_hkeyTcpNode);
    _hkeyTcpNode = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//        registry access, etc.
//

//  HISTORY:
//  
//  12/07/94  jeremys Borrowed from WNET common library
//  96/05/22  markdu  Borrowed (from inetcfg.dll)
//

#include "pch.hpp"

BOOL BUFFER::Alloc( UINT cbBuffer )
{
  _lpBuffer = (LPSTR)::GlobalAlloc(GPTR,cbBuffer);
  if (_lpBuffer != NULL) {
    _cb = cbBuffer;
    return TRUE;
  }
  return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
  LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, cbNew,
    GMEM_MOVEABLE | GMEM_ZEROINIT);
  if (lpNew == NULL)
    return FALSE;

  _lpBuffer = (LPSTR)lpNew;
  _cb = cbNew;
  return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
  _lpBuffer( NULL )
{
  if (cbInitial)
    Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
  if (_lpBuffer != NULL) {
    GlobalFree((HGLOBAL) _lpBuffer);
    _lpBuffer = NULL;
  }
}

BOOL BUFFER::Resize( UINT cbNew )
{
  BOOL fSuccess;

  if (QuerySize() == 0)
    fSuccess = Alloc( cbNew );
  else {
    fSuccess = Realloc( cbNew );
  }
  if (fSuccess)
    _cb = cbNew;
  return fSuccess;
}

RegEntry::RegEntry(const char *pszSubKey, HKEY hkey)
{
  _error = RegCreateKey(hkey, pszSubKey, &_hkey);
  if (_error) {
    bhkeyValid = FALSE;
  }
  else {
    bhkeyValid = TRUE;
  }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const char *pszValue, const char *string)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
            (unsigned char *)string, lstrlen(string)+1);
    }
  return _error;
}

long RegEntry::SetValue(const char *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
            (unsigned char *)&dwNumber, sizeof(dwNumber));
    }
  return _error;
}

long RegEntry::DeleteValue(const char *pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}


char *RegEntry::GetString(const char *pszValue, char *string, unsigned long length)
{
  DWORD   dwType = REG_SZ;
  
    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
            &length);
    }
  if (_error) {
    *string = '\0';
     return NULL;
  }

  return string;
}

long RegEntry::GetNumber(const char *pszValue, long dwDefault)
{
   DWORD   dwType = REG_BINARY;
   long  dwNumber = 0L;
   DWORD  dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
            &dwSize);
  }
  if (_error)
    dwNumber = dwDefault;
  
  return dwNumber;
}

long RegEntry::MoveToSubKey(const char *pszSubKeyName)
{
    HKEY  _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

  return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
      _error = RegFlushKey(_hkey);
    }
  return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new CHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

int __cdecl _purecall(void)
{
   return(0);
}

void * _cdecl operator new(unsigned int size)
{
  return (void *)::GlobalAlloc(GPTR,size); 
}

void _cdecl operator delete(void *ptr)
{
  GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\fltthk.inc ===
;//*********************************************************************
;//*                  Microsoft Windows                               **
;//*            Copyright (c) 1994-1998 Microsoft Corporation         **
;//*********************************************************************

; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16	macro	dwOffset
ifdef DEBUG
	pushd	offset FT_ThunkLogNames + dwOffset
	call	FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF	proto	near stdcall, psz:dword

FAPILOG16_Hlp:
	push	ebp
	mov	ebp,[esp+8]

	invoke	LogApiThkLSF, ebp

	pop	ebp
	ret	4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\debug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation         **
//*********************************************************************
#ifndef _PHBKDEBUG
#define _PHBKDEBUG

//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	void Dprintf(PCSTR pcsz, ...);
//#ifdef __cplusplus
//}
//#endif // __cplusplus

#ifdef DEBUG
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	BOOL FAssertProc(PCSTR szFile,  DWORD dwLine, PCSTR szMsg, DWORD dwFlags);
	void DebugSz(PCSTR psz);
//#ifdef __cplusplus
//}
//#endif // __cplusplus
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
	#define Assert(f)					AssertSz((f), "!(" #f ")")
#else
	#define DebugSz(x)
	#define AssertSzFlg(f, sz, dwFlg) f
	#define AssertSz(f, sz) f
	#define Assert(f) f
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\debug.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation         **
//*********************************************************************

// ############################################################################
// Debugging routines

#include "pch.hpp"

BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(PCSTR psz)
{
	OutputDebugString(psz);
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(PCSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintf(szBuf, pcsz, argp);

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(PCSTR szFile,  DWORD dwLine, PCSTR szMsg, DWORD dwFlags)
{
	char szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	BOOL fAssertIntoDebugger = FALSE;
	LPTSTR pszCommandLine = GetCommandLine();
	HANDLE	hAssertTxt;
	//BYTE	szTime[80];
	CHAR	szTime[80];
	SYSTEMTIME st;
	DWORD	cbWritten;
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz("***Recursive Assert***\r\n");
		return(FALSE);
		}

	fInAssert = TRUE;
	
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
	wsprintf(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
	hAssertTxt = CreateFile("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);
		wsprintf(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
    		ExitProcess(0);
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:    BUFFER_BASE

    SYNOPSIS:  Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Returns TRUE if
          successful.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    None

    USES:    None

    CAVEATS:  This is an abstract class, which unifies the interface
        of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
  UINT _cb;

  virtual BOOL Alloc( UINT cbBuffer ) = 0;
  virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
  BUFFER_BASE()
    { _cb = 0; }  // buffer not allocated yet
  ~BUFFER_BASE()
    { _cb = 0; }  // buffer size no longer valid
  BOOL Resize( UINT cbNew );
  UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER  BUFFER

/*************************************************************************

    NAME:    BUFFER

    SYNOPSIS:  Wrapper class for new and delete

    INTERFACE:  BUFFER()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Only works if the
          buffer hasn't been allocated yet.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    BUFFER_BASE

    USES:    operator new, operator delete

    CAVEATS:

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
  CHAR *_lpBuffer;

  virtual BOOL Alloc( UINT cbBuffer );
  virtual BOOL Realloc( UINT cbBuffer );

public:
  BUFFER( UINT cbInitial=0 );
  ~BUFFER();
  BOOL Resize( UINT cbNew );
  CHAR * QueryPtr() const { return (CHAR *)_lpBuffer; }
  operator CHAR *() const { return (CHAR *)_lpBuffer; }
};

class RegEntry
{
  public:
    RegEntry(const char *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
    ~RegEntry();
    
    long  GetError()  { return _error; }
    long  SetValue(const char *pszValue, const char *string);
    long  SetValue(const char *pszValue, unsigned long dwNumber);
    char *  GetString(const char *pszValue, char *string, unsigned long length);
    long  GetNumber(const char *pszValue, long dwDefault = 0);
    long  DeleteValue(const char *pszValue);
    long  FlushKey();
        long    MoveToSubKey(const char *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

  private:
    HKEY  _hkey;
    long  _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
  public:
    RegEnumValues(RegEntry *pRegEntry);
    ~RegEnumValues();
    long  Next();
    char *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
    long  GetError()  { return _error; }

  private:
        RegEntry * pRegEntry;
    DWORD   iEnum;
        DWORD   cEntries;
    CHAR *  pchName;
    LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:    WAITCURSOR

    SYNOPSIS:  Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};

#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

// string resource IDs
#define IDS_APPNAME                   1000
#define IDS_ERRFORMAT                 1001
#define IDS_EXEC_GRPCONV              1002
#define IDS_EXEC_GRPCONV_PARAM        1003
#define IDS_MAIL_WIZARD_REG_VAL       1004
#define IDS_DEF_COMPUTER_NAME         1005
#define IDS_DEF_WORKGROUP_NAME        1006
#define IDS_ERROutOfMemory            1100
#define IDS_ERRReadConfig             1101
#define IDS_ERRInstallTCPIP           1102
#define IDS_ERRInstallPPPMAC          1103
#define IDS_ERRInstallFiles           1104
#define IDS_ERRWriteDNS               1105

// dialog page IDs
//
// ChrisK 6/3/97 Olympus 5425
// Removed unused dialog
//
//#define IDD_SECURITY_CHECK            2000
#define IDD_DNS_WARNING               2001

#ifdef IDC_HELP
#undef IDC_HELP
#endif

// dialog control IDs
#define IDC_UNUSED                    -1
#define IDC_DISABLE_CHECK             2100
#define IDC_DISABLE_WARNING           2101

// icon IDs
#define IDI_WORLD                     2200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\wizthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\global.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************

//
//  GLOBAL.H - central header file for Internet config library
//

//  HISTORY:
//
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

#ifdef DEBUG
// component name for debug spew
#define SZ_COMPNAME "ICFG32: "
#endif // DEBUG

  #include <windows.h>
  #include <windowsx.h>
  #include <commctrl.h>
  #include <prsht.h>
  #include <regstr.h>
  #include "oharestr.h"

  // various RNA header files
  #include <ras.h>

  #include "wizglob.h"
  #include "wizdebug.h"

#undef DATASEG_READONLY
#define DATASEG_READONLY  ".rdata"
#include "inetcfg.h"
#include "cfgapi.h"
#include "clsutil.h"
#include "tcpcmn.h"
#include "ids.h"
#include "strings.h"

// Terminology: ISP - Internet Service Provider

// Defines
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers

// Globals

extern HINSTANCE  ghInstance;         // global module instance handle
extern LPSTR      gpszLastErrorText;  // hold text of last error

// Defines

// error class defines for PrepareErrorMessage
#define ERRCLS_STANDARD 0x0001
#define ERRCLS_SETUPX   0x0002
//#define ERRCLS_RNA      0x0003
//#define ERRCLS_MAPI     0x0004

#define OK        0    // success code for SETUPX class errors

// functions in PROPMGR.C
UINT GetConfig(CLIENTCONFIG * pClientConfig,DWORD * pdwErrCls);

// functions in CALLOUT.C
UINT InstallTCPIP(HWND hwndParent);
UINT InstallPPPMAC(HWND hwndParent);

// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons);
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf);
VOID _cdecl PrepareErrorMessage(UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,...);
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass);
DWORD RunMlsetExe(HWND hwndOwner);
VOID RemoveRunOnceEntry(UINT uResourceID);
BOOL GenerateDefaultName(CHAR * pszName,DWORD cbName,CHAR * pszRegValName,
  UINT uIDDefName);
BOOL GenerateComputerNameIfNeeded(VOID);
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent);

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//BOOL SetDesktopInternetIconToBrowser(VOID);

VOID PrepareForRunOnceApp(VOID);

// functions in INETAPI.C
BOOL DoDNSCheck(HWND hwndParent,BOOL * pfNeedRestart);

// functions in WIZDLL.C
RETERR   GetClientConfig(CLIENTCONFIG * pClientConfig);
UINT   InstallComponent(HWND hwndParent,DWORD dwComponent,DWORD dwParam);
RETERR   RemoveUnneededDefaultComponents(HWND hwndParent);
RETERR   RemoveProtocols(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols);
RETERR   BeginNetcardTCPIPEnum(VOID);
BOOL  GetNextNetcardTCPIPNode(LPSTR pszTcpNode,WORD cbTcpNode,DWORD dwFlags);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;


#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\pch.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation         **
//*********************************************************************
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\tcpcmn.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  TCPCMN.H - central header file for TCP/IP structures and configuration
//         functions
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#ifndef _TCPCMN_H_
#define _TCPCMN_H_

typedef DWORD IPADDRESS;

// same limits as in net setup UI
#define IP_ADDRESS_LEN          15    // big enough for www.xxx.yyy.zzz
#define MAX_GATEWAYS      8
#define MAX_DNSSERVER      3

// big enough for <ip>,<ip>,...
#define MAX_DNSSERVERLEN    MAX_DNSSERVER * (IP_ADDRESS_LEN+1)
#define MAX_GATEWAYLEN      MAX_GATEWAYS * (IP_ADDRESS_LEN+1)

// node type flags for _dwNodeFlags
#define NT_DRIVERNODE  0x0001
#define NT_ENUMNODE    0x0002

class ENUM_TCP_INSTANCE
{
private:
  DWORD       _dwCardFlags;  // INSTANCE_NETDRIVER, INSTANCE_PPPDRIVER, etc
  DWORD      _dwNodeFlags;  // NT_DRIVERNODE, NT_ENUMNODE, etc
  UINT       _error;
  HKEY       _hkeyTcpNode;
  VOID      CloseNode();
public:
  ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags);
  ~ENUM_TCP_INSTANCE();
  HKEY Next();
  UINT GetError()  { return _error; }
};


#endif  // _TCPCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\pch.hpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\i386\wizthk.asm ===
; Copyright (c) 1998 Microsoft Corporation
	page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Fri Jun 21 14:07:10 1996

;Command Line: ..\..\..\..\dev\tools\binr\thunk.exe -NC _TEXT ..\wizthk.thk 

	TITLE	$..\wizthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_wizthkTargetTable	;Flat address of target table in 16-bit module.

public FT_wizthkChecksum32
FT_wizthkChecksum32	dd	010e07h


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public wizthk_ThunkData32	;This symbol must be exported.
wizthk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	010e07h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_wizthk - offset wizthk_ThunkData32
	dd	offset FT_Prolog_wizthk - offset wizthk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public wizthk_ThunkConnect32@16
wizthk_ThunkConnect32@16:
	pop	edx
	push	offset wizthk_ThkData16
	push	offset wizthk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
wizthk_ThkData16 label byte
	db	"wizthk_ThunkData16",0


		


pfnQT_Thunk_wizthk	dd offset QT_Thunk_wizthk
pfnFT_Prolog_wizthk	dd offset FT_Prolog_wizthk
	.data
QT_Thunk_wizthk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_wizthk label byte
	db	32 dup(0cch)	;Patch space.


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include wizthk.inc



;************************ START OF THUNK BODIES************************




;
public GetClientConfig16@4
GetClientConfig16@4:
	FAPILOG16	212
	mov	cx, (1 SHL 10) + (0 SHL 8) + 8
; GetClientConfig16(16) = GetClientConfig16(32) {}
;
; dword ptr [ebp+8]:  pClientConfig
;
public IIGetClientConfig16@4
IIGetClientConfig16@4:
	call	dword ptr [pfnFT_Prolog_wizthk]
	sub	esp,24
	mov	esi,[ebp+8]
	or	esi,esi
	jnz	L0
	push	esi
	jmp	L1
L0:
	lea	edi,[ebp-88]
	push	edi	;pClientConfig: lpstruct32->lpstruct16
	or	dword ptr [ebp-20],01h	;Set flag to fixup ESP-rel argument.
	mov	ecx,12
@@:
	lodsd
	stosw
	loop	@B
L1:
	call	FT_Thunk
	movzx	ebx,ax
	mov	edi,[ebp+8]
	or	edi,edi
	jz	L2
	lea	esi,[ebp-88]	;pClientConfig  Struct16->Struct32
	mov	ecx,12
@@:
	lodsw
	cwde
	stosd
	loop	@B
L2:
	jmp	FT_Exit4





;
public BeginNetcardTCPIPEnum16@0
BeginNetcardTCPIPEnum16@0:
	FAPILOG16	161
	mov	cl,6
; BeginNetcardTCPIPEnum16(16) = BeginNetcardTCPIPEnum16(32) {}
;
;
public IIBeginNetcardTCPIPEnum16@0
IIBeginNetcardTCPIPEnum16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn





;
public GetNextNetcardTCPIPNode16@12
GetNextNetcardTCPIPNode16@12:
	FAPILOG16	131
	mov	cl,5
; GetNextNetcardTCPIPNode16(16) = GetNextNetcardTCPIPNode16(32) {}
;
; dword ptr [ebp+8]:  pszTcpNode
; dword ptr [ebp+12]:  cbTcpNode
; dword ptr [ebp+16]:  dwFlags
;
public IIGetNextNetcardTCPIPNode16@12
IIGetNextNetcardTCPIPNode16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	word ptr [ebp+12]	;cbTcpNode: dword->word
	push	dword ptr [ebp+16]	;dwFlags: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	cwde
	call	SUnMapLS_IP_EBP_8
	leave
	retn	12





;
public GetSETUPXErrorText16@12
GetSETUPXErrorText16@12:
	FAPILOG16	106
	mov	cl,4
; GetSETUPXErrorText16(16) = GetSETUPXErrorText16(32) {}
;
; dword ptr [ebp+8]:  dwErr
; dword ptr [ebp+12]:  pszErrorDesc
; dword ptr [ebp+16]:  cbErrorDesc
;
public IIGetSETUPXErrorText16@12
IIGetSETUPXErrorText16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwErr: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbErrorDesc: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public RemoveUnneededDefaultComponents16@4
RemoveUnneededDefaultComponents16@4:
	FAPILOG16	68
	mov	cl,3
; RemoveUnneededDefaultComponents16(16) = RemoveUnneededDefaultComponents16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
;
public IIRemoveUnneededDefaultComponents16@4
IIRemoveUnneededDefaultComponents16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn	4





;
public RemoveProtocols16@12
RemoveProtocols16@12:
	FAPILOG16	46
	mov	cl,2
	jmp	IIRemoveProtocols16@12
public InstallComponent16@12
InstallComponent16@12:
	FAPILOG16	189
	mov	cl,7
; RemoveProtocols16(16) = RemoveProtocols16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  dwRemoveFromCardType
; dword ptr [ebp+16]:  dwProtocols
;
public IIRemoveProtocols16@12
IIRemoveProtocols16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	push	dword ptr [ebp+12]	;dwRemoveFromCardType: dword->dword
	push	dword ptr [ebp+16]	;dwProtocols: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn	12





;
public DoGenInstall16@12
DoGenInstall16@12:
	FAPILOG16	27
	mov	cl,1
; DoGenInstall16(16) = DoGenInstall16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  lpszInfFile
; dword ptr [ebp+16]:  lpszInfSect
;
public IIDoGenInstall16@12
IIDoGenInstall16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public SetInstallSourcePath16@4
SetInstallSourcePath16@4:
	FAPILOG16	0
	mov	cl,0
; SetInstallSourcePath16(16) = SetInstallSourcePath16(32) {}
;
; dword ptr [ebp+8]:  szSourcePath
;
public IISetInstallSourcePath16@4
IISetInstallSourcePath16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] SetInstallSourcePath16',0
	db	'[F] DoGenInstall16',0
	db	'[F] RemoveProtocols16',0
	db	'[F] RemoveUnneededDefaultComponents16',0
	db	'[F] GetSETUPXErrorText16',0
	db	'[F] GetNextNetcardTCPIPNode16',0
	db	'[F] BeginNetcardTCPIPEnum16',0
	db	'[F] InstallComponent16',0
	db	'[F] GetClientConfig16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	_TEXT



externDef SetInstallSourcePath16:far16
externDef DoGenInstall16:far16
externDef RemoveProtocols16:far16
externDef RemoveUnneededDefaultComponents16:far16
externDef GetSETUPXErrorText16:far16
externDef GetNextNetcardTCPIPNode16:far16
externDef BeginNetcardTCPIPEnum16:far16
externDef InstallComponent16:far16
externDef GetClientConfig16:far16


FT_wizthkTargetTable label word
	dw	offset SetInstallSourcePath16
	dw	   seg SetInstallSourcePath16
	dw	offset DoGenInstall16
	dw	   seg DoGenInstall16
	dw	offset RemoveProtocols16
	dw	   seg RemoveProtocols16
	dw	offset RemoveUnneededDefaultComponents16
	dw	   seg RemoveUnneededDefaultComponents16
	dw	offset GetSETUPXErrorText16
	dw	   seg GetSETUPXErrorText16
	dw	offset GetNextNetcardTCPIPNode16
	dw	   seg GetNextNetcardTCPIPNode16
	dw	offset BeginNetcardTCPIPEnum16
	dw	   seg BeginNetcardTCPIPEnum16
	dw	offset InstallComponent16
	dw	   seg InstallComponent16
	dw	offset GetClientConfig16
	dw	   seg GetClientConfig16




	.data

public wizthk_ThunkData16	;This symbol must be exported.
wizthk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	010e07h	;Checksum
	dw	offset FT_wizthkTargetTable
	dw	seg    FT_wizthkTargetTable
	dd	0	;First-time flag.



	.code _TEXT


externDef ThunkConnect16:far16

public wizthk_ThunkConnect16
wizthk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    wizthk_ThunkData16
	push	offset wizthk_ThunkData16
	push	seg    wizthk_ThkData32
	push	offset wizthk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
wizthk_ThkData32 label byte
	db	"wizthk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfgnt\debug.cpp ===
/*-----------------------------------------------------------------------------
	debug.cpp

	This file implements the debuggin features

	Copyright (c) 1996-1998 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
		7/31/96 ValdonB Changes for Win16
	
-----------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#if defined(WIN16)
extern HINSTANCE g_hInst;
extern LPSTR g_lpszCommandLine;
extern LPSTR GetCommandLine(void);
#endif 

BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(LPCSTR psz)
{
#if defined(_DEBUG)
	OutputDebugString(psz);
#endif	
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(LPCSTR pcsz, ...)
{
#ifdef _DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

#if 0
	vsprintf(szBuf, pcsz, argp);
#else
	wvsprintf(szBuf, pcsz, argp);
#endif
	

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags)
{

	BOOL fAssertIntoDebugger = FALSE;

	char szMsgEx[1024], szTitle[255];
    char szFileName[MAX_PATH + 1] = {0};
	int id;
	UINT fuStyle;
	LPTSTR pszCommandLine = GetCommandLine();
	//BYTE	szTime[80];
#if !defined(WIN16)
	CHAR	szTime[80];
	HANDLE	hAssertTxt;
	SYSTEMTIME st;
	DWORD	cbWritten;
#endif
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz("***Recursive Assert***\r\n");
		return(FALSE);
		}

	fInAssert = TRUE;
	
#if defined(WIN16)
	GetModuleFileName(g_hInst, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%ld\r\n%s,\r\n%s", szFile, dwLine, szFileName, szMsg);
#else
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
#endif
	wsprintf(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
#if !defined(WIN16)
	hAssertTxt = CreateFile("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);   
		wsprintf(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}
#endif

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
#if defined(WIN16)
			exit(0);
#else
    		ExitProcess(0);
#endif
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;  
	
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfgnt\debug.h ===
/****************************************************************************
 *
 *	debug.h
 *
 *	Microsoft Confidential
 *	Copyright (c) 1998-1999 Microsoft Corporation
 *	All rights reserved
 *
 *	Debug support
 *
 *	09/02/99    quintinb    Created Header
 *
 ***************************************************************************/

#ifndef _PHBKDEBUG
#define _PHBKDEBUG

void Dprintf(LPCSTR pcsz, ...);
BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags);
void DebugSz(LPCSTR psz);

DWORD WINAPI GetOSVersion();
DWORD WINAPI GetOSBuildNumber();
DWORD GetOSMajorVersion(void);

//
// OS version macros
//
#define OS_NT51 ((GetOSVersion() == VER_PLATFORM_WIN32_NT) && (GetOSMajorVersion() >= 5) && (GetOSBuildNumber() > 2195))



#ifdef _DEBUG
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)					AssertSzFlg(f, sz, 0)
	#define Assert(f)						AssertSz((f), "!(" #f ")")
#else
	#define AssertSzFlg(f, sz, dwFlg)
	#define AssertSz(f, sz)
	#define Assert(f)
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\strings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  STRINGS.H - Header file for hard-coded strings
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)

#ifndef _STRINGS_H_
#define _STRINGS_H_

// registry strings
extern const CHAR szRegPathSetup[];
extern const CHAR szRegPathClass[];
extern const CHAR szRegPathEnumNet[];
extern const CHAR szRegPathSetupRunOnce[];
extern const CHAR szRegPathSoftwareMicrosoft[];
extern const CHAR szRegValOwner[];
extern const CHAR szRegValOrganization[];
extern const CHAR szRegValDriver[];
extern const CHAR szTCPGlobalKeyName[];
extern const CHAR szRegKeyBindings[];
extern const CHAR szRegValEnableDNS[];
extern const CHAR szRegPathExchangeClientOpt[];
extern const CHAR szRegValSilentRunning[];
extern const CHAR szRegValMlSet[];
extern const CHAR szRegPathComputerName[];
extern const CHAR szRegValComputerName[];
extern const CHAR szRegPathWorkgroup[];
extern const CHAR szRegValWorkgroup[];

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//extern const CHAR szRegPathInternetIconCommand[];

extern const CHAR szRegPathIexploreAppPath[];
extern const CHAR szRegPathDesktop[];
extern const CHAR szRegPathSetupWallpaper[];
extern const CHAR szRegValWallpaper[];
extern const CHAR szRegValTileWallpaper[];

// misc strings
extern const CHAR sz0[];
extern const CHAR sz1[];
extern const CHAR szNull[];
extern const CHAR szVSERVER[];
extern const CHAR szVREDIR[];

#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"
#if 0
#include "string.h"
#endif

#define MAX_MSG_PARAM     8

// function prototypes
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,va_list ArgList);

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    CHAR szMsgBuf[MAX_RES_LEN+1];
  CHAR szSmallBuf[SMALL_BUF_LEN+1];

    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons)
{
  CHAR szSmallBuf[SMALL_BUF_LEN+1];
  LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

  NAME:    MsgBoxParam

  SYNOPSIS:  Displays a message box with the specified string ID

  NOTES:    extra parameters are string pointers inserted into nMsgID.

********************************************************************/
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...)
{
  BUFFER Msg(3*MAX_RES_LEN+1);  // nice n' big for room for inserts
  BUFFER MsgFmt(MAX_RES_LEN+1);

  if (!Msg || !MsgFmt) {
    return MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONSTOP,MB_OK);
  }

    LoadSz(nMsgID,MsgFmt.QueryPtr(),MsgFmt.QuerySize());

  FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
    MsgFmt.QueryPtr(),((CHAR *) &uButtons) + sizeof(uButtons));

  return MsgBoxSz(hWnd,Msg.QueryPtr(),uIcon,uButtons);
}


/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf)
{
  ASSERT(lpszBuf);

  // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

  NAME:    GetErrorDescription

  SYNOPSIS:  Retrieves the text description for a given error code
        and class of error (standard, setupx)

********************************************************************/
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass)
{
  ASSERT(pszErrorDesc);

  // set a leading null in error description
  *pszErrorDesc = '\0';
  
  switch (uErrorClass) {

    case ERRCLS_STANDARD:

      if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
        uError,0,pszErrorDesc,cbErrorDesc,NULL)) {
        // if getting system text fails, make a string a la
        // "error <n> occurred"
        CHAR szFmt[SMALL_BUF_LEN+1];
        LoadSz(IDS_ERRFORMAT,szFmt,sizeof(szFmt));
        wsprintf(pszErrorDesc,szFmt,uError);
      }

      break;

    case ERRCLS_SETUPX:

      GetSETUPXErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    default:

      DEBUGTRAP("Unknown error class %lu in GetErrorDescription",
        uErrorClass);

  }

}
  
/*******************************************************************

  NAME:    FormatErrorMessage

  SYNOPSIS:  Builds an error message by calling FormatMessage

  NOTES:    Worker function for PrepareErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,va_list ArgList)
{
  ASSERT(pszMsg);
  ASSERT(pszFmt);

  // build the message into the pszMsg buffer
  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
    pszFmt,0,0,pszMsg,cbMsg,&ArgList);
  ASSERT(dwCount > 0);
}

/*******************************************************************

  NAME:    PrepareErrorMessage

  SYNOPSIS:  Displays an error message for given error 

  ENTRY:    hWnd - parent window
        uStrID - ID of string resource with message format.
          Should contain %1 to be replaced by error text,
          additional parameters can be specified as well.
        uError - error code for error to display
        uErrorClass - ERRCLS_xxx ID of class of error that
          uError belongs to (standard, setupx)
        uIcon - icon to display
        ... - additional parameters to be inserted in string
          specified by uStrID

********************************************************************/
VOID _cdecl PrepareErrorMessage(UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,...)
{
  // dynamically allocate buffers for messages
  BUFFER ErrorDesc(MAX_RES_LEN+1);
  BUFFER ErrorFmt(MAX_RES_LEN+1);

  if (!ErrorDesc || !ErrorFmt)
  {
    return;
  }

  // get a text description based on the error code and the class
  // of error it is
  GetErrorDescription(ErrorDesc.QueryPtr(),
    ErrorDesc.QuerySize(),uError,uErrorClass);

  // load the string for the message format
  LoadSz(uStrID,ErrorFmt.QueryPtr(),ErrorFmt.QuerySize());

  LPSTR args[MAX_MSG_PARAM];
  args[0] = (LPSTR) ErrorDesc.QueryPtr();
  memcpy(&args[1],((CHAR *) &uIcon) + sizeof(uIcon),(MAX_MSG_PARAM - 1) * sizeof(LPSTR));

  FormatErrorMessage(gpszLastErrorText, MAX_ERROR_TEXT,
    ErrorFmt.QueryPtr(),(va_list) &args[0]);
}

/*******************************************************************

  NAME:    RunMlsetExe

  SYNOPSIS:  Runs mlset32.exe, an Exchange app that needs to be
        run after files are installed otherwise Exchange
        barfs

  NOTES:    We look in registry to find path to mlset32.exe

********************************************************************/
DWORD RunMlsetExe(HWND hwndOwner)
{
  DWORD dwRet = ERROR_SUCCESS;

  // get path to mlset32 out of registry
  RegEntry re(szRegPathSoftwareMicrosoft,HKEY_LOCAL_MACHINE);

  CHAR szAppPath[MAX_PATH+1];
  if (re.GetString(szRegValMlSet,szAppPath,sizeof(szAppPath))) {
    PROCESS_INFORMATION pi;
    STARTUPINFO sti;

    // set "SilentRunning" registry switch to make mlset32
    // not display the Exchange wizard
    RegEntry reSilent(szRegPathExchangeClientOpt,HKEY_LOCAL_MACHINE);
    reSilent.SetValue(szRegValSilentRunning,(DWORD) 1);

    ZeroMemory(&sti,sizeof(STARTUPINFO));
    sti.cb = sizeof(STARTUPINFO);
            
    // launch mlset32.exe
    BOOL fRet = CreateProcess(NULL, (LPSTR) szAppPath,
                           NULL, NULL, FALSE, 0, NULL, NULL,
                           &sti, &pi);
    if (fRet) {
      CloseHandle(pi.hThread);

      // wait for mlset to complete
      MsgWaitForMultipleObjectsLoop(pi.hProcess);

      CloseHandle(pi.hProcess);
    } else {
      dwRet = GetLastError();
    }

    // put our window in front of mlset32's
    SetForegroundWindow(hwndOwner);
  
  } else {
    dwRet = ERROR_FILE_NOT_FOUND;
  }

  return dwRet;
}

/*******************************************************************

  NAME:    RemoveRunOnceEntry

  SYNOPSIS:  Removes the specified value from setup runonce key

  ENTRY:    uResourceID - ID of value name in resource
          (may be localized)

********************************************************************/
VOID RemoveRunOnceEntry(UINT uResourceID)
{
  RegEntry re(szRegPathSetupRunOnce,HKEY_LOCAL_MACHINE);
  CHAR szValueName[SMALL_BUF_LEN+1];
  ASSERT(re.GetError() == ERROR_SUCCESS);
  re.DeleteValue(LoadSz(uResourceID,
    szValueName,sizeof(szValueName)));
}

/*******************************************************************

  NAME:    GenerateComputerNameIfNeeded

  SYNOPSIS:  Makes up and stores in the registry a computer and/or
        workgroup name if not already set.

  NOTES:    If we don't do this, user will get prompted for computer
        name and workgroup.  These aren't meaningful to the user
        so we'll just make something up if these aren't set.

********************************************************************/
BOOL GenerateComputerNameIfNeeded(VOID)
{
  CHAR szComputerName[CNLEN+1]="";
  CHAR szWorkgroupName[DNLEN+1]="";
  BOOL fNeedToSetComputerName = FALSE;

  // get the computer name out of the registry
  RegEntry reCompName(szRegPathComputerName,HKEY_LOCAL_MACHINE);
  if (reCompName.GetError() == ERROR_SUCCESS) {
    reCompName.GetString(szRegValComputerName,szComputerName,
      sizeof(szComputerName));
    if (!lstrlen(szComputerName)) {
      // no computer name set!  make one up
      GenerateDefaultName(szComputerName,sizeof(szComputerName),
        (CHAR *) szRegValOwner,IDS_DEF_COMPUTER_NAME);
      // store the generated computer name in the registry
      reCompName.SetValue(szRegValComputerName,szComputerName);

      // also need to store the computer name in the workgroup key
      // which we will open below... set a flag so we know to do this.
      // (don't ask me why they store the computer name in two places...
      // but we need to set both.)
      fNeedToSetComputerName = TRUE;
    }
  }

  // get the workgroup name out of the registry
  RegEntry reWorkgroup(szRegPathWorkgroup,HKEY_LOCAL_MACHINE);
  if (reWorkgroup.GetError() == ERROR_SUCCESS) {

    // if we set a new computer name up above, then we have to set
    // a 2nd copy of the new name now, in the workgroup key
    if (fNeedToSetComputerName) {
      reWorkgroup.SetValue(szRegValComputerName,szComputerName);
    }


    reWorkgroup.GetString(szRegValWorkgroup,szWorkgroupName,
      sizeof(szWorkgroupName));
    if (!lstrlen(szWorkgroupName)) {
      // no workgroup name set!  make one up
      GenerateDefaultName(szWorkgroupName,sizeof(szWorkgroupName),
        (CHAR *) szRegValOrganization,IDS_DEF_WORKGROUP_NAME);
      // store the generated workgroup name in the registry
      reWorkgroup.SetValue(szRegValWorkgroup,szWorkgroupName);
    }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    GenerateDefaultName

  SYNOPSIS:  Generates default computer or workgroup name

  ENTRY:    pszName - buffer to be filled in with name
        cbName - size of cbName buffer
        pszRegValName - name of registry value in ...Windows\CurrentVersion
          key to generate name from
        uIDDefName - ID of string resource to use if no value is
          present in registry to generate name from

********************************************************************/
BOOL GenerateDefaultName(CHAR * pszName,DWORD cbName,CHAR * pszRegValName,
  UINT uIDDefName)
{
  ASSERT(pszName);
  ASSERT(pszRegValName);

  *pszName = '\0';  // NULL-terminate buffer

  // look for registered owner/organization name in registry
  RegEntry reSetup(szRegPathSetup,HKEY_LOCAL_MACHINE);
  if (reSetup.GetError() == ERROR_SUCCESS) {
    if (reSetup.GetString(pszRegValName,pszName,cbName) &&
      lstrlen(pszName)) {
      // got string from registry... now terminate at first whitespace
      CHAR * pch = pszName;
      while (*pch) {
        if (*pch == ' ') {
          // found a space, terminate here and stop
          *pch = '\0';           
        } else {
          // advance to next char, keep going
          pch = CharNext(pch);
        }
      }
      // all done!
      return TRUE; 
    }
  }
  
  // couldn't get this name from registry, go for our fallback name
  // from resource

  LoadSz(uIDDefName,pszName,cbName);
  return TRUE;
}

/*******************************************************************

  NAME:    MsgWaitForMultipleObjectsLoop

  SYNOPSIS:  Blocks until the specified object is signaled, while
        still dispatching messages to the main thread.

********************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE,INFINITE, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
      // got a message, dispatch it and wait again
      while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
        DispatchMessage(&msg);
      }
            break;
        }
    }
    // never gets here
}


/*******************************************************************
// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.


  NAME:    SetDesktopInternetIconToBrowser

  SYNOPSIS:  "Points" The Internet desktop icon to web browser
        (Internet Explorer)

  NOTES:    The Internet icon may initially "point" at this wizard,
        we need to set it to launch web browser once we complete
        successfully.

********************************************************************/
/********BOOL SetDesktopInternetIconToBrowser(VOID)
{
	CHAR szAppPath[MAX_PATH+1]="";
	BOOL fRet = FALSE;

	// look in the app path section in registry to get path to internet
	// explorer

	RegEntry reAppPath(szRegPathIexploreAppPath,HKEY_LOCAL_MACHINE);
	ASSERT(reAppPath.GetError() == ERROR_SUCCESS);
	if (reAppPath.GetError() == ERROR_SUCCESS) {

		reAppPath.GetString(szNull,szAppPath,sizeof(szAppPath));
		ASSERT(reAppPath.GetError() == ERROR_SUCCESS);

	}

	// set the path to internet explorer as the open command for the 
	// internet desktop icon
	if (lstrlen(szAppPath)) {
		RegEntry reIconOpenCmd(szRegPathInternetIconCommand,HKEY_CLASSES_ROOT);
		ASSERT(reIconOpenCmd.GetError() == ERROR_SUCCESS);
		if (reIconOpenCmd.GetError() == ERROR_SUCCESS) {
			UINT uErr = reIconOpenCmd.SetValue(szNull,szAppPath);
			ASSERT(uErr == ERROR_SUCCESS);
			
			fRet = (uErr == ERROR_SUCCESS);
		}
	}

	return fRet;
}
******/

/*******************************************************************

  NAME:    PrepareForRunOnceApp

  SYNOPSIS:  Copies wallpaper value in registry to make the runonce
        app happy

  NOTES:    The runonce app (the app that displays a list of apps
        that are run once at startup) has a bug.  At first boot,
        it wants to change the wallpaper from the setup wallpaper
        to what the user had before running setup.  Setup tucks
        the "old" wallpaper away in a private key, then changes
        the wallpaper to the setup wallpaper.  After the runonce
        app finishes, it looks in the private key to get the old
        wallpaper and sets that to be the current wallpaper.
        However, it does this all the time, not just at first boot!
        The end effect is that whenever you do anything that
        causes runonce.exe to run (add stuff thru add/remove
        programs control panel), your wallpaper gets set back to
        whatever it was when you installed win 95.  This is
        especially bad for Plus!, since wallpaper settings are an
        important part of the product.

        To work around this bug, we copy the current wallpaper settings
        (which we want preserved) to setup's private key.  When
        runonce runs it will say "aha!" and copy those values back
        to the current settings.

********************************************************************/
VOID PrepareForRunOnceApp(VOID)
{
  // open a key to the current wallpaper settings
  RegEntry reDesktop(szRegPathDesktop,HKEY_CURRENT_USER);
  ASSERT(reDesktop.GetError() == ERROR_SUCCESS);

  // open a key to the private setup section
  RegEntry reSetup(szRegPathSetupWallpaper,HKEY_LOCAL_MACHINE);
  ASSERT(reSetup.GetError() == ERROR_SUCCESS);

  if (reDesktop.GetError() == ERROR_SUCCESS &&
    reSetup.GetError() == ERROR_SUCCESS) {
    CHAR szWallpaper[MAX_PATH+1]="";
    CHAR szTiled[10]="";  // big enough for "1" + slop

    // get the current wallpaper name
    if (reDesktop.GetString(szRegValWallpaper,szWallpaper,
      sizeof(szWallpaper))) {

      // set the current wallpaper name in setup's private section
      UINT uRet=reSetup.SetValue(szRegValWallpaper,szWallpaper);
      ASSERT(uRet == ERROR_SUCCESS);

      // get the current 'tiled' value. 
      reDesktop.GetString(szRegValTileWallpaper,szTiled,
        sizeof(szTiled));

      // set the 'tiled' value in setup's section
      if (lstrlen(szTiled)) {
        uRet=reSetup.SetValue(szRegValTileWallpaper,szTiled);
        ASSERT(uRet == ERROR_SUCCESS);
      }
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfg9x\strings.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  STRINGS.C - String literals for hard-coded strings
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)

#include "pch.hpp"

#pragma data_seg(DATASEG_READONLY)

//////////////////////////////////////////////////////
// registry strings
//////////////////////////////////////////////////////

// "Software\\Microsoft\\Windows\\CurrentVersion"
static const CHAR szRegPathSetup[] =       REGSTR_PATH_SETUP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\"
static const CHAR szRegPathClass[] =       REGSTR_PATH_CLASS "\\";

// "Enum\\Network\\"
static const CHAR szRegPathEnumNet[] =      REGSTR_PATH_ENUM "\\Network\\";

// "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup"
static const CHAR szRegPathSetupRunOnce[] =   REGSTR_PATH_RUNONCE "\\Setup";

static const CHAR szRegPathSoftwareMicrosoft[]= "Software\\Microsoft";

// "RegisteredOwner"
static const CHAR szRegValOwner[] =       REGSTR_VAL_REGOWNER;

// "RegisteredOrganization"
static const CHAR szRegValOrganization[] =     REGSTR_VAL_REGORGANIZATION;

static const CHAR szRegValDriver[] =      "Driver";

// "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
static const CHAR szTCPGlobalKeyName[] =     REGSTR_PATH_VXD "\\MSTCP";

// "RemoteAccess"
static const CHAR szRegKeyBindings[] =      "Bindings";
static const CHAR szRegValEnableDNS[] =     "EnableDNS";

static const CHAR szRegPathExchangeClientOpt[] = "Software\\Microsoft\\Exchange\\Client\\Options";
static const CHAR szRegValSilentRunning[] =    "SilentRunning";
static const CHAR szRegValMlSet[] =        "MlSet";

// "System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"
static const CHAR szRegPathComputerName[] =     REGSTR_PATH_COMPUTRNAME;

// "ComputerName"
static const CHAR szRegValComputerName[] =      REGSTR_VAL_COMPUTRNAME;

// "System\\CurrentControlSet\\Services\\VxD\\VNETSUP"
static const CHAR szRegPathWorkgroup[] =    REGSTR_PATH_VNETSUP;

// "Workgroup"
static const CHAR szRegValWorkgroup[] =      REGSTR_VAL_WORKGROUP;

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//static const CHAR szRegPathInternetIconCommand[] = "CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\Shell\\Open\\Command";
static const CHAR szRegPathIexploreAppPath[] =  "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

// "Control Panel\\Desktop"
static const CHAR szRegPathDesktop[] =      REGSTR_PATH_DESKTOP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
static const CHAR szRegPathSetupWallpaper[] =  REGSTR_PATH_SETUP REGSTR_KEY_SETUP;

static const CHAR szRegValWallpaper[] =      "Wallpaper";
static const CHAR szRegValTileWallpaper[] =    "TileWallpaper";


//////////////////////////////////////////////////////
// misc strings
//////////////////////////////////////////////////////
static const CHAR sz0[]  =       "0";
static const CHAR sz1[]  =        "1";
static const CHAR szNull[] =       "";
static const CHAR szVSERVER[] =     "VSERVER";
static const CHAR szVREDIR[] =      "VREDIR";

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmcfg\cmcfg.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmcfg.cpp
//
// Module:   CMCFG32.DLL
//
// Synopsis: This DLL contains the call CMConfig that transfers information from
//           a connectoid created by Connection Wizard to a Connection Manager
//           profile. The phone number, username, and password are transferred.
//           If a backup phone number exists in the pszInsFile, it also transferss
//           The backup file. The name of the connectoid to translate is pszDUN.
//           The format of the .ins file includes:
//
//           [Backup Phone]
//           Phone_Number=<TAPI phone number starting with + or literal dial string>
//
//           If the number starts with a +, it is assumed to be TAPI formatted
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   a-frankh   created         05/06/97
//           nickball   cleaned-up      04/08/98
//           quintinb   deprecated the CMConfig private interface  03/23/01
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

HINSTANCE g_hInst;

//+---------------------------------------------------------------------------
//
//	Function:	CMConfig
//
//	Synopsis:	Transfers user information to CM profile
//				
//	Arguments:	LPCSTR pszInsFile - full pathname of .ins file, pass NULL if no .ins file
//				LPCSTR pszDUN - name of connectoid/CM profile
//				THE NAME OF THE CONNECTOID AND SERVICE NAME OF THE CM PROFILE MUST MATCH!
//  
//	Notes: Operates by finding the location of the CM directory. Looks for .cmp files and
//	gets the .cms file. Looks in the .cms file for the service name and compares it.	
//
//
//	Returns:	TRUE if successful.
//
//	History:	a-frankh - Created - 5/6/97
//----------------------------------------------------------------------------

extern "C" BOOL WINAPI CMConfig(LPSTR pszInsFile, LPSTR pszDUN ) 
{
    CMASSERTMSG(FALSE, TEXT("CMConfig -- The CMConfig Private Interface has been deprecated -- returning failure."));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  DllMain
//
// Synopsis:  Main entry point into the DLL.
//
// Arguments: HINSTANCE  hinstDLL - Our HINSTANCE
//            DWORD  fdwReason - The reason we are being called.
//            LPVOID  lpvReserved - Reserved
//
// Returns:   BOOL WINAPI - TRUE - always
//
// History:   nickball    Created Header    4/8/98
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HINSTANCE  hinstDLL, DWORD  fdwReason, LPVOID  lpvReserved) 
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hinstDLL;

        //
        // Disable thread attach notification
        //

        DisableThreadLibraryCalls(hinstDLL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfgnt\tapi.cpp ===
/****************************************************************************
 *
 *	tapi.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) 1998 Microsoft Corporation
 *	All rights reserved
 *
 *	Implementation of ICW's interaction with TAPI on NT
 *
 *	09/02/99    quintinb    Created Header
 *
 ***************************************************************************/
#include <windows.h>
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <tapi.h>


//
// The code below is stolen from private/net/ras/src/ui/setup/src/tapiconf.cxx
//

#define REGISTRY_INSTALLED_TAPI  SZ("HARDWARE\\DEVICEMAP\\TAPI DEVICES\\")
#define REGISTRY_ALTERNATE_TAPI  SZ("SOFTWARE\\MICROSOFT\\TAPI DEVICES\\")

// note that this definition DOES NOT have trailing \\, because DeleteTree
// doesn't like it.
#define REGISTRY_CONFIGURED_TAPI SZ("SOFTWARE\\MICROSOFT\\RAS\\TAPI DEVICES")

#define TAPI_MEDIA_TYPE          SZ("Media Type")
#define TAPI_PORT_ADDRESS        SZ("Address")
#define TAPI_PORT_NAME           SZ("Friendly Name")
#define TAPI_PORT_USAGE          SZ("Usage")

#define LOW_MAJOR_VERSION   0x0001
#define LOW_MINOR_VERSION   0x0003
#define HIGH_MAJOR_VERSION  0x0002
#define HIGH_MINOR_VERSION  0x0000

#define LOW_VERSION  ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)

#define MAX_DEVICE_TYPES 64

VOID RasTapiCallback (HANDLE, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD EnumerateTapiModemPorts(DWORD dwBytes, LPSTR szPortsBuf, 
								BOOL bWithDelay = FALSE);



DWORD
EnumerateTapiModemPorts(DWORD dwBytes, LPSTR szPortsBuf, BOOL bWithDelay) {
    LINEINITIALIZEEXPARAMS params;
    LINEADDRESSCAPS        *lineaddrcaps ;
    LINEDEVCAPS            *linedevcaps ;
    LINEEXTENSIONID        extensionid ;
    HLINEAPP               RasLine ;
    HINSTANCE              RasInstance = GetModuleHandle(TEXT("ICFGNT.DLL"));
    DWORD                  NegotiatedApiVersion ;
    DWORD                  NegotiatedExtVersion = 0;
    WORD                   i, k ;
    DWORD                  lines = 0 ;
    BYTE                   buffer[1000] ;
    DWORD                  totaladdress = 0;
    CHAR                   *address ;
    CHAR                   szregkey[512];
    LONG                   lerr;
    DWORD                  dwApiVersion = HIGH_VERSION;
    LPSTR                  szPorts = szPortsBuf;

    *szPorts = '\0';
    dwBytes--;

    ZeroMemory(&params, sizeof(params));

    params.dwTotalSize = sizeof(params);
    params.dwOptions   = LINEINITIALIZEEXOPTION_USEEVENT;

    /* the sleep is necessary here because if this routine is called just after a modem
    ** has been added from modem.cpl & unimdm.tsp is running,
    ** then a new modem added doesn't show up in the tapi enumeration.
    */

    //
	// We should not always sleep here - should sleep only if ModemWizard was
	// launched recently  -- VetriV
	//
	if (bWithDelay)
		Sleep(1000L);

    if (lerr = lineInitializeExW (&RasLine,
                                 RasInstance,
                                 (LINECALLBACK) RasTapiCallback,
                                 NULL,
                                 &lines,
                                 &dwApiVersion,
                                 &params))
    {
         return lerr;
    }

    // Go through all lines to see if we can find a modem
    for (i=0; i<lines; i++)
    {  // for all lines we are interested in get the addresses -> ports

       if (lineNegotiateAPIVersion(RasLine, i, LOW_VERSION, HIGH_VERSION, &NegotiatedApiVersion, &extensionid))
       {
           continue ;
       }

       memset (buffer, 0, sizeof(buffer)) ;

       linedevcaps = (LINEDEVCAPS *)buffer ;
       linedevcaps->dwTotalSize = sizeof (buffer) ;

       // Get a count of all addresses across all lines
       //
       if (lineGetDevCapsW (RasLine, i, NegotiatedApiVersion, NegotiatedExtVersion, linedevcaps))
       {
           continue ;
       }

       // is this a modem?
       if ( linedevcaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM )  {
            // first convert all nulls in the device class string to non nulls.
            //
            DWORD  j ;
            WCHAR *temp ;

            for (j=0, temp = (WCHAR*)((BYTE *)linedevcaps+linedevcaps->dwDeviceClassesOffset); j<linedevcaps->dwDeviceClassesSize; j++, temp++)
            {
              if (*temp == L'\0')
                 *temp = L' ' ;
            }

            //
            // select only those devices that have comm/datamodem as a device class
            //

            LPWSTR wszClassString = wcsstr((WCHAR*)((CHAR *)linedevcaps+linedevcaps->dwDeviceClassesOffset), L"comm/datamodem");
            if(wszClassString == NULL)
                continue;
        }

        LONG lRet;
        HLINE lhLine = 0;

        lRet = lineOpen(RasLine, i, &lhLine, dwApiVersion, 0, 0, LINECALLPRIVILEGE_NONE, 0, NULL);
        if(lRet != 0)
            continue;

        LPVARSTRING lpVarString;
        char buf[1000];
        lpVarString = (LPVARSTRING) buf;
        lpVarString->dwTotalSize = 1000;

        lRet = lineGetID(lhLine, 0, 0, LINECALLSELECT_LINE,
                (LPVARSTRING) lpVarString, TEXT("comm/datamodem/portname"));

        if(lRet != 0)
            continue;

        LPSTR szPortName = NULL;

        if (lpVarString->dwStringSize)
            szPortName = (LPSTR) ((LPBYTE) lpVarString + ((LPVARSTRING) lpVarString) -> dwStringOffset);
        //
        // Append port name to port list
        //

        UINT len = (szPortName ? strlen(szPortName) + 1 : 0);
        if(dwBytes < len)
        {
            if (lhLine) lineClose(lhLine);
            lineShutdown(RasLine);
            return(ERROR_SUCCESS);
        }

        if (szPortName)
        {
            strcpy(szPorts, szPortName);
            szPorts += len;
            *szPorts = '\0';
        }

        if (lhLine) lineClose(lhLine);
    }

    lineShutdown(RasLine);
    return ERROR_SUCCESS ;
}

VOID FAR PASCAL
RasTapiCallback (HANDLE context, DWORD msg, DWORD instance, DWORD param1, DWORD param2, DWORD param3)
{
   // dummy callback routine because the full blown TAPI now demands that
   // lineinitialize provide this routine.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfgnt\icfgnt5.cpp ===
/****************************************************************************
 *
 *  icfg32.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1999 Microsoft Corporation
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the NT specific functionality of inetcfg
 *
 *  6/5/97  ChrisK  Inherited from AmnonH
 *  7/3/97  ShaunCo Modfied for NT5
 *
 ***************************************************************************/
#define UNICODE
#define _UNICODE

#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <lmsname.h>
#include "debug.h"

#include <netcfgx.h>

const LPTSTR gc_szIsdnSigature = TEXT("\\NET\\");

#define REG_DATA_EXTRA_SPACE 255
#define DEVICE_INSTANCE_SIZE 128

extern DWORD g_dwLastError;


typedef BOOL (WINAPI *PFNINSTALLNEWDEVICE) (HWND hwndParent,
                                                LPGUID ClassGuid,
                                                PDWORD pReboot);
/*++

Routine Description:

   Exported Entry point from newdev.cpl. Installs a new device. A new Devnode is
   created and the user is prompted to select the device. If the class guid
   is not specified then then the user begins at class selection.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   LPGUID ClassGuid - Optional class of the new device to install.
                      If ClassGuid is NULL we start at detection choice page.
                      If ClassGuid == GUID_NULL or GUID_DEVCLASS_UNKNOWN
                         we start at class selection page.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.
*/


// For the code that was copied from netcfg, make the TraceError stuff
// go away.  Likewise for existing debug statements.
//
#define TraceError
#define Dprintf

ULONG
ReleaseObj (
        IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateAndInitializeINetCfg
//
//  Purpose:    Cocreate and initialize the root INetCfg object.  This will
//              optionally initialize COM for the caller too.
//
//  Arguments:
//      pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
//                                 returns TRUE if COM was successfully
//                                 initialized FALSE if not.  If NULL, means
//                                 don't initialize COM.
//      ppnc            [out]  The returned INetCfg object.
//      fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
//      cmsTimeout      [in]   See INetCfg::AcquireWriteLock
//      szwClientDesc   [in]   See INetCfg::AcquireWriteLock
//      pbstrClientDesc [in]   See INetCfg::AcquireWriteLock
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:
//
HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    BSTR*       pbstrClientDesc)
{
    Assert (ppnc);

    // Initialize the output parameter.
    *ppnc = NULL;

    // Initialize COM if the caller requested.
    HRESULT hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            if (pfInitCom)
            {
                *pfInitCom = FALSE;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, reinterpret_cast<void**>(&pnc));
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         reinterpret_cast<LPVOID *>(&pnclock));
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->AcquireWriteLock(cmsTimeout, szwClientDesc,
                                               pbstrClientDesc);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize (NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef ();
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->ReleaseWriteLock();
                    }
                }
                // Transfer reference to caller.
            }
            ReleaseObj(pnclock);

            ReleaseObj(pnc);
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }
    }
    TraceError("HrCreateAndInitializeINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndUnlockINetCfg
//
//  Purpose:    Uninitializes and unlocks the INetCfg object
//
//  Arguments:
//      pnc [in]    INetCfg to uninitialize and unlock
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc)
{
    HRESULT     hr = S_OK;

    hr = pnc->Uninitialize();
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->ReleaseWriteLock();

            ReleaseObj(pnclock);
        }
    }

    TraceError("HrUninitializeAndUnlockINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock)
{
    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->Uninitialize ();
    }

    ReleaseObj (pnc);

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    TraceError("HrUninitializeAndReleaseINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponent
//
//  Purpose:    Install the component with a specified id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pguidClass      [in] Class guid of the component to install.
//      pszwComponentId [in] Component id to install.
//      ppncc           [out] (Optional) Returned component that was
//                            installed.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco     4 Jan 1998
//
//  Notes:      nickball    7 May 1999 - Removed unused pszwOboToken parameter  
//
HRESULT
HrInstallComponent (
    INetCfg*                        pnc,
    const GUID*                     pguidClass,
    LPCWSTR                         pszwComponentId,
    INetCfgComponent**              ppncc)
{
    OBO_TOKEN   oboToken;

    Assert (pnc);
    Assert (pszwComponentId);

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Get the class setup object.
    //
    INetCfgClassSetup* pncclasssetup;

    ZeroMemory((PVOID)&oboToken, sizeof(oboToken));
    oboToken.Type = OBO_USER;
    
    //NT #330252 
    //oboToken.pncc = *ppncc;
    //oboToken. fRegistered = TRUE;

    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                    reinterpret_cast<void**>(&pncclasssetup));
    if (SUCCEEDED(hr))
    {
        hr = pncclasssetup->Install (pszwComponentId,
                &oboToken, 0, 0, NULL, NULL, ppncc);

        ReleaseObj (pncclasssetup);
    }
    TraceError("HrInstallComponent", hr);
    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   CallModemInstallWizard
//
//  Synopsis:   Invoke modem install wizard via SetupDi interfaces
//
//  Arguments:  hwnd - handle to parent window
//
//  Returns:    TRUE - success, FALSE - failed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
//
// The following code was stolen from RAS
//

BOOL
CallModemInstallWizardNT5(HWND hwnd)
{
   BOOL     fReturn = FALSE;
   PFNINSTALLNEWDEVICE pfn;
   HINSTANCE hInst;

   Dprintf("ICFGNT: CallModemInstallWizard\n");

   //
   // Load newdev.dll can call the InstallNewDevice method with Modem device class
   //
   hInst = LoadLibrary((LPCTSTR) L"newdev.dll");
   if (NULL == hInst)
   {
       goto CleanupAndExit;
   }

   pfn = (PFNINSTALLNEWDEVICE) GetProcAddress(hInst, (LPCSTR)"InstallNewDevice");
   if (NULL == pfn)
   {
       goto CleanupAndExit;
   }

   //
   // Call the function - on NT5 modem installation should not require
   // reboot; so that last parameter, which is used to return if restart/reboot
   // is required can be NULL
   //
   fReturn = pfn(hwnd, (LPGUID) &GUID_DEVCLASS_MODEM, NULL);


CleanupAndExit:

   if (NULL != hInst)
   {
       FreeLibrary(hInst);
   }
   return fReturn;
}



//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedModem
//
//  Synopsis:   Check system configuration to determine if there is at least
//              one physical modem installed
//
//  Arguments:  dwfOptions - currently not used
//
//  Returns:    HRESULT - S_OK if successfull
//              lpfNeedModem - TRUE if no modems are available
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedModemNT5(DWORD dwfOptions, LPBOOL lpfNeedModem)
{
    //
    // Ras is installed, and ICW wants to know if it needs to
    // install a modem.
    //
    *lpfNeedModem = TRUE;

    // Get the device info set for modems.
    //
    HDEVINFO hdevinfo = SetupDiGetClassDevs((GUID*)&GUID_DEVCLASS_MODEM,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT);
    if (hdevinfo)
    {
        SP_DEVINFO_DATA diData;
        diData.cbSize = sizeof(diData);

        // Look for at least one modem.
        //
        if (SetupDiEnumDeviceInfo(hdevinfo, 0, &diData))
        {
            *lpfNeedModem = FALSE;
        }

        SetupDiDestroyDeviceInfoList (hdevinfo);
    }

    if (*lpfNeedModem)
    {
        //
        // check for ISDN adaptors
        //
        // Get the device info set for modems.
        //
        hdevinfo = SetupDiGetClassDevs((GUID*)&GUID_DEVCLASS_NET,
                                       NULL,
                                       NULL,
                                       DIGCF_PRESENT);
        if (hdevinfo)
        {
            TCHAR   szDevInstanceId[DEVICE_INSTANCE_SIZE];
            DWORD   dwIndex = 0;
            DWORD   dwRequiredSize;
            SP_DEVINFO_DATA diData;
            diData.cbSize = sizeof(diData);

            //
            // look for an ISDN device
            //
            while (SetupDiEnumDeviceInfo(hdevinfo, dwIndex, &diData))
            {
                if (SetupDiGetDeviceInstanceId(hdevinfo,
                                               &diData,
                                               szDevInstanceId,
                                               sizeof(szDevInstanceId) / sizeof(szDevInstanceId[0]),
                                               &dwRequiredSize))
                {
                    HKEY    hReg, hInterface;
                    TCHAR   szLowerRange[MAX_PATH + 1];
                    DWORD   cb = sizeof(szLowerRange);

                    hReg = SetupDiOpenDevRegKey(hdevinfo, &diData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
                    if (hReg != INVALID_HANDLE_VALUE)
                    {
                        if (RegOpenKey(hReg, TEXT("Ndi\\Interfaces"), &hInterface) == ERROR_SUCCESS)
                        {
                            if (RegQueryValueEx(hInterface, TEXT("LowerRange"), 0, NULL, (PBYTE) szLowerRange, &cb) == ERROR_SUCCESS)
                            {
                                int iRetVal = 0;

                                if (OS_NT51)
                                {
                                    iRetVal = CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szLowerRange, -1, TEXT("isdn"), -1); 
                                }
                                else
                                {
                                    DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
                                    iRetVal = CompareString(lcid, NORM_IGNORECASE, szLowerRange, -1, TEXT("isdn"), -1);
                                }
                                
                                if (CSTR_EQUAL == iRetVal)
                                {
                                    *lpfNeedModem = FALSE;
                                    break;
                                }
                            }
                            RegCloseKey(hInterface);
                        }
                        RegCloseKey(hReg);
                    }

                    //
                    // ISDN adaptors are in the form XXX\NET\XXX
                    //
                    if (_tcsstr(szDevInstanceId, gc_szIsdnSigature))
                    {
                        *lpfNeedModem = FALSE;
                        break;
                    }
                }

                dwIndex++;
            }

            SetupDiDestroyDeviceInfoList (hdevinfo);
        }
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallModem
//
//  Synopsis:
//              This function is called when ICW verified that RAS is installed,
//              but no modems are avilable. It needs to make sure a modem is availble.
//              There are two possible scenarios:
//
//              a.  There are no modems installed.  This happens when someone deleted
//                  a modem after installing RAS. In this case we need to run the modem
//                  install wizard, and configure the newly installed modem to be a RAS
//                  dialout device.
//
//              b.  There are modems installed, but non of them is configured as a dial out
//                  device.  In this case, we silently convert them to be DialInOut devices,
//                  so ICW can use them.
//
//  Arguments:  hwndParent - handle to parent window
//              dwfOptions - not used
//
//  Returns:    lpfNeedsStart - not used
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallModemNT5(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart)
{
    //
    // Fire up the modem install wizard
    //
    if (!CallModemInstallWizardNT5(hwndParent))
    {
        return(g_dwLastError = GetLastError());
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedInetComponets
//
//  Synopsis:   Check to see if the components marked in the options are
//              installed on the system
//
//  Arguements: dwfOptions - set of bit flag indicating which components to
//              check for
//
//  Returns;    HRESULT - S_OK if successfull
//              lpfNeedComponents - TRUE is some components are not installed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedInetComponentsNT5(DWORD dwfOptions, LPBOOL lpfNeedComponents)
{
    Dprintf("ICFGNT: IcfgNeedInetComponents\n");

    //
    // Assume we have what we need.
    //
    *lpfNeedComponents = FALSE;

    HRESULT     hr          = S_OK;
    INetCfg*    pnc         = NULL;
    BOOL        fInitCom    = TRUE;

    // If the optiona are such that we need an INetCfg interface pointer,
    // get one.
    //
    if ((dwfOptions & ICFG_INSTALLTCP) ||
        (dwfOptions & ICFG_INSTALLRAS))
    {
        hr = HrCreateAndInitializeINetCfg (&fInitCom, &pnc,
                FALSE, 0, NULL, NULL);
    }

    // Look for TCP/IP using the INetCfg interface.
    //
    if (SUCCEEDED(hr) && (dwfOptions & ICFG_INSTALLTCP))
    {
        Assert (pnc);

        hr = pnc->FindComponent (NETCFG_TRANS_CID_MS_TCPIP, NULL);
        if (S_FALSE == hr)
        {
            *lpfNeedComponents = TRUE;
        }
    }

    // We no longer need the INetCfg interface pointer, so release it.
    //
    if (pnc)
    {
        (void) HrUninitializeAndReleaseINetCfg (fInitCom, pnc, FALSE);
    }

    // Normalize the HRESULT.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallInetComponentsNT5
//
//  Synopsis:   Install the components as specified by the dwfOptions values
//
//  Arguments   hwndParent - handle to parent window
//              dwfOptions - set of bit flags indicating which components to
//                  install
//
//  Returns:    HRESULT - S_OK if success
//              lpfNeedsReboot - TRUE if reboot is required
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallInetComponentsNT5(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart)
{
    Dprintf("ICFGNT: IcfgInstallInetComponents\n");

    //
    // Assume don't need restart
    //
    *lpfNeedsRestart = FALSE;

    HRESULT     hr          = S_OK;
    INetCfg*    pnc         = NULL;
    BOOL        fInitCom    = TRUE;

    // If the optiona are such that we need an INetCfg interface pointer,
    // get one.
    //
    if ((dwfOptions & ICFG_INSTALLTCP) ||
        (dwfOptions & ICFG_INSTALLRAS))
    {
        BSTR bstrClient;
        hr = HrCreateAndInitializeINetCfg (&fInitCom, &pnc, TRUE,
                0, L"", &bstrClient);
    }

    // Install TCP/IP on behalf of the user.
    //
    if (SUCCEEDED(hr) && (dwfOptions & ICFG_INSTALLTCP))
    {
        hr = HrInstallComponent (pnc, &GUID_DEVCLASS_NETTRANS,
                    NETCFG_TRANS_CID_MS_TCPIP, NULL);
    }

    // We no longer need the INetCfg interface pointer, so release it.
    //
    if (pnc)
    {
        // Apply the changes if everything was successful.
        //
        if (SUCCEEDED(hr))
        {
            hr = pnc->Apply();

            if (NETCFG_S_REBOOT == hr)
            {
                *lpfNeedsRestart = TRUE;
            }
        }
        (void) HrUninitializeAndReleaseINetCfg (fInitCom, pnc, TRUE);
    }

    // Normalize the HRESULT.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfgnt\icfgnt4.cpp ===
/****************************************************************************
 *
 *  icfg32.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1998 Microsoft Corporation
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the NT specific functionality of inetcfg
 *
 *  6/5/97  ChrisK  Inherited from AmnonH
 *
 ***************************************************************************/

#define INITGUID
#include <windows.h>
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <lmsname.h>
#include "debug.h"

const DWORD INFINSTALL_PRIMARYINSTALL = 0x00000001;
const DWORD INFINSTALL_INPROCINTERP   = 0x00000002;

#define REG_DATA_EXTRA_SPACE 255
#define CELEMS(x) ((sizeof(x))/(sizeof(x[0])))

DWORD (WINAPI *pfnNetSetupReviewBindings)(HWND hwndParent,
                DWORD dwBindFlags);
DWORD (WINAPI *pfnNetSetupComponentInstall)(HWND   hwndParent,
                PCWSTR pszInfOption,
                PCWSTR pszInfName,
                PCWSTR pszInstallPath,
                PCWSTR plszInfSymbols,
                DWORD  dwInstallFlags,
                PDWORD dwReturn);
DWORD (WINAPI *pfnNetSetupComponentRemove)(HWND hwndParent,
                PCWSTR pszInfOption,
                DWORD dwInstallFlags,
                PDWORD pdwReturn);
DWORD (WINAPI *pfnNetSetupComponentProperties)(HWND hwndParent,
                PCWSTR pszInfOption,
                DWORD dwInstallFlags,
                PDWORD pdwReturn);
DWORD (WINAPI *pfnNetSetupFindHardwareComponent)(PCWSTR pszInfOption,
                PWSTR pszInfName,
                PDWORD pcchInfName,
                PWSTR pszRegBase,     // optional, may be NULL
                PDWORD pcchRegBase ); // optional, NULL if pszRegBase is NULL
DWORD (WINAPI *pfnNetSetupFindSoftwareComponent)(PCWSTR pszInfOption,
                PWSTR pszInfName,
                PDWORD pcchInfName,
                PWSTR pszRegBase /*= NULL*/,
                PDWORD pcchRegBase /*= NULL*/);
DWORD (WINAPI *pfnRegCopyTree)();

HINSTANCE g_hNetcfgInst = NULL;
LPWSTR    g_wszInstallPath = 0;
DWORD     g_dwLastError = ERROR_SUCCESS;
extern DWORD EnumerateTapiModemPorts(DWORD dwBytes, LPSTR szPortsBuf, 
                                        BOOL bWithDelay = FALSE);

typedef struct tagFunctionTableEntry {
    LPVOID  *pfn;
    LPSTR   szEntryPoint;
} FunctionTableEntry;

#define REGISTRY_NT_CURRENTVERSION "SOFTWARE\\MICROSOFT\\WINDOWS NT\\CurrentVersion"

FunctionTableEntry NetcfgTable[] = {
    { (LPVOID *) &pfnNetSetupComponentInstall, "NetSetupComponentInstall" },
    { (LPVOID *) &pfnNetSetupFindSoftwareComponent, "NetSetupFindSoftwareComponent" },
    { (LPVOID *) &pfnNetSetupReviewBindings, "NetSetupReviewBindings" },
    { (LPVOID *) &pfnNetSetupComponentRemove, "NetSetupComponentRemove" },
    { (LPVOID *) &pfnNetSetupComponentProperties, "NetSetupComponentProperties" },
    { (LPVOID *) &pfnNetSetupFindHardwareComponent, "NetSetupFindHardwareComponent" },
    { 0, 0 }
};

typedef struct tagNetSetup
{
   WCHAR szOption[16];
   WCHAR szInfName[16];
} NETSETUP;

NETSETUP g_netsetup[] = { L"WKSTA", L"OEMNSVWK.INF",
                        L"SRV", L"OEMNSVSV.INF",
                        L"NETBIOS", L"OEMNSVNB.INF",
                        L"RPCLOCATE", L"OEMNSVRP.INF" };

#define NSERVICES (sizeof g_netsetup / sizeof g_netsetup[0])

inline stricmp(LPSTR s1, LPSTR s2) {
    while(*s1 && *s2) {
        char c1, c2;
        c1 = islower(*s1) ? toupper(*s1) : *s1;
        c2 = islower(*s2) ? toupper(*s2) : *s2;
        if(c1 != c2)
        {
            break;
        }
        s1++; s2++;
    }

    return(*s1 - *s2);
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadLibraryToFunctionTable
//
//  Synopsis:   Load structure with function pointers from FunctionTable
//
//  Arguments:  pTab - array of function to be loaded
//              szDLL - name of DLL to load function from
//
//  Returns:    Handle to szDLL (NULL indicates failure)
//
//  History:    6/5/97  Chrisk  Inherited
//
//-----------------------------------------------------------------------------
HINSTANCE
LoadLibraryToFunctionTable(FunctionTableEntry *pTab, LPSTR szDLL)
{
    HINSTANCE hInst;

    Dprintf("ICFGNT: LoadLibraryToFunctionTable\n");
    hInst = LoadLibrary(szDLL);
    if(hInst == 0)
    {
        return(hInst);
    }

    while(pTab->pfn) {
        *pTab->pfn = (LPVOID) GetProcAddress(hInst, pTab->szEntryPoint);
        if(*pTab->pfn == 0) 
        {
            FreeLibrary(hInst);
            return(0);
        }
        pTab++;
    }

    return(hInst);
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadNetcfg
//
//  Synopsis:   Load netcfg.dll and function poiners
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if sucessfull and !ERROR_SUCCESS otherwise
//
//  History:    6/5/97 ChrisK   Inherited
//
//-----------------------------------------------------------------------------
DWORD
LoadNetcfg()
{
    if(g_hNetcfgInst == NULL)
    {
        g_hNetcfgInst = LoadLibraryToFunctionTable(NetcfgTable, 
                                                 "NETCFG.DLL");
    }

    if(g_hNetcfgInst == NULL)
    {
        return(!ERROR_SUCCESS);
    }
    else
    {
        return(ERROR_SUCCESS);
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   IcfgSetInstallSourcePath
//
//  Synopsis:   Set the path that will be used to install system components
//
//  Arguments:  lpszSourcePath - path to be used as install source (ANSI)
//
//  Returns:    HRESULT - S_OK is success
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgSetInstallSourcePath(LPSTR lpszSourcePath)
{
    Dprintf("ICFGNT: IcfgSetInstallSourcePath\n");
    if(g_wszInstallPath)
    {
        HeapFree(GetProcessHeap(), 0, (LPVOID) g_wszInstallPath);
    }

    DWORD dwLen = lstrlen(lpszSourcePath);
    g_wszInstallPath = (LPWSTR) HeapAlloc(GetProcessHeap(), 0, dwLen * 2 + 2);
    if(g_wszInstallPath == 0)
    {
        return(g_dwLastError = ERROR_OUTOFMEMORY);
    }

    mbstowcs(g_wszInstallPath, lpszSourcePath, dwLen + 1);
    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetLocationOfSetupFiles
//
//  Synopsis:   Get the location of the files used to install windows.
//
//  Arguments:  hwndParent - handle of parent window
//
//  Returns:    win32 error code
//
//  History:    ChrisK  6/30/97 Created
//-----------------------------------------------------------------------------
DWORD GetLocationOfSetupFiles(HWND hwndParent)
{
    DWORD   dwRC = ERROR_SUCCESS;
    HKEY    hkey = NULL;
    HINF    hInf = INVALID_HANDLE_VALUE;
    UINT    DiskId = 0;
    CHAR    TagFile[128];
    CHAR    lpBuffer[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    lpBuffer[0] = '\0';

    if( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
                                    REGISTRY_NT_CURRENTVERSION,
                                    &hkey))
    {

        hInf = SetupOpenMasterInf();
        if (hInf == INVALID_HANDLE_VALUE) 
        {
            dwRC = GetLastError();
            goto GetLocationOfSetupFilesExit;
        }

        if (!SetupGetSourceFileLocation(hInf,NULL,"RASCFG.DLL",&DiskId,NULL,0,NULL))
        {
            dwRC = GetLastError();
            goto GetLocationOfSetupFilesExit;
        }

        if (!SetupGetSourceInfo(hInf,DiskId,SRCINFO_TAGFILE,TagFile,MAX_PATH,NULL))
        {
            dwRC = GetLastError();
            goto GetLocationOfSetupFilesExit;
        }

        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;

        if( RegQueryValueEx( hkey,
                            "SourcePath",
                            NULL,
                            NULL,
                            (LPBYTE)lpBuffer,
                            &dwLen) == 0)
        {
            RegCloseKey( hkey );
            hkey = NULL;

            // Ask the user to provide the drive\path of the sources. We pass this information
            // down to NetSetupComponentInstall so that the user is not prompted several times
            // for the same information. If the path is correct (IDF_CHECKFIRST) then the user
            // is not prompted at all.

            if( (dwRC = SetupPromptForDisk(hwndParent,
                                                NULL,
                                                NULL,
                                                lpBuffer,
                                                "RASCFG.DLL",
                                                TagFile,  // tag file
                                                IDF_CHECKFIRST,
                                                lpBuffer,
                                                MAX_PATH,
                                                &dwLen
                                                )) != DPROMPT_SUCCESS )
            {
                Dprintf("ICFG: Install: SetupPromptForDisk failed.\n");
                dwRC = GetLastError();
                goto GetLocationOfSetupFilesExit;
            }
        }

        // If we failed to get SourcePath from registry, then prompt the user once and use
        // this information for subsequent installs.

        else
        {
            if( (dwRC = SetupPromptForDisk(hwndParent,
                                                NULL,
                                                NULL,
                                                NULL,
                                                "RASCFG.DLL",
                                                TagFile,  // tag file
                                                IDF_CHECKFIRST,
                                                lpBuffer,
                                                MAX_PATH,
                                                &dwLen
                                                )) != DPROMPT_SUCCESS )
            {
                Dprintf("ICFG: Install: SetupPromptForDisk failed.\n");
                dwRC = GetLastError();
                goto GetLocationOfSetupFilesExit;
            }
        }
    }
GetLocationOfSetupFilesExit:
    if (ERROR_SUCCESS == dwRC)
    {
        IcfgSetInstallSourcePath(lpBuffer);
    }
    
    if (INVALID_HANDLE_VALUE != hInf)
    {
        SetupCloseInfFile(hInf);
        hInf = NULL;
    }

    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return dwRC;
}

//+----------------------------------------------------------------------------
//
//  Function:   InstallNTNetworking
//
//  Synopsis:   Install NT Server, workstation, netbios, and RPC locator
//              services as needed
//
//  Arguemtns:  hwndParent - parent window
//
//  Returns:    win32 error code
//
//  History:    ChrisK  6/27/97 Created
//
//-----------------------------------------------------------------------------
DWORD InstallNTNetworking(HWND hwndParent)
{
    DWORD       dwRC = ERROR_SUCCESS;
    UINT        index = 0;
    DWORD       cchInfName = MAX_PATH;
    WCHAR       pszInfName[MAX_PATH+1];
    SC_HANDLE   hscman, hsvc;
    DWORD       dwReturn;

    Dprintf("ICFGNT.DLL: InstallNTNetworking.\n");

    Assert(NULL == hwndParent || IsWindow(hwndParent));

    if(ERROR_SUCCESS != (dwRC = LoadNetcfg()))
    {
        Dprintf("ICFGNT.DLL: Failed load Netcfg API's, error %d\n",dwRC);
        goto InstallNTNetworkingExit;
    }

    //
    // Check for and install services
    //
    for (index = 0; index < NSERVICES; index++)
    {
        Dprintf("ICFGNT.DLL: Check service %d\n",index);

        //
        // Install service if it is not installed
        //
        if(pfnNetSetupFindSoftwareComponent(
                g_netsetup[index].szOption,   // OPTION
                pszInfName,                 // INF Name
                &cchInfName,
                NULL,
                NULL) != ERROR_SUCCESS )
        {

            if (0 == g_wszInstallPath || 0 == lstrlenW(g_wszInstallPath))
            {
                GetLocationOfSetupFiles(hwndParent);
            }

            Dprintf("ICFGNT.DLL: Need service %d.\n",index);
            if((dwRC = pfnNetSetupComponentInstall(
                    hwndParent,
                    g_netsetup[index].szOption,   // OPTION
                    g_netsetup[index].szInfName,  // INF Name
                    g_wszInstallPath,             // Install path optional
                    NULL,                       // symbols, optional
                    2,                          // INFINSTALL_INPROCINTERP
                    &dwReturn)) != ERROR_SUCCESS )
             {
                Dprintf("ICFGNT.DLL: Installing service %d failed with error %d.\n",
                    index,
                    dwRC);
                 goto InstallNTNetworkingExit;
             }

             // Since this is downlevel, we can just use the MAKELCID macro
             //
             if (CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), 
                                              NORM_IGNORECASE, g_netsetup[index].szOption, -1, L"WKSTA", -1))
             {                
                // if we installed the Workstation service, then we should disable
                // Netlogon service. We need to do this because netlogon service should
                // not be set to autostart if the user has not joined a domain.
                // 

                hscman = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS | GENERIC_WRITE );
                if( hscman == NULL) 
                {
                    dwRC = GetLastError();
                    Dprintf("ICFGNT.DLL: Failed to open serviceManager, error %d\n",dwRC);
                    goto InstallNTNetworkingExit;
                }

                hsvc = OpenService( hscman, SERVICE_NETLOGON, SERVICE_CHANGE_CONFIG );
                if ( hsvc == NULL) 
                {
                    dwRC = GetLastError();
                    Dprintf("ICFGNT.DLL: Failed to open service, error %d\n",dwRC);
                    goto InstallNTNetworkingExit;
                }
                ChangeServiceConfig( hsvc, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                CloseServiceHandle(hsvc);
                CloseServiceHandle(hscman);
            }
        }
    }
InstallNTNetworkingExit:

    return dwRC;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRegValue
//
//  Synopsis:   Dynamically allocate memory and read value from registry
//
//  Arguments:  hKey - handle to key to be read
//              lpValueName - pointer to value name to be read
//              lpData - pointer to pointer to data
//
//  Returns:    Win32 error, ERROR_SUCCESS is it worked
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
inline LONG GetRegValue(HKEY hKey, LPSTR lpValueName, LPBYTE *lpData)
{
    LONG dwError;
    DWORD cbData;

    Dprintf("ICFGNT: GetRegValue\n");
    dwError = RegQueryValueExA(hKey,
                               lpValueName,
                               NULL,
                               NULL,
                               NULL,
                               &cbData);
    if(dwError != ERROR_SUCCESS)
    {
        return(dwError);
    }

    //
    // Allocate space and buffer incase we need to add more info later
    // see turn off the printing binding
    //
    *lpData = (LPBYTE) GlobalAlloc(GPTR,cbData + REG_DATA_EXTRA_SPACE);
    if(*lpData == 0)
    {
        return(ERROR_OUTOFMEMORY);
    }

    dwError = RegQueryValueExA(hKey,
                               lpValueName,
                               NULL,
                               NULL,
                               *lpData,
                               &cbData);
    if(dwError != ERROR_SUCCESS)
    {
        GlobalFree(*lpData);
    }

    return(dwError);
}

//+----------------------------------------------------------------------------
//
//  Function:   ParseNetSetupReturn
//
//  Synopsis:   Interprit return values from NetSetup* functions
//
//  Arguments:  dwReturn - return value from NetSetup* function
//
//  Returns:    fReboot - TRUE means reboot required
//              fBindReview - TRUE means binding review is required
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
inline void
ParseNetSetupReturn(DWORD dwReturn, BOOL &fReboot, BOOL &fBindReview)
{
    Dprintf("ICFGNT: ParseNetSetupReturn\n");
    if(dwReturn == 0 || dwReturn == 4)
    {
        fBindReview = TRUE;
    }
    if(dwReturn == 0 || dwReturn == 5)
    {
        fReboot = TRUE;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   ReviewBindings
//
//  Synopsis:   Force WinNT to review network bindings
//
//  Arguments:  hwndParent - handle to parent window
//
//  Returns:    win32 error code (ERROR_SUCCESS means it worked)
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
DWORD
ReviewBindings(HWND hwndParent)
{
    DWORD dwErr;

    Dprintf("ICFGNT: ReviewBindings\n");
    dwErr = LoadNetcfg();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    return(pfnNetSetupReviewBindings(hwndParent, 0));
}


//+----------------------------------------------------------------------------
//
//  Function:   CallModemInstallWizard
//
//  Synopsis:   Invoke modem install wizard via SetupDi interfaces
//
//  Arguments:  hwnd - handle to parent window
//
//  Returns:    TRUE - success, FALSE - failed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
//
// The following code was stolen from RAS
//

BOOL
CallModemInstallWizard(HWND hwnd)
   /* call the Modem.Cpl install wizard to enable the user to install one or more modems
   **
   ** Return TRUE if the wizard was successfully invoked, FALSE otherwise
   **
   */
{
   HDEVINFO hdi;
   BOOL     fReturn = FALSE;
   // Create a modem DeviceInfoSet

   Dprintf("ICFGNT: CallModemInstallWizard\n");
   hdi = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_MODEM, hwnd);
   if (hdi)
   {
      SP_INSTALLWIZARD_DATA iwd;

      // Initialize the InstallWizardData

      ZeroMemory(&iwd, sizeof(iwd));
      iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
      iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
      iwd.hwndWizardDlg = hwnd;

      // Set the InstallWizardData as the ClassInstallParams

      if (SetupDiSetClassInstallParams(hdi, NULL, (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
      {
         // Call the class installer to invoke the installation
         // wizard.
         if (SetupDiCallClassInstaller(DIF_INSTALLWIZARD, hdi, NULL))
         {
            // Success.  The wizard was invoked and finished.
            // Now cleanup.
            fReturn = TRUE;

            SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA, hdi, NULL);
         }
      }

      // Clean up
      SetupDiDestroyDeviceInfoList(hdi);
   }
   return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Function:   IsDialableISDNAdapters
//
//  Synopsis:   Some ISDN adapters can be installed as RAS devices, but not as
//              unimodem devices, so we have to walk through the rest of the
//              TAPI devices looking for these.
//
//  Arguments:  None
//
//  Returns:    TRUE - there is a device available
//
//  History:    7/22/97 ChrisK  Created
//
//-----------------------------------------------------------------------------
#define REG_TAPIDEVICES "software\\microsoft\\ras\\tapi devices"
LPSTR szAddress = "Address";
LPSTR szUsage = "Usage";
LPSTR szMediaType = "Media Type";
BOOL IsDialableISDNAdapters()
{
    BOOL bRC = FALSE;

    HKEY    hkey = NULL, hsubkey = NULL;
    DWORD   dwIdx = 0;
    CHAR    szBuffer[MAX_PATH + 1];
    CHAR    szSubKey[MAX_PATH + 1];
    LPBYTE  lpData = NULL;
    LPSTR   lpsUsage = NULL;
    szBuffer[0] = '\0';

    //
    // Open TAPI device key
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                    REG_TAPIDEVICES,
                                    &hkey))
    {
        Dprintf("ICFGNT Can not open TAPI key.\n");
        goto IsDialableISDNAdaptersExit;
    }

    //
    // Scan for non unimodem device
    //
    
    while (FALSE == bRC)
    {
        szBuffer[0] = '\0';
        if (ERROR_SUCCESS != RegEnumKey(hkey,dwIdx,szBuffer,MAX_PATH))
        {
            goto IsDialableISDNAdaptersExit;
        }
        Dprintf("ICFGNT sub key (%s) found.\n",szBuffer);

        if (CSTR_EQUAL != CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), 
                                        NORM_IGNORECASE, szBuffer, -1, "unimodem", -1))
        {
            //
            // Open other TAPI device reg key
            //
            szSubKey[0] = '\0';
            wsprintf(szSubKey,"%s\\%s",REG_TAPIDEVICES,szBuffer);
            Dprintf("ICFGNT opening (%s).\n",szSubKey);
            if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                            szSubKey,
                                            &hsubkey))
            {
                Dprintf("ICFGNT Can not open TAPI SUB key.\n");
                goto IsDialableISDNAdaptersExit;
            }

            if (ERROR_SUCCESS != GetRegValue(hsubkey,szUsage,&lpData))
            {
                Dprintf("ICFGNT Can not get TAPI SUB key.\n");
                goto IsDialableISDNAdaptersExit;
            }

            //
            // Scan for "client"
            //
            lpsUsage = (LPSTR)lpData;
            while (*lpsUsage != '\0')
            {
                if(NULL != strstr(lpsUsage, "Client"))
                {
                    Dprintf("ICFGNT client found for device.\n");
                    //
                    // We found a client device, now check that it is ISDN
                    //
                    GlobalFree(lpData);
                    lpData = NULL;
                    if (ERROR_SUCCESS != GetRegValue(hsubkey,szMediaType,&lpData))
                    {
                        Dprintf("ICFGNT Can not get TAPI SUB value key.\n");
                        goto IsDialableISDNAdaptersExit;
                    }
                    
                    if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), 
                                                    NORM_IGNORECASE, (LPSTR)lpData, -1, "ISDN", -1))
                    {
                        Dprintf("ICFGNT ISDN media type found.\n");
                        //
                        // This is a valid dial-out ISDN device!!!  Wahoo!!
                        //
                        bRC = TRUE;
                    }
                    else
                    {
                        Dprintf("ICFGNT ISDN media type NOT found.\n");
                    }
                }
                else
                {
                    lpsUsage += lstrlen(lpsUsage)+1;
                }
            }

            if (lpData)
            {
                GlobalFree(lpData);
                lpData = NULL;
                lpsUsage = NULL;
            }
        }

        //
        // Move to the next REG key
        //
        dwIdx++;
    }

IsDialableISDNAdaptersExit:
    if (hkey)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }
    if (hsubkey)
    {
        RegCloseKey(hsubkey);
        hsubkey = NULL;
    }
    if (lpData)
    {
        GlobalFree(lpData);
        lpData = NULL;
        lpsUsage = NULL;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedModem
//
//  Synopsis:   Check system configuration to determine if there is at least
//              one physical modem installed
//
//  Arguments:  dwfOptions - currently not used
//
//  Returns:    HRESULT - S_OK if successfull
//              lpfNeedModem - TRUE if no modems are available
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
LPSTR szRasUnimodemSubKey =
        "Software\\Microsoft\\ras\\TAPI DEVICES\\Unimodem";

HRESULT WINAPI
IcfgNeedModemNT4 (DWORD dwfOptions, LPBOOL lpfNeedModem) 
{
    //
    // Ras is insatlled, and ICW wants to know if it needs to
    // install a modem.
    //
    *lpfNeedModem = TRUE;

    //
    //  ChrisK 7/22/97
    //  Added return code in order to provide centralized place to check
    //  for ISDN installations
    //
    HRESULT hRC = ERROR_SUCCESS;

    //
    // Check what modems are available to RAS
    //

    HKEY    hUnimodem;
    LONG    dwError;

    Dprintf("ICFGNT: IcfgNeedModem\n");

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szRasUnimodemSubKey,
                           0,
                           KEY_READ,
                           &hUnimodem);

    if(dwError != ERROR_SUCCESS)
    {
        goto IcfgNeedModemExit;
    }
    else
    {
        LPBYTE   lpData;

        dwError = GetRegValue(hUnimodem, szUsage, &lpData);
        if(dwError != ERROR_SUCCESS)
            goto IcfgNeedModemExit;

        LPBYTE  lpData2;
        dwError = GetRegValue(hUnimodem, szAddress, &lpData2);
        if(dwError != ERROR_SUCCESS)
        {
            hRC = dwError;
            goto IcfgNeedModemExit;
        }
        else
        {
            //
            // Try finding a Client or ClientAndServer Modem
            // Also, make sure all modems have corresponding TAPI devices
            //

            LPSTR   pUsage = (LPSTR) lpData;
            LPSTR   pAddress = (LPSTR) lpData2;
            char    portsbuf[1000];

            dwError = EnumerateTapiModemPorts(sizeof(portsbuf), portsbuf);
            if(dwError)
            {
                hRC = dwError;
                goto IcfgNeedModemExit;
            }

            while(*pUsage != '\0') {
                if(lstrcmp(pUsage, "Client") == 0 ||
                    lstrcmp(pUsage, "ClientAndServer") == 0 ||
                    lstrcmp(pUsage, "ClientAndServerAndRouter") == 0) 

                {
                        *lpfNeedModem = FALSE;
                }

                //
                // Make sure a corresponding TAPI port exists
                //

                LPSTR pPorts = portsbuf;
                while(*pPorts != '\0')
                    if(stricmp(pAddress, pPorts) == 0)
                    {
                        break;
                    }
                    else
                    {
                        pPorts += lstrlen(pPorts) + 1;
                    }

                if(*pPorts == '\0')
                {
                    hRC = ERROR_INTERNAL_ERROR;
                    goto IcfgNeedModemExit;
                }

                pUsage += lstrlen(pUsage) + 1;
                pAddress += lstrlen(pAddress) + 1;
            }
        }
    }

IcfgNeedModemExit:
    //
    // If there was some problem finding a typical dial out device,
    // then try again and check for dialing ISDN devices.
    //
    if (ERROR_SUCCESS != hRC ||
        FALSE != *lpfNeedModem)
    {
        if (IsDialableISDNAdapters())
        {
            hRC = ERROR_SUCCESS;
            *lpfNeedModem = FALSE;
        }
    }

    return(hRC);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallModem
//
//  Synopsis:
//              This function is called when ICW verified that RAS is installed,
//              but no modems are avilable. It needs to make sure a modem is availble.
//              There are two possible scenarios:
//
//              a.  There are no modems installed.  This happens when someone deleted
//                  a modem after installing RAS. In this case we need to run the modem
//                  install wizard, and configure the newly installed modem to be a RAS
//                  dialout device.
//
//              b.  There are modems installed, but non of them is configured as a dial out
//                  device.  In this case, we silently convert them to be DialInOut devices,
//                  so ICW can use them.
//
//  Arguments:  hwndParent - handle to parent window
//              dwfOptions - not used
//
//  Returns:    lpfNeedsStart - not used
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallModemNT4 (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart) 
{
    //
    // Check what modems are available to RAS
    //

    HKEY    hUnimodem;
    LONG    dwError;
    BOOL    fInstallModem = FALSE;

    Dprintf("ICFGNT: IcfgInstallModem\n");

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szRasUnimodemSubKey,
                           0,
                           KEY_READ,
                           &hUnimodem);

    if(dwError != ERROR_SUCCESS)
    {
        fInstallModem = TRUE;
    }
    else 
    {
            LPBYTE   lpData;

            dwError = GetRegValue(hUnimodem, szUsage, &lpData);
            if(dwError != ERROR_SUCCESS)
            {
                fInstallModem = TRUE;
            }
            else 
            {
                // Make sure at least one modem exists
                if(*lpData == '\0')
                {
                    fInstallModem = TRUE;
                }
            }
    }

    if(fInstallModem) 
    {
        //
        // Fire up the modem install wizard
        //

        if(!CallModemInstallWizard(hwndParent))
        {
            return(g_dwLastError = GetLastError());
        }

        //
        // Now configure the new modem to be a dial out device.
        //

        //
        // Install ras again with unattneded file!
        //

        return(ERROR_SUCCESS);

    }
    else 
    {
        //
        // We need to reconfigure dial in devices to be dialinout
        //

        //
        // install ras again with unattended file!
        //
        return(ERROR_SUCCESS);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedInetComponets
//
//  Synopsis:   Check to see if the components marked in the options are
//              installed on the system
//
//  Arguements: dwfOptions - set of bit flag indicating which components to
//              check for
//
//  Returns;    HRESULT - S_OK if successfull
//              lpfNeedComponents - TRUE is some components are not installed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedInetComponentsNT4(DWORD dwfOptions, LPBOOL lpfNeedComponents) {
    DWORD dwErr;

    //
    // Assume need nothing
    //
    *lpfNeedComponents = FALSE;

    Dprintf("ICFGNT: IcfgNeedInetComponents\n");
    dwErr = LoadNetcfg();
    if(dwErr != ERROR_SUCCESS)
    {
        return(g_dwLastError = dwErr);          // Shouldn't we map to hResult?
    }

    WCHAR wszInfNameBuf[512];
    DWORD cchInfName = sizeof(wszInfNameBuf) / sizeof(WCHAR);

    if(dwfOptions & ICFG_INSTALLTCP) 
    {
        dwErr = pfnNetSetupFindSoftwareComponent(L"TC",
                                          wszInfNameBuf,
                                          &cchInfName,
                                          0,
                                          0);
        if(dwErr != ERROR_SUCCESS)
            *lpfNeedComponents = TRUE;
    }

    if(dwfOptions & ICFG_INSTALLRAS) 
    {
       dwErr = pfnNetSetupFindSoftwareComponent(L"RAS",
                                          wszInfNameBuf,
                                          &cchInfName,
                                          0,
                                          0);
       if(dwErr != ERROR_SUCCESS)
            *lpfNeedComponents = TRUE;
    }

    if(dwfOptions & ICFG_INSTALLMAIL) 
    {
        // How do we do this?
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   GenerateRasUnattendedFile
//
//  Synopsis:   Create the file that will provide RAS setup the necessary
//              setting to install in an unattended mode
//
//  Arguments:  wszTmpFile - name of file to create
//              szPortsBuf
//
//  Returns:    FALSE - failure, TRUE - success
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
BOOL
GenerateRasUnattendedFile(LPWSTR wszTmpFile, LPSTR szPortsBuf)
{
    WCHAR wszTmpPath[MAX_PATH+1];
    WCHAR wszTmpShortPath[MAX_PATH+1];

    //
    // Create temporary file name and convert to non-wide form
    //

    Dprintf("ICFGNT: GenerateRasUnattendedFile\n");

    if (GetTempPathW(MAX_PATH, wszTmpPath) == 0)
    {
        return(FALSE);
    }

    //
    // always attempt to create the temp dir as the temp dir may not exist if 
    // the user logs in with a roaming profile
    //
    CreateDirectoryW(wszTmpPath, NULL);

    //
    // need to convert this to a short path since pfnNetSetupComponentInstall()
    // doesn't like to have a long path in the InfSymbols param.
    //
    if (!GetShortPathNameW(wszTmpPath, wszTmpShortPath, MAX_PATH))
    {
        return FALSE;
    }

    if (GetTempFileNameW(wszTmpPath, L"icw", 0, wszTmpFile) == 0)
    {
        return(FALSE);
    }

    //
    // need to convert the temp filename to shortpath too!
    //
    if (!GetShortPathNameW(wszTmpFile, wszTmpShortPath, MAX_PATH))
    {
        return FALSE;
    }
    wcscpy(wszTmpFile, wszTmpShortPath); 

    char szTmpFile[MAX_PATH+1];
    wcstombs(szTmpFile, wszTmpFile, wcslen(wszTmpFile) + 1);

#if 0
/*
    FILE *fp = fopen(szTmpFile, "w");

    if(fp == 0)
    {
        return(FALSE);
    }

    fprintf(fp, "[RemoteAccessParameters]\n");
    fprintf(fp, "PortSections    = ");

    LPSTR szPorts = szPortsBuf;

    while(*szPorts) {
        if(szPorts != szPortsBuf)
        {
            fprintf(fp, ",");
        }
        fprintf(fp, "%s", szPorts);
        szPorts += lstrlen(szPorts) + 1;
    }

    fprintf(fp, "\n");
    fprintf(fp, "DialoutProtocols    = TCP/IP\n");
    fprintf(fp, "\n");
    fprintf(fp, "[Modem]\n");
    fprintf(fp, "InstallModem=ModemSection\n");
    fprintf(fp, "\n");

    szPorts = szPortsBuf;

    while(*szPorts) {
        fprintf(fp, "[%s]\n", szPorts);
        fprintf(fp, "PortName        = %s\n", szPorts);
        fprintf(fp, "DeviceType      = Modem\n");
        fprintf(fp, "PortUsage       = DialOut\n");
        fprintf(fp, "\n");
        szPorts += lstrlen(szPorts) + 1;
    }

    fprintf(fp, "[ModemSection]\n");

    fclose(fp);
*/

#else

    //
    // Open the file for writing, bail on fail.
    //

    BOOL bRet = FALSE;

    HANDLE hFile = CreateFile(szTmpFile,GENERIC_WRITE,0,NULL,OPEN_EXISTING, 
                       FILE_ATTRIBUTE_NORMAL,NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        return FALSE;
    }

    LPSTR szPorts = szPortsBuf;
    char szFileBuf[MAX_PATH]={0};
    DWORD dwWrite;
    
    lstrcpy(szFileBuf, "[RemoteAccessParameters]\nPortSections    = ");

    if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
    {
        goto closefile;
    }

    while (*szPorts) 
    {
        //
        // Delimit each item with a comma
        //

        if (szPorts != szPortsBuf)
        {
            lstrcpy(szFileBuf, ",");
            if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
            {
                goto closefile;
            }
        }

        //
        // Write each port 
        //
        lstrcpyn(szFileBuf, szPorts, CELEMS(szFileBuf));

        if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
        {
            goto closefile;
        }
                     
        szPorts += lstrlen(szPorts) + 1;
    }
 
    //
    // Write DialoutProtocol TCP/IP and InstallModem
    //

    lstrcpy(szFileBuf, "\nDialoutProtocols    = TCP/IP\n\n[Modem]\nInstallModem=ModemSection\n\n");

    if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
    {
        goto closefile;
    }

    //
    // Enumerate ports again
    //

    szPorts = szPortsBuf;

    while (*szPorts) 
    {
        //
        // Write PortName section and entry
        //

        wsprintf(szFileBuf, "[%s]\n", szPorts);

        if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
        {
            goto closefile;
        }

        wsprintf(szFileBuf, "PortName        = %s\n", szPorts);

        if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
        {
            goto closefile;
        }

        //
        // Write DeviceType and PortUsage entry for each port
        //
        
        lstrcpy(szFileBuf, "DeviceType      = Modem\nPortUsage       = DialOut\n\n");

        if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
        {
            goto closefile;
        }

        szPorts += lstrlen(szPorts) + 1;
    }

    lstrcpy(szFileBuf, "[ModemSection]\n");

    if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
    {
        goto closefile;
    }

    bRet = TRUE;

closefile:

    CloseHandle(hFile);

#endif

    return(bRet);
}

//+----------------------------------------------------------------------------
//
//  Function:   InstallRAS
//
//  Synopsis:   Invoke unattended RAS installation
//
//  Arguments:  hwndParent - handle to parent window
//              szFile - name of unattended settings file
//              szSection -
//
//  Returns:    DWORD - win32 error
//              pdwReturn - return code from last parameter of
//                  pfnNetSetupComponentInstall
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
DWORD
InstallRAS(HWND hwndParent, LPWSTR szFile, LPWSTR szSection, LPDWORD pdwReturn) 
{
    WCHAR InfSymbols[1024];
    LPWSTR szInfSymbols = InfSymbols;

    Dprintf("ICFGNT: InstallRAS\n");

    DWORD dwRC = InstallNTNetworking(hwndParent);
    if (ERROR_SUCCESS != dwRC)
    {
        return dwRC;
    }

    LPWSTR szString1 = L"!STF_GUI_UNATTENDED";
    wcscpy(szInfSymbols, szString1);
    szInfSymbols += wcslen(szString1) + 1;

    LPWSTR szString2 = L"YES";
    wcscpy(szInfSymbols, szString2);
    szInfSymbols += wcslen(szString2) + 1;

    LPWSTR szString3 = L"!STF_UNATTENDED";
    wcscpy(szInfSymbols, szString3);
    szInfSymbols += wcslen(szString3) + 1;

    //
    // Unattneded file.
    //

    wcscpy(szInfSymbols, szFile);
    szInfSymbols += wcslen(szFile) + 1;

    LPWSTR szString4 = L"!STF_UNATTENDED_SECTION";
    wcscpy(szInfSymbols, szString4);
    szInfSymbols += wcslen(szString4) + 1;

    //
    // Unattnded section
    //

    wcscpy(szInfSymbols, szSection);
    szInfSymbols += wcslen(szSection) + 1;

    *szInfSymbols++ = 0;
    *szInfSymbols++ = 0;

    return(pfnNetSetupComponentInstall(hwndParent,
                                       L"RAS",
                                       L"OEMNSVRA.INF",
                                       g_wszInstallPath,
                                       InfSymbols,
                                       INFINSTALL_INPROCINTERP,     // Install Flags
                                       pdwReturn));
}


//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallInetComponents
//
//  Synopsis:   Install the components as specified by the dwfOptions values
//
//  Arguments   hwndParent - handle to parent window
//              dwfOptions - set of bit flags indicating which components to
//                  install
//
//  Returns:    HRESULT - S_OK if success
//              lpfNeedsReboot - TRUE if reboot is required
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallInetComponentsNT4(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart)
{
    DWORD dwErr;
    DWORD dwReturn;
    BOOL fNeedsReview;
    BOOL fNeedsRestart;
    BOOL fDoReview = FALSE;
    WCHAR wszInfNameBuf[512];
    DWORD cchInfName = sizeof(wszInfNameBuf) / sizeof(WCHAR);

    Dprintf("ICFGNT: IcfgInstallInetComponents\n");
    //
    // Assume don't need restart
    //
    *lpfNeedsRestart = FALSE;

    dwErr = LoadNetcfg();
    if(dwErr != ERROR_SUCCESS)
    {
        return(g_dwLastError = dwErr);          // Review: Shouldn't we map to hResult?
    }

    if(dwfOptions & ICFG_INSTALLTCP) 
    {
        dwErr = pfnNetSetupFindSoftwareComponent(L"TC",
                                          wszInfNameBuf,
                                          &cchInfName,
                                          0,
                                          0);
        if(dwErr != ERROR_SUCCESS) 
        {
            dwErr = pfnNetSetupComponentInstall(hwndParent,
                                            L"TC",
                                            L"OEMNXPTC.INF",
                                            g_wszInstallPath,
                                            L"\0\0",
                                            INFINSTALL_INPROCINTERP,     // Install Flags
                                            &dwReturn);
            if(dwErr != ERROR_SUCCESS)
            {
                return(g_dwLastError = dwErr);      // Review: Shouldn't we map to hResult?
            }

            ParseNetSetupReturn(dwReturn, fNeedsRestart, fNeedsReview);
            if(fNeedsRestart)
            {
                *lpfNeedsRestart = TRUE;
            }
            if(fNeedsReview)
            {
                fDoReview = TRUE;
            }
        }
    }

    if(dwfOptions & ICFG_INSTALLRAS) 
    {
        dwErr = pfnNetSetupFindSoftwareComponent(L"RAS",
                                          wszInfNameBuf,
                                          &cchInfName,
                                          0,
                                          0);
       if(dwErr != ERROR_SUCCESS) 
       {
            //
            // Before we install RAS, we have to make have to make sure a modem
            // is installed, because RAS will try to run the modem detection wizard
            // in unattneded mode if there are no modems, and we don't want that.
            //
            // The way we do that is we enumerate devices through TAPI, and if there are
            // no modems installed, we call the modem install wizard.  Only after
            // we make sure a modem was installed, we call ras install.
            //

            DWORD   DoTapiModemsExist(LPBOOL pfTapiModemsExist);
            char    portsbuf[1000];

            dwErr = EnumerateTapiModemPorts(sizeof(portsbuf), portsbuf);
            if(dwErr)
                return(g_dwLastError = dwErr);

            if(*portsbuf == 0) 
            {
                if(!CallModemInstallWizard(hwndParent))
                {
                    //
                    // if CallModemInstallWizard returned FALSE and 
                    // GetLastError() is ERROR_SUCCESS, it is actually
                    // a user cancelled case
                    //
                    if (ERROR_SUCCESS == (g_dwLastError = GetLastError()))
                        g_dwLastError = ERROR_CANCELLED;
                    return(g_dwLastError);
                }

                //
                // In this invocation of EnumerateTapiModemPorts
                // we have to wait for a 1 second before we start
                // enumerating the modems - hence set the last parameter
                // to TRUE  -- VetriV
                //
                dwErr = EnumerateTapiModemPorts(sizeof(portsbuf), portsbuf, 
                                                    TRUE);
                if(dwErr)
                {
                    return(g_dwLastError = dwErr);
                }

                if(*portsbuf == 0)
                {
                    return(g_dwLastError = ERROR_CANCELLED);
                }
            }

            WCHAR wszUnattFile[MAX_PATH];

            if(!GenerateRasUnattendedFile(wszUnattFile, portsbuf))
            {
                return(g_dwLastError = GetLastError());
            }

            dwErr = InstallRAS(hwndParent,
                           wszUnattFile,
                           L"RemoteAccessParameters",
                           &dwReturn);
            DeleteFileW(wszUnattFile);

            if(dwErr != ERROR_SUCCESS)
            {
                return(g_dwLastError = dwErr);      // Review: Shouldn't we map to hResult?
            }

            ParseNetSetupReturn(dwReturn, fNeedsRestart, fNeedsReview);
            if(fNeedsRestart)
            {
                *lpfNeedsRestart = TRUE;
            }
            if(fNeedsReview)
            {
                fDoReview = TRUE;
            }
       }
    }

    if(fDoReview)
    {
        return(g_dwLastError = ReviewBindings(hwndParent));  // Review: Shouldn't we map to hresult?
    }
    else
    {
        return(ERROR_SUCCESS);
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   IcfgIsFileSharingTurnedOn
//
//  Synopsis:   Check network bindings to determine if "Server" service is
//              bound to ndiswan adapter
//
//  Arguments:  dwfDriverType -
//
//  Returns:    HRESULT - S_OK is success
//              lpfSharingOn - TRUE if sharing is bound
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
LPSTR szLanManServerSubKey = "SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Linkage";
LPSTR szBind = "Bind";
LPSTR szExport = "Export";
LPSTR szRoute = "Route";
LPSTR szLanManServerDisabledSubKey = "SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Linkage\\Disabled";
LPSTR szNdisWan4 = "NdisWan";
struct BINDDATA
{
    CHAR *startb;
    CHAR *currb;
    CHAR *starte;
    CHAR *curre;
    CHAR *startr;
    CHAR *currr;
} net_bindings;

HRESULT WINAPI
IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn)
{
    HRESULT hr = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE lpData = NULL;
    CHAR *p;

    Dprintf("ICFGNT: IcfgIsFileSharingTurnedOn\n");
    Assert(lpfSharingOn);
    if (NULL == lpfSharingOn)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto IcfgIsFileSharingTurnedOnExit;
    }

    *lpfSharingOn = FALSE;

    //
    // Open lanmanServer registry key
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                szLanManServerSubKey,
                                &hKey))
    {
        Dprintf("ICFGNT: Failed to open lanmanServer key\n");
        goto IcfgIsFileSharingTurnedOnExit;
    }

    if (ERROR_SUCCESS != GetRegValue(hKey, szBind, &lpData))
    {
        Dprintf("ICFGNT: Failed to read binding information\n");
        goto IcfgIsFileSharingTurnedOnExit;
    }
    Assert(lpData);
    
    //
    // Look for a particular string in the data returned
    // Note: data is terminiated with two NULLs
    //
    p = (CHAR *)lpData;
    while (*p)
    {
        if (strstr( p, szNdisWan4)) 
        {
            Dprintf("ICFGNT: NdisWan4 binding found in %s\n",p);
            *lpfSharingOn = TRUE;
            break;
        }
        p += (lstrlen( p ) + 1);
    }

    
IcfgIsFileSharingTurnedOnExit:
    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    if (lpData)
    {
        GlobalFree(lpData);
        lpData = NULL;
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   MoveNextBinding
//
//  Synopsis:   Move to the next string in a MULTISZ data buffer
//
//  Arguments:  lpcBinding - pointer to address of current buffer position
//
//  Returns:    lpcBinding - pointer to next string
//
//  History:    6/5/97 ChrisK Created
//
//-----------------------------------------------------------------------------
inline void MoveNextBinding(CHAR **lplpcBinding)
{
    Dprintf("ICFGNT: MoveNextBinding\n");
    Assert(lplpcBinding && *lplpcBinding);
    if (lplpcBinding && *lplpcBinding)
    {
        *lplpcBinding += (lstrlen(*lplpcBinding)+1);
    }
    else
    {
        Dprintf("ICFGNT: MoveNextBinding received invalid parameter\n");
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CompactLinkage
//
//  Synopsis:   Compact a list of Multi_SZ data
//
//  Arguments:  lpBinding - point to the string of an Multi_Sz list that should
//              be over written
//
//  Returns:    none
//
//  History:    6/5/97  ChrisK Created
//
//-----------------------------------------------------------------------------
inline void CompactLinkage(CHAR *lpBinding)
{
    Dprintf("ICFGNT: CompactLinkage\n");
    Assert(lpBinding && *lpBinding);
    CHAR *lpLast = lpBinding;
    BOOL fNULLChar = FALSE;

    MoveNextBinding(&lpBinding);

    //
    // ChrisK Olympus 6311 6/11/97
    // Do not compact on a per string basis.  This causes the data to become
    // corrupted if the string being removed is shorter than the string being
    // added.  Instead compact on a per character basis, since those are always
    // the same size (on a given machine).
    //
    while (!fNULLChar || *lpBinding)
    {
        if (NULL == *lpBinding)
        {
            fNULLChar = TRUE;
        }
        else
        {
            fNULLChar = FALSE;
        }
        *lpLast++ = *lpBinding++;
    }

    //while (*lpBinding)
    //{
    //  lstrcpy(lpLast,lpBinding);
    //  lpLast = lpBinding;
    //  MoveNextBinding(&lpBinding);
    //}

    //
    // Add second terminating NULL
    //
    *lpLast = '\0';
}

//+----------------------------------------------------------------------------
//
//  Function:   SizeOfMultiSz
//
//  Synopsis:   determine the total size of a Multi_sz list, including
//              terminating NULLs
//
//  Arguments:  s - pointer to list
//
//  Returns:    DWORD - size of s
//
//  History:    6/5/97  ChrisK  created
//
//-----------------------------------------------------------------------------
DWORD SizeOfMultiSz(CHAR *s)
{
    Dprintf("ICFGNT: SizeOfMultiSz\n");
    Assert(s);
    DWORD dwLen = 0;
    //
    // total size of all strings
    //

    //
    // ChrisK Olympus 6311 6/11/97
    // Add special case for empty MultiSZ strings
    //

    //
    // Special case for empty MultiSz.
    // Note: even "empty" MultiSZ strings still have the two null terminating characters
    //
    if (!(*s))
    {
        //
        // Make sure we actually have two terminating NULLs in this case.
        //
        Assert(s[1] == '\0');
        //
        // Count terminating NULL.
        //
        dwLen = 1;
    }

    while (*s)
    {
        dwLen += lstrlen(s) + 1;
        s += lstrlen(s) + 1;
    }
    //
    // plus one for the extra terminating NULL
    //
    dwLen++;
    Dprintf("ICFGNT: SizeOfMultiSz returns %d\n", dwLen);

    return dwLen;
}

//+----------------------------------------------------------------------------
//
//  Function:   WriteBindings
//
//  Synopsis:   Write the data from a BINDDATA structure to the key given
//
//  Arguments:  bd - BINDDATA structure with data to be written
//              hKey - handle of registry key to get data
//
//  Returns:    win32 error code
//
//  History:    6/5/97  ChrisK  created
//
//-----------------------------------------------------------------------------
DWORD WriteBindings(BINDDATA bd, HKEY hKey)
{
    DWORD dwRC = ERROR_SUCCESS;
    DWORD dwSize;

    Assert (hKey &&
        bd.startb &&
        bd.starte &&
        bd.startr);

    Dprintf("ICFGNT: WriteBindings\n");

    //
    // Bind
    //
    dwSize = SizeOfMultiSz(bd.startb);
    if (ERROR_SUCCESS != (dwRC = RegSetValueEx(hKey,
                                    szBind,
                                    NULL,
                                    REG_MULTI_SZ,
                                    (LPBYTE)bd.startb,
                                    dwSize)))
    {
        Dprintf("ICFGNT: Failed to write Bind key\n");
        goto WriteBindingsExit;
    }
    
    //
    // Export
    //
    dwSize = SizeOfMultiSz(bd.starte);
    if (ERROR_SUCCESS != (dwRC = RegSetValueEx(hKey,
                                    szExport,
                                    NULL,
                                    REG_MULTI_SZ,
                                    (LPBYTE)bd.starte,
                                    dwSize)))
    {
        Dprintf("ICFGNT: Failed to write export key\n");
        goto WriteBindingsExit;
    }

    //
    // Route
    //
    dwSize = SizeOfMultiSz(bd.startr);
    if (ERROR_SUCCESS != (dwRC = RegSetValueEx(hKey,
                                    szRoute,
                                    NULL,
                                    REG_MULTI_SZ,
                                    (LPBYTE)bd.startr,
                                    dwSize)))
    {
        Dprintf("ICFGNT: Failed to write route key\n");
        goto WriteBindingsExit;
    }

WriteBindingsExit:
    return dwRC;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgTurnOffFileSharing
//
//  Synopsis;   Disable the binding between the "server" net service and the
//              ndiswan4 device
//
//  Arguments:  dwfDriverType - 
//              hwndParent - parent window
//
//  Returns:    HRESULT - S_OK if success
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent)
{
    BINDDATA LinkData = {NULL, NULL, NULL, NULL, NULL, NULL};
    BINDDATA DisData = {NULL, NULL, NULL, NULL, NULL, NULL};
    HKEY hKeyLink = NULL;
    HKEY hKeyDis = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BOOL bUpdateReg = FALSE;

    Dprintf("ICFGNT: IcfgTurnOffFileSharing\n");
    Assert(hwndParent);
    if (NULL == hwndParent)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto IcfgTurnOffFileSharingExit;
    }

    //
    // Open Keys and read binding data
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                            szLanManServerSubKey,
                            &hKeyLink))
    {
        Dprintf("ICFGNT: failed to open linkdata key\n");
        goto IcfgTurnOffFileSharingExit;
    }

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                            szLanManServerDisabledSubKey,
                            &hKeyDis))
    {
        Dprintf("ICFGNT: failed to open linkdata key\n");
        goto IcfgTurnOffFileSharingExit;
    }

    GetRegValue(hKeyLink,szBind,(LPBYTE*)&LinkData.startb);
    GetRegValue(hKeyLink,szExport,(LPBYTE*)&LinkData.starte);
    GetRegValue(hKeyLink,szRoute,(LPBYTE*)&LinkData.startr);
    GetRegValue(hKeyDis,szBind,(LPBYTE*)&DisData.startb);
    GetRegValue(hKeyDis,szExport,(LPBYTE*)&DisData.starte);
    GetRegValue(hKeyDis,szRoute,(LPBYTE*)&DisData.startr);

    //
    // Initialize all current pointers
    //
    LinkData.currb = LinkData.startb;
    LinkData.curre = LinkData.starte;
    LinkData.currr = LinkData.startr;

    DisData.currb = DisData.startb;
    while (*DisData.currb)
    {
        MoveNextBinding(&DisData.currb);
    }

    DisData.curre = DisData.starte;
    while (*DisData.curre)
    {
        MoveNextBinding(&DisData.curre);
    }

    DisData.currr = DisData.startr;
    while (*DisData.currr)
    {
        MoveNextBinding(&DisData.currr);
    }

    //
    // Scan linkages for NdisWan4 bindings
    //

    while (*LinkData.currb)
    {
        if (strstr(LinkData.currb, szNdisWan4))
        {
            Dprintf("ICFGNT: server binding found in %s\n",LinkData.currb);

            //
            // move binding to disabled list
            //
 
            lstrcpy(DisData.currb,LinkData.currb);
            lstrcpy(DisData.curre,LinkData.curre);
            lstrcpy(DisData.currr,LinkData.currr);

            //
            // Advanve current pointers in DisData
            //
            MoveNextBinding(&DisData.currb);
            MoveNextBinding(&DisData.curre);
            MoveNextBinding(&DisData.currr);

            //
            // Compact remaining linkage
            //
            CompactLinkage(LinkData.currb);
            CompactLinkage(LinkData.curre);
            CompactLinkage(LinkData.currr);

            bUpdateReg = TRUE;
        }
        else
        {
            //
            // Advance to next binding
            //
            MoveNextBinding(&LinkData.currb);
            MoveNextBinding(&LinkData.curre);
            MoveNextBinding(&LinkData.currr);
        }
    }
    
    if (bUpdateReg)
    {
        WriteBindings(LinkData,hKeyLink);
        WriteBindings(DisData,hKeyDis);

        RegCloseKey(hKeyDis);
        hKeyDis = NULL;

        RegCloseKey(hKeyLink);
        hKeyLink = NULL;

#if defined(_DEBUG)
        Dprintf("ICFGNT: ReviewBindings returnded %d\n",ReviewBindings(hwndParent));
#else
        ReviewBindings(hwndParent);
#endif
    }

IcfgTurnOffFileSharingExit:
    if (hKeyDis)
    {
        RegCloseKey(hKeyDis);
        hKeyDis = NULL;
    }

    if (hKeyLink)
    {
        RegCloseKey(hKeyLink);
        hKeyLink = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmcfg\cmcfg.h ===
//+----------------------------------------------------------------------------
//
// File:     cmcfg.h
//
// Module:   CMCFG32.DLL
//
// Synopsis: This source header file contains definitions for the CmConfig and CmConfigEx APIs
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   henryt       Created      08/27/99
//
//+----------------------------------------------------------------------------

#ifndef _CMCFG_H_
#define _CMCFG_H_

//
// Define string resources
//
#define IDS_NO_I386_ON_IA64 1000

#endif  // _CMCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmcfg\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMCFG32.DLL
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/17/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// WIN32 specfic includes
//
#include <ras.h>
#include <raserror.h>
#include "cmras.h"

#include "cmdebug.h"
#include "cmcfg.h"
#include "cmutil.h"

#include "base_str.h"
#include "mgr_str.h"
#include "reg_str.h"
#include "inf_str.h"
#include "stp_str.h"
#include "ras_str.h"

#include "cmsetup.h"

#include "allcmdir.h"

extern HINSTANCE  g_hInst;

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\ccfgnt\icfg32.cpp ===
/****************************************************************************
 *
 *	icfg32.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) 1992-1998 Microsoft Corporation
 *	All rights reserved
 *
 *	This module provides the implementation of the methods for
 *  the NT specific functionality of inetcfg
 *
 *	6/5/97	ChrisK	Inherited from AmnonH
 *
 ***************************************************************************/

#include <windows.h>
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <lmsname.h>
#include "debug.h"

#define REG_DATA_EXTRA_SPACE 255

extern DWORD g_dwLastError;

#include "ver.cpp"

//+----------------------------------------------------------------------------
//
//	Function:	IcfgNeedModem
//
//	Synopsis:	Check system configuration to determine if there is at least
//				one physical modem installed
//
//	Arguments:	dwfOptions - currently not used
//
//	Returns:	HRESULT - S_OK if successfull
//				lpfNeedModem - TRUE if no modems are available
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedModem (DWORD dwfOptions, LPBOOL lpfNeedModem) 
{
	if (GetOSMajorVersion() == 5)
	{
		return IcfgNeedModemNT5(dwfOptions, lpfNeedModem);
	}
	else
	{
		return IcfgNeedModemNT4(dwfOptions, lpfNeedModem);
	}
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgInstallModem
//
//	Synopsis:
//				This function is called when ICW verified that RAS is installed,
//				but no modems are avilable. It needs to make sure a modem is availble.
//				There are two possible scenarios:
//
//				a.  There are no modems installed.  This happens when someone deleted
//					a modem after installing RAS. In this case we need to run the modem
//				    install wizard, and configure the newly installed modem to be a RAS
//				    dialout device.
//
//				b.  There are modems installed, but non of them is configured as a dial out
//				    device.  In this case, we silently convert them to be DialInOut devices,
//				    so ICW can use them.
//
//	Arguments:	hwndParent - handle to parent window
//				dwfOptions - not used
//
//	Returns:	lpfNeedsStart - not used
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallModem (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart) 
{
	if (GetOSMajorVersion() == 5)
	{
		return IcfgInstallModemNT5(hwndParent, dwfOptions, lpfNeedsStart);
	}
	else
	{
		return IcfgInstallModemNT4(hwndParent, dwfOptions, lpfNeedsStart);
	}
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgNeedInetComponets
//
//	Synopsis:	Check to see if the components marked in the options are
//				installed on the system
//
//	Arguements:	dwfOptions - set of bit flag indicating which components to
//				check for
//
//	Returns;	HRESULT - S_OK if successfull
//				lpfNeedComponents - TRUE is some components are not installed
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents) 
{
	if (GetOSMajorVersion() == 5)
	{
		return IcfgNeedInetComponentsNT5(dwfOptions, lpfNeedComponents);
	}
	else
	{
		return IcfgNeedInetComponentsNT4(dwfOptions, lpfNeedComponents);
	}
}




//+----------------------------------------------------------------------------
//
//	Function:	IcfgInstallInetComponents
//
//	Synopsis:	Install the components as specified by the dwfOptions values
//
//	Arguments	hwndParent - handle to parent window
//				dwfOptions - set of bit flags indicating which components to
//					install
//
//	Returns:	HRESULT - S_OK if success
//				lpfNeedsReboot - TRUE if reboot is required
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart)
{
	if (GetOSMajorVersion() == 5)
	{
		return IcfgInstallInetComponentsNT5(hwndParent, dwfOptions, lpfNeedsRestart);
	}
	else
	{
		return IcfgInstallInetComponentsNT4(hwndParent, dwfOptions, lpfNeedsRestart);
	}
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgGetLastInstallErrorText
//
//	Synopsis:	Format error message for most recent error
//
//	Arguments:	none
//
//	Returns:	DWORD - win32 error code
//				lpszErrorDesc - string containing error message
//				cbErrorDesc - size of lpszErrorDesc
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
DWORD WINAPI
IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc)
{
	Dprintf("ICFGNT: IcfgGetLastInstallErrorText\n");
    return(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
							  NULL,
							  g_dwLastError,
							  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
							  lpszErrorDesc,
							  cbErrorDesc,
							  NULL));
}




//+----------------------------------------------------------------------------
//
//	Function:	DoStartService
//
//	Synopsis:	Start a particular service
//
//	Arguments:	hManager - handle to open service manager
//				szServiceName - name of service to start
//
//	Returns:	DWORD - win32 error code
//
//	History:	6/5/97	ChrisK	Inherited
//				7/28/97	ChrisK	Added query section
//-----------------------------------------------------------------------------
DWORD
DoStartService(SC_HANDLE hManager, LPTSTR szServiceName)
{
    SC_HANDLE hService = NULL;
	DWORD dwRC = ERROR_SUCCESS;

	//
	// Validate parameters
	//
	Assert(hManager && szServiceName);

	Dprintf("ICFGNT: DoStartService\n");
    hService = OpenService(hManager, szServiceName, SERVICE_START);
    if(hService != NULL)
	{
		if(!StartService(hService, 0, NULL)) 
		{
			dwRC = GetLastError();
			if(dwRC == ERROR_SERVICE_ALREADY_RUNNING) 
			{
				//
				// If the service is already running, great, we're done.
				//
				dwRC = ERROR_SUCCESS;
				goto DoStartServiceExit;
			}
		}

		CloseServiceHandle(hService);
		hService = NULL;
	}

	//
	// Try to simply see if the service is running
	//
	Dprintf("ICFGNT: Failed to start service, try just querying it.\n");
    hService = OpenService(hManager, szServiceName, SERVICE_QUERY_STATUS);
    if(hService != NULL)
	{
		SERVICE_STATUS sstatus;
		ZeroMemory(&sstatus,sizeof(sstatus));

		if(QueryServiceStatus(hService,&sstatus))
		{
			if ((SERVICE_RUNNING == sstatus.dwCurrentState)	|| 
				(SERVICE_START_PENDING == sstatus.dwCurrentState))
			{
				//
				// The service is running
				//
				dwRC = ERROR_SUCCESS;
				goto DoStartServiceExit;
			}
			else
			{
				//
				// The service not running and we can't access it.
				//
				Dprintf("ICFGNT: Queried service is not running.\n");
				dwRC = ERROR_ACCESS_DENIED;
				goto DoStartServiceExit;
			}
		}
		else
		{
			//
			// Can not query service
			//
			Dprintf("ICFGNT: QueryServiceStatus failed.\n");
			dwRC = GetLastError();
			goto DoStartServiceExit;
		}
	}
	else
	{
		//
		// Can't open the service
		//
		Dprintf("ICFGNT: Cannot OpenService.\n");
		dwRC = GetLastError();
		goto DoStartServiceExit;
	}

DoStartServiceExit:
	if (hService)
	{
		CloseServiceHandle(hService);
	}

    return(dwRC);
}



//+----------------------------------------------------------------------------
//
//	Function:	ValidateProductSuite
//
//	Synopsis:	Check registry for a particular Product Suite string
//
//	Arguments:	SuiteName - name of product suite to look for
//
//	Returns:	TRUE - the suite exists
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
BOOL 
ValidateProductSuite(LPSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

	Dprintf("ICFGNT: ValidateProductSuite\n");
	//
	// Determine the size required to read registry values
	//
    Rslt = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
	{
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        "ProductSuite",
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) 
	{
        goto exit;
    }

    if (!Size) 
	{
        goto exit;
    }

    ProductSuite = (LPSTR) GlobalAlloc( GPTR, Size );
    if (!ProductSuite) 
	{
        goto exit;
    }

	//
	// Read ProductSuite information
	//
    Rslt = RegQueryValueEx(
        hKey,
        "ProductSuite",
        NULL,
        &Type,
        (LPBYTE) ProductSuite,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) 
	{
        goto exit;
    }

    if (Type != REG_MULTI_SZ) 
	{
        goto exit;
    }

	//
	// Look for a particular string in the data returned
	// Note: data is terminiated with two NULLs
	//
    p = ProductSuite;
    while (*p) {
        if (strstr( p, SuiteName )) 
		{
            rVal = TRUE;
            break;
        }
        p += (lstrlen( p ) + 1);
    }

exit:
    if (ProductSuite) 
	{
        GlobalFree( ProductSuite );
    }

    if (hKey) 
	{
        RegCloseKey( hKey );
    }

    return rVal;
}


//+----------------------------------------------------------------------------
//
//	Function:	IcfgStartServices
//
//	Synopsis:	Start all services required by system
//
//	Arguments:	none
//
//	Returns:	HRESULT - S_OK if success
//
//	History:	6/5/97	ChrisK	Iherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgStartServices()
{
    //
    // returns ERROR_SERVICE_DISABLED if the service is disabled
    //

    SC_HANDLE hManager;

    Dprintf("ICFGNT: IcfgStartServices\n");
    hManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if(hManager == NULL)
    {
        return(GetLastError());
    }

    DWORD dwErr;


/* 
    //
    // Don't start RASAUTO anymore, it isn't necessary for RAS to be running.
    //
    if (!ValidateProductSuite( "Small Business" )) 
	{
		dwErr = DoStartService(hManager, TEXT("RASAUTO"));

        //
        // Ignore the return value, CM should proceed even if RASAUTO failed to launch
        //
	}
*/
    dwErr = DoStartService(hManager, TEXT("RASMAN"));
    CloseServiceHandle(hManager);
    return(dwErr);
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgIsGlobalDNS
//
//	Note: these functions are not needed on an NT system and it therefore not 
//	implemented
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS) 
{
    *lpfGlobalDNS = FALSE;
    return(ERROR_SUCCESS);
}



HRESULT WINAPI
IcfgRemoveGlobalDNS() 
{
    return(ERROR_SUCCESS);
}


HRESULT WINAPI
InetGetSupportedPlatform(LPDWORD pdwPlatform) 
{
    *pdwPlatform = VER_PLATFORM_WIN32_NT;
    return(ERROR_SUCCESS);
}


HRESULT WINAPI
InetSetAutodial(BOOL fEnable, LPCSTR lpszEntryName) 
{
    return(ERROR_INVALID_FUNCTION);
}


HRESULT WINAPI
InetGetAutodial(LPBOOL lpfEnable, LPSTR lpszEntryName,  DWORD cbEntryName) 
{
    return(ERROR_INVALID_FUNCTION);
}


HRESULT WINAPI
InetSetAutodialAddress(DWORD dwDialingLocation, LPSTR szEntry) 
{
    return(ERROR_SUCCESS);
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmcfg\makefile.inc ===
$(O)\cmcfg32.def: cmcfg32.src
    $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmcfg\cmcfgex.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmcfgex.cpp
//
// Module:   CMCFG32.DLL
//
// Synopsis: Source for the CmConfigEx API.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/17/99
//           quintinb       deprecated the CMConfigEx private interface  03/23/01
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
//+---------------------------------------------------------------------------
//
//	Function:	CMConfigEx
//
//	Synopsis:	Given the correct info in an INS file, this function extracts
//              the CMP, CMS, PBK, PBR, and INF files and invoke cmstp.exe
//              to install the profile.
//
//	Arguments:	pszInfFile      full path to the INS file
//
//	Returns:	BOOL            TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
extern "C" BOOL WINAPI CMConfigEx(
    LPCTSTR pszInsFile
) 
{
    CMASSERTMSG(FALSE, TEXT("CMConfigEx -- The CMConfigEx Private Interface has been deprecated -- returning failure."));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\cm\cmcfg\cmstpex.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmstpex.cpp
//
// Module:   CMCFG
//
// Synopsis: This file is the implementation of the CMSTP Extension Proc that
//           resides in cmcfg32.dll.  This proc is used to modify the install
//           behavior of cmstp.exe based profile installs.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb      Created    5-1-99
//
// History: 
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//  For ProfileNeedsMigration
//
#include "needsmig.cpp"

//
//  For GetPhoneBookPath
//
#include "linkdll.h"
#include "linkdll.cpp"
#include "allowaccess.h"
#include "allowaccess.cpp"
#include "getpbk.cpp"

//
//  For GetAllUsersCmDir
//
#include <shlobj.h>
#include "allcmdir.cpp"

//
//  Duplicated from processcmdln.h
//
#include "cmstpex.h"
#include "ver_str.h"
#include <shellapi.h>

//+----------------------------------------------------------------------------
//
// Function:  RenameOldCmBits
//
// Synopsis:  This function renames all of the old CM bits so that they will not
//            be loaded by the system during the launch of CM after the install.
//            This was to prevent problems with missing entry points (either things
//            we had removed or added to dlls like cmutil or cmpbk32).  The problem
//            is that cmdial32.dll is loaded explicitly from system32 by RAS (which 
//            has a fully qualified path).  However, any other dlls first check the
//            load directory of the exe file . . . which was cmstp.exe in the temp
//            dir.  Thus we were getting the newest cmdial32 but older versions of
//            cmutil, cmpbk, etc.  Thus to fix it we now rename the CM bits to .old
//            (cmmgr32.exe becomes cmmgr32.exe.old for instance).  This forces the
//            loader to pick the next best place to look for dlls, the system dir.
//
// Arguments: LPCTSTR szTempDir -- the temp dir path where the CM bits are
//
// Returns:   BOOL - TRUE if Successful
//
// History:   quintinb Created     6/2/99
//
//+----------------------------------------------------------------------------
BOOL RenameOldCmBits (LPCTSTR szTempDir)
{
    //
    //  Note that we don't rename cmstp.exe because it is doing the install.  We have no need to
    //  rename it because it is already executing and we are just trying to prevent old bits
    //  from being loaded and executed.
    //

    //
    //  Note that cmcfg32.dll will load the old cmutil.dll while the extension proc is running.
    //  Please be careful when you are adding cmutil entry points to cmcfg32.dll.
    //
  
    BOOL bReturn = TRUE;

    if (szTempDir)
    {

        //
        //  Sanity Check -- make sure we are not renaming the bits in system32
        //
        TCHAR szTemp[MAX_PATH+1];
        if (GetSystemDirectory(szTemp, MAX_PATH))
        {
            if (0 == lstrcmpi(szTemp, szTempDir))
            {
                return FALSE;
            }
        }

        TCHAR szSrc[MAX_PATH + 1];
        TCHAR szDest[MAX_PATH + 1];

        LPCTSTR ArrayOfCmFiles[] = 
        {
             TEXT("cmmgr32.exe"),
             TEXT("cmpbk32.dll"),
             TEXT("cmdial32.dll"),
             TEXT("cmdl32.exe"),
             TEXT("cnetcfg.dll"),
             TEXT("cmmon32.exe"),
             TEXT("cmutil.dll"),
             TEXT("instcm.inf"),
             TEXT("cmcfg32.dll"),
             TEXT("cnet16.dll"),
             TEXT("ccfg95.dll"),
             TEXT("cmutoa.dll"), // this probably won't ever exist in an older profile but delete anyway for interim build reasons
             TEXT("ccfgnt.dll")
        };
        const DWORD c_dwNumFiles = (sizeof(ArrayOfCmFiles)/sizeof(LPCTSTR));

        DWORD dwGreatestNumberOfChars = lstrlen(szTempDir) + 17; // 8.3 plus one for the NULL and one to count the dot and 4 for .old
        if (MAX_PATH > dwGreatestNumberOfChars)
        {
            for (int i = 0; i < c_dwNumFiles; i++)
            {
                wsprintf(szSrc, TEXT("%s\\%s"), szTempDir, ArrayOfCmFiles[i]);
                wsprintf(szDest, TEXT("%s\\%s.old"), szTempDir, ArrayOfCmFiles[i]);

                if (!MoveFile(szSrc, szDest))
                {
                    DWORD dwError = GetLastError();

                    //
                    //  Don't report an error because a file doesn't exist.
                    //
                    if (ERROR_FILE_NOT_FOUND != dwError)
                    {
                        bReturn = FALSE;
                    }
                }
            }        
        }
    }
    else
    {
        bReturn = FALSE;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  IsIeak5Cm
//
// Synopsis:  This function compares the given version and build numbers against
//            known constants to figure out if this is an IEAK5 profile or not.
//
// Arguments: DWORD dwMajorAndMinorVersion -- a DWORD containing the Major Version number
//                                            in the HIWORD and the Minor Version number
//                                            in the LOWORD.
//            DWORD dwBuildAndQfeNumber -- a DWORD containing the Build number in the 
//                                         HIWORD and the QFE number in the LOWORD.
//
// Returns:   BOOL -- TRUE if the version numbers passed in correspond to an IEAK5 profile
//
// History:   quintinb Created     8/2/99
//
//+----------------------------------------------------------------------------
BOOL IsIeak5Cm(DWORD dwMajorAndMinorVersion, DWORD dwBuildAndQfeNumber)
{
    BOOL bReturn = FALSE;
    const int c_Ieak5CmBuild = 1976;
    const int c_Ieak5CmMajorVer = 7;
    const int c_Ieak5CmMinorVer = 0;
    const DWORD c_dwIeak5Version = (c_Ieak5CmMajorVer << c_iShiftAmount) + c_Ieak5CmMinorVer;

    if ((c_dwIeak5Version == dwMajorAndMinorVersion) &&
        (c_Ieak5CmBuild == HIWORD(dwBuildAndQfeNumber)))

    {
        bReturn = TRUE;  
    }

    return bReturn;
}

//
//  RasTypeDefs
//
typedef DWORD (WINAPI *pfnRasSetEntryPropertiesSpec)(LPCTSTR, LPCTSTR, LPRASENTRY, DWORD, LPBYTE, DWORD);

//+----------------------------------------------------------------------------
//
// Function:  EnumerateAndPreMigrateAllUserProfiles
//
// Synopsis:  This function is called through the cmstp.exe extension proc.  It
//            is used to pre-migrate 1.0 profiles.  Any profile that needs migration
//            and hasn't been migrated yet (when the extension proc is called on an
//            install from an older profile), the connectoid is cleared so that the
//            CustomDialDll part of the connectoid entry is blanked out.  This 
//            prevents RasDeleteEntry being called on the connectoid by older versions
//            of cmstp.exe that don't know to clear the entry before calling it.
//            Otherwise, the RasCustomDeleteEntryNotify function is called and the whole
//            profile is deleted.  This will only happen on 1.0 profiles that have
//            been dialed with but not migrated/upgraded.  Please see NTRAID 379667
//            for further details.
//
// Arguments: BOOL bIeak5Profile -- If the calling profile is an IEAK5 CM profile or not
//
// Returns:   TRUE if successful
//
// History:   quintinb Created     8/2/99
//
//+----------------------------------------------------------------------------
BOOL EnumerateAndPreMigrateAllUserProfiles(BOOL bIeak5Profile)
{
    DWORD dwValueSize;
    HKEY hKey;
    DWORD dwType;
    DWORD dwDataSize;
    TCHAR szCurrentValue[MAX_PATH+1];
    TCHAR szCurrentData[MAX_PATH+1];

    //
    //  Load RasApi32.dll and get RasSetEntryProperties from it.
    //
    pfnRasSetEntryPropertiesSpec pfnSetEntryProperties = NULL;

    HMODULE hRasApi32 = LoadLibrary(TEXT("RASAPI32.DLL"));

    if (hRasApi32)
    {
        pfnSetEntryProperties = (pfnRasSetEntryPropertiesSpec)GetProcAddress(hRasApi32, 
                                                                             "RasSetEntryPropertiesA");
        if (NULL == pfnSetEntryProperties)
        {
            CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- Couldn't get RasSetEntryProperties."));
            return FALSE;
        }
    }
    else
    {
        CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- Couldn't load rasapi32.dll."));
        return FALSE;
    }

    //
    //  Get the all user CM and all user PBK directories
    //
    TCHAR szCmAllUsersDir[MAX_PATH+1] = {0};
    LPTSTR pszPhonebook = NULL;

    if (GetA