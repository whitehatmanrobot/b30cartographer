_dsbld_word

#ifndef	NO_STRING_OPERATIONS
	,
	_rd_ram_dsbld_string
#endif	/* NO_STRING_OPERATIONS */
};

READ_POINTERS	pointers_mode0_nch =
{
	_rdm0_byte_nch,
	_rdm0_word_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_rdm0_string_nch
#endif	/* NO_STRING_OPERATIONS */
};

#ifdef VGG
READ_POINTERS	pointers_mode0_ch4 =
{
	_rdm0_byte_ch4,
	_rdm0_word_ch4

#ifndef	NO_STRING_OPERATIONS
	,
	_rdm0_string_ch4
#endif	/* NO_STRING_OPERATIONS */
};
#endif

READ_POINTERS	pointers_mode1_nch =
{
	_rdm1_byte_nch,
	_rdm1_word_nch

#ifndef	NO_STRING_OPERATIONS
	,
	_rdm1_string_nch
#endif	/* NO_STRING_OPERATIONS */
};

#ifdef VGG
READ_POINTERS	pointers_mode1_ch4 =
{
	_rdm1_byte_ch4,
	_rdm1_word_ch4

#ifndef	NO_STRING_OPERATIONS
	,
	_rdm1_string_ch4
#endif	/* NO_STRING_OPERATIONS */
};
#endif

#ifdef A_VID
extern IU32 _ch2_md0_byte_read_glue();
extern IU32 _ch2_md0_word_read_glue();
extern void _ch2_md0_str_read_glue();

extern IU32 _ch2_md1_byte_read_glue();
extern IU32 _ch2_md1_word_read_glue();
extern void _ch2_md1_str_read_glue();

READ_POINTERS	pointers_mode0_ch2 =
{
	_ch2_md0_byte_read_glue,
	_ch2_md0_word_read_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_md0_str_read_glue
#endif	/* NO_STRING_OPERATIONS */
};

READ_POINTERS	pointers_mode1_ch2 =
{
	_ch2_md1_byte_read_glue,
	_ch2_md1_word_read_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_md1_str_read_glue
#endif	/* NO_STRING_OPERATIONS */
};
#else			/* AVID */

extern void rdm0_string_ch2 IPT3(UTINY *, dest, ULONG, offset, ULONG, count );
extern void rdm1_string_ch2 IPT3(UTINY *, dest, ULONG, offset, ULONG, count );
extern IU32 rdm0_byte_ch2 IPT1(ULONG, offset );
extern IU32 rdm1_byte_ch2 IPT1(ULONG, offset );
extern IU32 rdm0_word_ch2 IPT1(ULONG, offset );
extern IU32 rdm1_word_ch2 IPT1(ULONG, offset );

READ_POINTERS	pointers_mode0_ch2 =
{
	rdm0_byte_ch2,
	rdm0_word_ch2

#ifndef	NO_STRING_OPERATIONS
	,
	rdm0_string_ch2
#endif	/* NO_STRING_OPERATIONS */
};

READ_POINTERS	pointers_mode1_ch2 =
{
	rdm1_byte_ch2,
	rdm1_word_ch2

#ifndef	NO_STRING_OPERATIONS
	,
	rdm1_string_ch2
#endif	/* NO_STRING_OPERATIONS */
};

#endif /* A_VID */


#ifdef A3CPU
#ifdef C_VID
GLOBAL READ_POINTERS C_vid_reads;
#endif /* C_VID */
#else
#ifdef C_VID
GLOBAL READ_POINTERS C_vid_reads;
#else
GLOBAL READ_POINTERS A_vid_reads;
#endif /* A_VID */
#endif /* A3CPU */

#ifndef GISP_CPU
#if (defined(A_VID) && defined(A2CPU) && !defined(A3CPU)) || (defined(A3CPU) && defined(C_VID))
extern IU32 _glue_b_read();
extern IU32 _glue_w_read();
extern void _glue_str_read();

READ_POINTERS Glue_reads =
{
	_glue_b_read,
	_glue_w_read

#ifndef	NO_STRING_OPERATIONS
	,
	_glue_str_read
#endif	/* NO_STRING_OPERATIONS */

};
#endif
#endif /* GISP_CPU */

#else	/* CPU_40_STYLE - evid */

#ifdef C_VID
/* C_Evid glue */
extern read_byte_ev_glue IPT1(IU32, eaOff);
extern read_word_ev_glue IPT1(IU32, eaOff);
extern read_str_fwd_ev_glue IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
READ_POINTERS Glue_reads =
{
	read_byte_ev_glue,
	read_word_ev_glue,
	read_str_fwd_ev_glue
};
#else
READ_POINTERS Glue_reads = { 0, 0, 0 };
#endif /* C_VID */
READ_POINTERS	simple_reads;
READ_POINTERS	pointers_mode0_nch;
READ_POINTERS	pointers_mode1_nch;
READ_POINTERS	pointers_mode0_ch4;
READ_POINTERS	pointers_mode1_ch4;
READ_POINTERS	pointers_mode0_ch2;
READ_POINTERS	pointers_mode1_ch2;
GLOBAL READ_POINTERS C_vid_reads;
GLOBAL READ_POINTERS A_vid_reads;

ULONG EasVal;
IU32 latchval;	/* for get_latch() etc macros */
#endif	/* CPU_40_STYLE - evid */

READ_STATE read_state;

#ifndef	NO_STRING_OPERATIONS
GLOBAL void (*string_read_ptr)();
#endif	/* NO_STRING_OPERATIONS */

/* comparison masks for read mode 1 */
ULONG comp0, comp1, comp2, comp3;

/* colour comparison don't care masks for read mode 1 */
ULONG dont_care0, dont_care1, dont_care2, dont_care3;

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

/* Used to correct writes to M when in mode 0 */

GLOBAL IU32
rdm0_byte_ch2 IFN1(ULONG, offset )
{
	IU32 lsb;
	UTINY temp;
#ifndef NEC_98

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;
	setVideolatches(*(IU32 *)( EGA_planes + offset ));

	offset |= lsb;

  	temp = EGA_CPU.read_mapped_plane_ch2[offset];

#ifdef C_VID
	EasVal = temp;
#endif
#endif  //NEC_98
	return( temp );
}

/* Used to correct writes to M when in mode 0 */

GLOBAL IU32
rdm0_word_ch2 IFN1(ULONG, offset )
{
	IU32 temp;
#ifndef NEC_98
	IU32 lsb;

	setVideolatches(*(IU32 *)( EGA_planes +
		((( offset + 1 ) >> 1 ) << 2 )));

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;

	if( lsb )
	{
		temp = EGA_CPU.read_mapped_plane_ch2[offset + 1];
		temp |= ( EGA_CPU.read_mapped_plane_ch2[offset + 4] << 8 );
	}
	else
	{
		temp = EGA_CPU.read_mapped_plane_ch2[offset];
		temp |= ( EGA_CPU.read_mapped_plane_ch2[offset + 1] << 8 );
	}

#ifdef C_VID
	EasVal = temp;
#endif
#endif  //NEC_98
	return( temp );
}

/* Used to correct writes to M when in mode 0 */

GLOBAL void
rdm0_string_ch2 IFN3(UTINY *, dest, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	ULONG lsb;
	ULONG inc;
	UTINY *planes;

	if( getDF() )
		setVideolatches(*(IU32 *)( EGA_planes + (( offset >> 1 ) << 2 )));
	else
		setVideolatches(*(IU32 *)( EGA_planes + ((( offset + count - 1 ) >> 1 ) << 2 )));

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;

	if( lsb )
	{
		offset += 1;
		inc = 3;
	}
	else
		inc = 1;

	planes = EGA_CPU.read_mapped_plane_ch2;

    while( count-- )
    {
#ifdef BACK_M
        *dest-- = *(planes + offset);
#else
        *dest++ = *(planes + offset);
#endif
		offset += inc;
		inc ^= 0x2;
    }
#endif  //NEC_98
}

/* Used to correct writes to M when in mode 1 */

GLOBAL IU32
rdm1_byte_ch2 IFN1(ULONG, offset )
{
#if defined(NEC_98)
        return((IU32)0L);
#else   //NEC_98
	IU32 temp, lsb;

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;
	setVideolatches(*(IU32 *)( EGA_planes + offset ));

	if( lsb )
	{
		offset += 1;

		temp = (IU32)((( EGA_plane01[offset] ^ comp1 ) | dont_care1 )
					& (( EGA_plane23[offset] ^ comp3 ) | dont_care3 ));
	}
	else
	{
		temp = (IU32)((( EGA_plane01[offset] ^ comp0 ) | dont_care0 )
					& (( EGA_plane23[offset] ^ comp2 ) | dont_care2 ));
	}

#ifdef C_VID
	EasVal = temp;
#endif
	return( temp );
#endif  //NEC_98
}

GLOBAL IU32
rdm1_word_ch2 IFN1(ULONG, offset )		/* used to correct writes to M when in mode 1 */
{
#if defined(NEC_98)
        return((IU32)0L);
#else   //NEC_98
	IU32 temp1, temp2, lsb;

	setVideolatches(*(IU32 *)( EGA_planes + ((( offset + 1 ) >> 1 ) << 2 )));

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;

	if( lsb )
	{
		offset += 1;
		temp1 = (( EGA_plane01[offset] ^ comp1 ) | dont_care1 )
					& (( EGA_plane23[offset] ^ comp3 ) | dont_care3 );

		offset += 3;
		temp2 = (( EGA_plane01[offset] ^ comp0 ) | dont_care0 )
					& (( EGA_plane23[offset] ^ comp2 ) | dont_care2 );
	}
	else
	{
		temp1 = (( EGA_plane01[offset] ^ comp0 ) | dont_care0 )
					& (( EGA_plane23[offset] ^ comp2 ) | dont_care2 );

		offset += 1;
		temp2 = (( EGA_plane01[offset] ^ comp1 ) | dont_care1 )
					& (( EGA_plane23[offset] ^ comp3 ) | dont_care3 );
	}

	temp1 |= temp2 << 8;

#ifdef C_VID
	EasVal = temp1;
#endif
	return( temp1 );
#endif  //NEC_98
}

GLOBAL void
rdm1_string_ch2 IFN3(UTINY *, dest, ULONG, offset, ULONG, count )	/* used to correct writes to M when in mode 1 */
{
#ifndef NEC_98
	UTINY *p01, *p23;
	ULONG tcount, lsb;

#ifdef BACK_M
#define	PLUS -
#define	MINUS +
#else
#define	PLUS +
#define	MINUS -
#endif

	if( getDF() )
		setVideolatches(*(IU32 *)( EGA_planes + (( offset >> 1 ) << 2 )));
	else
		setVideolatches(*(IU32 *)( EGA_planes + ((( offset + count - 1 ) >> 1 ) << 2 )));

	dest = dest PLUS count;

	lsb = offset & 0x1;
	offset = ( offset >> 1 ) << 2;

	/* Two streams of source data */

	p01 = &EGA_plane01[offset];
	p23 = &EGA_plane23[offset];

	offset = 0;

	if( lsb )
	{
		*(dest MINUS count) = (UTINY)((( *(p01 + 1) ^ comp1 ) | dont_care1 )
   							        & (( *(p23 + 1) ^ comp3 ) | dont_care3 ));
		count--;
		offset += 4;
	}

	tcount = count & ~1;

	while( tcount-- )
	{
		*(dest MINUS tcount) = (UTINY)((( *(p01 + offset) ^ comp0) | dont_care0 )
							        & (( *(p23 + offset) ^ comp2 ) | dont_care2 ));

		tcount--;
		offset += 1;

		*(dest MINUS tcount) = (UTINY)((( *(p01 + offset) ^ comp1) | dont_care1 )
							        & (( *(p23 + offset) ^ comp3 ) | dont_care3 ));

		offset += 3;
	}	

	if( count & 1 )
	{
		*(dest MINUS count) = (UTINY)((( *(p01 + offset) ^ comp0 ) | dont_care0 )
							        & (( *(p23 + offset) ^ comp2 ) | dont_care2 ));
	}
#endif  //NEC_98
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_GRAPHICS.seg"
#endif

#if !(defined(NTVDM) && defined(MONITOR))
GLOBAL void
Glue_set_vid_rd_ptrs IFN1(READ_POINTERS *, handler )
{
#ifndef NEC_98
#ifndef CPU_40_STYLE	/* EVID */
#ifdef A3CPU
#ifdef C_VID

	C_vid_reads.b_read = handler->b_read;
	C_vid_reads.w_read = handler->w_read;
	C_vid_reads.str_read = handler->str_read;

#else
	UNUSED(handler);
#endif
#else					/* A3CPU */
#ifdef C_VID

	C_vid_reads.b_read = handler->b_read;
	C_vid_reads.w_read = handler->w_read;

#ifndef	NO_STRING_OPERATIONS
	C_vid_reads.str_read = handler->str_read;
#endif	/* NO_STRING_OPERATIONS */

#else

	A_vid_reads = *handler;

#if	0
	A_vid_reads.b_read = handler->b_read;
	A_vid_reads.w_read = handler->w_read;
#ifndef	NO_STRING_OPERATIONS
	A_vid_reads.str_read = handler->str_read;
#endif	/* NO_STRING_OPERATIONS */
#endif	/* 0 */

#endif	/* C_VID */
#endif	/* A3CPU */
#endif	/* CPU_40_STYLE - EVID */
#endif  //NEC_98
}	
#endif /* !(NTVDM && MONITOR) */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA.seg"
#endif

GLOBAL void
update_shift_count IFN0()

{
#ifndef NEC_98
	switch( EGA_CPU.chain )
	{
		case UNCHAINED:

 			/*
 			 *	Interleaved - need a shift count for accessing the mapped plane
 			 */

#ifdef BIGEND
 			setVideoread_shift_count(( 3 - getVideoread_mapped_plane() ) << 3);
#else
 			setVideoread_shift_count(getVideoread_mapped_plane() << 3);
#endif /* BIGEND */


			break;

		case CHAIN2:

 			/*
 			 *	Planar - need an offset for accessing the mapped plane
 			 */

 			EGA_CPU.read_mapped_plane_ch2 = EGA_planes +
		 					(getVideoread_mapped_plane() & 2) * EGA_PLANE_SIZE;

			break;

#ifdef	VGG
		case CHAIN4:

 			/*
 			 *	Interleaved - doesn't need any magic numbers
 			 */

			break;
#endif	/* VGG */
	}
#endif  //NEC_98
}

void
ega_read_routines_update IFN0()

{
#ifndef NEC_98
	LOCAL BOOL ram_off = TRUE;	/* optimised to avoid updates if ram disabled */
	LOCAL READ_POINTERS *read_ptrs;

	/* ram disabled and not now being enabled	*/

	if( ram_off && (!EGA_CPU.ram_enabled ))
		return;

	if( !EGA_CPU.ram_enabled )	/* video off, just return 0xff */
	{
#ifdef CPU_40_STYLE
		SetReadPointers(2);
#else  /* CPU_40_STYLE */

#ifndef GISP_CPU	
#ifdef A3CPU
#ifdef C_VID
		Glue_set_vid_rd_ptrs( &pointers_RAM_off );
#else
		Cpu_set_vid_rd_ptrs( &pointers_RAM_off );
#endif /* C_VID */
#else
		Glue_set_vid_rd_ptrs( &pointers_RAM_off );
#endif /* A3CPU */
#endif /* GISP_CPU */

#ifndef	NO_STRING_OPERATIONS
		setVideofwd_str_read_addr(_rd_ram_dsbld_fwd_string_lge);
		setVideofwd_str_read_addr(_rd_ram_dsbld_bwd_string_lge);
#endif	/* NO_STRING_OPERATIONS */

#endif  /* CPU_40_STYLE */

		ram_off = TRUE;	/* prevent recalcs until ram enabled again */

		return;
	}

	ram_off = FALSE;

	if( read_state.mode == 0 )    /* read mode 0 */
	{
		/* chained in write mode implies chained for reading too */

		switch( EGA_CPU.chain )
		{
			case UNCHAINED:
#ifdef CPU_40_STYLE
				SetReadPointers(0);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode0_nch;
#ifndef	NO_STRING_OPERATIONS
				setVideofwd_str_read_addr(_rdm0_fwd_string_nch_lge);
				setVideobwd_str_read_addr(_rdm0_bwd_string_nch_lge);
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */
				break;
				
			case CHAIN2:
#ifdef CPU_40_STYLE
				SetReadPointers(0);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode0_ch2;
#ifndef	NO_STRING_OPERATIONS
				string_read_ptr = rdm0_string_ch2;
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */
				EGA_CPU.read_mapped_plane_ch2 = EGA_planes +
							(getVideoread_mapped_plane() & 2)*EGA_PLANE_SIZE;
				break;
				
#ifdef	VGG
			case CHAIN4:
#ifdef CPU_40_STYLE
				SetReadPointers(0);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode0_ch4;
#ifndef	NO_STRING_OPERATIONS
				setVideofwd_str_read_addr(_rdm0_fwd_string_ch4_lge);
				setVideobwd_str_read_addr(_rdm0_bwd_string_ch4_lge);
#endif

#endif	/* CPU_40_STYLE */
				break;
#endif	/* VGG */
		}
	}
	else   /* read mode 1 */
	{
		switch( EGA_CPU.chain )
		{
			case UNCHAINED:
				/* preserve or complement values by xor with comps later */

				setVideodont_care(~sr_lookup[read_state.colour_dont_care]);
				setVideocolour_comp(~sr_lookup[read_state.colour_compare]);

#ifdef CPU_40_STYLE
				SetReadPointers(1);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode1_nch;
#ifndef	NO_STRING_OPERATIONS
				setVideofwd_str_read_addr(_rdm1_fwd_string_nch_lge);
				setVideobwd_str_read_addr(_rdm1_bwd_string_nch_lge);
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */
				break;

			case CHAIN2:
				dont_care0 = read_state.colour_dont_care & 1 ? 0 : 0xff;
				dont_care1 = read_state.colour_dont_care & 2 ? 0 : 0xff;
				dont_care2 = read_state.colour_dont_care & 4 ? 0 : 0xff;
				dont_care3 = read_state.colour_dont_care & 8 ? 0 : 0xff;

				comp0 = read_state.colour_compare & 1 ? 0 : 0xff;
				comp1 = read_state.colour_compare & 2 ? 0 : 0xff;
				comp2 = read_state.colour_compare & 4 ? 0 : 0xff;
				comp3 = read_state.colour_compare & 8 ? 0 : 0xff;

#ifdef CPU_40_STYLE
				SetReadPointers(1);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode1_ch2;
#ifndef	NO_STRING_OPERATIONS
				string_read_ptr = rdm1_string_ch2;
#endif	/* NO_STRING_OPERATIONS */

#endif	/* CPU_40_STYLE */

				break;

#ifdef	VGG
			case CHAIN4:
				setVideodont_care(( read_state.colour_dont_care & 1 ) ? 0 : 0xff);
				setVideocolour_comp(( read_state.colour_compare & 1 ) ? 0 : 0xff);

#ifdef CPU_40_STYLE
				SetReadPointers(1);
#else  /* CPU_40_STYLE */

				read_ptrs = &pointers_mode1_ch4;
#ifndef	NO_STRING_OPERATIONS
				setVideofwd_str_read_addr(_rdm1_fwd_string_ch4_lge);
				setVideobwd_str_read_addr(_rdm1_bwd_string_ch4_lge);
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */
				break;
#endif	/* VGG */
		}
	}

	update_shift_count();
	update_banking();

#ifndef CPU_40_STYLE
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
	Glue_set_vid_rd_ptrs( read_ptrs );
#else
	Cpu_set_vid_rd_ptrs( read_ptrs );
#endif /* C_VID */
#else
	Glue_set_vid_rd_ptrs( read_ptrs );
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif	/* CPU_40_STYLE */
#endif  //NEC_98
}

void
ega_read_init IFN0()

{
#ifndef NEC_98
	read_state.mode = 0;
	read_state.colour_compare = 0x0f;		/* looking for bright white */
	read_state.colour_dont_care = 0xf;		/* all planes significant */

#ifdef CPU_40_STYLE
	SetReadPointers(2);
#else  /* CPU_40_STYLE */

#ifndef	NO_STRING_OPERATIONS
	setVideofwd_str_read_addr(_rd_ram_dsbld_fwd_string_lge);
	setVideobwd_str_read_addr(_rd_ram_dsbld_bwd_string_lge);
#endif	/* NO_STRING_OPERATIONS */
#endif	/* CPU_40_STYLE */

	setVideoread_mapped_plane(0);

	ega_read_routines_update();			/* initialise M */

#if defined(EGA_DUMP) || defined(EGA_STAT)
	dump_read_pointers_init();
#endif

#if !defined(EGATEST) && !defined(A3CPU)
	read_pointers = Glue_reads;
#endif /* EGATEST */

#ifndef CPU_40_STYLE
#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
	Cpu_set_vid_rd_ptrs( &Glue_reads );
	Glue_set_vid_rd_ptrs( &pointers_mode0_nch );
#else
	Cpu_set_vid_rd_ptrs( &pointers_mode0_nch );
#endif	/* C_VID */
#else	/* A3CPU */
	Glue_set_vid_rd_ptrs( &pointers_mode0_nch );
#endif	/* A3CPU */
#endif /* GISP_CPU */
#endif	/* CPU_40_STYLE */
#endif  //NEC_98
}

void
ega_read_term IFN0()

{
#ifndef NEC_98
	/*
	 *	Turn off read calculations for non EGA/VGA adaptors
	 */

#ifdef CPU_40_STYLE
		SetReadPointers(3);
#else  /* CPU_40_STYLE */

#ifndef GISP_CPU
#ifdef A3CPU
#ifdef C_VID
	Glue_set_vid_rd_ptrs( &simple_reads );
#else
	Cpu_set_vid_rd_ptrs( &simple_reads );
#endif /* C_VID */
#else
	Glue_set_vid_rd_ptrs( &simple_reads );
#endif /* A3CPU */
#endif /* GISP_CPU */
#endif	/* CPU_40_STYLE */
#endif  //NEC_98
}

#endif /* REAL_VGA */
#endif /* EGG */

#endif	/* !(NTVDM && MONITOR) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ega_vide.c ===
#if !defined(i386) && defined(JAPAN)
    #include <windows.h>
#endif
#include "insignia.h"
#include "host_def.h"
/*                      INSIGNIA (SUB)MODULE SPECIFICATION
                        -----------------------------


        THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
        NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT                : EGA BIOS

RELATED DOCS            : IBM EGA Technical reference.

DESIGNER                : William Gulland

REVISION HISTORY        :
First version           : 17/8/88 William

SUBMODULE NAME          : ega_video

PURPOSE                 :  Emulate IBM EGA BIOS.


SccsID[]="@(#)ega_video.c       1.70 07/04/95 Copyright Insignia Solutions Ltd.";


[1.INTERMODULE INTERFACE SPECIFICATION]


[1.1    INTERMODULE EXPORTS]

        PROCEDURES() :  give procedure type,name, and argument types
                        void ega_video_init()
                        void ega_video_io()

        DATA         :  give type and name

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

        STRUCTURES/TYPEDEFS/ENUMS:

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

        PROCEDURES() :  give name, and source module name

        DATA         :  give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS      :     specify in following procedure descriptions
                        how these are accessed (read/modified)

[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE         :     ega_video_init()

PURPOSE           :     Initialize EGA-specific bits of the video BIOS.

PARAMETERS         None

ACCESS            :     called from video_init if EGA installed.

DESCRIPTION       :     describe what (not how) function does

                        Initializes ega_info & ega_info3.

=========================================================================

/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]                                               */

/* [3.1.1 #INCLUDES]                                                    */


#ifdef EGG
    #include <stdio.h>
    #include TypesH
    #include FCntlH

    #include "xt.h"
    #include CpuH
    #include "sas.h"
    #include "ios.h"
    #include "gmi.h"
    #include "gvi.h"
    #include "bios.h"
    #include "error.h"
    #include "config.h"
    #include "equip.h"
    #include "egacpu.h"
    #include "egaports.h"
    #include "gfx_upd.h"
    #include "egagraph.h"
    #include "egaread.h"
    #include "video.h"
    #include "egavideo.h"
    #include "vgaports.h"
    #include "debug.h"
    #include "timer.h"
    #include "host_gfx.h"
    #include "idetect.h"
    #ifndef PROD
        #include "trace.h"
    #endif
    #include "host.h"

    #ifdef  GISP_SVGA
        #include HostHwVgaH
        #include "hwvga.h"
    #endif          /* GISP_SVGA */
    #if defined(JAPAN) || defined(KOREA)
        #include <conapi.h>
    #endif // JAPAN || KOREA

/* [3.1.2 DECLARATIONS]                                                 */

GLOBAL IU8 Video_mode;  /* Shadow copy of BIOS video mode */
GLOBAL IU8 Currently_emulated_video_mode = 0;   /* Holds last video mode
                                                 * set through bios */

    #if defined(NTVDM) && defined(X86GFX)
/* Loads font from PC's BIOS into video memory */
IMPORT void loadNativeBIOSfont IPT1( int, lines );
    #endif

    #ifdef NTVDM
IMPORT int soft_reset;
IMPORT BOOL VDMForWOW;
IMPORT BOOL WowModeInitialized;
        #ifndef X86GFX
IMPORT void mouse_video_mode_changed(int new_video_mode);
        #endif
    #endif  /* NTVDM */

    #ifdef CPU_40_STYLE
GLOBAL IBOOL forceVideoRmSemantics = FALSE;
    #endif
    #ifdef JAPAN
// mskkbug #3167 works2.5 character corrupted 11/8/93 yasuho
// generate single byte charset for JAPAN
IMPORT GLOBAL void GenerateBitmap();
    #endif // JAPAN

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]                                                */

        #ifdef ANSI
GLOBAL void ega_set_mode(void),ega_char_gen(void);
static void ega_set_palette(void),ega_alt_sel(void);
GLOBAL void ega_set_cursor_mode(void);
static void ega_emul_set_palette(void);
        #else
GLOBAL void ega_set_mode(),ega_char_gen();
static void ega_set_palette(),ega_alt_sel();
GLOBAL void ega_set_cursor_mode();
static void ega_emul_set_palette();
        #endif /* ANSI */
static void (*ega_video_func[]) () = {
    ega_set_mode,
    ega_set_cursor_mode,
    vd_set_cursor_position,
    vd_get_cursor_position,
    vd_get_light_pen,
    vd_set_active_page,
    vd_scroll_up,
    vd_scroll_down,
    vd_read_attrib_char,
    vd_write_char_attrib,
    vd_write_char,
    ega_emul_set_palette,
    vd_write_dot,
    vd_read_dot,
    vd_write_teletype,
    vd_get_mode,
    ega_set_palette,
    ega_char_gen,
    ega_alt_sel,
    vd_write_string,
        #ifdef VGG
    not_imp,
    not_imp,
    not_imp,
    not_imp,
    not_imp,
    not_imp,
    vga_disp_comb,  /* Function 1A */
    vga_disp_func,
    vga_int_1C,     /* Save/Restore Video State */
        #endif
};

static int v7_mode_64_munge[4] ={0, 3, 12, 15};
IMPORT half_word bg_col_mask;

    #ifdef  VGG
/*
 * Define arrays for mapping the Video BIOS call start and end
 * cursor scanline to their corresponding VGA/EGA register values.
 * There are seperate arrays for cursor start and end and for
 * 8x8 and 8x16 char cell sizes.
 */

UTINY   vga_cursor8_start[17][17] = {
    /*00*/0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    /*01*/  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    /*02*/  0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    /*03*/  0x00, 0x01, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    /*04*/  0x00, 0x01, 0x05, 0x06, 0x07, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    /*05*/  0x00, 0x01, 0x02, 0x05, 0x06, 0x07, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    /*06*/  0x00, 0x01, 0x02, 0x04, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    /*07*/  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*08*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    /*09*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    /*10*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    /*11*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
    /*12*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0c, 0x0c, 0x0c, 0x0c,
    /*13*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0d, 0x0d, 0x0d,
    /*14*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0e, 0x0e,
    /*15*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07, 0x0f,
    /*16*/  0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x06, 0x07,
};


UTINY   vga_cursor16_start[17][17] = {
    /*00*/0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    /*01*/  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    /*02*/  0x00, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    /*03*/  0x00, 0x01, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    /*04*/  0x00, 0x01, 0x0c, 0x0d, 0x0e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    /*05*/  0x00, 0x01, 0x02, 0x0c, 0x0d, 0x0e, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    /*06*/  0x00, 0x01, 0x02, 0x08, 0x0c, 0x0d, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    /*07*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*08*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    /*09*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    /*10*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    /*11*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
    /*12*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c,
    /*13*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0d, 0x0d, 0x0d,
    /*14*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e, 0x0e, 0x0e,
    /*15*/  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x0f,
    /*16*/  0x00, 0x01, 0x02, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0c, 0x0d, 0x0e,
};

        #ifdef  USE_CURSOR_END_TABLES

UTINY   vga_cursor8_end[17][17] = {
    /*00*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /*01*/  0x01, 0x01, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*02*/  0x02, 0x02, 0x02, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*03*/  0x03, 0x03, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*04*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*05*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*06*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*07*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*08*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*09*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*10*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*11*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*12*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*13*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*14*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*15*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    /*16*/  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
};

UTINY   vga_cursor16_end[17][17] = {
    /*00*/0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /*01*/  0x01, 0x01, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*02*/  0x02, 0x02, 0x02, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*03*/  0x03, 0x03, 0x03, 0x03, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*04*/  0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*05*/  0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*06*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*07*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*08*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*09*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*10*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*11*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*12*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f,
    /*13*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f,
    /*14*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f,
    /*15*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
    /*16*/  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0e, 0x0e, 0x0e,
};
        #endif  /* USE_CURSOR_END_TABLES */
    #endif  /* VGG */

/* [5.1.1 #DEFINES]                                                     */
    #ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
        #include "VIDEO_BIOS_EGA.seg"
    #endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]                        */


/* [5.1.3 PROCEDURE() DECLARATIONS]                                     */

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS                                     */

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]                               */


/*
==========================================================================
FUNCTION        :       do_outb
PURPOSE         :       handy utility to output a value to an EGA chip register.
INPUT  PARAMS   :       index port, register, value to write
RETURN PARAMS   :       None
==========================================================================
FUNCTION        :       follow_ptr
PURPOSE         :       handy utility to follow a 'long' intel pointer.
INPUT  PARAMS   :       Address in M of the pointer
RETURN PARAMS   :       Address in M of the pointed-to byte.
==========================================================================
FUNCTION        :       low_set_mode
PURPOSE         :       Does low-level mode change.
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :       mode: screen mode to change to.
RETURN PARAMS   :
==========================================================================
FUNCTION        :       load_font
PURPOSE         :       load part of a font into EGA font memory.
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :       sys_addr table  Address in M of the character bitmaps
                        int count       number of characters to redefine
                        int char_off    first character to redefine
                        int font_no     font to change
                        int nbytes      Number of bytes per character
RETURN PARAMS   :
==========================================================================
PROCEDURE         :     ega_set_mode()
PURPOSE           :     Switch screen mode.
PARAMETERS        :      AL = mode.

GLOBALS           :     describe what exported data objects are
                        accessed and how. Likewise for imported
                        data objects.

ACCESS            :     via ega_video_func[] jump table.

RETURNED VALUE    :     None.

DESCRIPTION       :
==========================================================================
PROCEDURE         :     ega_alt_sel()
PURPOSE           :     Get EGA info
PARAMETERS        :     BL = function
GLOBALS           :
ACCESS            :     via ega_video_func[] jump table.
RETURNED VALUE    :     None.
DESCRIPTION       :
==========================================================================
FUNCTION        :       ega_set_palette
PURPOSE         :       brief description
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
FUNCTION        :       ega_emul_set_palette
PURPOSE         :       brief description
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
FUNCTION        :       ega_char_gen
PURPOSE         :       brief description
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
FUNCTION        :       write_ch_set/xor()
PURPOSE         :       Output character to screen in EGA graphics modes.
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
FUNCTION        :       name
PURPOSE         :       brief description
EXTERNAL OBJECTS:       list any used, and state changes incurred
RETURN VALUE    :
INPUT  PARAMS   :
RETURN PARAMS   :
==========================================================================
*/
    #ifdef VGG
/* Called for not implemented functions */
void not_imp IFN0()
{
    setAL(0);
}
    #endif

static void do_outb IFN3(int, index,int, ega_reg, byte, value)
{
    outb((IU16)index,(IU8)ega_reg);
    outb((IU16)(index+1),value);
}

sys_addr video_effective_addr IFN2(IU16, seg, IU16, offset)
{
    #ifdef CPU_40_STYLE
    if (forceVideoRmSemantics)
    {
        /* can't call effective_addr, as the segment is almost
        ** certainly bogus in prot mode. This mode of operation
        ** should ONLY be used when we are bypassing going to v86
        ** mode to do a video bios operation (see WinVDD.c)
        */
        return ((sys_addr)((((IU32)seg)<<4) + offset));
    }
    else
    #endif
    {
        return (effective_addr(seg, offset));
    }
}

sys_addr follow_ptr IFN1(sys_addr, addr)
{
    return (video_effective_addr(sas_w_at_no_check(addr+2),
                                 sas_w_at_no_check(addr)));
}

void low_set_mode IFN1(int, mode)
{
    int i;
    sys_addr save_addr,params_addr,palette_addr;
    word temp_word;
    half_word start, end, video_mode;


    params_addr = find_mode_table(mode,&save_addr);

/* setup Sequencer */
    #ifndef REAL_VGA
    do_outb(EGA_SEQ_INDEX,0,1);     /* Synchronous reset - turn off Sequencer */
    #else
    do_outb(EGA_SEQ_INDEX,0,0);     /* Reset - turn off Sequencer */
    #endif
    do_outb(EGA_CRTC_INDEX,0x11,0);
    for (i=0;i<EGA_PARMS_SEQ_SIZE;i++)
    {
        do_outb(EGA_SEQ_INDEX,i+1,sas_hw_at_no_check(params_addr+EGA_PARMS_SEQ+i));
    }
    do_outb(EGA_SEQ_INDEX,0,3);     /* Turn Sequencer back on */
/* setup Miscellaneous register */
    outb(EGA_MISC_REG,sas_hw_at_no_check(params_addr+EGA_PARMS_MISC));
/* setup CRTC */
    for (i=0;i<EGA_PARMS_CRTC_SIZE;i++)
    {
        do_outb(EGA_CRTC_INDEX,i,sas_hw_at_no_check(params_addr+EGA_PARMS_CRTC+i));
    }
    if (video_adapter == EGA)
    {
        if ((get_EGA_switches() & 1) && mode < 4)
        {
            /* For some reason, the CRTC parameter table for 'enhanced' text has
             * the same cursor start and end as for 'unenhanced' text.
             * So fix the cursor start & end values to sensible things.
             * This is not the case for the VGA BIOS mode table.
             */
            do_outb(EGA_CRTC_INDEX, R10_CURS_START, 11);
            do_outb(EGA_CRTC_INDEX, R11_CURS_END, 12);
        }
    }
/* setup attribute chip - NB need to do an inb() to clear the address */
    inb(EGA_IPSTAT1_REG, (half_word *)&temp_word);
    for (i=0;i<EGA_PARMS_ATTR_SIZE;i++)
    {
        outb(EGA_AC_INDEX_DATA,(IU8)i);
        outb(EGA_AC_INDEX_DATA,sas_hw_at_no_check(params_addr+EGA_PARMS_ATTR+i));
    }
/* setup graphics chips */
    for (i=0;i<EGA_PARMS_GRAPH_SIZE;i++)
    {
        do_outb(EGA_GC_INDEX,i,sas_hw_at_no_check(params_addr+EGA_PARMS_GRAPH+i));
    }

    #ifdef V7VGA
/* setup extensions registers */
        #ifndef GISP_SVGA       /* Don't want the V7 stuff for GISP
                           builds that still use our
                           video ROMS */

    if (video_adapter == VGA)
    {
        /* turn on extension registers */
        do_outb(EGA_SEQ_INDEX, 6, 0xea);

        if (mode < 0x46)
        {
            do_outb(EGA_SEQ_INDEX, 0xfd, 0x22);
            do_outb(EGA_SEQ_INDEX, 0xa4, 0x00);
            do_outb(EGA_SEQ_INDEX, 0xfc, 0x08);
            do_outb(EGA_SEQ_INDEX, 0xf6, 0x00);
            do_outb(EGA_SEQ_INDEX, 0xf8, 0x00);
            do_outb(EGA_SEQ_INDEX, 0xff, 0x00);
        }
        else
        {
            if (mode < 0x62)
                do_outb(EGA_SEQ_INDEX, 0xfd, 0x00);
            else if (mode == 0x62)
                do_outb(EGA_SEQ_INDEX, 0xfd, 0x90);
            else
                do_outb(EGA_SEQ_INDEX, 0xfd, 0xa0);

            if (mode == 0x60)
                do_outb(EGA_SEQ_INDEX, 0xa4, 0x00);
            else
                do_outb(EGA_SEQ_INDEX, 0xa4, 0x10);

            if (mode < 0x66)
                if ((mode == 0x63) || (mode == 0x64))
                    do_outb(EGA_SEQ_INDEX, 0xfc, 0x18);
                else
                    do_outb(EGA_SEQ_INDEX, 0xfc, 0x08);
            else
                do_outb(EGA_SEQ_INDEX, 0xfc, 0x6c);

            if ((mode < 0x65) || (mode == 0x66))
            {
                do_outb(EGA_SEQ_INDEX, 0xf6, 0x00);
                do_outb(EGA_SEQ_INDEX, 0xff, 0x00);
            }
            else
            {
                do_outb(EGA_SEQ_INDEX, 0xf6, 0xc0);
                do_outb(EGA_SEQ_INDEX, 0xff, 0x10);
            }

            if (mode == 0x62)
                do_outb(EGA_SEQ_INDEX, 0xf8, 0x10);
            else
                do_outb(EGA_SEQ_INDEX, 0xf8, 0x00);
        }

        /* turn off extension registers */
        do_outb(EGA_SEQ_INDEX, 6, 0xae);
    }
        #endif          /* GISP_SVGA */

    /***
            Update Extended BIOS data stuff ?
    ***/
    #endif

    /*
     * Update BIOS data variables
     */

    sas_storew_no_check(VID_COLS,sas_hw_at_no_check(params_addr+EGA_PARMS_COLS)); /* byte in ROM, word in BIOS var! */
    sas_store_no_check(vd_rows_on_screen, sas_hw_at_no_check(params_addr+EGA_PARMS_ROWS));
    sas_store_no_check(ega_char_height, sas_hw_at_no_check(params_addr+EGA_PARMS_HEIGHT));
    sas_storew_no_check(VID_LEN,sas_w_at_no_check(params_addr+EGA_PARMS_LENGTH));

/* save cursor mode: BIOS data area has end byte at the low address,
   so the bytes must be swapped over from the CRTC register sense */
    start = sas_hw_at_no_check(params_addr+EGA_PARMS_CURSOR);
    sas_store_no_check(VID_CURMOD+1, start);
    end = sas_hw_at_no_check(params_addr+EGA_PARMS_CURSOR+1);
    sas_store_no_check(VID_CURMOD, end);
    sure_sub_note_trace2(CURSOR_VERBOSE,"changing mode, setting cursor bios vbls to start=%d, end=%d",start,end);
    sure_sub_note_trace2(CURSOR_VERBOSE,"changing mode, mode=%#x, params_addr=%#x",mode,params_addr);

/* save Palette registers if necessary */
    palette_addr = follow_ptr(save_addr+PALETTE_OFFSET);
    if (palette_addr)
    {
        for (i=0;i<16;i++)
            sas_store_no_check(palette_addr+i, sas_hw_at_no_check(params_addr+EGA_PARMS_ATTR+i));
        sas_store_no_check(palette_addr+16, sas_hw_at_no_check(params_addr+EGA_PARMS_ATTR+17));
    }

/* Get the video_.. variables from the mode table */
    video_mode = sas_hw_at_no_check(vd_video_mode);
    #ifdef V7VGA
    if (video_adapter == VGA)
    {
        if (video_mode > 0x13)
            video_mode += 0x4c;
        else if ((video_mode == 1) && extensions_controller.foreground_latch_1)
            video_mode = extensions_controller.foreground_latch_1;
    }

    if (video_mode >= 0x60)
    {
        video_pc_low_regen = vd_ext_graph_table[video_mode-0x60].start_addr;
        video_pc_high_regen = vd_ext_graph_table[video_mode-0x60].end_addr;
    }
    else if (video_mode >= 0x40)
    {
        video_pc_low_regen = vd_ext_text_table[video_mode-0x40].start_addr;
        video_pc_high_regen = vd_ext_text_table[video_mode-0x40].end_addr;
    }
    else
    {
        video_pc_low_regen = vd_mode_table[video_mode].start_addr;
        video_pc_high_regen = vd_mode_table[video_mode].end_addr;
    }
    #else
    video_pc_low_regen = vd_mode_table[video_mode].start_addr;
    video_pc_high_regen = vd_mode_table[video_mode].end_addr;
    #endif /* V7VGA */

    #ifdef VGG
    if (video_adapter == VGA)
    {
        i = get_scanlines();       /* WARNING - needs the BIOS variables! */
        if (mode == 0x13 || mode > 0x65)
        {
            init_vga_dac(2);  /* 256 colour DAC table */
        }
        else if (i == RS200 || mode == 0x63 || mode == 0x64)
        {
            init_vga_dac(1);  /* DACs to emulate CGA palette - RGB + Intensity*/
        }
        else
        {
            init_vga_dac(0);  /* DACs to emulate EGA palette - RGB + rgb */
        }
        outb(VGA_DAC_MASK,0xff);
        /* Initialize the fancy VGA palette stuff to look like an EGA */
        inb(EGA_IPSTAT1_REG, (half_word *)&temp_word);
        outb(EGA_AC_INDEX_DATA, 20); /* Pixel padding register */
        outb(EGA_AC_INDEX_DATA, 0);  /* Use first block of 64 in DACs */
    }
    #endif
}

/* Load part of a font into EGA font memory. */
void load_font IFN5
(
sys_addr, table,     /* Address in M of the character bitmaps */
int, count,          /* number of characters to redefine */
int, char_off,       /* first character to redefine */
int, font_no,        /* font to change */
int, nbytes          /* Number of bytes per character */
)
{
        #if !(defined(NTVDM) && defined(X86GFX)) || defined(ARCX86)
    int i,j;
    sys_addr font_addr;
    sys_addr data_addr;
        #endif /* !(NTVDM && X86GFX) || ARCX86 */
    half_word temp_word;
    half_word video_mode;
    static word font_off[] = { 0, 0x4000, 0x8000, 0xc000, 0x2000, 0x6000, 0xa000, 0xe000};

/* First switch to font loading mode */
    low_set_mode(FONT_LOAD_MODE);


        #if defined(NTVDM) && defined(X86GFX)

            #ifdef ARCX86
    if (UseEmulationROM)
    {
        font_addr = (sys_addr)(&EGA_planes[FONT_BASE_ADDR]) +
                    (font_off[font_no] + FONT_MAX_HEIGHT*char_off) * 4;
        data_addr = table;

        for (i=0;i<count;i++)
        {
            for (j=0;j<nbytes;j++)
            {
                sas_store(font_addr, sas_hw_at_no_check(data_addr));
                font_addr += 4;
                data_addr++;
            }

            font_addr += (FONT_MAX_HEIGHT - nbytes) * 4;
        }
    }
    else
    {
        loadNativeBIOSfont( 25 );
    }
            #else  /* ARCX86 */
    loadNativeBIOSfont( 25 );
            #endif /* ARCX86 */

        #else
            #ifdef GISP_SVGA
    if (hostIsFullScreen( ))
    {
        loadFontToVGA( table , count , char_off , font_no , nbytes );
    }
    else
    {
        loadFontToEmulation( table , count , char_off , font_no , nbytes );
    }
            #else /* GISP_SVGA */


    /* Work out where to put the font. */
    font_addr = 0xA0000 + font_off[font_no] + FONT_MAX_HEIGHT*char_off;
    data_addr = table;

    for (i=0;i<count;i++)   /* for each character */
    {
        for (j=0;j<nbytes;j++)   /* for each byte of character */
        {
            sas_store(font_addr, sas_hw_at_no_check(data_addr));
            font_addr++;
            data_addr++;
        }

        font_addr += (FONT_MAX_HEIGHT - nbytes);
    }
            #endif  /* GISP_SVGA */
        #endif  /* NTVDM && X86GFX */

/* Finally switch back to the BIOS mode */
    video_mode = sas_hw_at_no_check(vd_video_mode);
        #ifdef V7VGA
    if (video_adapter == VGA)
        if (video_mode > 0x13)
            video_mode += 0x4c;
        else if ((video_mode == 1) && extensions_controller.foreground_latch_1)
            video_mode = extensions_controller.foreground_latch_1;
        #endif /* V7VGA */

    low_set_mode(video_mode);
    inb(EGA_IPSTAT1_REG,&temp_word);
    outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
}

void recalc_text IFN1(int, height)
{
    int scan_lines;
    half_word video_mode;
    word screen_height;
    half_word oflo;
    half_word protect;
        #ifdef NTVDM
    MAX_SCAN_LINE   crtc_reg9;
        #endif
        #ifdef JAPAN
    // mskkbug #2784 Title of VJE-PEN is strange 11/5/93 yasuho
    word length;
        #endif // JAPAN

    video_mode = sas_hw_at_no_check(vd_video_mode);
        #ifdef V7VGA
    if (video_adapter == VGA)
        if (video_mode > 0x13)
            video_mode += 0x4c;
        else if ((video_mode == 1) && extensions_controller.foreground_latch_1)
            video_mode = extensions_controller.foreground_latch_1;
        #endif /* V7VGA */

    if (video_adapter == EGA && !(get_EGA_switches() & 1) && (video_mode < 4))
        scan_lines = 200; /* Low res text mode */
    else
        scan_lines = get_screen_height() + 1;

    sas_store_no_check(ega_char_height, (IU8)height);
    sas_store_no_check(vd_rows_on_screen, (IU8)(scan_lines/height - 1));
        #ifdef JAPAN
    // mskkbug #2784 Title of VJE-PEN is strange 11/5/93 yasuho
    // Adjust video length
    length = (sas_hw_at_no_check(vd_rows_on_screen) + 1) *
             sas_w_at_no_check(VID_COLS) * 2;
    if (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x73)
        length *= 2;
    sas_storew_no_check(VID_LEN, length);
        #else // !JAPAN
    if (video_mode < 4 &&  scan_lines/height == 25)
        sas_storew_no_check(VID_LEN, (IU16)(video_mode<2 ? 0x800 : 0x1000));
    else
        sas_storew_no_check(VID_LEN, (IU16)((sas_hw_at_no_check(vd_rows_on_screen)+1)*sas_w_at_no_check(VID_COLS)*2));
        #endif // !JAPAN
        #ifdef NTVDM
    /* preserve other bits in register 9 for VGA */
    if (video_adapter == VGA)
    {
        outb(EGA_CRTC_INDEX, 9);
        inb(EGA_CRTC_DATA, (half_word *) &crtc_reg9);
        crtc_reg9.as_bfld.maximum_scan_line = height -1;
        outb(EGA_CRTC_DATA, (IU8)crtc_reg9.as.abyte);
    }
    else
        do_outb(EGA_CRTC_INDEX,9,(IU8)(height-1)); /* Character height */
        #else
    do_outb(EGA_CRTC_INDEX,9,height-1); /* Character height */
        #endif
    do_outb(EGA_CRTC_INDEX,0xA,(IU8)(height-1));    /* Cursor start */
    do_outb(EGA_CRTC_INDEX,0xB,0);          /* Cursor end */

    /*
    * VGA adapter height setting occupies Vertical Display End register
    * plus 2 bits in the overflow register. The overflow register may also
    * be write protected.
    */
    if (video_adapter == VGA)
    {
        #ifdef NTVDM
        /* Some globals that the mouse driver needs to have available */
        /* when an application (such as any CW based apps.) makes a   */
        /* call to int 33h AX = 26h.                                  */

        IMPORT word VirtualX, VirtualY;
        #endif /* NTVDM */

        screen_height = (sas_hw_at_no_check(vd_rows_on_screen)+1)*height-1;

        #ifdef NTVDM
        /* Create the virtual screen size maximums for the text modes */
        /* This is needed here for CW applications.                  */

        VirtualX = 640;         /* This is always this value */
        if (scan_lines == 401)
            VirtualY = 400;             /* 50 text row mode - 400 scanlines */
        else if (scan_lines == 351)
            VirtualY = 344;             /* 43 text row mode - 350 scanlines */
        else
            VirtualY = 200;             /* Failsafe - 25 row mode or rest!  */

        #endif /* NTVDM */

        outb(EGA_CRTC_INDEX, 7);        /* overflow register */
        inb(EGA_CRTC_DATA, &oflo);
        outb(EGA_CRTC_INDEX, 0x11);     /* vert sync contains protect bit */
        inb(EGA_CRTC_DATA, &protect);

        if (screen_height & 0x100)
            oflo |= 2;   /* bit 8 of height -> bit 1 of overflow register */
        else
            oflo &= ~2;
        if (screen_height & 0x200)
            oflo |= 0x40;   /* bit 9 of height -> bit 6 of overflow register */
        else
            oflo &= ~0x40;
        if ((protect & 0x80) == 0x80)    /* overflow reg protected */
        {
            do_outb(EGA_CRTC_INDEX, 0x11, (IU8)(protect & 0x7f)); /* enable writes */
            do_outb(EGA_CRTC_INDEX, 7, oflo);       /* overflow reg */
            do_outb(EGA_CRTC_INDEX, 0x11, protect); /* put back old value */
        }
        else
            do_outb(EGA_CRTC_INDEX, 7, oflo);       /* overflow reg */

        do_outb(EGA_CRTC_INDEX,0x12, (IU8)(screen_height & 0xff)); /* Vertical display end = scan lines */
    }
    else
        if (video_adapter == EGA)
    {
        screen_height = (sas_hw_at_no_check(vd_rows_on_screen)+1)*height-1;
        outb(EGA_CRTC_INDEX, 7);        /* overflow register */
        inb(EGA_CRTC_DATA, &oflo);
        if (screen_height & 0x100)
            oflo |= 2;   /* bit 8 of height -> bit 1 of overflow reg */
        else
            oflo &= ~2;
        do_outb(EGA_CRTC_INDEX, 7, oflo);       /* overflow reg */
        do_outb(EGA_CRTC_INDEX, 0x12, (IU8)(screen_height & 0xff)); /* Vertical display end = scan lines */
    }
    else
    {
        assert1(NO, "Bad video adapter (%d) in recalc_text", video_adapter);
    }

    do_outb(EGA_CRTC_INDEX,0x14,(IU8)height); /* Underline scan line - ie no underline */
}

static void set_graph_font IFN1(int, height)
{
    switch (getBL())
    {
    case 0:
        sas_store_no_check(vd_rows_on_screen, (IU8)(getDL()-1));
        break;
    case 1:
        sas_store_no_check(vd_rows_on_screen, 13);
        break;
    case 2:
        sas_store_no_check(vd_rows_on_screen, 24);
        break;
    case 3:
        sas_store_no_check(vd_rows_on_screen, 42);
        break;
    default:
        assert2(FALSE,"Illegal char gen sub-function %#x:%#x",getAL(),getBL());
    }
    sas_store_no_check(ega_char_height, (IU8)height);
}

LOCAL VOID
write_ch_set IFN5(sys_addr, char_addr, int, screen_off,
                  int, colour, int, nchs, int, scan_length)
{
    unsigned int i, j, colourmask, data, temp, char_height;
    unsigned int *screen;
    register sys_addr font;

        #ifndef REAL_VGA

    /*
     * video mode 11 (VGA 640x480 2 colour mode) is a special case as
     * it does not have a 'no display' attribute.
     */

    if (sas_hw_at_no_check(vd_video_mode) == 0x11)
        colourmask = ~0;
    else
        colourmask = sr_lookup[colour & 0xf];

    font = char_addr;

    screen = (unsigned int *) &EGA_planes[screen_off << 2];
    char_height = sas_hw_at_no_check(ega_char_height);

    if (nchs == 1)
    {
        for (i = char_height; i > 0; i--)
        {
            data = sas_hw_at_no_check(font);
            font++;
            temp = data << 8;
            data |= temp;
            temp = data << 16;
            data |= temp;

            *screen = data & colourmask;
            screen += scan_length;
        }
    }
    else
    {
        scan_length -= nchs;

        for (i = char_height; i > 0; i--)
        {
            data = sas_hw_at_no_check(font);
            font++;
            temp = data << 8;
            data |= temp;
            temp = data << 16;
            data |= temp;

            data &= colourmask;

            for (j = nchs; j > 0; j--)
            {
                *screen++ = data;
            }

            screen += scan_length;
        }
    }
        #else
    vga_card_w_ch_set(char_addr, screen_off, colour, nchs, scan_length, char_height);
        #endif
}

void write_ch_xor IFN5(sys_addr, char_addr, int, screen_off,
                       int, colour, int, nchs, int, scan_length)
{
    unsigned int i, j, colourmask, data, temp, char_height;
    unsigned int *screen;
    register sys_addr font;

        #ifndef REAL_VGA
    /*
     * video mode 11 (VGA 640x480 2 colour mode) is a special case as
     * it does not have a 'no display' attribute.
     */
    if (sas_hw_at_no_check(vd_video_mode) == 0x11)
        colourmask = ~0;
    else
        colourmask = sr_lookup[colour & 0xf];

    font = char_addr;
    char_height = sas_hw_at_no_check(ega_char_height);

    screen = (unsigned int *) &EGA_planes[screen_off << 2];

    if (nchs == 1)
    {
        for (i = char_height; i > 0; i--)
        {
            data = sas_hw_at_no_check(font);
            font++;
            temp = data << 8;
            data |= temp;
            temp = data << 16;
            data |= temp;

            *screen ^= data & colourmask;
            screen += scan_length;
        }
    }
    else
    {
        scan_length -= nchs;

        for (i = char_height; i > 0; i--)
        {
            data = sas_hw_at_no_check(font);
            font++;
            temp = data << 8;
            data |= temp;
            temp = data << 16;
            data |= temp;

            data &= colourmask;

            for (j = nchs; j > 0; j--)
            {
                *screen++ ^= data;
            }

            screen += scan_length;
        }
    }
        #else
    vga_card_w_ch_xor(char_addr, screen_off, colour, nchs, scan_length, char_height);
        #endif
}

GLOBAL void ega_set_mode IFN0()
{
    int pag;
    sys_addr save_addr,font_addr;
    int font_offset;
    half_word temp_word;
    byte mode_byte;
    byte video_mode;
        #ifdef V7VGA
    byte saveBL;
        #endif /* V7VGA */

        #ifndef PROD
    trace("setting video mode", DUMP_REG);
        #endif

        #ifdef GISP_SVGA
    /* Try and catch mode changes early */

    /* Are we in the ROMS at the BOP 10 ? */
    if (getCS( ) == EgaROMSegment)
    {
        if (videoModeIs( getAL( ) , GRAPH ))
        {
            /* Seem to have got a video mode int 10 */
            videoInfo.modeType = GRAPH;
            if (!hostEasyMode( ))
            {
                videoInfo.forcedFullScreen = TRUE;

                /* point IP at the JMP to host roms */
                setIP( 0x820 );

                /* and return, to let the host bios do the change */
                return;
            }


        }

        /* Not in the vga roms so carry on */
    }
        #endif          /* GISP_SVGA */

        #ifdef V7VGA
    /*
       Real video-7 maps mode 7 and mode f to mode 0.
    */

    if (video_adapter==VGA)
    {
        video_mode=(getAL()&0x7F);
        if (video_mode==7||video_mode==0xF)
        {
            setAL(getAL()&0x80);
            always_trace1("V7 doesn't support mode %02x, using mode 0\n",video_mode);
        }
    }
        #endif

        #ifdef JAPAN
    // mode73h support 5/26/1993 V-KazuyS
    // when it's not US mode, ntvdm maps mode 73 to mode 3.
            #ifdef JAPAN_DBG
    DbgPrint( "NTVDM: ega_set_mode() setting video mode %x\n", getAL() );
            #endif
    if (!is_us_mode())
    {
            #ifdef i386
        if (getAL() == 0x73)
        {
            sas_store(DosvModePtr, getAL());
            setAL( 0x03 );
            #else // !i386
        if ((getAL() & 0x7f) == 0x73)
        {
            setAL( (getAL() & 0x83) );
            #endif // !i386
        }
            #if !defined(i386) && defined(JAPAN_DBG)
        DbgPrint( " NTVDM: DosvMode %x\n", sas_hw_at_no_check(DosvModePtr));
            #endif
    }
        #endif // JAPAN
    if (is_bad_vid_mode(getAL()))
    {
        #ifdef V7VGA
        if ((video_adapter == VGA) && is_v7vga_mode(getAL() + 0x4c))
        {
            saveBL = getBL();
            /* Put the mode value where the V7 BIOS expects it */
            setBL(getAL() + 0x4c);
            v7vga_extended_set_mode();
            setBL(saveBL);
        }
        else
        #endif /* V7VGA */
            always_trace1("Bad video mode - %d.\n", getAL());
        return;
    }

    video_mode=(getAL()&0x7F);

        #ifdef V7VGA
    /*
     * The real V7 VGA does not change into 40 col mode while
     * in any proprietary text mode. (A bug ?!)
     * Emulate this behaviour !
     */
    if (video_adapter == VGA && video_mode == 1
        && is_v7vga_mode(extensions_controller.foreground_latch_1))
    {
        saveBL = getBL();
        /*
         * This is all backwards - we make the v7vga extended mode setup
         * believe the new mode is the old one. Probably the real card's BIOS
         * is just as confused as this code.
         * Put the mode value where the V7 BIOS expects it.
         */
        setBL(extensions_controller.foreground_latch_1);
        v7vga_extended_set_mode();
        setBL(saveBL);
        return;
    }

    /*
     * Don't confuse the tricky V7 extended mode setting, as
     * implemented in v7_video.c, v7vga_extended_set_mode().
     * low_set_mode() looks at it. Zero it.
     */
    extensions_controller.foreground_latch_1 = 0;
        #endif  /* V7VGA */

/*
 * Only update the global video mode if we're in the system virtual machine.
 * The global mode should then be valid for use in timer interrupts.
 */

    if (sas_hw_at_no_check(BIOS_VIRTUALISING_BYTE) == 0)
        Video_mode = video_mode;

    sas_store_no_check(vd_video_mode, (IU8)(getAL() & 0x7F)); /* get rid of top bit - indicates clear or not */
    sas_store_no_check(ega_info, (IU8)((sas_hw_at_no_check(ega_info) & 0x7F ) | (getAL() & 0x80))); /* update screen clear flag in ega_info */

        #ifdef JAPAN
    // In JP mode, if video mode != jp mode, set US mode.
    if (( video_mode != 0x03 )
        && ( video_mode != 0x11 )
        && ( video_mode != 0x12 )
        && ( video_mode != 0x72 )
        && ( video_mode != 0x73 ))
    {
            #ifdef JAPAN_DBG
        DbgPrint( "VideoMode(%02x) != jp mode, setCP 437\n", getAL() );
            #endif
        SetConsoleCP( 437 );
        SetConsoleOutputCP( 437 );
        SetDBCSVector( 437 );
    }

    // notice video format to console

    VDMConsoleOperation(VDM_SET_VIDEO_MODE,
                        (LPVOID)((sas_hw_at_no_check(DosvModePtr) == 0x73) ? TRUE : FALSE));

    // Int10Flag initialize
    {
        register byte *p = Int10Flag;
        register int i;
        int count = 80*50;

            #ifdef JAPAN_DBG
        DbgPrint( "NTVDM: ega_set_mode() Int10Flag Initialize\n" );
            #endif
        for (i = 0; i < count; i++)
            *p++ = INT10_SBCS | INT10_CHANGED;        // init == all space
        Int10FlagCnt++;
    }

        #elif defined(KOREA) // JAPAN
    // In KO mode, if video mode != ko mode, set US mode.
    if (( video_mode != 0x03 )
        && ( video_mode != 0x11 )
        && ( video_mode != 0x12 )
        && ( video_mode != 0x72 ))
    {

        SetConsoleCP( 437 );
        SetConsoleOutputCP( 437 );
        SetDBCSVector( 437 );
    }

    // notice video format to console
    VDMConsoleOperation(VDM_SET_VIDEO_MODE, (LPVOID)FALSE);
        #endif // KOREA
        #ifdef CPU_40_STYLE
    if (forceVideoRmSemantics && (!get_EGA_no_clear()))
    {
        /* empty the planes... */
        memset(&EGA_planes[0], 0, 64*1024*4);
    }
        #endif

        #ifdef MSWDVR
    /*
     * If the video mode has actually changed, then call
     * host_mswin_disable().
     */
    if (Currently_emulated_video_mode != video_mode)
    {
            #ifdef CPU_40_STYLE
        if (!getPE())
        {
            host_mswin_disable();
        }
            #else
        host_mswin_disable();
            #endif /* CPU_40_STYLE */
    }
        #endif /* MSWDVR */

    Currently_emulated_video_mode = video_mode;

        #if defined(NTVDM) && defined(X86GFX)
    /*
    ** Tim August 92. MicroSoft.
    ** Give host a chance to do a zany non-standard mode change.
    ** For Microsoft NT this is a transition to full-screen ie. the
    ** real PC's video BIOS and graphics board.
    **
    ** Return value of TRUE means host has done the mode change for
    ** us, so no need to continue.
    */
    {
        extern BOOL hostModeChange IPT0();

        if (hostModeChange())
            return;
    }
        #endif  /* NTVDM & X86GFX */

    save_addr = follow_ptr(EGA_SAVEPTR);
    if (alpha_num_mode())
    {
        #ifdef VGG
        /* load_font will do the mode change for us */
        if (video_adapter == VGA)
        {
            #ifdef NTVDM
            /* Some globals that the mouse driver needs to have available */
            /* when an application (such as any CW based apps.) makes a   */
            /* call to int 33h AX = 26h.                                  */

            IMPORT word VirtualX, VirtualY;
            #endif /* NTVDM */

            switch (get_VGA_lines())
            {
            case S350:
                load_font(EGA_CGMN,256,0,0,14);
            #ifdef NTVDM
                VirtualX = 640;
                VirtualY = 344;
            #endif /* NTVDM */
                break;
            case S400:
                load_font(EGA_HIFONT,256,0,0,16);
            #ifdef NTVDM
                /* This one gets hit the most by C.W. applications. */
                /* Actually, the other cases never seem to get hit  */
                /* but are there JUST IN CASE! The 43 and 50 row    */
                /* modes in recalc_text().                          */

                VirtualX = 640;
                VirtualY = 200;
            #endif /* NTVDM */
                break;
            default:
                load_font(EGA_CGDDOT,256,0,0,8);
            #ifdef NTVDM
                VirtualX = 640;
                VirtualY = 400;
            #endif /* NTVDM */
            }
        }
        else
        #endif  /* VGG */
        {
            if (get_EGA_switches() & 1)
                load_font(EGA_CGMN,256,0,0,14);
            else
                load_font(EGA_CGDDOT,256,0,0,8);
        }
        /* Now see if we have a nasty font to load */
        font_addr = follow_ptr(save_addr+ALPHA_FONT_OFFSET);
        if (font_addr != 0)
        {
            /* See if it applies to us */
            font_offset = 11;
            do
            {
                mode_byte = sas_hw_at_no_check(font_addr + font_offset);
                if (mode_byte == video_mode)
                {
                    load_font(follow_ptr(font_addr+6),sas_w_at_no_check(font_addr+2),sas_w_at_no_check(font_addr+4), sas_hw_at_no_check(font_addr+1), sas_hw_at_no_check(font_addr));
                    recalc_text(sas_hw_at_no_check(font_addr));
                    if (sas_hw_at_no_check(font_addr+10) != 0xff)
                        sas_store_no_check(vd_rows_on_screen, (IU8)(sas_hw_at_no_check(font_addr+10)-1));
                    break;
                }
                font_offset++;
            } while (mode_byte != 0xff);
        }
        #if defined(JAPAN) || defined(KOREA)
        // change Vram addres to DosVramPtr from B8000.
        // Don't call SetVram().
        if (!is_us_mode())
        {
            #ifdef i386
            // set_up_screen_ptr() vga_mode.c
            set_screen_ptr( (byte *)DosvVramPtr );
            // low_set_mode() ega_vide.c
            video_pc_low_regen = DosvVramPtr;
            video_pc_high_regen = DosvVramPtr + DosvVramSize - 1;
            // vga_gc_misc() vga_prts.c
            gvi_pc_low_regen = DosvVramPtr;
            gvi_pc_high_regen = DosvVramPtr + DosvVramSize - 1;
            sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
            // recalc_screen_params() gvi.c
            set_screen_length( DosvVramSize );
                #ifdef JAPAN_DBG
            DbgPrint( "NTVDM:   ega_set_mode() sets VRAM %x, size=%d\n", DosvVramPtr, DosvVramSize );
                #endif
            #endif // i386
            // copy from calcScreenParams()
            set_screen_height_recal( 474 ); /* set scanline */
            recalc_text(19);                /* char Height == 19 */

        }
            #ifdef JAPAN_DBG
        DbgPrint( "NTVDM:   video_pc_low_regen %x, high %x, gvi_pc_low_regen %x, high %x\n", video_pc_low_regen, video_pc_high_regen, gvi_pc_low_regen, gvi_pc_high_regen );
            #endif
        #endif // JAPAN || KOREA
    }
    else
    {
        /* graphics mode. No font load, so do mode change ourselves */
        low_set_mode(video_mode);
        /* Set up default graphics font */
        sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
        if (video_mode == 16)
            sas_storew_no_check(EGA_FONT_INT*4,EGA_CGMN_OFF);
        else
        #ifdef VGG
            if (video_mode == 17 || video_mode == 18)
            sas_storew_no_check(EGA_FONT_INT*4,EGA_HIFONT_OFF);
        else
        #endif
            sas_storew_no_check(EGA_FONT_INT*4,EGA_CGDDOT_OFF);
        /* Now see if we have a nasty font to load */
        font_addr = follow_ptr(save_addr+GRAPH_FONT_OFFSET);
        if (font_addr != 0)
        {
            /* See if it applies to us */
            font_offset = 7;
            do
            {
                mode_byte = sas_hw_at_no_check(font_addr + font_offset);
                if (mode_byte == video_mode)
                {
                    sas_store_no_check(vd_rows_on_screen, (IU8)(sas_hw_at_no_check(font_addr)-1));
                    sas_store_no_check(ega_char_height, sas_hw_at_no_check(font_addr+1));
                    sas_move_bytes_forward(font_addr+3, 4*EGA_FONT_INT, 4);
                    break;
                }
                font_offset++;
            } while (mode_byte != 0xff);
        }
    }

    sas_store_no_check(vd_current_page, 0);
    sas_storew_no_check((sys_addr)VID_ADDR, 0);
    sas_storew_no_check((sys_addr)VID_INDEX, EGA_CRTC_INDEX);
/*
 * CGA bios fills this entry in 'vd_mode_table' with 'this is a bad mode'
 * value, so make one up for VGA - used in VGA bios disp_func
 */
    if (video_mode < 8)
        sas_store_no_check(vd_crt_mode, vd_mode_table[video_mode].mode_control_val);
    else if (video_mode < 0x10)
        sas_store_no_check(vd_crt_mode, 0x29);
    else
        sas_store_no_check(vd_crt_mode, 0x1e);
    if (video_mode == 6)
        sas_store_no_check(vd_crt_palette, 0x3f);
    else
        sas_store_no_check(vd_crt_palette, 0x30);

    for (pag=0; pag<8; pag++)
        sas_storew_no_check(VID_CURPOS + 2*pag, 0);

        #ifdef V7VGA
    set_host_pix_height(1);
    set_banking( 0, 0 );
        #endif

        #ifdef NTVDM
    /* Don't want to clear screen on startup if integrated with the console. */
    if (soft_reset)
        #endif /* NTVDM */
    {
        /* Clear screen */
        if (!get_EGA_no_clear())
        {
        #ifdef REAL_VGA
            sas_fillsw_16(video_pc_low_regen, vd_mode_table[video_mode].clear_char,
                          (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
        #else /* REAL_VGA */
            #ifdef JAPAN
            // mode73h support
                #ifdef i386
            // "video_pc_low_regen" is in DOS address space.
            // Direct access is prohibited.
            // We must use sas function to access DOS address space.
            if (!is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
            {
                unsigned long *p;
                unsigned long value = (unsigned long)vd_mode_table[0x03].clear_char;
                int  len = (video_pc_high_regen - video_pc_low_regen) / 4 + 1;
                    #ifdef JAPAN_DBG
                DbgPrint( "NTVDM: Set mode 73H\n" );
                    #endif
                p = (unsigned long *)video_pc_low_regen;
                while (len--)
                {
                    *p++ = value;
                }
            }
            else
            {
                // kksuzuka #6168 screen attributes
                extern word textAttr;

                sas_fillsw(video_pc_low_regen,
                           ((textAttr << 8) | (vd_mode_table[video_mode].clear_char & 0x00FF)),
                           (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
            }
                #else // !i386
            if (!is_us_mode())
            {
                register int len = DosvVramSize/4;
                register long *planes = (long *)get_screen_ptr(0);
                extern word textAttr;

                if (sas_hw_at_no_check(DosvModePtr) == 0x73)
                    sas_fillsw(DosvVramPtr, 0, DosvVramSize/2); // Apr. 18 1994 TakeS
                else
                    // kksuzuka #6168 screen attributes
                    sas_fillsw(DosvVramPtr, (textAttr << 8) | 0x20, DosvVramSize/2);

                while (len--)
                {
                    // kksuzuka #6168 screen attributes
                    *planes++ = (textAttr << 8) | 0x00000020; //extended attr clear
                    ((textAttr << 8) | (vd_mode_table[video_mode].clear_char & 0x00FF));
                }
            }

            sas_fillsw(video_pc_low_regen, vd_mode_table[video_mode].clear_char,
                       (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
                #endif // !i386
            #elif defined(KOREA)
                #ifdef i386
            // "video_pc_low_regen" is in DOS address space.
            // Direct access is prohibited.
            // We must use sas function to access DOS address space.

            // kksuzuka #6168 screen attributes
            extern word textAttr;

            sas_fillsw(video_pc_low_regen,
                       ((textAttr << 8) | (vd_mode_table[video_mode].clear_char & 0x00FF)),
                       (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
                #else // !i386
                    #ifdef LATER // Do we really need this?. Fix for stress failure.
            if (!is_us_mode())
            {
                register int len = DosvVramSize/4;
                register long *planes = (long *)get_screen_ptr(0);
                extern word textAttr;

                // kksuzuka #6168 screen attributes
                sas_fillsw(DosvVramPtr, (textAttr << 8) | 0x20, DosvVramSize/2);

                while (len--)
                {
                    // kksuzuka #6168 screen attributes
                    *planes++ = (textAttr << 8) | 0x00000020; //extended attr clear
                    ((textAttr << 8) | (vd_mode_table[video_mode].clear_char & 0x00FF));
                }
            }
                    #endif
            sas_fillsw(video_pc_low_regen, vd_mode_table[video_mode].clear_char,
                       (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
                #endif // !i386
            #else // !JAPAN & KOREA
            sas_fillsw(video_pc_low_regen, vd_mode_table[video_mode].clear_char,
                       (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
            #endif // !JAPAN
            #ifdef NTVDM
            /*
             * Need to call host clear screen on NT because text windows don't
             * resize and we need to clear portion not being written to.
             */
            host_clear_screen();
            host_mark_screen_refresh();
            #endif /* NTVDM */
        #endif /* REAL_VGA */
        }
    }
    inb(EGA_IPSTAT1_REG,&temp_word);
    outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);        /* re-enable video */
        #if defined(JAPAN) || defined(KOREA)
    if (BOPFromDispFlag)
    {
        // mode73h support  set video mode to VGA BIOS work area
        if (!is_us_mode())
        {
            sas_store_no_check(vd_video_mode, sas_hw_at_no_check(DosvModePtr));
        }
        else
        {
            sas_store_no_check(DosvModePtr, sas_hw_at_no_check(vd_video_mode));
        }
    }
        #endif // JAPAN || KOREA
        #if defined(NTVDM) && !defined(X86GFX)
    /*  tell mouse that video mode is changed so it can update its own
     *  EGA registers(for EGA.SYS interface). Only do this on RISC machine.
     *  On X86 machines, ntio.sys int10 handler redirects set mode call
     *  to mouse first which then goes to ega_video_io.
     */
    mouse_video_mode_changed(video_mode);
        #endif
        #ifndef PROD
    trace("end of video set mode", DUMP_NONE);
        #endif
}

/*
 * Set the cursor start and end positions. A bit strange, in that it assumes
 * the caller thinks the cursor is in an 8*8 character cell ... but this
 * should be a copy of the IBM EGA BIOS routine ... what more can we do?
 */
    #define CGA_CURSOR_OFF_MASK     0x60
    #define CGA_CURSOR_OFF_VALUE    0x20
    #define EGA_CURSOR_OFF_START    0x1e
    #define EGA_CURSOR_OFF_END      0x00

GLOBAL void ega_set_cursor_mode IFN0()
{
    /*
     * Set cursor mode
     * Parameters:
     *  CX - cursor value (CH - start scanline, CL - stop scanline)
     */
    int start,end,char_height;

    /* get cursor start and end scan lines */
    start = getCH();
    end = getCL();

    /* The following check is done to see if the application is trying
       to turn the cursor off using a technique that worked on the CGA.
       If the application wants to turn the cursor off, it is faked
       up using suitable EGA start and end values */
    if ((start & CGA_CURSOR_OFF_MASK) == CGA_CURSOR_OFF_VALUE)
    {
        sure_sub_note_trace0(CURSOR_VERBOSE,"ega curs - application req curs off??");
        start = EGA_CURSOR_OFF_START;
        end = EGA_CURSOR_OFF_END;
    }
    /* If the application has enabled cursor emulation, try to fake
       up the same cursor appearance on the EGA 14 scan line character
       matrix as you would get on the CGA 8 scan line matrix. */
    else if (!get_EGA_cursor_no_emulate())
    {
        sure_sub_note_trace2(CURSOR_VERBOSE,"emulate CGA cursor using EGA cursor, CGA vals; start=%d, end = %d",start,end);

        char_height = sas_hw_at_no_check(ega_char_height);
        #ifdef JAPAN
        // support Dosv cursor
        if (!is_us_mode())
        {
            char_height = 8;

            if (start > (char_height-1))
                start = char_height - 1;
            if (end > (char_height-1))
                end = char_height - 1;

            if (start <= end)
            {
                if (!( (end == char_height - 1) || (start == char_height - 2) )
                    && ( end > 3 ))
                {
                    if (start + 2 >= end)
                    {
                        start = start - end + char_height - 1;
                        end = char_height - 1;
                        if (char_height >= 14)
                        {
                            start--;
                            end--;
                        }
                    }
                    else if (start <= 2)
                    {
                        end = char_height - 1;
                    }
                    else
                    {
                        start = char_height / 2;
                        end = char_height - 1;
                    }
                }
            }
            else if (end != 0)
            {
                start = end;
                end = char_height - 1;
            }
        }
        else
        #endif // JAPAN

        #ifdef  VGG
            if (video_adapter == VGA)
        {
            UTINY saved_start;

            if (start > 0x10)
                start = 0x10;
            if (end > 0x10)
                end = 0x10;

            /*
             * No more guessing, take the exact values from a real VGA:
             */

            saved_start = (UTINY)start;

            if (char_height >= 16)
            {
                start = vga_cursor16_start[end][start];
            #ifdef  USE_CURSOR_END_TABLES
                end   = vga_cursor16_end[end][saved_start]];
            #else
                if (end && (end > 3 || saved_start > end))
                    if (end != 0xF && end >= saved_start
                        && end <= saved_start + 2)
                        end = 0xE;
                    else
                        end = 0xF;
            #endif
            }
            else
            {
                start = vga_cursor8_start[end][start];
            #ifdef  USE_CURSOR_END_TABLES
                end   = vga_cursor8_end[end][saved_start]];
            #else
                if (end && (end > 3 || saved_start > end)
                    && !(saved_start==6 && end==6))
                    end = 7;
            #endif
            }
        }
        else
        {
        #endif  /* VGG */
            /* EGA does not allow for character height & does this. */
            if (start > 4)start += 5;
            if (end > 4)end += 5;

            /* adjust end scan line because the last line is specified by
               the cursor end register MINUS 1 on the EGA ... */
            end++;

            /* on the EGA, cursors extending to the bottom of the character
               matrix are achieved by setting the end register to 0 ... */

            if (start != 0 && end >= char_height)
                end = 0;

            /* this last bit defies any explanation, but it is what the
               IBM BIOS does ... */
            if ((end - start) == 0x10)
                end++;
        #ifdef VGG
        }
        #endif
    }

    /* actually set the EGA registers */
    sure_sub_note_trace2(CURSOR_VERBOSE,"ega_cur mode start %d end %d", start,end);
    do_outb(EGA_CRTC_INDEX, R10_CURS_START, (IU8)start);
    do_outb(EGA_CRTC_INDEX, R11_CURS_END, (IU8)end);

    /*
     * Update BIOS data variables
     */

    sas_storew_no_check((sys_addr)VID_CURMOD, getCX());
    setAH(0);
}

/* This routine is an approximate conversion of the corresponding IBM BIOS routine.
 * I don't think the IBM version works either.
 */
static void ega_emul_set_palette IFN0()
{
    sys_addr save_table;
    half_word work_BL;
    byte temp;

    save_table = follow_ptr( follow_ptr(EGA_SAVEPTR)+PALETTE_OFFSET);
/* setup attribute chip - NB need to do an inb() to clear the address */
    inb(EGA_IPSTAT1_REG,&temp);
    work_BL = getBL();
    if (getBH() == 0)
    {
        sas_store_no_check(vd_crt_palette, (IU8)((sas_hw_at_no_check(vd_crt_palette) & 0xe0) | (work_BL & 0x1f)));
        work_BL = (work_BL & 7) | ((work_BL<<1) & 0x10);
        if (!alpha_num_mode())
        {
            /* set Palette 0 (the background) */
            outb(EGA_AC_INDEX_DATA,0);
            outb(EGA_AC_INDEX_DATA,work_BL);
            if (save_table)
                sas_store_no_check(save_table, work_BL);
        }
        /* set the overscan register (the border) */
        outb(EGA_AC_INDEX_DATA,17);
        outb(EGA_AC_INDEX_DATA,work_BL);
        if (save_table)
            sas_store_no_check(save_table+16, work_BL);

        /* Now set BL as if we came in with BH = 1 */
        work_BL = (sas_hw_at_no_check(vd_crt_palette) & 0x20)>>5;
    }

/* Now do BH = 1 stuff. */
    if (!alpha_num_mode())
    {
        sas_store_no_check(vd_crt_palette, (IU8)((sas_hw_at_no_check(vd_crt_palette) & 0xdf) | ((work_BL<<5) & 0x20)));
        work_BL = work_BL | (sas_hw_at_no_check(vd_crt_palette) & 0x10) | 2;
        outb(EGA_AC_INDEX_DATA,1);
        outb(EGA_AC_INDEX_DATA,work_BL);
        if (save_table)
            sas_store_no_check(save_table+16, work_BL);
        work_BL += 2;
        outb(EGA_AC_INDEX_DATA,2);
        outb(EGA_AC_INDEX_DATA,work_BL);
        if (save_table)
            sas_store_no_check(save_table+16, work_BL);
        work_BL += 2;
        outb(EGA_AC_INDEX_DATA,3);
        outb(EGA_AC_INDEX_DATA,work_BL);
        if (save_table)
            sas_store_no_check(save_table+16, work_BL);
    }
    outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
}

static void ega_set_palette IFN0()
{
    IU8 i;
    byte temp;
    sys_addr save_table, palette_table;
    half_word old_mask;

    save_table = follow_ptr( follow_ptr(EGA_SAVEPTR)+PALETTE_OFFSET);
/* setup attribute chip - NB need to do an inb() to clear the address */
    inb(EGA_IPSTAT1_REG,&temp);
    switch (getAL())
    {
    case 0:
        outb(EGA_AC_INDEX_DATA,getBL());
        outb(EGA_AC_INDEX_DATA,getBH());
        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
        if (save_table)
            sas_store_no_check(save_table + getBL(), getBH());
        break;
    case 1:
        outb(EGA_AC_INDEX_DATA,17);     /* the border colour register */
        outb(EGA_AC_INDEX_DATA,getBH());
        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
        if (save_table)
            sas_store_no_check(save_table + 16, getBH());
        break;
    case 2:
        palette_table = video_effective_addr(getES(),
                                             getDX());
        for (i=0;i<16;i++)
        {
            outb(EGA_AC_INDEX_DATA,i);
            outb(EGA_AC_INDEX_DATA,sas_hw_at_no_check(palette_table+i));
        }
        outb(EGA_AC_INDEX_DATA,17);
        outb(EGA_AC_INDEX_DATA,sas_hw_at_no_check(palette_table+16));
        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
        if (save_table)
            for (i=0;i<17;i++)
                sas_store_no_check(save_table + i, sas_hw_at_no_check(palette_table+i));
        break;
    case 3:
/*<REAL_VGA>*/
        /* Select blinking or intensity - bit3 of AR10 */
        /*inb(EGA_IPSTAT1_REG,&temp);*/
        outb(EGA_AC_INDEX_DATA,16); /* mode control index */
        inb(EGA_AC_SECRET,&temp);  /* Old value */
        outb(EGA_AC_INDEX_DATA,
             (IU8)((temp & 0xf7) | ((getBL() & 1)<<3)));
        inb(EGA_IPSTAT1_REG,&temp);
        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
/*<REAL_VGA>*/
        old_mask = bg_col_mask;
        if (getBL())
        {
            bg_col_mask = 0x70;
            assert0(FALSE,"Blinking not supported");
            sas_store_no_check(vd_crt_mode, 0x29);
        }
        else
        {
            bg_col_mask = 0xf0; /* Intensity bit set */
            sas_store_no_check(vd_crt_mode, 0x09);
        }

        if (bg_col_mask != old_mask)
            screen_refresh_required();

        break;
    default:
        #ifdef VGG
        if (video_adapter == VGA)
            vga_set_palette();      /* VGA has many more subfuncs */
        else
        {
            assert1(FALSE,"Bad set palette submode %#x",getAL());
            not_imp();
        }
        #else
        assert1(FALSE,"Bad set palette submode %#x",getAL());
        setAL(0);
        #endif
        break;
    }
}

GLOBAL void ega_char_gen IFN0()
{
    switch (getAL())
    {
    case 3:
        do_outb(EGA_SEQ_INDEX,3,getBL());
        break;
    case 0:
    case 0x10:
        #ifdef JAPAN
        // ntraid:mskkbug#3167: works2.5: character corrupted
        // 11/8/93 yasuho
        // generate single byte charset for DOS/V
        // #4247: DOSSHELL,WORKS: screen lines are not enough
        // 12/14/93 yasuho
        // In Japanese mode, we don't necessary load_font,
        // recalc_text and so on.
        if (!is_us_mode())
        {
            GenerateBitmap();
            break;
        }
        #endif // JAPAN
        load_font(video_effective_addr(getES(),getBP()),getCX(),getDX(),getBL(),getBH());
        if (getAL()==0x10)
            recalc_text(getBH());

        #if defined(NTVDM) && defined(X86GFX)
        if (getBH()==0x16)
            loadNativeBIOSfont( 25 );
        else if (getBH()==0x14)
            loadNativeBIOSfont( 28 );
        else
            loadNativeBIOSfont( 50 );
        #endif /* NTVDM && X86GFX */
        break;
    case 1:
    case 0x11:
        load_font(EGA_CGMN,256,0,getBL(),14);
        if (getAL()==0x11)
            recalc_text(14);

        #if defined(NTVDM) && defined(X86GFX)
        loadNativeBIOSfont( 28 );
        #endif  /* NTVDM & X86GFX */
        break;
    case 2:
    case 0x12:
        load_font(EGA_CGDDOT,256,0,getBL(),8);
        if (getAL()==0x12)
            recalc_text(8);

        #if defined(NTVDM) && defined(X86GFX)
        loadNativeBIOSfont( 50 );
        #endif  /* NTVDM & X86GFX */
        break;
        #ifdef VGG
    case 4:
    case 0x14:
        load_font(EGA_HIFONT,256,0,getBL(),16);
        if (getAL()==0x14)
            recalc_text(16);

            #if defined(NTVDM) && defined(X86GFX)
        loadNativeBIOSfont( 25 );
            #endif  /* NTVDM & X86GFX */
        break;
        #endif  /* VGG */
    case 0x20:
        sas_storew_no_check(BIOS_EXTEND_CHAR*4,getBP());
        sas_storew_no_check(BIOS_EXTEND_CHAR*4+2,getES());
        break;
    case 0x21:
        sas_storew_no_check(EGA_FONT_INT*4,getBP());
        sas_storew_no_check(EGA_FONT_INT*4+2,getES());
        set_graph_font(getCX());
        break;
    case 0x22:
        #if defined(NTVDM) && defined(X86GFX)
            #ifdef ARCX86
        if (UseEmulationROM)
        {
            sas_storew_no_check(EGA_FONT_INT*4,EGA_CGMN_OFF);
            sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
        }
        else
        {
            sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x14].off);
            sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x14].seg);
        }
            #else  /* ARCX86 */
        sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x14].off);
        sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x14].seg);
            #endif /* ARCX86 */
        #else
        sas_storew_no_check(EGA_FONT_INT*4,EGA_CGMN_OFF);
        sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
        #endif  /* NTVDM & X86GFX */
        set_graph_font(14);
        break;
    case 0x23:
        #if defined(NTVDM) && defined(X86GFX)
            #ifdef ARCX86
        if (UseEmulationROM)
        {
            sas_storew_no_check(EGA_FONT_INT*4,EGA_CGDDOT_OFF);
            sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
        }
        else
        {
            sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x8pt1].off);
            sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x8pt1].seg);
        }
            #else  /* ARCX86 */
        sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x8pt1].off);
        sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x8pt1].seg);
            #endif /* ARCX86 */
        #else
        sas_storew_no_check(EGA_FONT_INT*4,EGA_CGDDOT_OFF);
        sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
        #endif  /* NTVDM & X86GFX */
        set_graph_font(8);
        break;
        #ifdef VGG
    case 0x24:
            #if defined(NTVDM) && defined(X86GFX)
                #ifdef ARCX86
        if (UseEmulationROM)
        {
            sas_storew_no_check(EGA_FONT_INT*4,EGA_HIFONT_OFF);
            sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
        }
        else
        {
            sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x16].off);
            sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x16].seg);
        }
                #else  /* ARCX86 */
        sas_storew_no_check(EGA_FONT_INT*4,nativeFontAddresses[F8x16].off);
        sas_storew_no_check(EGA_FONT_INT*4+2,nativeFontAddresses[F8x16].seg);
                #endif /* ARCX86 */
            #else
        sas_storew_no_check(EGA_FONT_INT*4,EGA_HIFONT_OFF);
        sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
            #endif  /* NTVDM & X86GFX */
        set_graph_font(16);
        break;
        #endif
    case 0x30:
        setCX(sas_hw_at_no_check(ega_char_height));
        setDL(sas_hw_at_no_check(vd_rows_on_screen));
        switch (getBH())
        {
        case 0:
            setBP(sas_w_at_no_check(BIOS_EXTEND_CHAR*4));
            setES(sas_w_at_no_check(BIOS_EXTEND_CHAR*4+2));
            break;
        case 1:
            setBP(sas_w_at_no_check(EGA_FONT_INT*4));
            setES(sas_w_at_no_check(EGA_FONT_INT*4+2));
            break;

        #if defined(NTVDM) && defined(X86GFX)

/* ntdetect.com gets the font info from real card on NT boot. VDM reads it into
 * array 'nativeFontAddresses'. Return these fonts as Insignia ROM not loaded.
 */
            #ifdef ARCX86
        case 2:
            if (UseEmulationROM)
            {
                setBP(EGA_CGMN_OFF);
                setES(EGA_SEG);
            }
            else
            {
                setBP(nativeFontAddresses[F8x14].off);
                setES(nativeFontAddresses[F8x14].seg);
            }
            break;
        case 3:
            if (UseEmulationROM)
            {
                setBP(EGA_CGDDOT_OFF);
                setES(EGA_SEG);
            }
            else
            {
                setBP(nativeFontAddresses[F8x8pt1].off);
                setES(nativeFontAddresses[F8x8pt1].seg);
            }
            break;
        case 4:
            if (UseEmulationROM)
            {
                setBP(EGA_INT1F_OFF);
                setES(EGA_SEG);
            }
            else
            {
                setBP(nativeFontAddresses[F8x8pt2].off);
                setES(nativeFontAddresses[F8x8pt2].seg);
            }
            break;
        case 5:
            if (UseEmulationROM)
            {
                setBP(EGA_CGMN_FDG_OFF);
                setES(EGA_SEG);
            }
            else
            {
                setBP(nativeFontAddresses[F9x14].off);
                setES(nativeFontAddresses[F9x14].seg);
            }
            break;
        case 6:
            if (UseEmulationROM)
            {
                setBP(EGA_HIFONT_OFF);
                setES(EGA_SEG);
            }
            else
            {
                setBP(nativeFontAddresses[F8x16].off);
                setES(nativeFontAddresses[F8x16].seg);
            }
            break;
        case 7:
            if (UseEmulationROM)
            {
                setBP(EGA_HIFONT_OFF);
                setES(EGA_SEG);
            }
            else
            {
                setBP(nativeFontAddresses[F9x16].off);
                setES(nativeFontAddresses[F9x16].seg);
            }
            break;
            #else  /* ARCX86 */
        case 2:
            setBP(nativeFontAddresses[F8x14].off);
            setES(nativeFontAddresses[F8x14].seg);
            break;
        case 3:
            setBP(nativeFontAddresses[F8x8pt1].off);
            setES(nativeFontAddresses[F8x8pt1].seg);
            break;
        case 4:
            setBP(nativeFontAddresses[F8x8pt2].off);
            setES(nativeFontAddresses[F8x8pt2].seg);
            break;
        case 5:
            setBP(nativeFontAddresses[F9x14].off);
            setES(nativeFontAddresses[F9x14].seg);
            break;
        case 6:
            setBP(nativeFontAddresses[F8x16].off);
            setES(nativeFontAddresses[F8x16].seg);
            break;
        case 7:
            setBP(nativeFontAddresses[F9x16].off);
            setES(nativeFontAddresses[F9x16].seg);
            break;
            #endif /* ARCX86 */

        #else   /* NTVDM & X86GFX */

        case 2:
            setBP(EGA_CGMN_OFF);
            setES(EGA_SEG);
            break;
        case 3:
            setBP(EGA_CGDDOT_OFF);
            setES(EGA_SEG);
            break;
        case 4:
            setBP(EGA_INT1F_OFF);
            setES(EGA_SEG);
            break;
        case 5:
            setBP(EGA_CGMN_FDG_OFF);
            setES(EGA_SEG);
            break;

            #ifdef VGG
        case 6:
        case 7:
            setBP(EGA_HIFONT_OFF);
            setES(EGA_SEG);
            break;
            #endif  /* VGG */
        #endif  /* NTVDM & X86GFX */
        default:
            assert2(FALSE,"Illegal char_gen subfunction %#x %#x",getAL(),getBH());
        }
        break;
    default:
        assert1(FALSE,"Illegal char_gen %#x",getAL());
    }
}

static void ega_alt_sel IFN0()
{
    switch (getBL())
    {
    case 0x10:
        setBH( (UCHAR)(get_EGA_disp()) );
        setBL( (UCHAR)(get_EGA_mem()) );
        setCH( (UCHAR)(get_EGA_feature()) );
        setCL( (UCHAR)(get_EGA_switches()) );
        break;
    case 0x20:
        /* Was "enable Print Screen that can do variables lines on screen."
         * This PC/XT bug fix function is redundant on PC/AT's and
         * is removed by BCN3330 -- it has been broken since BCN101.
         */
        assert1(FALSE,"Illegal alt_sel %#x",getBL());
        setAL(0);       /* A function we don't support */
        break;
    default:
        #ifdef VGG
        if (video_adapter == VGA)
            vga_func_12();      /* Try extra VGA stuff */
        else
        #endif
        {
            setAL(0);   /* A function we don't support */
            assert1(FALSE,"Illegal alt_sel %#x",getBL());
        }
    }
}


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

/*
[7.1 INTERMODULE DATA DEFINITIONS]                              */
/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]                         */

void ega_video_init IFN0()
{
    EQUIPMENT_WORD equip_flag;

    /*
     * ESTABLISH EQUIPMENT WORD INITIAL VIDEO MODE FIELD.
     *
     * This field will already have been initialised by this stage
     * to 00(binary) from the corresponding field of the CMOS equipment
     * byte; in that context 00(binary) meant 'primary display has its
     * own BIOS'.
     *
     * However, 00(binary) is not meaningful as the initial mode field
     * and must be updated at this point to 10(binary) for 80X25 colour.
     */
    equip_flag.all = sas_w_at_no_check(EQUIP_FLAG);
    equip_flag.bits.video_mode = VIDEO_MODE_80X25_COLOUR;
    sas_storew_no_check(EQUIP_FLAG, equip_flag.all);

        #if !defined(NTVDM) || ( defined(NTVDM) && !defined(X86GFX) ) || defined(ARCX86)
            #ifdef ARCX86
    if (UseEmulationROM)
            #endif
    {
        /* Initialize the INTs */
        sas_storew_no_check(BIOS_EXTEND_CHAR*4, EGA_INT1F_OFF);
        sas_storew_no_check(BIOS_EXTEND_CHAR*4+2, EGA_SEG);
        sas_move_bytes_forward(BIOS_VIDEO_IO*4, 0x42*4, 4); /* save old INT 10 as INT 42 */
        sas_storew_no_check(BIOS_VIDEO_IO*4, EGA_ENTRY_OFF);
        sas_storew_no_check(BIOS_VIDEO_IO*4+2, EGA_SEG);

        /* Now set up the EGA BIOS variables */
        if (video_adapter == VGA)
            sas_storew_no_check(EGA_SAVEPTR,VGA_PARMS_OFFSET);
        else
            sas_storew_no_check(EGA_SAVEPTR,EGA_PARMS_OFFSET);
        sas_storew_no_check(EGA_SAVEPTR+2,EGA_SEG);
    }
        #endif  /* !NTVDM | (NTVDM & !X86GFX) | ARCX86 */
        #if defined(NTVDM) && defined(X86GFX)
    sas_store_no_check(ega_info,0x60); /* Clear on mode change, 256K, EGA active, emulate cursor */
        #else
            #ifdef V7VGA
    if (video_adapter == VGA)
        sas_store_no_check(ega_info, 0x70);   /* Clear on mode change, 256K, Extensions allowed, EGA active, emulate cursor */
    else
        sas_store_no_check(ega_info, 0x60);   /* Clear on mode change, 256K, EGA active, emulate cursor */
            #else   /* V7VGA  -- Macs don't have V7 */
    sas_store_no_check(ega_info, 0x60);   /* Clear on mode change, 256K, EGA active, emulate cursor */
            #endif /* V7VGA */

        #endif /* NTVDM & X86GFX */
        #if !(defined(NTVDM) && defined(X86GFX))
    /* Some VGA cards eg ET4000, store info here needed for sync.
     * Inherit that info from page 0 copy.
     */
    sas_store_no_check(ega_info3, 0xf9);  /* feature bits = 0xF, EGA installed, use 8*14 font */
        #endif


        #ifdef VGG
    set_VGA_flags(S400 | VGA_ACTIVE);
        #endif

/* Set the default mode */
    ega_set_mode();
}

void ega_video_io IFN0()
{


        #if defined(NTVDM) && !defined(X86GFX)
    if (stream_io_enabled && getAH()!= 0x0E &&  getAX() != 0x13FF)
        disable_stream_io();
        #endif


    /*
     * The type of operation is coded into the AH register.  Some PC code
     * calls AH functions that are for other even more advanced cards - so we
     * ignore these.
     */

        #ifdef V7VGA
            #define check_video_func(AH)    ((AH >= 0 && AH < EGA_FUNC_SIZE) || (AH == 0x6f && video_adapter == VGA))
        #else
            #define check_video_func(AH)    (AH >= 0 && AH < EGA_FUNC_SIZE)
        #endif

    if (getAH() != 0xff)
        assert1(check_video_func(getAH()),"Illegal EGA VIO:%#x",getAH());
    if (check_video_func(getAH()))
    {
        IDLE_video();   /* add video anti-idle indicator */
        #ifdef V7VGA
        if (getAH() == 0x6f)
            v7vga_func_6f();
        else
        #endif /* V7VGA */
            (*ega_video_func[getAH()])();
        setCF(0);
    }
    else
        setCF(1);
}

/***** Routines to handle the EGA graphics modes,called from video.c **********/
void ega_graphics_write_char IFN6(int, col, int, row, int, ch,
                                  int, colour, int, page, int, nchs)
{
    sys_addr char_addr;
    register int i;
    int screen_off;
    byte char_height;
    register int scan_length = sas_w_at_no_check(VID_COLS);

    char_height = sas_hw_at_no_check(ega_char_height);
    char_addr = follow_ptr(EGA_FONT_INT*4)+char_height*ch;
    screen_off = page*sas_w_at_no_check(VID_LEN)+row*scan_length*char_height+col;
        #ifdef V7VGA
    if (video_adapter == VGA)
        if (sas_hw_at_no_check(vd_video_mode) == 0x18)
            colour = v7_mode_64_munge[colour&3];
        #endif /* V7VGA */
    if (colour & 0x80)
        write_ch_xor(char_addr,screen_off,colour,nchs,scan_length);
    else
        write_ch_set(char_addr,screen_off,colour,nchs,scan_length);

        #ifndef REAL_VGA
    nchs--;

    if (nchs)
    {
        for (i=char_height;i>0;i--)
        {
            (*update_alg.mark_fill)( screen_off, screen_off + nchs );
            screen_off += scan_length;
        }
    }
    else
    {
        for (i=char_height;i>0;i--)
        {
            (*update_alg.mark_byte)(screen_off);
            screen_off += scan_length;
        }
    }
        #endif
}

void ega_write_dot IFN4(int, colour, int, page, int, pixcol, int, row)
{
    register int screen_off,pixmask,setmask,colourmask,temp;

    screen_off = page*sas_w_at_no_check(VID_LEN)+(row*sas_w_at_no_check(VID_COLS)&0xFFFF)+pixcol/8;
    pixmask = 0x80 >>  (pixcol&7);

        #ifndef REAL_VGA

    temp = pixmask << 8;
    pixmask |= temp;
    temp = pixmask << 16;
    pixmask |= temp;

            #ifdef V7VGA
    if (video_adapter == VGA)
        if (sas_hw_at_no_check(vd_video_mode) == 0x18)
            colour = v7_mode_64_munge[colour&3];
            #endif /* V7VGA */

    colourmask = sr_lookup[colour & 0xf];

    setmask = pixmask & colourmask;

    if (colour & 0x80)
    {
        /* XOR pixel */

        temp = *( (unsigned int *) EGA_planes + screen_off );
        *( (unsigned int *) EGA_planes + screen_off ) = temp ^ setmask;
    }
    else
    {
        /* set/clear pixel */

        temp = *( (unsigned int *) EGA_planes + screen_off );
        temp &= ~pixmask;
        *( (unsigned int *) EGA_planes + screen_off ) = ( temp | setmask );
    }

    /* Get the screen updated */

    (*update_alg.mark_byte)(screen_off);
        #else
    vga_card_w_dot(screen_off, pixmask, colour);
        #endif
}

void ega_sensible_graph_scroll_up IFN6(int, row,
                                       int, col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    register int col_incr = sas_w_at_no_check(VID_COLS);
    register int i,source,dest;
    byte char_height;
    boolean screen_updated;

    char_height = sas_hw_at_no_check(ega_char_height);
    dest = sas_w_at_no_check(VID_ADDR)+row*col_incr*char_height+col;
    rowsdiff *= char_height;
    lines *= char_height;
    source = dest+lines*col_incr;
        #ifdef REAL_VGA
    vga_card_scroll_up(source, dest, rowsdiff, colsdiff, lines, attr, col_incr);
        #else
    screen_updated = (col+colsdiff) <= col_incr;  /* Check for silly scroll */

    if (screen_updated)
        screen_updated = (*update_alg.scroll_up)(dest,colsdiff,rowsdiff,attr,lines,0);

    for (i=0;i<rowsdiff-lines;i++)
    {
        memcpy(&EGA_planes[dest<<2],&EGA_planes[source<<2],colsdiff<<2);

        if (!screen_updated)
            (*update_alg.mark_string)(dest, dest+colsdiff-1);
        source += col_incr;
        dest += col_incr;
    }

    attr = sr_lookup[attr & 0xf];

    while (lines--)
    {
        memset4( attr, (ULONG *)&EGA_planes[dest<<2], colsdiff );

        if (!screen_updated)
            (*update_alg.mark_fill)(dest, dest+colsdiff-1);

        dest += col_incr;
    }
        #endif
}

void ega_sensible_graph_scroll_down IFN6(int, row,
                                         int, col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    register int col_incr = sas_w_at_no_check(VID_COLS);
    register int i,source,dest;
    byte char_height;
    boolean screen_updated;

    char_height = sas_hw_at_no_check(ega_char_height);
    dest = sas_w_at_no_check(VID_ADDR)+row*col_incr*char_height+col;
    rowsdiff *= char_height;
    lines *= char_height;
        #ifdef REAL_VGA
    dest += rowsdiff*col_incr-1; /* Last byte in destination */
    source = dest-lines*col_incr;
    vga_card_scroll_down(source, dest, rowsdiff, colsdiff, lines, attr, col_incr);
        #else
    screen_updated = (col+colsdiff) <= col_incr;  /* Check for silly scroll */
    if (screen_updated)
        screen_updated = (*update_alg.scroll_down)(dest,colsdiff,rowsdiff,attr,lines,0);
    dest += (rowsdiff-1)*col_incr; /* First byte in last row of dest */
    source = dest-lines*col_incr;

    for (i=0;i<rowsdiff-lines;i++)
    {
        memcpy(&EGA_planes[dest<<2],&EGA_planes[source<<2],colsdiff<<2);

        if (!screen_updated)
            (*update_alg.mark_string)(dest, dest+colsdiff-1);
        source -= col_incr;
        dest -= col_incr;
    }

    attr = sr_lookup[attr & 0xf];

    while (lines--)
    {
        memset4( attr, (ULONG *)&EGA_planes[dest<<2], colsdiff );

        if (!screen_updated)
            (*update_alg.mark_fill)(dest, dest+colsdiff-1);

        dest -= col_incr;
    }
        #endif
}

/* This is called from vga_video.c as well. */
void search_font IFN2(char *, the_char,int, height)
{
    register int i;
    register host_addr scratch_addr;
    register sys_addr font_addr;

    font_addr = follow_ptr(4*EGA_FONT_INT);
    scratch_addr = sas_scratch_address(height);
    if(!scratch_addr) {
        //Couldn't allocate enough memory
        setAL(0);
        return;
    }
    for (i=0;i<256;i++)
    {
        sas_loads(font_addr, scratch_addr, height);
        if (memcmp(scratch_addr,the_char,height) == 0)
            break;
        font_addr += height;
    }
    if (i<256)
        setAL((UCHAR)i);
    else
        setAL(0); /* Didn't find a character */
}

void ega_read_attrib_char IFN3(int, col, int, row, int, page)
{
    byte the_char[256], char_height;
    int screen_off;
    int i, data;

    char_height = sas_hw_at_no_check(ega_char_height);
    screen_off = page*sas_w_at_no_check(VID_LEN)+row*sas_w_at_no_check(VID_COLS)*char_height+col;
    /*
     * Load up the screen character into the_char.
     * We are looking for non-zero pixels, so OR all the planes together
     */
        #ifndef REAL_VGA
    for (i=0;i<char_height;i++)
    {
        data = *( (unsigned int *) EGA_planes + screen_off );
        data = ( data >> 16 ) | data;
        the_char[i] = ( data >> 8 ) | data;
        screen_off += sas_w_at_no_check(VID_COLS);
    }
        #else
    vga_card_read_ch(screen_off, sas_w_at_no_check(VID_COLS), char_height, the_char);
        #endif
    /* Now search the font */
    search_font((char *)the_char,(int)char_height);
}
void ega_read_dot IFN3(int, page, int, col, int, row)
{
    int screen_off;
    int shift;
    unsigned int data;
    byte val;
    byte mask;
        #ifdef  REAL_VGA
    extern half_word vga_card_read_dot();
        #endif


    /*
     * The following fixes a bug in print screen from DOS shell.
     * There is a bug in DOS shell that results in -1 and -2 being
     * passed through for the row.  Ignoring these values stops
     * SoftPC falling over.
     */

    if (row & 0x8000)
        return;

    screen_off = page*sas_w_at_no_check(VID_LEN)+row*sas_w_at_no_check(VID_COLS)+(col/8);
    /*
     * The value to return is calculated as:
     * val = plane0 | plane1*2**1 | plane2*2**2 | plane3*2**3
     * The masked-out bit from each plane must therefore be
     * shifted right to bit 0 (note it may already be there)
     * and then shifted up again by the appropriate amount for
     * each plane.
     */

    mask = 0x80 >> (col & 7);
    shift = 7 - (col & 7);

        #ifndef REAL_VGA

    data = *((unsigned int *) EGA_planes + screen_off );

    val = ((data >> 24) & mask) >> shift;
    val |= (((data >> 16) & mask) >> shift) << 1;
    val |= (((data >> 8) & mask) >> shift) << 2;
    val |= ((data & mask) >> shift) << 3;

        #else
    val = vga_card_read_dot(screen_off, shift);
        #endif
    setAL(val);
}

/*
 * Routine to grovel around with the fancy EGA mode tables to find the register parameters.
 * This is also called by the mouse driver, because it needs to know where the default
 * EGA register table for the current mode is stored.
 */
sys_addr find_mode_table IFN2(int, mode, sys_addr *, save_addr)
{
    sys_addr params_addr;
/*  get address of the SAVEPTR table, and hence the video params table. */
    *save_addr = follow_ptr(EGA_SAVEPTR);
    params_addr = follow_ptr(*save_addr) + mode*EGA_PARMS_SIZE;
/*  If we are modes F or 10, adjust to pick up the 256K EGA parameters */

        #ifdef NTVDM
    /* only take real mode number */
    mode &= 0x7F;
        #endif
    if (mode == 0xF || mode == 0x10)
        params_addr += 2*EGA_PARMS_SIZE;
        #ifdef VGG
    if (video_adapter == VGA)
    {
            #ifdef V7VGA
        /* If mode is 0x60+, pick up parameters from 0x1d onwards */
        if (mode >= 0x60)
            params_addr -= 67*EGA_PARMS_SIZE;
        else
            if (mode >= 0x40)
            params_addr -= 25*EGA_PARMS_SIZE;
        else
            #endif /* V7VGA */


/*  If we are modes 0x11 - 0x13, pick up parameters from entry 0x1a onwards */
            if (mode == 0x11 || mode == 0x12 || mode == 0x13)
            params_addr += 9*EGA_PARMS_SIZE;
        else if (mode < 4 || mode == 7) /* Alphanumeric mode */
        {
            switch (get_VGA_lines())
            {
            case S350:    /* EGA-type 350 scanlines */
                params_addr += 19*EGA_PARMS_SIZE;
                break;
            case S400:    /* Real VGA text mode */
                switch (mode)
                {
                case 0:
                case 1:
                    params_addr += (0x17-mode)*EGA_PARMS_SIZE;
                    break;
                case 2:
                case 3:
                    params_addr += (0x18-mode)*EGA_PARMS_SIZE;
                    break;
                case 7:
                    params_addr += (0x19-mode)*EGA_PARMS_SIZE;
                }
            default:      /* 200 scanlines - OK as is. */
                break;
            }
        }
    }
    else
        #endif  /* VGG */
    {               /* EGA */
/*  If modes 0-3, activate enhancement if switches say so */
        if ((get_EGA_switches() & 1) && mode < 4)
            params_addr += 19*EGA_PARMS_SIZE;
    }

        #if defined(NTVDM) && defined(X86GFX)
    /*
    * Tim August 92, Microsoft.
    * Make text modes (0-3) use our mode parameters in KEYBOARD.SYS
    * Three entries in table: 40x25, 80x25 & 80x25 mono
    * Make that 4 - add font load mode B. We have to be defensive in
    * case of dubious values from cards or m/c. (Pro II/EISA, Olivetti MP)
    * Table order: 40x25, 80x25, mono, font
    */
    {
        extern word babyModeTable;
        extern UTINY tempbabymode[];

        if (babyModeTable == 0)    /* ntio not loaded - use temp table */
        {
            if (!soft_reset)       /* be absolutely sure about this */
            {
                /* magic location:good until 16 bit code is running */
                sas_stores(0x41000, tempbabymode, 2 * EGA_PARMS_SIZE);
                if (mode == 0xb)
                    params_addr = 0x41000 + EGA_PARMS_SIZE;
                else
                    params_addr = 0x41000;  /* if not mode 3 tough */
                return (params_addr);
            }
            #ifndef PROD
            else
                printf("NTVDM:video window parm table not loaded but system initialised\n");
            #endif
        }
        if (babyModeTable > 0)
        {
            if (get_VGA_lines() == S350 && mode < 4)
            {
                if (mode < 2)
                    params_addr = babyModeTable + 4*EGA_PARMS_SIZE;
                else
                    params_addr = babyModeTable + 5*EGA_PARMS_SIZE;
            }
            else
            {
                if (mode < 4)
                {
                    mode = mode/2;
                    params_addr = babyModeTable + mode*EGA_PARMS_SIZE;
                }
                else
                {
                    if (mode == 0xb)
                        params_addr = babyModeTable + 3 * EGA_PARMS_SIZE;
                    else if (mode == 7) /* skip first 2 table entries */
                        params_addr = babyModeTable + 2 * EGA_PARMS_SIZE;
                }
            }
        }
    }
        #endif  /* NTVDM & X86GFX */

    return (params_addr);
}

/*
 * Calculate how many scanlines are currently displayed, and return a code:
 * RS200: 200 scanlines
 * RS350: 350 scanlines
 * RS400: 400 scanlines
 * RS480: 480 scanlines
 *
 * Different numbers of scanlines are returned as the code corresonding
 * to the nearest kosher scanline number.
 */

int get_scanlines IFN0()
{
    int scanlines,res;

    scanlines = sas_hw_at_no_check(ega_char_height) * sas_hw_at_no_check(vd_rows_on_screen);

    if (scanlines <= 275)
        res = RS200;
    else if (scanlines <=375)
        res = RS350;
    else if (scanlines <= 440)
        res = RS400;
    else
        res = RS480;

    return (res);
}

#endif /* EGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\egwrtm12.c ===
#include "insignia.h"
#include "host_def.h"

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )

/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DOCUMENT 			: name and number

RELATED DOCS		: include all relevant references

DESIGNER			: J Maiden

REVISION HISTORY	:
First version		: J Maiden, SoftPC 2.0
Second version		: J Shanly, SoftPC 3.0

SUBMODULE NAME		: write mode 1 and 2

SOURCE FILE NAME	: ega_writem1.c

PURPOSE			: functions to write to EGA memory in write modes 1 & 2
		
		
SccsID = @(#)ega_wrtm12.c	1.20 3/9/94 Copyright Insignia Solutions Ltd.

[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : ega_cpu.pi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :	
			ega_mode1_chn_b_write();
			ega_mode1_chn_w_write();
			ega_mode1_chn_b_fill();
			ega_mode1_chn_w_fill();
			ega_mode1_chn_b_move();
			ega_mode1_chn_w_move();
			ega_mode2_chn_b_write();
			ega_mode2_chn_w_write();
			ega_mode2_chn_b_fill();
			ega_mode2_chn_w_fill();
			ega_mode2_chn_b_move();
			ega_mode2_chn_w_move();

	DATA 	     :	give type and name

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:
		
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)


-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS	  :	struct EGA_CPU

FILES ACCESSED    :	NONE

DEVICES ACCESSED  :	NONE

SIGNALS CAUGHT	  :	NONE

SIGNALS ISSUED	  :	NONE


[1.4.2 EXPORTED OBJECTS]

/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */


#ifdef EGG

#include	"xt.h"
#include	"debug.h"
#include	"sas.h"
#include	TypesH
#include	CpuH
#include	"gmi.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"cpu_vid.h"
#include	"gfx_upd.h"

/* [3.1.2 DECLARATIONS]                                                 */


/* [3.2 INTERMODULE EXPORTS]						*/


/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#ifdef PROD
#include "SOFTPC_EGA.seg"
#else
#include "SOFTPC_EGA_WRITE.seg"
#endif
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/


/* [5.1.3 PROCEDURE() DECLARATIONS]					*/


/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

/*
[7.1 INTERMODULE DATA DEFINITIONS]				*/

#ifdef A_VID
IMPORT VOID	_ch2_mode1_chn_byte_write_glue();
IMPORT VOID	_ch2_mode1_chn_word_write_glue();
IMPORT VOID	_ch2_mode1_chn_byte_fill_glue();
IMPORT VOID	_ch2_mode1_chn_word_fill_glue();
IMPORT VOID	_ch2_mode1_chn_byte_move_glue();
IMPORT VOID	_ch2_mode1_chn_word_move_glue();

WRT_POINTERS mode1_handlers =
{
	_ch2_mode1_chn_byte_write_glue,
	_ch2_mode1_chn_word_write_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_mode1_chn_byte_fill_glue,
	_ch2_mode1_chn_word_fill_glue,
	_ch2_mode1_chn_byte_move_glue,
	_ch2_mode1_chn_byte_move_glue,
	_ch2_mode1_chn_word_move_glue,
	_ch2_mode1_chn_word_move_glue

#endif	/* NO_STRING_OPERATIONS */
};

IMPORT VOID	_ch2_mode2_chn_byte_write_glue();
IMPORT VOID	_ch2_mode2_chn_word_write_glue();
IMPORT VOID	_ch2_mode2_chn_byte_fill_glue();
IMPORT VOID	_ch2_mode2_chn_word_fill_glue();
IMPORT VOID	_ch2_mode2_chn_byte_move_glue();
IMPORT VOID	_ch2_mode2_chn_word_move_glue();

WRT_POINTERS mode2_handlers =
{
	_ch2_mode2_chn_byte_write_glue,
	_ch2_mode2_chn_word_write_glue

#ifndef	NO_STRING_OPERATIONS
	,
	_ch2_mode2_chn_byte_fill_glue,
	_ch2_mode2_chn_word_fill_glue,
	_ch2_mode2_chn_byte_move_glue,
	_ch2_mode2_chn_byte_move_glue,
	_ch2_mode2_chn_word_move_glue,
	_ch2_mode2_chn_word_move_glue

#endif	/* NO_STRING_OPERATIONS */
};
#else
VOID	ega_mode1_chn_b_write(ULONG, ULONG);
VOID	ega_mode1_chn_w_write(ULONG, ULONG);
VOID	ega_mode1_chn_b_fill(ULONG, ULONG, ULONG);
VOID	ega_mode1_chn_w_fill(ULONG, ULONG, ULONG);
VOID	ega_mode1_chn_b_move(ULONG, ULONG, ULONG, ULONG);
VOID	ega_mode1_chn_w_move(ULONG, ULONG, ULONG, ULONG);

VOID	ega_mode2_chn_b_write(ULONG, ULONG);
VOID	ega_mode2_chn_w_write(ULONG, ULONG);
VOID	ega_mode2_chn_b_fill(ULONG, ULONG, ULONG);
VOID	ega_mode2_chn_w_fill(ULONG, ULONG, ULONG);
VOID	ega_mode2_chn_b_move IPT4(ULONG, ead, ULONG, eas,
				 ULONG, count, ULONG, src_flag);
VOID	ega_mode2_chn_w_move IPT4(ULONG, ead, ULONG, eas,
				 ULONG, count, ULONG, src_flag);

WRT_POINTERS mode1_handlers =
{
      ega_mode1_chn_b_write,
      ega_mode1_chn_w_write

#ifndef	NO_STRING_OPERATIONS
	  ,
      ega_mode1_chn_b_fill,
      ega_mode1_chn_w_fill,
      ega_mode1_chn_b_move,
      ega_mode1_chn_b_move,
      ega_mode1_chn_w_move,
      ega_mode1_chn_w_move,

#endif	/* NO_STRING_OPERATIONS */

};

WRT_POINTERS mode2_handlers =
{
      ega_mode2_chn_b_write,
      ega_mode2_chn_w_write

#ifndef	NO_STRING_OPERATIONS
	  ,
      ega_mode2_chn_b_fill,
      ega_mode2_chn_w_fill,
      ega_mode2_chn_b_move,
      ega_mode2_chn_b_move,
      ega_mode2_chn_w_move,
      ega_mode2_chn_w_move,

#endif	/* NO_STRING_OPERATIONS */

};
#endif /* A_VID */


GLOBAL VOID
copy_alternate_bytes IFN3(byte *, start, byte *, end, byte *, source)
{
#ifndef NEC_98
	while (start <= end)
	{
		*start = *source;
		start += 4;       /* advance by longs, writing bytes */
		source += 4;
	}
#endif  //NEC_98
}

GLOBAL VOID
fill_alternate_bytes IFN3(byte *, start, byte *, end, byte, value )
{
#ifndef NEC_98
	while( start <= end )
	{
		*start = value;
		start += 4;	/* advance by longs, writing bytes */
	}
#endif  //NEC_98
}

#ifdef  BIGEND
#define first_half(wd)      ((wd & 0xff00) >> 8)
#define sec_half(wd)        (wd & 0xff)
#else
#define first_half(wd)      (wd & 0xff)
#define sec_half(wd)        ((wd & 0xff00) >> 8)
#endif

GLOBAL VOID
fill_both_bytes IFN3(USHORT, data, USHORT *, dest, ULONG, len )
{
#ifndef NEC_98
	USHORT swapped;

#ifdef BIGEND
	swapped = ((data & 0xff00) >> 8) | ((data & 0xff) << 8);
#endif

	if( (ULONG) dest & 1 )
	{
		*((UTINY *) dest) = first_half(data);

		dest = (USHORT *) ((ULONG) dest + 1);
		len--;

		while( len-- )
		{
			*dest = data;
			dest += 2;
		}

		*((UTINY *) dest) = sec_half(data);
	}
	else
	{
		while( len-- )
		{
#ifdef BIGEND
			*dest = swapped;
#else
			*dest = data;
#endif
			dest += 2;
		}
	}
#endif  //NEC_98
}


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_EGA_CHN.seg"
#endif

VOID
ega_mode1_chn_b_write IFN2(ULONG, value, ULONG, offset )
{
#ifndef NEC_98
	ULONG lsb;

	UNUSED(value);
	
	note_entrance0("ega_mode1_chn_b_write");

	lsb = offset & 1;
	offset = (offset >> 1) << 2;

	if( lsb )	/* odd address, in plane 1 or 3 */
	{
		if( getVideoplane_enable() & 2 )
			EGA_plane01[offset + 1] = get_latch1;

		if( getVideoplane_enable() & 8 )
			EGA_plane23[offset + 1] = get_latch3;
	}
	else		/* even address, in plane 0 or 2 */
	{
		if( getVideoplane_enable() & 1 )
			EGA_plane01[offset] = get_latch0;

		if( getVideoplane_enable() & 4 )
			EGA_plane23[offset] = get_latch2;
	}

	update_alg.mark_byte( offset );
#endif  //NEC_98
}

VOID
ega_mode1_chn_w_write IFN2(ULONG, value, ULONG, offset )
{
#ifndef NEC_98
	ULONG lsb;

	UNUSED(value);

	note_entrance0("ega_mode1_chn_w_write");

	lsb = offset & 1;
	offset = (offset >> 1) << 2;

	if( lsb )	/* odd address, low byte in planes 1 and 3 */
	{
		if( getVideoplane_enable() & 2 )
			EGA_plane01[offset + 1] = get_latch1;

		if( getVideoplane_enable() & 1 )
			EGA_plane01[offset + 4] = get_latch0;

		if( getVideoplane_enable() & 8 )
			EGA_plane23[offset + 1] = get_latch3;

		if( getVideoplane_enable() & 4 )
			EGA_plane23[offset + 4] = get_latch2;
	}
	else		/* even address, low byte in planes 0 and 2 */
	{
		if( getVideoplane_enable() & 1 )
			EGA_plane01[offset] = get_latch0;

		if( getVideoplane_enable() & 2 )
			EGA_plane01[offset + 1] = get_latch1;

		if( getVideoplane_enable() & 4 )
			EGA_plane23[offset] = get_latch2;

		if( getVideoplane_enable() & 8 )
			EGA_plane23[offset + 1] = get_latch3;
	}

	update_alg.mark_word( offset );
#endif  //NEC_98
}

/* used by both byte and word mode1 fill */

LOCAL VOID
ega_mode1_chn_fill IFN2(ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	ULONG low_offset;			/* distance into regen buffer of start of write */
	ULONG high_offset;		/* distance into regen buffer of end of write */
	ULONG length;			/* length of fill in bytes */
	ULONG lsb;

	note_entrance0("ega_mode1_chn_fill");

	/*
	 *	Complicated by possibility that only one of a chained pair of
	 *	planes is write enabled, needing alternate bytes to be written.
	 */

	high_offset = offset + count - 1;
	lsb = high_offset & 1;
	high_offset = (high_offset >> 1) << 2;
	high_offset |= lsb;

	low_offset = offset;
	length = count;

	switch( getVideoplane_enable() & 3 )
	{
		case 1:	/* just plane 0, ie even addresses to be written */
			if( offset & 1 )
				low_offset++;

			low_offset = (low_offset >> 1) << 2;
			fill_alternate_bytes( &EGA_plane01[low_offset],
							&EGA_plane01[high_offset], get_latch0 );
			break;

		case 2:	/* just plane 1, ie odd addresses to be written */
			if(( offset & 1 ) == 0 )
				low_offset++;

			low_offset = (low_offset >> 1) << 2;
			fill_alternate_bytes( &EGA_plane01[low_offset],
							&EGA_plane01[high_offset], get_latch1 );
			break;

		case 3:	/* sensible case is to have both chained planes write enabled */
			lsb = low_offset & 1;
			low_offset = (low_offset >> 1) << 2;

			if( lsb )
			{
				EGA_plane01[low_offset + 1] = get_latch1;
				low_offset += 4;
				length--;
			}

			if( length & 1 )
			{
				length -= 1;
				EGA_plane01[low_offset + (length << 1)] = get_latch0;
			}

			fill_both_bytes( get_latch1 | get_latch0 << 8,
							(USHORT *)&EGA_plane01[low_offset], length >> 1 );
			break;
	}	/* end of switch on plane01 enabled */

	low_offset = offset;
	length = count;

	switch( getVideoplane_enable() & 0xc )	/* isolate 2 bits for planes2 and 3 */
	{
		case 4:	/* just plane 2, ie even addresses to be written */
			if( low_offset & 1 )
				low_offset++;

			low_offset = (low_offset >> 1) << 2;
			fill_alternate_bytes( &EGA_plane23[low_offset],
							&EGA_plane23[high_offset], get_latch2 );
			break;

		case 8:	/* just plane 3, ie odd addresses to be written */
			if(( low_offset & 1 ) == 0 )
				low_offset++;

			low_offset = (low_offset >> 1) << 2;
			fill_alternate_bytes( &EGA_plane23[low_offset],
							&EGA_plane23[high_offset], get_latch3 );
			break;

		case 12:	/* sensible case is to have both chained planes write enabled */
			lsb = low_offset & 1;
			low_offset = (low_offset >> 1) << 2;

			if( lsb )
			{
				EGA_plane23[low_offset + 1] = get_latch1;
				low_offset += 4;
				length--;
			}

			if( length & 1 )
			{
				length -= 1;
				EGA_plane23[low_offset + (length << 1)] = get_latch0;
			}

			fill_both_bytes( get_latch1 | get_latch0 << 8,
							(USHORT *)&EGA_plane23[low_offset], length >> 1 );
			break;
	}	/* end of switch on plane23 enabled */
#endif  //NEC_98
}

VOID
ega_mode1_chn_b_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
  UNUSED(value);

  note_entrance0("ega_mode1_chn_b_fill");

  ega_mode1_chn_fill( offset, count );
  update_alg.mark_fill( offset, offset + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode1_chn_w_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	UNUSED(value);
	
	note_entrance0("ega_mode1_chn_w_fill");

	ega_mode1_chn_fill( offset, count );
	update_alg.mark_fill( offset, offset + count - 1 );
#endif  //NEC_98
}

LOCAL VOID
ega_mode1_chn_move_vid_src IFN5(ULONG, ead, ULONG, eas, ULONG, count,
	UTINY	*, EGA_plane, ULONG, plane )
{
#ifndef NEC_98
	ULONG end, lsbd, lsbs, dst, src;

	lsbs = eas & 1;
	eas = (eas >> 1) << 2;	
	eas |= lsbs;

	end = ead + count - 1;
	lsbd = end & 1;
	end = (end >> 1) << 2;	
	end |= lsbd;

	lsbd = ead & 1;
	ead = (ead >> 1) << 2;	
	ead |= lsbd;

	if( lsbd != ( plane & 1 ))
	{
		dst = lsbd ? ead + 3 : ead + 1;
		src = lsbs ? eas + 3 : eas + 1;
	}
	else
	{
		dst = ead;
		src = eas;
	}

	copy_alternate_bytes( &EGA_plane[dst], &EGA_plane[end], &EGA_plane[src] );
#endif  //NEC_98
}

GLOBAL VOID
ega_mode1_chn_b_move IFN4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag )
{
#ifndef NEC_98
	note_entrance0("ega_mode1_chn_b_move");

	if( src_flag )
	{
		if( getDF() )
		{
			eas -= count - 1;
			ead -= count - 1;
		}

		if( getVideoplane_enable() & 1 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane01, 0 );

		if( getVideoplane_enable() & 2 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane01, 1 );

		if( getVideoplane_enable() & 4 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane23, 2 );

		if( getVideoplane_enable() & 8 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane23, 3 );
	}
	else	/* source is not in ega memory, it becomes a fill */
	{
		if( getDF() )
			ead -= count - 1;

		ega_mode1_chn_fill( ead, count );
	}

	update_alg.mark_string( ead, ead + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode1_chn_w_move IFN4(ULONG, ead, ULONG, eas, ULONG, count, ULONG, src_flag)
{
#ifndef NEC_98
	note_entrance0("ega_mode1_chn_w_move");

	count <<= 1;

	if( src_flag )
	{
		if( getDF() )
		{
			eas -= count - 2;
			ead -= count - 2;
		}

		if( getVideoplane_enable() & 1 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane01, 0 );

		if( getVideoplane_enable() & 2 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane01, 1 );

		if( getVideoplane_enable() & 4 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane23, 2 );

		if( getVideoplane_enable() & 8 )
			ega_mode1_chn_move_vid_src( ead, eas, count, EGA_plane23, 3 );
	}
	else	/* source is not in ega memory, it becomes a fill */
	{
		if( getDF() )
			ead -= count - 2;

		ega_mode1_chn_fill( ead, count );
	}

	update_alg.mark_string( ead, ead + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode2_chn_b_write IFN2(ULONG, value, ULONG, offset )
{
#ifndef NEC_98
	ULONG	value1;
	ULONG lsb;

	note_entrance0("ega_mode2_chn_b_write");

	lsb = offset & 1;
	offset = (offset >> 1) << 2;

	if( EGA_CPU.fun_or_protection )
	{
		if( lsb )	/* odd address, applies to planes 1 and 3 */
		{
			if( getVideoplane_enable() & 2 )
			{
				value1 = value & 2 ? 0xff : 0;
				EGA_plane01[offset + 1] = (byte) do_logicals( value1, get_latch1 );
			}

			if( getVideoplane_enable() & 8 )
			{
				value1 = value & 8 ? 0xff : 0;
				EGA_plane23[offset + 1] = (byte) do_logicals( value1, get_latch3 );
			}
		}
		else		/* even address, applies to planes 0 and 2 */
		{
			if( getVideoplane_enable() & 1 )
			{
				value1 = value & 1 ? 0xff : 0;
				EGA_plane01[offset] = (byte) do_logicals( value1, get_latch0 );
			}

			if( getVideoplane_enable() & 4 )
			{
				value1 = value & 4 ? 0xff : 0;
				EGA_plane23[offset] = (byte) do_logicals( value1, get_latch2 );
			}
		}
	}
	else	/* no difficult function or protection stuff */
	{
		if( lsb )	/* odd address, applies to planes 1 and 3 */
		{
			if( getVideoplane_enable() & 2 )
				EGA_plane01[offset + 1] = value & 2 ? 0xff : 0;

			if( getVideoplane_enable() & 8 )
				EGA_plane23[offset + 1] = value & 8 ? 0xff : 0;
		}
		else		/* even address, applies to planes 0 and 2 */
		{
			if( getVideoplane_enable() & 1 )
				EGA_plane01[offset] = value & 1 ? 0xff : 0;

			if( getVideoplane_enable() & 8 )
				EGA_plane23[offset] = value & 4 ? 0xff : 0;
		}
	}

	update_alg.mark_byte( offset );
#endif  //NEC_98
}

VOID
ega_mode2_chn_w_write IFN2(ULONG, value, ULONG, offset )
{
#ifndef NEC_98
	ULONG value2;
	ULONG lsb;
	ULONG low, high;

	low = value & 0xff;
	high = value >> 8;

	note_entrance0("ega_mode2_chn_w_write");

	lsb = offset & 1;
	offset = (offset >> 1) << 2;

	if( EGA_CPU.fun_or_protection )
	{
		if( lsb )	/* odd address, low byte in planes 1 and 3 */
		{
			if( getVideoplane_enable() & 2 )
			{
				value2 = low & 2 ? 0xff : 0;
				EGA_plane01[offset + 1] = (byte) do_logicals( value2, get_latch1 );
			}

			if( getVideoplane_enable() & 1 )
			{
				value2 = high & 1 ? 0xff : 0;
				EGA_plane01[offset + 4] = (byte) do_logicals( value2, get_latch0 );
			}

			if( getVideoplane_enable() & 8 )
			{
				value2 = low & 8 ? 0xff : 0;
				EGA_plane23[offset + 1] = (byte) do_logicals( value2, get_latch3 );
			}

			if( getVideoplane_enable() & 4 )
			{
				value2 = high & 4 ? 0xff : 0;
				EGA_plane23[offset + 4] = (byte) do_logicals( value2, get_latch2 );
			}
		}
		else		/* even address, low byte in planes 0 and 2 */
		{
			if( getVideoplane_enable() & 1 )
			{
				value2 = low & 1 ? 0xff : 0;
				EGA_plane01[offset] = (byte) do_logicals( value2, get_latch0 );
			}

			if( getVideoplane_enable() & 2 )
			{
				value2 = high & 2 ? 0xff : 0;
				EGA_plane01[offset + 1] = (byte) do_logicals( value2, get_latch1 );
			}

			if( getVideoplane_enable() & 4 )
			{
				value2 = low & 4 ? 0xff : 0;
				EGA_plane23[offset] = (byte) do_logicals( value2, get_latch2 );
			}

			if( getVideoplane_enable() & 8 )
			{
				value2 = high & 8 ? 0xff : 0;
				EGA_plane23[offset + 1] = (byte) do_logicals( value2, get_latch3 );
			}
		}
	}
	else	/* easy no function or bit prot case */
	{
		if( lsb )	/* odd address, low byte in planes 1 and 3 */
		{
			if( getVideoplane_enable() & 2 )
				EGA_plane01[offset + 1] = low & 2 ? 0xff : 0;

			if( getVideoplane_enable() & 1 )
				EGA_plane01[offset + 4] = high & 1 ? 0xff : 0;

			if( getVideoplane_enable() & 8 )
				EGA_plane23[offset + 1] = low & 8 ? 0xff : 0;

			if( getVideoplane_enable() & 4 )
				EGA_plane23[offset + 4] = high & 4 ? 0xff : 0;
		}
		else		/* even address, low byte in planes 0 and 2 */
		{
			if( getVideoplane_enable() & 1 )
				EGA_plane01[offset] = low & 1 ? 0xff : 0;

			if( getVideoplane_enable() & 2 )
				EGA_plane01[offset + 1] = high & 2 ? 0xff : 0;

			if( getVideoplane_enable() & 4 )
				EGA_plane23[offset] = low & 4 ? 0xff : 0;

			if( getVideoplane_enable() & 8 )
				EGA_plane23[offset + 1] = high & 8 ? 0xff : 0;
		}
	}

	update_alg.mark_word( offset );
#endif  //NEC_98
}

VOID
ega_mode2_chn_b_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	ULONG low_offset;		/* distance into regen buffer of write start and end */
	ULONG high_offset;	/* distance into regen buffer of write start and end */
	ULONG new_value;

	note_entrance0("ega_mode2_chn_b_fill");

	/*
	 *	Complicated by possibility that only one of a chained pair of
	 *	planes is write enabled, needing alternate bytes to be written.
	 */

	/* starting on odd address makes it difficult, go to next one */

	if(( (ULONG) offset & 1 ) && count )
	{
		ega_mode2_chn_b_write(value, offset++ );
		count--;
	}

	/* ending on even address makes it difficult, retreat to previous one */

	if(( (ULONG)( offset + count - 1 ) & 1 ) == 0 && count )
	{
		ega_mode2_chn_b_write(value, offset + count - 1 );
		count--;
	}

	low_offset = (offset >> 1) << 2;				/* start of write */
	high_offset = ((offset + count - 1) >> 1) << 2;		/* end of write */

	switch( getVideoplane_enable() & 3 )
	{
		case 1:	/* just plane 0, ie even addresses to be written */
			value = value & 1 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value = do_logicals( value, get_latch0 );

			fill_alternate_bytes( &EGA_plane01[low_offset],
									&EGA_plane01[high_offset], (byte) value );
			break;

		case 2:	/* just plane 1, ie odd addresses to be written */
			value = value & 2 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value = do_logicals( value, get_latch1 );

			fill_alternate_bytes( &EGA_plane01[low_offset + 1],
									&EGA_plane01[high_offset], (byte) value );
			break;

		case 3:	/* sensible case is to have both chained planes write enabled */
			new_value = ( value & 1 ? 0xff : 0) | (value & 2 ? 0xff00: 0);

			if( EGA_CPU.fun_or_protection )
				new_value = do_logicals( new_value, get_latch01);

			fill_both_bytes( (IU16)new_value, (USHORT *)&EGA_plane01[low_offset], count >> 1 );
			break;

	}	/* end of switch on plane01 enabled */

	switch( getVideoplane_enable() & 0xc )	/* isolate 2 bits for planes2 and 3 */
	{
		case 4:	/* just plane 2, ie even addresses to be written */
			value = value & 4 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value = do_logicals( value, get_latch2 );

			fill_alternate_bytes( &EGA_plane23[low_offset],
								&EGA_plane23[high_offset],  (byte) value );
			break;

		case 8:	/* just plane 3, ie odd addresses to be written */
			value = value & 8 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value = do_logicals( value, get_latch3 );

			fill_alternate_bytes( &EGA_plane23[low_offset + 1],
								&EGA_plane23[high_offset], (byte) value );
			break;

		case 12:	/* sensible case is to have both chained planes write enabled */
			new_value = ( value & 4 ? 0xff : 0) | (value & 8 ? 0xff00: 0);

			if( EGA_CPU.fun_or_protection )
				new_value = do_logicals( new_value, get_latch23);

			fill_both_bytes( (IU16) new_value, (USHORT *)&EGA_plane23[low_offset], count >> 1 );
			break;
	}	/* end of switch on plane23 enabled */

	update_alg.mark_fill( offset, offset + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode2_chn_w_fill IFN3(ULONG, value, ULONG, offset, ULONG, count )
{
#ifndef NEC_98
	ULONG	low_offset;		/* distance into regen buffer of write start and end */
	ULONG	high_offset;	/* distance into regen buffer of write start and end */
	ULONG	value1;

	note_entrance0("ega_mode2_chn_w_fill");

	/*
	 *	Complicated by possibility that only one of a chained pair of
	 *	planes is write enabled, needing alternate bytes to be written.
	 */

	/* starting on odd address makes it difficult, go to next one */

	if(( (ULONG) offset & 1 ) && count )
	{
		ega_mode2_chn_b_write( value, offset++);
		count--;

		if( count )
		{
			ega_mode2_chn_b_write( value >> 8, offset + count - 1 );
			count--;
		}

		value = ( value << 8 ) | ( value >> 8 );
	}

	low_offset = (offset >> 1) << 2;				/* start of write */
	high_offset = ((offset + count - 1) >> 1) << 2;		/* end of write */

	switch( getVideoplane_enable() & 3 )
	{
		case 1:	/* just plane 0, ie even addresses to be written */
			value1 = value & 1 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch0 );

			fill_alternate_bytes( &EGA_plane01[low_offset],
									&EGA_plane01[high_offset], (byte) value1 );
			break;

		case 2:	/* just plane 1, ie odd addresses to be written */
			value1 = ( value >> 8 ) & 2 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch1 );

			fill_alternate_bytes( &EGA_plane01[low_offset + 1],
									&EGA_plane01[high_offset], (byte) value1 );
			break;

		case 3:	/* sensible case is to have both chained planes write enabled */
			/* get a word pattern for filling */
			value1 = ( value & 1 ? 0xff : 0 ) | (( value >> 8 ) & 2 ? 0xff00: 0 );

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch01 );

			fill_both_bytes( (IU16) value1, (USHORT *)&EGA_plane01[low_offset], count >> 1 );
			break;
	}	/* end of switch on plane01 enabled */

	switch( getVideoplane_enable() & 0xc )	/* isolate 2 bits for planes 2 and 3 */
	{
		case 4:	/* just plane 2, ie even addresses to be written */
			value1 = value & 4 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch2 );

			fill_alternate_bytes( &EGA_plane23[low_offset],
									&EGA_plane23[high_offset], (byte) value1 );
			break;

		case 8:	/* just plane 3, ie odd addresses to be written */
			value1 = ( value >> 8 ) & 8 ? 0xff : 0;

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch3 );

			fill_alternate_bytes( &EGA_plane23[low_offset + 1],
									&EGA_plane23[high_offset], (byte) value1 );
			break;

		case 12:	/* sensible case is to have both chained planes write enabled */
			/* get a word pattern for filling */
			value1 = ( value & 4 ? 0xff : 0 ) | (( value >> 8 ) & 8 ? 0xff00: 0 );

			if( EGA_CPU.fun_or_protection )
				value1 = do_logicals( value1, get_latch23);

			fill_both_bytes( (IU16) value1, (USHORT *)&EGA_plane23[low_offset], count >> 1 );
			break;
	}	/* end of switch on plane23 enabled */

	/* the 3rd parameter is needed by GORE. */
	update_alg.mark_wfill( offset, offset + count - 1, 0 );
#endif  //NEC_98
}

LOCAL VOID
ega_mode2_chn_move_guts IFN8(UTINY *, eas, UTINY *, ead, LONG, count,
	UTINY *, EGA_plane, ULONG, scratch, ULONG, plane, ULONG, w,
	ULONG, src_flag )
{
#ifndef NEC_98
	ULONG src, dst;
	UTINY *source;
	USHORT value;
	ULONG lsb;

	src = (ULONG) eas;

	dst = (ULONG) ead;

	/*
	 *	even planes cannot start with odd addresses
	 *	odd planes cannot start with even addresses
	 */

	if(( dst & 1 ) != ( plane & 1 ))	
	{
#ifdef BACK_M
		src--;
		scratch--;
#else
		src++;
		scratch++;
#endif
		dst++;
		count--;
	}

	lsb = dst & 1;
	dst = (dst >> 1) << 2;
	dst |= lsb;

	if( src_flag )
	{
		lsb = src & 1;
		src = (src >> 1) << 2;
		src |= lsb;

		if( plane & 1 )
		{

		/*
		 *	This causes latches to be read from 2 bytes above the word
		 *	that was read if it was on an odd address, ie it only applies
		 *	to planes 1 and 3 in chained mode word operations.
		 */

			source = w ? &EGA_plane[src] + 2 : &EGA_plane[src];
		}
		else
		{
			source = &EGA_plane[src];
		}

		src = scratch;
	}

	if( EGA_CPU.fun_or_protection )
	{
		while( count > 0 )
		{
			count -= 2;

			value = *(UTINY *) src & (1 << plane) ? 0xff : 0;
#ifdef BACK_M
			src -= 2;
#else
			src += 2;
#endif

			if( src_flag )
			{
				put_latch( plane, *source );
				source += 4;
			}

			EGA_plane[dst] = (byte) do_logicals( value, get_latch(plane) );
			dst += 4;
		}
	}
	else
	{
		while( count > 0 )
		{
			count -= 2;

			EGA_plane[dst] = *(UTINY *) src & (1 << plane) ? 0xff : 0;
#ifdef BACK_M
			src -= 2;
#else
			src += 2;
#endif
			dst += 4;
		}
	}
#endif  //NEC_98
}

/*
 * Used by ega_mode2_chn_b_move with w == 0 and by
 * ega_mode2_gen_w_move with w == 1
 */

VOID
ega_mode2_chn_move IFN5(UTINY, w, UTINY *, ead, UTINY *, eas, ULONG, count,
	ULONG, src_flag )
{
#ifndef NEC_98
	UTINY *scr;

	IMPORT VOID (*string_read_ptr)();

	count <<= w;

	if( src_flag )
	{
		/*
		 *	Source is in EGA, latches will change with each byte moved. We
		 *	restore CPU's view of source in regen, and use it to update planes
		 *	with the aid of the SAS scratch area.
		 */

#ifdef BACK_M
		scr = getVideoscratch() + 0x10000 - 1;
#else
		scr = getVideoscratch();
#endif

		if( getDF() )
		{
			eas = eas - count + 1 + w;
			ead = ead - count + 1 + w;
		}

		(*string_read_ptr)( scr, eas, count );
	}
	else
	{
		if( getDF() )
		{
#ifdef BACK_M
			eas = eas + count - 1 - w;
#else
			eas = eas - count + 1 + w;
#endif
			ead = ead - count + 1 + w;
		}
	}

	if( getVideoplane_enable() & 1 )		/* plane 0, even addresses, enabled */
		ega_mode2_chn_move_guts( eas, ead, count, EGA_plane01, (ULONG) scr, 0, w, src_flag );

	if( getVideoplane_enable() & 2 )		/* plane 1, odd addresses, enabled */
		ega_mode2_chn_move_guts( eas, ead, count, EGA_plane01, (ULONG) scr, 1, w, src_flag );

	if( getVideoplane_enable() & 4 )		/* plane 2, even addresses, enabled */
		ega_mode2_chn_move_guts( eas, ead, count, EGA_plane23, (ULONG) scr, 2, w, src_flag );

	if( getVideoplane_enable() & 8 )		/* plane 3, odd addresses, enabled */
		ega_mode2_chn_move_guts( eas, ead, count, EGA_plane23, (ULONG) scr, 3, w, src_flag );

	update_alg.mark_string( (int) ead, (int) ead + count - 1 );
#endif  //NEC_98
}

VOID
ega_mode2_chn_b_move IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag)
{
#ifndef NEC_98
  note_entrance0("ega_mode2_chn_b_move");

  /* general function, 0 means byte write */

  ega_mode2_chn_move(0, (UTINY *) ead, (UTINY *) eas, count, src_flag);
#endif  //NEC_98
}

VOID
ega_mode2_chn_w_move IFN4(ULONG, ead, ULONG, eas, ULONG, count,
	ULONG, src_flag)
{
#ifndef NEC_98
  note_entrance0("ega_mode2_chn_w_move");

  /* general function, 1 means word write */

  ega_mode2_chn_move(1, (UTINY *)ead, (UTINY *)eas, count, src_flag);
#endif  //NEC_98
}

#endif

#endif	/* !NTVDM | (NTVDM & !X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\ggdc.c ===
#if defined(NEC_98)

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::    NEC98 Graphic Emulation Routine    :::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ios.h"
#include "ica.h"
#include "gvi.h"
#include "gmi.h"
#include "debug.h"
#include "gfx_upd.h"
#include "egacpu.h"
#include "ggdc.h"
#include "tgdc.h"


void    (*ggdc_param_out )(half_word);
void    (*ggdc_data_in   )(half_word*);
void    (*palette_A8H_out)(half_word);
void    (*palette_AAH_out)(half_word);
void    (*palette_ACH_out)(half_word);
void    (*palette_AEH_out)(half_word);
void    (*ggdc_texte_com )(void);
void    NEC98_graph_init(void);
void    NEC98_graph_post(void);
void    NEC98_graph_outb(io_addr,half_word);
void    NEC98_graph_inb(io_addr,half_word*);
void    mode_ff2_out(half_word);
void    vram_disp_out(half_word);
void    vram_draw_out(half_word);
void    set_palette8_37(half_word);
void    set_palette8_15(half_word);
void    set_palette8_26(half_word);
void    set_palette8_04(half_word);
void    set_palette8_data(unsigned char,unsigned char,unsigned char,half_word);
void    set_palette16_index(half_word);
void    set_palette16_green(half_word);
void    set_palette16_red(half_word);
void    set_palette16_blue(half_word);
void    modeff_palette_change(void);
void    grcg_mode_out(half_word);
void    grcg_tile_out(half_word);
void    ggdc_command_out(half_word);
void    ggdc_status_in(half_word*);
void    ggdc_data_dummy(half_word*);
void    ggdc_param_dummy(half_word);
void    ggdc_reset_com(half_word);
void    ggdc_sync_com(half_word);
void    ggdc_sync_param(half_word);
void    ggdc_start_com(void);
void    ggdc_stop_com(void);
void    ggdc_zoom_com(void);
void    ggdc_zoom_param(half_word);
void    ggdc_scroll_com(half_word);
void    ggdc_scroll_param1(half_word);
void    ggdc_scroll_param2(half_word);
void    ggdc_scroll_param3(half_word);
void    ggdc_scroll_param4(half_word);
void    ggdc_scroll_param5(half_word);
void    ggdc_scroll_param6(half_word);
void    ggdc_scroll_param7(half_word);
void    ggdc_scroll_param8(half_word);
void    ggdc_csrform_com(void);
void    ggdc_csrform_param(half_word);
void    ggdc_pitch_com(void);
void    ggdc_pitch_param(half_word);
void    ggdc_vectw_com(void);
void    ggdc_vectw_param(half_word);
void    ggdc_textw_com(half_word);
void    ggdc_textw_param1(half_word);
void    ggdc_textw_param2(half_word);
void    ggdc_textw_param3(half_word);
void    ggdc_textw_param4(half_word);
void    ggdc_textw_param5(half_word);
void    ggdc_textw_param6(half_word);
void    ggdc_textw_param7(half_word);
void    ggdc_textw_param8(half_word);
void    ggdc_csrw_com(void);
void    ggdc_csrw_param(half_word);
void    ggdc_csrr_com(void);
void    ggdc_csrr_data1(half_word*);
void    ggdc_csrr_data2(half_word*);
void    ggdc_csrr_data3(half_word*);
void    ggdc_csrr_data4(half_word*);
void    ggdc_csrr_data5(half_word*);
void    ggdc_mask_com(void);
void    ggdc_mask_param(half_word);
void    ggdc_write_com(half_word);
void    ggdc_write_word_low(half_word);
void    ggdc_write_word_high(half_word);
void    ggdc_write_byte_low(half_word);
void    ggdc_write_byte_high(half_word);
void    ggdc_read_com(half_word);
void    ggdc_read_word_low(half_word*);
void    ggdc_read_word_high(half_word*);
void    ggdc_read_byte_low(half_word*);
void    ggdc_read_byte_high(half_word*);
void    ggdc_draw_pixel(void);
void    ggdc_draw_line(void);
void    ggdc_draw_gchar(void);
void    ggdc_draw_circle(void);
void    ggdc_draw_rect(void);
void    ggdc_draw_slgchar(void);
void    ggdc_draw_nothing(void);
void    ggdc_init_vectw_param(void);
void    ggdc_read_back_data(void);
void    video_freeze_change(BOOL);
BOOL    host_dummy(void);
void    recalc_ggdc_draw_parameter(void);

extern  PVOID   host_NEC98_vram_init(void);
extern  void    host_NEC98_vram_change(unsigned char);
//extern  void    host_freeze(void);
extern  BOOL    hostChangeMode(void);
extern  void    set_the_vlt(void);
extern  boolean choose_NEC98_display_mode(void);
extern  boolean choose_NEC98_graph_mode(void);
extern  BOOL    video_emu_mode;
extern  unsigned char   *graph_copy;

extern  void    ggdc_send_c_asm(unsigned long *);
extern  void    ggdc_mod_select(unsigned char *);
extern  void    ggdc_drawing_line(void);
extern  void    ggdc_drawing_pixel(void);
extern  void    ggdc_drawing_arc(void);
extern  void    ggdc_drawing_rect(void);
extern  void    ggdc_drawing_text(void);
extern  void    ggdc_read_back(unsigned long *);
extern  void    ggdc_writing(unsigned short *);
extern  void    ggdc_reading(unsigned short *);

static  unsigned char   palette16change[]={
        0x00,0x10,0x20,0x30,    
        0x40,0x50,0x60,0x70,    
        0x80,0x90,0xA0,0xB0,    
        0xC0,0xD0,0xE0,0xFF             /* use 16 colors mode palette change */
};

static  unsigned char palette16init[16][3]={
        0x00,0x00,0x00,
        0x00,0x00,0x07,
        0x00,0x07,0x00,
        0x00,0x07,0x07,
        0x07,0x00,0x00,
        0x07,0x00,0x07,
        0x07,0x07,0x00,
        0x07,0x07,0x07,
        0x04,0x04,0x04,
        0x00,0x00,0x0F,
        0x00,0x0F,0x00,
        0x00,0x0F,0x0F,
        0x0F,0x00,0x00,
        0x0F,0x00,0x0F,
        0x0F,0x0F,0x00,
        0x0F,0x0F,0x0F          /* 16 colors mode palette initialize data */
};

static  unsigned char palette8index[]={ 3,1,2,0 }; /* palette NO! */

static  unsigned char   ggdc_drawing    = 0;   /* GGDC status use      */
static  unsigned char   ggdc_dataready  = 0;   /* GGDC status use      */
static  unsigned char   ggdc_flipflop   = 0;   /* GGDC status use      */
static  unsigned char   ggdc_status     = 4;   /* GGDC status use      */
static  unsigned char   *drawaddress;       /* draw address         */
static  GGDC_C_TO_ASM   drawing_data;       /* send asm struct      */
static  GGDC_CSRR_BACK  readcsrr;       /* read back data       */

STRC_GGDC_GLOBALS               ggdcglobs;
STRC_PALETTE_GLOBALS    paletteglobs;
STRC_GRCG_GLOBALS               grcgglobs;
STRC_EGC_REGS egc_regs;                                 // EGC register 940325

/*--------------------      NEC NEC98 ADD 930611     --------------------*/

void    (*ggdc_param_out )(half_word  value);
void    (*ggdc_data_in   )(half_word *value);
void    (*palette_A8H_out)(half_word  value);
void    (*palette_AAH_out)(half_word  value);
void    (*palette_ACH_out)(half_word  value);
void    (*palette_AEH_out)(half_word  value);
void    (*ggdc_texte_com )(void);
void    (*ggdc_vecte_com )(void);
BOOL    (*pif_freeze_mode)(void);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::    NEC98 Graphic Emulation Entry     ::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    NEC98_graph_init(void)
{
        unsigned char *gvram_offset;

        io_define_inb (GRAPHIC_ADAPTOR,NEC98_graph_inb );
        io_define_outb(GRAPHIC_ADAPTOR,NEC98_graph_outb);

        io_connect_port( GGDC_PARAMETER,GRAPHIC_ADAPTOR,IO_READ_WRITE );
        io_connect_port( GGDC_COMMAND  ,GRAPHIC_ADAPTOR,IO_READ_WRITE );
        io_connect_port( MODE_FF2          ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( VRAM_DISPLAY  ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( VRAM_DRAW     ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( PALETTE_A8    ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( PALETTE_AA    ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( PALETTE_AC    ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( PALETTE_AE    ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( GRCG_MODE     ,GRAPHIC_ADAPTOR,IO_WRITE      );
        io_connect_port( GRCG_TILE     ,GRAPHIC_ADAPTOR,IO_WRITE      );

        gvram_offset = (unsigned char *)host_NEC98_vram_init();

        /*      Mapping GGDC address area       */

        NEC98GLOBS->gvram_p30_ptr  = gvram_offset;      /* palne 00 */
        NEC98GLOBS->gvram_p00_ptr  = gvram_offset + 0x00008000; /* palne 01 */
        NEC98GLOBS->gvram_p10_ptr  = gvram_offset + 0x00010000; /* palne 02 */
        NEC98GLOBS->gvram_p20_ptr  = gvram_offset + 0x00018000; /* palne 03 */
        NEC98GLOBS->gvram_p31_ptr  = gvram_offset + 0x00020000; /* palne 10 */
        NEC98GLOBS->gvram_p01_ptr  = gvram_offset + 0x00028000; /* palne 11 */
        NEC98GLOBS->gvram_p11_ptr  = gvram_offset + 0x00030000; /* palne 12 */
        NEC98GLOBS->gvram_p21_ptr  = gvram_offset + 0x00038000; /* palne 13 */

        NEC98GLOBS->gvram_p30_copy = &graph_copy[0x00000];
        NEC98GLOBS->gvram_p00_copy = &graph_copy[0x08000];
        NEC98GLOBS->gvram_p10_copy = &graph_copy[0x10000];
        NEC98GLOBS->gvram_p20_copy = &graph_copy[0x18000];
        NEC98GLOBS->gvram_p31_copy = &graph_copy[0x20000];
        NEC98GLOBS->gvram_p01_copy = &graph_copy[0x28000];
        NEC98GLOBS->gvram_p11_copy = &graph_copy[0x30000];
        NEC98GLOBS->gvram_p21_copy = &graph_copy[0x38000];
}

/*----------------------------------------------------------------------*/
void    NEC98_graph_post(void)
{

    unsigned char   loop,port_a;

/*      (1)MODE_FF2             */
                inb(0x31,&port_a);

        NEC98Display.modeff2.colorsel    = FALSE;
        NEC98Display.modeff2.regwrite    = FALSE;
        NEC98Display.modeff2.egcext      = FALSE;
        NEC98Display.modeff2.lcd1mode    = FALSE;
        NEC98Display.modeff2.lcd2mode    = FALSE;
        NEC98Display.modeff2.lsiinit     = FALSE;
        NEC98Display.modeff2.gdcclock    = (port_a&0x80) ? FALSE : TRUE;

        modeffglobs.modeff2_data[FF2_COLORSEL]  = FF2_8COLOR;
        modeffglobs.modeff2_data[FF2_REGWRITE]  = FF2_DISENB;
        modeffglobs.modeff2_data[FF2_EGCEXT]    = FF2_GRCG;
        modeffglobs.modeff2_data[FF2_LCD1MODE]  = FF2_GT1DOT;
        modeffglobs.modeff2_data[FF2_LCD2MODE]  = FF2_GR640;
        modeffglobs.modeff2_data[FF2_LSIINIT]   = FF2_INIOFF;
        modeffglobs.modeff2_data[FF2_GDCCLOCK1] = (port_a&0x80) ? FF2_GDC25_1 : FF2_GDC50_1;
        modeffglobs.modeff2_data[FF2_GDCCLOCK2] = (port_a&0x80) ? FF2_GDC25_2 : FF2_GDC50_2;

/*      (2)VRAM_SELECT  */

        NEC98GLOBS->read_bank   = FORE_BANK;
        NEC98GLOBS->select_bank = FORE_BANK;

/*      (3)PALETTE              */

        palette_A8H_out = set_palette8_37;
        palette_AAH_out = set_palette8_15;
        palette_ACH_out = set_palette8_26;
        palette_AEH_out = set_palette8_04;

        set_palette8_37(0x37);
        set_palette8_15(0x15);
        set_palette8_26(0x26);
        set_palette8_04(0x04);

        for( loop = 0 ; loop < 16 ; loop++){
                set_palette16_index(loop);
                set_palette16_green(palette16init[loop][0]);
                set_palette16_red  (palette16init[loop][1]);
                set_palette16_blue (palette16init[loop][2]);
        }
        paletteglobs.pal_16_index = 0   ;

/*      (4)GRCG                 */

        grcgglobs.grcg_mode     = 0;
        grcgglobs.grcg_count    = 0;
        grcgglobs.grcg_tile[0]  = 0;
        grcgglobs.grcg_tile[1]  = 0;
        grcgglobs.grcg_tile[2]  = 0;
        grcgglobs.grcg_tile[3]  = 0;

/*      (4-1)EGC        1994/03/25      */
        egc_regs.Reg0 = 0xFFF0;
        egc_regs.Reg1 = 0x40FF;
        egc_regs.Reg2 = 0x0CAC;
        egc_regs.Reg3 = 0x0000;
        egc_regs.Reg4 = 0xFFFF;
        egc_regs.Reg5 = 0x0000;
        egc_regs.Reg6 = 0x0000;
        egc_regs.Reg7 = 0x0000;
        egc_regs.Reg3fb = 0x0000;
        egc_regs.Reg5fb = 0x0000;


/*      (5)GRAPH GDC    */

        ggdc_drawing    = 0;
        ggdc_dataready  = 0;
        ggdc_flipflop   = 0;
        ggdc_status     = 4;
        ggdc_param_out  = ggdc_param_dummy;
        ggdc_data_in    = ggdc_data_dummy;
        ggdc_vecte_com  = ggdc_draw_nothing;
        ggdc_texte_com  = ggdc_draw_nothing;
        ggdc_init_vectw_param();

        ggdcglobs.sync_param[0] = 0x16;
        ggdcglobs.sync_param[1] = 0x26;
        ggdcglobs.sync_param[2] = 0x03;
        ggdcglobs.sync_param[3] = 0x11;
        ggdcglobs.sync_param[4] = 0x83;
        ggdcglobs.sync_param[5] = 0x07;
        ggdcglobs.sync_param[6] = 0x90;
        ggdcglobs.sync_param[7] = 0x65;

        NEC98Display.ggdcemu.vh  = FALSE;
        NEC98Display.ggdcemu.cr  = 0x26;
        NEC98Display.ggdcemu.lf  = 0x0190;

        ggdcglobs.csrform_param[0] = 0x01;
        NEC98Display.ggdcemu.lr     = 0x01;

        ggdcglobs.zoom_param      = 0x00;
        NEC98Display.ggdcemu.zw    = 0x00;

        ggdcglobs.pitch_param     = (port_a&0x80) ?   0x28 :   0x50;
        NEC98Display.ggdcemu.p     = (port_a&0x80) ? 0x0028 : 0x0050;

        ggdcglobs.scroll_param[0] = 0x00;
        ggdcglobs.scroll_param[1] = 0x00;
        ggdcglobs.scroll_param[2] = 0xF0;
        ggdcglobs.scroll_param[3] = 0x1F;
        ggdcglobs.scroll_param[4] = 0x00;
        ggdcglobs.scroll_param[5] = 0x00;
        ggdcglobs.scroll_param[6] = 0x10;
        ggdcglobs.scroll_param[7] = 0x00;

        NEC98Display.ggdcemu.sad1  = 0x0000;
        NEC98Display.ggdcemu.sl1   = 0x01FF;
        NEC98Display.ggdcemu.im1   = FALSE;
        NEC98Display.ggdcemu.sad2  = 0x0000;
        NEC98Display.ggdcemu.sl2   = 0x0001;
        NEC98Display.ggdcemu.im2   = FALSE;

        ggdcglobs.textw_param[0]  = 0x00;
        ggdcglobs.textw_param[1]  = 0x00;
        ggdcglobs.textw_param[2]  = 0x00;
        ggdcglobs.textw_param[3]  = 0x00;
        ggdcglobs.textw_param[4]  = 0x00;
        ggdcglobs.textw_param[5]  = 0x00;
        ggdcglobs.textw_param[6]  = 0x00;
        ggdcglobs.textw_param[7]  = 0x00;

        NEC98Display.ggdcemu.txt[0] = 0x00;
        NEC98Display.ggdcemu.txt[1] = 0x00;
        NEC98Display.ggdcemu.txt[2] = 0x00;
        NEC98Display.ggdcemu.txt[3] = 0x00;
        NEC98Display.ggdcemu.txt[4] = 0x00;
        NEC98Display.ggdcemu.txt[5] = 0x00;
        NEC98Display.ggdcemu.txt[6] = 0x00;
        NEC98Display.ggdcemu.txt[7] = 0x00;
        NEC98Display.ggdcemu.ptn    = 0x0000;

        ggdcglobs.write = 0x20;
        ggdcglobs.start_stop = 0x0C;
        NEC98Display.ggdcemu.mod = 0x00;

        drawaddress = NEC98GLOBS->gvram_p30_ptr;
        NEC98Display.gvram_copy = NEC98GLOBS->gvram_p30_copy;
        NEC98Display.gvram_ptr  = NEC98GLOBS->gvram_p30_ptr;
        if( video_emu_mode ){
                modeff_palette_change();
/*                      choose_NEC98_display_mode();             del 900828 check */
        }
}
/*----------------------------------------------------------------------*/

void    NEC98_graph_outb(io_addr port, half_word value)
{
        switch(port) {
                case MODE_FF2:
                        mode_ff2_out(value);
                        break;
                case GGDC_PARAMETER:
                        (*ggdc_param_out)(value);
                        pif_freeze_mode();
                        break;
                case GGDC_COMMAND:
                        ggdc_command_out(value);
                        pif_freeze_mode();
                        break;
                case VRAM_DISPLAY:
                        vram_disp_out(value);
                        break;
                case VRAM_DRAW:
                        vram_draw_out(value);
                        break;
                case PALETTE_A8:
                        (*palette_A8H_out)(value);
                        break;
                case PALETTE_AA:
                        (*palette_AAH_out)(value);
                        break;
                case PALETTE_AC:
                        (*palette_ACH_out)(value);
                        break;
                case PALETTE_AE:
                        (*palette_AEH_out)(value);
                        break;
                case GRCG_MODE:
                        grcg_mode_out(value);
                        pif_freeze_mode();
                        break;
                case GRCG_TILE:
                        grcg_tile_out(value);
                        pif_freeze_mode();
                        break;
                case EGC_ACTIVE :
                case EGC_MODE   :
                case EGC_ROP    :
                case EGC_FORE   :
                case EGC_MASK   :
                case EGC_BACK   :
                case EGC_BITAD  :
                case EGC_LENGTH :
                        //host_freeze();
                        hostModeChange();
                        break;
                default:
                        assert1(FALSE,"unkown NEC98 graphic out port %x",port);
        }
}

/*----------------------------------------------------------------------*/

void    NEC98_graph_inb(io_addr port, half_word *value)
{
        switch(port) {
                case GGDC_PARAMETER:
                        ggdc_status_in(value);
                        break;
                case GGDC_COMMAND:
                        (*ggdc_data_in)(value);
                        break;
                default:
                        assert1(FALSE,"unkown NEC98 graphic in port %x",port);
        }
}

/*----------------------------------------------------------------------*/
void    video_freeze_change(BOOL pifmode)
{
        if(pifmode){
                pif_freeze_mode = host_dummy            ; /* select dummy logic */
        }else{
//              pif_freeze_mode = host_freeze           ; /* freeze 98 emulator */
                pif_freeze_mode = hostModeChange        ; /* Change to Full-Screen Mode */
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::    NEC98 Emulation mode FF2     ::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    mode_ff2_out(half_word value)
{
        switch( value ){
                case FF2_8COLOR :
                case FF2_16COLOR:
                        NEC98Display.modeff2.colorsel = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_COLORSEL] = value ;
                        modeff_palette_change() ;
                        break;
                case FF2_DISENB :
                case FF2_ENABLE :
                        NEC98Display.modeff2.regwrite = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_REGWRITE] = value ;
                        break;
                case FF2_GT1DOT :
                case FF2_GTEQ   :
                        NEC98Display.modeff2.lcd1mode = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_LCD1MODE] = value ;
                        break;
                case FF2_GR640  :
                case FF2_GR641  :
                        NEC98Display.modeff2.lcd2mode = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_LCD2MODE] = value ;
                        break;
                case FF2_INIOFF :
                case FF2_INION  :
                        NEC98Display.modeff2.lsiinit = (value&1) ? TRUE:FALSE ;
                        modeffglobs.modeff2_data[FF2_LSIINIT] = value ;
                        break;
                case FF2_GDC25_1:
                        NEC98Display.modeff2.gdcclock = FALSE ;
                        modeffglobs.modeff2_data[FF2_GDCCLOCK1] = value ;
                        break;
                case FF2_GDC25_2:
                        NEC98Display.modeff2.gdcclock = FALSE ;
                        modeffglobs.modeff2_data[FF2_GDCCLOCK2] = value ;
                        break;
                case FF2_GDC50_1:
                        modeffglobs.modeff2_data[FF2_GDCCLOCK1] = value ;
                        if(modeffglobs.modeff2_data[FF2_GDCCLOCK2]==FF2_GDC50_2){
                                NEC98Display.modeff2.gdcclock = TRUE     ;
                        }else{
                                NEC98Display.modeff2.gdcclock = FALSE;
                        }
                        break;
                case FF2_GDC50_2:
                        modeffglobs.modeff2_data[FF2_GDCCLOCK2] = value ;
                        if(modeffglobs.modeff2_data[FF2_GDCCLOCK1]==FF2_GDC50_1){
                                NEC98Display.modeff2.gdcclock = TRUE     ;
                        }else{
                                NEC98Display.modeff2.gdcclock = FALSE;
                        }
                        break;
                default :
                        if( NEC98Display.modeff2.regwrite ){
                                switch( value ){
                                        case FF2_GRCG   :
                                        case FF2_EGC    :
                                                NEC98Display.modeff2.egcext
                                                        = (value&1) ? TRUE:FALSE ;
                                                modeffglobs.modeff2_data[FF2_EGCEXT] = value ;
                                                break;
                                        default :
                                                assert1(FALSE,"unkown mode FF2 value = %x",value);
                                }
                        }else{
                                switch( value ){
                                        case FF2_GRCG   :
                                        case FF2_EGC    :
                                                assert1(FALSE,"DISNABLE FF2 EGC MODE = %x",value);
                                        default :
                                                assert1(FALSE,"unkown mode FF2 value = %x",value);
                                }
                        }
        }
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::  NEC98 Emulation VRAM select reg   :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    vram_disp_out(half_word value)
{
        switch( value ){
                case FORE_BANK:
                        NEC98GLOBS->read_bank = value ;
                        if( video_emu_mode ){
                                set_mode_change_required(TRUE);
                        }
                        break;
                case BACK_BANK:
                        NEC98GLOBS->read_bank = value ;
                        if( video_emu_mode ){
                                set_mode_change_required(TRUE);
                        }
                        break;
                default :
                        assert1(FALSE,"unkown vram disp bank select value %x",value);
        }
}

/*----------------------------------------------------------------------*/

void    vram_draw_out(half_word value)
{
        switch( value ){
                case FORE_BANK:
                        NEC98GLOBS->select_bank = value;
                        host_NEC98_vram_change(value);
                        drawaddress = NEC98GLOBS->gvram_p30_ptr;
                        break;
                case BACK_BANK:
                        NEC98GLOBS->select_bank = value;
                        host_NEC98_vram_change(value);
                        drawaddress = NEC98GLOBS->gvram_p31_ptr;
                        break;
                default :
                        assert1(FALSE,"unkown vram draw bank select value %x",value);
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::      NEC98 Emulation palette       :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*:::::::::::::::::::           8 colors mode           ::::::::::::::::::::::::*/

void set_palette8_37(half_word value){ set_palette8_data(0,3,7,value); }
void set_palette8_15(half_word value){ set_palette8_data(1,1,5,value); }
void set_palette8_26(half_word value){ set_palette8_data(2,2,6,value); }
void set_palette8_04(half_word value){ set_palette8_data(3,0,4,value); }

/*----------------------------------------------------------------------*/

void set_palette8_data( unsigned char   portno , 
                        unsigned char   regno1 ,
                        unsigned char   regno2 ,
                        half_word       value  )
{
        unsigned char   palBL ;         /* palette exchange BLUE (BIT 0) */
        unsigned char   palRL ;         /* palette exchange RED  (BIT 1) */
        unsigned char   palGL ;         /* palette exchange GREEN(BIT 2) */
        unsigned char   palBH ;         /* palette exchange BLUE (BIT 4) */
        unsigned char   palRH ;         /* palette exchange RED  (BIT 5) */
        unsigned char   palGH ;         /* palette exchange GREEN(BIT 6) */

        NEC98Display.palette.flag = TRUE ;                /* palette changed */
        paletteglobs.pal_8_data[portno] = value ; /* save port A8,AA,AC,AEH */

        if(NEC98Display.modeff.graphmode){        /* TRUE  = mono  mode  */
            palBL = palRL = palGL = (value& 4) ? 0xFF:0x00 ;
            palBH = palRH = palGH = (value&64) ? 0xFF:0x00 ;
        }else{                                                   /* FALSE = color mode  */
            palBL = (value& 1) ? 0xFF:0x00 ;
            palRL = (value& 2) ? 0xFF:0x00 ;
            palGL = (value& 4) ? 0xFF:0x00 ;
            palBH = (value&16) ? 0xFF:0x00 ;
            palRH = (value&32) ? 0xFF:0x00 ;
            palGH = (value&64) ? 0xFF:0x00 ;
        }

        /* set new palette data --> UPDATE Logic --> HOST */

        NEC98Display.palette.data[regno2+8].peBlue       = (BYTE)palBL;
        NEC98Display.palette.data[regno2+8].peGreen      = (BYTE)palGL;
        NEC98Display.palette.data[regno2+8].peRed        = (BYTE)palRL;
        NEC98Display.palette.data[regno2+8].peFlags      = (BYTE)0x00 ;

        NEC98Display.palette.data[regno2  ].peBlue       = (BYTE)palBL;
        NEC98Display.palette.data[regno2  ].peGreen      = (BYTE)palGL;
        NEC98Display.palette.data[regno2  ].peRed        = (BYTE)palRL;
        NEC98Display.palette.data[regno2  ].peFlags      = (BYTE)0x00 ;

        NEC98Display.palette.data[regno1+8].peBlue       = (BYTE)palBH;
        NEC98Display.palette.data[regno1+8].peGreen      = (BYTE)palGH;
        NEC98Display.palette.data[regno1+8].peRed        = (BYTE)palRH;
        NEC98Display.palette.data[regno1+8].peFlags      = (BYTE)0x00 ;

        NEC98Display.palette.data[regno1  ].peBlue       = (BYTE)palBH;
        NEC98Display.palette.data[regno1  ].peGreen      = (BYTE)palGH;
        NEC98Display.palette.data[regno1  ].peRed        = (BYTE)palRH;
        NEC98Display.palette.data[regno1  ].peFlags      = (BYTE)0x00;
}

/*:::::::::::::::::::           16 colors mode          ::::::::::::::::::::::::*/

void set_palette16_index(half_word value)
{
        if( value >= 0 && value <= 0x0F ){
                paletteglobs.pal_16_index = value ;     /* save last palette index */
                NEC98Display.palette.data[value].peFlags = 0x00 ;
        }else{  
                assert1(FALSE,"16 color palette index value miss !!! %x",value);
        }
}

/*----------------------------------------------------------------------*/

void set_palette16_green(half_word value)
{
        if(  value >= 0 && value <= 0x0F ){
                NEC98Display.palette.flag = TRUE ;               /* palette changed */
                paletteglobs.pal_16_data[paletteglobs.pal_16_index][NEC98PALG]
                        = value ;
                if(NEC98Display.modeff.graphmode){       /* TRUE  = mono  mode  */
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peBlue      =
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peGreen     =
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peRed       =
                                (value&8) ? (BYTE)0xFF : (BYTE)0x00 ;
                }else{                                       /* FALSE = color mode  */
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peGreen =
                                (BYTE)(palette16change[value]) ;
                }
        }else{
                assert1(FALSE,"16 color palette green value miss !!! %x",value);
        }
}

/*----------------------------------------------------------------------*/

void set_palette16_red(half_word value)
{
        if(  value >= 0 && value <= 0x0F  ){
                paletteglobs.pal_16_data[paletteglobs.pal_16_index][NEC98PALR]
                        = value ;
                if(!NEC98Display.modeff.graphmode){       /* TRUE  = color mode  */
                        NEC98Display.palette.flag = TRUE ;               /* palette changed */
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peRed
                                = (BYTE)(palette16change[value]) ;
                }
        }else{
                assert1(FALSE,"16 color palette red value miss !!! %x",value);
        }
}

/*----------------------------------------------------------------------*/

void set_palette16_blue(half_word value)
{
        if(  value >= 0 && value <= 0x0F  ){
                paletteglobs.pal_16_data[paletteglobs.pal_16_index][NEC98PALB]
                        = value ;
                if(!NEC98Display.modeff.graphmode){       /* TRUE  = color mode  */
                        NEC98Display.palette.flag = TRUE ;               /* palette changed */
                        NEC98Display.palette.data[paletteglobs.pal_16_index].peBlue
                                = (BYTE)(palette16change[value]) ;
                }
        }else{
                assert1(FALSE,"16 color palette blue value miss !!! %x",value);
        }
}

/*----------------------------------------------------------------------*/

void modeff_palette_change(void)
{
        unsigned char loop      ;       /* work for loop counter        */
        unsigned char index     ;       /* work for 8 palette index */
        NEC98Display.palette.flag = TRUE ;                /* palette changed */
        if(NEC98Display.modeff2.colorsel){       /* 16 color mode */
            palette_A8H_out = set_palette16_index ;
            palette_AAH_out = set_palette16_green ;
            palette_ACH_out = set_palette16_red   ;
            palette_AEH_out = set_palette16_blue  ;

            if(NEC98Display.modeff.graphmode){       /* mono mode */
                for( loop=0 ; loop<16 ; loop++ ){
                     NEC98Display.palette.data[loop].peBlue   =
                     NEC98Display.palette.data[loop].peGreen  =
                     NEC98Display.palette.data[loop].peRed    =
                         (paletteglobs.pal_16_data[loop][NEC98PALG]&8) ? (BYTE)0xFF : (BYTE)0x00 ;
                     NEC98Display.palette.data[loop].peFlags=(BYTE)0x00;
                }
            }else{                                                          /* color mode */
                for( loop=0 ; loop<16 ; loop++ ){
                        NEC98Display.palette.data[loop].peBlue=
                                (BYTE)palette16change[paletteglobs.pal_16_data[loop][NEC98PALB]];
                        NEC98Display.palette.data[loop].peGreen=
                                (BYTE)palette16change[paletteglobs.pal_16_data[loop][NEC98PALG]];
                        NEC98Display.palette.data[loop].peRed=
                                (BYTE)palette16change[paletteglobs.pal_16_data[loop][NEC98PALR]];
                        NEC98Display.palette.data[loop].peFlags= (BYTE)0x00 ;
                }
            }
        }else{                                                          /*  8 color mode */

            palette_A8H_out = set_palette8_37 ;
            palette_AAH_out = set_palette8_15 ;
            palette_ACH_out = set_palette8_26 ;
            palette_AEH_out = set_palette8_04 ;

            if(NEC98Display.modeff.graphmode){       /* mono mode */
                for( loop=0 ; loop < 4 ; loop++ ){
                    index = palette8index[loop]     ;

                    NEC98Display.palette.data[index   ].peBlue       =
                    NEC98Display.palette.data[index   ].peGreen      =
                    NEC98Display.palette.data[index   ].peRed        =
                    NEC98Display.palette.data[index+ 8].peBlue       =
                    NEC98Display.palette.data[index+ 8].peGreen      =
                    NEC98Display.palette.data[index+ 8].peRed        =
                        (paletteglobs.pal_8_data[loop]&64) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index+ 4].peBlue       =
                    NEC98Display.palette.data[index+ 4].peGreen      =
                    NEC98Display.palette.data[index+ 4].peRed        =
                    NEC98Display.palette.data[index+12].peBlue       =
                    NEC98Display.palette.data[index+12].peGreen      =
                    NEC98Display.palette.data[index+12].peRed        =
                        (paletteglobs.pal_8_data[loop]& 4) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index   ].peFlags      =
                    NEC98Display.palette.data[index+ 4].peFlags      =
                    NEC98Display.palette.data[index+ 8].peFlags      =
                    NEC98Display.palette.data[index+12].peFlags      = (BYTE)0x00 ;
                }
            }else{                                                          /* color mode */
                for( loop=0 ; loop < 4 ; loop++ ){
                    index = palette8index[loop]     ;

                    NEC98Display.palette.data[index   ].peBlue       =
                    NEC98Display.palette.data[index+ 8].peBlue       =
                        (paletteglobs.pal_8_data[loop]&16) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index   ].peRed        =
                    NEC98Display.palette.data[index+ 8].peRed        =
                        (paletteglobs.pal_8_data[loop]&32) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index   ].peGreen      =
                    NEC98Display.palette.data[index+ 8].peGreen      =
                        (paletteglobs.pal_8_data[loop]&64) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index+ 4].peBlue       =
                    NEC98Display.palette.data[index+12].peBlue       =
                        (paletteglobs.pal_8_data[loop]& 1) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index+ 4].peRed        =
                    NEC98Display.palette.data[index+12].peRed        =
                        (paletteglobs.pal_8_data[loop]& 2) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index+ 4].peGreen      =
                    NEC98Display.palette.data[index+12].peGreen      =
                        (paletteglobs.pal_8_data[loop]& 4) ? (BYTE)0xFF : (BYTE)0x00 ;

                    NEC98Display.palette.data[index   ].peFlags      =
                    NEC98Display.palette.data[index+ 4].peFlags      =
                    NEC98Display.palette.data[index+ 8].peFlags      =
                    NEC98Display.palette.data[index+12].peFlags      = (BYTE)0x00 ;
                }
            }
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::       NEC98 Emulation GRCG      ::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    grcg_mode_out(half_word value)
{
        grcgglobs.grcg_mode  = value    ; 
        grcgglobs.grcg_count = 0                ; /* GRCG Tile count clear */
        if( video_emu_mode ){
            if(value&0x80){
                //host_freeze();
                hostModeChange();
            }
        }
}

void    grcg_tile_out(half_word value)
{
        switch(grcgglobs.grcg_count){
                case 0:
                        grcgglobs.grcg_tile[0] = value ;
                        grcgglobs.grcg_count++;
                        break;
                case 1:
                        grcgglobs.grcg_tile[1] = value ;
                        grcgglobs.grcg_count++;
                        break;
                case 2:
                        grcgglobs.grcg_tile[2] = value ;
                        grcgglobs.grcg_count++;
                        break;
                case 3:
                        grcgglobs.grcg_tile[3] = value ;
                        grcgglobs.grcg_count=0;
                        break;
                default:
                        assert1(FALSE,"GRCG TILE-REG count miss !!! %d",value);
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::    NEC98 Emulation Graph-GDC    ::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    ggdc_command_out(half_word value)
{
        ggdc_param_out  = ggdc_param_dummy      ; /* clear param out */
        ggdc_data_in    = ggdc_data_dummy       ; /* clear param in  */

        switch(value) {
                case GGDC_RESET1:
                case GGDC_RESET2:
                case GGDC_RESET3:
                        ggdc_reset_com(value);
                        break;
                case GGDC_SYNC_OFF:
                case GGDC_SYNC_ON :
                        ggdc_sync_com(value);
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                case GGDC_SLAVE :
                case GGDC_MASTER:
                        break;                          /* G-GDC must drive slave mode !!! */
                case GGDC_START1:
                case GGDC_START2:
                        ggdc_start_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_STOP1:
                case GGDC_STOP2:
                        ggdc_stop_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_ZOOM:
                        ggdc_zoom_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_SCROLL1:
                case GGDC_SCROLL2:
                case GGDC_SCROLL3:
                case GGDC_SCROLL4:
                case GGDC_SCROLL5:
                case GGDC_SCROLL6:
                case GGDC_SCROLL7:
                case GGDC_SCROLL8:
                        ggdc_scroll_com(value);
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_CSRFORM:
                        ggdc_csrform_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_PITCH:
                        ggdc_pitch_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_LPEN:
                        break;
                case GGDC_VECTW:
                        ggdc_vectw_com();
                        ggdcglobs.ggdc_now.command = value ;
                        ggdcglobs.ggdc_now.count   = 0     ;
                        break;
                case GGDC_VECTE:
                        (*ggdc_vecte_com)();
                        break;
                case GGDC_TEXTW1:
                case GGDC_TEXTW2:
                case GGDC_TEXTW3:
                case GGDC_TEXTW4:
                case GGDC_TEXTW5:
                case GGDC_TEXTW6:
                case GGDC_TEXTW7:
                case GGDC_TEXTW8:
                        ggdc_textw_com(value);
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                        break;
                case GGDC_TEXTE:
                        (*ggdc_texte_com)();
                        break;
                case GGDC_CSRW:
                        ggdc_csrw_com();
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                        break;
                case GGDC_CSRR:
                        ggdc_csrr_com();
                        break;
                case GGDC_MASK:
                        ggdc_mask_com();
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                        break;
                case GGDC_WRITE1:
                case GGDC_WRITE2:
                case GGDC_WRITE3:
                case GGDC_WRITE4:
                case GGDC_WRITE5:
                case GGDC_WRITE6:
                case GGDC_WRITE7:
                case GGDC_WRITE8:
                case GGDC_WRITE9:
                case GGDC_WRITE10:
                case GGDC_WRITE11:
                case GGDC_WRITE12:
                case GGDC_WRITE13:
                case GGDC_WRITE14:
                case GGDC_WRITE15:
                case GGDC_WRITE16:
                        ggdc_write_com(value);
                        ggdcglobs.ggdc_now.command = value ; /* last ggdc command */
                        ggdcglobs.ggdc_now.count   = 0     ; /* ggdc param count  */
                        break;
                case GGDC_READ1:
                case GGDC_READ2:
                case GGDC_READ3:
                case GGDC_READ4:
                case GGDC_READ5:
                case GGDC_READ6:
                case GGDC_READ7:
                case GGDC_READ8:
                case GGDC_READ9:
                case GGDC_READ10:
                case GGDC_READ11:
                case GGDC_READ12:
                case GGDC_READ13:
                case GGDC_READ14:
                case GGDC_READ15:
                case GGDC_READ16:
                        ggdc_read_com(value);
                        break;
                case GGDC_DMAW1:
                case GGDC_DMAW2:
                case GGDC_DMAW3:
                case GGDC_DMAW4:
                case GGDC_DMAW5:
                case GGDC_DMAW6:
                case GGDC_DMAW7:
                case GGDC_DMAW8:
                case GGDC_DMAW9:
                case GGDC_DMAW10:
                case GGDC_DMAW11:
                case GGDC_DMAW12:
                case GGDC_DMAW13:
                case GGDC_DMAW14:
                case GGDC_DMAW15:
                case GGDC_DMAW16:
                case GGDC_DMAR1:
                case GGDC_DMAR2:
                case GGDC_DMAR3:
                case GGDC_DMAR4:
                case GGDC_DMAR5:
                case GGDC_DMAR6:
                case GGDC_DMAR7:
                case GGDC_DMAR8:
                case GGDC_DMAR9:
                case GGDC_DMAR10:
                case GGDC_DMAR11:
                case GGDC_DMAR12:
                case GGDC_DMAR13:
                case GGDC_DMAR14:
                case GGDC_DMAR15:
                case GGDC_DMAR16:
                        ggdc_param_out = ggdc_param_dummy ;
                        break;
                default:
                        assert1(FALSE,"unkown GGDC command = %x",value);
        }
}

/*----------------------------------------------------------------------*/

void    ggdc_status_in(half_word *value)
{
        if(ggdc_dataready == 0){
                ggdc_status &= 0xFE;
        }else{
                ggdc_status |= 0x01;
        }
        if(ggdc_drawing == 0){
                ggdc_status &= 0xF7;
        }else{
                ggdc_status |= 0x08;
        }
        if(ggdc_flipflop == 0){
                ggdc_status &= 0x9F;
        }else{
                ggdc_status |= 0x60;
        }
        ggdc_flipflop  =  ( ggdc_flipflop + 1 ) & 1;
        *value         =  ggdc_status;
}

void    ggdc_data_dummy(half_word *value)
{
        *value = 0xFF;
}

void    ggdc_param_dummy(half_word value)
{
        /*      Opps!!! do nothing !!! */
}

BOOL    host_dummy(void)
{
        /*      Opps!!! do nothing !!! */
        return(0);
}

/*:::::::::::::::::::::::   G-GDC RESET Command   ::::::::::::::::::::::*/

void    ggdc_reset_com(half_word value)
{
/*      (1) GGDC STATUS FLAG CLEAR */
        ggdc_drawing    = 0;
        ggdc_dataready  = 0;
        ggdc_flipflop   = 0;
        ggdc_status     = 4;

/* (2) GGDC DRAW ROUTINE CONNECT CLEAR */
        ggdc_param_out  = ggdc_param_dummy;
        ggdc_data_in    = ggdc_data_dummy;

/* (3) GGDC VECTW PARAM CLEAR */
        ggdc_init_vectw_param();

/* (4) GGDC START STOP */
        ggdc_param_out = ggdc_sync_param;

        if( value == GGDC_RESET3 ){
                ggdc_start_com();
        }else{
                ggdc_stop_com();
        }
}

/*:::::::::::::::::::::::   G-GDC SYNC Command    ::::::::::::::::::::::*/

void    ggdc_sync_com(half_word value)
{
        ggdc_param_out = ggdc_sync_param ;
        if( value == GGDC_SYNC_OFF ){
                ggdc_stop_com();
        }else{
                ggdc_start_com();
        }
}
/*----------------------------------------------------------------------*/
void    ggdc_sync_param(half_word value)
{

        ggdcglobs.sync_param[ggdcglobs.ggdc_now.count]     = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case 0:
                        break;
                case 1:
                        NEC98Display.ggdcemu.cr = value ;
                        break;
                case 2:
                        break;
                case 3:
                        break;
                case 4:
                        if(value&0x40){
                                NEC98Display.ggdcemu.p |= 0x0100;
                        }else{
                                NEC98Display.ggdcemu.p &= 0x00FF;
                        }
                        break;
                case 5:
                        NEC98Display.ggdcemu.vh = (value&0x80) ? TRUE : FALSE;
                        break;
                case 6:
                        NEC98Display.ggdcemu.lf &= 0xFF00;
                        NEC98Display.ggdcemu.lf |= (unsigned short)value;
                        break;
                case 7:
                        NEC98Display.ggdcemu.lf &= 0x00FF;
                        NEC98Display.ggdcemu.lf |= ((unsigned short)(value&3))<<8;
                        ggdc_param_out = ggdc_param_dummy;
                        break;
                default:
                        assert1(FALSE,"GGDC SYNC param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*:::::::::::::::::::::::   G-GDC START Command   ::::::::::::::::::::::*/

void    ggdc_start_com(void)
{
        NEC98Display.ggdcemu.startstop = TRUE;
        ggdcglobs.start_stop = GGDC_START2;
        if( video_emu_mode ){
                set_mode_change_required(TRUE);
        }
}

/*:::::::::::::::::::::::   G-GDC STOP Command   :::::::::::::::::::::::*/

void    ggdc_stop_com(void)
{
        NEC98Display.ggdcemu.startstop = FALSE;
        ggdcglobs.start_stop = GGDC_STOP2;
        if( video_emu_mode ){
                set_mode_change_required(TRUE);
        }
}

/*:::::::::::::::::::::::   G-GDC ZOOM Command   :::::::::::::::::::::::*/

void    ggdc_zoom_com(void)
{
        ggdc_param_out = ggdc_zoom_param;
}
/*----------------------------------------------------------------------*/
void    ggdc_zoom_param(half_word value)
{
        ggdcglobs.zoom_param        = value;
        ggdcglobs.ggdc_now.param[0] = value;
        NEC98Display.ggdcemu.zw      = value & 0x0F;
        ggdc_param_out              = ggdc_param_dummy;
        ggdcglobs.ggdc_now.count    = 1;
}

/*::::::::::::::::::::::   G-GDC SCROLL Command   ::::::::::::::::::::::*/

void    ggdc_scroll_com(half_word value)
{
        switch( value ){
                case GGDC_SCROLL1:
                        ggdc_param_out = ggdc_scroll_param1;
                        break ;
                case GGDC_SCROLL2:
                        ggdc_param_out = ggdc_scroll_param2;
                        break ;
                case GGDC_SCROLL3:
                        ggdc_param_out = ggdc_scroll_param3;
                        break ;
                case GGDC_SCROLL4:
                        ggdc_param_out = ggdc_scroll_param4;
                        break ;
                case GGDC_SCROLL5:
                        ggdc_param_out = ggdc_scroll_param5;
                        break ;
                case GGDC_SCROLL6:
                        ggdc_param_out = ggdc_scroll_param6;
                        break ;
                case GGDC_SCROLL7:
                        ggdc_param_out = ggdc_scroll_param7;
                        break ;
                case GGDC_SCROLL8:
                        ggdc_param_out = ggdc_scroll_param8;
                        break ;
                default:
                        assert1(FALSE,"GGDC SCROLL bad command = %x",value);
        }
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param1(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[0] = value;
        NEC98Display.ggdcemu.sad1 &= 0xFFFFFF00;
        NEC98Display.ggdcemu.sad1 |= (unsigned long)(value);
        ggdc_param_out = ggdc_scroll_param2;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param2(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[1] = value;
        NEC98Display.ggdcemu.sad1 &= 0xFFFF00FF;
        NEC98Display.ggdcemu.sad1 |= ((unsigned long)(value)<<8);
        ggdc_param_out = ggdc_scroll_param3;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param3(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[2] = value;
        NEC98Display.ggdcemu.sad1 &= 0xFF00FFFF;
        NEC98Display.ggdcemu.sad1 |= (((unsigned long)(value&0x03))<<16);
        NEC98Display.ggdcemu.sl1  &= 0xFFF0;
        NEC98Display.ggdcemu.sl1  |= (((unsigned short)(value&0xF0))>>4);
        ggdc_param_out = ggdc_scroll_param4;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param4(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[3] = value;
        NEC98Display.ggdcemu.im1   = (value&0x40) ? TRUE : FALSE;
        NEC98Display.ggdcemu.sl1  &= 0xC0FF;
        NEC98Display.ggdcemu.sl1  |= (((unsigned short)(value&0x3F))<<4);
        ggdc_param_out = ggdc_scroll_param5;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param5(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[4] = value;
        NEC98Display.ggdcemu.sad2 &= 0xFFFFFF00;
        NEC98Display.ggdcemu.sad2 |= (unsigned long)(value);
        ggdc_param_out = ggdc_scroll_param6;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param6(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[5] = value;
        NEC98Display.ggdcemu.sad2 &= 0xFFFF00FF;
        NEC98Display.ggdcemu.sad2 |= ((unsigned long)(value)<<8);
        ggdc_param_out = ggdc_scroll_param7;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param7(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[6] = value;
        NEC98Display.ggdcemu.sad2 &= 0xFF00FFFF;
        NEC98Display.ggdcemu.sad2 |= (((unsigned long)(value&0x03))<<16);
        NEC98Display.ggdcemu.sl2  &= 0xFFF0;
        NEC98Display.ggdcemu.sl2  |= (((unsigned short)(value&0xF0))>>4);
        ggdc_param_out = ggdc_scroll_param8;
}

/*----------------------------------------------------------------------*/

void    ggdc_scroll_param8(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.scroll_param[7] = value;
        NEC98Display.ggdcemu.im2   = (value&0x40) ? TRUE : FALSE;
        NEC98Display.ggdcemu.sl2  &= 0xC0FF;
        NEC98Display.ggdcemu.sl2  |= (((unsigned short)(value&0x3F))<<4);
        ggdc_param_out = ggdc_param_dummy;
}

/*::::::::::::::::::::::   G-GDC CSRFORM Command   :::::::::::::::::::::*/

void    ggdc_csrform_com(void)
{
        ggdc_param_out = ggdc_csrform_param;
}

/*----------------------------------------------------------------------*/

void    ggdc_csrform_param(half_word value)
{

        ggdcglobs.csrform_param[ggdcglobs.ggdc_now.count]   = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case 0:
                        NEC98Display.ggdcemu.lr = value & 0x1F;
                        if( video_emu_mode ){
                                set_mode_change_required(TRUE);
                        }
                        break;
                case 1:
                        break;
                case 2:
                        ggdc_param_out = ggdc_param_dummy;
                        break;
                default:        
                        assert1(FALSE,"GGDC CSRFORM param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*:::::::::::::::::::::::   G-GDC PITCH Command   ::::::::::::::::::::::*/

void    ggdc_pitch_com(void)
{
        ggdc_param_out = ggdc_pitch_param;
}

/*----------------------------------------------------------------------*/

void    ggdc_pitch_param(half_word value)
{
        ggdcglobs.pitch_param         = value;
        ggdcglobs.ggdc_now.param[0]  = value;
        NEC98Display.ggdcemu.p       &= 0xFF00;
        NEC98Display.ggdcemu.p       |= (unsigned short)value;
        ggdc_param_out               = ggdc_param_dummy;
        ggdcglobs.ggdc_now.count     = 1;
}

/*::::::::::::::::::::::   G-GDC VECTW Command   :::::::::::::::::::::::*/

void    ggdc_vectw_com(void)
{
        ggdc_param_out = ggdc_vectw_param;
}

/*----------------------------------------------------------------------*/

void    ggdc_vectw_param(half_word value)
{
        ggdcglobs.vectw_param[ggdcglobs.ggdc_now.count]     = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case  0:
                        NEC98Display.ggdcemu.slrctl = (value&0xF8)>>3;
                        NEC98Display.ggdcemu.dir    = (value&0x07);
                        switch(NEC98Display.ggdcemu.slrctl){
                                case 0x00:      /* PIXEL */
                                        ggdc_vecte_com = ggdc_draw_pixel;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        break;
                                case 0x01:      /* LINE */
                                        ggdc_vecte_com = ggdc_draw_line;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        break;
                                case 0x02:      /* GRAPHIC CHAR */
                                        ggdc_vecte_com = ggdc_draw_nothing;
                                        ggdc_texte_com = ggdc_draw_gchar;
                                        break;
                                case 0x04:      /* CIRCLE */
                                        ggdc_vecte_com = ggdc_draw_circle;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        break;
                                case 0x08:      /* RECT */
                                        ggdc_vecte_com = ggdc_draw_rect;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        break;
                                case 0x12:      /* SLINE GRAPHIC CHAR */
                                        ggdc_vecte_com = ggdc_draw_nothing;
                                        ggdc_texte_com = ggdc_draw_slgchar;
                                        break;
                                default:
                                        ggdc_vecte_com = ggdc_draw_nothing;
                                        ggdc_texte_com = ggdc_draw_nothing;
                                        assert1(FALSE,"GGDC draw mode error = %x",
                                            NEC98Display.ggdcemu.slrctl);
                        }
                        break;
                case  1:
                        NEC98Display.ggdcemu.dc &= 0xFF00;
                        NEC98Display.ggdcemu.dc |= (unsigned short)value;
                        break;
                case  2:
                        NEC98Display.ggdcemu.dgd = (value&0x40) ? TRUE : FALSE;
                        NEC98Display.ggdcemu.dc &= 0x00FF;
                        NEC98Display.ggdcemu.dc |= ((unsigned short)(value&0x3F))<<8;
                        break;
                case  3:
                        NEC98Display.ggdcemu.d  &= 0xFF00;
                        NEC98Display.ggdcemu.d  |= (unsigned short)value;
                        break;
                case  4:
                        NEC98Display.ggdcemu.d  &= 0x00FF;
                        NEC98Display.ggdcemu.d  |= ((unsigned short)(value&0x3F))<<8;
                        break;
                case  5:
                        NEC98Display.ggdcemu.d2 &= 0xFF00;
                        NEC98Display.ggdcemu.d2 |= (unsigned short)value;
                        break;
                case  6:
                        NEC98Display.ggdcemu.d2 &= 0x00FF;
                        NEC98Display.ggdcemu.d2 |= ((unsigned short)(value&0x3F))<<8;
                        break;
                case  7:
                        NEC98Display.ggdcemu.d1 &= 0xFF00;
                        NEC98Display.ggdcemu.d1 |= (unsigned short)value;
                        break;
                case  8:
                        NEC98Display.ggdcemu.d1 &= 0x00FF;
                        NEC98Display.ggdcemu.d1 |= ((unsigned short)(value&0x3F))<<8;
                        break;
                case  9:
                        NEC98Display.ggdcemu.dm &= 0xFF00;
                        NEC98Display.ggdcemu.dm |= (unsigned short)value;
                        break;
                case 10:
                        NEC98Display.ggdcemu.dm &= 0x00FF;
                        NEC98Display.ggdcemu.dm |= ((unsigned short)(value&0x3F))<<8;
                        ggdc_param_out = ggdc_param_dummy;
                        break;
                default:        
                        assert1(FALSE,"GGDC VECTW param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*::::::::::::::::::::::   G-GDC TEXTW Command   :::::::::::::::::::::::*/

void    ggdc_textw_com(half_word value)
{
        switch( value ){
                case GGDC_TEXTW1:
                        ggdc_param_out = ggdc_textw_param1;
                        break;
                case GGDC_TEXTW2:
                        ggdc_param_out = ggdc_textw_param2;
                        break;
                case GGDC_TEXTW3:
                        ggdc_param_out = ggdc_textw_param3;
                        break;
                case GGDC_TEXTW4:
                        ggdc_param_out = ggdc_textw_param4;
                        break;
                case GGDC_TEXTW5:
                        ggdc_param_out = ggdc_textw_param5;
                        break;
                case GGDC_TEXTW6:
                        ggdc_param_out = ggdc_textw_param6;
                        break;
                case GGDC_TEXTW7:
                        ggdc_param_out = ggdc_textw_param7;
                        break;
                case GGDC_TEXTW8:
                        ggdc_param_out = ggdc_textw_param8;
                        break;
                default:
                        assert1(FALSE,"GGDC TEXTW bad command = %x",value);
        }
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param1(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[0] = value;
        NEC98Display.ggdcemu.ptn &= 0xFF00;
        NEC98Display.ggdcemu.ptn |= (unsigned short)value;
        NEC98Display.ggdcemu.txt[0] = value;
        ggdc_param_out = ggdc_textw_param2;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param2(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[1] = value;
        NEC98Display.ggdcemu.ptn &= 0x00FF;
        NEC98Display.ggdcemu.ptn |= ((unsigned short)value)<<8;
        NEC98Display.ggdcemu.txt[1] = value;
        ggdc_param_out = ggdc_textw_param3;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param3(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[2] = value;
        NEC98Display.ggdcemu.txt[2] = value;
        ggdc_param_out = ggdc_textw_param4;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param4(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[3] = value;
        NEC98Display.ggdcemu.txt[3] = value;
        ggdc_param_out = ggdc_textw_param5;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param5(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[4] = value;
        NEC98Display.ggdcemu.txt[4] = value;
        ggdc_param_out = ggdc_textw_param6;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param6(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[5] = value;
        NEC98Display.ggdcemu.txt[5] = value;
        ggdc_param_out = ggdc_textw_param7;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param7(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[6] = value;
        NEC98Display.ggdcemu.txt[6] = value;
        ggdc_param_out = ggdc_textw_param8;
}

/*----------------------------------------------------------------------*/

void    ggdc_textw_param8(half_word value)
{
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.count++;
        ggdcglobs.textw_param[7] = value;
        NEC98Display.ggdcemu.txt[7] = value;
        ggdc_param_out = ggdc_param_dummy;
}

/*:::::::::::::::::::::::   G-GDC CSRW Command   :::::::::::::::::::::::*/

void    ggdc_csrw_com(void)
{
        ggdc_param_out = ggdc_csrw_param;
}

/*----------------------------------------------------------------------*/

void    ggdc_csrw_param(half_word value)
{

        ggdcglobs.csrw_param[ggdcglobs.ggdc_now.count] = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case 0:
                        NEC98Display.ggdcemu.ead &= 0xFFFFFF00;
                        NEC98Display.ggdcemu.ead |= (unsigned long)value;
                        break;
                case 1:
                        NEC98Display.ggdcemu.ead &= 0xFFFF00FF;
                        NEC98Display.ggdcemu.ead |= ((unsigned long)value)<<8;
                        break;
                case 2:
                        NEC98Display.ggdcemu.ead &= 0xFF00FFFF;
                        NEC98Display.ggdcemu.ead |= ((unsigned long)(value&0x03))<<16;
                        NEC98Display.ggdcemu.wg   = (value&0x08) ? TRUE : FALSE;
                        NEC98Display.ggdcemu.dad  = 0x0001 << ((value&0xF0)>>4);
                        ggdcglobs.mask_param[0]  = 
                                (unsigned char)(NEC98Display.ggdcemu.dad&0x00FF);
                        ggdcglobs.mask_param[1]  = 
                                (unsigned char)((NEC98Display.ggdcemu.dad&0xFF00)>>4);
                        ggdc_param_out = ggdc_param_dummy;
                        break;
                default:        
                        assert1(FALSE,"GGDC CSRW param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*:::::::::::::::::::::::   G-GDC CSRR Command   :::::::::::::::::::::::*/

void    ggdc_csrr_com(void)
{
        ggdc_param_out  = ggdc_param_dummy;
        ggdc_data_in    = ggdc_csrr_data1;     /* read data routine set  */
        ggdc_dataready  = 1;                           /* set ggdc data read OK! */
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data1(half_word *value)
{
        ggdc_data_in = ggdc_csrr_data2;
        *value = ggdcglobs.csrw_param[0];
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data2(half_word *value)
{
        ggdc_data_in = ggdc_csrr_data3;
        *value = ggdcglobs.csrw_param[1];
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data3(half_word *value)
{
        ggdc_data_in = ggdc_csrr_data4;
        *value = (ggdcglobs.csrw_param[2] & 0x03);
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data4(half_word *value)
{
        ggdc_data_in = ggdc_csrr_data5;
        *value = ggdcglobs.mask_param[0];
}
/*----------------------------------------------------------------------*/
void    ggdc_csrr_data5(half_word *value)
{
        ggdc_data_in = ggdc_data_dummy;
        *value = ggdcglobs.mask_param[1];
        ggdc_dataready = 0;                            /* set ggdc data read END! */
}

/*:::::::::::::::::::::::   G-GDC MASK Command   :::::::::::::::::::::::*/

void    ggdc_mask_com(void)
{
        ggdc_param_out = ggdc_mask_param;
}
/*----------------------------------------------------------------------*/
void    ggdc_mask_param(half_word value)
{

        ggdcglobs.mask_param[ggdcglobs.ggdc_now.count]   = value;
        ggdcglobs.ggdc_now.param[ggdcglobs.ggdc_now.count] = value;

        switch(ggdcglobs.ggdc_now.count++){
                case 0:
                        NEC98Display.ggdcemu.dad &= 0xFF00;
                        NEC98Display.ggdcemu.dad |= (unsigned short)value;
                        break;
                case 1:
                        NEC98Display.ggdcemu.dad &= 0x00FF;
                        NEC98Display.ggdcemu.dad |= ((unsigned short)value)<<8;
                        ggdc_param_out = ggdc_param_dummy;
                        break;
        default:        
                        assert1(FALSE,"GGDC MASK param count error = %d",
                                ggdcglobs.ggdc_now.count);
        }
}

/*----------------------------------------------------------------------*/
static  unsigned short  write_data;
static  unsigned short  read_data ;
/*----------------------------------------------------------------------*/

/*:::::::::::::::::::::::   G-GDC WRITE Command   ::::::::::::::::::::::*/


void    ggdc_write_com(half_word value)
{
        ggdcglobs.write = value;       /* save last WRITE Command */
        NEC98Display.ggdcemu.whl =  (value&0x18)>>3;
        NEC98Display.ggdcemu.mod =  (value&0x03);
        ggdc_mod_select(&NEC98Display.ggdcemu.mod);

        if(NEC98Display.ggdcemu.slrctl==0){
                switch(NEC98Display.ggdcemu.whl){
                        case 0x00:
                                ggdc_param_out = ggdc_write_word_low;
                                break;
                        case 0x02:
                                ggdc_param_out = ggdc_write_byte_low;
                                break;
                        case 0x03:
                                ggdc_param_out = ggdc_write_byte_high;
                                break;
                        default:
                                ggdc_param_out = ggdc_param_dummy;
                                assert1(FALSE,"GGDC WRITE WHL error = %d",
                                NEC98Display.ggdcemu.whl);
                }
        }else{
                ggdc_param_out = ggdc_param_dummy;
        }
}
/*----------------------------------------------------------------------*/
void    ggdc_write_word_low(half_word value)
{
        ggdc_drawing = DRAWING;
        ggdc_param_out = ggdc_write_word_high;
        write_data = (unsigned short)value;
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_write_word_high(half_word value)
{
        write_data &= 0x00FF;
        write_data |= ((unsigned short)value) << 8;

        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_writing((unsigned short *)&write_data);
        ggdc_read_back_data();

        if(NEC98Display.ggdcemu.dc != 0 ){
                ggdc_param_out = ggdc_write_word_low;
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_param_out = ggdc_param_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_write_byte_low(half_word value)
{
        write_data = (unsigned short)value;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_writing((unsigned short *)&write_data);
        ggdc_read_back_data();

        if(NEC98Display.ggdcemu.dc != 0 ){
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_param_out = ggdc_param_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_write_byte_high(half_word value)
{
        write_data = ((unsigned short)value) << 8;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_writing((unsigned short *)&write_data);
        ggdc_read_back_data();

        if(NEC98Display.ggdcemu.dc != 0 ){
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_param_out = ggdc_param_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}

/*:::::::::::::::::::::::   G-GDC READ Command   :::::::::::::::::::::::*/

void    ggdc_read_com(half_word value)
{
        NEC98Display.ggdcemu.whl =  (value&0x18)>>3;
        NEC98Display.ggdcemu.mod =  (value&0x03);
        ggdcglobs.write &= 0xFC;
        ggdcglobs.write |= NEC98Display.ggdcemu.mod; /* save GGDC mod param */
        ggdc_mod_select(&NEC98Display.ggdcemu.mod);

        if(NEC98Display.ggdcemu.slrctl==0){
                switch(NEC98Display.ggdcemu.whl){
                        case 0x00:
                                ggdc_data_in = ggdc_read_word_low;
                                break;
                        case 0x02:
                                ggdc_data_in = ggdc_read_byte_low;
                                break;
                        case 0x03:
                                ggdc_data_in = ggdc_read_byte_high;
                                break;
                        default:
                                ggdc_data_in = ggdc_data_dummy;
                                assert1(FALSE,"GGDC READ WHL error = %d",
                                NEC98Display.ggdcemu.whl);
                }
        }else{
                ggdc_data_in = ggdc_data_dummy;
        }
}

/*----------------------------------------------------------------------*/
void    ggdc_read_word_low(half_word *value)
{
        ggdc_drawing = DRAWING;
        ggdc_data_in = ggdc_read_word_high;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_reading((unsigned short *)&read_data);
        ggdc_read_back_data();
        *value = (half_word)(read_data&0x00FF);
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_read_word_high(half_word *value)
{

        ggdc_drawing = DRAWING;
        *value = (half_word)((read_data&0xFF00)>>8);
        if(NEC98Display.ggdcemu.dc != 0 ){
                ggdc_data_in = ggdc_read_word_low;
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_data_in = ggdc_data_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_read_byte_low(half_word *value)
{
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_reading((unsigned short *)&read_data);
        ggdc_read_back_data();
        *value = (half_word)(read_data&0x00FF);
        if(NEC98Display.ggdcemu.dc != 0 ){
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_data_in = ggdc_data_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_read_byte_high(half_word *value)
{
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_reading((unsigned short *)&read_data);
        ggdc_read_back_data();
        *value = (half_word)((read_data&0xFF00)>>8);
        if(NEC98Display.ggdcemu.dc != 0 ){
                NEC98Display.ggdcemu.dc --;
        }else{
                ggdc_data_in = ggdc_data_dummy;
                ggdc_init_vectw_param();
        }
        ggdc_drawing = NOTDRAW;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::    G-GDC DRAW ROUTINE CALL     ::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void    ggdc_draw_pixel(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_pixel();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
        
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_line(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;        /*      set drawing start flag  */
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_line();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;        /* reset drawing start flag */
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_gchar(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_text();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_circle(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_arc();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_rect(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_rect();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_slgchar(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        recalc_ggdc_draw_parameter();
        ggdc_send_c_asm((unsigned long *)&drawing_data);
        ggdc_drawing_text();
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}
/*----------------------------------------------------------------------*/
void    ggdc_draw_nothing(void)
{
        ggdc_param_out = ggdc_param_dummy;
        ggdc_drawing = DRAWING;
        ggdc_read_back_data();
        ggdc_init_vectw_param();
        ggdc_drawing = NOTDRAW;
}

/*----------------------------------------------------------------------*/
void    recalc_ggdc_draw_parameter(void)
{
        unsigned char   loop;  /* use loop counter */

        drawing_data.asm_vram = (unsigned long)&drawaddress[0];
        drawing_data.asm_ead = NEC98Display.ggdcemu.ead;
        drawing_data.asm_pitch  = (NEC98Display.modeff2.gdcclock) ? 
                                  (unsigned short)(NEC98Display.ggdcemu.p/2) :
                                  (unsigned short)(NEC98Display.ggdcemu.p  );
        drawing_data.asm_dir = (unsigned long)NEC98Display.ggdcemu.dir;
        drawing_data.asm_dc = NEC98Display.ggdcemu.dc+1;
        drawing_data.asm_d = NEC98Display.ggdcemu.d;
        drawing_data.asm_d2 = NEC98Display.ggdcemu.d2;
        drawing_data.asm_d1 = NEC98Display.ggdcemu.d1;
        drawing_data.asm_dm = NEC98Display.ggdcemu.dm;
        drawing_data.asm_ptn = NEC98Display.ggdcemu.ptn;
        drawing_data.asm_zoom = NEC98Display.ggdcemu.zw+1;
        drawing_data.asm_sl = (NEC98Display.ggdcemu.slrctl==0x12) ? 1 : 0;
        drawing_data.asm_wg = (NEC98Display.ggdcemu.wg) ? 1 : 0;
        drawing_data.asm_maskgdc = NEC98Display.ggdcemu.dad;

        for( loop=0 ; loop<8 ; loop++){
            drawing_data.asm_txt[loop] = NEC98Display.ggdcemu.txt[loop];
        }
}
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::     G-GDC INIT FUNCTIONS     :::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void    ggdc_init_vectw_param(void)
{
        NEC98Display.ggdcemu.dc  =  0x0000; /* DC =  0 */
        NEC98Display.ggdcemu.d   =  0x0008; /* D  =  8 */
        NEC98Display.ggdcemu.d2  =  0x0008; /* D2 =  8 */
        NEC98Display.ggdcemu.d1  =  0x3FFF; /* D1 = -1 */
        NEC98Display.ggdcemu.dm  =  0x3FFF; /* DM = -1 */

        ggdcglobs.vectw_param[ 1]  = 0x00; 
        ggdcglobs.vectw_param[ 2] &= 0x40; 
        ggdcglobs.vectw_param[ 3]  = 0x08; 
        ggdcglobs.vectw_param[ 4]  = 0x00; 
        ggdcglobs.vectw_param[ 5]  = 0x08; 
        ggdcglobs.vectw_param[ 6]  = 0x00; 
        ggdcglobs.vectw_param[ 7]  = 0xFF; 
        ggdcglobs.vectw_param[ 8]  = 0x3F; 
        ggdcglobs.vectw_param[ 9]  = 0xFF; 
        ggdcglobs.vectw_param[10]  = 0x3F; 
}

/*----------------------------------------------------------------------*/
void    ggdc_read_back_data(void)
{
        ggdc_read_back((unsigned long *)&readcsrr);
        NEC98Display.ggdcemu.ead  = readcsrr.lastead;
        NEC98Display.ggdcemu.dad  = readcsrr.lastdad;

        ggdcglobs.csrw_param[0]  = readcsrr.lastcsrr[0];
        ggdcglobs.csrw_param[1]  = readcsrr.lastcsrr[1];
        ggdcglobs.csrw_param[2] &= 0xFC;
        ggdcglobs.csrw_param[2] |= readcsrr.lastcsrr[2];
        ggdcglobs.mask_param[0]  = readcsrr.lastcsrr[3];
        ggdcglobs.mask_param[1]  = readcsrr.lastcsrr[4];
}
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\gvi.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: gvi 
 *
 * Description	: Generic Video Interface Module internal descriptions.
 *
 * Author	: Henry Nash
 *
 * Notes	: The following functions are defined 
 *
 *                gvi_init              - Set up gvi variables
 *                gvi_term              - Close down current video adaptor
 *
 *		  Note that all addresses used by these routines are
 *		  in host address space NOT 8088 address space.		
 *
 *		  The data itself is not passed as a parameter in the
 *		  GVI calls since the 8088 memory to which the calls
 *		  refer may be accessed to obtain the new data.
 *
 *                The default video adapter is CGA.
 *
 * Mods: (r3.4) : The Mac II running MultiFinder and MPW C has a few
 *                problems. One is the difficulty in initialising
 *                static variables of the form:
 *
 *                host_addr x = (host_addr)M;
 *
 *                This is fixed by initialising variables of this type
 *                in in-line code. A crock, but what else can I do?
 */

/*
 * static char SccsID[]="@(#)gvi.c	1.22 8/25/93 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */

#include "xt.h"
#include "bios.h"
#include "sas.h"
#include "error.h"
#include "config.h"
#include "gvi.h"
#include "gmi.h"
#include "cga.h"
#ifdef HERC
#include "herc.h"
#endif
#include "debug.h"
#include "gfx_upd.h"
#ifdef EGG
#include "egagraph.h"
#include "egacpu.h"
#endif /* EGG */
#include "host_gfx.h"

/*
 * External variables
 */

extern int soft_reset;  /* Defined in reset.c                       */

/*
 * Global variables reflecting the state of the currently selected adapter
 * These should be integrated with the new EGA stuff
 */

#if defined(NEC_98)
DISPLAY_GLOBS   NEC98Display;
#else   //NEC_98
DISPLAY_GLOBS	PCDisplay;
#endif  //NEC_98
int text_blk_size;	/* In TEXT mode the size of a dirty block   */

/*
 * Other globals
 */

/*
 * These 4 variables are used by the BIOS & host stuff to indicate where the active
 * adaptor is. NB. The EGA can move!!
 */

host_addr gvi_host_low_regen;
host_addr gvi_host_high_regen;
sys_addr gvi_pc_low_regen;
sys_addr gvi_pc_high_regen;

half_word video_adapter    = NO_ADAPTOR;	/* No adaptor initially */


/*
 * Global routines
 */

void	recalc_screen_params IFN0()
{
#ifdef VGG
	if (get_doubleword_mode())
		set_bytes_per_line(get_chars_per_line()<<3);
	else
#endif
	    if (get_word_addressing())
		set_bytes_per_line(get_chars_per_line()<<1);
	    else
#ifdef V7VGA
		if (get_seq_chain4_mode())
			set_bytes_per_line(get_chars_per_line()<<3);
		else
/*
 * The V7VGA proprietary text modes fall through here, because the V7 card
 * uses so-called byte-mode for them.  This does not affect the PC's
 * view of things, therefore assure that for text modes
 * 	bytes_per_line = 2 * chars_per_line 	
 * always holds.
 */
			if ( is_it_text() )
				set_bytes_per_line(get_chars_per_line()<<1);
			else
#endif /* V7VGA */
#ifdef VGG
				/* Caters for the 'undocumented' VGA modes */
				if (get_256_colour_mode())
					set_bytes_per_line(get_chars_per_line()<<1);
				else
#endif /* VGG */
					set_bytes_per_line(get_chars_per_line());
	/*
	 * This is pretty tacky, but...
	 */
	if (video_adapter==EGA || video_adapter == VGA)
		set_screen_length(get_offset_per_line()*get_screen_height()/get_char_height());
	else
		set_screen_length(get_bytes_per_line()*get_screen_height()/get_char_height());
	set_char_width(8);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

#if defined(NEC_98)
void gvi_init()
{
    video_adapter = 1;  // '1' means NEC98.
    NEC98_init();
    host_clear_screen();
}

void gvi_term IFN0(){}

#else   //NEC_98
void gvi_init IFN1(half_word, v_adapter)
{
    int screen_height;

    /*
     * If this is second or subsequent reset, switch off old video adapter
     * ports before initialising new one.
     */

    if (soft_reset)
        switch (video_adapter) {
#ifdef DUMB_TERMINAL
        case MDA:
            mda_term();
            break;
#endif /* DUMB_TERMINAL */
        case CGA:
#ifdef CGAMONO 
	case CGA_MONO: 
#endif 
            cga_term();
            break;
#ifdef EGG
        case EGA:
	    ega_term();
	    break;
#endif
#ifdef VGG
        case VGA:
	    vga_term();
	    break;
#endif
#ifdef HERC
	case HERCULES:
	    herc_term();
	    break;
#endif
        default:
#ifndef PROD
            fprintf(trace_file, "gvi_term: invalid video adaptor: %d\n",
                    video_adapter);
#endif
	    break;
        }

    /*
     * Set up GVI variables, depending on v_adapter.
     */

    switch (v_adapter) {
    case MDA:
    case CGA:
#ifdef CGAMONO  
    case CGA_MONO:  
#endif
	screen_height = CGA_HEIGHT;
        video_adapter = v_adapter;
        break;
#ifdef HERC
    case HERCULES:
	screen_height = HERC_HEIGHT;
	video_adapter = v_adapter;
	break;
#endif
#ifdef EGG
    case EGA:
	screen_height = EGA_HEIGHT;
        video_adapter = v_adapter;
        break;
#endif
#ifdef VGG
    case VGA:
	screen_height = VGA_HEIGHT;
        video_adapter = v_adapter;
        break;
#endif
    default:
	screen_height = CGA_HEIGHT;
        video_adapter = CGA;    /* Default video adapter */
    }

#ifdef GORE
	/*
	 *	GORE variables must be set up before doing any other
	 *	graphics.
	 */

    init_gore_update();
#endif /* GORE */

/* Setting all these variables should be done in the appropriate xxx_init() */
    switch (video_adapter) {
#ifdef DUMB_TERMINAL
    case MDA:
        mda_init();
        break;
#endif /* DUMB_TERMINAL */
    case CGA:
#ifdef CGAMONO  
    case CGA_MONO:  
#endif
        cga_init();
        break;
#ifdef HERC
    case HERCULES:
	herc_init();
	break;
#endif
#ifdef EGG
    case EGA:
	ega_init();
        break;
#endif
#ifdef VGG
    case VGA:
	vga_init();
        break;
#endif
    default:
        break;
    }

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )
    host_init_adaptor(video_adapter,screen_height);
    host_clear_screen();
#endif	/* !NTVDM | (NTVDM & !X86GFX) */

#ifdef EGA_DUMP
	dump_init(host_getenv( "EGA_DUMP_FILE" ), video_adapter);
#endif
}


void gvi_term IFN0()
{
    switch (video_adapter) {
#ifdef DUMB_TERMINAL
    case MDA:
        mda_term();
        break;
#endif /* DUMB_TERMINAL */
    case CGA:
#ifdef CGAMONO  
    case CGA_MONO:  
#endif
        cga_term();
        break;
#ifdef HERC
    case HERCULES:
	herc_term();
	break;
#endif
#ifdef EGG
    case EGA:
	ega_term();
	break;
#endif
#ifdef VGG
    case VGA:
	vga_term();
	break;
#endif
    case NO_ADAPTOR: /* Do nothing if video_adaptor not initialised */
	break;
    default:
#ifndef PROD
        fprintf(trace_file, "gvi_term: invalid video adaptor: %d\n",
                video_adapter);
#endif
	break;
    }

#ifdef GORE
    term_gore_update();
#endif /* GORE */
}
#endif  //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=video
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc;$(WINDOWS_INC_PATH)

SOURCES=  \
    ..\ega_mode.c      \
    ..\ega_prts.c      \
    ..\ega_vide.c      \
    ..\gfx_updt.c      \
    ..\video.c         \
    ..\gvi.c           \
    ..\video_io.c      \
    ..\v7_ports.c      \
    ..\v7_video.c      \
    ..\vga_mode.c      \
    ..\vga_prts.c      \
    ..\vga_vide.c      \
    ..\ega_read.c      \
    ..\ega_writ.c      \
    ..\ega_dmmy.c      \
    ..\ega_trcr.c      \
    ..\egawrtm0.c      \
    ..\egwrtm12.c      \
    ..\cga.c           \
    ..\tgdc.c          \
    ..\crtc.c          \
    ..\cg.c            \
    ..\ggdc.c

i386_SOURCES=           ..\i386\ggdcdraw.asm

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC

SOURCES_USED=..\sources.inc

!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\gfx_updt.c ===
/*                      INSIGNIA (SUB)MODULE SPECIFICATION
                        -----------------------------


        THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
        NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT                : Display Update Algorithms

DESIGNER                : William Gulland

REVISION HISTORY        :
First version           : date, who

SccsID[]="@(#)gfx_update.c      1.82 06/30/95 Copyright Insignia Solutions Ltd.";

*/

/*
PURPOSE                 : Keep the host screen up to date.
[1.INTERMODULE INTERFACE SPECIFICATION]

[1.1    INTERMODULE EXPORTS]

        DATA         :  give type and name
                        struct _UPDATE_ALG update_alg

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

        STRUCTURES/TYPEDEFS/ENUMS:

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
None
-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]
None.
[1.4.2 EXPORTED OBJECTS]
=========================================================================
GLOBALS           :     describe what exported data objects are
                        accessed and how. Likewise for imported
                        data objects.
                        update_alg - pointers to update functions contained
                        here or elsewhere - eg. host specific update stuff.

                        text_update() - routine to do a text update, by comparing
                        the adaptor regen area with video_copy.

                        cga_graph_update() - routine to do a graphics update, by comparing
                        the adaptor regen area with video_copy.

                        text_scroll_up/down() - scroll portion of the screen in text mode.
                        cga_graph_scroll_up/down() - scroll portion of the screen in cga graphics mode.
=========================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]                                               */

#include "insignia.h"
#include "host_def.h"

#include <stdio.h>
#include StringH
#include "xt.h"
#include "sas.h"
#include "ios.h"
#include CpuH
#include "gmi.h"
#include "gvi.h"
#include "cga.h"
#include "error.h"
#include "config.h"     /* to get defn of MDA! */
#include "trace.h"
#include "debug.h"
#include "gfx_upd.h"
#include "host_gfx.h"
#include "video.h"

#ifdef EGG
#include "egacpu.h"
#include "egagraph.h"
#include "vgaports.h"
#include "egaports.h"
#endif /* EGG */

#ifdef GORE
#include "gore.h"
#endif /* GORE */

#include "ga_mark.h"
#include "ga_defs.h"

/*[3.2 INTERMODULE EXPORTS]                                             */

/*
 * Terminal type.  This is initialised to a set default which is determined
 * in host_graph.h.
 */

int terminal_type = TERMINAL_TYPE_DEFAULT;

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]                                                */

/* [5.1.1 #DEFINES]                                                     */
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_GRAPHICS.seg"
#endif

#if     defined(PROD) || (!defined(EGG))
#define init_dirty_recs()               dirty_next = 0
#else
#define init_dirty_recs()               { dirty_next = 0 ; if (io_verbose & EGA_DISPLAY_VERBOSE) \
                                                trace("--- start collecting update records ---\n",0); }
#endif

#define get_dirty_rec_total()           (dirty_next)
#ifdef VGG
#if     defined(PROD) || (!defined(EGG))
#define add_dirty_rec(line,st,len,off,fr)       {       dirty[dirty_next].line_no = (line); \
                                                dirty[dirty_next].start = (st); \
                                                dirty[dirty_next].end = (st) + (len); \
                                                dirty[dirty_next].video_copy_offset = (off); \
                                                dirty[dirty_next].v7frig = (fr); \
                                                dirty_next++; \
                                        }
#else
#define add_dirty_rec(line,st,len,off,fr)       {       if (io_verbose & EGA_DISPLAY_VERBOSE) {\
                                                        char    trace_string[80]; \
                                                        sprintf(trace_string,"dirty[%d]line_no %d, start %d end %d", \
                                                                                        dirty_next,(line),(st),(st)+(len));\
                                                        trace(trace_string,0); \
                                                } \
                                                dirty[dirty_next].line_no = (line); \
                                                dirty[dirty_next].start = (st); \
                                                dirty[dirty_next].end = (st) + (len); \
                                                dirty[dirty_next].video_copy_offset = (off); \
                                                dirty[dirty_next].v7frig = (fr); \
                                                dirty_next++; \
                                        }
#endif
#else /* VGG */
#if     defined(PROD) || (!defined(EGG))
#define add_dirty_rec(line,st,len,off)  {       dirty[dirty_next].line_no = (line); \
                                                dirty[dirty_next].start = (st); \
                                                dirty[dirty_next].end = (st) + (len); \
                                                dirty[dirty_next].video_copy_offset = (off); \
                                                dirty_next++; \
                                        }
#else
#define add_dirty_rec(line,st,len,off)  {       if (io_verbose & EGA_DISPLAY_VERBOSE) {\
                                                        char    trace_string[80]; \
                                                        sprintf(trace_string,"dirty[%d]line_no %d, start %d end %d", \
                                                                                        dirty_next,(line),(st),(st)+(len));\
                                                        trace(trace_string,0); \
                                                } \
                                                dirty[dirty_next].line_no = (line); \
                                                dirty[dirty_next].start = (st); \
                                                dirty[dirty_next].end = (st) + (len); \
                                                dirty[dirty_next].video_copy_offset = (off); \
                                                dirty_next++; \
                                        }
#endif
#endif /* VGG */

#define get_dirty_line(ind)     (dirty[(ind)].line_no)
#define get_dirty_start(ind)    (dirty[(ind)].start)
#define get_dirty_end(ind)      (dirty[(ind)].end)
#define get_dirty_offset(ind)   (dirty[(ind)].video_copy_offset)
#define clear_dirty()           {setVideodirty_total(0);setVideodirty_low(0x80001);setVideodirty_high(-1);}

#ifdef  NO_STRING_OPERATIONS
#define SET_VGLOBS_MARK_STRING(func)            /*nothing*/
#else
#define SET_VGLOBS_MARK_STRING(func)    setVideomark_string(func);
#endif  /* NO_STRING_OPERATIONS */


/* Parts of update and paint routines assume start of screen memory is on
a 4-byte boundary. This macro makes this true and reports if it wasn't. */
#ifdef PROD
#define ALIGN_SCREEN_START(start) (start &= ~3L)
#else
#define ALIGN_SCREEN_START(start) if (start & 3L) \
        { file_id; printf("Start of screen not 4-byte aligned"); newline; \
        start &= ~3L; }
#endif  /* PROD */

GLOBAL LONG dirty_curs_offs = -1;               /* GLOBAL for JOKER */
GLOBAL LONG dirty_curs_x;
GLOBAL LONG dirty_curs_y;

#ifndef REAL_VGA

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]                        */

/* [5.1.3 PROCEDURE() DECLARATIONS]                                     */

        LOCAL boolean simple_update IPT0();
        boolean dummy_scroll IPT6(int,dummy1,int,dummy2,int,dummy3,
                        int,dummy4,int,dummy5,int,dummy6);
#if defined(NTVDM) && defined(MONITOR)
        boolean mon_text_scroll_up IPT6(sys_addr, start, int, width, int, height, int, attr, int, lines, int, colour);
        boolean mon_text_scroll_down IPT6(sys_addr, start, int, width, int, height, int, attr, int, lines, int, colour);
#endif /* NTVDM & MONITOR */

        LOCAL VOID save_gfx_update_routines IPT0();
        LOCAL VOID inhibit_gfx_update_routines IPT0();

        /* Imports from v7_ports.c */

#ifdef V7VGA
        IMPORT  VOID    draw_v7ptr IPT0();
        IMPORT  VOID    remove_v7ptr IPT0();
        IMPORT  BOOL    v7ptr_between_lines IPT2(int,start_line,int,end_line);
#endif /* V7VGA */


#ifdef  HOST_SCREEN_UPDATES

IMPORT BOOL HostUpdatedVGA IPT0();      /* Called from vga_graph_update() */
IMPORT BOOL HostUpdatedEGA IPT0();      /* ega_graph_update() */

#else   /* HOST_SCREEN_UPDATES */

#define HostUpdatedVGA()        FALSE
#define HostUpdatedEGA()        FALSE

#endif  /* HOST_SCREEN_UPDATES */


/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS                                     */

byte *video_copy;               /* video_copy is now allocated in host_init_screen()'s */

#ifndef macintosh
#ifdef VGG
#ifdef V7VGA
static  DIRTY_PARTS     dirty[768];
#else
static  DIRTY_PARTS     dirty[480];
#endif /* V7VGA */
#else
static  DIRTY_PARTS     dirty[350];
#endif
#else
DIRTY_PARTS     *dirty; /* NB. Allocated as 350*4*sizeof(int) in applInit(). */
#endif

IMPORT half_word bg_col_mask;
static  int     dirty_next=0;

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]                               */

static  int     search_video_copy IFN3(int, start_line,
        int, end_line, int, start_offset)
{
        register        byte    *ptr,*k;
        register        int     j;
        register        int     quarter_opl = get_offset_per_line()>>2;
        byte    *vcopy = &video_copy[start_offset];
        byte save,*end_ptr;

        ptr = vcopy;
        end_ptr = ptr + quarter_opl*(end_line-start_line);
        save = *end_ptr;
        *end_ptr = 1;   /* End marker */
        while(ptr < end_ptr)
        {
                if(!*ptr)
                        do {; } while (!(*++ptr));
                if(ptr >= end_ptr)break;
                /* Work out where in line we've reached */
                j = (int)((ptr - vcopy)%quarter_opl);
                /*
                 * Have found a dirty line. Find width
                 */
                for ( k= ptr+quarter_opl-j-1; *k == 0 ; k-- ) ; /* We know *ptr != 0, so k will stop at ptr */
#ifdef VGG
                add_dirty_rec((int)((ptr-vcopy)/quarter_opl)+start_line,
                              j<<2, (int)(k-ptr+1)<<2, ptr-video_copy-j,0);
#else
                add_dirty_rec((int)((ptr-vcopy)/quarter_opl)+start_line,
                              j<<2, (int)(k-ptr+1)<<2, ptr-video_copy-j);
#endif /* VGG */

                ptr += quarter_opl - j;
                /*
                 * Don't clear out the marked area in case the plane wraps
                 */
        }
        *end_ptr = save;
        return( get_dirty_rec_total() );
}

#ifdef VGG

/*
 *      Special version of search_video_copy() for the Video 7 Extended Modes 60h & 61h
 *      and 'undocumented' VGA mode which have chars_per_line of 90 & 94 which don't seem
 *  to be multiples of 4.  Interestingly, Zany Golf ( EGA, Mode 14 ) also ends up
 *  calling this code.
 */

static  int     v7_search_video_copy IFN3(int, start_line,
        int, end_line, int, start_offset)
{
        register        byte    *ptr,*k;
        register        int     j;
        register        int     half_opl = get_offset_per_line()>>1;
        register        int     quarter_opl = get_offset_per_line()>>2;
        byte    *vcopy = &video_copy[start_offset];
        byte save,*end_ptr;
        long length;
        int bodge = 0;

        if (start_line & 1)
                bodge = 2;
        ptr = vcopy;

        /*
         * This calculation sets end_ptr slightly too high to
         * ensure that all the dirty areas get found.
         */

        end_ptr = ptr + (half_opl*(end_line-start_line+1))/2;

        save = *end_ptr;
        *end_ptr = 1;   /* End marker */
        while(ptr < end_ptr)
        {
                if(!*ptr)
                {
                        while (!(*++ptr));
                }
                if(ptr >= end_ptr)break;
                /* Work out where in line we've reached */
                j = (int)((ptr - vcopy)%half_opl);
                /*
                 * Have found a dirty line. Find width
                 */
                for ( k= ptr+half_opl-j-1; *k == 0 ; k-- ) ; /* We know *ptr != 0, so k will stop at ptr */

                length = k-ptr+1;
                if (j <= quarter_opl)
                {
                        if (length > quarter_opl-j)
                        {
                                add_dirty_rec((int)(2*(ptr-vcopy)/half_opl)+start_line,
                                j<<2, (int)(half_opl-2*j)<<1, ptr-video_copy-j,bodge);
                                add_dirty_rec((int)(2*(ptr-vcopy)/half_opl)+start_line+1,
                                0, ((int)(j+length-quarter_opl)<<2)-2, ptr-video_copy-j+quarter_opl,2+bodge);
                        }
                        else
                        {
                                add_dirty_rec((int)(2*(ptr-vcopy)/half_opl)+start_line,
                                j<<2, (int)(length)<<2, ptr-video_copy-j,bodge);
                        }
                }
                else
                {
                        add_dirty_rec((int)(2*(ptr-vcopy)/half_opl)+start_line,
                             (j-quarter_opl-1)<<2, (int)((length)<<2), ptr-video_copy-j+quarter_opl,2+bodge);
                }

                ptr += half_opl - j;
                /*
                 * Don't clear out the marked area in case the plane wraps
                 */
        }
        *end_ptr = save;
        return( get_dirty_rec_total() );
}
#endif /* VGG */

static  int     search_video_copy_aligned IFN3(int, start_line,
        int, end_line, int, start_offset)
{
        register        unsigned int *ptr4;
        register        byte    *ptr,*k;
        register        int     j;
        register        int     quarter_opl = get_offset_per_line()>>2;
        byte    *vcopy = &video_copy[start_offset];
        byte save,*end_ptr;

        ptr = vcopy;
        end_ptr = ptr + quarter_opl*(end_line-start_line);
        save = *end_ptr;
        *end_ptr = 1;   /* End marker */
        while(ptr < end_ptr)
        {
                ptr4 = (unsigned int *)(ptr-4);
                do {; } while (!(*++ptr4));
                ptr = (byte *)ptr4;
                if(!*ptr)
                        do {; } while (!(*++ptr));
                if(ptr >= end_ptr)break;
                /* Work out where in line we've reached */
                j = (int)((ptr - vcopy)%quarter_opl);
                /*
                 * Have found a dirty line. Find width
                 */
                for ( k= ptr+quarter_opl-j-1; *k == 0 ; k-- ) ; /* We know *ptr != 0, so k will stop at ptr */
#ifdef VGG
                add_dirty_rec((int)((ptr-vcopy)/quarter_opl)+start_line,
                              j<<2, (int)(k-ptr+1)<<2, ptr-video_copy-j,0);
#else
                add_dirty_rec((int)((ptr-vcopy)/quarter_opl)+start_line,
                              j<<2, (int)(k-ptr+1)<<2, ptr-video_copy-j);
#endif /* VGG */
                ptr += quarter_opl - j;
                /*
                 * Don't clear out the marked area in case the plane wraps
                 */
        }
        *end_ptr = save;
        return( get_dirty_rec_total() );
}

static  void    paint_records IFN2(int, start_rec, int, end_rec)
{
        register        DIRTY_PARTS     *i,*end_ptr;
#ifdef VGG
        int dirty_frig;
#endif /* VGG */

        i= &dirty[start_rec];
        end_ptr =  &dirty[end_rec];
        while (i<end_ptr) {
                register        int     last_line, cur_start, cur_end,max_width;
                int     first_line;
                long    dirty_vc_offset;

                first_line = i->line_no;
                last_line = first_line;
                cur_start = i->start;
                cur_end = i->end;
                max_width = (cur_end-cur_start) << 1;   /* To split up diagonal lines */

                /*
                 * offset in bytes into video_copy, which is quarter offset into plane at start of this rectangle
                 */

                dirty_vc_offset = i->video_copy_offset;
#ifdef VGG
                dirty_frig = i->v7frig; /* for the V7 modes with chars_per_line not a multiple of 4 */
#endif /* VGG */
                i++;
                while (i < end_ptr) {
                        if ( i->line_no - last_line < 3 ) {
                                /*
                                 * This entry can be included into the same paint
                                 * as long as it doesn't make the rectangle too wide
                                 */

                                if ( i->end > cur_end ){
                                        if(i->end - cur_start > max_width)break;
                                        cur_end = i->end;
                                }
                                if ( i->start < cur_start ){
                                        if(cur_end - i->start > max_width)break;
                                        cur_start = i->start;
                                }
                                last_line = i->line_no;
                                i++;
                        }
                        else
                          break;
                }
                /*
                 * paint the rectangle found
                 */

                /* do not paint beyond the right hand side of the screen;
                   these checks were put in to cope with the special
                   case of the brain-scan display in 'EGAWOW' */
                if (cur_end > get_bytes_per_line())
                        cur_end = get_bytes_per_line();
#ifdef VGG
                if (cur_end > cur_start)
                        (*paint_screen)((dirty_vc_offset<<2) + dirty_frig + cur_start,
                        cur_start<<3, first_line, cur_end-cur_start,
                        last_line-first_line+1);
#else
                if (cur_end > cur_start)
                        (*paint_screen)((dirty_vc_offset<<2) + cur_start,
                        cur_start<<3, first_line, cur_end-cur_start,
                        last_line-first_line+1);
#endif /* VGG */
        }
        /* Clear out video copy */
        for(i = &dirty[start_rec];i<end_ptr;i++)
        {
                register byte *j,*end;
                end = &video_copy[ i->video_copy_offset+(i->end>>2)];
#ifdef VGG
                j =  &video_copy[ i->video_copy_offset+(i->start>>2)+i->v7frig];
#else
                j =  &video_copy[ i->video_copy_offset+(i->start>>2)];
#endif /* VGG */
                do *j++ = 0; while(j<end);
        }
}

#ifdef BIGEND
#define get_char_attr(unsigned_long_ptr)     ((*(unsigned_long_ptr)) >> 16)
#else
#define get_char_attr(unsigned_long_ptr)     (((*(unsigned_long_ptr)) & 0xffff))
#endif

#ifdef EGG

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

static  int     ega_text_find_dirty_lines IFN5(byte *, vcopy, byte *, planes,
        int, start_line, int, end_line, int, screen_start)
{
        register        int     i,j,k;
        register        unsigned short  shorts_per_line=(unsigned short)get_chars_per_line();
        register        int     offset,cur_y;
        register        int     char_height=get_host_char_height();
        register        int     opl=get_offset_per_line();
        register        IU32    *from;
        register        USHORT  *to;

        for(i=start_line,offset=0,cur_y=start_line*char_height; i<end_line;
                                                i++,offset += opl, cur_y += char_height )
        {
                to = (USHORT *) &vcopy[offset];
                from = (IU32 *) &planes[(offset<<1)];
                for(j=0;j<shorts_per_line;j++)
                {
                        if(*to++ != get_char_attr(from++))
                        {
                                to--;from--;
                                for(k=shorts_per_line-1-j;*(to+k) == get_char_attr(from+k);k--)
                                        ;

                                /*
                                * Note: For text mode there is one char for every word.
                                * no of bytes into screen=line*bytes_per_line + ints_into_line*4
                                * x_coord=width_of_one_char*(no_of_ints_into_line*2)
                                * y_coord=height_of_one_char*2*line
                                * The host y co-ords are doubled
                                */

#ifdef VGG
                                add_dirty_rec(cur_y,j<<2,(k<<1)+2,screen_start+(offset<<1),0);
#else
                                add_dirty_rec(cur_y,j<<2,(k<<1)+2,screen_start+(offset<<1));
#endif /* VGG */
                                break;  /* onto next line */
                        }
                }
        }
        return( get_dirty_rec_total() );
}

static  void    ega_text_paint_dirty_recs IFN2(int, start_rec, int, end_rec)
{
        register        int     char_wid = get_pix_char_width()>>1;
        register        int     i;
        register        int     length;
        register        USHORT *to,*from;

        for (i=start_rec;i<end_rec;i++)
        {
                length = get_dirty_end(i)-get_dirty_start(i);

                (*paint_screen)(get_dirty_offset(i)+get_dirty_start(i),
                (get_dirty_start(i)>>1)*char_wid,get_dirty_line(i), length, 1);

                length >>= 1;
                to = (USHORT *) &video_copy[(get_dirty_offset(i)+
                                                                          get_dirty_start (i))>>1];

                from = (USHORT *)get_screen_ptr(get_dirty_offset(i)+get_dirty_start(i));

                while ( length-- > 0 )
                {
                        *to++ = *from;          /* char and attribute bytes */
                        from += 2;                      /* skip over the planes 2,3 */
                }
        }
}

#endif /* EGG */

#ifdef SEGMENTATION                     /* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

#endif /* REAL_VGA */

VOID remove_old_cursor IFN0()
{
        if( dirty_curs_offs >= 0 )
        {
                sub_note_trace2( ALL_ADAPT_VERBOSE,
                                "remove_old_cursor x=%d, y=%d", dirty_curs_x, dirty_curs_y );

                (*paint_screen)( dirty_curs_offs, dirty_curs_x * get_pix_char_width(),
                                                                dirty_curs_y * get_host_char_height(), 2 );

                dirty_curs_offs = -1;
        }
}


GLOBAL VOID
simple_handler IFN0()
{
        setVideodirty_total(getVideodirty_total() + 1);
}

LOCAL   boolean simple_update IFN0()
{
        setVideodirty_total(getVideodirty_total() + 1);
        return( FALSE );
}

LOCAL VOID simple_update_b_move IFN4(UTINY *, laddr, UTINY *, haddr,
                                UTINY *, src, UTINY, src_type)
{
        UNUSED(laddr);
        UNUSED(haddr);
        UNUSED(src);
        UNUSED(src_type);

        setVideodirty_total(getVideodirty_total() + 1);
}

MEM_HANDLERS vid_handlers =
{
        simple_handler,
        simple_handler,
        simple_handler,
        simple_handler,
        simple_update_b_move,
        simple_handler
};

GLOBAL void dummy_calc IFN0()
{
}

/*
[7.1 INTERMODULE DATA DEFINITIONS]                              */

UPDATE_ALG update_alg =
{
        (T_mark_byte)simple_update,
        (T_mark_word)simple_update,
        (T_mark_fill)simple_update,
        (T_mark_wfill)simple_update,
        (T_mark_string)simple_update,
        dummy_calc,
        dummy_scroll,
        dummy_scroll,
};

#ifndef REAL_VGA

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]                         */


/*
==========================================================================
FUNCTION        :       flag_mode_change_required()
PURPOSE         :       Flag that a mode change is imminent and set the
                        scrolling routines to dummies to avoid scrolling
                        using routines for the wrong mode.
EXTERNAL OBJECTS:
RETURN VALUE    :       None
INPUT  PARAMS   :       None
RETURN PARAMS   :       None
==========================================================================
*/

void    flag_mode_change_required IFN0()
{
    set_mode_change_required(YES);

    update_alg.mark_byte = (T_mark_byte)simple_update;
    update_alg.mark_word = (T_mark_word)simple_update;
    update_alg.mark_fill = (T_mark_fill)simple_update;
    update_alg.mark_wfill = (T_mark_wfill)simple_update;
    update_alg.mark_string = (T_mark_string)simple_update;

    update_alg.scroll_up = dummy_scroll;
    update_alg.scroll_down = dummy_scroll;
}


/*
==========================================================================
FUNCTION        :       reset_paint_routines()
PURPOSE         :       Reset paint routines to dummies to ensure
                        there are no problems painting the screen
                        using incorrect routines during reboot.
EXTERNAL OBJECTS:
RETURN VALUE    :       None
INPUT  PARAMS   :       None
RETURN PARAMS   :       None
==========================================================================
*/

void    reset_paint_routines IFN0()
{
    set_mode_change_required(YES);

    update_alg.calc_update = dummy_calc;
    update_alg.scroll_up = dummy_scroll;
    update_alg.scroll_down = dummy_scroll;
}

/*
 * Update the window to look like the regen buffer says it should
 */
#ifdef EGG

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

void    ega_wrap_split_text_update IFN0()
{
        register int i;                         /* Loop counter         */
        register USHORT *from,*to;
        register int cur_ypos;
        int     lines_per_screen;
        int     offset;
        int     screen_start;
        int     split_line;

        if (getVideodirty_total() == 0 || get_display_disabled() )
                return;

        host_start_update();

        screen_start=get_screen_start() << 2;

        ALIGN_SCREEN_START(screen_start);

        lines_per_screen = get_screen_length()/get_offset_per_line();
        split_line = (get_screen_split()+(get_char_height()>>1))/get_char_height();

        if (split_line>lines_per_screen)
                split_line=lines_per_screen;

        to = (USHORT *) &video_copy[screen_start >> 1];
        from = (USHORT *) get_screen_ptr(screen_start);

        if( getVideodirty_total() > 1500 )      /* paint the whole lot */
        {
                int     no_of_split_lines = lines_per_screen - split_line;
                int     limit;

                cur_ypos = 0;

                if( screen_start + (get_screen_length() << 1) > 4 * EGA_PLANE_DISP_SIZE )
                {
                        note_display_state0("Split screen and wrapping !!");

                        limit = (4 * EGA_PLANE_DISP_SIZE - screen_start) >> 2;

                        for( i = 0; i < limit; i++ )
                        {
                                *to++ = *from;
                                from += 2;
                        }

                        to = (USHORT *) &video_copy[0];
                        from = (USHORT * ) get_screen_ptr(0);
                        limit = (screen_start + ((get_screen_length() - 2 * EGA_PLANE_DISP_SIZE) << 1)) >> 2;

                        for( i = 0; i < limit; i++ )
                        {
                                *to++ = *from;
                                from += 2;
                        }
                        limit = 4 * EGA_PLANE_DISP_SIZE;
                        for( i = 0, offset = screen_start; offset < limit;
                                i++, offset += (get_offset_per_line() << 1 ))
                        {
                                (*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
                                cur_ypos += get_host_char_height();
                        }

                        for( i = 0, offset = 0; i < split_line;
                                                        i++, offset += (get_offset_per_line() << 1 ))
                        {
                                (*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
                                cur_ypos += get_host_char_height();
                        }
                }
                else
                {
                        to = (USHORT *) &video_copy[screen_start >> 1];
                        from = (USHORT * ) get_screen_ptr(screen_start);
                        limit = (split_line * get_offset_per_line()) >> 1;

                        for( i = 0; i < limit; i++ )
                        {
                                *to++ = *from;
                                from += 2;
                        }

                        for( i = 0, offset = screen_start; i < split_line;
                                                        i++, offset += (get_offset_per_line() << 1 ))
                        {
                                (*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
                                cur_ypos += get_host_char_height();
                        }
                }

                if( no_of_split_lines > 0 )
                {
                        to = (USHORT *) &video_copy[0];
                        from = (USHORT * ) get_screen_ptr(0);
                        limit = (no_of_split_lines * get_offset_per_line()) >> 1;

                        for( i = 0; i < limit; i++ )
                        {
                                *to++ = *from;
                                from += 2;
                        }

                        for( i = split_line, offset = 0; i < lines_per_screen;
                                                        i++, offset += (get_offset_per_line() << 1 ))
                        {
                                (*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
                                cur_ypos += get_host_char_height();
                        }
                }
        }
        else
        {
                if( screen_start + (get_screen_length() << 1) > 4 * EGA_PLANE_DISP_SIZE )
                {
                        register        int     wrap_line =
                                        (4 * EGA_PLANE_DISP_SIZE - screen_start) / (get_offset_per_line() << 1);
                        int     next,next1,next2;

                        note_display_state0("Its a text wrap!");

                        init_dirty_recs();

                        next = ega_text_find_dirty_lines(&video_copy[screen_start >> 1],
                                                        get_screen_ptr(screen_start), 0,
                                                                                wrap_line, screen_start );

                        next1 = ega_text_find_dirty_lines(&video_copy[0],
                                                get_screen_ptr(0), wrap_line, split_line, 0 );

                        next2 = ega_text_find_dirty_lines(&video_copy[0],
                                                get_screen_ptr(0), split_line, lines_per_screen, 0 );

                        ega_text_paint_dirty_recs(0,next);
                        ega_text_paint_dirty_recs(next,next1);
                        ega_text_paint_dirty_recs(next1,next2);
                }
                else
                {
                        int     next,next1;

                        init_dirty_recs();
                        next = ega_text_find_dirty_lines( &video_copy[screen_start >> 1],
                                        get_screen_ptr(screen_start), 0, split_line, screen_start );

                        next1 = ega_text_find_dirty_lines( &video_copy[0], get_screen_ptr(0),
                                                                        split_line, lines_per_screen, 0 );

                        ega_text_paint_dirty_recs(0,next);
                        ega_text_paint_dirty_recs(next,next1);
                }
        }

        host_end_update();

        setVideodirty_total(0);
}

void    ega_split_text_update IFN0()
{
        register int i;                         /* Loop counter         */
        register USHORT *from,*to;
        register int cur_ypos;
        int     lines_per_screen;
        int     offset;
        int     screen_start;
        int     split_line;

        if (getVideodirty_total() == 0 || get_display_disabled() )
                return;

        host_start_update();

        screen_start = get_screen_start() << 2;

        ALIGN_SCREEN_START(screen_start);

        lines_per_screen = get_screen_length()/get_offset_per_line();

        split_line = (get_screen_split()+(get_char_height()>>1))/get_char_height();

        if( split_line > lines_per_screen )
                split_line = lines_per_screen;

        to = (USHORT *) &video_copy[screen_start >> 1];
        from = (USHORT *) get_screen_ptr(screen_start);

        if( getVideodirty_total() > 1500 )      /* paint the whole lot */
        {
                int     no_of_split_lines = lines_per_screen - split_line;

                sub_note_trace2( EGA_DISPLAY_VERBOSE,
                        "split line %d (lines_per_screen %d)", split_line, lines_per_screen);
                sub_note_trace1( EGA_DISPLAY_VERBOSE, "screen split %d", get_screen_split() );

                cur_ypos = 0;

                for( i = 0; i < (split_line * get_offset_per_line()) >> 1; i++ )
                {
                        *to++ = *from;
                        from += 2;
                }

                for( i = 0, offset = screen_start; i < split_line;
                                                        i++, offset += ( get_offset_per_line() << 1 ))
                {
                        (*paint_screen)( offset, 0, cur_ypos, get_bytes_per_line(), 1 );
                        cur_ypos += get_host_char_height();
                }

                if( no_of_split_lines > 0 )
                {
                        to = (USHORT *) &video_copy[0];
                        from = (USHORT *) get_screen_ptr(0);

                        for( i = 0; i < (no_of_split_lines * get_offset_per_line()) >> 1; i++ )
                        {
                                *to++ = *from;
                                from += 2;
                        }

                        for( i = split_line, offset = 0; i < lines_per_screen;
                                                                        i++, offset += ( get_offset_per_line() << 1 ))
                        {
                                (*paint_screen)( offset, 0, cur_ypos, get_bytes_per_line(), 1);
                                cur_ypos += get_host_char_height();
                        }
                }
        }
        else
        {
                int     next,next1;

                assert0( FALSE, "ega_split_text - partial update" );

                init_dirty_recs();

                next = ega_text_find_dirty_lines( &video_copy[screen_start >> 1],
                                        get_screen_ptr(screen_start) , 0, split_line, screen_start );

                next1 = ega_text_find_dirty_lines( &video_copy[0], get_screen_ptr(0),
                                                                split_line, lines_per_screen, 0 );

                ega_text_paint_dirty_recs(0,next);
                ega_text_paint_dirty_recs(next,next1);
        }

        host_end_update();

        setVideodirty_total(0);
}

void ega_wrap_text_update IFN0()
{
        register int i;                         /* Loop counter         */
        register USHORT *from,*to;
        register int cur_ypos;
        int     lines_per_screen;
        int     offset;
        int     screen_start;

        if (getVideodirty_total() == 0 || get_display_disabled() )
                return;

        host_start_update();

        screen_start=get_screen_start() << 2;

        ALIGN_SCREEN_START(screen_start);

        lines_per_screen = get_screen_length()/get_offset_per_line();

        if( getVideodirty_total() > 1500 )      /* paint the whole lot */
        {
                to = (USHORT *) &video_copy[screen_start >> 1];
                from = (USHORT *) get_screen_ptr(screen_start);

                for( i = get_screen_length() >> 1; i > 0; i-- )
                {
                        *to++ = *from;
                        from += 2;
                }

                cur_ypos = 0;

                if( screen_start + (get_screen_length() << 1) > 4 * EGA_PLANE_DISP_SIZE )
                {
                        register        int     leftover;
                        int     limit;

                        note_display_state0("Wrapping text");

                        limit = 4 * EGA_PLANE_DISP_SIZE;
                        for( offset = screen_start; offset < limit;
                                                        offset+=(get_offset_per_line() << 1) )
                        {
                                (*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
                                cur_ypos += get_host_char_height();
                        }

                        leftover = screen_start
                                + ((get_screen_length() - 2 * EGA_PLANE_DISP_SIZE) << 1);

                        for( offset = 0; offset < leftover;
                                                offset += ( get_offset_per_line() << 1 ))
                        {
                                (*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
                                cur_ypos += get_host_char_height();
                        }
                }
                else
                {
                        for( offset = screen_start;
                                        offset < screen_start + (get_screen_length() << 1);
                                                                offset += ( get_offset_per_line() << 1 ))
                        {
                                (*paint_screen)( offset, 0, cur_ypos, get_bytes_per_line(), 1 );
                                cur_ypos += get_host_char_height();
                        }
                }
        }
        else
        {
                if( screen_start + (get_screen_length() << 1) > 4 * EGA_PLANE_DISP_SIZE )
                {
                        int     next,next1;
                        int     lines_left = (screen_start +
                                        ((get_screen_length() - 2 * EGA_PLANE_DISP_SIZE) << 1)) /
                                                                                (get_offset_per_line() << 1);

                        note_display_state0("Wrapping text");

                        init_dirty_recs();
                        next = ega_text_find_dirty_lines( &video_copy[screen_start >> 1],
                                                get_screen_ptr(screen_start), 0,
                                                        lines_per_screen - lines_left, screen_start);

                        next1 = ega_text_find_dirty_lines( video_copy, get_screen_ptr(0),
                                                lines_per_screen - lines_left, lines_per_screen, 0 );

                        ega_text_paint_dirty_recs(0,next);
                        ega_text_paint_dirty_recs(next,next1);
                }
                else
                {
                        register        int     next;

                        init_dirty_recs();
                        next = ega_text_find_dirty_lines( &video_copy[screen_start >> 1],
                                                get_screen_ptr(screen_start), 0,
                                                        lines_per_screen, screen_start);

                        ega_text_paint_dirty_recs(0,next);
                }
        }

        host_end_update();

        setVideodirty_total(0);
}

void ega_text_update IFN0()
{
        register int i;                         /* Loop counter         */
        register USHORT *from,*to;
        register int cur_ypos;
        int     lines_per_screen;
        int     offset;
        int     screen_start;

        if (getVideodirty_total() == 0 || get_display_disabled() )
                return;

        host_start_update();

        screen_start=get_screen_start()<<2;

        ALIGN_SCREEN_START(screen_start);

        lines_per_screen = get_screen_length()/get_offset_per_line();

        if(getVideodirty_total()>1500)  /* paint the whole lot */
        {
                to = (USHORT *)&video_copy[screen_start>>1];
                from = (USHORT *) get_screen_ptr(screen_start);

                for(i=get_screen_length()>>1;i>0;i--)
                {
                        *to++ = *from;  /* char and attribute bytes */
                        from += 2;              /* planes 2,3 interleaved */
                }

                cur_ypos = 0;
                for(offset=screen_start;offset<screen_start+(get_screen_length()<<1);
                                                                        offset+=(get_offset_per_line()<<1) )
                {
                        (*paint_screen)(offset,0,cur_ypos,get_bytes_per_line(), 1);
                        cur_ypos += get_host_char_height();
                }
        }
        else
        {
                register        int     next;

                init_dirty_recs();
                next = ega_text_find_dirty_lines( &video_copy[screen_start>>1],
                        get_screen_ptr(screen_start), 0, lines_per_screen, screen_start);

                ega_text_paint_dirty_recs(0,next);

                remove_old_cursor();
        }

        setVideodirty_total(0);

        if (is_cursor_visible())
        {
                half_word attr;

                dirty_curs_x = get_cur_x();
                dirty_curs_y = get_cur_y();

                dirty_curs_offs = screen_start+dirty_curs_y * (get_offset_per_line()<<1) + (dirty_curs_x<<2);
                attr = *(get_screen_ptr(dirty_curs_offs + 1));

                host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
        }

        host_end_update();
}
#endif /* EGG */

#ifdef SEGMENTATION                     /* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

/*
 * Update the window to look like the regen buffer says it should
 */

void text_update IFN0()
{

    register int i;     /* Loop counters                */
    register int j,k;
    register IU32 *from,*to;
    register int ints_per_line = get_bytes_per_line()>>2;
    register int cur_ypos;
    int lines_per_screen;
    int offset,len,x,screen_start;
    USHORT *wfrom;
    USHORT *wto;

    if (getVideodirty_total() == 0 || get_display_disabled() )
        return;

    lines_per_screen = get_screen_length()/get_bytes_per_line();

    host_start_update();
    screen_start=get_screen_start()<<1;
    ALIGN_SCREEN_START(screen_start);
    to = (IU32 *)&video_copy[screen_start];
    from = (IU32 *) get_screen_ptr(screen_start);

    if(getVideodirty_total()>1500)      /* paint the whole lot */
    {
            for(i=get_screen_length()>>2;i>0;i--)*to++ = *from++;
            cur_ypos = 0;
            for(offset=0;offset<get_screen_length();offset+=get_bytes_per_line() )
            {
                    (*paint_screen)(screen_start+offset,0,cur_ypos,get_bytes_per_line(), 1);
                    cur_ypos += get_host_char_height();
            }
   }
   else
   {
           for(i=0;i<lines_per_screen;i++)
           {
            for(j=0;j<ints_per_line;j++)
            {
                if(*to++ != *from++)
                {
                    to--;from--;
                    for(k=ints_per_line-1-j;*(to+k)== *(from+k);k--){};
                    /*
                     * Note: For text mode there is one char for every word.
                     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
                     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
                     * y_coord=height_of_one_char*2*line
                     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
                     * The host y co-ords are doubled
                     */

                    /* one or more ints of data are now selected
                       but refine difference to words (i.e. characters),
                       to avoid a glitch on the screen when typing in to
                       a dumb terminal  */

                    offset = i * get_bytes_per_line() + (j<<2);
                    len    = (k<<2) + 4;
                    x      = (j<<1) * get_pix_char_width();
                    wfrom = (USHORT *)from;
                    wto   = (USHORT *)to;
                    if (*wfrom == *wto)
                    {
                        offset += 2;
                        x += get_pix_char_width();
                        len -= 2;
                    }
                    wfrom += (k<<1) + 1;
                    wto   += (k<<1) + 1;
                    if (*wfrom == *wto)
                    {
                        len -= 2;
                    }

                    (*paint_screen)(offset+screen_start,x,i*get_host_char_height(),len, 1);

                    for(k=j;k<ints_per_line;k++)
                        *to++ = *from++;
                    break;      /* onto next line */
                }
            }
          }

        remove_old_cursor();
   }    /* end if(getVideodirty_total()>1500) */

    setVideodirty_total(0);

    if (is_cursor_visible())
    {
                half_word attr;

                dirty_curs_x = get_cur_x();
                dirty_curs_y = get_cur_y();

                dirty_curs_offs = screen_start+dirty_curs_y * get_offset_per_line() + (dirty_curs_x<<1);
                attr = *(get_screen_ptr(dirty_curs_offs + 1));

                host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
    }

    host_end_update();
}

/*
 * Update the physical screen to reflect the CGA regen buffer
 */

LOCAL VOID
cga_graph_update_unchained IFN0()
{
    LONG i, j, k, l;    /* Loop counters                */
    IU32 *from,*to;
    LONG cur_ypos;
    LONG offs;

    if (getVideodirty_total() == 0 || get_display_disabled() ) return;

    host_start_update();

        /*
         * Graphics mode
         */

        to = (IU32 *)&video_copy[0];
        from = (IU32 *) get_screen_ptr(0);

        if (getVideodirty_total() > 5000)
        {
            /*
             * Refresh the whole screen from the regen buffer
             */

                for(i=4096;i>0;i--)
                {
                        *to++ = *from++;
                }

            for (cur_ypos = 0,offs=0; cur_ypos < 400; offs += SCAN_LINE_LENGTH, cur_ypos += 4)
            {
                (*paint_screen)(offs,0,cur_ypos,SCAN_LINE_LENGTH,1);
                (*paint_screen)((offs+ODD_OFFSET),0,cur_ypos+2,SCAN_LINE_LENGTH,1);
            }
        }
        else
        {
                /*
                 * Draw the dirtied blocks
                 */

                /* do even lines */

                for (i = 0; i < 100; i++ )
                {
                        for(j=20;j>0;j--)
                        {
                                if(*to != *from)
                                {
                                        for(k=j-1;*(to+k)== *(from+k);k--)
                                                ;

                                /*
                                 * i is pc scanline no/2,
                                 * so offset=(i*SCAN_LINE_LENGTH + bytes_into_line)*inc_count
                                 * host_x = bytes_into_line*8   -- 8 pixels per byte
                                 * host_y = i*2*2               -- to convert pc scanlines to host ones
                                 * length = k                   -- plus one to counteract k-- in loop
                                 */

                                        (*paint_screen)
                                                (((i*SCAN_LINE_LENGTH+((20-j)<<2))),
                                                                                        (20-j)<<5,i<<2,(k<<2)+4,1);

                                        for(l=k+1;l>0;l--)
                                        {
                                                *to++ = *from++;
                                        }

                                        l = j - k - 1;
                                        to += l;
                                        from += l;

                                        break;  /* onto next line */
                                }

                                to++;
                                from++;
                        }
                }

                /* do odd  lines */

                from = (IU32 *) get_screen_ptr(ODD_OFFSET);
                to = (IU32 *)&video_copy[ODD_OFFSET];

                for (i = 0; i < 100; i++ )
                {
                        for(j=20;j>0;j--)
                        {
                                if(*to != *from)
                                {
                                        for(k=j-1;*(to+k)== *(from+k);k--)
                                                ;
                                        /*
                                         * i=line_no/2
                                         * j=bytes_from_end => (80-j)=bytes from start of line
                                         * k=no of bytes less 1 different => length in bytes=k+1
                                         * offset=(i*SCAN_LINE_LENGTH+OFFSET_TO_ODD_BANK+
                                         *                                               (80-j))*inc_count
                                         */

                                        (*paint_screen)(
                                        ((i*SCAN_LINE_LENGTH+ODD_OFFSET+((20-j)<<2))),
                                                                                        (20-j)<<5,(i<<2)+2,(k<<2)+4,1);

                                        for(l=k+1;l>0;l--)
                                        {
                                                *to++ = *from++;
                                        }

                                        l = j - k - 1;
                                        to += l;
                                        from += l;

                                        break;  /* onto next line */
                                }

                                to++;
                                from++;
                        }
                }
        }

    host_end_update();

    setVideodirty_total(0);
}

#ifdef  EGG
LOCAL VOID
cga_graph_update_chain2 IFN0()
{
    LONG i, j, k, l;    /* Loop counters                */
    USHORT *from,*to;
    LONG cur_ypos;
    LONG offs;
        SHORT start_line, end_line;

        if (getVideodirty_total() == 0 || get_display_disabled() )
                return;

    host_start_update();

        /*
         * Graphics mode
         */

        to = (USHORT *)&video_copy[0];
        from = (USHORT *) get_screen_ptr(0);

        if (getVideodirty_total() > 5000)
        {
                /*
                 * Refresh the whole screen from the regen buffer
                 */

                for(i=4096*2;i>0;i--)
                {
                        *to++ = *from;
                        from += 2;
                }

                for (cur_ypos = 0,offs=0; cur_ypos < 400;
                        offs += SCAN_LINE_LENGTH, cur_ypos += 4)
                {
                        (*paint_screen)(offs<<1,0,cur_ypos,SCAN_LINE_LENGTH,1);
                        (*paint_screen)((offs+ODD_OFFSET)<<1,0,cur_ypos+2,
                                        SCAN_LINE_LENGTH,1);
                }
        }
        else
        {
                /*
                 * Draw the dirtied blocks
                 */

                /*
                 * Start and end line represent the lines within the 8 K video
                 * memory blocks, NOT the lines as they appear on screen.
                 */
                start_line = (short)(getVideodirty_low() / SCAN_LINE_LENGTH);
                end_line = (short)((getVideodirty_high() / SCAN_LINE_LENGTH) + 1);

                /* AJO 6/1/92
                 * Can get start/end lines past end of screen since video bank
                 * is larger than actally required for these modes; just ignore
                 * lines after end of screen. Not doing this check can cause
                 * incorrect screen update for programs that deliberately write
                 * into the memory between the end of that used for the screen
                 * display and the end of the bank (e.g. PCLABS).
                 */
                if (start_line <= 100)
                {
                    if (end_line > 100)
                                end_line = 100;

                    to = (USHORT *)&video_copy[start_line * SCAN_LINE_LENGTH];
                    from = (USHORT *)get_screen_ptr((start_line *
                                                     SCAN_LINE_LENGTH) << 1);

                        /* do even lines */

                        for (i = start_line; i < end_line; i++ )
                        {
                                for(j=40;j>0;j--)
                                {
                                        if(*to != *from)
                                        {
                                                for(k=j-1;*(to+k)== *(from+(k<<1));k--)
                                                        ;


/*
 * i is pc scanline no/2,
 * so offset=(i*SCAN_LINE_LENGTH + bytes_into_line)*inc_count
 * host_x = bytes_into_line*8   -- 8 pixels per byte
 * host_y = i*2*2               -- to convert pc scanlines to host ones
 * length = k                   -- plus one to counteract k-- in loop
 */

                                                (*paint_screen)(
                                                        ((i*SCAN_LINE_LENGTH+((40-j)<<1))<<1),
                                                        (40-j)<<4,i<<2,(k<<1)+2,1);

                                                for(l=k+1;l>0;l--)
                                                {
                                                        *to++ = *from;
                                                        from += 2;
                                                }

                                                l = j - k - 1;
                                                to += l;
                                                from += l << 1;

                                                break;  /* onto next line */
                                        }

                                        to++;
                                        from += 2;
                                }
                        }

                        /* do odd  lines */

                        from = (USHORT *) get_screen_ptr((start_line * SCAN_LINE_LENGTH + ODD_OFFSET) << 1);
                        to = (USHORT *)&video_copy[start_line * SCAN_LINE_LENGTH + ODD_OFFSET];

                        for (i = start_line; i < end_line; i++ )
                        {
                                for(j=40;j>0;j--)
                                {
                                        if(*to != *from)
                                        {
                                                for(k=j-1;*(to+k)== *(from+(k<<1));k--)
                                                        ;

/*
 * i=line_no/2
 * j=bytes_from_end => (80-j)=bytes from start of line
 * k=no of bytes less 1 different => length in bytes=k+1
 * offset=(i*SCAN_LINE_LENGTH+OFFSET_TO_ODD_BANK+(80-j))*inc_count
 */

                                                (*paint_screen)(
                                                ((i*SCAN_LINE_LENGTH+ODD_OFFSET+((40-j)<<1))<<1),
                                                                                                (40-j)<<4,(i<<2)+2,(k<<1)+2,1);

                                                for(l=k+1;l>0;l--)
                                                {
                                                        *to++ = *from;
                                                        from += 2;
                                                }

                                                l = j - k - 1;
                                                to += l;
                                                from += l << 1;

                                                break;  /* onto next line */
                                        }

                                        to++;
                                        from += 2;
                                }
                        }
                }
        }

        clear_dirty();

    host_end_update();
}

LOCAL VOID
cga_graph_update_chain4 IFN0()
{
    LONG i, j, k, l;            /* Loop counters                */
    UTINY *from,*to;
    LONG cur_ypos;
    LONG        offs;
        SHORT start_line, end_line;

        if (getVideodirty_total() == 0 || get_display_disabled() )
                return;

    host_start_update();

        /*
         * Graphics mode
         */

        to = (UTINY *)&video_copy[0];
        from = (UTINY *) get_screen_ptr(0);

        if (getVideodirty_total() > 5000)
        {
                /*
                 * Refresh the whole screen from the regen buffer
                 */

                for(i=4096*4;i>0;i--)
                {
                        *to++ = *from;
                        from += 4;
                }

                for (cur_ypos = 0,offs=0; cur_ypos < 400;
                 offs += SCAN_LINE_LENGTH, cur_ypos += 4)
                {
                        (*paint_screen)(offs<<2,0,cur_ypos,SCAN_LINE_LENGTH,1);
                        (*paint_screen)((offs+ODD_OFFSET)<<2,0,cur_ypos+2,
                                        SCAN_LINE_LENGTH,1);
                }
        }
        else
        {
                /*
             * Draw the dirtied blocks
             */

                /*
                 * start and end line represent the lines within the 8 K video
                 * memory blocks, NOT the lines as they appear on screen.
                 */
                start_line = (short)(getVideodirty_low() / SCAN_LINE_LENGTH);
                end_line = (short)((getVideodirty_high() / SCAN_LINE_LENGTH) + 1);

                /* AJO 6/1/92
                 * Can get start/end lines past end of screen since video bank
                 * is larger than actally required for these modes; just ignore
                 * lines after end of screen. Not doing this check can cause
                 * incorrect screen update for programs that deliberately write
                 * into the memory between the end of that used for the screen
                 * display and the end of the bank (e.g. PCLABS).
                 */
                if (start_line <= 100)
                {
                    if (end_line > 100)
                        end_line = 100;

                    to = (UTINY *)&video_copy[start_line * SCAN_LINE_LENGTH];
                    from = (UTINY *) get_screen_ptr((start_line *
                                                     SCAN_LINE_LENGTH) << 2);

                    /* do even lines */

                        for (i = start_line; i < end_line; i++ )
                        {
                                for(j=80;j>0;j--)
                                {
                                        if(*to != *from)
                                        {
                                                for(k=j-1;*(to+k)== *(from+(k<<2));k--)
                                                ;

/*
 * i is pc scanline no/2, so offset=(i*SCAN_LINE_LENGTH +
 *                                              bytes_into_line)*inc_count
 * host_x = bytes_into_line*8   -- 8 pixels per byte
 * host_y = i*2*2               -- to convert pc scanlines to host ones
 * length = k                   -- plus one to counteract k-- in loop
 */

                                                (*paint_screen)(
                                                        (i*SCAN_LINE_LENGTH+(80-j))<<2,
                                                        (80-j)<<3,i<<2,k+1,1);

                                        for(l=k+1;l>0;l--)
                                        {
                                                *to++ = *from;
                                                from += 4;
                                        }

                                        l = j - k - 1;
                                        to += l;
                                        from += l << 2;

                                                break;  /* onto next line */
                                        }

                                        to++;
                                        from += 4;
                                }
                        }
                        /* do odd  lines */

                        from = (UTINY *) get_screen_ptr(((start_line * SCAN_LINE_LENGTH) + ODD_OFFSET)<<2);
                        to = (UTINY *)&video_copy[(start_line * SCAN_LINE_LENGTH) + ODD_OFFSET];

                        for (i = start_line; i < end_line; i++ )
                        {
                                for(j=80;j>0;j--)
                                {
                                        if(*to != *from)
                                        {
                                                for(k=j-1;*(to+k)== *(from+(k<<2));k--)
                                                ;
/*
 * i=line_no/2
 * j=bytes_from_end => (80-j)=bytes from start of line
 * k=no of bytes less 1 different => length in bytes=k+1
 * offset=(i*SCAN_LINE_LENGTH+OFFSET_TO_ODD_BANK+(80-j))*inc_count
 */

                                                (*paint_screen)(
                                                        (i*SCAN_LINE_LENGTH+(80-j)+ODD_OFFSET)<<2,
                                                        (80-j)<<3,(i<<2)+2,k+1,1);

                                        for(l=k+1;l>0;l--)
                                        {
                                                *to++ = *from;
                                                from += 4;
                                        }

                                        l = j - k - 1;
                                        to += l;
                                        from += l << 2;

                                                break;  /* onto next line */
                                        }

                                        to++;
                                        from += 4;
                                }
                        }
                }
        }

        clear_dirty();

    host_end_update();
}
#endif  /* EGG */

GLOBAL VOID
cga_med_graph_update IFN0()

{

        /*
         *      The med res CGA graphics mode ( mode 4 ) is an EGA CHAIN2 mode !!
         *      It uses the simple ega copy routines that use an interleaved format
         *      for the data.
         */

#ifdef EGG
        if( video_adapter != CGA )
                cga_graph_update_chain2( );
        else
#endif
                cga_graph_update_unchained( );
}

GLOBAL VOID
cga_hi_graph_update IFN0()

{

        /*
         *      The hi res CGA graphics mode ( mode 6 ) is an EGA CHAIN4 mode !!
         *      It uses the simple ega copy routines that use an interleaved format
         *      for the data.
         */

#ifdef EGG
        if( video_adapter != CGA )
                cga_graph_update_chain4( );
        else
#endif
                cga_graph_update_unchained( );
}

#ifdef EGG

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

void    ega_wrap_split_graph_update IFN0()
{
        register        int     bpl;
        register        int     quarter_opl;
        register        int     screen_split;

        if ( getVideodirty_total() == 0 || get_display_disabled() )
                return;

        screen_split=get_screen_split();

        /*
         * make sure don't fall off end of screen
         */

        if (screen_split>get_screen_height())
                screen_split = get_screen_height();

        bpl = get_bytes_per_line();
        quarter_opl = get_offset_per_line()>>2;

        host_start_update();

        if (getVideodirty_total() > 20000 ) {
                int split_scanlines = get_screen_height() - screen_split;

                if ( get_screen_start() + screen_split*get_offset_per_line() > EGA_PLANE_DISP_SIZE ) {
                        assert0(NO,"Panic he wants to do split screens and wrappig!!");

                        /*
                         * Ignore wrapping for now
                         */

                        memset(&video_copy[get_screen_start()>>2],0,screen_split*quarter_opl);
                        (*paint_screen)( get_screen_start(), 0, 0, bpl, screen_split );
                }
                else {
                        memset(&video_copy[get_screen_start()>>2],0,screen_split*quarter_opl);
                        (*paint_screen)( get_screen_start(), 0, 0, bpl, screen_split );
                }
                if (split_scanlines>0) {
                        memset(&video_copy[0],0,split_scanlines*quarter_opl);
                        (*paint_screen)( 0, 0, screen_split, bpl, split_scanlines);
                }
        }
        else {
                int     next,next1;

                init_dirty_recs();

                if ( get_screen_start() + screen_split*get_offset_per_line() > EGA_PLANE_DISP_SIZE ) {
                        assert0(NO, "Wrapping and spliting, its too much for my head");
                        next = search_video_copy(0,screen_split,get_screen_start()>>2);
                }
                else {
                        next = search_video_copy(0,screen_split,get_screen_start()>>2);
                }
                next1 = search_video_copy(screen_split,get_screen_height(),0);

                paint_records(0,next);
                paint_records(next,next1);
        }

        clear_dirty();

        host_end_update();
}

void    ega_split_graph_update IFN0()
{
        register        int     bpl;
        register        int     quarter_opl;
        register        int     screen_split;
        register        int     screen_height;

        if ( getVideodirty_total() == 0 || get_display_disabled() )
                return;

        screen_split  = get_screen_split()/get_pc_pix_height();
        screen_height = get_screen_height()/get_pc_pix_height();

        /*
         * make sure don't fall off end of screen
         */

        if (screen_split > screen_height)
                screen_split = screen_height;

        bpl = get_bytes_per_line();
        quarter_opl = get_offset_per_line()>>2;

        host_start_update();

        if (getVideodirty_total() > 20000 ) {
                int split_scanlines = screen_height - screen_split;

                memset(&video_copy[get_screen_start()>>2],0,screen_split*quarter_opl);
                (*paint_screen)( get_screen_start(), 0, 0, bpl, screen_split );
                if (split_scanlines>0) {
                        memset(&video_copy[0],0,split_scanlines*quarter_opl);
                        (*paint_screen)( 0, 0, screen_split, bpl, split_scanlines);
                }
        }
        else {
                int     next,next1;

                init_dirty_recs();

                next = search_video_copy(0,screen_split,get_screen_start()>>2);
                next1 = search_video_copy(screen_split,screen_height,0);

                paint_records(0,next);
                paint_records(next,next1);
        }

        clear_dirty();

        host_end_update();
}

#ifdef VGG
/* again v similar to ega version but works on 1 large plane instead of 4 */
static  void    vga_paint_records IFN2(int, start_rec, int, end_rec)
{
        register        DIRTY_PARTS     *i,*end_ptr;
        int dirty_frig;

        i= &dirty[start_rec];
        end_ptr =  &dirty[end_rec];
        while (i<end_ptr) {
                register        int     last_line, cur_start, cur_end,max_width;
                int     first_line;
                int     dirty_vc_offset;

                first_line = i->line_no;
                last_line = first_line;
                cur_start = i->start;
                cur_end = i->end;
                max_width = (cur_end-cur_start) << 1;   /* To split up diagonal lines */

                /*
                 * offset in bytes into video_copy, which is equivalent to off
                 * into 'large' vga plane
                 */

                dirty_vc_offset = i->video_copy_offset;
                dirty_frig = i->v7frig;
                i++;
                while (i < end_ptr) {
                        if ( i->line_no - last_line < 3 ) {
                                /*
                                 * This entry can be included into the same paint
                                 * as long as it doesn't make the rectangle too wide
                                 */
                                if ( i->end > cur_end ){
                                        if(i->end - cur_start > max_width)break;
                                        cur_end = i->end;
                                }
                                if ( i->start < cur_start ){
                                        if(cur_end - i->start > max_width)break;
                                        cur_start = i->start;
                                }
                                last_line = i->line_no;
                                i++;
                        }
                        else
                          break;
                }
                /*
                 * paint the rectangle found
                 */

                /* do not paint beyond the right hand side of the screen;
                   these checks were put in to cope with the special
                   case of the brain-scan display in 'EGAWOW' */
                if (cur_end > get_bytes_per_line())
                        cur_end = get_bytes_per_line();
                if (cur_end > cur_start)
                        (*paint_screen)((dirty_vc_offset<<2) + dirty_frig + cur_start,
                        cur_start, first_line, cur_end-cur_start,
                        last_line-first_line+1);
        }
        /* Clear out video copy */
        for(i = &dirty[start_rec];i<end_ptr;i++)
        {
                register byte *j,*end;
                end = &video_copy[ i->video_copy_offset+(i->end>>2)];
                j =  &video_copy[ i->video_copy_offset+(i->start>>2) + i->v7frig];
                do *j++ = 0; while(j<end);
        }
}


/* dramatically similar to ega graph update but calls vga-ish paint interface */
void    vga_graph_update IFN0()
{
        register        int     opl = get_offset_per_line();
        register        int     bpl = get_bytes_per_line();
        int             screen_height = get_screen_height()/
                                        (get_char_height()*get_pc_pix_height());

        if ( getVideodirty_total() == 0 || get_display_disabled() )
                return;

        host_start_update();

        if (!HostUpdatedVGA()) {
                if (getVideodirty_total() > 20000 )
                {
                        register        byte    *vcopy = &video_copy[get_screen_start()>>2];

                        memset(vcopy,0,get_screen_length()>>2);
                        (*paint_screen)( get_screen_start(), 0, 0, bpl, screen_height );

#ifdef V7VGA
                        draw_v7ptr();
#endif /* V7VGA */
                }
                else
                {
                        register        int     next;
                        register        int     start_line,end_line;

                        start_line = ((getVideodirty_low()<<2) - get_screen_start())/opl;
                        end_line = ((getVideodirty_high()<<2) - get_screen_start())/opl + 1;  /* changed from +2, but I'm not happy. WJG 24/5/89 */

                        if(start_line<0)start_line = 0;
                        if (end_line > screen_height)
                                end_line = screen_height;
                        if(start_line < end_line)       /* Sanity check - could be drawing to another page */
                        {
                /*
                   6.4.92 MG
                   We remove the pointer before the update. Hits performance, but
                   makes the display work correctly.
                */

#ifdef V7VGA
                                if (v7ptr_between_lines(start_line,end_line))
                                        remove_v7ptr();
#endif /* V7VGA */

                                init_dirty_recs();
                                /* see if we can search the video copy by ints instead of bytes - need opl divisible by 16 */
                                if(opl & 15)
#ifdef VGG
                                        if (opl & 3)
                                                next = v7_search_video_copy(start_line,end_line,(get_screen_start()+start_line*opl)>>2);
                                        else
#endif /* VGG */
                                                next = search_video_copy(start_line,end_line,(get_screen_start()+start_line*opl)>>2);
                                else
                                        next = search_video_copy_aligned(start_line,end_line,(get_screen_start()+start_line*opl)>>2);
                                vga_paint_records(0,next);

#ifdef V7VGA
                /*
                 * We might have just blatted over the V7 h/w graphics pointer.
                 * Hence redraw it. A more intelligent solution would be preferable.
                 *
                 * 6/4/92 MG We now have a somewhat more intelligent solution,
                 * checking if the pointer is in the update region before we
                 * draw it.
                 */

                                if (v7ptr_between_lines(start_line,end_line))
                                        draw_v7ptr();
#endif /* V7VGA */

                        }
                }
        }                                                                                                               /* Host didn't update screen itself */

        clear_dirty();

        host_end_update();
}

void    vga_split_graph_update IFN0()
{
        register        int     bpl;
        register        int     quarter_opl;
        register        int     screen_split;
        register        int     screen_height;

        if ( getVideodirty_total() == 0 || get_display_disabled() )
                return;

        screen_split = get_screen_split() /
                       (get_char_height() * get_pc_pix_height());
        screen_height = get_screen_height() /
                        (get_char_height() * get_pc_pix_height());

        /*
         * make sure don't fall off end of screen
         */

        if (screen_split>screen_height)
                screen_split = screen_height;

        bpl = get_bytes_per_line();
        quarter_opl = get_offset_per_line()>>2;

        host_start_update();

        if (getVideodirty_total() > 20000 ) {
                int split_scanlines = screen_height - screen_split;

                memset(&video_copy[get_screen_start()>>2],0,screen_split*quarter_opl);
                (*paint_screen)( get_screen_start(), 0, 0, bpl, screen_split );
                if (split_scanlines>0) {
                        memset(&video_copy[0],0,split_scanlines*quarter_opl);
                        (*paint_screen)( 0, 0, screen_split, bpl, split_scanlines);
                }
        }
        else {
                int     next,next1;

                init_dirty_recs();

                next = search_video_copy(0,screen_split,get_screen_start()>>2);
                next1 = search_video_copy(screen_split,screen_height,0);

                vga_paint_records(0,next);
                vga_paint_records(next,next1);
        }

        clear_dirty();

        host_end_update();
}

#endif /* VGG */

void    ega_graph_update IFN0()
{
        register        int     opl = get_offset_per_line();
        register        int     bpl = get_bytes_per_line();

        if ( getVideodirty_total() == 0 || get_display_disabled() )
                return;

    host_start_update();

        if (!HostUpdatedEGA()) {
                if (getVideodirty_total() > 20000)
                {
                        register        byte    *vcopy = &video_copy[get_screen_start()>>2];

                        memset(vcopy,0,get_screen_length()>>2);
                        (*paint_screen)( get_screen_start(), 0, 0, bpl, get_screen_height()/get_pc_pix_height());
                }
                else
                {
                        register        int     next;
                        register        int     start_line,end_line;

                        start_line = ((getVideodirty_low()<<2) - get_screen_start())/opl;
                        end_line = ((getVideodirty_high()<<2) - get_screen_start())/opl + 1;  /* changed from +2, but I'm not happy. WJG 24/5/89 */
                        if(start_line<0)start_line = 0;
                        if(end_line>(get_screen_height()/get_pc_pix_height()))end_line = get_screen_height()/get_pc_pix_height();
                        if(start_line < end_line)       /* Sanity check - could be drawing to another page */
                        {
                                init_dirty_recs();

                                /*
                                 * See if we can search the video copy by ints instead of bytes
                                 * - we need opl and the screen_start divisible by 16
                                 */

                                if(( opl & 15 ) || ( get_screen_start() & 15 ))
#ifdef VGG
                                        if (opl & 3)
                                                next = v7_search_video_copy( start_line,
                                                                end_line, (get_screen_start()+start_line*opl) >> 2 );
                                        else
#endif /* VGG */
                                                next = search_video_copy( start_line,
                                                                end_line, (get_screen_start()+start_line*opl) >> 2 );
                                else
                                        next = search_video_copy_aligned( start_line,
                                                                end_line, (get_screen_start()+start_line*opl) >> 2 );

                                paint_records(0,next);
                        }
                }
        }                                                                                                       /* Host updated EGA screen */

        clear_dirty();

#ifdef V7VGA
        /*
         * We might have just blatted over the V7 h/w graphics pointer.
         * Hence redraw it. A more intelligent solution would be preferable.
         */

        draw_v7ptr();
#endif /* V7VGA */

        host_end_update();
}


void    ega_wrap_graph_update IFN0()
{
        register        int     opl = get_offset_per_line();
        register        int     bpl = get_bytes_per_line();

        if ( getVideodirty_total() == 0 || get_display_disabled() )
                return;

        host_start_update();

        if (getVideodirty_total() > 20000 ) {
                register        byte    *vcopy = &video_copy[get_screen_start()>>2];

                if (get_screen_start()+get_screen_length()>EGA_PLANE_DISP_SIZE) {
                        register        int     offset = (EGA_PLANE_DISP_SIZE - get_screen_start());
                        register        int     left_over = offset % opl;
                        register        int     ht1 = offset / opl;
                        register        int     ht2 = get_screen_height() - ht1 - 1;
                        register        int     quarter_opl = opl>>2;

                        memset(vcopy,0,offset>>2);
                        memset(&video_copy[0],0,(get_screen_length()-offset)>>2);
                        (*paint_screen)( get_screen_start(), 0, 0, bpl, ht1 );

                        /*
                         * Deal with line that is split by wrapping
                         */

                        if ( left_over > bpl ) {
                                (*paint_screen)( ht1*opl, 0, ht1, bpl, 1);
                        }
                        else {
                                (*paint_screen)( get_screen_start()+ht1*opl, 0, ht1, left_over, 1);
                                (*paint_screen)( 0, left_over<<3, ht1, bpl-left_over, 1);
                        }

                        (*paint_screen)( opl-left_over, 0, ht1+1, bpl, ht2 );
                }
                else {
                        memset(vcopy,0,get_screen_length()>>2);
                        (*paint_screen)( get_screen_start(), 0, 0, bpl, get_screen_height() );
                }
        }
        else {
                register        int     next;

                init_dirty_recs();
                if (get_screen_start()+get_screen_length()>EGA_PLANE_DISP_SIZE) {

                        register        int     offset = (EGA_PLANE_DISP_SIZE - get_screen_start());
                        register        int     left_over = offset % opl;
                        register        int     ht1 = offset / opl;
                        register        int     next1;
                        register        int     wrapped_bytes = opl-left_over;


                        /*
                         * Search video copy
                         */

                        next = search_video_copy(0,ht1,get_screen_start()>>2);
                        next1 = search_video_copy(ht1,get_screen_height(),wrapped_bytes>>2);

                        paint_records(0,next);

                        /*
                         * paint middle line anyway 'cos its too hard to work out whats happened
                         */

                        if (left_over<bpl) {
                                (*paint_screen)(EGA_PLANE_DISP_SIZE-left_over,0,ht1,left_over,1);
                                (*paint_screen)(0,left_over<<3,ht1,bpl-left_over,1);
                        }
                        else {
                                (*paint_screen)(EGA_PLANE_DISP_SIZE-left_over,0,ht1,bpl,1);
                        }

                        /*
                         * now do wrapped area
                         */

                        paint_records(next,next1);
                }
                else {
                        next = search_video_copy(0,get_screen_height(),get_screen_start()>>2);
                        paint_records(0,next);
                }
        }

        clear_dirty();

        host_end_update();
}

#endif /* EGG */

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

/*---------------------  Scrolling routines --------------------------*/

#define UP      0
#define DOWN    1

LOCAL VOID
adjust_cursor IFN7(ULONG, dirn, ULONG, tlx, ULONG, tly, ULONG, width,
        ULONG, height, ULONG, lines, ULONG, bpl )
{

        /*
         * We must not adjust dirty_curs_offset here if it is -1, as this tells
         * us that the cursor is not displayed. If dirty_curs_offs becomes
         * positive, we fool remove_old_cursor into trying to replace the cursor
         * with spurious data.  JJS - 29/6/95.
         */
        if (dirty_curs_offs != -1)
                if(( dirty_curs_x >= (LONG)tlx ) && ( dirty_curs_x < (LONG)(( tlx + width ))))
                        if(( dirty_curs_y >= (LONG)tly ) && ( dirty_curs_y < (LONG)(( tly + height ))))
                        {
                                switch( dirn )
                                {
                                case UP:
                                        dirty_curs_y -= lines;
                                        dirty_curs_offs -= lines * bpl * 2;
                                        break;

                                case DOWN:
                                        dirty_curs_y += lines;
                                        dirty_curs_offs += lines * bpl * 2;
                                        break;
                                }
                                setVideodirty_total(getVideodirty_total() + 1);
                        }
}

/*ARGSUSED5*/
boolean text_scroll_up IFN6(int, start, int, width, int, height,
        int, attr, int, lines, int, dummy_arg)
{
    short blank_word, *ptr, *top_left_ptr,*top_right_ptr, *bottom_right_ptr;
    unsigned short dummy;
    unsigned char *p;
    int words_per_line;
        int i,tlx,tly,htlx,htly,colour;
        int bpl = 2*get_chars_per_line();
        long start_offset;
        register half_word *src,*dest;
        register word *s_ptr,*d_ptr;
        register word data;
        register int j;
        boolean result;

        UNUSED(dummy_arg);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        if (video_adapter == MDA)
        {
                /*
                 * The colour we fill with for MDA is either black or low intensity white,
                 * depending on whether the attribute byte specifies reverse video.
                 */
                colour = ((attr & 0x77) == 0x70)? 1 : 0;
        }
        else
        {
                /*
                 * The colour we fill with for colour text displays is controlled by
                 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
                 */
                colour = (attr & bg_col_mask) >> 4;
        }
/*
 * Reduce the width of the rectangle if any right hand area is completely
 * blank.
 *
 * Don't reduce the size of the scrolling region for a dumb terminal.
 * Dumb terminal uses line feeds to scroll up, but only if the whole
 * screen is to be scrolled.  Reducing the scroll region causes
 * the whole region to be redrawn.
 */

#ifdef DUMB_TERMINAL
        if (terminal_type != TERMINAL_TYPE_DUMB)
        {
#endif /* DUMB_TERMINAL */

                /* originally dummy was char [2] */
                /* unfortunately doing (short) *dummy */
                /* causes a bus error on M88K */
                p = (unsigned char *) &dummy;
                p [0] = ' ';
                p [1] = (unsigned char)attr;
            blank_word = dummy;

            words_per_line   = get_chars_per_line();
            top_left_ptr = (short *) get_screen_ptr((start - gvi_pc_low_regen)<<1);
        top_right_ptr    = top_left_ptr + width - 2;
            bottom_right_ptr = top_right_ptr + bpl * (height - 1);
            ptr = bottom_right_ptr;
            if (width > 2) /* dont want to get a zero rectangle for safetys sake */
            {
                while (*ptr == blank_word)
                {
                    if (ptr == top_right_ptr)   /* reached top of column? */
                    {
                        top_right_ptr -= 2;     /* yes go to bottom of next */
                        bottom_right_ptr -= 2;
                        if (top_right_ptr == top_left_ptr)
                            break;
                        ptr = bottom_right_ptr;
                    }
                    else
                        ptr -= bpl;     /* skipping interleaved planes */
                }
            }
            width = (int)(top_right_ptr - top_left_ptr + 2) << 1;
#ifdef DUMB_TERMINAL
        }
#endif /* DUMB_TERMINAL */

        /* Do the host stuff */

        start_offset = start - sas_w_at_no_check(VID_ADDR) - gvi_pc_low_regen;

        tlx = (int)(start_offset%get_bytes_per_line());

        htlx = tlx      * get_pix_char_width()/2;

        tly = (int)(start_offset/get_bytes_per_line());
        htly = tly * get_host_char_height();

        result = host_scroll_up(htlx,htly,htlx+width/4*get_pix_char_width()-1,
                                htly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

        if(!result)
                return FALSE;

        adjust_cursor( UP, tlx >> 1, tly, width >> 2, height, lines, bpl );

        /* Scroll up the video_copy */

        dest = video_copy + start - gvi_pc_low_regen;
        src = dest + lines * bpl;

        if( width == (2 * bpl))
        {
                /* Can do the whole thing in one go */

                memcpy(dest,src,(width>>1)*(height-lines));
                fwd_word_fill( (short)((' '<<8) | attr), dest+(width>>1)*(height-lines),(width>>1)*lines/2);
        }
        else
        {
                /* Not scrolling whole width of screen, so do each line seperately */
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width>>1);
                        dest += bpl;
                        src += bpl;
                }

                /* Fill exposed area of video copy */

                for(i=0;i<lines;i++)
                {
                        fwd_word_fill( (short)((' '<<8) | attr), dest,width>>2);
                        dest += bpl;
                }
        }

        /* Update video buffer */

        dest = get_screen_ptr((start - gvi_pc_low_regen)<<1);
        src = dest + lines * bpl * 2;

        for(i=0;i<height-lines;i++)
        {
                j = width >> 2;
                d_ptr = (word *)dest;
                s_ptr = (word *)src;

                while( j-- > 0 )
                {
                        *d_ptr = *s_ptr;                /* CHAR  and  ATTRIB */
                        d_ptr += 2;                     /* skip FONT and plane 3 */
                        s_ptr += 2;
                }

                dest += bpl * 2;
                src += bpl * 2;
        }

        /* Fill exposed area of buffer */

#ifdef BIGEND
        data = (' ' << 8) | attr;
#else
        data = (attr << 8) | ' ';
#endif

        for(i=0;i<lines;i++)
        {
                j = width >> 2;
                d_ptr = (word *) dest;

                while( j-- > 0 )
                {
                        *d_ptr = data;
                        d_ptr += 2;
                }

                dest += bpl * 2;
        }

        host_scroll_complete();

        return TRUE;
}

/*ARGSUSED5*/
boolean text_scroll_down IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int,dummy_arg)
{
        int i,tlx,tly,htlx,htly,colour;
        int bpl = 2*get_chars_per_line();
        long start_offset;
        register half_word *src,*dest;
        register word *d_ptr,*s_ptr;
        register word data;
        register int j;
        boolean result;

        UNUSED(dummy_arg);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        if(video_adapter == MDA)
        {
                /*
                 * The colour we fill with for MDA is either black or low intensity white,
                 * depending on whether the attribute byte specifies reverse video.
                 */
                colour = ((attr & 0x77) == 0x70)? 1 : 0;
        }
        else
        {
                /*
                 * The colour we fill with for colour text displays is controlled by
                 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
                 */
                colour = (attr & bg_col_mask) >>4;
        }

        width <<= 1;

        /* Do the host stuff */

        start_offset = start - get_screen_start() * 2 - gvi_pc_low_regen;

        tlx = (int)(start_offset%get_bytes_per_line());
        htlx = tlx      * get_pix_char_width()/2;

        tly = (int)(start_offset/get_bytes_per_line());
        htly = tly * get_host_char_height();

        result = host_scroll_down(htlx,htly,htlx+width/4*get_pix_char_width()-1,
                        htly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

        if(!result)
                return FALSE;

        adjust_cursor( DOWN, tlx >> 1, tly, width >> 2, height, lines, bpl );

        /* Scroll down the video_copy */

        if( width == (2 * bpl))
        {
                /* Can do the whole thing in one go */
                src = video_copy + start - gvi_pc_low_regen;
                dest = src + lines * bpl;
                memcpy(dest,src,(width>>1)*(height-lines));
                fwd_word_fill( (short)((' '<<8) | attr), src,(width>>1)*lines/2);
        }
        else
        {
                /* Not scrolling whole width of screen, so do each line seperatly */
                dest = video_copy + start-gvi_pc_low_regen + (height-1) * bpl;
                src = dest - lines * bpl;
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width>>1);
                        dest -= bpl;
                        src -= bpl;
                }

                /* Fill exposed area of video copy */

                for(i=0;i<lines;i++)
                {
                        fwd_word_fill( (short)((' '<<8) | attr), dest,width>>2);
                        dest -= bpl;
                }
        }

        /* Update video buffer */

        dest = get_screen_ptr((start - gvi_pc_low_regen)<<1) + (height-1) * bpl * 2;
        src = dest - lines * bpl * 2;

        for(i=0;i<height-lines;i++)
        {
                j = width >> 2;
                d_ptr = (word *) dest;
                s_ptr = (word *) src;

                while( j-- > 0 )
                {
                        *d_ptr = *s_ptr;
                        d_ptr += 2;
                        s_ptr += 2;
                }

                dest -= bpl * 2;
                src -= bpl * 2;
        }

        /* Fill exposed area of buffer */

#ifdef BIGEND
        data = (' ' << 8) | attr;
#else
        data = (attr << 8) | ' ';
#endif

        for(i=0;i<lines;i++)
        {
                j = width >> 2;
                d_ptr = (word *) dest;

                while( j-- > 0 )
                {
                        *d_ptr = data;
                        d_ptr += 2;
                }

                dest -= bpl * 2;
        }

        host_scroll_complete();

        return TRUE;
}

/*---------------------  CGA Scrolling routines --------------------------*/

/*ARGSUSED5*/
boolean cga_text_scroll_up IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int,dummy_arg)
{
    short blank_word, *ptr, *top_left_ptr,*top_right_ptr, *bottom_right_ptr;
    unsigned short dummy;
    unsigned char *p;
    int words_per_line;
        int i,tlx,tly,colour;
        int bpl = 2*get_chars_per_line();
        long start_offset;
        register half_word *src,*dest;
        boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        UNUSED(dummy_arg);

        if (video_adapter == MDA)
        {
                /*
                 * The colour we fill with for MDA is either black or low intensity white,
                 * depending on whether the attribute byte specifies reverse video.
                 */
                colour = ((attr & 0x77) == 0x70)? 1 : 0;
        }
        else
        {
                /*
                 * The colour we fill with for colour text displays is controlled by
                 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
                 */
                colour = (attr & bg_col_mask) >>4;
        }
/*
 * Reduce the width of the rectangle if any right hand area is completely
 * blank.
 *
 * Don't reduce the size of the scrolling region for a dumb terminal.
 * Dumb terminal uses line feeds to scroll up, but only if the whole
 * screen is to be scrolled.  Reducing the scroll region causes
 * the whole region to be redrawn.
 */

#ifdef DUMB_TERMINAL
        if (terminal_type != TERMINAL_TYPE_DUMB)
        {
#endif /* DUMB_TERMINAL */

                /* originally dummy was char [2] */
                /* unfortunately doing (short) *dummy */
                /* causes a bus error on M88K */
                p = (unsigned char *) &dummy;
                p [0] = ' ';
                p [1] = (unsigned char)attr;
            blank_word = dummy;

            words_per_line   = get_chars_per_line();
            top_left_ptr     = (short *) get_screen_ptr(start - gvi_pc_low_regen);
            top_right_ptr    = top_left_ptr + (width >> 1) - 1;
            bottom_right_ptr = top_right_ptr + words_per_line * (height - 1);
            ptr = bottom_right_ptr;
            if (width > 2) /* dont want to get a zero rectangle for safetys sake */
            {
                while (*ptr == blank_word)
                {
                    if (ptr == top_right_ptr)   /* reached top of column? */
                    {
                        top_right_ptr--;        /* yes go to bottom of next */
                        bottom_right_ptr--;
                        if (top_right_ptr == top_left_ptr)
                            break;
                        ptr = bottom_right_ptr;
                    }
                    else
                        ptr -= words_per_line;
                }
            }
            width = (int)(top_right_ptr - top_left_ptr + 1) << 1;
#ifdef DUMB_TERMINAL
        }
#endif /* DUMB_TERMINAL */

        /* do the host stuff */
        start_offset = start - get_screen_start()*2 - gvi_pc_low_regen;
        tlx = (int)(start_offset%get_bytes_per_line())*get_pix_char_width()/2;
        tly = (int)(start_offset/get_bytes_per_line())*get_host_char_height();
        result = host_scroll_up(tlx,tly,tlx+width/2*get_pix_char_width()-1,
                                tly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

        if(!result)
                return FALSE;

        /* Adjust cursor */

        if(( dirty_curs_offs != -1 ) && ( dirty_curs_x < ( width >> 1 )))
        {
                dirty_curs_y -= lines;
                dirty_curs_offs -= lines * bpl;
                setVideodirty_total(getVideodirty_total() + 1);
        }

        /* Scroll up the video_copy */
        dest = video_copy + start-gvi_pc_low_regen;
        src = dest + lines * bpl;

        if(width == bpl)
        {
                /* Can do the whole thing in one go */
                memcpy(dest,src,width*(height-lines));
                fwd_word_fill( (short)((' '<<8) | attr), dest+width*(height-lines),width*lines/2);
        }
        else
        {
                /* Not scrolling whole width of screen, so do each line seperatly */
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width);
                        dest += bpl;
                        src += bpl;
                }

                /* Fill exposed area of video copy */

                for(i=0;i<lines;i++)
                {
                        fwd_word_fill( (short)((' '<<8) | attr), dest,width/2);
                        dest += bpl;
                }
        }

        /* Update video buffer */

        dest = get_screen_ptr(start - gvi_pc_low_regen);
        src = dest + lines * bpl;
        for(i=0;i<height-lines;i++)
        {
                memcpy(dest,src,width);
                dest += bpl;
                src += bpl;
        }

        /* Fill exposed area of buffer */

        for(i=0;i<lines;i++)
        {
                fwd_word_fill( (short)((' '<<8) | attr), dest,width/2);
                dest += bpl;
        }

        host_scroll_complete();

        return TRUE;
}

/*ARGSUSED5*/
boolean cga_text_scroll_down IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int,dummy_arg)
{
        int i,tlx,tly,colour;
        int bpl = 2*get_chars_per_line();
        long start_offset;
        register half_word *src,*dest;
        boolean result;

        UNUSED(dummy_arg);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        if(video_adapter == MDA)
        {
                /*
                 * The colour we fill with for MDA is either black or low intensity white,
                 * depending on whether the attribute byte specifies reverse video.
                 */
                colour = ((attr & 0x77) == 0x70)? 1 : 0;
        }
        else
        {
                /*
                 * The colour we fill with for colour text displays is controlled by
                 * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
                 */
                colour = (attr & bg_col_mask) >>4;
        }

        /* do the host stuff */
        start_offset = start - get_screen_start() * 2 - gvi_pc_low_regen;
        tlx = (int)(start_offset%get_bytes_per_line())*get_pix_char_width()/2;
        tly = (int)(start_offset/get_bytes_per_line())*get_host_char_height();
        result = host_scroll_down(tlx,tly,tlx+width/2*get_pix_char_width()-1,
                        tly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

        if(!result)
                return FALSE;

        /* Adjust cursor */

        if(( dirty_curs_offs != -1 ) && ( dirty_curs_x < ( width >> 1 )))
        {
                dirty_curs_y += lines;
                dirty_curs_offs += lines * bpl;
                setVideodirty_total(getVideodirty_total() + 1);
        }

        /* Scroll down the video_copy */

        if(width == bpl)
        {
                /* Can do the whole thing in one go */
                src = video_copy + start - gvi_pc_low_regen;
                dest = src + lines * bpl;
                memcpy(dest,src,width*(height-lines));
                fwd_word_fill( (short)((' '<<8) | attr), src,width*lines/2);
        }
        else
        {
                /* Not scrolling whole width of screen, so do each line seperatly */
                dest = video_copy + start-gvi_pc_low_regen + (height-1) * bpl;
                src = dest - lines * bpl;
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width);
                        dest -= bpl;
                        src -= bpl;
                }

                /* Fill exposed area of video copy */

                for(i=0;i<lines;i++)
                {
                        fwd_word_fill( (short)((' '<<8) | attr), dest,width/2);
                        dest -= bpl;
                }
        }

        /* Update video buffer */

        dest = get_screen_ptr(start - gvi_pc_low_regen) + (height-1) * bpl;
        src = dest - lines * bpl;
        for(i=0;i<height-lines;i++)
        {
                memcpy(dest,src,width);
                dest -= bpl;
                src -= bpl;
        }

        /* Fill exposed area of buffer */

        for(i=0;i<lines;i++)
        {
                fwd_word_fill( (short)((' '<<8) | attr), dest,width/2);
                dest -= bpl;
        }

        host_scroll_complete();

        return TRUE;
}

boolean cga_graph_scroll_up IFN6(int, start, int, width, int, height,
        int, attr, int, lines, int, colour)
{
        int i,tlx,tly;
        long start_offset;
        half_word *src,*dest;
        boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        /* Do the host stuff */

        start_offset = start - gvi_pc_low_regen;
        tlx = (int)(start_offset%SCAN_LINE_LENGTH)*8;
        tly = (int)(start_offset/SCAN_LINE_LENGTH)*4;

        result = host_scroll_up(tlx,tly,tlx+width*8-1,tly+height*4-1,lines*4,colour);

        if(!result)return FALSE;

        /* scroll up the video_copy */
        dest = video_copy + start_offset;
        src = dest + lines*SCAN_LINE_LENGTH;

        if(width == SCAN_LINE_LENGTH)
        {
                /* Can do the whole thing in one go */
                memcpy(dest,src,width*(height-lines));
                memset( dest+width*(height-lines),attr,width*lines);
                memcpy(dest+(ODD_OFFSET),src+(ODD_OFFSET),width*(height-lines));
                memset( dest+width*(height-lines)+(ODD_OFFSET),attr,width*lines);
        }
        else
        {
                /* Not scrolling whole width of screen, so do each line seperatly */
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width);
                        memcpy(dest+(ODD_OFFSET),src+(ODD_OFFSET),width);
                        dest += SCAN_LINE_LENGTH;
                        src += SCAN_LINE_LENGTH;
                }

                /* clear the video_copy */
                for(i=0;i<lines;i++)
                {
                        memset( dest,attr,width);
                        memset( dest+(ODD_OFFSET),attr,width);
                        dest += SCAN_LINE_LENGTH;
                }
        }
#ifdef EGG
        if(video_adapter == EGA || video_adapter == VGA)
        {
                int bpl = SCAN_LINE_LENGTH;
                int oof = ODD_OFFSET;

                if( sas_hw_at_no_check(vd_video_mode) == 6 )
                {
                        /* Hi-res mode stored in interleaved format in 3.0 */

                        start_offset <<= 2;
                        bpl <<= 2;
                        width <<= 2;
                        oof <<= 2;
                }
                else
                {
                        start_offset <<= 1;
                        bpl <<= 1;
                        width <<= 1;
                        oof <<= 1;
                }

                dest = EGA_plane01 + start_offset;
                src = dest + lines*bpl;
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width);
                        memcpy(dest+oof,src+oof,width);
                        dest += bpl;
                        src += bpl;
                }

                /* clear the EGA plane */
                for(i=0;i<lines;i++)
                {
                        memset( dest,attr,width);
                        memset( dest+oof,attr,width);
                        dest += bpl;
                }
        }
#endif /* EGG */

        host_scroll_complete();

        return TRUE;
}

boolean cga_graph_scroll_down IFN6(int, start, int, width, int, height,
        int, attr, int, lines, int, colour)
{
        int i,tlx,tly;
        long start_offset;
        register half_word *src,*dest;
        boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        /* Do the host stuff */

        start_offset = start - gvi_pc_low_regen;
        tlx = (int)(start_offset%SCAN_LINE_LENGTH)*8;
        tly = (int)(start_offset/SCAN_LINE_LENGTH)*4;

        result = host_scroll_down(tlx,tly,tlx+width*8-1,tly+height*4-1, lines*4,colour);

        if(!result)return FALSE;

        /* Scroll down the video_copy */

        if(width == SCAN_LINE_LENGTH)
        {
                /* Can do the whole thing in one go */
                src = video_copy + start - gvi_pc_low_regen;
                dest = src + lines*SCAN_LINE_LENGTH;
                memcpy(dest,src,width*(height-lines));
                memset(src,attr,width*lines);
                memcpy(dest+ODD_OFFSET,src+ODD_OFFSET,width*(height-lines));
                memset(src+ODD_OFFSET,attr,width*lines);
        }
        else
        {
                /* Not scrolling whole width of screen, so do each line seperatly */
                dest = video_copy + start - gvi_pc_low_regen + (height-1)*SCAN_LINE_LENGTH;
                src = dest - lines*SCAN_LINE_LENGTH;
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width);
                        memcpy(dest+ODD_OFFSET,src+ODD_OFFSET,width);
                        dest -= SCAN_LINE_LENGTH;
                        src -= SCAN_LINE_LENGTH;
                }

                /* clear the video_copy */
                for(i=0;i<lines;i++)
                {
                        memset(dest,attr,width);
                        memset(dest+ODD_OFFSET,attr,width);
                        dest -= SCAN_LINE_LENGTH;
                }
        }
#ifdef EGG
        if(video_adapter == EGA || video_adapter == VGA)
        {
                register int bpl = SCAN_LINE_LENGTH;
                register int oof = ODD_OFFSET;

                if( sas_hw_at_no_check(vd_video_mode) == 6 )
                {
                        /* Hi-res mode stored in interleaved format in 3.0 */

                        start_offset <<= 2;
                        bpl <<= 2;
                        width <<= 2;
                        oof <<= 2;
                }
                else
                {
                        start_offset <<= 1;
                        bpl <<= 1;
                        width <<= 1;
                        oof <<= 1;
                }

                dest = EGA_plane01 + start - gvi_pc_low_regen + (height-1)*bpl;
                src = dest - lines*bpl;
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width);
                        memcpy(dest+oof,src+oof,width);
                        dest -= bpl;
                        src -= bpl;
                }

                /* clear the EGA plane */
                for(i=0;i<lines;i++)
                {
                        memset(dest,attr,width);
                        memset(dest+oof,attr,width);
                        dest -= bpl;
                }
        }
#endif /* EGG */

        host_scroll_complete();

        return TRUE;
}

#ifdef VGG
/*ARGSUSED5*/
boolean vga_graph_scroll_up IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int,dummy)
{
        int start_offset,tlx,tly;
        boolean status;

        UNUSED(dummy);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        (*update_alg.calc_update)();
        /* do the host stuff */
        start_offset = start - get_screen_start();
        tlx = (start_offset%get_offset_per_line())*2;
        tly = (start_offset/get_offset_per_line())*2;
        status = host_scroll_up(tlx,tly,tlx+width*2-1,tly+height*2-1,lines*2,attr);

        host_scroll_complete();

        return(status);

}

/*ARGSUSED5*/
boolean vga_graph_scroll_down IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int,dummy_arg)
{
        int start_offset,tlx,tly;
        boolean status;

        UNUSED(dummy_arg);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        (*update_alg.calc_update)();
        /* do the host stuff */
        start_offset = start - get_screen_start();
        tlx = (start_offset%get_offset_per_line())*2;
        tly = (start_offset/get_offset_per_line())*2;
        status =  host_scroll_down(tlx,tly,tlx+width*2-1,tly+height*2-1,lines*2,attr);

        host_scroll_complete();

        return(status);

}

#ifdef V7VGA
/*ARGSUSED5*/
boolean v7vga_graph_scroll_up IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int,dummy)
{
        int start_offset,tlx,tly;
        boolean status;

        UNUSED(dummy);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        (*update_alg.calc_update)();
        /* do the host stuff */
        start_offset = start - get_screen_start();
        tlx = (start_offset%get_offset_per_line());
        tly = (start_offset/get_offset_per_line());
        status = host_scroll_up(tlx,tly,tlx+width-1,tly+height-1,lines,attr);

        host_scroll_complete();

        return(status);
}

/*ARGSUSED5*/
boolean v7vga_graph_scroll_down IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int, dummy_arg)
{
        int start_offset,tlx,tly;
        boolean status;

        UNUSED(dummy_arg);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        (*update_alg.calc_update)();
        /* do the host stuff */
        start_offset = start - get_screen_start();
        tlx = (start_offset%get_offset_per_line());
        tly = (start_offset/get_offset_per_line());
        status = host_scroll_down(tlx,tly,tlx+width-1,tly+height-1,lines,attr);

        host_scroll_complete();

        return(status);
}
#endif /* V7VGA */
#endif /* VGG */

#ifdef EGG

#ifdef SEGMENTATION             /* See note with first use of this flag */
#if             defined(JOKER) && !defined(PROD)
#include "SOFTPC_GRAPHICS.seg"
#undef  SEGMENTATION            /* HeeHee! */
#else
#include "SOFTPC_EGA.seg"
#endif  /* DEV JOKER variants */
#endif

/*ARGSUSED5*/
boolean ega_graph_scroll_up IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int,dummy)
{
        int start_offset,tlx,tly;
        boolean status;

        UNUSED(dummy);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        (*update_alg.calc_update)();
        /* do the host stuff */
        attr &= 0xf;
        start_offset = start - get_screen_start();
        tlx = (start_offset%get_offset_per_line())*8*get_pix_width();
        tly = (start_offset/get_offset_per_line())*get_pc_pix_height();
        status =  (host_scroll_up(tlx,tly,tlx+width*8*get_pix_width()-1,tly+height*get_pc_pix_height()-1,lines*get_pc_pix_height(),attr));

        host_scroll_complete();

        return(status);

}

/*ARGSUSED5*/
boolean ega_graph_scroll_down IFN6(int, start, int, width, int, height,
        int, attr, int, lines,int,dummy_arg)
{
        int start_offset,tlx,tly;
        boolean status;

        UNUSED(dummy_arg);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif

        (*update_alg.calc_update)();

        /* do the host stuff */
        attr &= 0xf;
        start_offset = start - get_screen_start();
        tlx = (start_offset%get_offset_per_line())*8*get_pix_width();
        tly = (start_offset/get_offset_per_line())*get_pc_pix_height();
        status = (host_scroll_down(tlx,tly,tlx+width*8*get_pix_width()-1,tly+height*get_pc_pix_height()-1,lines*get_pc_pix_height(),attr));

        host_scroll_complete();

        return(status);

}
#endif /* EGG */

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

#endif /* REAL_VGA */

/*ARGSUSED0*/
boolean dummy_scroll IFN6(int,dummy1,int,dummy2,int,dummy3,int,
                                dummy4,int,dummy5,int,dummy6)
{
        UNUSED(dummy1);
        UNUSED(dummy2);
        UNUSED(dummy3);
        UNUSED(dummy4);
        UNUSED(dummy5);
        UNUSED(dummy6);

        return FALSE;
}

#ifndef REAL_VGA

/*---------------------  End of scrolling routines --------------------------*/

#ifdef GORE

#ifdef GORE_PIG
GLOBAL UTINY gore_copy[0x80000];        /* Big enough for enormous Super7 VGA modes */
#endif /* GORE_PIG */

LOCAL VOID
gore_mark_byte_nch IFN0()
{
#ifdef GORE_PIG
        gore_copy[(Ead >> 2) + (v7_write_bank << 16)] = gd.gd_b_wrt.mark_type;
#endif /* GORE_PIG */

        (*gu_handler.b_wrt)(( Ead >> 2 ) + ( v7_write_bank << 16 ));
}

LOCAL VOID
gore_mark_word_nch IFN0()
{
#ifdef GORE_PIG
        gore_copy[(Ead >> 2 ) + 1 + (v7_write_bank << 16)] =
                        gore_copy[(Ead >> 2) + (v7_write_bank << 16)] = gd.gd_w_wrt.mark_type;
#endif /* GORE_PIG */

        (*gu_handler.w_wrt)(( Ead >> 2 ) + ( v7_write_bank << 16 ));
}

LOCAL VOID
gore_mark_string_nch IFN0()
{
        ULONG temp =  ( Ead >> 2 ) + ( v7_write_bank << 16 );

#ifdef GORE_PIG
        memfill( gd.gd_b_str.mark_type, &gore_copy[temp], &gore_copy[temp+V3-1] );
#endif /* GORE_PIG */

        (*gu_handler.b_str)( temp, temp + V3 - 1, V3 );
}

LOCAL VOID
gore_mark_byte_ch4 IFN0()
{
        ULONG temp =  Ead + ( v7_write_bank << 16 );

#ifdef GORE_PIG
        if( temp < gd.dirty_low )
                gd.dirty_low = temp;

        if( temp > gd.dirty_high )
                gd.dirty_high = temp;

        gore_copy[temp] = gd.gd_b_wrt.mark_type;
#endif /* GORE_PIG */

        (*gu_handler.b_wrt)( temp );
}

LOCAL VOID
gore_mark_word_ch4 IFN0()
{
        ULONG temp =  Ead + ( v7_write_bank << 16 );

#ifdef GORE_PIG
        if( temp < gd.dirty_low )
                gd.dirty_low = temp;

        if(( temp + 1 ) > gd.dirty_high )
                gd.dirty_high = temp + 1;

        gore_copy[temp + 1] = gore_copy[temp] = gd.gd_w_wrt.mark_type;
#endif /* GORE_PIG */

        (*gu_handler.w_wrt)( Ead + ( v7_write_bank << 16 ));
}

LOCAL VOID
gore_mark_string_ch4 IFN0()
{
        ULONG temp =  Ead + ( v7_write_bank << 16 );
        ULONG temp2 =  temp + V3 - 1;

#ifdef GORE_PIG
        if( temp < gd.dirty_low )
                gd.dirty_low = temp;

        if( temp2 > gd.dirty_high )
                gd.dirty_high = temp2;

        memfill( gd.gd_b_str.mark_type, &gore_copy[temp], &gore_copy[temp2] );
#endif /* GORE_PIG */

        (*gu_handler.b_str)( temp, temp2, V3 );
}
#endif /* GORE */

#ifdef  EGG
/*
 * Given an offset into CGA memory return the offset
 * within an 8K bank of video memory.
 */
#define BANK_OFFSET(off) (off & 0xDFFF)

GLOBAL VOID cga_mark_byte IFN1(int, addr)
{
        register        int     offset = BANK_OFFSET(addr);

        if(offset < getVideodirty_low())
                setVideodirty_low(offset);

        if(offset > getVideodirty_high())
                setVideodirty_high(offset);

        setVideodirty_total(getVideodirty_total() + 1);
}

GLOBAL VOID cga_mark_word IFN1(int, addr)
{
        register        int     offset1 = BANK_OFFSET(addr);
        register        int     offset2 = offset1 + 1;

        if(offset1 < getVideodirty_low())
                setVideodirty_low(offset1);

        if(offset2 > getVideodirty_high())
                setVideodirty_high(offset2);

        setVideodirty_total(getVideodirty_total() + 2);
}

GLOBAL VOID cga_mark_string IFN2(int, laddr, int, haddr)
{
        register        int     offset1 = BANK_OFFSET(laddr);
        register        int     offset2 = BANK_OFFSET(haddr);

        if(offset1 < getVideodirty_low())
                setVideodirty_low(offset1);

        if(offset2 > getVideodirty_high())
                setVideodirty_high(offset2);

        setVideodirty_total(getVideodirty_total() + offset2-offset1+1);
}

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

GLOBAL VOID ega_mark_byte IFN1(int, off_in)
{
#ifdef GORE
        (*gu_handler.b_wrt)( off_in );
#else
        register int offset = off_in>>2;

        video_copy[offset] = 1;

        if(offset < getVideodirty_low())
                setVideodirty_low(offset);

        if(offset > getVideodirty_high())
                setVideodirty_high(offset);

        setVideodirty_total(getVideodirty_total() + 1);
#endif /* GORE */
}

GLOBAL VOID ega_mark_word IFN1(int, addr)
{
#ifdef GORE
        (*gu_handler.w_wrt)( addr );
#else

        register        int     offset1 = addr >> 2;
        register        int     offset2 = (addr+1) >> 2;

        video_copy[offset1] = 1;
        video_copy[offset2] = 1;

        if(offset1 < getVideodirty_low())
                setVideodirty_low(offset1);

        if(offset2 > getVideodirty_high())
                setVideodirty_high(offset2);

        setVideodirty_total(getVideodirty_total() + 2);
#endif /* GORE */
}

GLOBAL VOID ega_mark_wfill IFN3(int, laddr, int, haddr, int, col)
{
#ifdef GORE
        (*gu_handler.w_fill)( laddr, haddr, haddr - laddr + 1, col );
#else

        register        int     offset1 = laddr >> 2;
        register        int     offset2 = haddr >> 2;

        UNUSED(col);

        memfill(1,&video_copy[offset1],&video_copy[offset2]);

        if(offset1 < getVideodirty_low())
                setVideodirty_low(offset1);

        if(offset2 > getVideodirty_high())
                setVideodirty_high(offset2);

        setVideodirty_total(getVideodirty_total() + offset2-offset1+1);
#endif /* GORE */
}

GLOBAL VOID ega_mark_string IFN2(int, laddr, int, haddr)
{
#ifdef GORE
        (*gu_handler.b_str)( laddr, haddr, haddr - laddr + 1 );
#else
        register        int     offset1 = laddr >> 2;
        register        int     offset2 = haddr >> 2;

        memfill(1,&video_copy[offset1],&video_copy[offset2]);

        if(offset1 < getVideodirty_low())
                setVideodirty_low(offset1);

        if(offset2 > getVideodirty_high())
                setVideodirty_high(offset2);

        setVideodirty_total(getVideodirty_total() + offset2-offset1+1);
#endif /* GORE */
}

#endif /* EGG */

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

GLOBAL VOID screen_refresh_required IFN0()
{

#ifdef GORE
        (*gu_handler.b_str)( 0, get_screen_length(), get_screen_length() );
#endif /* GORE */

#ifndef CPU_40_STYLE
        /*
         * This is to stop the VGA globals pointer being
         * dereferenced before it is set up in main.c.
         */

        if (VGLOBS)
                VGLOBS->dirty_flag = 1000000L;
#else
        setVideodirty_total(1000000L);
#endif  /* CPU_40_STYLE */
}

#ifdef EGG

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

LOCAL MARKING_TYPE curr_mark_type;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )    /* remove uneeded code */

GLOBAL VOID
set_mark_funcs IFN0()
{
        switch (curr_mark_type)
        {
                case    SIMPLE_MARKING:
                        update_alg.mark_byte = (T_mark_byte)simple_update;
                        update_alg.mark_word = (T_mark_word)simple_update;
                        update_alg.mark_fill = (T_mark_fill)simple_update;
                        update_alg.mark_wfill = (T_mark_wfill)simple_update;
                        update_alg.mark_string = (T_mark_string)simple_update;

#ifndef CPU_40_STYLE    /* EVID */
                        setVideomark_byte(FAST_FUNC_ADDR(_simple_mark_sml));
                        setVideomark_word(FAST_FUNC_ADDR(_simple_mark_sml));

                        SET_VGLOBS_MARK_STRING(_simple_mark_lge);
#else   /* CPU_40_STYLE - EVID */
                        SetMarkPointers(0);
#endif  /* CPU_40_STYLE - EVID */
                        break;

                case    CGA_GRAPHICS_MARKING:
                        update_alg.mark_byte = (T_mark_byte)cga_mark_byte;
                        update_alg.mark_word = (T_mark_word)cga_mark_word;
                        update_alg.mark_fill = (T_mark_fill)cga_mark_string;
                        update_alg.mark_wfill = (T_mark_wfill)cga_mark_string;
                        update_alg.mark_string = (T_mark_string)cga_mark_string;

#ifndef CPU_40_STYLE    /* EVID */
                        setVideomark_byte(FAST_FUNC_ADDR(_cga_mark_byte));
                        setVideomark_word(FAST_FUNC_ADDR(_cga_mark_word));

                        SET_VGLOBS_MARK_STRING(_cga_mark_string);
#else   /* CPU_40_STYLE - EVID */
                        SetMarkPointers(1);
#endif  /* CPU_40_STYLE - EVID */

                        break;

                case    EGA_GRAPHICS_MARKING:
#ifdef GORE
                        reset_gore_ptrs();
                        gd.curr_line_diff = get_bytes_per_line();
                        gd.max_vis_addr = get_screen_length() - 1 + ( v7_write_bank << 16 );
#ifdef  VGG
                        gd.shift_count = get_256_colour_mode() ? 0 : 3;
#else
                        gd.shift_count = 3;
#endif  /* VGG */
#endif /* GORE */

                        update_alg.mark_byte = (T_mark_byte)ega_mark_byte;
                        update_alg.mark_word = (T_mark_word)ega_mark_word;
                        update_alg.mark_fill = (T_mark_fill)ega_mark_string;
                        update_alg.mark_wfill = (T_mark_wfill)ega_mark_wfill;
                        update_alg.mark_string = (T_mark_string)ega_mark_string;

                        switch( EGA_CPU.chain )
                        {
                                case UNCHAINED:
#ifdef GORE
                                        setVideomark_byte(gore_mark_byte_nch);
                                        setVideomark_word(gore_mark_word_nch);

                                        SET_VGLOBS_MARK_STRING(gore_mark_string_nch);
#else
#ifndef CPU_40_STYLE    /* EVID */
                                        setVideomark_byte(FAST_FUNC_ADDR(_mark_byte_nch));
                                        setVideomark_word(FAST_FUNC_ADDR(_mark_word_nch));

                                        SET_VGLOBS_MARK_STRING(_mark_string_nch);
#else   /* CPU_40_STYLE - EVID */
                                        SetMarkPointers(2);
#endif  /* CPU_40_STYLE - EVID */
#endif /* GORE */
                                        break;

                                case CHAIN2:
                                        assert0( NO, "CHAIN2 in graphics mode !!" );

                                        break;

#ifdef  VGG
                                case CHAIN4:
#ifdef GORE
                                        setVideomark_byte(gore_mark_byte_ch4);
                                        setVideomark_word(gore_mark_word_ch4);

                                        SET_VGLOBS_MARK_STRING(gore_mark_string_ch4);
#else
#ifndef CPU_40_STYLE    /* EVID */
                                        setVideomark_byte(FAST_FUNC_ADDR(_mark_byte_ch4));
                                        setVideomark_word(FAST_FUNC_ADDR(_mark_word_ch4));

                                        SET_VGLOBS_MARK_STRING(_mark_string_ch4);
#else   /* CPU_40_STYLE - EVID */
                                        SetMarkPointers(3);
#endif  /* CPU_40_STYLE - EVID */
#endif /* GORE */
                                        break;
#endif  /* VGG */
                        }

                        break;

                default:
                        assert1(NO,"Unknown marking type %d", (int) curr_mark_type);
                        break;
        }
}
#endif  /* !NTVDM | (NTVDM & !X86GFX) */

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

GLOBAL void set_gfx_update_routines IFN3(T_calc_update, update_routine,
                MARKING_TYPE, marking_type, SCROLL_TYPE, scroll_type)
{
        enable_gfx_update_routines();
        update_alg.calc_update = update_routine;
        switch (scroll_type) {
                case    NO_SCROLL:
                        update_alg.scroll_up = dummy_scroll;
                        update_alg.scroll_down = dummy_scroll;
                        break;
                case    TEXT_SCROLL:
#if defined(NTVDM) && defined(MONITOR)
                        update_alg.scroll_up = (T_scroll_up)mon_text_scroll_up;
                        update_alg.scroll_down = (T_scroll_down)mon_text_scroll_down;
#else
                        update_alg.scroll_up = text_scroll_up;
                        update_alg.scroll_down = text_scroll_down;
#endif  /* NTVDM & MONITOR */
                        break;
#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX) )    /* remove unneeded code */
                case    CGA_GRAPH_SCROLL:
                        update_alg.scroll_up = cga_graph_scroll_up;
                        update_alg.scroll_down = cga_graph_scroll_down;
                        break;
                case    EGA_GRAPH_SCROLL:
                        update_alg.scroll_up = ega_graph_scroll_up;
                        update_alg.scroll_down = ega_graph_scroll_down;
                        break;
#ifdef VGG
                case    VGA_GRAPH_SCROLL:
                        update_alg.scroll_up = vga_graph_scroll_up;
                        update_alg.scroll_down = vga_graph_scroll_down;
                        break;
#ifdef V7VGA
                case    V7VGA_GRAPH_SCROLL:
                        update_alg.scroll_up = v7vga_graph_scroll_up;
                        update_alg.scroll_down = v7vga_graph_scroll_down;
                        break;
#endif /* V7VGA */
#endif /* VGG */
#endif /* !NTVDM | (NTVDM & !X86GFX) */
        }

        curr_mark_type = marking_type;

        set_mark_funcs();

        /*
         * The newly setup update routines will not be needed yet if the
         * display is disabled, but must be saved in any case so that
         * redundant enables (as in dosshell) restore the correct ones.
         * If the display is disabled we must also then install the dummy
         * update routines as the current ones.
         *
         * AJO 23/4/93
         * DON'T use disable_gfx_update_routines() here cos' it's a NOP
         * if the display is already disabled which causes bizarre problems
         * if a mode change is performed while disabled.
         */
        save_gfx_update_routines();
        if (get_display_disabled())
                inhibit_gfx_update_routines();
}
#endif /* EGG */

#endif /* REAL_VGA */

#ifndef cursor_changed
void cursor_changed IFN2(int, x, int, y)
{
#ifndef REAL_VGA
        UNUSED(x);
        UNUSED(y);

        setVideodirty_total(getVideodirty_total() + 1);
#else
    IU32 offset;

    offset = (y * 2 * get_chars_per_line()) + (x << 1);
    offset += get_screen_start()<<1;    /* Because screen start is in WORDS */
    vga_card_place_cursor((word)offset);
#endif
}
#endif

void host_cga_cursor_has_moved IFN2(int, x, int, y)
{
        cursor_changed(x,y);
}

/* Called when the start & end of the cursor are changed. */

void base_cursor_shape_changed IFN0()
{
        cursor_changed(get_cur_x(),get_cur_y());
}

#ifndef REAL_VGA
#ifdef HERC

#define DIRTY ((unsigned char)-1)

void     herc_update_screen IFN0()
{
    register int    i, j, k, offs, y;
    register USHORT *from, *to;
    int        lines_per_screen = get_screen_length() / get_bytes_per_line();
    /* lines of text on screen */
    half_word       begin[349], end[348];

    if(( getVideodirty_total() == 0 ) || get_display_disabled())
                return;

    host_start_update();

    if (get_cga_mode() == TEXT)
    {
        /*
         * arbitrary limit over which we just repaint the whole screen in one operation, assuming
         * this is more efficient than working out large minimum rectangles. This value should be
         * tuned at some future point.
         */
        to = (USHORT *) &video_copy[get_screen_start()];
        from = (USHORT *) get_screen_ptr((get_screen_start() << 1));

        if (getVideodirty_total() > 1500)
        {
            for (i = get_screen_length() >> 1; i > 0; i--)
                *to++ = *from++;

                offs = 0;
                y = 0;

                for( i = 0; i < lines_per_screen; i++ )
                {
                    (*paint_screen) (offs, 0, y, get_bytes_per_line() );
                        offs += get_bytes_per_line();
                        y += get_host_char_height();
                }
        }
        else
        {
            /*
             * step through row/cols looking for a dirty bit then look for the last clear dirty bit,
             * and draw the line of text
             */
            register int    ints_per_line = get_bytes_per_line() >> 1;

            for (i = 0, offs = 0; i < lines_per_screen; i++, offs += get_bytes_per_line())
            {
                for (j = 0; j < ints_per_line; j++)
                {
                    if (*to++ != *from++)
                    {
                        to--;
                        from--;
                        for (k = ints_per_line - 1 - j; *(to + k) == *(from + k); k--)
                            ;

                        (*paint_screen) (offs + (j << 1), j * get_pix_char_width(),
                                                        i * get_host_char_height() , (k << 1) + 2 );

                        for (k = j; k < ints_per_line; k++)
                            *to++ = *from++;
                        break;                   /* onto next line */
                    }
                }
            }
        }                                        /* end else getVideodirty_total() > 1500  */

        remove_old_cursor();

        if (is_cursor_visible())
        {
                half_word attr;

                dirty_curs_x = get_cur_x();
                dirty_curs_y = get_cur_y();

                dirty_curs_offs = dirty_curs_y * get_bytes_per_line() + (dirty_curs_x << 1);
                attr = *(get_screen_ptr(dirty_curs_offs + 1));

                host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
        }
    }
    else                                         /* GRAPHICS  MODE */
    {

        to = (USHORT *) &video_copy[0];
        from = (USHORT *) get_screen_ptr(get_screen_start());

        /*
         * arbitrary limit over which we just repaint the whole screen in one operation, assuming
         * this is more efficient than working out large minimum rectangles. This value should be
         * tuned at some future point.
         */

        if (getVideodirty_total() > 8000)
        {
            for (i = 16384; i > 0; i--)
                *to++ = *from++;
            (*paint_screen) (0, 0, 90, 348);
        }
        else
        {
            for (i = 0; i < 348; i += 4)         /* bank 0 */
            {
                begin[i] = DIRTY;
                for (j = 0; j < 45; j++)
                {
                    if (*to++ != *from++)
                    {
                        to--;
                        from--;
                        for (k = 44 - j; *(to + k) == *(from + k); k--)
                            ;
                        begin[i] = j;
                        end[i] = j + k;
                        for (k = j; k < 45; k++)
                            *to++ = *from++;
                        break;                   /* onto next scan line */
                    }
                }
            }

            to += 181;
            from += 181;                         /* skip over the gap */

            for (i = 1; i < 349; i += 4)         /* bank 1 */
            {
                begin[i] = DIRTY;
                for (j = 0; j < 45; j++)
                {
                    if (*to++ != *from++)
                    {
                        to--;
                        from--;
                        for (k = 44 - j; *(to + k) == *(from + k); k--)
                            ;
                        begin[i] = j;
                        end[i] = j + k;
                        for (k = j; k < 45; k++)
                            *to++ = *from++;
                        break;                   /* onto next scan line */
                    }
                }
            }

            to += 181;
            from += 181;                         /* skip over the gap */

            for (i = 2; i < 348; i += 4)         /* bank 2 */
            {
                begin[i] = DIRTY;
                for (j = 0; j < 45; j++)
                {
                    if (*to++ != *from++)
                    {
                        to--;
                        from--;
                        for (k = 44 - j; *(to + k) == *(from + k); k--)
                            ;
                        begin[i] = j;
                        end[i] = j + k;
                        for (k = j; k < 45; k++)
                            *to++ = *from++;
                        break;                   /* onto next scan line */
                    }
                }
            }

            to += 181;
            from += 181;                         /* skip over the gap */

            for (i = 3; i < 349; i += 4)         /* bank 3 */
            {
                begin[i] = DIRTY;
                for (j = 0; j < 45; j++)
                {
                    if (*to++ != *from++)
                    {
                        to--;
                        from--;
                        for (k = 44 - j; *(to + k) == *(from + k); k--)
                            ;
                        begin[i] = j;
                        end[i] = j + k;
                        for (k = j; k < 45; k++)
                            *to++ = *from++;
                        break;                   /* onto next scan line */
                    }
                }
            }

            begin[348] = DIRTY;                  /* end marker */
            for (i = 0; i < 348; i++)
            {
                register int    beginx, endx, beginy;
                if (begin[i] != DIRTY)           /* a dirty scan line */
                {
                    beginy = i;
                    beginx = begin[i];
                    endx = end[i];
                    while (begin[++i] != DIRTY)
                    {
                        if (begin[i] < beginx)
                            beginx = begin[i];
                        if (end[i] > endx)
                            endx = end[i];
                    }
                    (*paint_screen) (beginy, 2 * beginx, 2 * (endx - beginx + 1), i - beginy);
                }
            }
        }                                        /* end else (getVideodirty_total() > 8000) */
    }

    setVideodirty_total(0);

    host_end_update();
}
#endif

#if defined(VGG) || defined(EGG)

#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_EGA.seg"
#endif

/* ============================================================================
 * The following routines enable and disable the GFX update routines
 * by saving/restoring the current routines and replacing them with
 * dummy routines that do nothing while update is disabled.
 *
 * AJO 23/4/93
 * Any sequence of enable/disable/mode change should now work as expected.
 * ============================================================================
 */

LOCAL UPDATE_ALG save_update_alg;
LOCAL IBOOL gfx_update_routines_inhibited = FALSE;

LOCAL VOID save_gfx_update_routines IFN0()
{
    /*
     * Save all current update functions so we can restore them later
     */
    save_update_alg.mark_byte   = update_alg.mark_byte;
    save_update_alg.mark_word   = update_alg.mark_word;
    save_update_alg.mark_fill   = update_alg.mark_fill;
    save_update_alg.mark_wfill  = update_alg.mark_wfill;
    save_update_alg.mark_string = update_alg.mark_string;
    save_update_alg.calc_update = update_alg.calc_update;
    save_update_alg.scroll_up   = update_alg.scroll_up;
    save_update_alg.scroll_down = update_alg.scroll_down;
}

LOCAL VOID inhibit_gfx_update_routines IFN0()
{
    /*
     * Set all current update routines to dummy ones that do nothing.
     */
    gfx_update_routines_inhibited = TRUE;

    update_alg.mark_byte        = (T_mark_byte)simple_update;
    update_alg.mark_word        = (T_mark_word)simple_update;
    update_alg.mark_fill        = (T_mark_fill)simple_update;
    update_alg.mark_wfill       = (T_mark_wfill)simple_update;
    update_alg.mark_string      = (T_mark_string)simple_update;
    update_alg.calc_update      = dummy_calc;
    update_alg.scroll_up        = dummy_scroll;
    update_alg.scroll_down      = dummy_scroll;
}

GLOBAL void disable_gfx_update_routines IFN0()
{
    /*
     * Disable GFX update routines; do nothing if update already disabled,
     * otherwise save the current routines and install dummy ones in their
     * place.
     */
    note_entrance0("disable gfx update routines");

    if (gfx_update_routines_inhibited)
        return;

    save_gfx_update_routines();
    inhibit_gfx_update_routines();
}

GLOBAL void enable_gfx_update_routines IFN0()
{
    /*
     * Reenable GFX update routines; copy the saved routines back to be
     * the current ones.
     */
    note_entrance0("enable gfx update routines");

    gfx_update_routines_inhibited = FALSE;

    update_alg.mark_byte        = save_update_alg.mark_byte;
    update_alg.mark_word        = save_update_alg.mark_word;
    update_alg.mark_fill        = save_update_alg.mark_fill;
    update_alg.mark_wfill       = save_update_alg.mark_wfill;
    update_alg.mark_string      = save_update_alg.mark_string;
    update_alg.calc_update      = save_update_alg.calc_update;
    update_alg.scroll_up        = save_update_alg.scroll_up;
    update_alg.scroll_down      = save_update_alg.scroll_down;
}

#endif /* VGG */
#ifdef SEGMENTATION             /* See note with first use of this flag */
#include "SOFTPC_GRAPHICS.seg"
#endif

#ifdef NTVDM

void init_text_rect();
void add_to_rect(int screen_start,register int x, register int y, int len);
void paint_text_rect(int screen_start);

int RectDefined;
int RectTop, RectBottom, RectLeft, RectRight;

#ifdef MONITOR
/*
 * Update the window to look like the regen buffer says it should
 * and with no help from dirty_total.
 */

static int now_cur_x = -1, now_cur_y = -1;
/*
 * Reset the static cursor variables:
 */
GLOBAL void resetNowCur()
{
        now_cur_x = -1;
        now_cur_y = -1;
}

#ifdef JAPAN
void mon_text_update_03( void );

void mon_text_update_03()
{

    register int i;     /* Loop counters                */
    register int j,k;
    register unsigned short *from,*to;
    register int ints_per_line = get_offset_per_line()>>1;
    int lines_per_screen;
    int len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;
    int dwords_to_compare;

    byte *pInt10Flag;
    static unsigned short save_char; /* save DBCS first byte */
    static unsigned short *save_pos;
    static NtInt10FlagUse = FALSE;

    /*::::::::::::::::::::::::::::::::::::::::::::::: Is the display disable */

    if(get_display_disabled()) return;

    /*::::::::::::::::::::::::::::::::: get screen size and location details */

    screen_start=get_screen_start()<<1;
    ALIGN_SCREEN_START(screen_start);

    // mode 73h support
    if ( *(byte *)DosvModePtr == 0x73 ) {
        to = (unsigned short *)&video_copy[screen_start*2];
        from = (unsigned short *) get_screen_ptr(screen_start*2);
    }
    else {
        to = (unsigned short *)&video_copy[screen_start];
        from = (unsigned short *) get_screen_ptr(screen_start);
    }

    /*::::::::::::::::::::::::::::::::::::::::::: Check for buffer overflows */

#ifndef PROD
    if(((int)to) & 3)           printf("Video copy not aligned on DWORD\n");
    if(get_screen_length() & 3) printf("Screen size incorrect\n");
#endif

    /*::::::::::::::::::::::::::::::::::::::::::::::: Has the screen changed */

#ifndef CPU_40_STYLE
#if defined(NTVDM)
    if( VGLOBS && VGLOBS->dirty_flag >= 1000000L ){
#else
    if( VGLOBS && VGLOBS->dirtyTotal >= 1000000L ){
#endif

#else
    if(getVideodirty_total() >= 1000000L ){
#endif

        /*
        ** screen_refresh_required() has requested a complete screen
        ** repaint by setting the dirtyTotal.
        **
        ** When switching between display pages video copy and display
        ** memory could be the same so our normal partial update algorithm
        ** gets confused.
        ** This scheme updates video copy and then forces a complete
        ** repaint.
        ** Another option would have been to splat video copy and then go
        ** through the partial update code below, but this is quicker.
        **
        ** Tim Jan 93.
        */
        setVideodirty_total(0);

        /*
        ** Copy the screen data to our video copy.
        */
        dwords_to_compare = get_screen_length() / 4;
        _asm
        {
                push esi        //Save orginal values of registers used by the
                push edi        //complier
                push ecx

                mov edi,to      //Ptr to video copy
                mov esi,from    //Ptr to intel video memory

                mov ecx,dwords_to_compare
                rep movsd       //Move screen data to video copy.

                pop ecx
                pop edi
                pop esi
        }

        /*
        ** Re-paint the whole screen.
        ** Set up rectangle dimension globals here for paint_text_rect(),
        ** instead of calling add_to_rect().
        */
        while ( NtInt10FlagUse ) {
            DbgPrint( "NtInt10Flag busy\n" );
            Sleep( 100L );
        }
            NtInt10FlagUse = TRUE;
            memcpy( NtInt10Flag, Int10Flag, 80*50 );
        {
            register int i;
            register byte *p;

            for ( p = Int10Flag, i = 0; i < 80*50; i++ ) {
               *p++ &= (~INT10_CHANGED); // reset
            }
        }

        if (get_offset_per_line() == 0)    /* showing up in stress */
            lines_per_screen = 25;
        else
            lines_per_screen = get_screen_length()/get_offset_per_line();
        RectTop = 0;
        RectLeft = 0;
        RectBottom = lines_per_screen - 1;
        RectRight = ints_per_line - 1;
        RectDefined = TRUE;
        host_start_update();
        paint_text_rect(screen_start);
        host_end_update();

        NtInt10FlagUse = FALSE;

    }else{

      /*
      ** Normal partial screen update.
      */

      /*::::::::::::::::::::::: Repaint parts of the screen that have changed */


      if (get_offset_per_line() == 0)    /* showing up in stress */
          lines_per_screen = 25;
      else
          lines_per_screen = get_screen_length()/get_offset_per_line();

      if( Int10FlagCnt )
      {
           Int10FlagCnt = 0;

           host_start_update();
           /* Screen changed, calculate position of first variation */

           init_text_rect();

           while ( NtInt10FlagUse ) {
               DbgPrint( "NtInt10Flag busy\n" );
               Sleep( 100L );
           }
           NtInt10FlagUse = TRUE;
           memcpy( NtInt10Flag, Int10Flag, 80*50 );
        {
           register int i;
           register byte *p;

           for ( p = Int10Flag, i = 0; i < 80*50; i++ ) {
               *p++ &= (~INT10_CHANGED); // reset
           }
        }

           pInt10Flag = NtInt10Flag;

           for( i = 0; i < lines_per_screen; i++, pInt10Flag += ints_per_line )
           {
                for ( j = 0; j < ints_per_line; j++ ) {
                    if ( pInt10Flag[j] & INT10_CHANGED )
                        break;
                }
                if ( j == ints_per_line )
                    continue;             // not change goto next line

                for ( k = ints_per_line - 1; k >= j; k-- ) {
                    if ( pInt10Flag[k] & INT10_CHANGED )
                        break;
                }

                // ntraid:mskkbug#3297,3515: some character does not display
                // 11/6/93 yasuho
                // Repaint the incomplete DBCS character
                if (j && (pInt10Flag[j] & INT10_DBCS_TRAILING) &&
                    (pInt10Flag[j-1] == INT10_DBCS_LEADING)) {
                        j--;
                        pInt10Flag[j] |= INT10_CHANGED;
                }

                to += j;
                from += j;

                len = k - j + 1;
                x = j;

                add_to_rect(screen_start, x, i, len);

                /*.................. transfer data painted to video copy */

                for( k = j; k < ints_per_line; k++ )
                    *to++ = *from++;
          }

          /* End of screen, flush any outstanding text update rectangles */
          paint_text_rect(screen_start);

          NtInt10FlagUse = FALSE;
          host_end_update();

     } /* End of partial screen update */

    } /* End of if dirtyTotal stuff, which selects full or partial repaint */


    /*:::::::::::::::::::::::::::::::::::::: Does the cursor need repainting */

    if(is_cursor_visible())
    {
        half_word attr;

        dirty_curs_x = get_cur_x();
        dirty_curs_y = get_cur_y();

        if(dirty_curs_x == now_cur_x && dirty_curs_y == now_cur_y)
        {
            host_end_update();
            return;
        }

        now_cur_x = dirty_curs_x;
        now_cur_y = dirty_curs_y;
        dirty_curs_offs = screen_start+dirty_curs_y * get_offset_per_line() + (dirty_curs_x<<1);

        if(dirty_curs_offs < 0x8001)    /* no lookup in possible gap */
            attr = *(get_screen_ptr(dirty_curs_offs + 1));
        else
            attr = 0;   /* will be off screen anyway */

        host_paint_cursor(dirty_curs_x, dirty_curs_y, attr);
    }

}  // mon_text_update_03()

#endif // JAPAN
#if defined(KOREA)
// For Text emulation
void mon_text_update_ko()
{
    register int i;     /* Loop counters                */
    register int j,k;
    register unsigned long *from,*to;
    register int ints_per_line = get_offset_per_line()>>2;
    int lines_per_screen;
    int len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;
    int dwords_to_compare;

    unsigned char *flag_from, *flag_to;
    boolean  DBCSState1 = FALSE;
    boolean  DBCSState2 = FALSE;

    /*::::::::::::::::::::::::::::::::::::::::::::::: Is the display disable */

    if(get_display_disabled()) return;

    /*::::::::::::::::::::::::::::::::: get screen size and location details */

    screen_start=get_screen_start()<<1;
    ALIGN_SCREEN_START(screen_start);

    to = (unsigned long *)&video_copy[screen_start];
    from = (unsigned long *) get_screen_ptr(screen_start);

    /*::::::::::::::::::::::::::::::::::::::::::: Check for buffer overflows */

#ifndef PROD
    if(((int)to) & 3)           printf("Video copy not aligned on DWORD\n");
    if(get_screen_length() & 3) printf("Screen size incorrect\n");
#endif

    /*::::::::::::::::::::::::::::::::::::::::::::::: Has the screen changed */

#ifndef CPU_40_STYLE
#if defined(NTVDM)
    if( VGLOBS && VGLOBS->dirty_flag >= 1000000L ){
#else
    if( VGLOBS && VGLOBS->dirtyTotal >= 1000000L ){
#endif

#else
    if(getVideodirty_total() >= 1000000L ){
#endif

        /*
        ** screen_refresh_required() has requested a complete screen
        ** repaint by setting the dirtyTotal.
        **
        ** When switching between display pages video copy and display
        ** memory could be the same so our normal partial update algorithm
        ** gets confused.
        ** This scheme updates video copy and then forces a complete
        ** repaint.
        ** Another option would have been to splat video copy and then go
        ** through the partial update code below, but this is quicker.
        **
        ** Tim Jan 93.
        */
        setVideodirty_total(0);

        /*
        ** Copy the screen data to our video copy.
        */
        dwords_to_compare = get_screen_length() / 4;
        _asm
        {
                push esi        //Save orginal values of registers used by the
                push edi        //complier
                push ecx

                mov edi,to      //Ptr to video copy
                mov esi,from    //Ptr to intel video memory

                mov ecx,dwords_to_compare
                rep movsd       //Move screen data to video copy.

                pop ecx
                pop edi
                pop esi
        }

        /*
        ** Re-paint the whole screen.
        ** Set up rectangle dimension globals here for paint_text_rect(),
        ** instead of calling add_to_rect().
        */
        if (get_offset_per_line() == 0)    /* showing up in stress */
            lines_per_screen = 25;
        else
            lines_per_screen = get_screen_length()/get_offset_per_line();
        RectTop = 0;
        RectLeft = 0;
        RectBottom = lines_per_screen - 1;
        RectRight = (ints_per_line<<1) - 1;
        RectDefined = TRUE;
        host_start_update();
        paint_text_rect(screen_start);
        host_end_update();

    }else{

      /*
      ** Normal partial screen update.
      */

      dwords_to_compare = get_screen_length() / 4;

      _asm
      {
        push esi        //Save orginal values of registers used by the
        push edi        //complier
        push ecx

        mov esi,to      //Ptr to screen copy
        mov edi,from    //Ptr to intel video memory

        mov ecx,dwords_to_compare
        repe cmpsd      //Compare screen buffers

        mov dwords_to_compare,ecx
//      mov to,esi
//      mov from,edi

        pop ecx
        pop edi
        pop esi
      }

      /*::::::::::::::::::::::: Repaint parts of the screen that have changed */


      if (get_offset_per_line() == 0)    /* showing up in stress */
          lines_per_screen = 25;
      else
          lines_per_screen = get_screen_length()/get_offset_per_line();

      if(dwords_to_compare)
      {
           host_start_update();
           /* Screen changed, calculate position of first variation */

           init_text_rect();

           flag_from = (unsigned char*)Int10Flag;
           flag_to   = (unsigned char*)NtInt10Flag;
           wfrom = (unsigned short *)from;
           wto   = (unsigned short *)to;
           for(i=0;i<lines_per_screen;i++)
           {
            for(j=0;j<ints_per_line*2;j++)
            {
                if (DBCSState1)
                {
                    *flag_from++ = INT10_DBCS_TRAILING;
                    DBCSState1 = FALSE;
                }
                else if (DBCSState1 = is_dbcs_first(LOBYTE(*wfrom)))
                    *flag_from++ = INT10_DBCS_LEADING;
                else
                    *flag_from++ = INT10_SBCS;
                wfrom++;

                if (DBCSState2)
                {
                    *flag_to++ = INT10_DBCS_TRAILING;
                    DBCSState2 = FALSE;
                }
                else if (DBCSState2 = is_dbcs_first(LOBYTE(*wto)))
                    *flag_to++ = INT10_DBCS_LEADING;
                else
                    *flag_to++ = INT10_SBCS;
                wto++;
            }
           }

           flag_from = (unsigned char*)Int10Flag;
           flag_to   = (unsigned char*)NtInt10Flag;

           for(i=0;i<lines_per_screen;i++)
           {
            for(j=0;j<ints_per_line;j++)
            {
                flag_from+=2;
                flag_to+=2;
                if(*to++ != *from++)
                {
                    to--;from--;
                    flag_to-=2;flag_from-=2;
                    for(k=ints_per_line-1-j;*(to+k)== *(from+k);k--){};
                    /*
                     * Note: For text mode there is one char for every word.
                     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
                     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
                     * y_coord=height_of_one_char*2*line
                     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
                     * The host y co-ords are doubled
                     */

                    /* one or more ints of data are now selected
                       but refine difference to words (i.e. characters),
                       to avoid a glitch on the screen when typing in to
                       a dumb terminal  */

                    len    = (k<<2) + 4;
                    x      = (j<<1);

                    wfrom = (unsigned short *)from;
                    wto   = (unsigned short *)to;
                    if (*wfrom == *wto)
                    {
                        if (*flag_from & INT10_DBCS_TRAILING)
                        {
                            x--;
                            len += 2;
                        }
                        else if ( !(*flag_from & INT10_DBCS_LEADING) &&
                                  !(*flag_to   & INT10_DBCS_LEADING)   )
                        {
                            x++;
                            len -= 2;
                        }
                    }
                    else if ( (*flag_from & INT10_DBCS_TRAILING) ||
                              (*flag_to   & INT10_DBCS_TRAILING)   )
                    {
                        x--;
                        len += 2;
                    }

                    wfrom += (k<<1) + 1;
                    wto   += (k<<1) + 1;
                    if (*wfrom == *wto)
                    {
                        if (*(flag_from+(k<<1)+1) & INT10_DBCS_LEADING)
                        {
                            len += 2;
                        }
                        else if ( !(*(flag_from+(k<<1)+1) & INT10_DBCS_TRAILING) &&
                                  !(*(flag_to+(k<<1)+1)   & INT10_DBCS_TRAILING)   )
                        {
                            len -= 2;
                        }
                    }
                    else if ( (*(flag_from+(k<<1)+1) & INT10_DBCS_LEADING) ||
                              (*(flag_to+(k<<1)+1)   & INT10_DBCS_LEADING)   )
                    {
                        len += 2;
                    }

                    add_to_rect(screen_start, x, i, len/2);

                    /*.............................. transfer data painted to video copy */

                    for(k=j;k<ints_per_line;k++)
                        *to++ = *from++;

                    flag_from += (ints_per_line-j) << 1;
                    flag_to   += (ints_per_line-j) << 1;

                    break;      /* onto next line */
                }
            }
          }

          /* End of screen, flush any outstanding text update rectangles */
          paint_text_rect(screen_start);

          host_end_update();

     } /* End of partial screen update */

    } /* End of if dirtyTotal stuff, which selects full or partial repaint */


    /*:::::::::::::::::::::::::::::::::::::: Does the cursor need repainting */

    if(is_cursor_visible())
    {
        half_word attr;

        dirty_curs_x = get_cur_x();
        dirty_curs_y = get_cur_y();

        if(dirty_curs_x == now_cur_x && dirty_curs_y == now_cur_y)
        {
            host_end_update();
            return;
        }

        now_cur_x = dirty_curs_x;
        now_cur_y = dirty_curs_y;
        dirty_curs_offs = screen_start+dirty_curs_y * get_offset_per_line() + (dirty_curs_x<<1);

        if(dirty_curs_offs < 0x8001)    /* no lookup in possible gap */
            attr = *(get_screen_ptr(dirty_curs_offs + 1));
        else
            attr = 0;   /* will be off screen anyway */

        host_paint_cursor(dirty_curs_x, dirty_curs_y, attr);
    }


}
#endif

void mon_text_update()
{

    register int i;     /* Loop counters                */
    register int j,k;
    static unsigned long *from = NULL, *to = NULL;
    unsigned long *fromx,*tox;
    register int ints_per_line = get_offset_per_line()>>2;
    int lines_per_screen;
    int len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;
    int dwords_to_compare_first, dwords_to_compare_second;

    //
    // If mode_change_required is set, we need to switch to correct display
    // mode before updating screen.  So here, we do nothing and wait for
    // nt_graphics_tick to change mode and update screen.
    //

    if (get_mode_change_required()) {
        return;
    }
#ifdef JAPAN
    if (BOPFromDispFlag && *(word *)DBCSVectorAddr) {
        if (*(byte *)DosvModePtr == 0x03 || *(byte *)DosvModePtr == 0x73) {
            mon_text_update_03();
            return;
        }
    }
#elif defined(KOREA) // JAPAN
    if (BOPFromDispFlag && *(word *)DBCSVectorAddr) {
        if (*(byte *)DosvModePtr == 0x03) {
            mon_text_update_ko();
            return;
        }
    }
#endif // KOREA
    /*::::::::::::::::::::::::::::::::::::::::::::::: Is the display disable */

    if(get_display_disabled()) return;

    /*::::::::::::::::::::::::::::::::: get screen size and location details */


    screen_start=get_screen_start()<<1;
    ALIGN_SCREEN_START(screen_start);


    /*::::::::::::::::::::::::::::::::::::::::::::::: Has the screen changed */

#ifndef CPU_40_STYLE
#if defined(NTVDM)
    if( VGLOBS && VGLOBS->dirty_flag >= 1000000L ){
#else
    if( VGLOBS && VGLOBS->dirtyTotal >= 1000000L ){
#endif

#else
    if(getVideodirty_total() >= 1000000L ){
#endif

        /*
        ** screen_refresh_required() has requested a complete screen
        ** repaint by setting the dirtyTotal.
        **
        ** When switching between display pages video copy and display
        ** memory could be the same so our normal partial update algorithm
        ** gets confused.
        ** This scheme updates video copy and then forces a complete
        ** repaint.
        ** Another option would have been to splat video copy and then go
        ** through the partial update code below, but this is quicker.
        **
        ** Tim Jan 93.
        */
        setVideodirty_total(0);

        /*
        ** Copy the screen data to our video copy.
        */
        dwords_to_compare_first = get_screen_length() / 4;
        to = (unsigned long *)&video_copy[screen_start];
        from = (unsigned long *) get_screen_ptr(screen_start);

        /* Check for buffer overflows */

#ifndef PROD
        if(((int)to) & 3)           printf("Video copy not aligned on DWORD\n");
        if(get_screen_length() & 3) printf("Screen size incorrect\n");
#endif
        _asm
        {
                push esi        //Save orginal values of registers used by the
                push edi        //complier
                push ecx

                mov edi,to      //Ptr to video copy
                mov esi,from    //Ptr to intel video memory

                mov ecx,dwords_to_compare_first
                rep movsd       //Move screen data to video copy.

                pop ecx
                pop edi
                pop esi
        }

        /*
        ** Re-paint the whole screen.
        ** Set up rectangle dimension globals here for paint_text_rect(),
        ** instead of calling add_to_rect().
        */
        if (get_offset_per_line() == 0)    /* showing up in stress */
            lines_per_screen = 25;
        else
            lines_per_screen = get_screen_length()/get_offset_per_line();
        RectTop = 0;
        RectLeft = 0;
        RectBottom = lines_per_screen - 1;
        RectRight = (ints_per_line<<1) - 1;
        RectDefined = TRUE;
        host_start_update();
        paint_text_rect(screen_start);
        host_end_update();

    } else {

        /*
        ** Normal partial screen update.
        */
        dwords_to_compare_first = get_screen_length() / 4;
        tox = (unsigned long *)&video_copy[screen_start];
        fromx = (unsigned long *) get_screen_ptr(screen_start);
        if ((unsigned long)from >= (unsigned long)get_screen_ptr(screen_start) + get_screen_length() ||
            (unsigned long)from < (unsigned long)get_screen_ptr(screen_start))
        {
            to = tox;
            from = fromx;
            dwords_to_compare_second = 0;

            /* Check for buffer overflows */

#ifndef PROD
            if(((int)to) & 3)           printf("Video copy not aligned on DWORD\n");
            if(get_screen_length() & 3) printf("Screen size incorrect\n");
#endif
        }
        else
        {
            dwords_to_compare_second = to - (unsigned long *)&video_copy[screen_start];
            dwords_to_compare_first -= dwords_to_compare_second;
        }

        //
        // Has the screen changed
        //
        _asm
        {
            push esi        //Save orginal values of registers used by the
            push edi        //complier
            push ecx

            mov esi,to      //Ptr to screen copy
            mov edi,from    //Ptr to intel video memory

            mov ecx,dwords_to_compare_first
            repe cmpsd      //Compare screen buffers

            jne short done

            mov esi,tox     //Ptr to screen copy
            mov edi,fromx   //Ptr to intel video memory

            mov ecx,dwords_to_compare_second
            repe cmpsd      //Compare screen buffers

            done:
            mov to, esi
            mov from, edi
            mov dwords_to_compare_first,ecx

            pop ecx
            pop edi
            pop esi
        }


        /* Repaint parts of the screen that have changed */


        if(dwords_to_compare_first)
        {
             host_start_update();
             /* Screen changed, calculate position of first variation */

             init_text_rect();

             if (get_offset_per_line() == 0)    /* showing up in stress */
                 lines_per_screen = 25;
             else
                 lines_per_screen = get_screen_length()/get_offset_per_line();

             for(i=0;i<lines_per_screen;i++)
             {
              for(j=0;j<ints_per_line;j++)
              {
                  if(*tox++ != *fromx++)
                  {
                      tox--;fromx--;
                      for (k = ints_per_line-1-j; *(tox + k)== *(fromx + k); k--){};
                      /*
                       * Note: For text mode there is one char for every word.
                       * no of bytes into screen=line*bytes_per_line + ints_into_line*4
                       * x_coord=width_of_one_char*(no_of_ints_into_line*2)
                       * y_coord=height_of_one_char*2*line
                       * length=no_of_ints*4+4     the plus 4 is to counteract the k--
                       * The host y co-ords are doubled
                       */

                      /* one or more ints of data are now selected
                         but refine difference to words (i.e. characters),
                         to avoid a glitch on the screen when typing in to
                         a dumb terminal  */

                      len    = (k<<2) + 4;
                      x      = (j<<1);

                      wfrom = (unsigned short *)fromx;
                      wto   = (unsigned short *)tox;
                      if (*wfrom == *wto)
                      {
                          x++;
                          len -= 2;
                      }
                      wfrom += (k<<1) + 1;
                      wto   += (k<<1) + 1;
                      if (*wfrom == *wto)
                      {
                          len -= 2;
                      }

                      add_to_rect(screen_start, x, i, len/2);

                      /* transfer data painted to video copy */

                      for(k=j;k<ints_per_line;k++)
                          *tox++ = *fromx++;

                      break;      /* onto next line */
                  }
              }
            }

            /* End of screen, flush any outstanding text update rectangles */
            paint_text_rect(screen_start);

            host_end_update();

            to -= ints_per_line;
            from -= ints_per_line;

        } /* End of partial screen update */
    } /* End of if dirtyTotal stuff, which selects full or partial repaint */

    /* Does the cursor need repainting */

    if(is_cursor_visible())
    {
        half_word attr;

        dirty_curs_x = get_cur_x();
        dirty_curs_y = get_cur_y();

        if(dirty_curs_x == now_cur_x && dirty_curs_y == now_cur_y)
        {
            host_end_update();
            return;
        }

        now_cur_x = dirty_curs_x;
        now_cur_y = dirty_curs_y;
        dirty_curs_offs = screen_start+dirty_curs_y * get_offset_per_line() + (dirty_curs_x<<1);

        if(dirty_curs_offs < 0x8001)    /* no lookup in possible gap */
            attr = *(get_screen_ptr(dirty_curs_offs + 1));
        else
            attr = 0;   /* will be off screen anyway */

        host_paint_cursor(dirty_curs_x, dirty_curs_y, attr);
    }

}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

boolean mon_text_scroll_up IFN6(sys_addr, start, int, width, int, height, int, attr, int, lines, int, colour)
{
    short blank_word, *ptr, *top_left_ptr,*top_right_ptr, *bottom_right_ptr;
    unsigned short dummy;
    unsigned char *p;
    int words_per_line;
        int i,tlx,tly;
        int bpl = 2*get_chars_per_line();
        long start_offset;
        register half_word *src,*dest;
        boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif
#ifdef JAPAN
        // mode73h support
        if (!is_us_mode() && (*(byte *)DosvModePtr == 0x73)) {
            bpl = 4 * get_chars_per_line();
        }
#endif // JAPAN
        /*
         * The colour we fill with for colour text displays is controlled by
         * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
         */
        colour = ((half_word)attr>>4) & 7;

/*
 * Reduce the width of the rectangle if any right hand area is completely
 * blank.
 *
 * Don't reduce the size of the scrolling region for a dumb terminal.
 * Dumb terminal uses line feeds to scroll up, but only if the whole
 * screen is to be scrolled.  Reducing the scroll region causes
 * the whole region to be redrawn.
 */

        /* originally dummy was char [2] */
        /* unfortunately doing (short) *dummy */
        /* causes a bus error on M88K */
        p = (unsigned char *) &dummy;
        p [0] = ' ';
        p [1] = (unsigned char)attr;
        blank_word = dummy;

        words_per_line   = get_chars_per_line();
        top_left_ptr     = (short *) get_screen_ptr(start - gvi_pc_low_regen);
        top_right_ptr    = top_left_ptr + (width >> 1) - 1;
        bottom_right_ptr = top_right_ptr + words_per_line * (height - 1);
        ptr = bottom_right_ptr;
        if (width > 2) /* dont want to get a zero rectangle for safetys sake */
        {
            while (*ptr == blank_word)
            {
                if (ptr == top_right_ptr)       /* reached top of column? */
                {
                    top_right_ptr--;    /* yes go to bottom of next */
                    bottom_right_ptr--;
                    if (top_right_ptr == top_left_ptr)
                        break;
                    ptr = bottom_right_ptr;
                }
                else
                    ptr -= words_per_line;
            }
        }
        width = (int)(top_right_ptr - top_left_ptr + 1) << 1;

        /* do the host stuff */
        start_offset = start - get_screen_start()*2 - gvi_pc_low_regen;
        tlx = (int)(start_offset%get_bytes_per_line())*get_pix_char_width()/2;
        tly = (int)(start_offset/get_bytes_per_line())*get_host_char_height();
        result = host_scroll_up(tlx,tly,tlx+width/2*get_pix_char_width()-1,
                                tly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

        if(!result)
                return FALSE;


        adjust_cursor( UP, tlx, tly, width >> 1, height, lines, bpl );

        /* Scroll up the video_copy */
        dest = video_copy + start-gvi_pc_low_regen;
        src = dest + lines * bpl;

        if(width == bpl)
        {
                /* Can do the whole thing in one go */
                memcpy(dest,src,width*(height-lines));
                fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest+width*(height-lines),width*lines/2);
        }
        else
        {
                /* Not scrolling whole width of screen, so do each line seperatly */
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width);
                        dest += bpl;
                        src += bpl;
                }

                /* Fill exposed area of video copy */

                for(i=0;i<lines;i++)
                {
                        fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest,width/2);
                        dest += bpl;
                }
        }

        /* Update video buffer */

        dest = get_screen_ptr(start - gvi_pc_low_regen);
        src = dest + lines * bpl;
        for(i=0;i<height-lines;i++)
        {
                memcpy(dest,src,width);
                dest += bpl;
                src += bpl;
        }

        /* Fill exposed area of buffer */

        for(i=0;i<lines;i++)
        {
                fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest,width/2);
                dest += bpl;
        }

        host_scroll_complete();

        return TRUE;
}

boolean mon_text_scroll_down IFN6(sys_addr, start, int, width, int, height, int, attr, int, lines, int, colour)
{
        int i,tlx,tly;
        int bpl = 2*get_chars_per_line();
        long start_offset;
        register half_word *src,*dest;
        boolean result;

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
        if ( getVM() )
           return FALSE;   /* Don't optimise in V86 Mode */
#endif
#ifdef JAPAN
        // mode73h support
        if (!is_us_mode() && (*(byte *)DosvModePtr == 0x73)) {
        bpl = 4 * get_chars_per_line();
        }
#endif /// JAPAN

        /*
         * The colour we fill with for colour text displays is controlled by
         * bits 4-6 of attr, with bit 7 turning on blinking (which we don't support)
         */
        colour = ((half_word)attr>>4) & 7;


        /* do the host stuff */
        start_offset = start - get_screen_start() * 2 - gvi_pc_low_regen;
        tlx = (int)(start_offset%get_bytes_per_line())*get_pix_char_width()/2;
        tly = (int)(start_offset/get_bytes_per_line())*get_host_char_height();
        result = host_scroll_down(tlx,tly,tlx+width/2*get_pix_char_width()-1,
                        tly+height*get_host_char_height()-1, lines*get_host_char_height(),colour);

        if(!result)
                return FALSE;

        adjust_cursor( DOWN, tlx, tly, width >> 1, height, lines, bpl );

        /* Scroll down the video_copy */

        if(width == bpl)
        {
                /* Can do the whole thing in one go */
                src = video_copy + start - gvi_pc_low_regen;
                dest = src + lines * bpl;
                memcpy(dest,src,width*(height-lines));
                fwd_word_fill( (short)((' '<<8) | (half_word)attr), src,width*lines/2);
        }
        else
        {
                /* Not scrolling whole width of screen, so do each line seperatly */
                dest = video_copy + start-gvi_pc_low_regen + (height-1) * bpl;
                src = dest - lines * bpl;
                for(i=0;i<height-lines;i++)
                {
                        memcpy(dest,src,width);
                        dest -= bpl;
                        src -= bpl;
                }

                /* Fill exposed area of video copy */

                for(i=0;i<lines;i++)
                {
                        fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest,width/2);
                        dest -= bpl;
                }
        }

        /* Update video buffer */

        dest = get_screen_ptr(start - gvi_pc_low_regen) + (height-1) * bpl;
        src = dest - lines * bpl;
        for(i=0;i<height-lines;i++)
        {
                memcpy(dest,src,width);
                dest -= bpl;
                src -= bpl;
        }

        /* Fill exposed area of buffer */

        for(i=0;i<lines;i++)
        {
                fwd_word_fill( (short)((' '<<8) | (half_word)attr), dest,width/2);
                dest -= bpl;
        }

        host_scroll_complete();

        return TRUE;
}
#endif  /* MONITOR */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Text handling routines :::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#define MAX_LEFT_VARIATION  (2)
#define MAX_RIGHT_VARIATION (5)

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) < (b) ? (a) : (b))

int ExpandCount;
int BaseL, BaseR;

/* Init text rect variables */

void init_text_rect()
{
    RectDefined = FALSE;       /* No rectangle defined yet */
    ExpandCount = 0;
}

/* Add coordinates to rectangle */

void add_to_rect(int screen_start, register int x, register int y, int len)
{
    // Note the len will never be big enough to inc y
    int endx = x + len - 1;

    /* printf("add rect - (%d,%d) len %d\n", x, y, len); */


    /* Is there an existing rectangle */
    if(RectDefined)
    {
        /* Validate X variation and Y coord */

#if defined(JAPAN) || defined(KOREA)
        if( ( BaseL == x ) &&
            ( BaseR == endx )  &&
#else
        if(abs(BaseL - x) <= MAX_LEFT_VARIATION &&
           abs(BaseR - endx) <= MAX_RIGHT_VARIATION &&
#endif
           RectBottom+1 >= y)
        {
            /* Expand rectangle */
            ExpandCount++;
            /* printf("Expanding rect\n"); */

            RectLeft = MIN(RectLeft,x);
            RectRight = MAX(RectRight,endx);
            RectBottom = y;
            return;
        }
        else
        {
            paint_text_rect(screen_start);
        }
    }

    /* New rectangle */

    /* printf("Defining new rect\n"); */

    RectDefined = TRUE;     /* Rectangle defined */

    BaseL = x;              /* Base Left/Right */
    BaseR = endx;

    RectTop = y;            /* Define rectangle */
    RectLeft = x;

    RectBottom = y;
    RectRight = endx;
}


/* Paint rectangle */

void paint_text_rect(int screen_start)
{
#ifdef MONITOR
#ifdef JAPAN
    int offset;

    if (!is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73))
        offset = (RectTop * (get_offset_per_line()<<1)) + (RectLeft<<2);
    else
        offset = RectTop * get_offset_per_line() + (RectLeft<<1);
#else // !JAPAN
    int offset = RectTop * get_offset_per_line() + (RectLeft<<1);
#endif // !JAPAN
#else
    int offset = (RectTop * (get_offset_per_line()<<1)) + (RectLeft<<2);
#endif

    /* Is there a rectangled defined */
    if(!RectDefined) return;

    /* Paint rectangle */

    /* printf("Paint rect (%d,%d) (%d,%d)  \t[%d]\n",RectLeft,RectTop,RectRight,RectBottom,ExpandCount); */

    (*paint_screen)(offset + screen_start,                      /* Start Offset */
#ifdef MONITOR
                   RectLeft, RectTop,                           /* Screen X,Y */
#else
                   RectLeft*get_pix_char_width(),RectTop*get_host_char_height(),
#endif
                    (RectRight - RectLeft +1)*2,                /* Len */
                    RectBottom - RectTop +1);                   /* Height */

    RectDefined = FALSE;        /* Rectangle painted */
    ExpandCount = 0;
}

#ifndef MONITOR
#ifdef JAPAN
// This routine provides the same functionality as mon_text_update_03().
void jazz_text_update_jp();

void jazz_text_update_jp()
{

    register int i;     /* Loop counters                */
    register int j,k;
    register unsigned short *from,*to;
    register int chars_per_line = get_offset_per_line()>>1;
    int lines_per_screen;
    int offset,len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;

    byte *pInt10Flag;
    static NtInt10FlagUse = FALSE;
    IMPORT sys_addr DosvVramPtr;
    register sys_addr ptr = DosvVramPtr;
    register int skip;


    if (getVideodirty_total() == 0 || get_display_disabled() )
        return;

    if ( get_offset_per_line() == 0 ){
        lines_per_screen = 25;
    }
    else {
        lines_per_screen = get_screen_length()/get_offset_per_line();
    }

    host_start_update();

    screen_start=get_screen_start()<<2;
    ALIGN_SCREEN_START(screen_start);

    // mode 03h and 73h use same plane  Aug. 6 TakeS
    to = (unsigned short *)&video_copy[get_screen_start()<<1];
    from = (unsigned short *) get_screen_ptr(screen_start);

    skip = 2;

    if(getVideodirty_total() >1500)     /* paint the whole lot */
    {
        for(i=get_screen_length()>>1;i>0;i--)
        {
            *to++ = *from;      /* char and attribute bytes */
            from++;
            sas_loadw(ptr, from);
            from++;
            ptr += skip;
            // from += 2;               /* planes 2,3 interleaved */
        }

        while ( NtInt10FlagUse ) {
#ifdef JAPAN_DBG
            DbgPrint( "NtInt10Flag busy\n" );
#endif
            Sleep( 100L );
        }
        NtInt10FlagUse = TRUE;
        memcpy( NtInt10Flag, Int10Flag, 80*50 );
        {
        register int i = 80*50;
        register byte *p = Int10Flag;

        while(i--){
          *p++ &= (~INT10_CHANGED); // reset
          }
        }

        (*paint_screen)(screen_start, 0, 0, get_bytes_per_line(),
                        lines_per_screen);

        NtInt10FlagUse = FALSE;
    }
    else
    {
      if( Int10FlagCnt )
        {
          Int10FlagCnt = 0;

          /* Screen changed, calculate position of first variation */

          init_text_rect();

          while ( NtInt10FlagUse ) {
#ifdef JAPAN_DBG
            DbgPrint( "NtInt10Flag busy\n" );
#endif
            Sleep( 100L );
          }
          NtInt10FlagUse = TRUE;
            memcpy( NtInt10Flag, Int10Flag, 80*50 );
          {
            register int i = 80*50;
            register byte *p = Int10Flag;

            while(i--){
              *p++ &= (~INT10_CHANGED); // reset
              }
          }

          pInt10Flag = NtInt10Flag;

          for(i=0;i<lines_per_screen;i++, pInt10Flag += chars_per_line )
            {
              for(j=0;j<chars_per_line;j++, to++, from +=2, ptr += skip )
                {
                  if ( pInt10Flag[j] & INT10_CHANGED )
                    break;
                }
              if ( j == chars_per_line )
                continue;             // not change goto next line

                  for ( k = chars_per_line - 1; k >= j; k-- ) {
                    if ( pInt10Flag[k] & INT10_CHANGED )
                      break;
                  }

                // ntraid:mskkbug#3297,3515: some character does not display
                // 11/6/93 yasuho
                // Repaint the incomplete DBCS character
                if (j && (pInt10Flag[j] & INT10_DBCS_TRAILING) &&
                    (pInt10Flag[j-1] == INT10_DBCS_LEADING)) {
                        j--;
                        pInt10Flag[j] |= INT10_CHANGED;
                }

              len = k - j + 1;
              x = j;

                add_to_rect(screen_start, x, i, len);

              /*.................. transfer data painted to video copy */

              for( k = j; k < chars_per_line; k++ ){
                *to++ = *from;
                from++;
                sas_loadw(ptr, from);
                from++;
                ptr += skip;
                // from += 2;
              }
            }
        }
      /* End of screen, flush any outstanding text update rectangles */
        paint_text_rect(screen_start);

      NtInt10FlagUse = FALSE;
  }

  setVideodirty_total(0);

  /*:::::::::::::::::::::::::::::::::::::::::::::::::: Repaint cursor */

  if (is_cursor_visible())
    {
      half_word attr;

      dirty_curs_x = get_cur_x();
      dirty_curs_y = get_cur_y();

      dirty_curs_offs = screen_start+dirty_curs_y * (get_offset_per_line()<<1) + (dirty_curs_x<<2);
      attr = *(get_screen_ptr(dirty_curs_offs + 1));

      host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
    }

  host_end_update();
}
#endif // JAPAN
#if defined(KOREA)
void jazz_text_update_ko()
{

    register int i;     /* Loop counters                */
    register int j,k;
    register unsigned short *from,*to;
    register int chars_per_line = get_offset_per_line()>>1;
    int lines_per_screen;
    int offset,len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;

    unsigned char *flag_from, *flag_to;
    boolean  DBCSState1 = FALSE;
    boolean  DBCSState2 = FALSE;

    if (getVideodirty_total() == 0 || get_display_disabled() )
        return;

    lines_per_screen = get_screen_length()/get_offset_per_line();

    host_start_update();

    screen_start=get_screen_start()<<2;
    ALIGN_SCREEN_START(screen_start);

    to = (unsigned short *)&video_copy[get_screen_start()<<1];
    from = (unsigned short *) get_screen_ptr(screen_start);

    if(getVideodirty_total() >1500)     /* paint the whole lot */
    {
        for(i=get_screen_length()>>1;i>0;i--)
        {
            *to++ = *from;      /* char and attribute bytes */
            from += 2;          /* planes 2,3 interleaved */
        }

        (*paint_screen)(screen_start, 0, 0, get_bytes_per_line(),
                        lines_per_screen);
    }
    else
    {
        init_text_rect();

        flag_from = (unsigned char*)Int10Flag;
        flag_to   = (unsigned char*)NtInt10Flag;
        wfrom = (unsigned short *)from;
        wto   = (unsigned short *)to;
        for(i=0;i<lines_per_screen;i++)
        {
         for(j=0;j<chars_per_line;j++)
         {
             if (DBCSState1)
             {
                 *flag_from++ = INT10_DBCS_TRAILING;
                 DBCSState1 = FALSE;
             }
             else if (DBCSState1 = is_dbcs_first(LOBYTE(*wfrom)))
                 *flag_from++ = INT10_DBCS_LEADING;
             else
                 *flag_from++ = INT10_SBCS;
             wfrom+=2;

             if (DBCSState2)
             {
                 *flag_to++ = INT10_DBCS_TRAILING;
                 DBCSState2 = FALSE;
             }
             else if (DBCSState2 = is_dbcs_first(LOBYTE(*wto)))
                 *flag_to++ = INT10_DBCS_LEADING;
             else
                 *flag_to++ = INT10_SBCS;
             wto++;
         }
        }

        flag_from = (unsigned char*)Int10Flag;
        flag_to   = (unsigned char*)NtInt10Flag;

        for(i=0;i<lines_per_screen;i++)
        {
            for(j=0;j<chars_per_line;j++)
            {
                flag_from++;
                flag_to++;
                if(*to != *from)
                {
                    k=chars_per_line-1-j;
                    wfrom = from + k*2;
                    wto   = to + k;

                    for(;*wto== *wfrom;k--,wto--,wfrom-=2){};
                    /*
                     * Note: For text mode there is one char for every word.
                     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
                     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
                     * y_coord=height_of_one_char*2*line
                     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
                     * The host y co-ords are doubled
                     */

                    /* one or more ints of data are now selected
                       but refine difference to words (i.e. characters),
                       to avoid a glitch on the screen when typing in to
                       a dumb terminal  */

                    offset = (i * (get_offset_per_line()<<1)) + (j<<2);
                    len    = (k<<2) + 4;
                    x      = j;

                    if ( (*flag_from & INT10_DBCS_TRAILING) ||
                         (*flag_to   & INT10_DBCS_TRAILING)   )
                    {
                        x--;
                        len += 4;
                    }

                    wfrom = from + (k<<1);
                    wto   = to + k;
                    if (*wfrom == *wto)
                    {
                        if (*(flag_from+k) & INT10_DBCS_LEADING)
                        {
                            len += 4;
                        }
                        else if ( !(*(flag_from+k) & INT10_DBCS_TRAILING) &&
                                  !(*(flag_to+k)   & INT10_DBCS_TRAILING)   )
                        {
                            len -= 4;
                        }
                    }
                    else if ( (*(flag_from+k) & INT10_DBCS_LEADING) ||
                              (*(flag_to+k)   & INT10_DBCS_LEADING)   )
                    {
                        len += 4;
                    }

                    add_to_rect(screen_start, x, i, len/4);

                    for(k=j;k<chars_per_line;k++)
                    {
                        *to++ = *from;
                        from+=2;
                    }

                    flag_from += (chars_per_line-j);
                    flag_to   += (chars_per_line-j);

                    break;      /* onto next line */
                }
                else
                {
                    to++; from +=2;
                }
            }
        }
          /* End of screen, flush any outstanding text update rectangles */
          paint_text_rect(screen_start);
    }

        setVideodirty_total(0);

        /*:::::::::::::::::::::::::::::::::::::::::::::::::: Repaint cursor */

        if (is_cursor_visible())
        {
                half_word attr;

                dirty_curs_x = get_cur_x();
                dirty_curs_y = get_cur_y();

                dirty_curs_offs = screen_start+dirty_curs_y * (get_offset_per_line()<<1) + (dirty_curs_x<<2);
                attr = *(get_screen_ptr(dirty_curs_offs + 1));

                host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
        }

        host_end_update();
}
#endif // KOREA

void jazz_text_update()
{

    register int i;     /* Loop counters                */
    register int j,k;
    register unsigned short *from,*to;
    register int chars_per_line = get_offset_per_line()>>1;
    int lines_per_screen;
    int offset,len,x,screen_start;
    unsigned short *wfrom;
    unsigned short *wto;

#ifdef JAPAN
    byte vmode = sas_hw_at_no_check(DosvModePtr);
    if (BOPFromDispFlag &&
        (sas_w_at_no_check(DBCSVectorAddr) != 0) &&
        (vmode == 0x03 || vmode == 0x73)) {
        jazz_text_update_jp();
        return;
    }
#elif defined(KOREA) // JAPAN
    byte vmode = sas_hw_at_no_check(DosvModePtr);
    if (BOPFromDispFlag &&
        (sas_w_at_no_check(DBCSVectorAddr) != 0) &&
        (vmode == 0x03)) {
        jazz_text_update_ko();
        return;
    }
#endif // KOREA
    if (getVideodirty_total() == 0 || get_display_disabled() )
        return;

    lines_per_screen = get_screen_length()/get_offset_per_line();

    host_start_update();

    screen_start=get_screen_start()<<2;
    ALIGN_SCREEN_START(screen_start);

    to = (unsigned short *)&video_copy[get_screen_start()<<1];
    from = (unsigned short *) get_screen_ptr(screen_start);

    if(getVideodirty_total() >1500)     /* paint the whole lot */
    {
        for(i=get_screen_length()>>1;i>0;i--)
        {
            *to++ = *from;      /* char and attribute bytes */
            from += 2;          /* planes 2,3 interleaved */
        }

        (*paint_screen)(screen_start, 0, 0, get_bytes_per_line(),
                        lines_per_screen);
    }
    else
    {
        init_text_rect();

        for(i=0;i<lines_per_screen;i++)
        {
            for(j=0;j<chars_per_line;j++)
            {
                if(*to != *from)
                {
                    k=chars_per_line-1-j;
                    wfrom = from + k*2;
                    wto   = to + k;

                    for(;*wto== *wfrom;k--,wto--,wfrom-=2){};
                    /*
                     * Note: For text mode there is one char for every word.
                     * no of bytes into screen=line*bytes_per_line + ints_into_line*4
                     * x_coord=width_of_one_char*(no_of_ints_into_line*2)
                     * y_coord=height_of_one_char*2*line
                     * length=no_of_ints*4+4     the plus 4 is to counteract the k--
                     * The host y co-ords are doubled
                     */

                    /* one or more ints of data are now selected
                       but refine difference to words (i.e. characters),
                       to avoid a glitch on the screen when typing in to
                       a dumb terminal  */

                    offset = (i * (get_offset_per_line()<<1)) + (j<<2);
                    len    = (k<<2) + 4;
                    add_to_rect(screen_start, j, i, len/4);

                    for(k=j;k<chars_per_line;k++)
                    {
                        *to++ = *from;
                        from+=2;
                    }
                    break;      /* onto next line */
                }
                else
                {
                    to++; from +=2;
                }
            }
        }
          /* End of screen, flush any outstanding text update rectangles */
          paint_text_rect(screen_start);
    }

        setVideodirty_total(0);

        /*:::::::::::::::::::::::::::::::::::::::::::::::::: Repaint cursor */

        if (is_cursor_visible())
        {
                half_word attr;

                dirty_curs_x = get_cur_x();
                dirty_curs_y = get_cur_y();

                dirty_curs_offs = screen_start+dirty_curs_y * (get_offset_per_line()<<1) + (dirty_curs_x<<2);
                attr = *(get_screen_ptr(dirty_curs_offs + 1));

                host_paint_cursor( dirty_curs_x, dirty_curs_y, attr );
        }

        host_end_update();
}
#endif /* MONITOR */
#endif /* NTVDM */
#endif /* REAL_VGA */

extern void host_stream_io_update(half_word *, word);

#ifdef NTVDM
void stream_io_update(void)
{

#ifdef MONITOR
    if (sas_w_at_no_check(stream_io_bios_busy_sysaddr)) {
        return;

    }
#endif

    if (*stream_io_dirty_count_ptr) {
        host_start_update();
        host_stream_io_update(stream_io_buffer, *stream_io_dirty_count_ptr);
        host_end_update();
        *stream_io_dirty_count_ptr = 0;

    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\tgdc.c ===
/*      TGDC Emulation File                                                        */
/*                                                                       NEC_98    */

#if defined(NEC_98)
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ios.h"
#include "tgdc.h"
#include "ica.h"
#include "gvi.h"
#include "gmi.h"
#include "debug.h"
#include "gfx_upd.h"
#include "egacpu.h"
#include "cg.h"

void set_cursorpos();
void tgdc_reset_func IPT0();
void tgdc_sync_func IPT1(half_word,value);
void tgdc_start_func IPT0();
void tgdc_stop_func IPT0();
void tgdc_scroll_func IPT1(half_word,value);
void tgdc_csrform_func IPT1(half_word,value);
void tgdc_pitch_func IPT1(half_word, value);
void tgdc_csrw_func IPT1(half_word, value);
void tgdc_csrr_func IPT1(half_word *,value);
void tgdc_write_command IPT1(half_word, value);
void tgdc_write_param IPT1(half_word, value);
void tgdc_write_mode1 IPT1(half_word, value);
void tgdc_write_border IPT1(half_word,value);
void tgdc_read_status IPT1(half_word *,value);
void tgdc_read_data IPT1(half_word *,value);

int FIFOCount;
unsigned char   status_flag;
unsigned short  cur_offset_low  = 0;
unsigned short  cur_offs,old_cur_offs=0;
unsigned char   tmpcommand;
BOOL crtv_int_request;
BOOL cursor_move_required = TRUE;
BOOL scroll_move_required = TRUE;
short read_stat_count;
BOOL fontselchanged = FALSE;

extern modeff_palette_change();
extern void host_set_mode_ff();
extern VOID RequestVsync();
extern  DISPLAY_GLOBS   NEC98Display;
extern  BOOL    video_emu_mode;        /* ADD 930720 */

TGDC_GLOBS tgdcglobs;
MODEFF_GLOBS modeffglobs;

void set_cursorpos()
{
    unsigned char *vram_NEC98,*attr_NEC98;
//      unsigned        linepos,colmnpos;
    unsigned linecount;
    int i,num;
    BOOL curs_set;

    vram_NEC98=( unsigned char *)cur_offs+NEC98_TEXT_P0_OFF;
    attr_NEC98=( unsigned char *)cur_offs+NEC98_ATTR_P0_OFF;
    curs_set=FALSE;
//      if (get_doubleword_mode())
//              num=4;
//      else
            num=2;
    if (vram_NEC98 < NEC98_ATTR_P0_OFF) {
        for (i=0,linecount=0;i<text_splits.nRegions;
            linecount+=text_splits.split[i].lines,i++) {
            if (linecount > LINES_PER_SCREEN)
                break;
            else {
                if (( vram_NEC98<((text_splits.split[i].lines*get_bytes_per_line())
                    +text_splits.split[i].addr )) && ( vram_NEC98>=text_splits.split[i].addr) ){
                    set_cur_y((vram_NEC98-text_splits.split[i].addr)/(get_bytes_per_line())+linecount);
                    set_cur_x((vram_NEC98-text_splits.split[i].addr)%(get_bytes_per_line())/num);
                    if (get_cur_y() < LINES_PER_SCREEN) {
                        if (curs_set == FALSE) {
                            curs_set=TRUE;
//                                                      set_cur_x(colmnpos);
//                                                      set_cur_y(linepos);
                            host_paint_cursor(get_cur_x(),get_cur_y(),*attr_NEC98);
                        }
                    }
                }
            }
        }
    }
}


/*             TEXT GDC Command Emulator                                            */

void tgdc_reset_func IFN0()
{
    set_crt_on(FALSE);
    set_mode_change_required(TRUE);
    if ((tmpcommand == GDC_RESET0) || (tmpcommand == GDC_RESET1)) {
            tgdc_write_command(GDC_SYNC0);
    } else {
            tgdc_write_command(GDC_SYNC1);
    }
}

void tgdc_sync_func IFN1(half_word,value) 
{
int src,dst,cnt;

    cnt =tgdcglobs.now.count;
    if (cnt > 7) {
            assert1(FALSE,"NEC98:Illegal Parameter on SYNC %#x",value);
    } else {
            switch(cnt) {
                case 0:
                    if (tmpcommand == GDC_SYNC1)
                        tgdcglobs.startstop = TRUE;
                    else
                        tgdcglobs.startstop = FALSE;
                    break;
                case 1:
                    set_chars_per_line(value+2);
                    set_bytes_per_line(get_chars_per_line()*2);
                    set_offset_per_line(get_chars_per_line()*2);
                    break;
                case 4:
                    src = (int)((value >>6)<<7);
//                              dst = get_pitch_width();
//                              set_pitch_width((src <<1) | (dst & 0x0ff));
                    set_pitch_width(src <<1);
                    break;
                case 6:
                    src = (int)(value);
//                              dst = get_screen_height();
//                              set_screen_height(src | (dst & 0xff00));
                    set_screen_height(src-1);
                    break;
                case 7:
                    src = (int)((value & 0x03)<<6);
                    dst = get_screen_height();
                    set_screen_height((src<<2) | (dst & 0x00ff)-1);
                    set_mode_change_required(TRUE);
                    if (tgdcglobs.now.command & GDC_SYNC1)
                        set_crt_on(TRUE);
                    else
                        set_crt_on(FALSE);
                    break;
            }
            tgdcglobs.sync[tgdcglobs.now.count] = (unsigned char)value;
    }
}

void tgdc_start_func IFN0() {
        set_crt_on(TRUE);
        tgdcglobs.startstop = TRUE;
        set_mode_change_required(TRUE);
}

void tgdc_stop_func IFN0() {
        set_crt_on(FALSE);
        tgdcglobs.startstop = FALSE;
        set_mode_change_required(TRUE);
}

void tgdc_scroll_func IFN1(half_word,value) {
        int count,qcount;
        int src,dst;
        count = tgdcglobs.now.count;
        if (count > 15) {
                assert1(FALSE,"NEC98:Illegal Parameter on SCROLL %#x",value);
         } else {
                qcount = count>>2;
                switch(count & 0x03) {
                    case 0:
                        src = (int)(value);
//                              dst = text_splits.split[qcount].addr;
//                              text_splits.split[qcount].addr = src | (dst & 0xFF00);
                        text_splits.split[qcount].addr = src;
                        break;
                    case 1:
                        src = (int)(value);
                        dst = text_splits.split[qcount].addr;
                        text_splits.split[qcount].addr = (((src << 8) | (dst & 0x00FF)) << 1)
                            + NEC98_TEXT_P0_OFF;
                        break;
                    case 2:
                        src = (int)(value);
//                              dst = text_splits.split[qcount].lines;
//                              text_splits.split[qcount].lines = (src >> 4) | (dst & 0xFFF0);
                        text_splits.split[qcount].lines = src >> 4;
                        break;
                    case 3:
                        src = (int)(value);
                        dst = text_splits.split[qcount].lines;
                        text_splits.split[qcount].lines = (src << 4) | (dst & 0x000F);
                        text_splits.split[qcount].lines /= get_char_height();
                        assert2(FALSE,"NEC98:SCROLL %#x Lines  %#x Height",
                            text_splits.split[qcount].lines,get_char_height());
                        break;
                }
                text_splits.nRegions = qcount + 1;
                tgdcglobs.scroll[count] = (unsigned char) value;
                scroll_move_required = TRUE;
        }
}

void tgdc_csrform_func IFN1(half_word,value)
{
    int src,dst,cnt;

    cnt = tgdcglobs.now.count;
    if (cnt > 2) {
        assert1(FALSE,"NEC98:Illegal Parameter on CSRFORM %#x",value);
    } else {
        switch(cnt) {
            case 0:
                if (value>>7)
                    set_cursor_visible(TRUE);
                else
                    set_cursor_visible(FALSE);
//                              set_char_height(((value) & 0x1f)+1);
                cursor_move_required = TRUE; // 950414 bugfix
                                             // WX2 cursor illegal blink
                break;
            case 1:
                src = value >> 6;
                dst = get_blink_rate();
//                              set_blink_rate(src | (dst & 0xfc));
                set_blink_rate(src);
                if (value & 0x20)
                    set_blink_disable(TRUE);
                else
                    set_blink_disable(FALSE);
                set_cursor_start(value & 0x1f);
                break;
            case 2:
                src = value << 5;
                dst = get_blink_rate();
                set_blink_rate(((src>>3) | (dst & 0x03))*4);
                set_cursor_height((value >> 3) - get_cursor_start()+1);
                host_cursor_size_changed(get_cursor_start(),(int)(value));
                break;
        }
        tgdcglobs.csrform[tgdcglobs.now.count] = (unsigned char) value;
    }
}

void tgdc_pitch_func IFN1(half_word, value)
{
    int src,dst;

    if (tgdcglobs.now.count > 0) {
        assert1(FALSE,"NEC98:Illegal Parameter on PITCH %#x",value);
    } else {
        src = (int) value;
        dst = get_pitch_width();
        set_pitch_width(src | (dst & 0x100));
        tgdcglobs.pitch = (unsigned char)value;
    }
}

void tgdc_csrw_func IFN1(half_word, value)
{
    unsigned short src,dst,cnt;

    cnt = tgdcglobs.now.count;
    switch(cnt) {
        case 0:
            cur_offset_low = (unsigned short) value;
            break;
        case 1:
            cur_offs = (((value & 0x1f)<<8)+(cur_offset_low & 0xff))*2;
            if (cur_offs != old_cur_offs){
                cursor_move_required = TRUE;
                old_cur_offs = cur_offs;
//                              set_cursorpos();
            }
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Parameter on CSRW%#x",value);
    }
}

void tgdc_csrr_func IFN1(half_word *,value)
{
    unsigned short  tmp;
 
    switch(FIFOCount) {
        case 0:
            tmp = (old_cur_offs >> 1) & 0x00ff;
            *value = (half_word) tmp;
            break;
        case 1:
            tmp = (old_cur_offs >> 1) & 0x1f00;
            *value = (half_word)(tmp >> 8);
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Parameter on CSRR %#x",*value);
            FIFOCount--;
    }
    FIFOCount++;
}

/*              TEXT GDC Port                                                      */

void tgdc_write_command IFN1(half_word, value)
{
    tmpcommand = value;
    if ((tmpcommand <= 0x70) && (tmpcommand >= 0x7f))
            tmpcommand = 0x70;
    FIFOCount = 0;
    status_flag &= 0xFE;
    tgdcglobs.now.count = 0;
    switch(tmpcommand) {
        case GDC_RESET0:
        case GDC_RESET1:
        case GDC_RESET2:
            tgdc_reset_func();
            break;
        case GDC_START0:
        case GDC_START1:
            tgdc_start_func();
            break;
        case GDC_STOP0:
        case GDC_STOP1:
            tgdc_stop_func();
            break;
        case GDC_CSRR:
            status_flag |= 0x01;
            break;
        case GDC_SCROLL:
            tgdcglobs.now.count = (int) (value & 0x0f);
        case GDC_SYNC0:
        case GDC_SYNC1:
        case GDC_CSRFORM:
        case GDC_PITCH:
        case GDC_CSRW:
            tgdcglobs.now.command = tmpcommand;
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Command %#x",value);
    }
}

void tgdc_write_param IFN1(half_word, value)
{
    tgdcglobs.now.param[tgdcglobs.now.count]=(unsigned char)value;
    switch(tmpcommand) {
        case GDC_SYNC0:
        case GDC_SYNC1:
            tgdc_sync_func(value);
            break;
        case GDC_SCROLL:
            tgdc_scroll_func(value);
            break;
        case GDC_CSRFORM:
            tgdc_csrform_func(value);
            break;
        case GDC_PITCH:
            tgdc_pitch_func(value);
            break;
        case GDC_CSRW:
            tgdc_csrw_func(value);
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Command or Parameter %#x",value);
            tgdcglobs.now.param[tgdcglobs.now.count]=(unsigned char)0xff;
            return;
    }
    tgdcglobs.now.count++;
}

void tgdc_write_mode1 IFN1(half_word, value)
{
    half_word       ffvalue = (value & 0x0F);
    BOOL    *pff = &NEC98Display.modeff.atrsel;

    switch(ffvalue >> 1) {
        case 0:
            modeffglobs.modeff_data[0] = ffvalue;
            if (ffvalue & 0x01)
                NEC98Display.modeff.atrsel = TRUE;
            else
                NEC98Display.modeff.atrsel = FALSE;
            break;
        case 1:
            modeffglobs.modeff_data[1] = ffvalue;
            modeff_palette_change();
            if (ffvalue & 0x01)
                NEC98Display.modeff.graphmode = TRUE;
            else
                NEC98Display.modeff.graphmode = FALSE;
            break;
        case 2:
            modeffglobs.modeff_data[2] = ffvalue;
            if (ffvalue & 0x01)
                NEC98Display.modeff.width = TRUE;
            else
                NEC98Display.modeff.width = FALSE;
            break;
        case 3:
            modeffglobs.modeff_data[3] = ffvalue;
            fontselchanged = TRUE;
            outb(CG_WRITE_SECOND,(unsigned char)(cgglobs.code & 0x00FF));
            fontselchanged = FALSE;
           if (ffvalue & 0x01)
               NEC98Display.modeff.fontsel = TRUE;
           else
               NEC98Display.modeff.fontsel = FALSE;
           break;
       case 4:
           modeffglobs.modeff_data[4] = ffvalue;
           if (ffvalue & 0x01){
               NEC98Display.modeff.graph88 = TRUE;
           }else{
               NEC98Display.modeff.graph88 = FALSE;
           }
           set_mode_change_required(TRUE);
           break;
       case 5:
           modeffglobs.modeff_data[5] = ffvalue;
           if (ffvalue & 0x01)
               NEC98Display.modeff.kacmode = TRUE;
           else
               NEC98Display.modeff.kacmode = FALSE;
           break;
       case 6:
           modeffglobs.modeff_data[6] = ffvalue;
           if (ffvalue & 0x01)
               NEC98Display.modeff.nvmwpermit = TRUE;
           else
               NEC98Display.modeff.nvmwpermit = FALSE;
           break;
       case 7:
           modeffglobs.modeff_data[7] = ffvalue;
           if (ffvalue & 0x01){
               NEC98Display.modeff.dispenable = TRUE;
           }else{
               NEC98Display.modeff.dispenable = FALSE;
           }
           set_mode_change_required(TRUE);
           break;
    }
#ifdef VSYNC                                                //      VSYNC
    if ((ffvalue >>1) != 5)
        host_set_mode_ff(ffvalue);
#endif                                                      //      VSYNC
}

void tgdc_write_border IFN1(half_word,value)
{
        tgdcglobs.border = (unsigned char)value;
}

void tgdc_read_status IFN1(half_word *,value)
{
//      status_flag ^= 0x20;
        if (status_flag & 0x20) {
                if (read_stat_count > 2) {
                        status_flag ^= 0x20;
                        read_stat_count = 0;
                } else
                        read_stat_count++;
        }
        status_flag ^= 0x40;
        *value = status_flag;
}

void tgdc_read_data IFN1(half_word *,value)
{
    if (status_flag & 0x01) {
        switch (tmpcommand) {
            case GDC_CSRR:
                if (FIFOCount >4 )
                    ;
                else {
                    tgdc_csrr_func(value);
                }
                break;
            default:
                assert1(FALSE,"NEC98:Illegal Command %#x",tmpcommand);
        }
    }
}



GLOBAL void text_gdc_inb IFN2(io_addr, port, half_word *, value)
{
    switch(port) {
        case TGDC_READ_STATUS:
            tgdc_read_status(value);
            break;
        case TGDC_READ_DATA:
            tgdc_read_data(value);
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Port %#x",port);
    }
}

GLOBAL void text_gdc_outb IFN2(io_addr, port, half_word, value)
{
    switch(port) {
        case TGDC_WRITE_PARAMETER:
            tgdc_write_param(value);
            break;
        case TGDC_WRITE_COMMAND:
            tgdc_write_command(value);
            break;
        case TGDC_CRT_INTERRUPT:
//                  DbgPrint("NTVDM: Vsync Request!!\n");
//                  ica_hw_interrupt(ICA_MASTER, CPU_CRTV_INT, 1);
//                      crtv_int_request = TRUE;
            RequestVsync();
            break;
        case TGDC_WRITE_MODE1:
            tgdc_write_mode1(value);
            break;
        case TGDC_WRITE_BORDER:
            tgdc_write_border(value);
            break;
        default:
            assert1(FALSE,"NEC98:Illegal Port %#x",port);
    }
}

GLOBAL void text_gdc_init IFN0()
{
    io_define_inb(TEXT_GDC_ADAPTOR,text_gdc_inb);
    io_define_outb(TEXT_GDC_ADAPTOR,text_gdc_outb);
        io_connect_port(TGDC_WRITE_PARAMETER,TEXT_GDC_ADAPTOR,IO_READ_WRITE);
        io_connect_port(TGDC_WRITE_COMMAND,TEXT_GDC_ADAPTOR,IO_READ_WRITE);
    io_connect_port(TGDC_CRT_INTERRUPT, TEXT_GDC_ADAPTOR, IO_WRITE);
        io_connect_port(TGDC_WRITE_MODE1,TEXT_GDC_ADAPTOR,IO_WRITE);
        io_connect_port(TGDC_WRITE_BORDER,TEXT_GDC_ADAPTOR,IO_WRITE);
}

GLOBAL void text_gdc_post IFN0()
{
        int i;
        unsigned short  ffpost[] = { 0, 2, 4, 7, 8, 0x0a, 0x0c, 0x0f};

        FIFOCount = 0;
        status_flag = 0x04;
//      cur_offs = (get_cur_y()*get_bytes_per_line()+(get_cur_x()<<1));
        cur_offs = 0;
        tmpcommand = 0xff;
        crtv_int_request=FALSE;
        read_stat_count = 0;
        set_doubleword_mode(FALSE);
        NEC98GLOBS->screen_ptr = 0xA0000;

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_SYNC0);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x10);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x4e);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x07);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x25);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x07);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x07);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x90);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x65);

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_PITCH);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x50);

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_CSRFORM);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x0f);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x7b);

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_SCROLL);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0xf0);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x1f);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x10);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x10);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x10);
        text_gdc_outb(TGDC_WRITE_PARAMETER,0x00);

        text_gdc_outb(TGDC_WRITE_COMMAND,GDC_START1);

        for ( i=0 ; i<8 ; i++)
                text_gdc_outb(TGDC_WRITE_MODE1,ffpost[i]);
}

GLOBAL void VSYNC_beats IFN0()
{
        status_flag ^= 0x20;
}

GLOBAL void TgdcStatusChange IFN0()
{
        status_flag != 0x20;
        read_stat_count = 0;
}
#endif //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\v7_ports.c ===
#include "insignia.h"
#include "host_def.h"
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		v7_ports.c

 Description:
		Code for the extended registers of the Video 7 VGA.
		Based on the V7 VGA Technical Reference Manual.

 Author:
		Phil Taylor

 Date:
		26 September 1990

 SccsID	"@(#)v7_ports.c	1.19 01/13/95 Copyright Insignia Solutions Ltd."

======================================================================
]*/


#ifdef V7VGA

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "ios.h"
#include "gfx_upd.h"
#include "debug.h"
#include "egacpu.h"
#include "egaports.h"
#include "egagraph.h"
#include "egaread.h"
#include "vgaports.h"


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_VGA.seg"
#endif


IMPORT	byte	crtc_0_7_protect;
IMPORT	byte	crtc_0_8_protect;
IMPORT	byte	crtc_9_b_protect;
IMPORT	byte	crtc_c_protect;

FORWARD void    draw_v7ptr();

GLOBAL ULONG fg_latches;
GLOBAL UTINY fg_bg_control;

GLOBAL	void	remove_v7ptr IPT0();

SAVED	word	curr_v7ptr_x;
SAVED	word	curr_v7ptr_y;

/*(
----------------------------------------------------------------------

Function:	
		vga_seq_extn_control( io_addr port, half_word value )

Purpose:
		To emulate writing to the Extensions Control Register.

Input:
		port	- the V7VGA I/O port (should always be 0x3c5)
		value	- the value to be written to the register

Output:
		The Extensions Control Register is set to the correct value.

----------------------------------------------------------------------
)*/

GLOBAL VOID
vga_seq_extn_control(port, value)
io_addr         port;
half_word       value;

{
#ifndef NEC_98
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(6,%#x)\n",value);)
	note_entrance2("vga_seq_extn_control(%x,%x)", port, value);

	if (value == 0xea)
		sequencer.extensions_control.as_bfld.extension_enable = 1;
	else if (value == 0xae)
		sequencer.extensions_control.as_bfld.extension_enable = 0;
#endif  //NEC_98
}

GLOBAL VOID
v7_get_banks( rd_bank, wrt_bank )

UTINY *rd_bank;
UTINY *wrt_bank;

{
#ifndef NEC_98
	if( get_seq_chain4_mode() && get_chain4_mode() ) {
		set_v7_bank_for_seq_chain4( rd_bank, wrt_bank );
	}
	else {

	/*
	   1.4.92 MG
	   Note that we and off the top bit of the bank selects. This means
	   that accesses to the top 512k (which we don't have) get mapped into
	   the bottom 512k, rather than being thrown away. This prevents SEGVs
	   and saves complications in the write routines, but causes other
	   problems.

	   Further explanation is in draw_v7ptr() at the end of this file.
	*/

		*rd_bank=(extensions_controller.ram_bank_select.as_bfld.cpu_read_bank_select&1);
		*wrt_bank=(extensions_controller.ram_bank_select.as_bfld.cpu_write_bank_select&1);
	}
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		vga_extn_outb( io_addr port, half_word value )

Purpose:
		To emulate writing to the V7VGA Extension Registers

Input:
		port	- the V7VGA I/O port (should always be 0x3c5)
		value	- the value to be written to the register

Output:
		The Extension Registers are set to the correct value, and
		any other required actions are emulated.

----------------------------------------------------------------------
)*/

GLOBAL VOID
vga_extn_outb(port, value)
io_addr         port;
half_word       value;

{
#ifndef NEC_98
	half_word	old_value;

	note_entrance2("vga_extn_outb(%x,%x)", port, value);
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq ext (%#x,%#x)\n",
		sequencer.address.as.abyte,value);)

	switch (sequencer.address.as.abyte) {

		case 0x83:
			note_entrance0("attribute controller index");
			attribute_controller.address.as.abyte = value;
			break;
		case 0x94:
			note_entrance0("pointer pattern");
			extensions_controller.pointer_pattern = value;
			host_start_update ();
			(*clear_v7ptr)(curr_v7ptr_x, curr_v7ptr_y);
			draw_v7ptr();
			host_end_update ();
			break;
		case 0x9c:
			note_entrance0("pointer horiz position hi");
			extensions_controller.ptr_horiz_posn_hi.as.abyte = value;
			break;
		case 0x9d:
			note_entrance0("pointer horiz position lo");
			extensions_controller.ptr_horiz_posn_lo = value;
			break;
		case 0x9e:
			note_entrance0("pointer vert position hi");
			extensions_controller.ptr_vert_posn_hi.as.abyte = value;
			break;
		case 0x9f:
			note_entrance0("pointer vert position lo");
			extensions_controller.ptr_vert_posn_lo = value;
			host_start_update ();
			(*clear_v7ptr)(curr_v7ptr_x, curr_v7ptr_y);
			draw_v7ptr();
			host_end_update ();
			break;
		case 0xa0:
			note_entrance0("graphics controller mem latch 0");
			/* Direct access to memory data latch 0 */
			put_latch0(value);
			break;
		case 0xa1:
			note_entrance0("graphics controller mem latch 1");
			/* Direct access to memory data latch 1 */
			put_latch1(value);
			break;
		case 0xa2:
			note_entrance0("graphics controller mem latch 2");
			/* Direct access to memory data latch 2 */
			put_latch2(value);
			break;
		case 0xa3:
			note_entrance0("graphics controller mem latch 3");
			/* Direct access to memory data latch 3 */
			put_latch3(value);
			break;
		case 0xa4:
			note_entrance0("clock select");
			extensions_controller.clock_select.as.abyte = value;
			/* Typically set to 0x10 for extended hi-res modes */
			break;
		case 0xa5:
			note_entrance0("cursor attributes");
			old_value=(half_word)extensions_controller.cursor_attrs.as.abyte;
			extensions_controller.cursor_attrs.as.abyte = value;

			/*
			   8.6.92 MG
			   We need to check that the pointer was disabled
			   before we redraw it when it is enabled. Otherwise
			   we can get old pointers left on the screen in
			   Windows.
			*/

			/* Not doing cursor mode stuff (whatever that means) */

                        if ((value&0x80) != (old_value&0x80)) {
				host_start_update ();
				if (value & 0x80) {
					/* Enable hardware graphics pointer */
					draw_v7ptr();
				}
				else {
					/* Disable hardware graphics pointer */
					(*clear_v7ptr)(curr_v7ptr_x, curr_v7ptr_y);
				}
				host_end_update ();
			}
			break;

		/*
		   31.3.92 MG Register c1 is an undocumented DAC control
		   register, bit 0 switches between 6 and 8 bit data in
		   the DAC.
		*/

		case 0xc1:
			extensions_controller.dac_control.as.abyte=value;
			if (extensions_controller.dac_control.as_bfld.dac_8_bits) {
				DAC_data_bits=8;
				DAC_data_mask=0xff;
			}
			else {
				DAC_data_bits=6;
				DAC_data_mask=0x3f;
			}
			break;
		case 0xea:
			note_entrance0("switch strobe");
			/* loads up switch readback with some CPU data lines */
			extensions_controller.switch_readback = 0xff;
			/* This is hard coded for the jumper/switch settings, and might not be right */
			break;
		case 0xeb:
			note_entrance0("emulation_control");
			extensions_controller.emulation_control.as.abyte = value;
			if (extensions_controller.emulation_control.as_bfld.write_prot_2)
				crtc_0_8_protect = TRUE;
			else
				crtc_0_8_protect = FALSE;
			if (extensions_controller.emulation_control.as_bfld.write_prot_1)
				crtc_9_b_protect = TRUE;
			else
				crtc_9_b_protect = FALSE;
			if (extensions_controller.emulation_control.as_bfld.write_prot_0)
				crtc_c_protect = TRUE;
			else
				crtc_c_protect = FALSE;
			break;
		case 0xec:
			note_entrance0("foreground latch 0");
			extensions_controller.foreground_latch_0 = value;
			SET_FG_LATCH( 0, value );
			break;
		case 0xed:
			note_entrance0("foreground latch 1");
			extensions_controller.foreground_latch_1 = value;
			SET_FG_LATCH( 1, value );
			break;
		case 0xee:
			note_entrance0("foreground latch 2");
			extensions_controller.foreground_latch_2 = value;
			SET_FG_LATCH( 2, value );
			break;
		case 0xef:
			note_entrance0("foreground latch 3");
			extensions_controller.foreground_latch_3 = value;
			SET_FG_LATCH( 3, value );
			break;
		case 0xf0:
			note_entrance0("fast foreground latch load");
			switch (extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state)
			{
				case 0:
					extensions_controller.foreground_latch_0 = value;
					extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 1;
					SET_FG_LATCH( 0, value );
					break;
				case 1:
					extensions_controller.foreground_latch_1 = value;
					extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 2;
					SET_FG_LATCH( 1, value );
					break;
				case 2:
					extensions_controller.foreground_latch_2 = value;
					extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 3;
					SET_FG_LATCH( 2, value );
					break;
				case 3:
					extensions_controller.foreground_latch_3 = value;
					extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 0;
					SET_FG_LATCH( 3, value );
					break;
			}
			break;
		case 0xf1:
			note_entrance0("fast latch load state");
			extensions_controller.fast_latch_load_state.as.abyte = value;
			break;
		case 0xf2:
			note_entrance0("fast background latch load");
			switch (extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state)
			{
				case 0:
					put_latch0(value);
					extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 1;
					break;
				case 1:
					put_latch1(value);
					extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 2;
					break;
				case 2:
					put_latch2(value);
					extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 3;
					break;
				case 3:
					put_latch3(value);
					extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 0;
					break;
			}
			break;
		case 0xf3:
			note_entrance0("masked write control");
			extensions_controller.masked_write_control.as.abyte = value;
			break;
		case 0xf4:
			note_entrance0("masked write mask");
			extensions_controller.masked_write_mask = value;
			break;
		case 0xf5:
			note_entrance0("foreground/background pattern");
			extensions_controller.fg_bg_pattern = value;
			break;
		case 0xf6:
			note_entrance0("1Mb RAM bank select");
			extensions_controller.ram_bank_select.as.abyte = value;
			update_banking();
			break;
		case 0xf7:
			note_entrance0("switch readback");
			extensions_controller.switch_readback = value;
			break;
		case 0xf8:
			note_entrance0("clock control");
			extensions_controller.clock_control.as.abyte = value;
			/* Hope we don't have to do anything here */
			break;
		case 0xf9:
			note_entrance0("page select");
			extensions_controller.page_select.as.abyte = value;
			update_banking();
			break;
		case 0xfa:
			note_entrance0("foreground color");
			extensions_controller.foreground_color.as.abyte = value;
			break;
		case 0xfb:
			note_entrance0("background color");
			extensions_controller.background_color.as.abyte = value;
			break;
		case 0xfc:
			note_entrance0("compatibility control");
			{
				BOOL now_seqchain4;
				BOOL now_seqchain;

				now_seqchain4 = get_seq_chain4_mode();
				now_seqchain = get_seq_chain_mode();
				extensions_controller.compatibility_control.as.abyte = value;
				set_seq_chain4_mode(extensions_controller.compatibility_control.as_bfld.sequential_chain4);
				set_seq_chain_mode(extensions_controller.compatibility_control.as_bfld.sequential_chain);
				if (get_chain4_mode() && (now_seqchain4 != (BOOL)get_seq_chain4_mode()))
				{
					/* do we need to change the read/write routines here?? */
					ega_read_routines_update();
					ega_write_routines_update( CHAINED );
				}
			}
			break;
		case 0xfd:
			note_entrance0("timing select");
			extensions_controller.timing_select.as.abyte = value;
			/* Used to select timing states for V-RAM hi-res modes */
			/* Hope we don't have to do anything here */
			break;
		case 0xfe:
			note_entrance0("foreground/background control");
			extensions_controller.fg_bg_control.as.abyte = value;
			fg_bg_control = value;
			ega_read_routines_update();
			ega_write_routines_update( WRITE_MODE );

			/***
			set_fg_bg_mode();
			***/
			break;
		case 0xff:
			note_entrance0("16-bit interface control");
			extensions_controller.interface_control.as.abyte = value;

			/***
			sort_out_memory_stuff();
			sort_out_interface_stuff();
			***/
			break;
		default:
			NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)
			        fprintf(trace_file,"Bad extensions index %x\n",
			        sequencer.address.as.abyte);)
			break;
	}
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		vga_extn_inb( io_addr port, half_word *value )

Purpose:
		To emulate reading from the V7VGA Extension Registers

Input:
		port	- the V7VGA I/O port (should always be 0x3c5)

Output:
		value	- the value read from the register
		Any other required actions are emulated.

----------------------------------------------------------------------
)*/

GLOBAL VOID
vga_extn_inb(port, value)
io_addr         port;
half_word       *value;
{
#ifndef NEC_98
	note_entrance1("vga_extn_inb(%x)", port);

	switch (sequencer.address.as.abyte) {

		case 0x83:
			*value = (half_word)attribute_controller.address.as.abyte;
			break;
		case 0x8e:
		case 0x8f:
			/* chip revision 3 */
			*value = 0x70;
			break;
		case 0x94:
			*value = extensions_controller.pointer_pattern;
			break;
		case 0x9c:
			*value = (half_word)extensions_controller.ptr_horiz_posn_hi.as.abyte;
			break;
		case 0x9d:
			*value = extensions_controller.ptr_horiz_posn_lo;
			break;
		case 0x9e:
			*value = (half_word)extensions_controller.ptr_vert_posn_hi.as.abyte;
			break;
		case 0x9f:
			*value = extensions_controller.ptr_vert_posn_lo;
			break;
		case 0xa0:
			/* Direct access to memory data latch 0 */
			*value = get_latch0;
			break;
		case 0xa1:
			/* Direct access to memory data latch 1 */
			*value = get_latch1;
			break;
		case 0xa2:
			/* Direct access to memory data latch 2 */
			*value = get_latch2;
			break;
		case 0xa3:
			/* Direct access to memory data latch 3 */
			*value = get_latch3;
			break;
		case 0xa4:
			*value = (half_word)extensions_controller.clock_select.as.abyte;
			break;
		case 0xa5:
			*value = extensions_controller.cursor_attrs.as.abyte & 0x89;
			break;

		/*
		   31.3.92 MG Register C1 controls 6/8 bit data in the DAC.
		*/

		case 0xc1:
			*value = (half_word)extensions_controller.dac_control.as.abyte;	
			break;
		case 0xeb:
			*value = (half_word)extensions_controller.emulation_control.as.abyte;
			break;
		case 0xec:
			*value = extensions_controller.foreground_latch_0;
			break;
		case 0xed:
			*value = extensions_controller.foreground_latch_1;
			break;
		case 0xee:
			*value = extensions_controller.foreground_latch_2;
			break;
		case 0xef:
			*value = extensions_controller.foreground_latch_3;
			break;
		case 0xf0:
			switch (extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state)
			{
				case 0:
					*value = extensions_controller.foreground_latch_0;
					break;
				case 1:
					*value = extensions_controller.foreground_latch_1;
					break;
				case 2:
					*value = extensions_controller.foreground_latch_2;
					break;
				case 3:
					*value = extensions_controller.foreground_latch_3;
					break;
			}
			extensions_controller.fast_latch_load_state.as_bfld.fg_latch_load_state = 0;
			break;
		case 0xf1:
			*value = (half_word)extensions_controller.fast_latch_load_state.as.abyte;
			break;
		case 0xf2:
			switch (extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state)
			{
				case 0:
					*value = get_latch0;
					break;
				case 1:
					*value = get_latch1;
					break;
				case 2:
					*value = get_latch2;
					break;
				case 3:
					*value = get_latch3;
					break;
			}
			extensions_controller.fast_latch_load_state.as_bfld.bg_latch_load_state = 0;
			break;
		case 0xf3:
			*value = extensions_controller.masked_write_control.as.abyte & 3;
			break;
		case 0xf4:
			*value = extensions_controller.masked_write_mask;
			break;
		case 0xf5:
			*value = extensions_controller.fg_bg_pattern;
			break;
		case 0xf6:
			*value = (half_word)extensions_controller.ram_bank_select.as.abyte;
			break;
		case 0xf7:
			*value = extensions_controller.switch_readback;
			break;
		case 0xf8:
			*value = (half_word)extensions_controller.clock_control.as.abyte;
			break;
		case 0xf9:
			*value = (half_word)extensions_controller.page_select.as_bfld.extended_page_select;
			break;
		case 0xfa:
			*value = (half_word)extensions_controller.foreground_color.as.abyte;
			break;
		case 0xfb:
			*value = (half_word)extensions_controller.background_color.as.abyte;
			break;
		case 0xfc:
			*value = (half_word)extensions_controller.compatibility_control.as.abyte;
			break;
		case 0xfd:
			*value = (half_word)extensions_controller.timing_select.as.abyte;
			break;
		case 0xfe:
			*value = extensions_controller.fg_bg_control.as.abyte & 0xe;
			break;
		case 0xff:
			*value = (half_word)extensions_controller.interface_control.as.abyte;
			break;
		default:
			NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)
			        fprintf(trace_file,"Bad extensions index %x\n",
			        sequencer.address.as.abyte);)

		/* 31.3.92 MG This used to return 0xFF, but a real card
		   returns zero. */

			*value = 0;
			break;

	}
	note_entrance1("returning %x",*value);
#endif //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		draw_v7ptr()

Purpose:
		To emulate the V7 hardware pointer on the screen.

Input:
		None.

Output:
		The pointer is displayed on the screen.

----------------------------------------------------------------------
)*/

GLOBAL VOID
draw_v7ptr()
{
#ifndef NEC_98
	sys_addr pattern;

	if (extensions_controller.cursor_attrs.as_bfld.pointer_enable)
	{
		curr_v7ptr_x = extensions_controller.ptr_horiz_posn_lo +
			(extensions_controller.ptr_horiz_posn_hi.as_bfld.ptr_horiz_position << 8);


		if (get_seq_chain4_mode() && get_chain4_mode())
		{
			/*
			 * In the extended 256 col modes we seem to need to halve
			 * the x coordinate to get the pointer in the right place.
			 */
			curr_v7ptr_x >>= 1;
		}

		curr_v7ptr_y = extensions_controller.ptr_vert_posn_lo +
			(extensions_controller.ptr_vert_posn_hi.as_bfld.ptr_vert_position << 8);

		/*
		 * I have never seen the pointer bank select bits used, so
		 * this is a guess as to their meaning.
		 */

	/*
	   1.4.92 MG
	   Sadly, this guess isn't correct - the pointer_bank_select bits are
	   used to select which 256k bank the pointer data is read from. Now
	   we have a problem, as if a program writes the data to the third
	   bank then it actually ends up in the first because the bank
	   selection routines for memory access and off the top bit.

	   As a result, we also need to lose the top bit here. The correct
	   way to do this would be to either support nonexistent VGA memory
	   correctly, or to add another 512k to the memory we already use.
	
	   This fix is mainly to make Windows 3.1 work with its video-7
	   driver. It stuffs bytes into the last few k of the 1Mb space on
	   the video-7 to see if the memory exists. As we just map this
	   access to 512k lower, it thinks we have 1Mb of RAM rather than
	   512k, so puts the pointer at the top of the 1Mb.

	   Programs which call the VGA BIOS to determine the memory size
	   will not have this problem.
	*/

		pattern = (((extensions_controller.interface_control.as_bfld.pointer_bank_select&1) << 16)
			+ (0xc000 + (extensions_controller.pointer_pattern << 6))) << 2;

		(*paint_v7ptr)(pattern, curr_v7ptr_x, curr_v7ptr_y);
	}
#endif  //NEC_98
}

GLOBAL	VOID	remove_v7ptr IFN0()

{
	(*clear_v7ptr)(curr_v7ptr_x, curr_v7ptr_y);
}

GLOBAL	BOOL	v7ptr_between_lines IFN2(int, start_line, int, end_line)

{
	if (curr_v7ptr_y+32<start_line||curr_v7ptr_y>end_line)
		return FALSE;
	return TRUE;
}

#ifdef CPU_40_STYLE
/*
 * 4.0 video support moves v7 fg latch value from variable 'fg_latches'
 * int CPU variable accessed by interface fn to get/set all 4 bytes of
 * latches. Take byte index and value and update v7 latch via interface
 */
GLOBAL void set_v7_fg_latch_byte IFN2(IU8, index, IU8, value)
{
#ifndef NEC_98
	IU32 v7latch;

	/* get current value */
	v7latch = getVideov7_fg_latches();

	/* change byte 'index' to 'value */
	switch(index)
	{
	case 0:
		v7latch = (v7latch & 0xffffff00) | value;
		break;

	case 1:
		v7latch = (v7latch & 0xffff00ff) | (value << 8);
		break;

	case 2:
		v7latch = (v7latch & 0xff00ffff) | (value << 16);
		break;

	case 3:
		v7latch = (v7latch & 0x00ffffff) | (value << 24);
		break;

	default:
		always_trace1("set_v7_fg_latch_byte: index > 3 (%d)", index);
	}

	/* update v7 latches */
	setVideov7_fg_latches(v7latch);
#endif  //NEC_98
}
#endif	/* CPU_40_STYLE */

#endif /* V7VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\vga_prts.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT 		: name and number

RELATED DOCS		: include all relevant references

DESIGNER		:

REVISION HISTORY	:
First version		: February 1990, S. Frost

SUBMODULE NAME		: vga		

SOURCE FILE NAME	: vga_ports.c

PURPOSE			: emulation of VGA registers (ports).
			  Calls lower levels of the VGA emulation (or EGA
			  emulation) to do the real work.

SccsID[]="@(#)vga_ports.c	1.67 07/18/94 Copyright Insignia Solutions Ltd.";


[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE :

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :
			VOID vga_init()
			VOID vga_term()
			VOID vga_seq_inb()
			VOID vga_crtc_outb()
			VOID vga_crtc_inb()
			VOID vga_gc_outb()
			VOID vga_gc_inb()
			VOID vga_ac_outb()
			VOID vga_ac_inb()
			VOID vga_misc_outb()
			VOID vga_misc_inb()
			VOID vga_feat_outb()
			VOID vga_feat_inb()
			VOID vga_ipstat0_inb()
			VOID vga_dac_outb()
			VOID vga_dac_inb()
			LONG vga_get_line_compare()	(* hunter only *)
			LONG vga_get_max_scan_lines()	(* hunter only *)
	DATA 	     :	

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]
-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

	PROCEDURES() :
			io_define_inb
			io_define_outb
			io_redefine_inb
			io_redefine_outb
			io_connect_port
			io_disconnect_port
			flag_mode_change_required()
			set_index_state()
			in_index_state()

	DATA 	     : 	give name, and source module name

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS	  :	specify in following procedure descriptions
			how these are accessed (read/modified)

FILES ACCESSED    :	NONE

DEVICES ACCESSED  :	NONE

SIGNALS CAUGHT	  :	NONE

SIGNALS ISSUED	  :	NONE


[1.4.2 EXPORTED OBJECTS]
=========================================================================
PROCEDURE	  : 	vga_init

PURPOSE		  : 	initialize VGA.

PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	establish vga ports.
			initialize vga code to sensible state.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_term

PURPOSE		  : 	terminate VGA.

PARAMETERS	  :	none

GLOBALS		  :	none

DESCRIPTION	  : 	remove vga ports.
			free up allocated memory etc.

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_seq_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the
			sequencers's register ports, and gets info from
			appropriate vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_crtc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the sequencer chip's ports, and pass
			appropriate info to vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_crtc_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the crtc's register ports,
			and gets info from appropriate vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_gc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the graphics controller chip's ports,
			and pass appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_gc_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the
			graphics controller's register ports, and gets info from
			appropriate vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_ac_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the attribute controller chip's ports, and pass
			appropriate info to vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_ac_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the
			attribute controller's register ports, and gets info
			from appropriate vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================
=========================================================================
PROCEDURE	  : 	vga_misc_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to the miscellaneous register's port, and pass
			appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_ipstat0_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from the input status register 0 port,
			and gets info from appropriate ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none

DESCRIPTION	  : 	

ERROR INDICATIONS :	none.

ERROR RECOVERY	  :	none.
=========================================================================

=========================================================================
PROCEDURE	  : 	vga_dac_inb((io_addr) port, (half_word) *value)

PURPOSE		  : 	deal with an attempt to read a byte from one of the
			DAC's register ports, and gets info from appropriate
			vga sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	pointer to memory byte where value read from port should go.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================
=========================================================================
PROCEDURE	  : 	vga_dac_outb((io_addr) port, (half_word) value)

PURPOSE		  : 	deal with bytes written to one of the DAC register
			ports, and pass appropriate info to ega sub-modules.

PARAMETERS
	port	  :	port address written to.
	value	  :	the byte written to the port.

GLOBALS		  :	none
DESCRIPTION	  : 	
ERROR INDICATIONS :	none.
ERROR RECOVERY	  :	none.
=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/

/* [3.1.1 #INCLUDES]                                                    */

#ifndef REAL_VGA	/* ega port handling moved to host for REAL_VGA */
#ifdef VGG

#include	"xt.h"
#include	CpuH
#include	"debug.h"
#include  	"timer.h"
/* both timer.h & gvi.h define HIGH & LOW - ensure we get gvi definitions */
#undef HIGH
#undef LOW
#include	"sas.h"
#include	"gmi.h"
#include	"gvi.h"
#include	"ios.h"
#include  	"ica.h"
#include  	"gfx_upd.h"
#include	"egacpu.h"
#include	"egagraph.h"
#include	"video.h"
#include	"egaread.h"
#include	"egamode.h"
#include	"vgaports.h"
#include	"error.h"
#include	"config.h"

#include	"host_gfx.h"

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/

#include	"egaports.h"

#ifdef GISP_SVGA
#include "hwvgaio.h"
#endif 	/* GISP_SVGA */

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

VOID vote_vga_mode IPT0();

/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_VGA.seg"
#endif


/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/
#ifdef V7VGA
GLOBAL struct extensions_controller extensions_controller;
#endif /* V7VGA */
GLOBAL struct crt_controller crt_controller;
GLOBAL struct sequencer sequencer;
GLOBAL struct attribute_controller attribute_controller;
GLOBAL struct graphics_controller graphics_controller;

/* Registers not contained in an LSI device */

GLOBAL MISC_OUTPUT_REG	miscellaneous_output_register;

GLOBAL FEAT_CONT_REG	feature_control_register;

GLOBAL INPUT_STAT_REG0	input_status_register_zero;

GLOBAL INPUT_STAT_REG1	input_status_register_one;

typedef	enum { DAC_RED, DAC_GREEN, DAC_BLUE }	RGB;
LOCAL	RGB 	DAC_rgb_state = DAC_RED;
LOCAL	byte	DAC_wr_addr;
LOCAL	byte	DAC_rd_addr;
LOCAL	byte	DAC_state;

/* 31.3.92 MG For windows 3.1 we must emulate the DAC correctly, storing
   6 or 8 bit data depending on the value in the video-7 C1 extension
   register. */

GLOBAL	byte	DAC_data_mask=0x3f;
#ifdef V7VGA
GLOBAL	int	DAC_data_bits=6;
#endif

byte	crtc_0_7_protect	= FALSE;
#ifdef V7VGA
byte	crtc_0_8_protect	= FALSE;
byte	crtc_9_b_protect	= FALSE;
byte	crtc_c_protect	= FALSE;
#endif /* V7VGA */


IMPORT half_word bg_col_mask; /* Used to work out the background colour */

VOID vga_ipstat1_inb IPT2(io_addr,port,half_word *,value);

/* Declarations for new sequencer code */
VOID vga_seq_outb_index IPT2(io_addr,port,half_word,value);
VOID vga_seq_clock IPT2(io_addr,port,half_word,value);
VOID vga_seq_char_map IPT2(io_addr,port,half_word,value);
VOID vga_seq_mem_mode IPT2(io_addr,port,half_word,value);
#ifdef V7VGA
IMPORT VOID vga_seq_extn_control IPT2(io_addr,port,half_word,value);
IMPORT VOID vga_extn_outb IPT2(io_addr,port,half_word,value);
IMPORT VOID vga_extn_inb IPT2(io_addr,port,half_word *,value);
#endif /* V7VGA */
VOID vga_seq_inb IPT2(io_addr,port,half_word *,value);
/* Same as EGA */
VOID vga_seq_map_mask IPT2(io_addr,port,half_word,value);

IMPORT VOID (*ega_seq_regs[]) IPT2(io_addr, port, half_word, value);
IMPORT VOID ega_seq_reset IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_seq_clock IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_seq_map_mask IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_seq_char_map IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_seq_mem_mode IPT2(io_addr,port,half_word,value);

/* Declarations for VGA graphics controller code */
/* VGA differing versions */
VOID vga_gc_mode IPT2(io_addr,port,half_word,value);
VOID vga_gc_inb IPT2(io_addr,port,half_word *,value);
VOID vga_gc_outb IPT2(io_addr,port,half_word,value);
/* Same as EGA but needed as static struct has changed - shame */
VOID vga_gc_outb_index IPT2(io_addr,port,half_word,value);
VOID vga_gc_outw IPT2(io_addr,port,word,value);
VOID vga_gc_set_reset IPT2(io_addr,port,half_word,value);
VOID vga_gc_enable_set IPT2(io_addr,port,half_word,value);
VOID vga_gc_compare IPT2(io_addr,port,half_word,value);
VOID vga_gc_rotate IPT2(io_addr,port,half_word,value);
VOID vga_gc_read_map IPT2(io_addr,port,half_word,value);
VOID vga_gc_misc IPT2(io_addr,port,half_word,value);
VOID vga_gc_dont_care IPT2(io_addr,port,half_word,value);
VOID vga_gc_mask IPT2(io_addr,port,half_word,value);
VOID vga_gc_mask_ff IPT2(io_addr,port,half_word,value);


/* extern decls to put redirection array back */
IMPORT VOID (*ega_gc_regs[]) IPT2(io_addr,port,half_word,value);
#ifndef A2CPU
IMPORT VOID (*ega_gc_regs_cpu[]) IPT2(io_addr,port,half_word,value);
#endif
IMPORT VOID ega_gc_set_reset IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_enable_set IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_compare IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_rotate IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_read_map IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_mode IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_misc IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_set_reset IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_dont_care IPT2(io_addr,port,half_word,value);
IMPORT VOID ega_gc_mask_ff IPT2(io_addr,port,half_word,value);

IMPORT VOID _vga_gc_outb_index IPT2(io_addr,port,half_word,value);
IMPORT VOID _ega_gc_outb_mask IPT2(io_addr,port,half_word,value);
IMPORT VOID _ega_gc_outb_mask_ff IPT2(io_addr,port,half_word,value);

/* Declarations for VGA DAC code */
VOID vga_dac_inb IPT2(io_addr,port,half_word *,value);
VOID vga_dac_outb IPT2(io_addr,port,half_word,value);
VOID vga_dac_data_outb IPT2(io_addr,port,half_word,value);
VOID vga_dac_data_inb IPT2(io_addr,port,half_word *,value);

VOID vga_ac_inb IPT2(io_addr,port,half_word *,value);
VOID vga_ac_outb IPT2(io_addr,port,half_word,value);
VOID vga_crtc_inb IPT2(io_addr,port,half_word *,value);
VOID vga_crtc_outb IPT2(io_addr,port,half_word,value);
VOID vga_misc_outb IPT2(io_addr,port,half_word,value);
VOID vga_misc_inb IPT2(io_addr,port,half_word *,value);
VOID vga_feat_outb IPT2(io_addr,port,half_word,value);
VOID vga_feat_inb IPT2(io_addr,port,half_word *,value);
VOID vga_ipstat0_inb IPT2(io_addr,port,half_word *,value);
/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

void set_index_state(void);
boolean in_index_state(void);

/* copy of ega routines needed to access correct copy of structs */
LOCAL VOID	do_chain_majority_decision IFN0()
{
#ifndef NEC_98
	SAVED	SHORT	current_votes=0;
	SHORT		new_votes;

	new_votes = sequencer.memory_mode.as_bfld.not_odd_or_even ? 0 : 1 ;	/* 0 - chained */
	new_votes += (SHORT)graphics_controller.mode.as_bfld.odd_or_even ;	/* 1 - chained */
	new_votes += (SHORT)graphics_controller.miscellaneous.as_bfld.odd_or_even ;	/* 1 - chained */

	if(( new_votes == 1 ) && ( current_votes > 1 ) && ( EGA_CPU.chain != CHAIN4 ))
	{
		/*
		 * Transition from chained to unchained
		 */

		EGA_CPU.chain  = UNCHAINED;
		setVideochain(EGA_CPU.chain);
		ega_read_routines_update();
		ega_write_routines_update(CHAINED);
		set_memory_chained(NO);
		flag_mode_change_required();
	}
	else
	{
		if(( new_votes > 1 ) && ( current_votes == 1 ))
		{
			/*
			 * Transition from unchained to chained
			 */

			EGA_CPU.chain = CHAIN2;
			setVideochain(EGA_CPU.chain);
			ega_read_routines_update();
			ega_write_routines_update(CHAINED);
			set_memory_chained(YES);
			flag_mode_change_required();
		}
	}

	current_votes = new_votes;
#endif  //NEC_98
}

#ifdef	NTVDM
/*
 * NTVDM uses do_new_cursor() to sync the emulation.
 */
GLOBAL VOID	do_new_cursor IFN0()
#else
LOCAL VOID	do_new_cursor IFN0()
#endif
{
#ifndef NEC_98

	note_entrance0("do_new_cursor()");

	if (crt_controller.cursor_start.as_bfld.cursor_start >= (unsigned)get_char_height() ) {
		note_entrance0("No cursor");
		set_cursor_visible(FALSE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start | 0x20,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end == 0) {
		note_entrance0("cursor from start to bum");
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(get_char_height() - get_cursor_start());
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end < crt_controller.cursor_start.as_bfld.cursor_start) {
		note_entrance0("2 cursors");
		set_cursor_start1(0);
		set_cursor_height1(crt_controller.cursor_end.as_bfld.cursor_end);
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(get_char_height() - get_cursor_start());
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end == crt_controller.cursor_start.as_bfld.cursor_start) {
		note_entrance0("One line cursor");
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(1);
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else if (crt_controller.cursor_end.as_bfld.cursor_end - 1 >= (unsigned)get_char_height()) {
		note_entrance0("block cursor");
		set_cursor_start(0);
		set_cursor_height(get_char_height());
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}
	else {
		assert2(((crt_controller.cursor_end.as_bfld.cursor_end - 1) >= crt_controller.cursor_start.as_bfld.cursor_start),
				"cursor values do not match default set Start %d, End %d",
				crt_controller.cursor_end.as_bfld.cursor_end,
				crt_controller.cursor_start.as_bfld.cursor_start);
		note_entrance0("normal cursor");
		set_cursor_start(crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_height(crt_controller.cursor_end.as_bfld.cursor_end - crt_controller.cursor_start.as_bfld.cursor_start);
		set_cursor_start1(0);
		set_cursor_height1(0);
		set_cursor_visible(TRUE);
		host_cursor_size_changed(crt_controller.cursor_start.as_bfld.cursor_start,
					crt_controller.cursor_end.as_bfld.cursor_end);
	}

	if(( get_cur_y() < 0 ) ||
			((( get_cur_y() + 1 ) * get_char_height()) > get_screen_height() ))
	{
		set_cursor_visible( FALSE );
	}

	base_cursor_shape_changed();
#endif  //NEC_98
}
/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

/*
[7.1 INTERMODULE DATA DEFINITIONS]				*/

PC_palette *DAC;

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/

GLOBAL UTINY *vga_gc_outb_index_addr;

#if defined(NEC_98)
extern  BOOL    video_emu_mode ;        /* NEC NEC98 PIF FILE INFORMATION */
GLOBAL VOID     NEC98_init()
{
        note_entrance0("NEC98_init");

        if( video_emu_mode ){
                choose_display_mode = choose_NEC98_graph_mode;
        }else{
                choose_display_mode = choose_NEC98_display_mode;
        }

        set_pc_pix_height(1);
        set_host_pix_height(1);

        init_NEC98_globals();

        NEC98_CPU.fun_or_protection = 1;       /* assume complicated until we know it's easy */
        NEC98GLOBS->bit_prot_mask = 0xffffffff;

        gvi_pc_low_regen  = NEC98_TEXT_P0_PTR ;
        gvi_pc_high_regen = NEC98_TEXT_P0_PTR + NEC98_REGEN_END;

        set_pix_width(1);
        set_pix_char_width(8);
        set_display_disabled(FALSE);

        set_char_height(16);
        set_screen_height(399);
        set_screen_start(0);
        set_word_addressing(YES);
        set_actual_offset_per_line(80);
        set_offset_per_line(160);       /* chained */
        set_horiz_total(80);    /* calc screen params from this and prev 3 */
        set_screen_split(511);  /* make sure there is no split screen to start with ! */

        set_prim_font_index(0);
        set_sec_font_index(0);
        set_regen_ptr(0,EGA_planes);////for Graphics

        /* prevent copyright message mysteriously disappearing */
        timer_video_enabled = TRUE;

}
#endif  //NEC_98

GLOBAL VOID	vga_init IFN0()
{
#ifndef NEC_98
	note_entrance0("vga_init");
	/*
	 * Define sequencer's ports
	 */

	ega_seq_regs[1] = FAST_FUNC_ADDR(vga_seq_clock);
	ega_seq_regs[2] = FAST_FUNC_ADDR(vga_seq_map_mask);
	ega_seq_regs[3] = FAST_FUNC_ADDR(vga_seq_char_map);
	ega_seq_regs[4] = FAST_FUNC_ADDR(vga_seq_mem_mode);
#ifdef V7VGA
	ega_seq_regs[6] = vga_seq_extn_control;
#endif /* V7VGA */

	io_define_outb(EGA_SEQ_ADAP_INDEX,vga_seq_outb_index);
	io_define_outb(EGA_SEQ_ADAP_DATA,ega_seq_reset);
        io_define_inb(EGA_SEQ_ADAP_INDEX,vga_seq_inb);
        io_define_inb(EGA_SEQ_ADAP_DATA,vga_seq_inb);
	io_connect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX,IO_READ_WRITE);
	io_connect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA,IO_READ_WRITE);

	/*
	 * Define CRTC's ports
	 */

	io_define_outb(EGA_CRTC_ADAPTOR,vga_crtc_outb);
	io_define_inb(EGA_CRTC_ADAPTOR,vga_crtc_inb);
	io_connect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR,IO_READ_WRITE);
	io_connect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR,IO_READ_WRITE);

	/*
	 * Define Graphics Controller's ports
	 */

	ega_gc_regs[0] = FAST_FUNC_ADDR(vga_gc_set_reset);
	ega_gc_regs[1] = FAST_FUNC_ADDR(vga_gc_enable_set);
	ega_gc_regs[2] = FAST_FUNC_ADDR(vga_gc_compare);
	ega_gc_regs[3] = FAST_FUNC_ADDR(vga_gc_rotate);
	ega_gc_regs[4] = FAST_FUNC_ADDR(vga_gc_read_map);
	ega_gc_regs[5] = FAST_FUNC_ADDR(vga_gc_mode);
	ega_gc_regs[6] = FAST_FUNC_ADDR(vga_gc_misc);
	ega_gc_regs[7] = FAST_FUNC_ADDR(vga_gc_dont_care);
	ega_gc_regs[8] = FAST_FUNC_ADDR(vga_gc_mask_ff);

	vga_gc_outb_index_addr = (UTINY *) &graphics_controller.address;

	io_define_out_routines(EGA_GC_ADAP_INDEX, vga_gc_outb_index, vga_gc_outw, NULL, NULL);

#ifndef CPU_40_STYLE	/* TEMPORARY */
	Cpu_define_outb(EGA_GC_ADAP_INDEX,_vga_gc_outb_index);
#endif

	io_define_outb(EGA_GC_ADAP_DATA,ega_gc_set_reset);
	Cpu_define_outb(EGA_GC_ADAP_DATA,NULL);
#ifndef A2CPU
	ega_gc_regs_cpu[8] = NULL;
#endif

	io_define_inb(EGA_GC_ADAP_INDEX,vga_gc_inb);
	io_define_inb(EGA_GC_ADAP_DATA,vga_gc_inb);

	io_connect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX,IO_READ_WRITE);
	io_connect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA,IO_READ_WRITE);

	/*
	 * Define Attribute controller's ports
	 */

	io_define_outb(EGA_AC_ADAPTOR,vga_ac_outb);
	io_define_inb(EGA_AC_ADAPTOR,vga_ac_inb);
	io_connect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR,IO_READ_WRITE);
	io_connect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR,IO_READ);

	/*
	 * Define Miscellaneous register's port
	 */

	io_define_outb(EGA_MISC_ADAPTOR,vga_misc_outb);
	io_define_inb(EGA_MISC_ADAPTOR,vga_misc_inb);
	io_connect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR,IO_WRITE);
	io_connect_port(VGA_MISC_READ_REG,EGA_MISC_ADAPTOR,IO_READ);

	/*
	 * Define Feature controller's port
	 */

	io_define_outb(EGA_FEAT_ADAPTOR,vga_feat_outb);
	io_define_inb(EGA_FEAT_ADAPTOR,vga_feat_inb);
	io_connect_port(EGA_FEAT_REG,EGA_FEAT_ADAPTOR,IO_WRITE);
	io_connect_port(VGA_FEAT_READ_REG,EGA_FEAT_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 0 port
	 */

	io_define_inb(EGA_IPSTAT0_ADAPTOR,vga_ipstat0_inb);
	io_connect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 1 port
	 */

	io_define_inb(EGA_IPSTAT1_ADAPTOR,vga_ipstat1_inb);
	io_connect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR,IO_READ);

        /*
         * Define VGA DAC register port
         */
        io_define_inb(VGA_DAC_INDEX_PORT,vga_dac_inb);
        io_define_outb(VGA_DAC_INDEX_PORT,vga_dac_outb);
        io_connect_port(VGA_DAC_MASK,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_connect_port(VGA_DAC_RADDR,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_connect_port(VGA_DAC_WADDR,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_define_inb(VGA_DAC_DATA_PORT,vga_dac_data_inb);
        io_define_outb(VGA_DAC_DATA_PORT,vga_dac_data_outb);
        io_connect_port(VGA_DAC_DATA,VGA_DAC_DATA_PORT,IO_READ_WRITE);

	/*
	 * Initialise internals of VGA
	 * +++++++++++++++++++++++++++
	 */

	choose_display_mode = choose_vga_display_mode;

	miscellaneous_output_register.as.abyte = 0;

	set_pc_pix_height(1); /* set by bit 7 of the crtc max scanline reg */
	set_host_pix_height(1);

	/* Initialize address map */

	graphics_controller.miscellaneous.as.abyte = 0;
	graphics_controller.read_map_select.as_bfld.map_select = 0;

	/* Looking for bright white */

	graphics_controller.color_compare.as_bfld.color_compare = 0xf;

	/* All planes significant */

	graphics_controller.color_dont_care.as_bfld.color_dont_care = 0xf;

	/* Initialise palette source */

	attribute_controller.address.as_bfld.palette_address_source = 1;

	/* Initialise crtc screen height fields and set screen height to be consistent */

	crt_controller.vertical_display_enable_end = 0;
	crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_8 = 0;
	crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_9 = 0;
	/* JOKER: Avoid video BIOS dividing by zero.. */
	crt_controller.horizontal_display_end = (IU8)400;
	set_screen_height(0);

	init_vga_globals();
	EGA_CPU.fun_or_protection = 1;	/* assume complicated until we know it's easy */

	setVideobit_prot_mask(0xffffffff);

#ifdef V7VGA
	/* Initialise V7VGA Extensions Registers */
	extensions_controller.pointer_pattern = 0xff;
	extensions_controller.clock_select.as.abyte = 0;
	extensions_controller.cursor_attrs.as.abyte = 0;
	extensions_controller.emulation_control.as.abyte = 0;
	extensions_controller.masked_write_control.as_bfld.masked_write_enable = 0;
	extensions_controller.ram_bank_select.as.abyte = 0;
	extensions_controller.clock_control.as.abyte &= 0xe4;
	extensions_controller.page_select.as.abyte = 0;
	extensions_controller.compatibility_control.as.abyte &= 0x2;
	extensions_controller.timing_select.as.abyte = 0;
	extensions_controller.fg_bg_control.as.abyte &= 0xf3;
	extensions_controller.interface_control.as.abyte &= 0xe0;
	extensions_controller.foreground_latch_1 = 0;

	/* 31.3.92 MG Default to six-bit palette */

	extensions_controller.dac_control.as.abyte=0;
	DAC_data_bits=6;
#endif /* V7VGA */
	DAC_data_mask=0x3f;

	ega_write_init();
	ega_read_init();
	ega_mode_init();

	/*
	 * Some parts of input status register always return 1, so set fields accordingly
	 */
	input_status_register_zero.as.abyte = 0x70 ;

	/*
	 * set up some variables to get us going (They may have to be changed in the fullness of time)
	 */

	gvi_pc_low_regen  = CGA_REGEN_START;
	gvi_pc_high_regen = CGA_REGEN_END;

	set_pix_width(1);
	set_pix_char_width(8);
	set_display_disabled(FALSE);

	set_char_height(8);
#ifdef V7VGA
	set_screen_limit(0x20000);
#else
	set_screen_limit(0x8000);
#endif /* V7VGA */
	set_screen_start(0);
	set_word_addressing(YES);
	set_actual_offset_per_line(80);
	set_offset_per_line(160);	/* chained */
	set_horiz_total(80);	/* calc screen params from this and prev 3 */
#ifdef NTVDM
	set_screen_split(0x3FF);	/* 10 bits for VGA line compare register */
#else
	set_screen_split(511);	/* make sure there is no split screen to start with ! */
#endif

	set_prim_font_index(0);
	set_sec_font_index(0);

	set_regen_ptr(0,EGA_planes);

	/* prevent copyright message mysteriously disappearing */
	timer_video_enabled = TRUE;

#endif  //NEC_98
}

GLOBAL VOID	vga_term IFN0()
{
#ifndef NEC_98
SHORT	index;

	note_entrance0("vga_term");

	/*
	 * Disconnect sequencer's ports
	 */

	ega_seq_regs[1] = FAST_FUNC_ADDR(ega_seq_clock);
	ega_seq_regs[2] = FAST_FUNC_ADDR(ega_seq_map_mask);
	ega_seq_regs[3] = FAST_FUNC_ADDR(ega_seq_char_map);
	ega_seq_regs[4] = FAST_FUNC_ADDR(ega_seq_mem_mode);
	io_disconnect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX);
	io_disconnect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA);

	/*
	 * Disconnect CRTC's ports
	 */

	io_disconnect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR);
	io_disconnect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR);

	/*
	 * Disconnect Graphics Controller's ports
	 */

	ega_gc_regs[0] = FAST_FUNC_ADDR(ega_gc_set_reset);
	ega_gc_regs[1] = FAST_FUNC_ADDR(ega_gc_enable_set);
	ega_gc_regs[2] = FAST_FUNC_ADDR(ega_gc_compare);
	ega_gc_regs[3] = FAST_FUNC_ADDR(ega_gc_rotate);
	ega_gc_regs[4] = FAST_FUNC_ADDR(ega_gc_read_map);
	ega_gc_regs[5] = FAST_FUNC_ADDR(ega_gc_mode);
	ega_gc_regs[6] = FAST_FUNC_ADDR(ega_gc_misc);
	ega_gc_regs[7] = FAST_FUNC_ADDR(ega_gc_dont_care);
	ega_gc_regs[8] = FAST_FUNC_ADDR(ega_gc_mask_ff);
	io_disconnect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX);
	io_disconnect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA);

	/*
	 * Disconnect Attribute controller's ports
	 */

	io_disconnect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR);
	io_disconnect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR);

	/*
	 * Disconnect Miscellaneous register's port
	 */

	io_disconnect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR);
	io_disconnect_port(VGA_MISC_READ_REG,EGA_MISC_ADAPTOR);

	/*
	 * Disconnect Feature controller port
	 */

	io_disconnect_port(EGA_FEAT_REG,EGA_MISC_ADAPTOR);
	io_disconnect_port(VGA_FEAT_READ_REG,EGA_MISC_ADAPTOR);

	/*
	 * Disconnect Input Status Register 0 port
	 */

	io_disconnect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR);

	/*
	 * Disconnect Input Status Register 1 port
	 */

	io_disconnect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR);

        /*
         * Disconnect DAC ports
         */

        io_disconnect_port(VGA_DAC_MASK,VGA_DAC_INDEX_PORT);
        io_disconnect_port(VGA_DAC_RADDR,VGA_DAC_INDEX_PORT);
        io_disconnect_port(VGA_DAC_WADDR,VGA_DAC_INDEX_PORT);
        io_disconnect_port(VGA_DAC_DATA,VGA_DAC_DATA_PORT);

	/*
	 * Free internals of VGA
	 */

	/* free the font files */
	for (index = 0; index < MAX_NUM_FONTS; index++)
		host_free_font(index);

	EGA_CPU.chain = UNCHAINED;
	setVideochain(EGA_CPU.chain);
	set_chain4_mode(NO);
	EGA_CPU.doubleword = FALSE;
	set_doubleword_mode(NO);
	set_graph_shift_reg(NO);
	set_256_colour_mode(NO);

	/* Disable CPU read processing */
	ega_read_term();
	ega_write_term();
#endif  //NEC_98
}

GLOBAL VOID	vga_seq_dummy_outb IFN2(io_addr,port,half_word,value)
{
	UNUSED(port);
#ifdef PROD
	UNUSED(value);
#endif

	assert2(NO,"Output to bad seq reg %#x with data %#x\n",sequencer.address.as.abyte,value);
}

GLOBAL VOID	vga_seq_outb_index IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("vga_seq_outb_index(%x,%x)", port, value);
#ifdef V7VGA
	if (sequencer.extensions_control.as_bfld.extension_enable && (value & 0x80))
	{
		sequencer.address.as.abyte = value;
		io_redefine_inb(EGA_SEQ_ADAP_DATA, vga_extn_inb);
		io_redefine_outb(EGA_SEQ_ADAP_DATA, vga_extn_outb);
		return;
	}
	io_redefine_inb(EGA_SEQ_ADAP_DATA, vga_seq_inb);
#endif /* V7VGA */
	
	sequencer.address.as.abyte = ( value & 0x07 );

#ifndef V7VGA
	if (value > 4)
	{
		/* a bad port index value, so ignore any data sent to it */
		io_redefine_outb(EGA_SEQ_ADAP_DATA,vga_seq_dummy_outb);
		return;
	}
#endif /* !V7VGA */
	io_redefine_outb(EGA_SEQ_ADAP_DATA,ega_seq_regs[value & 0x07]);
#endif  //NEC_98
}


GLOBAL VOID	vga_seq_clock IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
	unsigned dot_clock;
	unsigned screen_off;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(1,%x)\n",value);)
	note_entrance2("vga_seq_clock(%x,%x)", port, value);
	/* clock mode register */
	dot_clock = sequencer.clocking_mode.as_bfld.dot_clock;
	screen_off = sequencer.clocking_mode.as_bfld.screen_off;
	sequencer.clocking_mode.as.abyte = value;
	if (sequencer.clocking_mode.as_bfld.dot_clock != dot_clock) {
		/*
		** Switch to/from double width pixels
		*/
		if (sequencer.clocking_mode.as_bfld.dot_clock==1) {
			set_pix_width(2);
			set_double_pix_wid(YES);
			set_pix_char_width(16);
		} else {
			set_pix_width(1);
			set_double_pix_wid(NO);
			set_pix_char_width(8);
		}
		flag_mode_change_required();
	}
	if (sequencer.clocking_mode.as_bfld.screen_off != screen_off) {
	    if (sequencer.clocking_mode.as_bfld.screen_off) {
		set_display_disabled(TRUE);
		timer_video_enabled = 0;
		disable_gfx_update_routines();
	    }
	    else {
		set_display_disabled(FALSE);
		timer_video_enabled = 1;
		enable_gfx_update_routines();
		screen_refresh_required();
	    }
	}
#endif  //NEC_98
}

/* the vga supports 4 fonts maps to the ega's 4 */
GLOBAL VOID	vga_seq_char_map IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned map_selects;
FAST TINY select_a, select_b;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(3,%#x)\n",value);)
	note_entrance2("vga_seq_char_map(%x,%x)", port, value);
	/* char map select reg */
	map_selects = sequencer.character_map_select.character.map_selects;
	sequencer.character_map_select.as.abyte = value;
	if (sequencer.character_map_select.character.map_selects != map_selects)
	{
		/*
		** character mapping attributes have changed.
		**
		** If fonts selected are different bit 3 of attribute byte in alpha mode
		** selects which of the two fonts to use (giving 512 chars).
		*/


		select_a = sequencer.character_map_select.as_bfld.character_map_select_a | (sequencer.character_map_select.as_bfld.ch_map_select_a_hi << 2);
		select_b = sequencer.character_map_select.as_bfld.character_map_select_b | (sequencer.character_map_select.as_bfld.ch_map_select_b_hi << 2);
		EGA_GRAPH.attrib_font_select = (select_a != select_b);
		set_prim_font_index(select_a);
		set_sec_font_index(select_b);

		host_select_fonts(get_prim_font_index(), get_sec_font_index());
		flag_mode_change_required();
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_seq_mem_mode IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
    unsigned now_chain4;

#ifdef PROD
	UNUSED(port);
#endif
    NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(4,%#x)\n",value);)
    note_entrance2("vga_seq_mem_mode(%x,%x)", port, value);

    now_chain4 = sequencer.memory_mode.as_bfld.chain4;
    /* mem mode register */
    sequencer.memory_mode.as.abyte = value ;

    if( now_chain4 != sequencer.memory_mode.as_bfld.chain4 )
    {
		if( sequencer.memory_mode.as_bfld.chain4 == 0 )
		{
			EGA_CPU.chain = UNCHAINED;
			setVideochain(EGA_CPU.chain);
			set_chain4_mode(NO);
			do_chain_majority_decision();
			if (EGA_CPU.chain != CHAIN2)
			{
				ega_read_routines_update();
				ega_write_routines_update(CHAINED);
				flag_mode_change_required();
			}
		}
		else
		{
			EGA_CPU.chain = CHAIN4;
			setVideochain(EGA_CPU.chain);
			set_chain4_mode(YES);
			set_memory_chained(NO);
			ega_read_routines_update();
			ega_write_routines_update(CHAINED);
			flag_mode_change_required();
		}

    }
    else
    {
		do_chain_majority_decision();
    }

    assert1(sequencer.memory_mode.as_bfld.extended_memory == 1,
			    "Someone is trying to set extended memory to 0 (reg=%x)",value);
#endif  //NEC_98
}

GLOBAL VOID	vga_seq_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
	note_entrance1("vga_seq_inb(%x)", port);
	if (port == EGA_SEQ_INDEX) {
	    *value = (half_word)sequencer.address.as.abyte;
	    note_entrance1("returning %x",*value);
	    return;
	}
	if (port == EGA_SEQ_DATA) {
	    switch(sequencer.address.as.abyte) {

	    case 0:
		*value = 3;
		break;
	    case 1:
		*value = (half_word)sequencer.clocking_mode.as.abyte;
		break;
	    case 2:
		*value = (half_word)getVideoplane_enable();
		break;
	    case 3:
		*value = (half_word)sequencer.character_map_select.as.abyte;
		break;
	    case 4:
		*value = (half_word)sequencer.memory_mode.as.abyte;
		break;
#ifdef V7VGA
	    case 6:
		*value = (half_word)sequencer.extensions_control.as.abyte;
		break;
#endif /* V7VGA */
	    default:
		assert1(NO,"Bad sequencer index %d\n",sequencer.address.as.abyte);
		*value = IO_EMPTY_PORT_BYTE_VALUE;
	    }
	    note_entrance1("returning %x",*value);
	}
	else {
	    assert1(NO,"Bad seq port %d",port);
	    *value = IO_EMPTY_PORT_BYTE_VALUE;
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_crtc_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
	SHORT offset;
	struct
	{	/* aVOID alignment problems with casts */
		unsigned value : 8;
	} new;


	note_entrance2("vga_crtc_outb(%x,%x)", port, value);
	switch (port) {
		case 0x3d4:
			note_entrance1("New crtc index %d",value);
			crt_controller.address.as.abyte = value;
			break;
		case 0x3d5:
			note_entrance1( "Index %d", crt_controller.address.as_bfld.index );
			NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE) if (crt_controller.address.as_bfld.index != 0xe && crt_controller.address.as_bfld.index != 0xf)fprintf(trace_file,"crtc(%#x,%#x)\n",crt_controller.address.as_bfld.index,value);)
			/*
			 * We have to save all values in the VGA, even if we
			 * dont support the reg, as all values are read/write.
			 */
			switch (crt_controller.address.as_bfld.index) {
				case 0:
					note_entrance0("horiz total");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.horizontal_total = value;
					break;
				case 1:
					note_entrance0("horiz display end");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
					{
						crt_controller.horizontal_display_end = value+1;
						if (get_256_colour_mode())
						{
							set_horiz_total(crt_controller.horizontal_display_end>>1);
						}
						else
						{
							set_horiz_total(crt_controller.horizontal_display_end);
						}
					}
					break;
				case 2:
					note_entrance0("start horiz blank");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.start_horizontal_blanking = value;
					break;
				case 3:
					note_entrance0("end horiz blank");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.end_horizontal_blanking.as.abyte = value;
					break;
				case 4:
					note_entrance0("start horiz retrace");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.start_horizontal_retrace = value;
					break;
				case 5:
					note_entrance0("end horiz retrace");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.end_horizontal_retrace.as.abyte = value;
					break;
				case 6:
					note_entrance0("vert tot");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE && crtc_0_7_protect == FALSE)
#else
					if (crtc_0_7_protect == FALSE)
#endif /* V7VGA */
						crt_controller.vertical_total = value;
					break;
				case 7:
					note_entrance0("overflow");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE)
					{
#endif /* V7VGA */
						new.value = value;
						if (crtc_0_7_protect) {
							byte temp_line_cmp;
							temp_line_cmp = (byte) ((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8;
							((CRTC_OVERFLOW*)&new)->as.abyte = crt_controller.crtc_overflow.as.abyte;
							((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8 = temp_line_cmp;
						}
						if (crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_8 !=
								((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8)
						{
							/*
							 * Screen height changed
							 */

							set_screen_height_med_recal(
								((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_8 );

							flag_mode_change_required();
						}
						if (crt_controller.crtc_overflow.as_bfld.line_compare_bit_8 !=
							((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8)
						{
							/*
							 * split screen height changed
							 */

							EGA_GRAPH.screen_split.as_bfld.med_bit =
									((CRTC_OVERFLOW*)&new)->as_bfld.line_compare_bit_8;

							if( !get_split_screen_used() )
								flag_mode_change_required();

							screen_refresh_required();
						}
						if (crt_controller.crtc_overflow.as_bfld.vertical_display_enab_end_bit_9 !=
							((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_9)
						{
							/*
							 * split screen height changed
							 */
							set_screen_height_hi_recal(((CRTC_OVERFLOW*)&new)->as_bfld.vertical_display_enab_end_bit_9);
							flag_mode_change_required();
						}
#ifdef NTVDM
						crt_controller.crtc_overflow.as.abyte = new.value;
#else
						crt_controller.crtc_overflow.as.abyte = value;
#endif
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 8:
					note_entrance0("preset row scan");
#ifdef V7VGA
					if (crtc_0_8_protect == FALSE)
#endif /* V7VGA */
						crt_controller.preset_row_scan.as.abyte = value;
					break;
				case 9:
					note_entrance0("max scan line");
#ifdef V7VGA
					if (crtc_9_b_protect == FALSE)
					{
#endif /* V7VGA */
						new.value = value;
						if (crt_controller.maximum_scan_line.as_bfld.maximum_scan_line
							!= ((MAX_SCAN_LINE*)&new)->as_bfld.maximum_scan_line)
						{
							set_char_height_recal(
								(((MAX_SCAN_LINE*)&new)->as_bfld.maximum_scan_line)+1);
							do_new_cursor();
							flag_mode_change_required();
						}

						if( crt_controller.maximum_scan_line.as_bfld.double_scanning
								!= ((MAX_SCAN_LINE*)&new)->as_bfld.double_scanning)
						{
							set_pc_pix_height(1 <<
								((MAX_SCAN_LINE*)&new)->as_bfld.double_scanning);

							flag_mode_change_required();
						}

						if (crt_controller.maximum_scan_line.as_bfld.line_compare_bit_9
							!= ((MAX_SCAN_LINE*)&new)->as_bfld.line_compare_bit_9)
						{
							/*
							 * split screen height changed
							 */

							EGA_GRAPH.screen_split.as_bfld.top_bit =
							    ((MAX_SCAN_LINE*)&new)->as_bfld.line_compare_bit_9;

							if( !get_split_screen_used() )
								flag_mode_change_required();

							screen_refresh_required();
						}
						crt_controller.maximum_scan_line.as.abyte = value;
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 0xa:
					note_entrance0("cursor start");
#ifdef V7VGA
					if (crtc_9_b_protect == FALSE)
					{
#endif /* V7VGA */
						new.value = value;
						if (crt_controller.cursor_start.as_bfld.cursor_off)
							set_cursor_visible(FALSE);
						else
							set_cursor_visible(TRUE);

						if (crt_controller.cursor_start.as_bfld.cursor_start !=
							((CURSOR_START*)&new)->as_bfld.cursor_start)
						{
							crt_controller.cursor_start.as.abyte = value;
						}

						do_new_cursor();
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 0xb:
					note_entrance0("cursor end");
#ifdef V7VGA
					if (crtc_9_b_protect == FALSE)
					{
#endif /* V7VGA */
						new.value = value;
						if (crt_controller.cursor_end.as_bfld.cursor_end !=
							((CURSOR_END*)&new)->as_bfld.cursor_end)
						{
							crt_controller.cursor_end.as.abyte = value;
							assert0(crt_controller.cursor_end.as_bfld.cursor_skew_control == 0,
									"Someone is trying to use cursor skew");
							do_new_cursor();
						}
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 0xc:
					note_entrance0("start address high");
#ifdef V7VGA
					if (crtc_c_protect == FALSE)
					{
#endif /* V7VGA */
						if (crt_controller.start_address_high != value)
						{
							set_screen_start((value << 8) + crt_controller.start_address_low);
							host_screen_address_changed(value, crt_controller.start_address_low);
							/* check if it wraps now */
#ifdef V7VGA
							if( !( get_seq_chain4_mode() || get_seq_chain_mode() ))
#endif /* V7VGA */
								if (get_chain4_mode() )
								{
									if( (get_screen_start()<<2)
												+ get_screen_length() > 4*EGA_PLANE_DISP_SIZE )
										choose_vga_display_mode();
								}
								else
									if ( get_memory_chained() )
									{
										if( (get_screen_start()<<1)
													+ get_screen_length() > 2*EGA_PLANE_DISP_SIZE )
											choose_vga_display_mode();
									}
									else
									{
										if( get_screen_start()
													+ get_screen_length() > EGA_PLANE_DISP_SIZE )
											choose_vga_display_mode();
									}
							screen_refresh_required();
						}
						crt_controller.start_address_high = value;
#ifdef V7VGA
					}
#endif /* V7VGA */
					break;
				case 0xd:
					note_entrance0("start address low");
					if (crt_controller.start_address_low != value)
					{
						set_screen_start((crt_controller.start_address_high << 8) + value);
						host_screen_address_changed(crt_controller.start_address_high, value);
						/* check if it wraps now */
#ifdef V7VGA
						if( !( get_seq_chain4_mode() || get_seq_chain_mode() ))
#endif /* V7VGA */
							if (get_chain4_mode() )
							{
								if( (get_screen_start()<<2)
											+ get_screen_length() > 4*EGA_PLANE_DISP_SIZE )
									choose_vga_display_mode();
							}
							else
								if ( get_memory_chained() )
								{
									if( (get_screen_start()<<1)
												+ get_screen_length() > 2*EGA_PLANE_DISP_SIZE )
										choose_vga_display_mode();
								}
								else
								{
									if( get_screen_start()
												+ get_screen_length() > EGA_PLANE_DISP_SIZE )
										choose_vga_display_mode();
								}
						screen_refresh_required();
					}
					crt_controller.start_address_low = value;
					break;
				case 0xe:
					note_entrance0("cursor loc high");
					if (crt_controller.cursor_location_high != value)
					{
						crt_controller.cursor_location_high = value;

						offset = (value<<8) | crt_controller.cursor_location_low;
						offset -= (SHORT)get_screen_start();

						set_cur_x(offset % crt_controller.horizontal_display_end);
						set_cur_y(offset / crt_controller.horizontal_display_end);

						do_new_cursor();

						if(!get_mode_change_required() && is_it_text())
							cursor_changed(get_cur_x(), get_cur_y());
					}
					break;
				case 0xf:
					note_entrance0("cursor loc lo");
					if (crt_controller.cursor_location_low != value)
					{
						crt_controller.cursor_location_low = value;

						offset = value | (crt_controller.cursor_location_high<<8);
						offset -= (SHORT)get_screen_start();

						set_cur_x(offset % crt_controller.horizontal_display_end);
						set_cur_y(offset / crt_controller.horizontal_display_end);

						do_new_cursor();

						if(!get_mode_change_required() && is_it_text())
							cursor_changed(get_cur_x(), get_cur_y());
					}
					break;
				case 0x10:
					note_entrance0("vert retrace start");
					crt_controller.vertical_retrace_start = value;
					break;
				case 0x11:
					note_entrance0("vert retrace end");
					crt_controller.vertical_retrace_end.as.abyte = value;
                                        if ((value & 32) == 32)
                                           ega_int_enable = 0;
                                        else
					{
                                           ega_int_enable = 1;
                                           input_status_register_zero.as_bfld.crt_interrupt = 1;        /* = !VS */
					}
                                        if ((value & 16) != 16)
                                        {
                                           ica_clear_int(AT_EGA_VTRACE_ADAPTER,AT_EGA_VTRACE_INT);
                                           /*
                                            * clear status latch
                                            */
                                           input_status_register_zero.as_bfld.crt_interrupt = 0;        /* = !VS */
                                        }
			/* ??? */
					if (crt_controller.vertical_retrace_end.as_bfld.crtc_protect)
						crtc_0_7_protect = TRUE;
					else
						crtc_0_7_protect = FALSE;
					break;
				case 0x12:
					note_entrance0("vert disp enable end");
					if (crt_controller.vertical_display_enable_end != value)
					{
						crt_controller.vertical_display_enable_end = value;
						set_screen_height_lo_recal(value);
						flag_mode_change_required();
					}
					break;
				case 0x13:
					note_entrance0("offset");
					if (crt_controller.offset != value)
					{
						crt_controller.offset = value;
						set_actual_offset_per_line(value<<1);	/* actual offset into plane in bytes */
						flag_mode_change_required();
					}
					break;
				case 0x14:
					note_entrance0("underline loc");
					crt_controller.underline_location.as.abyte = value;
					set_underline_start(crt_controller.underline_location.as_bfld.underline_location);
					if (crt_controller.underline_location.as_bfld.doubleword_mode) {
					    assert0(crt_controller.underline_location.as_bfld.count_by_4 == 1,"count by 4 not set in doubleword mode");
					    EGA_CPU.doubleword = TRUE;
					    set_doubleword_mode(YES);
					}
					else {
					    assert0(crt_controller.underline_location.as_bfld.count_by_4 == 0,"count by 4 set when doubleword clear");
					    EGA_CPU.doubleword = FALSE;
					    set_doubleword_mode(NO);
					}
					break;
				case 0x15:
					note_entrance0("start vert blank");
					crt_controller.start_vertical_blanking = value;
					break;
				case 0x16:
					note_entrance0("end vert blank");
					crt_controller.end_vertical_blanking = value;
					break;
				case 0x17:
					note_entrance0("mode control");
					new.value = value;
					if (crt_controller.mode_control.as_bfld.compatibility_mode_support !=
						((MODE_CONTROL*)&new)->as_bfld.compatibility_mode_support)
					{
						if ( (((MODE_CONTROL*)&new)->as_bfld.compatibility_mode_support) == 0)
							set_cga_mem_bank(YES);
						else	set_cga_mem_bank(NO);
						flag_mode_change_required();
					}
					if (crt_controller.mode_control.as_bfld.word_or_byte_mode !=
						((MODE_CONTROL*)&new)->as_bfld.word_or_byte_mode)
					{
						set_word_addressing_recal(
							(((MODE_CONTROL*)&new)->as_bfld.word_or_byte_mode) == 0 );
					}
#ifdef V7VGA
					if (crt_controller.mode_control.as_bfld.horizontal_retrace_select !=
						((MODE_CONTROL*)&new)->as_bfld.horizontal_retrace_select)
					{
						EGA_GRAPH.multiply_vert_by_two = ((MODE_CONTROL*)&new)->as_bfld.horizontal_retrace_select;
						flag_mode_change_required();
						screen_refresh_required();

					}
#endif
					crt_controller.mode_control.as.abyte = value;
					assert0(crt_controller.mode_control.as_bfld.select_row_scan_counter == 1,"Row scan 0");
					assert0(crt_controller.mode_control.as_bfld.horizontal_retrace_select == 0,
														"retrace select 1");
					assert0(crt_controller.mode_control.as_bfld.hardware_reset == 1,"hardware reset cleared");
					break;
				case 0x18:
					note_entrance0("line compare reg");
					if (crt_controller.line_compare != value)
					{
						crt_controller.line_compare = value;
						EGA_GRAPH.screen_split.as_bfld.low_byte = value;

						if( !get_split_screen_used() )
							flag_mode_change_required();

						screen_refresh_required();
					}
					break;
				default:
					assert1(NO,"Bad crtc index %d",crt_controller.address.as_bfld.index);
					break;
			}
			break;
		default:
			assert1(NO,"Bad port passed %x", port );
			break;
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_crtc_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance3("ega_crtc_inb(%x,%x) index %d", port, value, crt_controller.address.as_bfld.index);
	switch(crt_controller.address.as_bfld.index) {
		case	0:
			*value = crt_controller.horizontal_total;
			break;
		case	1:
			*value = crt_controller.horizontal_display_end - 1;
			break;
		case	2:
			*value = crt_controller.start_horizontal_blanking;
			break;
		case	3:
			*value =(half_word)crt_controller.end_horizontal_blanking.as.abyte;
			break;
		case	4:
			*value = crt_controller.start_horizontal_retrace;
			break;
		case	5:
			*value = (half_word)crt_controller.end_horizontal_retrace.as.abyte;
			break;
		case	6:
			*value = crt_controller.vertical_total;
			break;
		case	7:
			*value = (half_word)crt_controller.crtc_overflow.as.abyte;
			break;
		case	8:
			*value = (half_word)crt_controller.preset_row_scan.as.abyte;
			break;
		case	9:
			*value = (half_word)crt_controller.maximum_scan_line.as.abyte;
			break;
		case	0xa:
			*value = (half_word)crt_controller.cursor_start.as.abyte ;
			note_entrance1("cursor start %d",*value);
			break;
		case	0xb:
			*value = (half_word)crt_controller.cursor_end.as.abyte ;
			note_entrance1("cursor end %d",*value);
			break;
		case	0xc:
			*value = crt_controller.start_address_high ;
			note_entrance1("start address high %x",*value);
			break;
		case	0xd:
			*value = crt_controller.start_address_low ;
			note_entrance1("start address low %x",*value);
			break;
		case	0xe:
			*value = crt_controller.cursor_location_high ;
			note_entrance1("cursor location high %x",*value);
			break;
		case	0xf:
			*value = crt_controller.cursor_location_low ;
			note_entrance1("cursor location low %x",*value);
			break;
		case	0x10:
			*value = crt_controller.vertical_retrace_start;
			break;
		case	0x11:
			*value = crt_controller.vertical_retrace_end.as.abyte & ~0x20;
			break;
		case	0x12:
			*value = (half_word)crt_controller.vertical_display_enable_end;
			break;
		case	0x13:
			*value = crt_controller.offset;
			break;
		case	0x14:
			*value = (half_word)crt_controller.underline_location.as.abyte;
			break;
		case	0x15:
			*value = crt_controller.start_vertical_blanking;
			break;
		case	0x16:
			*value = crt_controller.end_vertical_blanking;
			break;
		case	0x17:
			*value = (half_word)crt_controller.mode_control.as.abyte;
			break;
		case	0x18:
			*value = crt_controller.line_compare;
			break;
#ifdef V7VGA
		case	0x1f:
			*value = crt_controller.start_address_high ^ 0xea;
			break;
		case	0x22:
			switch(graphics_controller.read_map_select.as_bfld.map_select)
			{
				case 0:
					*value = get_latch0;
					break;
				case 1:
					*value = get_latch1;
					break;
				case 2:
					*value = get_latch2;
					break;
				case 3:
					*value = get_latch3;
					break;
			}
			break;
		case 	0x24:
			*value = (half_word)attribute_controller.address.as.abyte;
			break;
#endif /* V7VGA */
		default:
			assert1(crt_controller.address.as_bfld.index>24,"inb from bad crtc index %d",crt_controller.address.as_bfld.index);
			*value = IO_EMPTY_PORT_BYTE_VALUE;
			break;
	}
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"RD crtc %#x = %#x\n",crt_controller.address.as_bfld.index,*value);)
#endif  //NEC_98
}


GLOBAL VOID	vga_gc_mode IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
MODE new_mode;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(5,%#x)\n",value);)
	note_entrance2("vga_gc_mode(%x,%x)", port, value);
	new_mode.as.abyte = value;
	if (graphics_controller.mode.as_bfld.write_mode != new_mode.as_bfld.write_mode)
	{
		/*
		 * write mode change
		 */

		EGA_CPU.write_mode = (unsigned char)new_mode.as_bfld.write_mode;
		setVideowrmode(EGA_CPU.write_mode);
		ega_write_routines_update(WRITE_MODE);
	}

	if (graphics_controller.mode.as_bfld.read_mode != new_mode.as_bfld.read_mode)
	{
		/*
		 * read mode change
		 */
		read_state.mode = new_mode.as_bfld.read_mode;
		ega_read_routines_update();
	}

	if (graphics_controller.mode.as_bfld.shift_register_mode != new_mode.as_bfld.shift_register_mode)
	{

	    switch(new_mode.as_bfld.shift_register_mode) {

	    case 0:		/* EGA mode */
		set_graph_shift_reg(NO);
		set_256_colour_mode(NO);
		set_horiz_total(crt_controller.horizontal_display_end);
		break;
	    case 1:		/* CGA med res mode */
		set_graph_shift_reg(YES);
		set_256_colour_mode(NO);
		set_horiz_total(crt_controller.horizontal_display_end);
		break;
	    case 2:		/* VGA 256 colour mode */
	    case 3:		/* Bottom bit ignored, if top bit set */
		set_graph_shift_reg(NO);
		set_256_colour_mode(YES);
		/* Need to halve horiz display end for 256 cols */
		set_horiz_total(crt_controller.horizontal_display_end>>1);
		flag_palette_change_required();
		break;
	    }
	    flag_mode_change_required();
	}

	graphics_controller.mode.as.abyte = new_mode.as.abyte;

	/*
	 * Check for any change to chained mode rule by having an election
	 * (Note: EGA registers must be updated before calling election)
	 */

	do_chain_majority_decision();
#endif  //NEC_98
}

/*
 * note: identical to ega routines, but needed in this module to ensure
 * correct struct set
 */

GLOBAL VOID	vga_gc_outb_index IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("vga_gc_outb_index(%x,%x)", port, value);
	value &= 0xf;
	graphics_controller.address.as.abyte = value;
	assert2(value<9,"Bad gc index %#x port %#x",value,port);

	io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_regs[value]);
	Cpu_define_outb(EGA_GC_ADAP_DATA,ega_gc_regs_cpu[value]);
#endif  //NEC_98
}


/*( vga_gc_outw
**	Most PC programs do an "OUT DX, AX" which sets up the GC index
**	register with the AL and the GC data register with AH.
**	Avoid going through generic_outw() by doing it all here!
**	See also: ega_gc_outw() in "ega_ports.c"
)*/
GLOBAL VOID vga_gc_outw IFN2(io_addr, port, word, outval)
{
#ifndef NEC_98
	reg		temp;
	INT		value;

	temp.X = outval;

	value = temp.byte.low & 0xf;
	graphics_controller.address.as.abyte = value;

	assert2(value<9,"Bad gc index %#x port %#x",value,port);

	io_redefine_outb(EGA_GC_ADAP_DATA,ega_gc_regs[value]);

	Cpu_define_outb(EGA_GC_ADAP_DATA,ega_gc_regs_cpu[value]);

	(*(ega_gc_regs[value]))((io_addr)(port+1), temp.byte.high);
#endif  //NEC_98
}


GLOBAL VOID	vga_gc_set_reset IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned set_reset;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(0,%x)\n",value);)
	note_entrance2("vga_gc_set_reset(%x,%x)", port, value);
	set_reset = graphics_controller.set_or_reset.as_bfld.set_or_reset;
	graphics_controller.set_or_reset.as.abyte = value;
	if (graphics_controller.set_or_reset.as_bfld.set_or_reset != set_reset)
	{
		EGA_CPU.set_reset = graphics_controller.set_or_reset.as_bfld.set_or_reset;
		ega_write_routines_update(SET_RESET);
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_enable_set IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned en_set_reset;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(1,%x)\n",value);)
	note_entrance2("vga_gc_enable_set(%x,%x)", port, value);
	en_set_reset = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset;
	graphics_controller.enable_set_or_reset.as.abyte = value;
	if (graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset != en_set_reset)
	{
		EGA_CPU.sr_enable = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset;
		write_state.sr = graphics_controller.enable_set_or_reset.as_bfld.enable_set_or_reset==0?0:1;
		setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
		ega_write_routines_update(ENABLE_SET_RESET);
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_compare IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned colour_compare;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(2,%x)\n",value);)
	note_entrance2("vga_gc_compare(%x,%x)", port, value);
	colour_compare = graphics_controller.color_compare.as_bfld.color_compare;
	graphics_controller.color_compare.as.abyte = value;
	if (graphics_controller.color_compare.as_bfld.color_compare != colour_compare)
	{
		read_state.colour_compare = (unsigned char)graphics_controller.color_compare.as_bfld.color_compare;
		if (read_state.mode == 1) ega_read_routines_update();
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_rotate IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
	struct {
		unsigned value : 8;
	} new;

	UNUSED(port);
	
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(3,%x)\n",value);)
	new.value = value;
	if (graphics_controller.data_rotate.as_bfld.rotate_count != ((DATA_ROTATE*)&new)->as_bfld.rotate_count )
	{
		setVideorotate(((DATA_ROTATE*)&new)->as_bfld.rotate_count);
		ega_write_routines_update(ROTATION);
	}
	if (graphics_controller.data_rotate.as_bfld.function_select != ((DATA_ROTATE*)&new)->as_bfld.function_select)
	{
		write_state.func = ((DATA_ROTATE*)&new)->as_bfld.function_select;
		setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
		ega_write_routines_update(FUNCTION);
	}
	EGA_CPU.fun_or_protection = (value != 0) || write_state.bp;
	graphics_controller.data_rotate.as.abyte = value;
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_read_map IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(4,%x)\n",value);)

	note_entrance2("vga_gc_read_map(%x,%x)", port, value);

	setVideoread_mapped_plane(value & 3);

	update_shift_count();
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_misc IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned memory_map;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(6,%x)\n",value);)
	note_entrance2("vga_gc_misc(%x,%x)", port, value);
	memory_map = graphics_controller.miscellaneous.as_bfld.memory_map;
	graphics_controller.miscellaneous.as.abyte = value;
	if (graphics_controller.miscellaneous.as_bfld.memory_map != memory_map)
	{
		/*
		 * Where EGA appears in PC memory space changed.
		*/
		
#ifndef GISP_SVGA
		if (miscellaneous_output_register.as_bfld.enable_ram)
			sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);
#endif		/* GISP_SVGA */

		switch (graphics_controller.miscellaneous.as_bfld.memory_map)
		{
			case 0:
				gvi_pc_low_regen = 0xA0000;
				gvi_pc_high_regen = 0xBFFFF;
				break;
			case 1:
				gvi_pc_low_regen = 0xA0000;
				gvi_pc_high_regen = 0xAFFFF;
				break;
			case 2:
				gvi_pc_low_regen = 0xB0000;
				gvi_pc_high_regen = 0xB7FFF;
				break;
			case 3:
				gvi_pc_low_regen = 0xB8000;
				gvi_pc_high_regen = 0xBFFFF;
				break;
		}

		if (miscellaneous_output_register.as_bfld.enable_ram)
			sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);

		/*
		 * Tell cpu associated modules that regen area has moved
		 */

		ega_read_routines_update();
		ega_write_routines_update(RAM_MOVED);
	}

	/* Decide alpha/graphics mode by voting. */
	vote_vga_mode();

	/*
	 * Check for any change to chained mode rule by having an election
	 * (Note: EGA registers must be updated before calling election)
	 */

	do_chain_majority_decision();
#endif  //NEC_98
}

GLOBAL VOID	vga_gc_dont_care IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
unsigned colour_dont_care;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(7,%x)\n",value);)
	note_entrance2("vga_gc_dont_care(%x,%x)", port, value);
	colour_dont_care = graphics_controller.color_dont_care.as_bfld.color_dont_care;
	graphics_controller.color_dont_care.as.abyte = value;
	if (graphics_controller.color_dont_care.as_bfld.color_dont_care != colour_dont_care)
	{
		read_state.colour_dont_care = (unsigned char)graphics_controller.color_dont_care.as_bfld.color_dont_care;
		if (read_state.mode == 1) ega_read_routines_update();
	}
#endif  //NEC_98
}




/*
 * The EGA mask register is written to more times than all other ports added together!
 * To help make this register fast, we have two different routines to handle it:
 * ega_gc_mask for when the register's current value is not 0xFF, ie. masking is active
 * ega_gc_mask_ff for when the mask register = 0xFF, so masking is disabled.
 */


/*(
** vga_mask_register_changed
**	This gets called whenever the mask register gets changed, and
**	updates the internals appropriately. Since the mask registers
**	are hit more than any other registers, this should do the job!
**
**	Rather than calling the monster ega_write_routines_update() (in "ega_write.c"),
**	we do as little as we possibly can here!
**	In particular, all we do is set the video write pointer handlers
**	to the appropriate one and update the internal EGA_CPU state...
**
**	We DON'T do anything about altering the marking funcs, etc.
**
**	See also "ega_mask_register_changed" in "ega_ports.c".
**
**  NB: GLOBAL for JOKER.
)*/
#include	"cpu_vid.h"
IMPORT void Glue_set_vid_wrt_ptrs(WRT_POINTERS * handler );

GLOBAL VOID vga_mask_register_changed IFN1(BOOL, gotBitProtection)
{
#ifndef NEC_98
	ULONG				state;
	SAVED IU8			masks[] = {0x1f, 0x01, 0x0f, 0x0f};
	IMPORT WRT_POINTERS	*mode_chain_handler_table[];
#ifdef V7VGA
	IMPORT	UTINY		Last_v7_fg_bg, fg_bg_control;
#endif


	write_state.bp = gotBitProtection;
	setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
	EGA_CPU.fun_or_protection = (gotBitProtection || (graphics_controller.data_rotate.as.abyte != 0));

	/* Check that we're not trying to handle any pathological cases here...
	** This means we chicken out for Chain2 and V7VGA dithering.
	*/

	if ((EGA_CPU.chain == CHAIN2)
#ifdef V7VGA
		|| ( Last_v7_fg_bg != fg_bg_control)
#endif /* V7VGA */
		)
	{
		ega_write_routines_update(BIT_PROT);

		return;
	}

	/* the "mode_0" union variant has the largest "lookup" field (5 bits.) */

	state = EGA_CPU.ega_state.mode_0.lookup & masks[EGA_CPU.write_mode];

#ifdef A3CPU
#ifdef C_VID
	Glue_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
#else
	Cpu_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);	
#endif /* C_VID */
#else
#if !(defined(NTVDM) && defined(X86GFX))
	Glue_set_vid_wrt_ptrs(&mode_chain_handler_table[EGA_CPU.saved_mode_chain][state]);
#endif /* !(NTVDM && X86GFX) */
#endif /* A3CPU */

	EGA_CPU.saved_state = state;
#endif  //NEC_98
}


/* this is the one that is usually called */
GLOBAL VOID	vga_gc_mask IFN2(USHORT,port,FAST UTINY,value)
{
#ifndef NEC_98
	FAST ULONG  mask;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(8,%x)\n",value);)
	note_entrance2("vga_gc_mask(%x,%x)", port, value);

	/*
	 * Update video routine according to new bit protection
	 */

	mask = value | (value << 8);
	mask |= (mask << 16);	/* replicate the mask into 4 bytes */
	setVideobit_prot_mask(mask);
	setVideodata_xor_mask(~(EGA_CPU.calc_data_xor & mask));
	setVideolatch_xor_mask(EGA_CPU.calc_latch_xor & mask);

	if(value == 0xff)
	{
#ifndef	USE_OLD_MASK_CODE
		vga_mask_register_changed(/*bit protection :=*/0);
#else
		write_state.bp = 0;
		setVideowrstate(EGA_CPU.ega_state.mode_0.lookup);
		EGA_CPU.fun_or_protection = (graphics_controller.data_rotate.as.abyte != 0);
		ega_write_routines_update(BIT_PROT);
#endif	/* USE_OLD_MASK_CODE */

		/* Alter the function table used by ega_gc_index */
		ega_gc_regs[8] = FAST_FUNC_ADDR(vga_gc_mask_ff);

#ifndef CPU_40_STYLE	/* TEMPORARY */
#ifndef A2CPU
		/* Alter the function table used by assembler ega_gc_index */
		ega_gc_regs_cpu[8] = FAST_FUNC_ADDR(_ega_gc_outb_mask_ff);
#endif
#endif

		io_redefine_outb(EGA_GC_ADAP_DATA,vga_gc_mask_ff);

#ifndef CPU_40_STYLE	/* TEMPORARY */
		Cpu_define_outb(EGA_GC_ADAP_DATA,_ega_gc_outb_mask_ff);
#endif
	}
#endif  //NEC_98
}

/* This version isn't called so often */
GLOBAL VOID	vga_gc_mask_ff IFN2(USHORT,port,FAST UTINY,value)
{
#ifndef NEC_98
	FAST ULONG mask;

#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"gc(8,%x)\n",value);)
	note_entrance2("vga_gc_mask(%x,%x)", port, value);

	/*
	 * Update video routine according to new bit protection
	 */

	if(value != 0xff)
	{
		mask = value | (value << 8);
		mask |= (mask << 16);	/* replicate the mask into 4 bytes */
		setVideobit_prot_mask(mask);
		setVideodata_xor_mask(~(EGA_CPU.calc_data_xor & mask));
		setVideolatch_xor_mask(EGA_CPU.calc_latch_xor & mask);

#ifndef	USE_OLD_MASK_CODE
		vga_mask_register_changed(/*bit protection :=*/1);
#else
		write_state.bp = 1;
		setVideowrstate(EGA_CPU.ega_state.mode_0.lookup);
		EGA_CPU.fun_or_protection = TRUE;
		ega_write_routines_update(BIT_PROT);
#endif	/* USE_OLD_MASK_CODE*/

		/* Alter the function table used by ega_gc_index */
		ega_gc_regs[8] = FAST_FUNC_ADDR(vga_gc_mask);

#ifndef CPU_40_STYLE	/* TEMPORARY */
#ifndef A2CPU
		/* Alter the function table used by assembler ega_gc_index */
		ega_gc_regs_cpu[8] = FAST_FUNC_ADDR(_ega_gc_outb_mask);
#endif
#endif

		io_redefine_outb(EGA_GC_ADAP_DATA,vga_gc_mask);

#ifndef CPU_40_STYLE	/* TEMPORARY */
		Cpu_define_outb(EGA_GC_ADAP_DATA,_ega_gc_outb_mask);
#endif
	}
#endif  //NEC_98
}
/* end of 'same as EGA' gc routines */

/*
 * copy of ega routine to place in correct module to update static struct.
 */
GLOBAL VOID	vga_seq_map_mask IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"seq(2,%x)\n",value);)
	note_entrance2("vga_seq_map_mask(%x,%x)", port, value);

	/* map mask register */
	/*
	 * Different display plane(s) have been enabled. Update the video
	 * routines to deal with this
	 */

	value &= 0xf;			/* 4 planes ==> lower 4 bits valid */

	setVideoplane_enable(value);
	setVideoplane_enable_mask(sr_lookup[value]);
	write_state.pe = (value == 0xf);				/* 1 or 0 */
	setVideowrstate((IU8)EGA_CPU.ega_state.mode_0.lookup);
	ega_write_routines_update(PLANES_ENABLED);
#endif  //NEC_98
}
/* end of 'same as EGA' seq routines */

/*
 * copy of ega routine to place in correct module to update static struct.
 */

SAVED TINY vga_ip0_state = 0;	/* current ega status state */
SAVED TINY vga_ip0_state_count = 1;     /* position in that state */

GLOBAL VOID	v_ret_intr_status IFN0()
{
#ifndef NEC_98
    vga_ip0_state = 3;
    vga_ip0_state_count = 6;
#endif  //NEC_98
}


/*
	The following routine should not return a value with top bit set
	until we emulate a Rev4 Video7 card.
*/

/*
 * Some programs synchronise with the display by waiting for the
 * next vertical retrace.
 *
 * We attempt to follow the following waveform:
 *          _____                                               _____
 * VS _____|     |_____________________________________________|     |___
 *       ____________     _     _               _     _     _____________
 * DE __|            |___| |___| |_  .......  _| |___| |___|             |_
 *
 * State   |  3  | 0 |            1                        | 2 |
 *
 */

#if defined(NTVDM) || defined(host_get_time_ms) || defined(host_get_count_ms)

 /*
  * end of periods for each state
  * Units are 100 usec (0.1 ms) to match GetPerfCounter() resolution
  * Total period is based on 70 Hz for NTVDM and 50Hz otherwise
  */
#ifdef NTVDM
#define IPSTAT1_STATE_0    	(25)
#define IPSTAT1_STATE_1     	(IPSTAT1_STATE_0 + 75)
#define IPSTAT1_STATE_2     	(IPSTAT1_STATE_1 + 25)
#define IPSTAT1_STATE_3     	(IPSTAT1_STATE_2 + 10)
#define IPSTAT1_CYCLE_TIME  	IPSTAT1_STATE_3
#else	/* NTVDM */
#define IPSTAT1_STATE_0		(4)			/* End of state 0, ms */
#define IPSTAT1_STATE_1		(IPSTAT1_STATE_0 + 9)	/* End of state 1, ms */
#define IPSTAT1_STATE_2		(IPSTAT1_STATE_1 + 4)	/* End of state 2, ms */
#define IPSTAT1_STATE_3		(IPSTAT1_STATE_2 + 3)	/* End of state 3, ms */
#define IPSTAT1_CYCLE_TIME	IPSTAT1_STATE_3		/* Cycle time, ms */
#endif	/* NTVDM */

GLOBAL VOID  vga_ipstat1_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
   IMPORT ULONG GetPerfCounter(void);
   SAVED ULONG RefreshStartTime=0;
   ULONG cycles;
   ULONG CurrTime;


#if defined(X86GFX)
/* Silly programs (especially editors) that are concerned that they might
 * be running on CGA's will read this port like crazy before each screen
 * access. This frig catches the common case:
 *     in
 *     test al,80
 *     j{e,ne} back to the in
 * and moves IP to beyond the test. So far this hasn't broken anything(!!)
 * but has made good speedups in a variety of apps.
 */
   sys_addr off;
   word cs, ip;
   ULONG dwat;
   IMPORT word getCS(), getIP();
#endif

#ifdef PROD
	UNUSED(port);
#endif

#ifdef X86GFX
    cs = getCS();
    ip = getIP();
    off = (cs << 4) + ip;
    dwat = sas_dw_at(off);
    if (dwat == 0xfb7401a8 || dwat == 0xfb7501a8)
    {
	ip += 4;
	setIP(ip);
	*value = 5;	/* anything really */
    	return;
    }
#endif

    note_entrance2("vga_ipstat1_inb(%x,%x)", port, value);

#ifdef V7VGA
	attribute_controller.address.as_bfld.index_state = 0;
#else
    set_index_state();	/* Initialize the Attribute register flip-flop (EGA tech ref, p 56) */
#endif /* V7VGA */

#if defined(NTVDM) || defined(host_get_count_ms)

#ifdef NTVDM
   CurrTime = GetPerfCounter();
#else
   CurrTime = host_get_count_ms();
#endif

   cycles = CurrTime >= RefreshStartTime
               ? CurrTime - RefreshStartTime
               : 0xFFFFFFFF - RefreshStartTime + CurrTime;

        /*  If app hasn't checked the status for a long time (for at least
         *  one Display Refresh Cycle). start the app at end of state 0.
         */
   if (cycles > IPSTAT1_CYCLE_TIME) {
       RefreshStartTime = CurrTime;
       cycles = 0;
   }

#else 	/* host_get_time_ms */

    cycles = host_get_time_ms() % IPSTAT1_CYCLE_TIME;

#endif	/* host_get_time_ms */

   if (cycles < IPSTAT1_STATE_0)
   {
       *value = 0x05;
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
   }
   else if (cycles < IPSTAT1_STATE_1)
   {
       *value = 0x04;
       if (((cycles - IPSTAT1_STATE_0) % 3) == 0)
           *value |= 0x01;
       input_status_register_zero.as_bfld.crt_interrupt = 0;   /* = !VS */
   }
   else if (cycles < IPSTAT1_STATE_2)
   {
	*value = 0x05;
       input_status_register_zero.as_bfld.crt_interrupt = 0;   /* = !VS */
   }
   else /* IPSTAT1_STATE_3 */
   {
       *value = 0x0d;
       input_status_register_zero.as_bfld.crt_interrupt = 1;   /* = VS */
   }
#endif  //NEC_98
}

#else   /* !(NTVDM || host_get_time_ms || host_get_count_ms) */

GLOBAL VOID	vga_ipstat1_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98

	/*
	 * The whole of this routine has been nicked from the cga without modification
	 * The s_lengths array should probably be altered for the ega timings, and somewhere
	 * an interrupt should be fired off.
	 */

	SAVED TINY sub_state = 0;	/* sub state for ega state 2 */

     SAVED ULONG gmfudge = 17; /* Random number seed for pseudo-random
						bitstream generator to give the state
						lengths below that 'genuine' feel to
						progs that require it! */
     FAST ULONG h;

    /*
     * relative 'lengths' of each state. State 2 is *3 as it has 3 sub states
     */

	SAVED TINY s_lengths[] = { 8, 18, 8, 6 };


#ifdef PROD
	UNUSED(port);
#endif
    note_entrance2("vga_ipstat1_inb(%x,%x)", port, value);

#ifdef V7VGA
	attribute_controller.address.as_bfld.index_state = 0;
#else
    set_index_state();	/* Initialize the Attribute register flip-flop (EGA tech ref, p 56) */
#endif /* V7VGA */

    vga_ip0_state_count --;	/* attempt relative 'timings' */
    switch (vga_ip0_state) {

    case 0:
	if (vga_ip0_state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    vga_ip0_state_count = s_lengths[1] + (gmfudge & 3);
	    vga_ip0_state = 1;
	}
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
	*value = 0x05;
	break;

    case 1:
	if (vga_ip0_state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    vga_ip0_state_count = s_lengths[2] + (gmfudge & 3);
	    vga_ip0_state = 2;
	    sub_state = 2;
	}
	switch (sub_state) {	/* cycle through 0,0,1 sequence */
	case 0:		/* to represent DE toggling */
	    *value = 0x04;
	    sub_state = 1;
	    break;
	case 1:
	    *value = 0x04;
	    sub_state = 2;
	    break;
	case 2:
	    *value = 0x05;
	    sub_state = 0;
	    break;
        }
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
	break;

    case 2:
	if (vga_ip0_state_count == 0) {	/* change to next state ? */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    vga_ip0_state_count = s_lengths[3] + (gmfudge & 3);
	    vga_ip0_state = 3;
	}
	*value = 0x05;
	input_status_register_zero.as_bfld.crt_interrupt = 0;	/* = !VS */
	break;

    case 3:
	if (vga_ip0_state_count == 0) {	/* wrap back to first state */
            h = gmfudge << 1;
            gmfudge = (h&0x80000000) ^ (gmfudge & 0x80000000)? h|1 : h;
	    vga_ip0_state_count = s_lengths[0] + (gmfudge & 3);
	    vga_ip0_state = 0;
	}
	input_status_register_zero.as_bfld.crt_interrupt = 1;	/* = !VS */
	*value = 0x0d;
	break;
    }
    note_entrance1("returning %x",*value);
#endif  //NEC_98
}

#endif /* !(NTVDM || host_get_time_ms || host_get_count_ms) */

GLOBAL VOID	vga_gc_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
	note_entrance1("vga_gc_inb(%x)", port);
	if (port == EGA_GC_INDEX) {
	    *value = (half_word)graphics_controller.address.as.abyte;
	    note_entrance1("returning %x",*value);
	    return;
	}
	if (port == EGA_GC_DATA) {
	    switch(graphics_controller.address.as.abyte) {

	    case 0:
		*value = (half_word)graphics_controller.set_or_reset.as.abyte;
		break;
	    case 1:
		*value = (half_word)graphics_controller.enable_set_or_reset.as.abyte;
		break;
	    case 2:
		*value = (half_word)graphics_controller.color_compare.as.abyte;
		break;
	    case 3:
		*value = (half_word)graphics_controller.data_rotate.as.abyte;
		break;
	    case 4:
		*value = (half_word)getVideoread_mapped_plane();
		break;
	    case 5:
		*value = (half_word)graphics_controller.mode.as.abyte;
		break;
	    case 6:
		*value = (half_word)graphics_controller.miscellaneous.as.abyte;
		break;
	    case 7:
		*value = (half_word)graphics_controller.color_dont_care.as.abyte;
		break;
	    case 8:
		*value = (half_word)getVideobit_prot_mask() & 0xff;
		break;
	    default:
		assert1(NO,"Bad gc index %d",graphics_controller.address.as.abyte);
		*value = IO_EMPTY_PORT_BYTE_VALUE;
	    }
	    note_entrance1("returning %x",*value);
	}
	else {
	    assert1(NO,"Bad gc port %d",port);
	    *value = IO_EMPTY_PORT_BYTE_VALUE;
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_ac_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
	struct {
		unsigned value : 8;
	} new;

#ifdef PROD
	UNUSED(port);
#endif

	note_entrance2("vga_ac_outb(%x,%x)", port, value);
	assert1( port == EGA_AC_INDEX_DATA, "Bad port %x", port);
	new.value = value;
#ifdef V7VGA
	attribute_controller.address.as_bfld.index_state = !attribute_controller.address.as_bfld.index_state;
	if (attribute_controller.address.as_bfld.index_state) {
#else
	if ( in_index_state() ) {
#endif /* V7VGA */
		note_entrance1("Setting index to %d", value);
		if ((unsigned)(((value & 0x20) >> 5)) != attribute_controller.address.as_bfld.palette_address_source)
		{
			if (value & 0x20)
			{
				set_display_disabled(FALSE);
				timer_video_enabled = 1;
				enable_gfx_update_routines();
				screen_refresh_required();
			}
			else
			{
				/*
				 * not strictly accurate, since we are meant to fill the screen with
				 * the current overscan colour. However that is normally black so this
				 * will do.
				 */
				set_display_disabled(TRUE);
				timer_video_enabled = 0;
				disable_gfx_update_routines();
			}
		}
#ifdef V7VGA
		attribute_controller.address.as.abyte = (attribute_controller.address.as_bfld.index_state << 7) | (value & 0x3f);
#else
		attribute_controller.address.as.abyte = value;
#endif /* V7VGA */
	} else {
		NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"attr(%#x,%#x)\n",attribute_controller.address.as_bfld.index,value);)
		switch (attribute_controller.address.as_bfld.index) {
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 0xa:
		case 0xb:
		case 0xc:
		case 0xd:
		case 0xe:
		case 0xf:
			note_entrance1("Change palette %d",attribute_controller.address.as_bfld.index);
			attribute_controller.palette[attribute_controller.address.as_bfld.index].as.abyte = value;
			set_palette_val(attribute_controller.address.as_bfld.index, value);

			flag_palette_change_required();
			break;
		case 0x10:
			note_entrance0("mode control reg");
			if (attribute_controller.mode_control.as_bfld.background_intensity_or_blink !=
				((AC_MODE_CONTROL*)&new)->as_bfld.background_intensity_or_blink)
			{
				set_intensity( ((AC_MODE_CONTROL*)&new)->as_bfld.background_intensity_or_blink );
			}
			if (attribute_controller.mode_control.as_bfld.select_video_bits !=
				((AC_MODE_CONTROL*)&new)->as_bfld.select_video_bits)
			{
				set_colour_select(((AC_MODE_CONTROL*)&new)->as_bfld.select_video_bits);
				flag_palette_change_required();
			}
			attribute_controller.mode_control.as.abyte = value;

     			if (attribute_controller.mode_control.as_bfld.background_intensity_or_blink)
				/* blinking - not supported */
				bg_col_mask = 0x70;
			else
				/* using blink bit to provide 16 background colours */
				bg_col_mask = 0xf0;

			/* Vote on alpha/graphics mode */
        		vote_vga_mode();
			assert0(attribute_controller.mode_control.as_bfld.display_type == 0, "Mono display selected");
			assert0(attribute_controller.mode_control.as_bfld.enable_line_graphics_char_codes == 0,
											"line graphics enabled");
			break;
		case 0x11:
			note_entrance0("set border");
			attribute_controller.overscan_color.as.abyte = value;
			EGA_GRAPH.border[RED] = get_border_color(red_border,secondary_red_border);
			EGA_GRAPH.border[GREEN] = get_border_color(green_border,secondary_green_border);
			EGA_GRAPH.border[BLUE] = get_border_color(blue_border,secondary_blue_border);
			host_set_border_colour(value);
			break;
		case 0x12:
			note_entrance1("color plane enable %x",value);
			if ( attribute_controller.color_plane_enable.as_bfld.color_plane_enable !=
					((COLOR_PLANE_ENABLE*)&new)->as_bfld.color_plane_enable ) {
				set_plane_mask(((COLOR_PLANE_ENABLE*)&new)->as_bfld.color_plane_enable);
				host_change_plane_mask(get_plane_mask());	/* Update Host palette */
			}
			attribute_controller.color_plane_enable.as.abyte = value;
			break;
		case 0x13:
			note_entrance0("horiz pel panning");
			attribute_controller.horizontal_pel_panning.as.abyte = value;
			break;
		case 0x14:
			note_entrance0("pixel padding register");
			if (attribute_controller.pixel_padding.as_bfld.color_top_bits !=
				((PIXEL_PAD*)&new)->as_bfld.color_top_bits)
			{
				set_top_pixel_pad(((PIXEL_PAD*)&new)->as_bfld.color_top_bits);
				flag_palette_change_required();
			}
			if (attribute_controller.pixel_padding.as_bfld.color_mid_bits !=
				((PIXEL_PAD*)&new)->as_bfld.color_mid_bits)
			{
				set_mid_pixel_pad(((PIXEL_PAD*)&new)->as_bfld.color_mid_bits);
				flag_palette_change_required();
			}
			attribute_controller.pixel_padding.as.abyte = value;
			break;
		default:
			assert1(NO,"Bad ac index %d", attribute_controller.address.as_bfld.index);
			break;
		}
	}
#endif  //NEC_98
}

GLOBAL VOID	vga_ac_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
    note_entrance1("vga_ac_inb(%x)", port);
    if (port == EGA_AC_INDEX_DATA) {	/* 3c0 */
	*value = (half_word)attribute_controller.address.as.abyte;
	note_entrance1("returning %x",*value);
	return;
    }
    if (port == EGA_AC_SECRET) {	/* 3c1 */
	switch (attribute_controller.address.as_bfld.index) {
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 0xa:
	case 0xb:
	case 0xc:
	case 0xd:
	case 0xe:
	case 0xf:
		*value = (half_word)attribute_controller.palette[attribute_controller.address.as_bfld.index].as.abyte;
		break;
	case 0x10:
		*value = (half_word)attribute_controller.mode_control.as.abyte;
		break;
	case 0x11:
		*value = (half_word)attribute_controller.overscan_color.as.abyte;
		break;
	case 0x12:
		*value = (half_word)attribute_controller.color_plane_enable.as.abyte;
		break;
	case 0x13:
		*value = (half_word)attribute_controller.horizontal_pel_panning.as.abyte;
		break;
	case 0x14:
		*value = (half_word)attribute_controller.pixel_padding.as.abyte;
		break;
	}
	note_entrance1("returning %x",*value);
    }
    else {
        assert1(NO,"Bad ac port %d",port);
        *value = IO_EMPTY_PORT_BYTE_VALUE;
    }
#endif  //NEC_98
}
	
GLOBAL VOID	vga_misc_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
MISC_OUTPUT_REG new;

#ifdef PROD
	UNUSED(port);
#endif

	NON_PROD(if(io_verbose & EGA_PORTS_VERBOSE)fprintf(trace_file,"misc %#x\n",value);)

	note_entrance2("vga_misc_outb(%x,%x)", port, value);

	assert1(port==EGA_MISC_REG,"Bad port %x",port);
	new.as.abyte = value;

	if (miscellaneous_output_register.as_bfld.enable_ram != new.as_bfld.enable_ram)
	{
		/*
		 * writes to plane memory en/disabled
		 */

		note_entrance0("Ram enabled");

#ifndef GISP_SVGA
		if(new.as_bfld.enable_ram)
			sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
		else
			sas_disconnect_memory(gvi_pc_low_regen,gvi_pc_high_regen);
#endif		/* GISP_SVGA */
		EGA_CPU.ram_enabled = new.as_bfld.enable_ram;
		ega_read_routines_update();
		ega_write_routines_update(RAM_ENABLED);
	}

	miscellaneous_output_register.as.abyte = new.as.abyte;

	update_banking();
#endif  //NEC_98
}

GLOBAL VOID	vga_misc_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	assert1(port==VGA_MISC_READ_REG,"Bad port %x",port);
	*value = (half_word)miscellaneous_output_register.as.abyte;
#endif  //NEC_98
}

GLOBAL VOID	vga_ipstat0_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance1("vga_ipstat0_inb(%x)", port);
	*value = (half_word)input_status_register_zero.as.abyte;
	note_entrance1("returning %x",*value);
#endif  //NEC_98
}

GLOBAL VOID	vga_feat_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance2("ega_feat_outb(%x,%x)", port, value);
	feature_control_register.as.abyte = value;
#endif  //NEC_98
}

GLOBAL VOID	vga_feat_inb IFN2(io_addr,port,half_word *, value)
{
#ifndef NEC_98
	UNUSED(port);
	*value = (half_word)feature_control_register.as.abyte;
#endif  //NEC_98
}

GLOBAL VOID	vga_dac_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
    note_entrance1("vga_dac_outb %#x",port);
    switch(port) {

    case VGA_DAC_MASK:
	if (get_DAC_mask() != value) {
	    set_DAC_mask(value);
	    flag_palette_change_required();
	}
	break;

    case VGA_DAC_RADDR:
	DAC_rd_addr = value;
	DAC_state = 3;		/* show 3c7 status read in read mode */
	assert0(DAC_rgb_state == DAC_RED, "DAC rd addr change when state not RED");
	DAC_rgb_state = DAC_RED;
	break;

    case VGA_DAC_WADDR:
	DAC_wr_addr = value;
	DAC_state = 0;		/* show 3c7 status read in write mode */
	assert0(DAC_rgb_state == DAC_RED, "DAC wr addr change when state not RED");
	DAC_rgb_state = DAC_RED;
	break;

    default:
	assert1(NO,"Bad DAC port %d",port);
    }
#endif  //NEC_98
}

/*
 * as this poor little port is hammered, we split it off from it's DAC siblings
 * for (hoped) efficiency.
 */
GLOBAL VOID	vga_dac_data_outb IFN2(io_addr,port,half_word,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif

    note_entrance1("vga_dac_data_outb %#x",port);
    switch(DAC_rgb_state) {

    case DAC_RED:
	DAC[DAC_wr_addr].red = value & DAC_data_mask;
	DAC_rgb_state = DAC_GREEN;
	break;

    case DAC_GREEN:
	DAC[DAC_wr_addr].green = value & DAC_data_mask;
	DAC_rgb_state = DAC_BLUE;
	break;

    case DAC_BLUE:
	DAC[DAC_wr_addr].blue = value & DAC_data_mask;
	DAC_rgb_state = DAC_RED;
	/*
	 * very important side affect - many progs dont touch the DAC
	 * index reg after setting it to the start of a group.
	 */
	DAC_wr_addr++;
	break;

    default:
	assert1(NO,"unknown DAC state %d",DAC_rgb_state);
    }

    flag_palette_change_required();
#endif  //NEC_98
}

GLOBAL VOID	vga_dac_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
    note_entrance1("vga_dac_inb %#x",port);
    switch(port) {

    case VGA_DAC_MASK:
	*value = get_DAC_mask();
	break;

    case VGA_DAC_RADDR:
	*value= DAC_state;	/* either 0 - write mode or 3 - read mode */
	break;

    case VGA_DAC_WADDR:
	*value = DAC_wr_addr;
	break;

    default:
	assert1(NO,"Bad DAC port read %d",port);
    }
    note_entrance1("returning %#x",*value);
#endif  //NEC_98
}

GLOBAL VOID	vga_dac_data_inb IFN2(io_addr,port,half_word *,value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	note_entrance1("vga_dac_data_inb %#x",port);
    switch(DAC_rgb_state) {

    case DAC_RED:
	    *value = DAC[DAC_rd_addr].red;
	    DAC_rgb_state = DAC_GREEN;
	    break;

    case DAC_GREEN:
	    *value = DAC[DAC_rd_addr].green;
	    DAC_rgb_state = DAC_BLUE;
	    break;

    case DAC_BLUE:
	    *value = DAC[DAC_rd_addr].blue;
	    DAC_rgb_state = DAC_RED;
	    /* NB important side affect of 3rd read */
	    DAC_rd_addr++;
	    break;

    default:
	    assert1(NO,"bad DAC state %d",DAC_rgb_state);
    }
    note_entrance1("returning %#x",*value);
#endif  //NEC_98
}

#if defined(NTVDM) && defined(X86GFX)
/*
 * There is no way of obtaining the DAC read address via a port access
 * (that we know of). Thus save/restore stuff etc needs this interface.
 */
half_word get_vga_DAC_rd_addr()
{
    return DAC_rd_addr;
}
#endif	/* NTVDM & X86GFX */

VOID    vote_vga_mode IFN0()
{
#ifndef NEC_98
        int     votes;

        votes = graphics_controller.miscellaneous.as_bfld.graphics_mode;
        votes += attribute_controller.mode_control.as_bfld.graphics_mode;
        switch(votes) {
        case 0:
                if (!is_it_text())
                {
                        /* switch to text mode */
                        set_text_mode(YES);
                        flag_mode_change_required();
                }
                break;

        case 2:
                if (is_it_text())
                {
                        /* switch to graphics mode */
                        set_text_mode(NO);
                        flag_mode_change_required();
                }
                break;

        case 1:
                if (graphics_controller.miscellaneous.as_bfld.graphics_mode)
                {
                        if (is_it_text())
                        {
                                assert0(NO,"Forcing mode to be graphics cos graphics controller sez so");
                                set_text_mode(NO);
                                flag_mode_change_required();
                        }
                }
                else
                {
                        if (!is_it_text())
                        {
                                assert0(NO,"Forcing mode to be alpha cos graphics controller sez so");
                                set_text_mode(YES);
                                flag_mode_change_required();
                        }
                }
                break;

        default:
                assert1(NO,"Wierd vote result %d in vote_vga_mode",votes);
        }
#endif //NEC_98
}       /* vote_vga_mode */

#ifdef GISP_SVGA
/*(
 *	function	:	mapRealIOPorts( )
 *
 *	purpose		:	mapping of real io functions for HW
 *				vga on ccpu
 *
 *	inputs		:	none
 *	outputs		:	none
 *	returns		:	void
 *	globals		:	none
 *	
 *	
)*/

void
mapRealIOPorts IFN0( )
{
#ifndef NEC_98
	always_trace0("mapping vga ports to _real_ IN/OUT");
	/*
	 * Define sequencer's ports
	 */

	io_define_outb(EGA_SEQ_ADAP_INDEX, hostRealOUTB );
	io_define_outb(EGA_SEQ_ADAP_DATA, hostRealOUTB );
        io_define_inb(EGA_SEQ_ADAP_INDEX, hostRealINB );
        io_define_inb(EGA_SEQ_ADAP_DATA, hostRealINB );

	/*
	 * Define CRTC's ports
	 */

	io_define_outb(EGA_CRTC_ADAPTOR, hostRealOUTB );
	io_define_inb(EGA_CRTC_ADAPTOR, hostRealINB );

	/*
	 * Define Graphics Controller's ports
	 */

	io_define_outb(EGA_GC_ADAP_INDEX, hostRealOUTB );
	Cpu_define_outb(EGA_GC_ADAP_INDEX, NULL );

	io_define_outb(EGA_GC_ADAP_DATA, hostRealOUTB );
	Cpu_define_outb(EGA_GC_ADAP_DATA,NULL);

	io_define_inb(EGA_GC_ADAP_INDEX, hostRealINB );
	io_define_inb(EGA_GC_ADAP_DATA, hostRealINB );

	/*
	 * Define Attribute controller's ports
	 */

	io_define_outb(EGA_AC_ADAPTOR, hostRealOUTB );
	io_define_inb(EGA_AC_ADAPTOR, hostRealINB );

	/*
	 * Define Miscellaneous register's port
	 */

	io_define_outb(EGA_MISC_ADAPTOR, hostRealOUTB );
	io_define_inb(EGA_MISC_ADAPTOR, hostRealINB );

	/*
	 * Define Feature controller's port
	 */

	io_define_outb(EGA_FEAT_ADAPTOR, hostRealOUTB );
	io_define_inb(EGA_FEAT_ADAPTOR, hostRealINB );

	/*
	 * Define Input Status Register 0 port
	 */

	io_define_inb(EGA_IPSTAT0_ADAPTOR, hostRealINB );

	/*
	 * Define Input Status Register 1 port
	 */

	io_define_inb(EGA_IPSTAT1_ADAPTOR, hostRealINB );

        /*
         * Define VGA DAC register port
         */
        io_define_inb(VGA_DAC_INDEX_PORT, hostRealINB );
        io_define_outb(VGA_DAC_INDEX_PORT, hostRealOUTB );
        io_define_inb(VGA_DAC_DATA_PORT, hostRealINB );
        io_define_outb(VGA_DAC_DATA_PORT, hostRealOUTB );

#endif //NEC_98
}


/*(
 *	function	:	mapEmulatedIOPorts( )
 *
 *	purpose		:	mapping of emulated io functions for HW
 *				vga on ccpu
 *
 *	inputs		:	none
 *	outputs		:	none
 *	returns		:	void
 *	globals		:	none
 *	
 *	
)*/

void
mapEmulatedIOPorts IFN0( )
{
#ifndef NEC_98
	always_trace0( "Mapping vga ports to Emulation" );

	/*
	 * Define sequencer's ports
	 */

	io_define_outb(EGA_SEQ_ADAP_INDEX,vga_seq_outb_index);
	io_define_outb(EGA_SEQ_ADAP_DATA,ega_seq_reset);
        io_define_inb(EGA_SEQ_ADAP_INDEX,vga_seq_inb);
        io_define_inb(EGA_SEQ_ADAP_DATA,vga_seq_inb);
	io_connect_port(EGA_SEQ_INDEX,EGA_SEQ_ADAP_INDEX,IO_READ_WRITE);
	io_connect_port(EGA_SEQ_DATA,EGA_SEQ_ADAP_DATA,IO_READ_WRITE);

	/*
	 * Define CRTC's ports
	 */

	io_define_outb(EGA_CRTC_ADAPTOR,vga_crtc_outb);
	io_define_inb(EGA_CRTC_ADAPTOR,vga_crtc_inb);
	io_connect_port(EGA_CRTC_INDEX,EGA_CRTC_ADAPTOR,IO_READ_WRITE);
	io_connect_port(EGA_CRTC_DATA,EGA_CRTC_ADAPTOR,IO_READ_WRITE);

	/*
	 * Define Graphics Controller's ports
	 */

	vga_gc_outb_index_addr = (UTINY *) &graphics_controller.address;

	io_define_outb(EGA_GC_ADAP_INDEX,vga_gc_outb_index);
	Cpu_define_outb(EGA_GC_ADAP_INDEX,_vga_gc_outb_index);

	io_define_outb(EGA_GC_ADAP_DATA,ega_gc_set_reset);
	Cpu_define_outb(EGA_GC_ADAP_DATA,NULL);

	io_define_inb(EGA_GC_ADAP_INDEX,vga_gc_inb);
	io_define_inb(EGA_GC_ADAP_DATA,vga_gc_inb);

	io_connect_port(EGA_GC_INDEX,EGA_GC_ADAP_INDEX,IO_READ_WRITE);
	io_connect_port(EGA_GC_DATA,EGA_GC_ADAP_DATA,IO_READ_WRITE);

	/*
	 * Define Attribute controller's ports
	 */

	io_define_outb(EGA_AC_ADAPTOR,vga_ac_outb);
	io_define_inb(EGA_AC_ADAPTOR,vga_ac_inb);
	io_connect_port(EGA_AC_INDEX_DATA,EGA_AC_ADAPTOR,IO_READ_WRITE);
	io_connect_port(EGA_AC_SECRET,EGA_AC_ADAPTOR,IO_READ);

	/*
	 * Define Miscellaneous register's port
	 */

	io_define_outb(EGA_MISC_ADAPTOR,vga_misc_outb);
	io_define_inb(EGA_MISC_ADAPTOR,vga_misc_inb);
	io_connect_port(EGA_MISC_REG,EGA_MISC_ADAPTOR,IO_WRITE);
	io_connect_port(VGA_MISC_READ_REG,EGA_MISC_ADAPTOR,IO_READ);

	/*
	 * Define Feature controller's port
	 */

	io_define_outb(EGA_FEAT_ADAPTOR,vga_feat_outb);
	io_define_inb(EGA_FEAT_ADAPTOR,vga_feat_inb);
	io_connect_port(EGA_FEAT_REG,EGA_FEAT_ADAPTOR,IO_WRITE);
	io_connect_port(VGA_FEAT_READ_REG,EGA_FEAT_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 0 port
	 */

	io_define_inb(EGA_IPSTAT0_ADAPTOR,vga_ipstat0_inb);
	io_connect_port(EGA_IPSTAT0_REG,EGA_IPSTAT0_ADAPTOR,IO_READ);

	/*
	 * Define Input Status Register 1 port
	 */

	io_define_inb(EGA_IPSTAT1_ADAPTOR,vga_ipstat1_inb);
	io_connect_port(EGA_IPSTAT1_REG,EGA_IPSTAT1_ADAPTOR,IO_READ);

        /*
         * Define VGA DAC register port
         */
        io_define_inb(VGA_DAC_INDEX_PORT,vga_dac_inb);
        io_define_outb(VGA_DAC_INDEX_PORT,vga_dac_outb);
        io_connect_port(VGA_DAC_MASK,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_connect_port(VGA_DAC_RADDR,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_connect_port(VGA_DAC_WADDR,VGA_DAC_INDEX_PORT,IO_READ_WRITE);
        io_define_inb(VGA_DAC_DATA_PORT,vga_dac_data_inb);
        io_define_outb(VGA_DAC_DATA_PORT,vga_dac_data_outb);
        io_connect_port(VGA_DAC_DATA,VGA_DAC_DATA_PORT,IO_READ_WRITE);

#endif //NEC_98
}

#endif 		/* GISP_SVGA */


#ifdef HUNTER

/* Get line compare value */

LONG vga_get_line_compare  IFN0()

    {
    LONG		return_value;

    return_value = crt_controller.line_compare;
    if (crt_controller.crtc_overflow.as_bfld.line_compare_bit_8 != 0)
	return_value += 0x100;
    return (return_value);
    }			/* ega_get_line_compare */

/* Get maximum scan lines value */

LONG vga_get_max_scan_lines  IFN0()

    {
    return (crt_controller.maximum_scan_line.as_bfld.maximum_scan_line);
    }			/* ega_get_max_scan_lines */

/* Set line compare value */

VOID vga_set_line_compare  IFN1(LONG,lcomp_val)

/* lcomp_val ----> new value for line compare */

    {
#ifndef NEC_98
    CRTC_OVERFLOW	new_overflow;

    new_overflow.as.abyte = crt_controller.crtc_overflow.as.abyte;
    if (lcomp_val >= 0x100)
	new_overflow.as_bfld.line_compare_bit_8 = 1;
    else
	new_overflow.as_bfld.line_compare_bit_8 = 0;

    outb(EGA_CRTC_INDEX, 7);
    outb(EGA_CRTC_DATA, new_overflow.as.abyte);
    outb(EGA_CRTC_INDEX, 24);
    outb(EGA_CRTC_DATA, lcomp_val & 0xff);
#endif //NEC_98
    }

#endif /* HUNTER */
#endif /* VGG */
#endif /* REAL_VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\biosbop.inc ===
bop     MACRO   callid
        db      0c4h,0c4h,callid
        endm

BIOS_PRINTER_IO equ     17h
PRNIO_EXECUTE   equ     -1
PRNIO_FLUSH     equ     0
PRNIO_OPEN      equ     1
PRNIO_CLOSE     equ     2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\vga_vide.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title        : vga_video.c
 *
 * Description  : BIOS video internal routines.
 *
 * Author       : William Gulland
 *
 * Notes        : The following functions are defined in this module:
 *
 *
 *
 */

/*
 *      static char SccsID[]="@(#)vga_video.c   1.37 06/26/95 Copyright Insignia Solutions Ltd.";
 */


#ifdef VGG

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "VIDEO_BIOS_VGA.seg"
#endif

/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#include FCntlH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "bios.h"
#include "ios.h"
#include "gmi.h"
#include "sas.h"
#include "gvi.h"
#include "timer.h"
#include "gfx_upd.h"
#include "host.h"
#include "egacpu.h"
#include "egaports.h"
#include "egagraph.h"
#include "egaread.h"
#include "video.h"
#include "egavideo.h"
#include "equip.h"
#include "vga_dac.h"
#include "vgaports.h"
#include "debug.h"

#ifndef PROD
#include "trace.h"
#endif

#include "host_gfx.h"

/*
 * ============================================================================
 * Global data
 * ============================================================================
 */


/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

#define DISABLE_REFRESH         0x20
/* the bit in the vga seq clock register that disables screen refresh */

#define VGA_COLOUR 8    /* Display Code */
typedef struct _rgb
{
        byte red;
        byte green;
        byte blue;
} rgb_struct;

/* internal function declarations */

/* To convert to grey, set all components to 30% r, 59% g and 11% b. */
static void greyify(rgb)
rgb_struct *rgb;
{
        unsigned int grey;

        grey = (30*rgb->red+59*rgb->green+11*rgb->blue)/100;
        rgb->red = rgb->green = rgb->blue = (unsigned char)grey;
}

static void set_dac(dac,rgb)
half_word dac;
rgb_struct *rgb;
{
        if(is_GREY())greyify(rgb);
        outb(VGA_DAC_WADDR,dac);
        outb(VGA_DAC_DATA,rgb->red);
        outb(VGA_DAC_DATA,rgb->green);
        outb(VGA_DAC_DATA,rgb->blue);
}

static void get_dac(dac,rgb)
half_word dac;
rgb_struct *rgb;
{
        outb(VGA_DAC_RADDR,dac);
        inb(VGA_DAC_DATA,&(rgb->red));
        inb(VGA_DAC_DATA,&(rgb->green));
        inb(VGA_DAC_DATA,&(rgb->blue));
}


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */


void init_vga_dac(table)
int table;      /* Which table to use */
{
    int loop;
    byte *dac;
    rgb_struct rgb;

#ifdef  macintosh

        /* load the required DAC in */
        dac = host_load_vga_dac (table);

        /* check it worked */
        if (!dac)
                return;

#else   /* macintosh */

    switch (table)
    {
        case 0:
          dac = vga_dac;
          break;
        case 1:
          dac = vga_low_dac;
          break;
        case 2:
          dac = vga_256_dac;
          break;
        default:
          assert1(FALSE,"Bad VGA DAC table %d",table);
          return;
    }

#endif  /* macintosh */

    for(loop = 0; loop < 0x100; loop++)
        {
                rgb.red = *dac; rgb.green = dac[1]; rgb.blue = dac[2];
                set_dac(loop,&rgb);
                dac+=3;
    }

#ifdef  macintosh

        /* and dump the DAC back into the heap */
        host_dump_vga_dac ();

#endif  /* macintosh */
}

/***** Routines to handle VGA 256 colour modes, called from video.c **********/
GLOBAL VOID vga_graphics_write_char
        IFN6( LONG, col, LONG, row, LONG, ch, IU8, colour, LONG, page, LONG, nchs)
{
        register sys_addr char_addr;
        register long screen_offset;
        register int i,j,k,char_height,len;
        register int scan_length = 8*sas_w_at_no_check(VID_COLS);
        register byte mask, val, bank;

        UNUSED(page);

        char_height = sas_hw_at_no_check(ega_char_height);
        char_addr = follow_ptr(EGA_FONT_INT*4)+char_height*ch;

/* VGA 256 colour mode has only one page, so ignore 'page' */

        /*
         * Set read/write banks to zero to optimise the update_alg call
         */

        set_banking( 0, 0 );

        screen_offset = row*scan_length*char_height+8*col;
        len = ( nchs << 3 ) - 1;

        for(i=0;i<char_height;i++)
        {
                (*update_alg.mark_fill)( screen_offset, screen_offset + len );

                val = sas_hw_at_no_check(char_addr);
                char_addr++;

                for(j=0;j<nchs;j++)
                {
                        mask = 0x80;

                        for(k=0;k<8;k++)
                        {
                                if( val & mask )
                                        *(IU8 *)(getVideowplane() + screen_offset) = colour;
                                else
                                        *(IU8 *)(getVideowplane() + screen_offset) = 0;

                                screen_offset++;
                                mask = mask >> 1;
                        }
                }

                screen_offset += scan_length - ( nchs << 3 );
        }

        /*
         * Set read/write banks to last value in case someone relies on this side-effect
         */

        bank = (byte)(( screen_offset - ( scan_length - ( nchs << 3 ))) >> 16);
        set_banking( bank, bank );
}

GLOBAL VOID vga_write_dot
        IFN4(LONG, colour, LONG, page, LONG, pixcol, LONG, row)
{
#ifdef REAL_VGA
        register sys_addr screen_offset;

        screen_offset = video_pc_low_regen+8*row*sas_w_at_no_check(VID_COLS)+pixcol;
        sas_store(screen_offset, colour); /* WOW - that's easy!! */
#else
        long screen_offset;
        UTINY bank;

        UNUSED(page);

        screen_offset = (8*row*sas_w_at_no_check(VID_COLS)+pixcol);

        bank = (UTINY)(screen_offset >> 16);
        set_banking( bank, bank );

        EGA_plane0123[screen_offset] = (UCHAR)colour;
        (*update_alg.mark_byte)(screen_offset);
#endif  /* REAL_VGA */
}

GLOBAL VOID vga_sensible_graph_scroll_up
        IFN6( LONG, row, LONG, col, LONG, rowsdiff, LONG, colsdiff, LONG, lines, LONG, attr)
{
        register int col_incr = 8*sas_w_at_no_check(VID_COLS);
        register int i;
        register long source,dest;
        register byte char_height;
        boolean screen_updated;

        col *= 8; colsdiff *= 8; /* 8 bytes per character */
        char_height = sas_hw_at_no_check(ega_char_height);
        rowsdiff *= char_height;
        lines *= char_height;
#ifdef REAL_VGA
        /* Not done for back M */
        dest = video_pc_low_regen+sas_loadw(VID_ADDR)+
                row*col_incr*char_height+col;
        source = dest+lines*col_incr;
        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy_16(dest,source,colsdiff);
                source += col_incr;
                dest += col_incr;
        }
        while(lines--)
        {
                memset_16(dest,attr,colsdiff);
                dest += col_incr;
        }
#else
        dest = sas_w_at_no_check(VID_ADDR)+ row*col_incr*char_height+col;
        source = dest+lines*col_incr;
        screen_updated = (col+colsdiff) <= col_incr;  /* Check for silly scroll */
        if(screen_updated)
                screen_updated = (*update_alg.scroll_up)(dest,colsdiff,rowsdiff,attr,lines,0);
        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy(&EGA_plane0123[dest],&EGA_plane0123[source],colsdiff);
                if(!screen_updated)
                        (*update_alg.mark_string)(dest,dest+colsdiff-1);
                source += col_incr;
                dest += col_incr;
        }
        while(lines--)
        {
                memset(&EGA_plane0123[dest],attr,colsdiff);
                if(!screen_updated)
                        (*update_alg.mark_fill)(dest,dest+colsdiff-1);
                dest += col_incr;
        }
#endif  /* REAL_VGA */
}

GLOBAL VOID vga_sensible_graph_scroll_down
        IFN6( LONG, row, LONG, col, LONG, rowsdiff, LONG, colsdiff, LONG, lines, LONG, attr)
{
        register int col_incr = 8*sas_w_at_no_check(VID_COLS);
        register int i;
        register long source,dest;
        register byte char_height;
        boolean screen_updated;

        col *= 8; colsdiff *= 8; /* 8 bytes per character */
        char_height = sas_hw_at_no_check(ega_char_height);
        rowsdiff *= char_height;
        lines *= char_height;
#ifdef REAL_VGA
        /* Not done for back M */
        dest = video_pc_low_regen+sas_loadw(VID_ADDR)+
                row*col_incr*char_height+col;
        dest += (rowsdiff-1)*col_incr;
        source = dest-lines*col_incr;
        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy_16(dest,source,colsdiff);
                source -= col_incr;
                dest -= col_incr;
        }
        while(lines--)
        {
                memset_16(dest,attr,colsdiff);
                dest -= col_incr;
        }
#else
        dest = sas_w_at_no_check(VID_ADDR)+ row*col_incr*char_height+col;
        screen_updated = (col+colsdiff) <= col_incr;  /* Check for silly scroll */
        if(screen_updated)
                screen_updated = (*update_alg.scroll_down)(dest,colsdiff,rowsdiff,attr,lines,0);
        dest += (rowsdiff-1)*col_incr;
        source = dest-lines*col_incr;
        for(i=0;i<rowsdiff-lines;i++)
        {
                memcpy(&EGA_planes[dest],&EGA_planes[source],colsdiff);
                if(!screen_updated)
                        (*update_alg.mark_string)(dest,dest+colsdiff-1);
                source -= col_incr;
                dest -= col_incr;
        }
        while(lines--)
        {
                memset(&EGA_planes[dest],attr,colsdiff);
                if(!screen_updated)
                        (*update_alg.mark_fill)(dest,dest+colsdiff-1);
                dest -= col_incr;
        }
#endif  /* REAL_VGA */
}

GLOBAL VOID vga_read_attrib_char IFN3(LONG, col, LONG, row, LONG, page)
{
        byte the_char[256];
        register host_addr screen;
        register int i,k;
        register int scan_length = 8*sas_w_at_no_check(VID_COLS);
    register byte mask;
        byte char_height = sas_hw_at_no_check(ega_char_height);

        UNUSED(page);

/*printf("vga_read_attrib_char(%d,%d,%d)\n",
        col,row,page);*/
/* VGA 256 colour mode has only one page, so ignore 'page' */
#ifdef REAL_VGA
        screen = video_pc_low_regen+row*scan_length*char_height+8*col;
#else
        screen = &EGA_plane0123[row*scan_length*char_height+8*col];
#endif  /* REAL_VGA */
        for(i=0;i<char_height;i++)
        {
                mask = 0x80;
                the_char[i]=0;
                for(k=0;k<8;k++)
                {
                        if(*screen++)
                                the_char[i] |= mask;
                        mask = mask >> 1;
                }
                screen += scan_length - 8;
        }
        search_font((char *)the_char,(int)char_height);
}

GLOBAL VOID vga_read_dot IFN3(LONG, page, LONG, pixcol, LONG, row)
{
        register host_addr screen;

        UNUSED(page);

/*printf("vga_read_dot(%d,%d,%d)\n",page,col,row);*/
#ifdef REAL_VGA
        screen = video_pc_low_regen+8*row*sas_w_at_no_check(VID_COLS)+pixcol;
#else
        screen = &EGA_plane0123[8*row*sas_w_at_no_check(VID_COLS)+pixcol];
#endif  /* REAL_VGA */
        setAL(*screen) ; /* WOW - that's easy!! */
}

/****** Routines to handle BIOS functions new to VGA *******/
void vga_set_palette()
{
        /*
         * Called via INT 10 AH=10, AL='not understood by ega_set_palette()'
         * Sets/reads VGA DACs.
         */
        UCHAR i;
    word i2;
    int dac;
        byte temp; /* For inb()s. */
        byte mode_reg;
        rgb_struct rgb_dac;
        sys_addr ptr;
        switch(getAL())
        {
                case 7:         /* Read attribute register */
                        outb(EGA_AC_INDEX_DATA,getBL()); /* set index */
                        inb(EGA_AC_SECRET,&temp);
                        setBH(temp);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;
                case 8:         /* Read overscan register */
                        outb(EGA_AC_INDEX_DATA,17); /* overscan index */
                        inb(EGA_AC_SECRET,&temp);
                        setBH(temp);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;
                case 9:         /* Read all palette regs. + overscan */
                        ptr = effective_addr(getES(),getDX());
                        for(i=0;i<16;i++)
                        {
                                outb(EGA_AC_INDEX_DATA,i); /* set index */
                                inb(EGA_AC_SECRET,&temp);
                                sas_store(ptr, temp);
                                inb(EGA_IPSTAT1_REG,&temp);
                                ptr++;
                        }
                        outb(EGA_AC_INDEX_DATA,17); /* overscan index */
                        inb(EGA_AC_SECRET,&temp);
                        sas_store(ptr, temp);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;
                case 0x10:      /* Set one DAC */
                        rgb_dac.red = getDH();
                        rgb_dac.green = getCH();
                        rgb_dac.blue = getCL();
                        set_dac(getBX(),&rgb_dac);
                        break;
                case 0x12:      /* Set block of DACs */
                        ptr = effective_addr(getES(),getDX());
                        dac = getBX();
                        for(i2=0;i2<getCX();i2++)
                        {
                           rgb_dac.red = sas_hw_at_no_check(ptr);
                           rgb_dac.green = sas_hw_at_no_check(ptr+1);
                           rgb_dac.blue = sas_hw_at_no_check(ptr+2);
                           set_dac(dac,&rgb_dac);
                           dac++;ptr += 3;
                        }
                        break;
                case 0x13:      /* Set paging mode
                                 * see Prog Guide to Video Systems, pp60-63]
                                 * and IBM ROM BIOS pp26-27.
                                 */
                        outb(EGA_AC_INDEX_DATA,16); /* mode control index */
                        inb(EGA_AC_SECRET,&mode_reg);  /* Old value */
                        if(getBL()==0)
                        {  /* Select paging mode */
                           outb(EGA_AC_INDEX_DATA,
                                (IU8)((mode_reg & 0x7f) | (getBH()<<7)));
                        }
                        else /* Select a palette page */
                        {
                           inb(EGA_IPSTAT1_REG,&temp);
                           outb(EGA_AC_INDEX_DATA,20); /* pixel padding index */
                           if(mode_reg & 0x80)
                            /* 16 entry palettes
                             *  bits 0-3of the pad register relevant */
                             outb(EGA_AC_INDEX_DATA,getBH());
                           else
                            /* 64 entry palette - only bits 2-3 relevent */
                             outb(EGA_AC_INDEX_DATA,(IU8)(getBH()<<2));
                        }
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;

                case 0x15:      /* Get value of one DAC */
                        get_dac(getBX(),&rgb_dac);
                        setDH(rgb_dac.red);
                        setCH(rgb_dac.green);
                        setCL(rgb_dac.blue);
                        break;
                case 0x17:
                        ptr = effective_addr(getES(),getDX());
                        dac = getBX();
                        for(i2=0;i2<getCX();i2++)
                        {
                           get_dac(dac,&rgb_dac);
                           sas_store(ptr, rgb_dac.red);
                           sas_store(ptr+1, rgb_dac.green);
                           sas_store(ptr+2, rgb_dac.blue);
                           dac++;
                           ptr += 3;
                        }
                        break;
                case 0x18:
                        /* Set the VGA DAC mask. */
                        outb(VGA_DAC_MASK,getBL());
                        break;
                case 0x19:
                        /* Get the VGA DAC mask. */
                        inb(VGA_DAC_MASK,&temp);
                        setBL(temp);
                        break;
                case 0x1a:
                        /* Return current mode control & pixel padding */
                        outb(EGA_AC_INDEX_DATA,16); /* mode control index */
                        inb(EGA_AC_SECRET,&mode_reg);
                        if(mode_reg & 0x80)
                                setBL(1);
                        else
                                setBL(0);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA,20); /* pixel padding index */
                        inb(EGA_AC_SECRET,&temp);
                        setBH(temp);
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        break;
                case 0x1b:      /* Convert set of DACs to grey scale. */
                        dac = getBX();
                        for(i2=0;i2<getCX();i2++)
                        {
                                get_dac(dac,&rgb_dac);
                                greyify(&rgb_dac);
                                set_dac(dac,&rgb_dac);
                                dac++;
                        }
                        break;
                default:
                        assert1(FALSE,"Bad set palette submode %#x",getAL());
                        break;
        }
}

/*
 * Various miscellaneous flags can be set using
 * INT 10, AH 12, AL flag.
 * Called from ega_alt_sel().
 */
void vga_func_12()
{
        half_word       seq_clock;

        switch(getBL())
        {
                case 0x30:      /* Set number of scan lines */
                        if(getAL() == 0)
                                set_VGA_lines(S200);
                        else if(getAL() == 1)
                                set_VGA_lines(S350);
                        else
                                set_VGA_lines(S400);
                        setAL(0x12);    /* We did it */
                        break;
                case 0x33:      /* Enable/Disable Grey-Scale Summing */
                        if(getAL())
                                set_GREY(0);
                        else
                                set_GREY(GREY_SCALE);
                        setAL(0x12);    /* We did it */
                        break;
                case 0x34:      /* Enable/disable Cursor Emulation */
                        set_EGA_cursor_no_emulate(getAL() & 1);
                        setAL(0x12);    /* We did it */
                        break;

                case 0x36:      /* Enable/Disable Screen Refresh */
                        if (getAL() == 0)
                        {
                                outb(EGA_SEQ_INDEX, 1);
                                inb(EGA_SEQ_DATA, &seq_clock);
                                outb(EGA_SEQ_DATA, (IU8)(seq_clock & ~DISABLE_REFRESH));
                        }
                        else
                        {
                                outb(EGA_SEQ_INDEX, 1);
                                inb(EGA_SEQ_DATA, &seq_clock);
                                outb(EGA_SEQ_DATA, (IU8)(seq_clock | DISABLE_REFRESH));
                        }
                        setAL(0x12);
                        break;
                case 0x31:      /* Enable/Disable Default Palette Loading */
                case 0x32:      /* Enable/Disable Video */
                case 0x35:      /* Switch active display */
                        /* do not set code that means it worked */
                default:
                        setAL(0);       /* Function not supported */
                        break;
        }
}
void vga_disp_comb()
{
        /* check that we really are a VGA */
        if (video_adapter != VGA)
        {
                /* we are not -so this function is not implemented */
                not_imp();
                return;
        }

        /*
         * On a PS/2, AL=1 is (I believe) used to switch active displays.
         * We ignore this.
         * AL=0 returns the current display, which we can cope with.
         */
        if(getAL() == 0)
        {
                setBH(0);          /* Only one display, so no inactive one! */
                setBL(VGA_COLOUR); /* VGA with colour monitor. (7 for mono) */
        }
        setAX(0x1A); /* Tell him we coped. */
}

void vga_disp_func()
{
        /*
         * This function returns masses of info. about the current
         * display and screen mode.
         * One of the things returned is a pointer to the display info.
         * This is stored in the VGA ROM, so all we need to do is set
         * the pointer up.
         *
         */
        sys_addr buf = effective_addr(getES(),getDI());
        byte temp,mode_reg, video_mode;

#if defined(NTVDM) && defined(X86GFX)
        IMPORT word vga1b_seg, vga1b_off;
#endif  /* NTVDM & X86GFX */

        /* check that we really are a VGA */
#ifndef HERC
        if (video_adapter != VGA)
#else
        if ( (video_adapter != VGA) && (video_adapter != HERCULES))
#endif  /* HERC */
        {
                /* we are not -so this function is not implemented */
                not_imp();
                return;
        }

#ifdef HERC
     if( video_adapter == VGA)
     {
#endif  /* HERC */
        video_mode = sas_hw_at_no_check(vd_video_mode);
#ifdef V7VGA
        if ((video_mode == 1) && extensions_controller.foreground_latch_1)
                video_mode = extensions_controller.foreground_latch_1;
        else if (video_mode > 0x13)
                video_mode += 0x4c;
#endif /* V7VGA */

/*
 * Store VGA capability table pointer. Usually lives in Insignia ROM, on NT
 * x86 it has to live in ntio.sys.
 */
#if defined(NTVDM) && defined(X86GFX)
        sas_storew(buf, vga1b_off);
        sas_storew(buf+2, vga1b_seg);
#else
        sas_storew(buf,INT10_1B_DATA);
        sas_storew(buf+2,EGA_SEG);
#endif  /* NTVDM & X86GFX */

        sas_store(buf+0x4, video_mode); /* Current video mode */
        sas_storew(buf+5,sas_w_at_no_check(VID_COLS)); /* Cols on screen */
        sas_storew(buf+7,sas_w_at_no_check(VID_LEN));  /* Size of screen */
        sas_storew(buf+9,sas_w_at_no_check(VID_ADDR)); /* Address of screen */
        sas_move_bytes_forward(VID_CURPOS,buf+0xB,16);      /* Cursor positions */
        sas_storew(buf+0x1b,sas_w_at_no_check(VID_CURMOD)); /* Cursor type */
        sas_store(buf+0x1D, sas_hw_at_no_check(vd_current_page));
        sas_storew(buf+0x1E,sas_w_at_no_check(VID_INDEX));
        sas_store(buf+0x20, sas_hw_at_no_check(vd_crt_mode));
        sas_store(buf+0x21, sas_hw_at_no_check(vd_crt_palette));
        sas_store(buf+0x22, (IU8)(sas_hw_at_no_check(vd_rows_on_screen)+1));
        sas_storew(buf+0x23,sas_w_at_no_check(ega_char_height));
        sas_store(buf+0x25, VGA_COLOUR);        /* Active display */
        sas_store(buf+0x26, 0);         /* Inactive display (none) */
#ifdef V7VGA
        if (video_mode >= 0x60)
        {
                sas_storew(buf+0x27,vd_ext_graph_table[video_mode-0x60].ncols);
                sas_store(buf+0x29, vd_ext_graph_table[video_mode-0x60].npages);
        }
        else if (video_mode >= 0x40)
        {
                sas_storew(buf+0x27,vd_ext_text_table[video_mode-0x40].ncols);
                sas_store(buf+0x29, vd_ext_text_table[video_mode-0x40].npages);
        }
        else
        {
                sas_storew(buf+0x27,vd_mode_table[video_mode].ncols);
                sas_store(buf+0x29, vd_mode_table[video_mode].npages);
        }
#else
        sas_storew(buf+0x27,vd_mode_table[video_mode].ncols);
        sas_store(buf+0x29, vd_mode_table[video_mode].npages);
#endif /* V7VGA */
        sas_store(buf+0x2A, (IU8)(get_scanlines()));

        outb(EGA_SEQ_INDEX,3);
        inb(EGA_SEQ_DATA,&temp);        /* Character Font select reg. */
        sas_store(buf+0x2B, (IU8)((temp & 3)|((temp & 0x10)>>2)));
                         /* extract bits 410 - font B */
        sas_store(buf+0x2C, (IU8)(((temp & 0xC)>>2)|((temp & 0x20)>>3)));
                        /* extract bits 532 - font A */

        temp = 1;                       /* All modes on all displays active */
        if(is_GREY())temp |= 2;
        if(is_MONO())temp |= 4;
        if(is_PAL_load_off())temp |=8;
        if(get_EGA_cursor_no_emulate())temp |= 0x10;
        inb(EGA_IPSTAT1_REG,&mode_reg); /* Clear Attribute flip-flop */
        outb(EGA_AC_INDEX_DATA,16); /* mode control index */
        inb(EGA_AC_SECRET,&mode_reg);
        if(mode_reg & 8)temp |= 0x20;
        inb(EGA_IPSTAT1_REG,&mode_reg); /* Clear Attribute flip-flop */
        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
        sas_store(buf+0x2D, temp);
        sas_store(buf+0x31, 3);         /* 256KB video memory */
        setAX(0x1B); /* We did it! */
#ifdef HERC
       } /* if VGA */
    if( video_adapter == HERCULES)
     {
        video_mode = sas_hw_at(vd_video_mode);
        sas_storew(buf,INT10_1B_DATA);
        sas_storew(buf+2,EGA_SEG);
        sas_store(buf+0x4, video_mode);                         /* Current video mode */
        sas_storew(buf+5,sas_w_at(VID_COLS));                   /* Cols on screen */
        sas_storew(buf+7,sas_w_at(VID_LEN));                    /* Size of screen */
        sas_storew(buf+9,sas_w_at(VID_ADDR));                   /* Address of screen */
        sas_move_bytes_forward(VID_CURPOS,buf+0xB,16);          /* Cursor positions */
        sas_store(buf+0x1b, HERC_CURS_START+HERC_CURS_HEIGHT);  /* Cursor end line */
        sas_store(buf+0x1c, HERC_CURS_START);                   /* Cursor start line */
        sas_store(buf+0x1D, sas_hw_at(vd_current_page));
        sas_storew(buf+0x1E,sas_w_at(VID_INDEX));
        sas_store(buf+0x20, sas_hw_at(vd_crt_mode));
        sas_store(buf+0x21, sas_hw_at(vd_crt_palette));
        sas_store(buf+0x22, sas_hw_at(vd_rows_on_screen)+1);
        sas_storew(buf+0x23, 14);                               /* char height is 14 */
        sas_store(buf+0x25,0x01 );      /* 01=MDA with monochrome display as Active display */
        sas_store(buf+0x26, 0);         /* Inactive display (none) */

        vd_mode_table[video_mode].ncols= 2;                     /* Black & White 2 colors */
        sas_storew(buf+0x27,vd_mode_table[video_mode].ncols);
        vd_mode_table[video_mode].npages= 2;                    /* support 2 pages  */
        sas_store(buf+0x29, vd_mode_table[video_mode].npages);

        sas_store(buf+0x2A, get_scanlines());

        sas_store(buf+0x2B,0x00);       /* Primary Font select always 0 */
        sas_store(buf+0x2C,0x00);       /* Secondary Font select always 0 */


        sas_store(buf+0x2D, 0x30);      /* MDA with Monochrome Display */
        sas_store(buf+0x31, 0);         /* 64KB video memory */
        setAX(0x1B); /* We did it! */
       } /* if HERCULES */
#endif  /* HERC */
}

void vga_int_1C()
{
sys_addr buff = effective_addr(getES(),getBX());
UCHAR i;
int i2;
word states;
half_word temp;
rgb_struct rgb_dac;
static word buff_sizes[] = { 0,2,2,3,0x0d,0x0e,0x0e,0x0f };
static byte const1[] = { 2,0x18,6,0x20 };
static byte const2[] = { 0xd4,3,0x20,7,0,0 };
static byte const3[] = { 0x20 };
static byte const4[] = { 0x68,0x15,0x20,0x0a,0x85,0,0,0xc0,0,0x0c,0,0xc0,0,8,0,0xc0 };
static byte const5[] = { 1,0,0xff };

        /* check that we really are a VGA */
        if (video_adapter != VGA)
        {
                /* we are not -so this function is not implemented */
                not_imp();
                return;
        }
        states = getCX() & 7;
        switch (getAL())
        {
        case 00:  /* buffer sizes into bx */
                setBX(buff_sizes[states]);
                setAL(0x1c);
                break;

        case 01:  /* Save video states to es:bx */
                if( states&1 )  /* Video hardware state */
                        sas_storew(buff, 0x0064); /* ID words. DODGY! */
                if( states&2 )  /* Video BIOS state */
                        sas_storew(buff+2, 0x0064);
                if( states&4 )  /* Video DAC state */
                        sas_storew(buff+4, 0x0064);
                buff += 0x20;

                if( states&1 )  /* Video hardware state */
                {
                        for(i=0;i<sizeof(const1);i++)
                                sas_store(buff++, const1[i]);
                        for(i=0;i<5;i++)
                        {
                                outb(EGA_SEQ_INDEX,i);
                                inb(EGA_SEQ_DATA,&temp);
                                sas_store(buff++, temp);
                        }
                        inb(VGA_MISC_READ_REG,&temp);
                        sas_store(buff++, temp);
                        for(i=0;i<0x19;i++)
                        {
                                outb(EGA_CRTC_INDEX,i);
                                inb(EGA_CRTC_DATA,&temp);
                                sas_store(buff++, temp);
                        }
                        for(i=0;i<20;i++)
                        {
                                inb(EGA_IPSTAT1_REG,&temp); /*clear attribute flipflop*/
                                outb(EGA_AC_INDEX_DATA,i);
                                inb(EGA_AC_SECRET,&temp);
                                sas_store(buff++, temp);
                        }
                        /* now ensure video reenabled. First ensure
                         * AC reg is in 'index' state by reading Status reg 1
                         */
                        inb(EGA_IPSTAT1_REG,&temp);
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        for(i=0;i<9;i++)
                        {
                                outb(EGA_GC_INDEX,i);
                                inb(EGA_GC_DATA,&temp);
                                sas_store(buff++, temp);
                        }
                        for(i=0;i<sizeof(const2);i++)
                                sas_store(buff++, const2[i]);
                }
                if( states&2 )  /* Video BIOS state  */
                {
                        for(i=0;i<sizeof(const3);i++)
                                sas_store(buff++, const3[i]);
                        sas_store(buff++, sas_hw_at_no_check(vd_video_mode));
                        sas_storew(buff,sas_w_at_no_check(VID_COLS));
                        buff += 2;
                        sas_storew(buff,sas_w_at_no_check(VID_LEN));
                        buff += 2;
                        sas_storew(buff,sas_w_at_no_check(VID_ADDR));
                        buff += 2;
                        sas_move_bytes_forward(VID_CURPOS, buff, 16);
                        buff += 16;
                        outb(EGA_CRTC_INDEX,R11_CURS_END);
                        inb(EGA_CRTC_DATA,&temp);
                        sas_store(buff++, (IU8)(temp & 0x1F));
                        outb(EGA_CRTC_INDEX,R10_CURS_START);
                        inb(EGA_CRTC_DATA,&temp);
                        sas_store(buff++, (IU8)(temp & 0x1F));
                        sas_store(buff++, sas_hw_at_no_check(vd_current_page));
                        sas_storew(buff,sas_w_at_no_check(VID_INDEX));
                        buff += 2;
                        sas_store(buff++, sas_hw_at_no_check(vd_crt_mode));
                        sas_store(buff++, sas_hw_at_no_check(vd_crt_palette));
                        sas_store(buff++, sas_hw_at_no_check(vd_rows_on_screen));
                        sas_storew(buff, sas_w_at_no_check(ega_char_height));
                        buff += 2;
                        sas_store(buff++, sas_hw_at_no_check(ega_info));
                        sas_store(buff++, sas_hw_at_no_check(ega_info3));
                        sas_store(buff++, sas_hw_at_no_check(VGA_FLAGS));
                        sas_store(buff++, sas_hw_at_no_check(0x48a)); /* DCC */
                        sas_move_bytes_forward(EGA_SAVEPTR, buff, 4);
                        buff += 4;

                        for(i=0;i<sizeof(const4);i++)
                                sas_store(buff++, const4[i]);
                }
                if( states&4 )  /* VGA DAC values  */
                {
                        for(i=0;i<sizeof(const5);i++)
                                sas_store(buff++, const5[i]);
                        for(i2=0;i2<256;i2++)
                        {
                                get_dac(i2, &rgb_dac);
                                sas_store(buff++, rgb_dac.red);
                                sas_store(buff++, rgb_dac.green);
                                sas_store(buff++, rgb_dac.blue);
                        }
                }
                break;

        case 02:  /* Restore video states from es:bx */
                buff += 0x20;
                if( states&1 )  /* Video hardware state */
                {
                        buff += sizeof(const1);
                        for(i=0;i<5;i++)
                        {
                                outb(EGA_SEQ_INDEX,i);
                                outb(EGA_SEQ_DATA,sas_hw_at_no_check(buff++));
                        }
                        outb(VGA_MISC_READ_REG,sas_hw_at_no_check(buff++));
                        for(i=0;i<0x19;i++)
                        {
                                outb(EGA_CRTC_INDEX,i);
                                outb(EGA_CRTC_DATA,sas_hw_at_no_check(buff++));
                        }
                        inb(EGA_IPSTAT1_REG,&temp); /* clear attribute flip flop */
                        for(i=0;i<20;i++)
                        {
                                outb(EGA_AC_INDEX_DATA,i);
                                outb(EGA_AC_INDEX_DATA,sas_hw_at_no_check(buff++));
                        }
                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
                        for(i=0;i<9;i++)
                        {
                                outb(EGA_GC_INDEX,i);
                                outb(EGA_GC_DATA,sas_hw_at_no_check(buff++));
                        }
                        buff += sizeof(const2);
                }
                if( states&2 )  /* Video BIOS state  */
                {
                        buff += sizeof(const3);
                        sas_store_no_check(vd_video_mode, sas_hw_at_no_check(buff++));
                        sas_storew_no_check(VID_COLS,sas_w_at_no_check(buff));
                        buff += 2;
                        sas_storew_no_check(VID_LEN,sas_w_at_no_check(buff));
                        buff += 2;
                        sas_storew_no_check(VID_ADDR,sas_w_at_no_check(buff));
                        buff += 2;
                        sas_move_bytes_forward(buff, VID_CURPOS, 16);
                        buff += 16;
                        outb(EGA_CRTC_INDEX,R11_CURS_END);
                        temp = sas_hw_at_no_check(buff++) & 0x1F;
                        outb(EGA_CRTC_DATA,temp);
                        outb(EGA_CRTC_INDEX,R10_CURS_START);
                        temp = sas_hw_at_no_check(buff++) & 0x1F;
                        outb(EGA_CRTC_DATA,temp);
                        sas_store_no_check(vd_current_page, sas_hw_at_no_check(buff++));
                        sas_storew_no_check(VID_INDEX,sas_w_at_no_check(buff));
                        buff += 2;
                        sas_store_no_check(vd_crt_mode, sas_hw_at_no_check(buff++));
                        sas_store_no_check(vd_crt_palette, sas_hw_at_no_check(buff++));
                        sas_store_no_check(vd_rows_on_screen, sas_hw_at_no_check(buff++));
                        sas_storew_no_check(ega_char_height, sas_w_at_no_check(buff));
                        buff += 2;
                        sas_store_no_check(ega_info, sas_hw_at_no_check(buff++));
                        sas_store_no_check(ega_info3, sas_hw_at_no_check(buff++));
                        sas_store_no_check(VGA_FLAGS, sas_hw_at_no_check(buff++));
                        sas_store_no_check(0x48a, sas_hw_at_no_check(buff++)); /* DCC */
                        sas_move_bytes_forward(buff, EGA_SAVEPTR, 4);
                        buff += 4;
                        buff += sizeof(const4);
                }
                if( states&4 )  /* VGA DAC values  */
                {
                        buff += sizeof(const5);
                        for(i2=0;i2<256;i2++)
                        {
                                rgb_dac.red = sas_hw_at_no_check(buff++);
                                rgb_dac.green = sas_hw_at_no_check(buff++);
                                rgb_dac.blue = sas_hw_at_no_check(buff++);
                                set_dac(i2,&rgb_dac);
                        }
                }
                break;

        default:
                not_imp();
                break;
        }
}

#endif  /* VGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\vga_mode.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA (SUB)MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DESIGNER		: S.Frost

REVISION HISTORY	:
First version		: Feb/Mar 1990. Simon Frost

SOURCE FILE NAME	: vga_mode.c

PURPOSE			: To decide which mode the VGA is in according to
			  variables set via vga_ports.c and to choose the
			  appropriate update and paint routines accordingly.
			  Borrows heavily from ega_mode.c...

static char SccsID[]="@(#)vga_mode.c	1.35 06/01/95 Copyright Insignia Solutions Ltd.";




[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

	INCLUDE FILE : ega_mode.gi

[1.1    INTERMODULE EXPORTS]

	PROCEDURES() :	choose_vga_display_mode

	DATA 	     :	uses EGA_GRAPH.display_state which is set via vga_ports.c, to
			determine what memory organisation the display side is in, and
			hence what sort of update and paint routines to use.

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

	STRUCTURES/TYPEDEFS/ENUMS:

uses	enum DISPLAY_STATE which is declared in ega_graph.pi.

uses	EGA_GRAPH structure for global variables set by the ports and
	used by the display.

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]
     (not o/s objects or standard libs)

	PROCEDURES() : vote_vga_mode()
			host_set_paint_routine(DISPLAY_MODE)

	DATA 	     : EGA_GRAPH struct.

-------------------------------------------------------------------------

[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

[1.4.2 EXPORTED OBJECTS]

=========================================================================
PROCEDURE	  : 	choose_vga_display_mode

PURPOSE		  : 	To decide which memory organisation is being used by
			the vga, and to pick the best update and paint routines
			accordingly.  The paint routines are host specific,
			and so the memory organisation is indicated by an enum
			(called DISPLAY_MODE), describing each sort of memory
			organisation.

PARAMETERS	  :	none

GLOBALS		  :	uses EGA_GRAPH struct, specially display_state to
			decide which mode is being used.

=========================================================================


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]						*/


#ifndef REAL_VGA
#ifdef	VGG

/* [3.1.1 #INCLUDES]                                                    */

#include	"xt.h"
#include	"error.h"
#include	"config.h"
#include	"gvi.h"
#include	"gmi.h"
#include	"gfx_upd.h"
#include	"egagraph.h"
#include	"vgaports.h"
#include	"egacpu.h"
#include	"egaports.h"
#include	"debug.h"
#include	"host_gfx.h"

#ifdef GORE
#include	"gore.h"
#endif /* GORE */

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						*/

#include	"egamode.h"

#ifdef GISP_SVGA
#include HostHwVgaH
#include "hwvga.h"
#endif /* GISP_SVGA */

/*
5.MODULE INTERNALS   :   (not visible externally, global internally)]

[5.1 LOCAL DECLARATIONS]						*/

/* [5.1.1 #DEFINES]							*/
#ifdef SEGMENTATION
/*
 * The following #define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_VGA.seg"
#endif

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			*/

/* [5.1.3 PROCEDURE() DECLARATIONS]					*/

/*
=========================================================================
PROCEDURE	  : 	set_up_screen_ptr()

PURPOSE		  : 	Decide which plane the information must come from for displaying

PARAMETERS	  :	none

GLOBALS		  :	uses EGA_GRAPH struct, plane_mask to decide which planes are enabled

=========================================================================
*/

LOCAL VOID
set_up_screen_ptr()
{
#if defined(NEC_98)
        set_screen_ptr(0x00000L);
#else   //NEC_98
	if( get_chain4_mode() )
	{
		if (all_planes_enabled())
			set_screen_ptr(EGA_plane0123);
		else
			assert0(NO,"No planes enabled for chain-4 mode\n");
	}
	else
		if( get_memory_chained() )
		{
			if( plane01_enabled() )
				set_screen_ptr(EGA_plane01);
			else
				if( plane23_enabled() )
					set_screen_ptr(EGA_plane23);
				else
					assert0(NO,"No planes enabled for chain mode");
		}
		else
			set_screen_ptr(EGA_planes);
#endif  //NEC_98
}

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS 					*/

IMPORT	DISPLAY_MODE	choose_mode[];

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				*/

#ifdef GISP_SVGA
	    extern void mon_text_update();
#endif /* GISP_SVGA */

static	void	set_update_routine(mode)
DISPLAY_MODE	mode;
{
	static int last_height = 200;

	if (last_height != get_screen_height()) {
		last_height = get_screen_height();
	}
	note_display_state1("VGA set_update_routine(%s)", get_mode_string(mode) );

#if defined(NTVDM) && defined(MONITOR)
	{
#if defined(NEC_98)
            extern void NEC98_text_update();
            set_gfx_update_routines( NEC98_text_update, SIMPLE_MARKING, NO_SCROLL );
            return;

#else   //NEC_98
	    extern void mon_text_update(void);

	    switch (mode)
	    {
	    case EGA_TEXT_40_SP_WR:
	    case EGA_TEXT_80_SP_WR:
	    case CGA_TEXT_40_SP_WR:
	    case CGA_TEXT_80_SP_WR:
	    case EGA_TEXT_40_SP:
	    case EGA_TEXT_80_SP:
	    case CGA_TEXT_40_SP:
	    case CGA_TEXT_80_SP:
	    case EGA_TEXT_40_WR:
	    case EGA_TEXT_80_WR:
	    case EGA_TEXT_40:
	    case EGA_TEXT_80:
	    case CGA_TEXT_40_WR:
	    case CGA_TEXT_80_WR:
	    case CGA_TEXT_40:
	    case CGA_TEXT_80:
	    case TEXT_40_FUN:
	    case TEXT_80_FUN:
		set_gfx_update_routines(mon_text_update, SIMPLE_MARKING,
					TEXT_SCROLL);
		return;
	    default:
		break;
	}

#endif  //NEC_98
	}

#endif	/* MONITOR */
/* NTVDM monitor: All text monitor cases dealt with. For frozen graphics */
/* now fall through to do decode to correct paint routines per mode */

#ifndef NEC_98
	switch (mode) {
		case EGA_TEXT_40_SP_WR:
		case EGA_TEXT_80_SP_WR:
		case CGA_TEXT_40_SP_WR:
		case CGA_TEXT_80_SP_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
			set_gfx_update_routines( mon_text_update, SIMPLE_MARKING, NO_SCROLL );
#else /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_split_text_update, SIMPLE_MARKING, NO_SCROLL );
#endif /* GISP_SVGA */
			host_update_fonts();
			break;
		case EGA_TEXT_40_SP:
		case EGA_TEXT_80_SP:
		case CGA_TEXT_40_SP:
		case CGA_TEXT_80_SP:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
			set_gfx_update_routines( mon_text_update, SIMPLE_MARKING, NO_SCROLL );
#else /* GISP_SVGA */
			set_gfx_update_routines( ega_split_text_update, SIMPLE_MARKING, NO_SCROLL );
#endif /* GISP_SVGA */
			host_update_fonts();
			break;
		case EGA_TEXT_40_WR:
		case EGA_TEXT_80_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
			set_gfx_update_routines( mon_text_update, SIMPLE_MARKING, NO_SCROLL );
#else /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_text_update, SIMPLE_MARKING, NO_SCROLL );
#endif /* GISP_SVGA */
			host_update_fonts();
			break;
		case EGA_TEXT_40:
		case EGA_TEXT_80:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#if defined(NTVDM) && !defined(MONITOR)   /* Only get here for NTVDM Riscs */
			{
	    		    extern void jazz_text_update(void);
	    		    set_gfx_update_routines( jazz_text_update, SIMPLE_MARKING, TEXT_SCROLL );
			}
#else
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
			set_gfx_update_routines( mon_text_update, SIMPLE_MARKING, TEXT_SCROLL );
#else /* GISP_SVGA */
			set_gfx_update_routines( ega_text_update, SIMPLE_MARKING, TEXT_SCROLL );
#endif /* GISP_SVGA */
			host_update_fonts();
#endif	/* NTVDM */
			break;
		case CGA_TEXT_40_WR:
		case CGA_TEXT_80_WR:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
#endif /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case CGA_TEXT_40:
		case CGA_TEXT_80:
			assert0( is_it_text(), "In text memory mode, but not in alpha mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
#endif /* GISP_SVGA */
			assert1( get_screen_height() == 200, "screen height %d for text mode", get_screen_height() );
			set_gfx_update_routines( text_update, SIMPLE_MARKING, TEXT_SCROLL );
			host_update_fonts();
			break;
		case CGA_MED:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 2;
#endif /* GISP_SVGA */
			set_gfx_update_routines( cga_med_graph_update, CGA_GRAPHICS_MARKING, CGA_GRAPH_SCROLL );
			break;
		case CGA_HI:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			set_gfx_update_routines( cga_hi_graph_update, CGA_GRAPHICS_MARKING, CGA_GRAPH_SCROLL );
			break;
		case EGA_HI_WR:
		case EGA_MED_WR:
		case EGA_LO_WR:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case EGA_HI:
		case EGA_MED:
		case EGA_LO:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
#ifdef GORE
			if (get_256_colour_mode())
			    set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, VGA_GRAPH_SCROLL );
			else
			    set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, EGA_GRAPH_SCROLL );
#else
			if (get_256_colour_mode())
			    set_gfx_update_routines( vga_graph_update, EGA_GRAPHICS_MARKING, VGA_GRAPH_SCROLL );
			else
			    set_gfx_update_routines( ega_graph_update, EGA_GRAPHICS_MARKING, EGA_GRAPH_SCROLL );
#endif /* GORE */
			break;
		case EGA_HI_SP_WR:
		case EGA_MED_SP_WR:
		case EGA_LO_SP_WR:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			set_gfx_update_routines( ega_wrap_split_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
			break;

		case EGA_HI_SP:
		case EGA_MED_SP:
		case EGA_LO_SP:
			assert0( !is_it_text(), "In graphics memory mode, but not in graphics mode !!" );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
#endif /* GISP_SVGA */
			if (get_256_colour_mode())
				set_gfx_update_routines(vga_split_graph_update,
					EGA_GRAPHICS_MARKING, NO_SCROLL);
			else
				set_gfx_update_routines(ega_split_graph_update,
					EGA_GRAPHICS_MARKING, NO_SCROLL);
			break;

		case TEXT_40_FUN:
		case TEXT_80_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
#ifdef GISP_SVGA
			videoInfo.modeType = TEXT;
#endif /* GISP_SVGA */
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( text_update, SIMPLE_MARKING, NO_SCROLL );
			host_update_fonts();
			break;
		case CGA_HI_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
#endif /* GISP_SVGA */
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( cga_hi_graph_update, CGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case CGA_MED_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
			set_gfx_update_routines( cga_med_graph_update, CGA_GRAPHICS_MARKING, NO_SCROLL );
			break;
		case EGA_HI_FUN:
		case EGA_MED_FUN:
		case EGA_LO_FUN:
			assert1(NO,"Funny memory organisation selected %s", get_mode_string(mode) );
#ifdef GISP_SVGA
			videoInfo.modeType = GRAPH;
			videoInfo.numPlanes = 4;
#endif /* GISP_SVGA */
			do_display_trace("dumping EGA_GRAPH struct ...", dump_EGA_GRAPH());
#ifdef GORE
			set_gfx_update_routines( process_object_list, EGA_GRAPHICS_MARKING, NO_SCROLL );
#else
			set_gfx_update_routines( ega_graph_update, EGA_GRAPHICS_MARKING, NO_SCROLL );
#endif /* GORE */
			break;
		case DUMMY_FUN:
			assert0(NO,"Using the dummy mode!!");
#ifdef GISP_SVGA
			videoInfo.modeType = UNIMP;
#endif /* GISP_SVGA */
			set_gfx_update_routines( dummy_calc, SIMPLE_MARKING, NO_SCROLL );
			break;
		default:
			assert1(NO,"Bad display mode %d", (int) mode );
#ifdef GISP_SVGA
			videoInfo.modeType = UNIMP;
#endif /* GISP_SVGA */
			break;
	}
#endif  //NEC_98
}


/*
7.INTERMODULE INTERFACE IMPLEMENTATION :

[7.1 INTERMODULE DATA DEFINITIONS]				*/

/*
[7.2 INTERMODULE PROCEDURE DEFINITIONS]				*/



boolean	choose_vga_display_mode()
{
#ifndef NEC_98
	DISPLAY_MODE	mode;

	note_entrance0("choose vga display mode");

	/*
	 * offset_per_line depends upon whether chained addressing is being
	 * used. This is because we interleave the planes, rather than
	 * anything the EGA does.
	 */

	if( get_chain4_mode() )
	{
		set_offset_per_line_recal(get_actual_offset_per_line() << 2);
	}
	else
		if( get_memory_chained() )
		{
			set_offset_per_line_recal(get_actual_offset_per_line() << 1);
		}
		else
		{
			set_offset_per_line_recal(get_actual_offset_per_line());
		}

	/*
	 * It is possible that the display hardware will wrap the plane addressing. This occurs
	 * when the screen_start plus the screen_length are longer than the plane length.
	 * When in chained mode there is two planes length before wrapping occurs.
	 * When in chain 4 mode there is 4 planes length before wrapping occurs.
	 *
	 * V7VGA: No wrapping can occur with either of the sequential chain variants.
	 */

#ifdef V7VGA
	if( !( get_seq_chain4_mode() || get_seq_chain_mode() ))
#endif /* V7VGA */
		if (get_chain4_mode() )
		{
			set_screen_can_wrap( (get_screen_start()<<2)
						+ get_screen_length() > 4*EGA_PLANE_DISP_SIZE );
		}
		else
			if ( get_memory_chained() )
			{
				set_screen_can_wrap( (get_screen_start()<<1)
							+ get_screen_length() > 2*EGA_PLANE_DISP_SIZE );
			}
			else
			{
				set_screen_can_wrap( get_screen_start()
							+ get_screen_length() > EGA_PLANE_DISP_SIZE );
			}

	/*
	 * split screen comes into operation when screen_split is less than screen height
	 * split screen used is used as part of munge_index.
	 */

	set_split_screen_used( get_screen_split() < get_screen_height() );

	/*
	 * For the purposes of choosing a mode set up boolean values for chars per line (to help
	 * select the correct text mode), and screen height (to select EGA resolution).
	 */

	set_200_scan_lines( (get_screen_height()/get_pc_pix_height()) == 200 );

	/*
	 * Set up the appropriate update routine according to the memory organisation selected
	 * and return an indication of whether more than 1 plane can be used by the display.
	 *
	 * Note that in chained mode plane01 is considered to be one plane. Similarly for plane23
	 *
	 * We have to be careful that a nasty program, such as EGA-PICS, hasn't set up a ridiculously big
	 * screen size for the CGA modes (presumably caused by us being unlucky when the timer tick goes off).
	 */
	if(is_it_cga() && get_screen_length() > 0x4000)
#ifdef V7VGA
		/* For the 2 & 4 colour modes 63h & 64h */
		mode = EGA_HI;
#else
		mode = DUMMY_FUN;
#endif /* V7VGA */
	else
		mode = choose_mode[get_munged_index()];

	/*
	 * Now set up screen pointers appropriately.
	 */

	set_up_screen_ptr();

	set_update_routine(mode);

	/*
	 * set up the paint routine to correspond with the memory organisation and the update routine
	 * (this bit is host specific)
	 */

	host_set_paint_routine(mode,get_screen_height());

	/*
	 * The screen needs refreshing, because the update and paint routines have changed.
	 * Indicate to the update routines that the next time they are called, they must update
	 * the whole screen
	 */

	screen_refresh_required();
#endif  //NEC_98
	return TRUE;
}

#endif /* EGG */
#endif /* REAL_VGA */

#if defined(NEC_98)

// NEC98 GARAPHIC UPDATE LOGIC

extern  void    NEC98_graph_update();
extern  void    NEC98_text_graph_update();
extern  void    NEC98_nothing_update();
extern  void    NEC98_nothing_upgrap();
extern  BOOL    compatible_font;
BOOL    select_disp_nothing;
BOOL    once_pal;

boolean choose_NEC98_graph_mode(void)
{
        DISPLAY_MODE    mode;

        select_disp_nothing = FALSE ;
        once_pal = FALSE ;
        if( NEC98GLOBS->read_bank & 1 ){
                set_gvram_ptr ( NEC98GLOBS->gvram_p31_ptr  );
                set_gvram_copy( NEC98GLOBS->gvram_p31_copy );
        }else{
                set_gvram_ptr ( NEC98GLOBS->gvram_p30_ptr  );
                set_gvram_copy( NEC98GLOBS->gvram_p30_copy );
        }
        if( NEC98Display.ggdcemu.lr == 1 ){
                set_gvram_start( (int)(NEC98Display.ggdcemu.sad1*2) );
        }else{
                set_gvram_start( 0x00000000 );
        }
        set_gvram_width( 80 );

        if( get_char_height() == 20 ){
                set_text_lines(20);
        }else{
                set_text_lines(25);
        }

        if( NEC98Display.modeff.dispenable  == FALSE || (NEC98Display.crt_on  == FALSE &&
                 NEC98Display.ggdcemu.startstop  == FALSE ))
        {
                set_gfx_update_routines( NEC98_nothing_upgrap, SIMPLE_MARKING, NO_SCROLL );
                select_disp_nothing = TRUE ;
                mode = NEC98_T25L_G400 ;
                host_set_paint_routine(mode,get_screen_height()) ;
        }else{
                if( NEC98Display.crt_on == TRUE && NEC98Display.ggdcemu.startstop == FALSE )
                {
                set_gfx_update_routines( NEC98_text_update, SIMPLE_MARKING, NO_SCROLL );
                        if( get_char_height() == 20 ){
                                mode = NEC98_TEXT_20L;
                        }else{
                                mode = NEC98_TEXT_25L;
                        }
                }else if( NEC98Display.crt_on  == FALSE && NEC98Display.ggdcemu.startstop == TRUE )
                {
                set_gfx_update_routines( NEC98_graph_update, SIMPLE_MARKING, NO_SCROLL );
                        if( NEC98Display.ggdcemu.lr == 1 ){
                                if(NEC98Display.modeff.graph88==TRUE){
                                        mode = NEC98_GRAPH_200_SLT;
                                }else{
                                        mode = NEC98_GRAPH_200;
                                }
                                set_gvram_length( 0x4000 );
                                set_gvram_height( 200 );
                                set_line_per_char( 200 / get_text_lines());
                        }else{
                                mode = NEC98_GRAPH_400 ;
                                set_gvram_length( 0x8000 );
                                set_gvram_height( 400 );
                                set_line_per_char( 400 / get_text_lines());
                        }
                }else{
                set_gfx_update_routines( NEC98_text_graph_update, SIMPLE_MARKING, NO_SCROLL );
                        if( NEC98Display.ggdcemu.lr==1 ){
                                if(get_char_height()==20){
                                        if(NEC98Display.modeff.graph88==TRUE){
                                                mode = NEC98_T20L_G200_SLT ;
                                        }else{
                                                mode = NEC98_T20L_G200 ;
                                        }
                                        set_line_per_char(10);
                                }else{
                                        if(NEC98Display.modeff.graph88==TRUE){
                                                mode = NEC98_T25L_G200_SLT ;
                                        }else{
                                                mode = NEC98_T25L_G200 ;
                                        }
                                        set_line_per_char(8);
                                }
                                set_gvram_length(0x4000);
                                set_gvram_height(200)   ;
                        }else{
                                if(get_char_height()==20){
                                        mode = NEC98_T20L_G400 ;
                                        set_line_per_char(20);
                                }else{
                                        mode = NEC98_T25L_G400 ;
                                        set_line_per_char(16);
                                }
                                set_gvram_length(0x8000);
                                set_gvram_height(400)   ;
                        }
                }
                host_set_paint_routine(mode,get_screen_height()) ;
                set_gvram_scan((get_gvram_width()*get_gvram_height())/get_screen_height());
                set_screen_length(get_offset_per_line()*get_screen_height()/get_char_height());
        }
        screen_refresh_required() ;
        return(TRUE);
}


boolean choose_NEC98_display_mode(void)
{
        DISPLAY_MODE mode;

        select_disp_nothing = FALSE ;
        once_pal = FALSE ;

        if( get_char_height() == 20 ){
                set_text_lines(20);
        }else{
                set_text_lines(25);
        }

        if( NEC98Display.modeff.dispenable == FALSE ||  NEC98Display.crt_on == FALSE )
        {
                if( compatible_font == FALSE ) set_crt_on(FALSE);
                set_gfx_update_routines( NEC98_nothing_update, SIMPLE_MARKING, NO_SCROLL );
                select_disp_nothing = TRUE;
                if( get_char_height() == 20 ){
                        mode = NEC98_TEXT_20L;
                }else{
                        mode = NEC98_TEXT_25L;
                }
        }else{
                if( compatible_font == FALSE ) set_crt_on(TRUE);
            set_gfx_update_routines( NEC98_text_update, SIMPLE_MARKING, NO_SCROLL );
                if( get_char_height() == 20 ){
                        mode = NEC98_TEXT_20L;
                }else{
                        mode = NEC98_TEXT_25L;
                }
        }
        if( compatible_font == FALSE )  mode = NEC98_TEXT_80;
        set_gvram_width( 80 );
        set_screen_length(get_offset_per_line()*get_screen_height()/get_char_height());
        host_set_paint_routine(mode,get_screen_height());
        screen_refresh_required();
        return(TRUE);
}
#endif  //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\i386\ggdcdraw.asm ===
;ifdef  NEC98                    /*      #endif position = EOF */

;/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
;/*::::::::::::::::    NEC98 GGDC Graphic Draw Emulation  :::::::::::::::*/
;/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

;/*             add making start        NEC NEC98 930623 KBNES 1OA       */

.386p

include ks386.inc
include callconv.inc

_TEXT   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING
_TEXT   ENDS

_DATA   SEGMENT  DWORD USE32 PUBLIC 'DATA'

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
write_one_word  label   dword
        dd      offset  draw_mov        ; replace

draw_one_pixel  label   dword
        dd      offset  draw_and        ; replace
        dd      offset  draw_or         ; replace

draw_one_word   label   dword
        dd      offset  draw_mov        ; replace
        dd      offset  draw_xor        ; complement
        dd      offset  draw_and        ; clear
        dd      offset  draw_or         ; set

draw_0_pixel    label   dword
        dd      offset  draw_and        ; replace
        dd      offset  draw_nop        ; complement
        dd      offset  draw_nop        ; clear
        dd      offset  draw_nop        ; set

draw_1_pixel    label   dword
        dd      offset  draw_or         ; replace
        dd      offset  draw_xor        ; complement
        dd      offset  draw_and        ; clear
        dd      offset  draw_or         ; set

ggdc_dir_func_pixel             label   dword
        dd      offset  pixel_dir_0
        dd      offset  pixel_dir_1
        dd      offset  pixel_dir_2
        dd      offset  pixel_dir_3
        dd      offset  pixel_dir_4
        dd      offset  pixel_dir_5
        dd      offset  pixel_dir_6
        dd      offset  pixel_dir_7

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ggdc_dir_func_word              label   dword
        dd      offset  word_dir_0
        dd      offset  word_dir_1
        dd      offset  word_dir_2
        dd      offset  word_dir_3
        dd      offset  word_dir_4
        dd      offset  word_dir_5
        dd      offset  word_dir_6
        dd      offset  word_dir_7

ggdc_VRAM       dd      00000000H
ggdc_EAD        dd      00000000H
ggdc_PITCH      dd      00000000H
ggdc_DIR        dd      00000000H
ggdc_DC         dw      0000H
ggdc_D          dw      0000H
ggdc_D2         dw      0000H
ggdc_D1         dw      0000H
ggdc_DM         dw      0000H
ggdc_PTN        dw      0000H
ggdc_ZOOM       dw      0000H
ggdc_SL         dw      0000H
ggdc_WG         dw      0000H
ggdc_MASKGDC    dw      0000H
ggdc_TXT        label   byte
                db      00H
                db      00H
                db      00H
                db      00H
                db      00H
                db      00H
                db      00H
                db      00H

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ggdc_MASKCPU    dw      0000H
ggdc_READ       dw      0000H
ZOOM1           dw      0000H
ZOOM2           dw      0000H
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
ggdc_read_back_EAD      dd      00000000H
ggdc_read_back_DAD      dw      0000H
ggdc_CSRR_1             db      00H
ggdc_CSRR_2             db      00H
ggdc_CSRR_3             db      00H
ggdc_CSRR_4             db      00H
ggdc_CSRR_5             db      00H
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
_DATA   ENDS


_TEXT   SEGMENT

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::       NEC98 GGDC Graphic DATA SET      ::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc _ggdc_mod_select,1

        push    ebp                     ; save ebp
        mov     ebp,esp                 ; set up stack frame
                                        ; ebp - n = local data area
                                        ; ebp + 0 = save ebp
                                        ; ebp + 4 = return address
        pushad
;       push    eax                     ; save eax reg
;       push    ebx                     ; save ebx reg

        xor     ebx,ebx                 ; ebx = 0
        mov     eax,[ebp+8]             ; parameter 1 = mod data address
        mov     bl,byte ptr[eax]        ; set mode
        mov     eax,draw_0_pixel[ebx*4] ; select logic
        mov     [draw_one_pixel][0],eax ; save 1dot 0bit
        mov     eax,draw_1_pixel[ebx*4] ; select logic
        mov     [draw_one_pixel][4],eax ; save 1dot 1bit
        mov     eax,draw_one_word[ebx*4]; select logic
        mov     [write_one_word],eax    ; save 1dot 1bit
;       pop     ebx                     ; restore ebx
;       pop     eax                     ; restore eax
        popad

        mov     esp,ebp                 ; restore stack frame
        pop     ebp                     ; restore ebp
        stdRET  _ggdc_mod_select

stdENDP  _ggdc_mod_select

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_send_c_asm,1

        push    ebp
        mov     ebp,esp
        pushad
        mov     esi,[ebp+8]                     ; c   data area
        mov     edi,offset ggdc_VRAM            ; asm data area
        mov     ecx,11                          ; move count
        rep     movsd                           ; 44 bytes data move

        mov     ecx,16                          ;
        mov     dx,[ggdc_MASKGDC]               ; GGDC mask data
@@:     rcr     dx,1                            ; reverse right <-> left
        rcl     ax,1                            ;
        loop    short   @b                      ;
        mov     [ggdc_MASKCPU],ax               ; use CPU drawing

        popad
        pop     ebp
        stdRET          _ggdc_send_c_asm

stdENDP _ggdc_send_c_asm
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_read_back,1

        push    ebp
        mov     ebp,esp
        pushad
        mov     esi,offset ggdc_read_back_EAD   ; copy back data
        mov     edi,[ebp+8]                     ; asm data area
        mov     ecx,11                          ; move count
        rep     movsb                           ; 11 bytes data move
        popad
        pop     ebp
        stdRET  _ggdc_read_back

stdENDP _ggdc_read_back

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw LINE       :::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_drawing_line,0

        pushad                                  ; save all reg

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     ebx,[ggdc_DIR]                  ; ebx = direction next
        mov     cx ,[ggdc_PTN]                  ; cx  = line pattern
        mov     dx ,[ggdc_D]                    ; dx  = vectw param D

draw_line_loop:
        movzx   eax,cx                          ; line pattern set
        and     eax,1                           ; select logic
        ror     cx,1                            ; next pattern
        mov     eax,draw_one_pixel[eax*4]       ; address set
        call    eax                             ; drawing 1 dot

        test    dx, 2000h                       ; D >= 0 ? check bit 13
        jz      short draw_line_pos             ; Yes jump!
        add     dx,[ggdc_D1]                    ; D = D + D1
        movzx   eax,bx                          ; ax = DIR
        test    al,1                            ; DIR LSB = 0 ?
        jnz     short draw_line_inc             ; No!  DIR = DIR + 1
        jmp     short draw_line_dir             ; Yes  DIR = DIR
draw_line_pos:
        add     dx,[ggdc_D2]                    ; D  = D + D2
        movzx   eax,bx                          ; ax = DIR
        test    al,1                            ; DIR LSB = 0 ?
        jnz     short draw_line_dir             ; No! DIR = DIR
draw_line_inc:
        inc     ax                              ; DIR = DIR + 1
        and     ax,7                            ; bound dir 0-->7

draw_line_dir:
        mov     eax,ggdc_dir_func_pixel[eax*4]  ; select dir function
        call    eax                             ; next pixel position

        dec     word ptr[ggdc_DC]               ; loop-1
        jnz     draw_line_loop                  ; 0 ?? next pixel

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET _ggdc_drawing_line

stdENDP _ggdc_drawing_line


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw ARC        :::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_drawing_arc,0

        pushad                                  ; save all reg

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     ebx,[ggdc_DIR]                  ; bx  = direction next
        mov     cx ,[ggdc_PTN]                  ; cx  = mask pattern
        mov     dx ,[ggdc_D]                    ; dx  = vectw param D

        inc     word ptr [ggdc_DM]              ; DM = DM + 1
draw_arc_loop:
        dec     word ptr [ggdc_DM]              ; DM = DM - 1
        jnz     short @f                        ; DM = 0 ? No! jump
        inc     word ptr [ggdc_DM]

        movzx   eax,cx                          ; ax is PTN
        and     ax,1                            ; pattern set
        mov     eax,draw_one_pixel[eax*4]       ; address set
        call    eax                             ; drawing 1 dot
@@:
        ror     cx,1                            ; next pattern
        add     dx,[ggdc_D1]                    ; D = D + D1
        test    dx,2000h                        ; D >= 0 ?
        jz      short draw_arc_pos              ; Yes! jump
        add     dx,[ggdc_D2]                    ; D  = D + D2
        sub     word ptr [ggdc_D2],2            ; D2 = D2 - 2
        mov     eax,ebx                         ; ax = DIR
        test    al,1                            ; DIR LSB = 0 ?
        jz      short draw_arc_inc              ; yes !
        jmp     short draw_arc_dir              ; no  !
draw_arc_pos:
        mov     eax,ebx                         ; ax = DIR
        test    al,1                            ; DIR LSB = 0 ?
        jz      short draw_arc_dir              ; Yes!
draw_arc_inc:
        inc     ax                              ; DIR = DIR + 1
        and     ax,7                            ; bound 7
draw_arc_dir:
        sub     word ptr[ggdc_D1],2             ; D1 = D1 - 2
        mov     eax,ggdc_dir_func_pixel[eax*4]  ; select dir function
        call    eax                             ; next position
        dec     [ggdc_DC]                       ; loop - 1
        jnz     draw_arc_loop                   ; 0 ?? next pixel

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET          _ggdc_drawing_arc

stdENDP         _ggdc_drawing_arc

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw RECT       :::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


cPublicProc     _ggdc_drawing_rect,0

        pushad

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     ebx,[ggdc_DIR]                  ; bx  = direction next
        mov     cx ,[ggdc_PTN]                  ; cx  = mask pattern
        mov     dx ,[ggdc_D]                    ; dx  = vectw param D

draw_rect_loop:
        movzx   eax,cx                          ; ax is PTN
        and     eax,1                           ; set pattern
        mov     eax,draw_one_pixel[eax*4]       ; address set
        call    eax                             ; drawing 1 dot
        ror     cx,1                            ; next pattern

        movzx   ebx,bx                          ; ax = DIR
        mov     eax,ggdc_dir_func_pixel[ebx*4]  ; select dir function
        call    eax                             ; next position

        add     dx,[ggdc_D1]                    ; D = D+1
        test    dx,3fffh                        ; D=0 ?
        jnz     draw_rect_loop                  ; no! next

        test    word ptr[ggdc_DC],1             ; DC LSB = 0
        jnz     short @f                        ; No ! jump
        add     dx,[ggdc_D2]                    ; D = D + D2
        jmp     short draw_rect_dec             ;
@@:
        add     dx,[ggdc_DM]                    ;
draw_rect_dec:
        add     bx,2                            ; DIR = DIR + 2
        and     bx,7                            ; bound 7

        dec     [ggdc_DC]                       ; DC = DC - 1
        jnz     draw_rect_loop                  ; if DC!=0 loop

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET          _ggdc_drawing_rect

stdENDP         _ggdc_drawing_rect


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw PIXEL    :::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_drawing_pixel

        pushad

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     ebx,[ggdc_DIR]                  ; bx  = direction next
        mov     cx ,[ggdc_PTN]                  ; cx  = line pattern

        movzx   eax,cx                          ; set line pattern
        and     eax, 1                          ; pattern ?
        mov     eax,draw_one_pixel[eax*4]       ; select function
        call    eax                             ; draw pixel

        mov     eax,ggdc_dir_func_pixel[ebx*4]  ; select dir function
        call    eax                             ; next position

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET          _ggdc_drawing_pixel

stdENDP         _ggdc_drawing_pixel


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw TEXT     :::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_drawing_text,0

        pushad
        mov     esi,[ggdc_EAD]                  ; esi  = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp  = vram start address
        mov     dx, [ggdc_D]                    ; edx  = D
        mov     ax, [ggdc_ZOOM]                 ; copy zoom
        mov     [ZOOM1],ax                      ; ZW1
        xor     ebx,ebx                         ; TXT start data
        mov     ch,01h                          ; reset PS

text_2nd_dir_loop:

        mov     cl,ggdc_TXT[ebx]                ; get TXn
        inc     ebx                             ; point to next TX
        and     bl,7                            ; bound 7
        mov     ax,[ggdc_ZOOM]                  ; eax = zoom
        mov     [ZOOM2],ax                      ; ZW2 = ZW + 1

text_2nd_dir_zoom:                              ; D times (D2 times)
text_1st_dir_loop:

        mov     al,cl                           ; copy TXn
        test    al,ch                           ; get PS bit
        mov     eax,0                           ; PS bit 1 or 0 ?
        jz      short @f                        ; 0 : EAX = 0
        inc     eax                             ; 1 : EAX = 1
@@:
        mov     eax,draw_one_pixel[eax*4]       ; select function
        call    eax                             ; drawing 1 dot

        dec     word ptr[ZOOM1]                 ; ZW1 = ZW1 - 1
        jnz     short text_1st_zoom_skip        ; ZW1 = 0 ? No!
        mov     ax,[ggdc_ZOOM]                  ; ax  = ZW + 1
        mov     [ZOOM1],ax                      ; ZW1 = ZW + 1
        add     dx,[ggdc_D1]                    ; D = D + D1

        test    dx,3fffh                        ; D = 0 ?
        jz      short text_1st_dir_loop_exit    ; Yes!

        rol     ch, 1                           ; ROL(PS)
        test    word ptr[ggdc_DM],1             ; if LSB(DM)
        jnz     short text_1st_zoom_skip        ;   1 : ROL(PS)
        ror     ch, 2                           ;   0 : ROR(PS)

text_1st_zoom_skip:
        mov     eax,[ggdc_DIR]                  ; get DIR
        mov     eax,ggdc_dir_func_pixel[eax*4]  ; select dir function
        call    eax                             ; calculate next dot address
        jmp     short text_1st_dir_loop         ; while D != 0

text_1st_dir_loop_exit:
        mov     eax,[ggdc_DIR]                  ; get DIR' = DIR
        inc     ax                              ; DIR' = DIR' + 1
        test    word ptr[ggdc_SL],1             ; SL bit check ?
        jnz     short @f                        ;   1 :  DIR' = DIR' + 0
        inc     ax                              ;   0 :  DIR' = DIR' + 1
@@:
        test    word ptr[ggdc_DM],1             ; if LSB(DM)
        jnz     short @f                        ;   1 :  DIR' = DIR' + 0
        add     ax, 4                           ;   0 :  DIR' = DIR' + 4
@@:
        and     eax, 7                          ; normalize DIR'
        mov     eax,ggdc_dir_func_pixel[eax*4]  ; select dir function
        call    eax                             ; calculate next scanline address
        add     [ggdc_DIR],4                    ; DIR = DIR + 4
        and     [ggdc_DIR],7                    ; normalize DIR

        mov     dx,[ggdc_D2]                    ;
        dec     word ptr[ggdc_DM]               ; DM = DM - 1
        dec     word ptr[ZOOM2]                 ; ZOOM2 - 1
        jnz     text_2nd_dir_zoom               ; ZOOM2 != 0

        dec     word ptr[ggdc_DC]               ; DC = DC - 1
        jnz     text_2nd_dir_loop               ; DC != 0

        call    save_ead_dad                    ; last position save
        popad                                   ; restore all reg
        stdRET          _ggdc_drawing_text

stdENDP         _ggdc_drawing_text

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw WRITE    :::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_writing,1

        push    ebp
        mov     ebp,esp
        pushad

        mov     ebx,[ebp+8]                     ; output data address
        mov     bx,word ptr[ebx]                ; output data

        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     edx,[ggdc_DIR]                  ; dx  = direction

        test    [ggdc_WG],1                     ; WG bit on ?
        jnz     short write_text_mode           ;  1: TEXT  mode
                                                ;  0: GRAPH mode
write_graph_mode:
        test    bx,1                            ; check LSB of output data
        jz      short @f                        ;
        mov     eax,[write_one_word]            ;
        call    eax                             ; drawing 1 pixel
@@:
        mov     eax,ggdc_dir_func_pixel[edx*4]  ; select dir function
        call    eax                             ; calculate next dot address
        jmp     short write_end                 ;

write_text_mode:
        mov     ecx,16                          ; change out data
@@:     rcr     bx,1                            ;
        rcl     ax,1                            ; left bit <-> right bit
        loop    @b                              ;
        mov     bx,[ggdc_MASKCPU]               ; save mask data
        and     ax,bx                           ; mask & out data
        mov     [ggdc_MASKCPU],ax               ; ax = mask data

        mov     eax,[write_one_word]            ;
        call    eax                             ; drawing 1 word
        mov     eax,ggdc_dir_func_word[edx*4]   ; select dir function
        call    eax                             ; calculate next dot address

        mov     [ggdc_MASKCPU],bx               ; resrtore dAD/MASK
write_end:
        call    save_ead_dad                    ; last position save
        popad                                   ;
        pop     ebp                             ;
        stdRET          _ggdc_writing

stdENDP         _ggdc_writing

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::    NEC98 GGDC Graphic Draw READ     :::::::::::::::::::
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

cPublicProc     _ggdc_reading,1

        push    ebp
        mov     ebp,esp
        pushad

        mov     ebx,[ebp+8]                     ; return data address
        push    ebx                             ; save it
        mov     esi,[ggdc_EAD]                  ; esi = ggdc start address
        mov     ebp,[ggdc_VRAM]                 ; ebp = vram start address
        mov     edx,[ggdc_DIR]                  ; dx  = direction

        mov     edi,esi                         ; copy ggdc address
        and     edi,0000ffffH                   ; recalc NEC98 vram address bound
        mov     ax,[ebp+edi*2]                  ; read data
        xchg    ah,al                           ; high <-> low

        mov     ecx, 16
@@:     rcr     ax, 1                           ; reverse bits
        rcl     bx, 1                           ; left to right
        loop    short @b                        ; do 16 times
        mov     [ggdc_READ],bx                  ; save data

        test    [ggdc_WG],1                     ; WG check
        jnz     short read_text_mode            ;  1: TEXT mode
                                                ;  0: GRAPHIC mode
read_graph_mode:
        mov     eax,ggdc_dir_func_pixel[edx*4]  ; select dir function
        call    eax                             ; calculate next dot address
        jmp     short read_end

read_text_mode:
        mov     eax,ggdc_dir_func_word[edx*4]   ; select dir function
        call    eax                             ; calculate next dot address

read_end:
        mov     ax,[ggdc_READ]                  ; copy back from tmp
        pop     ebx                             ; data address
        mov     word ptr[ebx],ax                ; return

        call    save_ead_dad                    ; last position save
        popad
        pop     ebp
        stdRET  _ggdc_reading

stdENDP         _ggdc_reading

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
save_ead_dad:

        mov     eax,esi                 ; Last Ead address
        and     eax,0003FFFFH           ; bound GGDC memory area
        mov     [ggdc_read_back_EAD],eax;
        mov     [ggdc_CSRR_1],al        ; return data1
        shr     eax,8                   ;
        mov     [ggdc_CSRR_2],al        ; return data2
        shr     eax,8                   ;
        mov     [ggdc_CSRR_3],al        ; return data3
        mov     ecx,16                  ;
        mov     dx,[ggdc_MASKCPU]       ; GGDC mask data
@@:     rcr     dx,1                    ; reverse right <-> left
        rcl     ax,1                    ;
        loop    short   @b              ;
        mov     [ggdc_read_back_DAD],ax ; use GDC drawing
        mov     [ggdc_CSRR_4],al        ; return data4
        mov     [ggdc_CSRR_5],ah        ; return data5
        ret

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_and                                                              ;
;       input:                                                          ;
;               esi = ggdc address                                      ;
;               ebp = virtual vram start address                        ;
;       destory:                                                        ;
;               eax,edi,flag                                            ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_and:
        public  draw_and

        mov     ax,[ggdc_MASKCPU]       ; set
        xchg    ah,al                   ; change High <-> Low
        not     ax                      ; not
        mov     edi,esi                 ; copy ggdc address
        and     edi,0000ffffH           ; recalc NEC98 vram address bound
        and     [ebp+edi*2],ax          ; draw pixel
        ret                             ; return

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_or                                                               ;
;       input:                                                          ;
;               esi = ggdc address                                      ;
;               ebp = virtual vram start address                        ;
;       destory:                                                        ;
;               eax,edi,flag                                            ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_or:
        public  draw_or

        mov     ax,[ggdc_MASKCPU]       ; set
        xchg    ah,al                   ; change High <-> Low
        mov     edi,esi                 ; copy ggdc address
        and     edi,0000ffffH           ; recalc NEC98 vram address bound
        or      [ebp+edi*2],ax          ; draw pixel
        ret                             ; return

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_xor                                                              ;
;       input:                                                          ;
;               esi = ggdc address                                      ;
;               ebp = virtual vram start address                        ;
;       destory:                                                        ;
;               eax,edi,flag                                            ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_xor:
        public  draw_xor

        mov     ax,[ggdc_MASKCPU]       ; set
        xchg    ah,al                   ; change High <-> Low
        mov     edi,esi                 ; copy ggdc address
        and     edi,0000ffffH           ; recalc NEC98 vram address bound
        xor     [ebp+edi*2],ax          ; draw pixel
        ret                             ; return


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_mov                                                              ;
;       input:                                                          ;
;               esi = ggdc address                                      ;
;               ebp = virtual vram start address                        ;
;       destory:                                                        ;
;               eax,edi,flag                                            ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_mov:
        public  draw_mov

        mov     ax,[ggdc_MASKCPU]       ; set
        xchg    ah,al                   ; change High <-> Low
        mov     edi,esi                 ; copy ggdc address
        and     edi,0000ffffH           ; recalc NEC98 vram address bound
        mov     [ebp+edi*2],ax          ; draw pixel
        ret                             ; return


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; draw_mov                                                              ;
;       input  : none                                                   ;
;       destory: none                                                   ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

draw_nop:
        public  draw_nop

                ret             ; do nothing

;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ggdc_dir_func_pixel                                                   ;
;       input  : none                                                   ;
;       update : esi                                                    ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

pixel_dir_0:
        public  pixel_dir_0

        add     esi,[ggdc_PITCH]                ; move down
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_1:
        public  pixel_dir_1

        add     esi,[ggdc_PITCH]                ; move down
        ror     word ptr [ggdc_MASKCPU],1       ; move right
        adc     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_2:
        public  pixel_dir_2

        ror     word ptr [ggdc_MASKCPU],1       ; move right
        adc     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_3:
        public  pixel_dir_3

        sub     esi,[ggdc_PITCH]                ; move up
        ror     word ptr[ggdc_MASKCPU],1        ; move right
        adc     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_4:
        public  pixel_dir_4

        sub     esi,[ggdc_PITCH]                ; move up
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_5:
        public  pixel_dir_5

        sub     esi,[ggdc_PITCH]                ; move up
        rol     word ptr [ggdc_MASKCPU],1       ; move left
        sbb     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_6:
        public  pixel_dir_6

        rol     word ptr [ggdc_MASKCPU],1       ; move left
        sbb     esi,0                           ; over word?
        ret                                     ; return


;-----------------------------------------------------------------------;
pixel_dir_7:
        public  pixel_dir_7

        add     esi,[ggdc_PITCH]                ; move down
        rol     word ptr [ggdc_MASKCPU],1       ; move left
        sbb     esi,0                           ; over word?
        ret                                     ; return


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ggdc_dir_func_short                                                   ;
;       input  : none                                                   ;
;       destory: esi , dx , flag                                        ;
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

word_dir_0:
        public  word_dir_0

        add     esi,[ggdc_PITCH]        ; move down
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_1:
        public  word_dir_1

        add     esi,[ggdc_PITCH]        ; move down
        inc     esi                     ; move right
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_2:
        public  word_dir_2

        inc     esi                     ; move right
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_3:
        public  word_dir_3

        sub     esi,[ggdc_PITCH]        ; move up
        inc     esi                     ; move right
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_4:
        public  word_dir_4

        sub     esi,[ggdc_PITCH]        ; move up
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_5:
        public  word_dir_5

        sub     esi,[ggdc_PITCH]        ; move up
        dec     esi                     ; move left
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_6:
        public  word_dir_6

        dec     esi                     ; move left
        ret                             ; return


;-----------------------------------------------------------------------;
word_dir_7:
        public  word_dir_7

        add     esi,[ggdc_PITCH]        ; move down
        dec     esi                     ; move left
        ret                             ; return


_TEXT   ENDS
END
;endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\video.c ===
#if (defined(JAPAN) || defined(KOREA)) && !defined(i386)
    #include <windows.h>
#endif // (JAPAN || KOREA)&& !i386
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title : video.c
 *
 * Description : BIOS video internal routines.
 *
 * Author   : Henry Nash
 *
 * Notes : The following functions are defined in this module:
 *
 *                video_init()
 *
 *      vd_set_mode()
 *      vd_set_cursor_mode()
 *      vd_set_cursor_position()
 *      vd_get_cursor_position()
 *      vd_get_light_pen()
 *      vd_set_active_page()
 *      vd_scroll_up()
 *      vd_scroll_down()
 *      vd_read_attrib_char()
 *      vd_write_char_attrib()
 *      vd_write_char()
 *      vd_set_colour_palette()
 *      vd_write_dot()
 *      vd_read_dot()
 *      vd_write_teletype()
 *      vd_get_mode()
 *      vd_write_string()
 *
 *      The above vd_ functions are called by the video_io()
 *      function via a function table.
 *
 */

/*
 * static char SccsID[]="@(#)video.c   1.61 07/03/95 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
    #include "VIDEO_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include <malloc.h>
#include StringH
#include TypesH
#include FCntlH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "sas.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "bios.h"
#include "ios.h"
#include "gmi.h"
#include "gvi.h"
#include "gfx_upd.h"
#include "host.h"
#include "video.h"
#include "cga.h"
#ifdef   EGG
    #include "egacpu.h"
    #include "egaports.h"
#endif   /* EGG */
#include "equip.h"
#include "debug.h"
#include "timer.h"
#ifndef PROD
    #include "trace.h"
#endif
#include "egavideo.h"
#include "host_gfx.h"
#include "cpu_vid.h"
#include "ga_defs.h"
#if defined(JAPAN) || defined(KOREA)
    #include <conapi.h>
    #include "nt_graph.h" // for SetConsoleEUDC()
    #include "egagraph.h" // for SetVram()
#endif // JAPAN || KOREA

#ifdef   EGG
    #define  VD_ROWS_ON_SCREEN sas_hw_at_no_check(vd_rows_on_screen)
#else
    #define VD_ROWS_ON_SCREEN  vd_rows_on_screen
#endif   /* EGG */


#ifdef NTVDM
short    stream_io_dirty_count_32 = 0;
half_word  *   stream_io_buffer = NULL;
boolean  stream_io_enabled = FALSE;
word     stream_io_buffer_size = 0;
word  *  stream_io_dirty_count_ptr = NULL;
    #ifdef MONITOR
sys_addr stream_io_bios_busy_sysaddr;
    #endif

#endif



/*
 * ============================================================================
 * Global data
 * ============================================================================
 *
 * These variables are basically the same as the corresponding gvi_.. variables,
 * but reflect where the BIOS thinks the screen is, rather than where it really is.
 * This was done to fix "dots on screen" problem with EGA-PICS, which changes screen
 * mode behind the BIOS's back.
 */
GLOBAL sys_addr video_pc_low_regen,video_pc_high_regen;

#if defined(JAPAN) || defined(KOREA)
GLOBAL byte Int10Flag[80*50];
GLOBAL byte NtInt10Flag[80*50];

GLOBAL word DosvVramSeg;
GLOBAL word DosvVramOff;
GLOBAL word DosvModeSeg;
GLOBAL word DosvModeOff;
GLOBAL word NtConsoleFlagSeg;
GLOBAL word NtConsoleFlagOff;
GLOBAL word DispInitSeg;
GLOBAL word DispInitOff;
GLOBAL word FullScreenResumeOff;
GLOBAL word FullScreenResumeSeg;
GLOBAL sys_addr DosvVramPtr;
GLOBAL sys_addr DosvModePtr;
GLOBAL sys_addr NtConsoleFlagPtr;
GLOBAL sys_addr SetModeFlagPtr;
GLOBAL int PrevCP = 437;                  // default CP
GLOBAL int DosvVramSize;
    #define DOSV_VRAM_SIZE 8000               // 8/6/1993 V-KazuyS
GLOBAL word textAttr;                   // for screen attributes
#endif

#ifdef JAPAN
GLOBAL int  Int10FlagCnt = 0;

// #4183: status line of oakv(DOS/V FEP) doesn't disappear -yasuho
GLOBAL half_word IMEStatusLines;
#endif

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/* internal function declarations */
LOCAL sys_addr    extend_addr IPT1(sys_addr,addr);
LOCAL half_word fgcolmask IPT1(word, rawchar);
LOCAL word  expand_byte IPT1(word, lobyte);
GLOBAL void    graphics_write_char IPT5(half_word, x, half_word, y, half_word, wchar, half_word, attr, word, how_many);
LOCAL void  M6845_reg_init IPT2(half_word, mode, word, base);
LOCAL void  vd_dummy IPT0();

#ifdef HERC
GLOBAL void herc_alt_sel IPT0();
GLOBAL void herc_char_gen IPT0();
GLOBAL void herc_video_init IPT0();
#endif /* HERC */

void (*video_func[]) () = {
    vd_set_mode,
    vd_set_cursor_mode,
    vd_set_cursor_position,
    vd_get_cursor_position,
    vd_get_light_pen,
    vd_set_active_page,
    vd_scroll_up,
    vd_scroll_down,
    vd_read_attrib_char,
    vd_write_char_attrib,
    vd_write_char,
    vd_set_colour_palette,
    vd_write_dot,
    vd_read_dot,
    vd_write_teletype,
    vd_get_mode,
    vd_dummy,
#ifdef HERC
    herc_char_gen,
    herc_alt_sel,
#else /* !HERC */
    vd_dummy,
    vd_dummy,
#endif /* HERC */
    vd_write_string,
    vd_dummy,
    vd_dummy,
    vd_dummy,
    vd_dummy,
    vd_dummy,
    vd_dummy,
    vd_dummy,
#ifdef VGG
    vga_disp_func,
#else /* !VGG */
    vd_dummy,
#endif /* VGG */
    vd_dummy,
};

unsigned char   valid_modes[] =
{
    ALL_MODES,              /* Mode 0. */
    ALL_MODES,              /* Mode 1. */
    ALL_MODES,              /* Mode 2. */
    ALL_MODES,              /* Mode 3. */
    ALL_MODES,              /* Mode 4. */
    ALL_MODES,              /* Mode 5. */
    ALL_MODES,              /* Mode 6. */
    ALL_MODES,              /* Mode 7. */
    NO_MODES,               /* Mode 8. */
    NO_MODES,               /* Mode 9. */
    NO_MODES,               /* Mode 10. */
    EGA_MODE | VGA_MODE,    /* Mode 11. */
    EGA_MODE | VGA_MODE,    /* Mode 12. */
    EGA_MODE | VGA_MODE,    /* Mode 13. */
    EGA_MODE | VGA_MODE,    /* Mode 14. */
    EGA_MODE | VGA_MODE,    /* Mode 15. */
    EGA_MODE | VGA_MODE,    /* Mode 16. */
    VGA_MODE,               /* Mode 17. */
    VGA_MODE,               /* Mode 18. */
    VGA_MODE,               /* Mode 19. */
};

MODE_ENTRY vd_mode_table[] = {
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,    0x2C,40,16,8,/*Blink|BW*/
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,    0x28,40,16,8,/*Blink*/
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,    0x2D,80,16,8,/*Blink|BW|80x25*/
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,    0x29,80,16,8,/*Blink|80x25*/
    0xB8000L, 0xBFFFFL, VD_CLEAR_GRAPHICS,0x2A,40,4,1,/*Blink|graph*/
    0xB8000L, 0xBFFFFL, VD_CLEAR_GRAPHICS,0x2E,40,4,1,/*Blink|graph|BW*/
    0xB8000L, 0xBFFFFL, VD_CLEAR_GRAPHICS,0x1E,80,2,1,/*640x200|graph|BW*/
    0xB0000L, 0xB7FFFL, VD_CLEAR_TEXT,    0x29,80,0,8,/*MDA:Blink|80x25*/
    0L, 0L, 0,     VD_BAD_MODE,   0,0,0,   /* Never a valid mode */
    0L, 0L ,0,     VD_BAD_MODE,   0,0,0,   /* Never a valid mode */
    0,0,0,         VD_BAD_MODE,   0,0,0,   /* Never a valid mode */
    0xA0000L, 0xAFFFFL, 0,VD_BAD_MODE,0,0,0,/* Mode B - EGA colour font load */
    0xA0000L, 0xAFFFFL, 0,VD_BAD_MODE,0,0,0,/* Mode C - EGA monochrome font load */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,40,16,8,/* 320x200 EGA graphics */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,16,4,/* 640x200 EGA graphics */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,2,2,/* 640x350 EGA 'mono' */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,16,2,/* 640x350 EGA 16 colour */
#ifdef VGG
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,2,1,/* 640x480 EGA++ 2 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,16,1,/* 640x480 EGA++ 16 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,40,256,1,/* 320x200 VGA 256 colour */
#endif
};

#ifdef V7VGA
MODE_ENTRY vd_ext_text_table[] = {
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,80,16,8,/* 80x43 V7VGA 16 colour */
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,132,16,8,/* 132x25 V7VGA 16 colour */
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,132,16,8,/* 132x43 V7VGA 16 colour */
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,80,16,8,/* 80x60 V7VGA 16 colour */
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,100,16,8,/* 100x60 V7VGA 16 colour */
    0xB8000L, 0xBFFFFL, VD_CLEAR_TEXT,VD_BAD_MODE,132,16,8,/* 132x28 V7VGA 16 colour */
};

MODE_ENTRY vd_ext_graph_table[] = {
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,94,16,2,/* 752x410 V7VGA 16 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,90,16,2,/* 720x540 V7VGA 16 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,100,16,2,/* 800x600 V7VGA 16 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,128,2,2,/* 1024x768 V7VGA 2 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,128,4,2,/* 1024x768 V7VGA 4 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,128,16,2,/* 1024x768 V7VGA 16 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,256,1,/* 640x400 V7VGA 256 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,80,256,1,/* 640x480 V7VGA 256 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,90,256,1,/* 720x540 V7VGA 256 colour */
    0xA0000L, 0xAFFFFL, VD_CLEAR_GRAPHICS,VD_BAD_MODE,100,256,1,/* 800x600 V7VGA 256 colour */
};
#endif /* V7VGA */

/*
 * Macros to calculate the offset from the start of the screen buffer
 * and start of page for a given row and column.
 */

#define vd_page_offset(col, row)       ( ((row) * vd_cols_on_screen + (col))<<1)

#define vd_regen_offset(page, col, row)                 \
      ((page) * sas_w_at_no_check(VID_LEN) + vd_page_offset((col), (row)) )

#define vd_high_offset(col, row)   (((row) * ONELINEOFF)+(col))

#define vd_medium_offset(col, row)   (((row) * ONELINEOFF)+(col<<1))

#define vd_cursor_offset(page)                    \
      ( vd_regen_offset(page, sas_hw_at_no_check(VID_CURPOS+2*page), sas_hw_at_no_check(VID_CURPOS+2*page+1)) )

#define GET_CURSOR_POS 3
#define SET_CURSOR_POS 2
#define WRITE_A_CHAR 10

/*
 * Static function declarations.
 */

LOCAL void sensible_text_scroll_down IPT6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr);
LOCAL void sensible_text_scroll_up IPT6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr);
LOCAL void sensible_graph_scroll_up IPT6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr);
LOCAL void sensible_graph_scroll_down IPT6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr);
LOCAL void kinky_scroll_up IPT7(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr, int, vd_cols_on_screen);
LOCAL void kinky_scroll_down IPT7(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr, int, vd_cols_on_screen);

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

#ifdef JAPAN
GLOBAL int dbcs_first[0x100] = {
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 0x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 1x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 2x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 3x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 4x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 5x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 6x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 7x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // 8x
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // 9x
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // Ax
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // Bx
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // Cx
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // Dx
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Ex
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Fx
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE, FALSE, FALSE
};
#elif defined(KOREA) // JAPAN
GLOBAL int dbcs_first[0x100] = {
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 0x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 1x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 2x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 3x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 4x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 5x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 6x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 7x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 8x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, // 9x
    FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
    FALSE, TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Ax
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Bx
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Cx
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Dx
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Ex
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  // Fx
    TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  FALSE
};
#endif // KOREA

#if defined(JAPAN) || defined(KOREA)
GLOBAL int BOPFromDispFlag = FALSE;
GLOBAL int BOPFromNtDisp1Flag = FALSE;
GLOBAL sys_addr DBCSVectorAddr = 0;
GLOBAL word SaveDBCSVector[20];
GLOBAL int DBCSVectorLen = 0;

int is_us_mode()
{
    if (( BOPFromDispFlag == TRUE ) &&  DBCSVectorAddr != 0 &&
        ( sas_w_at_no_check(DBCSVectorAddr) != 0x00 ))
        return (FALSE);   // Not US mode
    else
        return (TRUE);    // US mode
}

void SetDBCSVector( int CP )
{
    int i, j;
    sys_addr ptr;

    #ifdef JAPAN_DBG
    DbgPrint( " SetDBCSVector(%d) BOPFromDispFlag=%d, BOPFromNtDisp1Flag=%d\n", CP, BOPFromDispFlag, BOPFromNtDisp1Flag );
    #endif

    if (!BOPFromDispFlag && !BOPFromNtDisp1Flag)
        return;

    ptr = DBCSVectorAddr;

    if (CP == 437)
    {
        for (i = 0; i < DBCSVectorLen; i++)
        {
            sas_storew_no_check( ptr, 0x0000 );
            ptr += 2;
        }
        for (i = 0; i < 0x100; i++)
        {
            dbcs_first[i] = FALSE;
        }
        // Set cursor mode
        if (!SetConsoleCursorMode( sc.OutputHandle,
                                   TRUE,             // Bringing
                                   FALSE             //  No double byte cursor
                                 ))
        {
            DbgPrint( "NTVDM: SetConsoleCursorMode Error\n" );
        }
    }
    else
    { // CP == 932
        for (i = 0; i < DBCSVectorLen; i++)
        {
            sas_storew_no_check( ptr, SaveDBCSVector[i] );
            ptr += 2;
        }
        for (i = 0, j = 0; i < DBCSVectorLen; i++)
        {
            //DbgPrint( "...%02x.", LOBYTE(SaveDBCSVector[i]) );
            for (; j < LOBYTE(SaveDBCSVector[i]); j++)
            {
                dbcs_first[j] = FALSE;
            }
            //DbgPrint( "...%02x.", HIBYTE(SaveDBCSVector[i]) );
            for (; j <= HIBYTE(SaveDBCSVector[i]); j++)
            {
                dbcs_first[j] = TRUE;
            }
        }
        for (; j < 0x100; j++)
        {
            dbcs_first[j] = FALSE;
        }
        // Set cursor mode
        if (!SetConsoleCursorMode( sc.OutputHandle,
                                   FALSE,            //  No bringing
                                   FALSE             //  No double byte cursor
                                 ))
        {
            DbgPrint( "NTVDM: SetConsoleCursorMode Error\n" );
        }
    }

}

void SetVram()
{

    #ifdef i386
    if (!is_us_mode())
    {
        // set_up_screen_ptr() vga_mode.c
        set_screen_ptr( (byte *)DosvVramPtr );
        // low_set_mode() ega_vide.c
        video_pc_low_regen = DosvVramPtr;
        video_pc_high_regen = DosvVramPtr + DosvVramSize - 1;
        // vga_gc_misc() vga_prts.c
        gvi_pc_low_regen = DosvVramPtr;
        gvi_pc_high_regen = DosvVramPtr + DosvVramSize - 1;
        sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
        // recalc_screen_params() gvi.c
        set_screen_length( DosvVramSize );

        #ifdef JAPAN_DBG
        DbgPrint( "NTVDM: SetVram() video_pc_low_regen %x, high %x, gvi_pc_low_regen %x, high %x len%d\n", video_pc_low_regen, video_pc_high_regen, gvi_pc_low_regen, gvi_pc_high_regen, get_screen_length() );
        #endif
    }
    else
    {
        // set_up_screen_ptr() vga_mode.c
        set_screen_ptr( (IU8*)0xB8000 );
        // low_set_mode() ega_vide.c
        video_pc_low_regen = vd_mode_table[sas_hw_at_no_check(vd_video_mode)].start_addr;
        video_pc_high_regen = vd_mode_table[sas_hw_at_no_check(vd_video_mode)].end_addr;
        // vga_gc_misc() vga_prts.c
        gvi_pc_low_regen = 0xB8000;
        gvi_pc_high_regen = 0xBFFFF;
        sas_connect_memory(gvi_pc_low_regen,gvi_pc_high_regen,(half_word)SAS_VIDEO);
        // recalc_screen_params() gvi.c
        set_screen_length(get_offset_per_line()*get_screen_height()/get_char_height());

        #ifdef JAPAN_DBG
        DbgPrint( "NTVDM: SetVram() video_pc_low_regen %x, high %x, gvi_pc_low_regen %x, high %x len%d\n", video_pc_low_regen, video_pc_high_regen, gvi_pc_low_regen, gvi_pc_high_regen, get_screen_length() );
        #endif
    }
    #endif // i386
}

// IME will change status line with set mode
void SetModeForIME()
{
    word CS_save, IP_save, AX_save;
    half_word video_mode;
    extern UINT ConsoleOutputCP;
    #ifdef X86GFX
    extern word int10_seg, int10_caller;
    #endif // X86GFX

    if (!BOPFromDispFlag)
        return;

    video_mode = sas_hw_at_no_check(vd_video_mode);

    if (video_mode == 0x03 && (UINT)PrevCP != ConsoleOutputCP)
    {

        /* Call int10 handler */
        CS_save = getCS();          /* Save current CS,IP settings */
        IP_save = getIP();
        AX_save = getAX();
        sas_store_no_check( SetModeFlagPtr, 1 );
        setAX((word)video_mode);    /* IME expects setmode */
    #ifdef X86GFX
        exec_sw_interrupt( int10_seg, int10_caller );
    #else // !X86GFX
        setCS(VIDEO_IO_SEGMENT);
        setIP(VIDEO_IO_RE_ENTRY);
        host_simulate();
    #endif // !X86GFX
        sas_store_no_check( SetModeFlagPtr, 0 );
        setCS(CS_save);             /* Restore CS,IP */
        setIP(IP_save);
        setAX(AX_save);
    }
    PrevCP = ConsoleOutputCP;
}
#endif // JAPAN || KOREA

GLOBAL VOID
simple_bios_byte_wrt IFN2(ULONG, ch, ULONG, ch_addr)
{
    *(IU8 *)(getVideoscreen_ptr() + ch_addr) = (UTINY)ch;
#if !defined(EGG) && !defined(C_VID) && !defined(A_VID)
    setVideodirty_total(getVideodirty_total() + 1);
#endif   /* not EGG or C_VID or A_VID */
}

GLOBAL VOID
simple_bios_word_wrt IFN2(ULONG, ch_attr, ULONG, ch_addr)
{
    *(IU8 *)(getVideoscreen_ptr() + ch_addr) = (UTINY)ch_attr;
    *(IU8 *)(getVideoscreen_ptr() + ch_addr + 1) = (UTINY)(ch_attr >> 8);
#if !defined(EGG) && !defined(C_VID) && !defined(A_VID)
    setVideodirty_total(getVideodirty_total() + 1);
#endif   /* not EGG or C_VID or A_VID */
}

/*
 * It is possible for the Hercules to attempt text in graphics mode,
 * relying on our int 10 handler to call itself recursively so a user
 * handler can intercept the write character function.
 */

GLOBAL void vd_set_mode IFN0()
{
    half_word card_mode = 0;
    half_word pag;
    EQUIPMENT_WORD equip_flag;
    word page_size,vd_addr_6845,vd_cols_on_screen;
    UCHAR current_video_mode = getAL();

    if (is_bad_vid_mode(current_video_mode))
    {
        always_trace1("Bad video mode - %d.\n", current_video_mode);
        return;
    }

    /*
     * Set the Video mode to the value in AL
     */
    equip_flag.all = sas_w_at_no_check(EQUIP_FLAG);
    if ((half_word)current_video_mode > VD_MAX_MODE ||
        vd_mode_table[current_video_mode].mode_control_val == VD_BAD_MODE)
    {
#ifndef PROD
        trace(EBAD_VIDEO_MODE, DUMP_REG);
#endif
        return;
    }
    if (equip_flag.bits.video_mode == VIDEO_MODE_80X25_BW)
    {
        vd_addr_6845 = 0x3B4;    /* Index register for B/W M6845 chip */
        sas_store_no_check (vd_video_mode , 7);       /* Force B/W mode */
        card_mode++;
    }
    else
    {
        vd_addr_6845 = 0x3D4;
        if (current_video_mode == 7)
        {
            /*
             * Someone has tried to set the monochrome mode without
             * the monochrome card installed - this can be generated by
             * a 'mode 80' from medium res graphics mode.
             * Take 'I am very confused' type actions by clearing the
             * screen and then disabling video - this is v. similar to
             * the action taken by the PC but with less snow!
             */

            /*
             * Clear the video area
             */
#ifdef REAL_VGA
            sas_fillsw_16(video_pc_low_regen,
                          vd_mode_table[sas_hw_at_no_check(vd_video_mode)].clear_char,
                          (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#else
            sas_fillsw(video_pc_low_regen,
                       vd_mode_table[sas_hw_at_no_check(vd_video_mode)].clear_char,
                       (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif

            /*
             * Force a redraw
             */
            outb(M6845_MODE_REG, card_mode);
            outb(M6845_MODE_REG,
                 (IU8)(vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val | VIDEO_ENABLE));
            /*
             * Turn off the video until another mode command is given
             */
            outb(M6845_MODE_REG,
                 (IU8)(vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val & ~VIDEO_ENABLE));
            return;
        }
        sas_store_no_check (vd_video_mode , current_video_mode);
    }

#ifdef EGG
    sas_store_no_check(vd_rows_on_screen, 24);
#endif
    sas_store_no_check (vd_current_page , 0);

    /*
     * Initialise the Control Register
     */

    outb(M6845_MODE_REG, card_mode);

    /*
     * Set up M6845 registers for this mode
     */

    M6845_reg_init(sas_hw_at_no_check(vd_video_mode), vd_addr_6845);

    /*
     * ... now overwrite the dynamic registers, eg cursor position
     */

    outb(M6845_INDEX_REG, R14_CURS_ADDRH);
    outb(M6845_DATA_REG, 0);
    outb(M6845_INDEX_REG, R15_CURS_ADDRL);
    outb(M6845_DATA_REG, 0);
    /*
     * Clear the video area
     */
#ifdef REAL_VGA
    sas_fillsw_16(video_pc_low_regen, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].clear_char,
                  (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#else
    sas_fillsw(video_pc_low_regen, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].clear_char,
               (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif

    /*
     * re-enable video for this mode
     */
    outb(M6845_MODE_REG, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val);

    if (sas_hw_at_no_check(vd_video_mode) != 7)
    {
        if (sas_hw_at_no_check(vd_video_mode) != 6)
            sas_store_no_check (vd_crt_palette , 0x30);
        else
            sas_store_no_check (vd_crt_palette , 0x3F);
        outb(CGA_COLOUR_REG, sas_hw_at_no_check(vd_crt_palette));
    }

    vd_cols_on_screen = vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_screen_cols;


    /*
     * Update BIOS data variables
     */

    sas_storew_no_check((sys_addr)VID_COLS, vd_cols_on_screen);
    sas_storew_no_check((sys_addr)VID_ADDR, 0);
    sas_storew_no_check((sys_addr)VID_INDEX, vd_addr_6845);
    sas_store_no_check (vd_crt_mode , vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val);
    for (pag=0; pag<8; pag++)
        sas_storew_no_check(VID_CURPOS + 2*pag, 0);
    if (sas_hw_at_no_check(vd_video_mode) == 7)
        page_size = 4096;
    else
        page_size = sas_w_at_no_check(VID_LENS+(sas_hw_at_no_check(vd_video_mode) & 0xE));  /* sneakily divide mode by 2 and use as word address! */
    sas_storew_no_check(VID_LEN,page_size);
}


GLOBAL void vd_set_cursor_mode IFN0()
{
    /*
     * Set cursor mode
     * Parameters:
     *  CX - cursor value (CH - start scanline, CL - stop scanline)
     */
    io_addr vd_addr_6845;

    vd_addr_6845 = sas_w_at_no_check(VID_INDEX);
    outb(M6845_INDEX_REG, R10_CURS_START);
    outb(M6845_DATA_REG, getCH());
    outb(M6845_INDEX_REG, R11_CURS_END);
    outb(M6845_DATA_REG, getCL());

    /*
     * Update BIOS data variables
     */
    sure_sub_note_trace2(CURSOR_VERBOSE,"setting bios cursor vbl to start=%d, end=%d",getCH(),getCL());

    sas_storew_no_check((sys_addr)VID_CURMOD, getCX());
    setAH(0);
}


GLOBAL void vd_set_cursor_position IFN0()
{
    /*
     * Set cursor variables to new values and update the display
     * adaptor registers.
     * The parameters are held in the following registers:
     *
     * DX - row/column of new cursor position
     * BH - page number
     *
     */

    word cur_pos,vd_addr_6845,vd_cols_on_screen;

    /* Load internal variables with the values stored in BIOS
     * data area.
     */

    vd_addr_6845 = sas_w_at_no_check(VID_INDEX);
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);

#if defined(JAPAN) || defined(KOREA)
    // for assist calc installer
    // assist calc installer doesn't set BH register to 0
    // In MS-DOS/V it was only support page number == 0
    // I think $DISP.SYS check to see if BH == 0 or to set BH=0
    // in all Int10 function.
    // Therefore you must check BH register value.

    if (!is_us_mode())
        sas_storew_no_check(VID_CURPOS, getDX()); // same as BH == 0
    else
        sas_storew_no_check(VID_CURPOS+(getBH()*2), getDX());
#else // !JAPAN && !KOREA
    sas_storew_no_check(VID_CURPOS+(getBH()*2), getDX());
#endif // !JAPAN && !KOREA

    if (sas_hw_at_no_check(vd_current_page) == getBH())
    {           /* display if this page */

        /*
         * Calculate position in regen buffer, ignoring attribute bytes
         */

        cur_pos = vd_regen_offset(getBH(), getDL(), getDH());
        cur_pos /= 2;      /* not interested in attributes */

        /*
         * tell the 6845 all about the change
         */
        outb(M6845_INDEX_REG, R14_CURS_ADDRH);
        outb(M6845_DATA_REG,  (IU8)(cur_pos >> 8));
        outb(M6845_INDEX_REG, R15_CURS_ADDRL);
        outb(M6845_DATA_REG,  (IU8)(cur_pos & 0xff));
    }
}


GLOBAL void vd_get_cursor_position IFN0()
{
    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    word vd_cursor_mode;
    half_word vd_cursor_col, vd_cursor_row;

    vd_cursor_mode = sas_w_at_no_check(VID_CURMOD);
    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + getBH()*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + getBH()*2 + 1);

    /*
     * Return the cursor coordinates and mode
     */
    sure_sub_note_trace4(CURSOR_VERBOSE,"returning bios cursor info; start=%d, end=%d, row=%#x, col=%#x",(vd_cursor_mode>>8) & 0xff,vd_cursor_mode & 0xff, vd_cursor_row, vd_cursor_col);

    setDH(vd_cursor_row);
    setDL(vd_cursor_col);
    setCX(vd_cursor_mode);
    setAH(0);
}


GLOBAL void vd_get_light_pen IFN0()
{
    /*
     * Read the current position  of the light pen. Tests light pen switch
     * & trigger & returns AH == 0 if not triggered. (This should always be
     * true in this version) If set (AH == 1) then returns:
     *  DH, DL - row, column of char lp posn.
     *  CH  -  raster line (0-199)
     *  BX  -  pixel column (0-319,639)
     */

    half_word status;

    if (sas_hw_at_no_check(vd_video_mode) == 7)
    {
        setAX(0x00F0);    /* Returned by real MDA */
        return;           /* MDA doesn't support a light pen */
    }

    inb(CGA_STATUS_REG, &status);
    if ((status & 0x6) == 0)
    {   /* Switch & trigger */
        setAH(0);      /* fail */
        return;
    }
    else
    {             /* not supported */
#ifndef PROD
        trace("call to light pen - trigger | switch was on!", DUMP_REG);
#endif
    }
}


GLOBAL void vd_set_active_page IFN0()
{
    /*
     * Set active display page from the 8 (4) available from the adaptor.
     * Parameters:
     *   AL - New active page #
     */

    word cur_pos,vd_addr_6845,vd_crt_start,vd_cols_on_screen;
    half_word vd_cursor_col, vd_cursor_row;
#ifdef V7VGA
    UTINY bank;
#endif

    /* Load internal variables with the values stored in BIOS
     * data area.
     */

    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    vd_addr_6845 = sas_w_at_no_check(VID_INDEX);

    /*   redundancy check against BIOS page number variable removed as it
         was redundant (more checks in the outbs) and caused a bug in
         "image.exe", a 3D drawing package for EGA which itself sets the
         BIOS variable before using this routine to set the active page */

    if (sas_hw_at_no_check(vd_video_mode) > 3 && sas_hw_at_no_check(vd_video_mode) < 8)
        return;  /* Only one page for MDA * CGA graphics */

    sas_store_no_check (vd_current_page , getAL());

#ifdef V7VGA
    /*
     * This function is used by the Video 7 to set the bank for the
     * hi-res V7 graphics modes.
     * For this case, the setting of vd_crt_start etc. seems to be
     * inappropriate.
     */

    if (sas_hw_at_no_check(vd_video_mode) >= 0x14)
    {
        bank = sas_hw_at_no_check(vd_current_page);
        set_banking( bank, bank );

        return;
    }
#endif /* V7VGA */

    /* start of screen */
    vd_crt_start = sas_w_at_no_check(VID_LEN) * sas_hw_at_no_check(vd_current_page);
    /*
     * Update BIOS data variables
     */
    sas_storew_no_check((sys_addr)VID_ADDR, vd_crt_start);

    if (alpha_num_mode())vd_crt_start /= 2; /* WORD address for text modes */

    /*
     * set the start address into the colour adaptor
     */

    outb(CGA_INDEX_REG, CGA_R12_START_ADDRH);
    outb(CGA_DATA_REG, (IU8)(vd_crt_start >> 8));
    outb(CGA_INDEX_REG, CGA_R13_START_ADDRL);
    outb(CGA_DATA_REG, (IU8)(vd_crt_start  & 0xff));

    /*
     * Swap to cursor for this page
     */

    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + sas_hw_at_no_check(vd_current_page)*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + sas_hw_at_no_check(vd_current_page)*2 + 1);

    /*
     * Calculate position in regen buffer, ignoring attribute bytes
     */

    cur_pos = (sas_w_at_no_check(VID_ADDR)+vd_page_offset( vd_cursor_col, vd_cursor_row)) / 2;

    outb(M6845_INDEX_REG, R14_CURS_ADDRH);
    outb(M6845_DATA_REG,  (IU8)(cur_pos >> 8));
    outb(M6845_INDEX_REG, R15_CURS_ADDRL);
    outb(M6845_DATA_REG,  (IU8)(cur_pos & 0xff));

}

GLOBAL void vd_scroll_up IFN0()
{
    /*
     * Scroll up a block of text.  The parameters are held in the following
     * registers:
     *
     * AL - Number of rows to scroll. NB. if AL == 0 then the whole region
     *      is cleared.
     * CX - Row/col of upper left corner
     * DX - row/col of lower right corner
     * BH - attribute to be used on blanked line(s)
     *
     * IMPORTANT MESSAGE TO ALL VIDEO HACKERS:
     * vd_scroll_up() and vd_scroll_down() are functionally identical
     * except for the sense of the scroll - if you find and fix a bug
     * in one, then please do the same for the other
     */
    word vd_cols_on_screen;
    int t_row,b_row,l_col,r_col,lines,attr;
    int rowsdiff,colsdiff;
#ifdef JAPAN
    int text_flag = 0;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);

    t_row = getCH();
    b_row = getDH();
    l_col = getCL();
    r_col = getDL();
    lines = getAL();
    attr = getBH();

#ifdef   JAPAN
    // #4183: status line of oakv(DOS/V FEP) doesn't disappear -yasuho
    // $disp.sys is also be able to scroll in IME status lines.
    if (!is_us_mode())
    {
        if (b_row > VD_ROWS_ON_SCREEN + IMEStatusLines)
            b_row = VD_ROWS_ON_SCREEN + IMEStatusLines;
        if (t_row > VD_ROWS_ON_SCREEN + IMEStatusLines)
            t_row = VD_ROWS_ON_SCREEN + IMEStatusLines;
    }
    else
    {
        if (b_row > VD_ROWS_ON_SCREEN)
            b_row = VD_ROWS_ON_SCREEN;
        if (t_row > VD_ROWS_ON_SCREEN)
            t_row = VD_ROWS_ON_SCREEN;
    }
#else // !JAPAN
    if (b_row > VD_ROWS_ON_SCREEN)
        b_row = VD_ROWS_ON_SCREEN; /* trim to screen size */

    if (t_row > VD_ROWS_ON_SCREEN)
        t_row = VD_ROWS_ON_SCREEN; /* trim to screen size */
#endif // !JAPAN

    if (r_col < l_col)     /* some dipstick has got their left & right mixed up */
    {
        colsdiff = l_col; /* use colsdiff as temp */
        l_col = r_col;
        r_col = colsdiff;
    }

#ifdef JAPAN
    // for HANAKO v2 installer, it sets DL to 0x80 ( >=vd_cols_on_screen)
    // And when app set DL=0x4f, text_scroll should be run
    if (r_col == 0x80 || r_col == 0x4f)
        text_flag = 1;
#endif // JAPAN
    if (r_col >= vd_cols_on_screen)
        r_col = vd_cols_on_screen-1;

    colsdiff = r_col-l_col+1;
    rowsdiff = b_row-t_row+1;

    if (lines == 0)  /* clear region */
    {
        lines = rowsdiff;
    }
#ifdef JAPAN
    // for HANAKO v2 installer, it sets DL to 0x80 ( >=vd_cols_on_screen )
    if (r_col == vd_cols_on_screen-1 && !text_flag)
#else // !JAPAN
    if (r_col == vd_cols_on_screen-1)
#endif // !JAPAN
    {
#ifdef EGG
        if (ega_mode())
            ega_sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
    #ifdef VGG
        else if (vga_256_mode())
            vga_sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
    #endif
        else
#endif
            kinky_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr,vd_cols_on_screen);
    }
    else
    {
        if (alpha_num_mode())
            sensible_text_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#ifdef EGG
    #ifdef VGG
        else if (vga_256_mode())
            vga_sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
    #endif
        else if (ega_mode())
            ega_sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#endif
        else
            sensible_graph_scroll_up(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#ifdef EGA_DUMP
        dump_scroll(sas_hw_at_no_check(vd_video_mode),0,video_pc_low_regen,sas_w_at_no_check(VID_ADDR),sas_w_at_no_check(VID_COLS),
                    t_row,l_col,rowsdiff,colsdiff,lines,attr);
#endif
        /*
         * re-enable video for this mode, if on a CGA adaptor (fixes ROUND42 bug).
         */
        if (video_adapter == CGA)
            outb(CGA_CONTROL_REG, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val);
    }
#ifdef   JAPAN
    // mskkbug#2757 works2.5 garbage remains after exiting install -yasuho
    // We need flush screen when scroll the screen.
    Int10FlagCnt++;
#endif // JAPAN
}

/*
 * Functions to scroll sensible areas of the screen. This routine will try to use
 * host scrolling and clearing.
 */
LOCAL void sensible_text_scroll_up IFN6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    register sys_addr   source, dest;
#if !defined(i386) && defined(JAPAN)
    register sys_addr sourceV, destV;
    int                 linesdiff;
    word attrW = (word)((attr << 8)|' ');
#endif // !i386 && JAPAN
    register int  col_incr,i;
    boolean       screen_updated = FALSE;
    int        vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
#ifdef JAPAN
    // for mskkbug #875
    byte *p = &Int10Flag[t_row * vd_cols_on_screen + l_col];
#endif // JAPAN


    /* Set origin of data movement for calculating screen refresh */

#if defined(JAPAN) && defined(i386)
    // mode73h support
    if (!is_us_mode() && ( sas_hw_at_no_check (DosvModePtr) == 0x73 ))
    {
        source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row)*2 + video_pc_low_regen;

        col_incr = sas_w_at_no_check(VID_COLS) * 4; /* offset to next line */
    }
    else
    {
        source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + video_pc_low_regen;
        col_incr = sas_w_at_no_check(VID_COLS) * 2; /* offset to next line */
    }
#else // !JAPAN || !i386
    source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + video_pc_low_regen;
    #if !defined(i386) && defined(JAPAN)
    sourceV = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + DosvVramPtr;
    #endif // !i386 && JAPAN
    col_incr = sas_w_at_no_check(VID_COLS) * 2; /* offset to next line */
#endif // !JAPAN || !i386

    /* Try to scroll the adaptor memory & host screen. */

    if (source >= get_screen_base())
    {
#if defined(JAPAN) && defined(i386)
        // mode73h support
        if (!is_us_mode() && ( sas_hw_at_no_check (DosvModePtr) == 0x73 ))
        {
            screen_updated = (*update_alg.scroll_up)(source,4*colsdiff,rowsdiff,attr,lines,0);
        }
        else
        {
            screen_updated = (*update_alg.scroll_up)(source,2*colsdiff,rowsdiff,attr,lines,0);
        }
#else // !JAPAN || !i386
        screen_updated = (*update_alg.scroll_up)(source,2*colsdiff,rowsdiff,attr,lines,0);
#endif // !JAPAN || i386
    }

    dest = source;
#if !defined(i386) && defined(JAPAN)
    destV = sourceV;
#endif // !i386 && JAPAN
/*
 * We dont need to move data which would be scrolled off the
 * window. So point source at the first line which needs to
 * be retained.
 *
 * NB if we are just doing a clear, the scroll for loop will
 * terminate immediately.
 */
    source += lines*col_incr;
#if !defined(i386) && defined(JAPAN)
    sourceV += lines*col_incr;
    linesdiff = vd_cols_on_screen * lines;
#endif // !i386 && JAPAN
    for (i = 0; i < rowsdiff-lines; i++)
    {
#ifdef REAL_VGA
        VcopyStr(&M[dest],&M[source], colsdiff*2);
#else
    #ifdef JAPAN
        // for RAID #875
        if (!screen_updated)
        {
            // mode73h support
        #ifdef i386
            if (!is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73 ))
            {
                sas_move_bytes_forward (source, dest, colsdiff*4);
            }
            else
            {
                sas_move_bytes_forward (source, dest, colsdiff*2);
            }

        #else // !i386
            sas_move_bytes_forward (source, dest, colsdiff*2);
            if (!is_us_mode())
                sas_move_bytes_forward (sourceV, destV, colsdiff*2);
        #endif // !i386
            {
                register int i;

                for (i = 0; i < colsdiff; i++)
                {
        #ifdef i386
                    p[i] = ( p[i+vd_cols_on_screen] | INT10_CHANGED );
        #else // !i386
//I think this is correct!!
                    p[i] = ( p[i+linesdiff] | INT10_CHANGED );
        #endif // !i386
                }
            }
        }
    #else // !JAPAN
        if (!screen_updated)
            sas_move_bytes_forward (source, dest, colsdiff*2);
    #endif // !JAPAN
#endif

        /* next line */
        source += col_incr;
        dest += col_incr;
#ifdef JAPAN
    #if !defined(i386)
        sourceV += col_incr;
        destV += col_incr;
    #endif // !i386
        p += vd_cols_on_screen;
#endif // JAPAN
    }

/* moved all the data we were going to move - blank the cleared region */

#if !defined(i386) && defined(JAPAN)
    if (sas_hw_at_no_check(DosvModePtr) == 0x73)
        attrW = 0;
#endif // !i386 && JAPAN

    while (lines--)
    {
#ifdef REAL_VGA
        sas_fillsw_16(dest, (attr << 8)|' ', colsdiff);
#else
    #ifdef JAPAN
        // for mskkbug #875
        if (!screen_updated)
        {
            // mode73h support
        #ifdef i386
            if (!is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
            {
                unsigned long *destptr = (unsigned long *)dest;
                int i;

                for (i = 0; i < colsdiff; i++)
                {
                    *destptr++ = (attr << 8)|' ';
                }
            }
            else
            {
                sas_fillsw(dest, (attr << 8)|' ', colsdiff);
            }
        #else // !i386
            sas_fillsw(dest, (attr << 8)|' ', colsdiff);
            //add Apr. 18 1994 DosvVram holds extended attributes
            if (!is_us_mode())
                sas_fillsw(destV, attrW, colsdiff);
        #endif // !i386
        #ifdef i386
// "p" (Int10Flag) is on 32 bit address space, so we must no use "sas" function
// to access 32 bit address.
            sas_fills( (sys_addr)p, ( INT10_SBCS | INT10_CHANGED ), colsdiff );
        #else // !i386
            {
                register int i = colsdiff;
                register byte *pp = p;
                while (i--)
                {
                    *pp++ = ( INT10_SBCS | INT10_CHANGED );
                }
            }
        #endif // !i386
        }
    #else // !JAPAN
        if (!screen_updated)
            sas_fillsw(dest, (IU16)((attr << 8)|' '), colsdiff);
    #endif // !JAPAN
#endif
        dest += col_incr;
#ifdef JAPAN
    #if !defined(i386)
        destV += col_incr;
    #endif // !i386
        p += vd_cols_on_screen;
#endif // JAPAN
    }
}

LOCAL void sensible_graph_scroll_up IFN6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    sys_addr   source, dest;
    int     i,colour;
    boolean    screen_updated;

    rowsdiff *= 4;    /* 8 scans per char - 4 per bank */
    lines *= 4;    /* scan lines */

    /* Set origin of data movement for calculating screen refresh */

    if (sas_hw_at_no_check(vd_video_mode) != 6)
    {
        colour = attr & 0x3;
        colsdiff *= 2;    /* 4 pixels/byte */

        source = vd_medium_offset(l_col, t_row) + video_pc_low_regen;
    }
    else
    {
        colour = attr & 0x1;
        source = vd_high_offset(l_col, t_row) + video_pc_low_regen;
    }

    /* Try to scroll the adaptor memory & host screen */

    screen_updated = (*update_alg.scroll_up)(source,colsdiff,rowsdiff,attr,lines,colour);

    if (screen_updated && (video_adapter != CGA ))
        return;

    dest = source;

    /*
     * We dont need to move data which would be scrolled off the
     * window. So point source at the first line which needs to
     * be retained.
     *
     * NB if we are just doing a clear, the scroll for loop will
     * terminate immediately.
     */

    source += lines*SCAN_LINE_LENGTH;

    for (i = 0; i < rowsdiff-lines; i++)
    {
#ifdef REAL_VGA
        VcopyStr(&M[dest],&M[source], colsdiff);
#else
        sas_move_bytes_forward (source,dest, colsdiff);
#endif
        /*
         * graphics mode has to cope with odd bank as well
         */
#ifdef REAL_VGA
        VcopyStr(&M[dest+ODD_OFF],&M[source+ODD_OFF], colsdiff);
#else
        sas_move_bytes_forward (source+ODD_OFF,dest+ODD_OFF, colsdiff);
#endif
        source += SCAN_LINE_LENGTH;
        dest += SCAN_LINE_LENGTH;
    }

    /* Moved all the data we were going to move - blank the cleared region */

    while (lines--)
    {
#ifdef REAL_VGA
        sas_fills_16(dest, attr, colsdiff);
        sas_fills_16(dest+ODD_OFF, attr, colsdiff);
#else
        sas_fills(dest, (IU8)attr, colsdiff);
        sas_fills(dest+ODD_OFF, (IU8)attr, colsdiff);
#endif
        dest += SCAN_LINE_LENGTH;
    }
}

/*
 * Handle silly case where the wally programmer is scrolling a daft window.
 * We must be careful not to scribble off the end of the video page, to avoid
 * nasty things like dead MacIIs.
 */
LOCAL void kinky_scroll_up IFN7(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr, int, vd_cols_on_screen)
{
    register sys_addr   source, dest;
    register int  col_incr;
    register int  i;
    half_word is_alpha;

    switch (sas_hw_at_no_check(vd_video_mode))
    {

    case 0:
    case 1:
    case 2:      /* text */
    case 3:
    case 7:
        is_alpha = TRUE;
        /* set origin of data movement for calculating screen refresh */
        source = sas_w_at_no_check(VID_ADDR)+vd_page_offset(l_col, t_row) + video_pc_low_regen;
        col_incr = vd_cols_on_screen * 2;   /* offset to next line */
        break;

    case 6:
    case 4:
    case 5:
        is_alpha = FALSE;
        rowsdiff *= 4;    /* 8 scans per char - 4 per bank */
        lines *= 4;    /* scan lines */
#ifdef NTVDM
        /* mode 4 and 5 have 40 rows with 4 pixels/byte while
         * mode 6 has 80 rows with 8 pixels/byte.
         * They have the same line increment value
         */
        col_incr = SCAN_LINE_LENGTH;
#endif
        if (sas_hw_at_no_check(vd_video_mode) != 6)
        {
            colsdiff *= 2;      /* 4 pixels/byte */
            /* set origin of data movement for calculating screen refresh */
            source = vd_medium_offset(l_col, t_row) + video_pc_low_regen;
        }
        else
            source = vd_high_offset(l_col, t_row) + video_pc_low_regen;

        break;

    default:
#ifndef PROD
        trace("bad video mode\n",DUMP_REG);
#endif
        ;
    }

    dest = source;
/*
 * We dont need to move data which would be scrolled off the
 * window. So point source at the first line which needs to
 * be retained. AL lines ( = lines ) are to be scrolled so
 * add lines*<width> to source pointer - apg
 *
 * NB if we are just doing a clear, the scroll for loop will
 * terminate immediately.
 */
    source += lines*col_incr;
    if (is_alpha)
    {
        for (i = 0; i < rowsdiff-lines; i++)
        {
#ifdef REAL_VGA
            VcopyStr(&M[dest],&M[source], colsdiff*2);
#else
            sas_move_bytes_forward (source,dest, colsdiff*2);
#endif
            /* next line */
            source += col_incr;
            dest += col_incr;
        }
    }
    else
    {
        for (i = 0; i < rowsdiff-lines; i++)
        {
#ifdef REAL_VGA
            VcopyStr(&M[dest],&M[source], colsdiff);
#else
            sas_move_bytes_forward (source,dest, colsdiff);
#endif
            /*
             * graphics mode has to cope with odd bank as well
             */
#ifdef REAL_VGA
            VcopyStr(&M[dest+ODD_OFF],&M[source+ODD_OFF], colsdiff);
#else
            sas_move_bytes_forward (source+ODD_OFF,dest+ODD_OFF, colsdiff);
#endif
            source += SCAN_LINE_LENGTH;
            dest += SCAN_LINE_LENGTH;
        }
    }
    /* moved all the data we were going to move - blank the cleared region */
    if (is_alpha)
    {

        while (lines--)
        {
            if ((dest + 2*colsdiff) > video_pc_high_regen+1)
            {
                colsdiff = (int)((video_pc_high_regen+1-dest)/2);
                lines = 0; /* force termination */
            }
#ifdef REAL_VGA
            sas_fillsw_16(dest, (attr << 8)|' ', colsdiff);
#else
            sas_fillsw(dest, (IU16)((attr << 8)|' '), colsdiff);
#endif
            dest += col_incr;
        }
    }
    else
    {

        while (lines--)
        {
#ifdef REAL_VGA
            sas_fills_16(dest, attr, colsdiff);
            sas_fills_16(dest+ODD_OFF, attr, colsdiff);
#else
            sas_fills(dest, (IU8)attr, colsdiff);
            sas_fills(dest+ODD_OFF, (IU8)attr, colsdiff);
#endif
            dest += SCAN_LINE_LENGTH;
        }
    }

}


GLOBAL void vd_scroll_down IFN0()
{
    /*
     * Scroll down a block of text.  The parameters are held in the following
     * registers:
     *
     * AL - Number of rows to scroll. NB. if AL == 0 then the whole region
     *      is cleared.
     * CX - Row/col of upper left corner
     * DX - row/col of lower right corner
     * BH - attribute to be used on blanked line(s)
     *
     * IMPORTANT MESSAGE TO ALL VIDEO HACKERS:
     * vd_scroll_up() and vd_scroll_down() are functionally identical
     * except for the sense of the scroll - if you find and fix a bug
     * in one, then please do the same for the other
     */
    word vd_cols_on_screen;
    int t_row,b_row,l_col,r_col,lines,attr;
    int rowsdiff,colsdiff;
#ifdef JAPAN
    int text_flag = 0;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);

    t_row = getCH();
    b_row = getDH();
    l_col = getCL();
    r_col = getDL();
    lines = getAL();
    attr = getBH();

#ifdef   JAPAN
    // #4183: status line of oakv(DOS/V FEP) doesn't disappear 12/11/93 yasuho
    // $disp.sys is also be able to scroll in IME status lines.
    if (!is_us_mode())
    {
        if (b_row > VD_ROWS_ON_SCREEN + IMEStatusLines)
            b_row = VD_ROWS_ON_SCREEN + IMEStatusLines;
        if (t_row > VD_ROWS_ON_SCREEN + IMEStatusLines)
            t_row = VD_ROWS_ON_SCREEN + IMEStatusLines;
    }
    else
    {
        if (b_row > VD_ROWS_ON_SCREEN)
            b_row = VD_ROWS_ON_SCREEN;
        if (t_row > VD_ROWS_ON_SCREEN)
            t_row = VD_ROWS_ON_SCREEN;
    }
#else // !JAPAN
    if (b_row > VD_ROWS_ON_SCREEN)
        b_row = VD_ROWS_ON_SCREEN; /* trim to screen size */

    if (t_row > VD_ROWS_ON_SCREEN)
        t_row = VD_ROWS_ON_SCREEN; /* trim to screen size */
#endif // !JAPAN

    if (r_col < l_col)     /* some dipstick has got their left & right mixed up */
    {
        colsdiff = l_col; /* use colsdiff as temp */
        l_col = r_col;
        r_col = colsdiff;
    }

#ifdef JAPAN
    // for HANAKO v2 installer, it sets DL to 0x80 ( >=vd_cols_on_screen)
    // And when app set DL=0x4f, text_scroll should be run
    if (r_col == 0x80 || r_col == 0x4f)
        text_flag = 1;
#endif // JAPAN
    if (r_col >= vd_cols_on_screen)
        r_col = vd_cols_on_screen-1;

    colsdiff = r_col-l_col+1;
    rowsdiff = b_row-t_row+1;

    if (lines == 0)  /* clear region */
    {
        lines = rowsdiff;
    }
#ifdef JAPAN
    // for HANAKO v2 installer
    if (r_col == vd_cols_on_screen-1 && !text_flag)
#else // !JAPAN
    if (r_col == vd_cols_on_screen-1)
#endif // !JAPAN
#ifdef EGG
        if (ega_mode())
            ega_sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
    #ifdef VGG
        else if (vga_256_mode())
            vga_sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
    #endif
        else
#endif
            kinky_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr,vd_cols_on_screen);
    else
    {
        if (alpha_num_mode())
            sensible_text_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#ifdef EGG
        else if (ega_mode())
            ega_sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
    #ifdef VGG
        else if (vga_256_mode())
            vga_sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
    #endif
#endif
        else
            sensible_graph_scroll_down(t_row,l_col,rowsdiff,colsdiff,lines,attr);
#ifdef EGA_DUMP
        dump_scroll(sas_hw_at_no_check(vd_video_mode),1,video_pc_low_regen,sas_w_at_no_check(VID_ADDR),sas_w_at_no_check(VID_COLS),
                    t_row,l_col,rowsdiff,colsdiff,lines,attr);
#endif
        /*
         * re-enable video for this mode, if on a CGA adaptor (fixes ROUND42 bug).
         */
        if (video_adapter == CGA)
            outb(CGA_CONTROL_REG, vd_mode_table[sas_hw_at_no_check(vd_video_mode)].mode_control_val);
    }
#ifdef   JAPAN
    // mskkbug#2757: works2.5: garbage remains after exiting install -yasuho
    // We need flush screen when scroll the screen.
    Int10FlagCnt++;
#endif // JAPAN
}

LOCAL void sensible_text_scroll_down IFN6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    register sys_addr   source, dest;
#if !defined(i386) && defined(JAPAN)
    register sys_addr   sourceV, destV;
    int                 linesdiff;
    word attrW = (word)((attr << 8)|' ');
#endif // !i386 && JAPAN
    register int  col_incr;
    register int  i;
    boolean    screen_updated = FALSE;
    int        vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
#ifdef JAPAN
    // for mskkbug #875
    byte *p = &Int10Flag[ (t_row+rowsdiff-1) * vd_cols_on_screen + l_col];
#endif // JAPAN

#if defined(JAPAN) && defined(i386)
    // mode73h support
    if (!is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
    {
        source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row)*2 + video_pc_low_regen;

        col_incr = sas_w_at_no_check(VID_COLS) * 4; /* offset to next line */
    }
    else
    {
        source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + video_pc_low_regen;
        col_incr = sas_w_at_no_check(VID_COLS) * 2; /* offset to next line */
    }
#else // !JAPAN || !i386
    source = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + video_pc_low_regen;
    col_incr = sas_w_at_no_check(VID_COLS) * 2;
    #if !defined(i386) && defined(JAPAN)
    sourceV = sas_w_at_no_check(VID_ADDR) + vd_page_offset(l_col, t_row) + DosvVramPtr;
    #endif // !i386 && JAPAN
#endif // !386 || !JAPAN

    /* Try to scroll the adaptor memory & host screen. */

    if (source >= get_screen_base())
    {
#if defined(JAPAN) && defined(i386)
        // mode73h support
        if (!is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
        {
            screen_updated = (*update_alg.scroll_up)(source,4*colsdiff,rowsdiff,attr,lines,0);
        }
        else
        {
            screen_updated = (*update_alg.scroll_up)(source,2*colsdiff,rowsdiff,attr,lines,0);
        }
#else // !JAPAN || !i386
        screen_updated = (*update_alg.scroll_down)(source,2*colsdiff,rowsdiff,attr,lines,0);
#endif // !JAPAN || !i386
    }

    dest = source + (rowsdiff-1)*col_incr;
    source = dest - lines*col_incr;
#if !defined(i386) && defined(JAPAN)
    destV = sourceV + (rowsdiff-1)*col_incr;
    sourceV = destV - lines*col_incr;
    linesdiff = vd_cols_on_screen * lines;
#endif // !i386 && JAPAN
/*
 * NB if we are just doing a clear area, the scrolling 'for' loop will terminate immediately
 */

    for (i = 0; i < rowsdiff-lines; i++)
    {
#ifdef REAL_VGA
        VcopyStr(&M[dest],&M[source], colsdiff*2);
#else
    #ifdef JAPAN
        // for mskkbug #875
        if (!screen_updated)
        {
            // mode73h support
        #ifdef i386
            if (!is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
            {
                sas_move_bytes_forward (source, dest, colsdiff*4);
            }
            else
            {
                sas_move_bytes_forward (source, dest, colsdiff*2);
            }

        #else // !i386
            sas_move_bytes_forward (source, dest, colsdiff*2);
            if (!is_us_mode())
                sas_move_bytes_forward( sourceV, destV, colsdiff*2);
        #endif // !i386
            {
                register int i;

                for (i = 0; i < colsdiff; i++)
                {
        #ifdef i386
                    p[i] = ( p[i - vd_cols_on_screen] | INT10_CHANGED );
        #else // !i386
                    //I think this is correct!!
                    p[i] = ( p[i - linesdiff] | INT10_CHANGED );
        #endif // !i386
                }
            }
        }
    #else // !JAPAN
        if (!screen_updated)
            sas_move_bytes_forward (source, dest, colsdiff*2);
    #endif // !JAPAN
#endif
        source -= col_incr;
        dest -= col_incr;
#ifdef JAPAN
    #if !defined(i386)
        sourceV -= col_incr;
        destV -= col_incr;
    #endif // !i386
        p -= vd_cols_on_screen;
#endif // JAPAN
    }

    /* moved all the data we were going to move - blank the cleared region */

#if !defined(i386) && defined(JAPAN)
    if (sas_hw_at_no_check(DosvModePtr) == 0x73)
        attrW = 0;
#endif // !i386 && JAPAN

    while (lines--)
    {
#ifdef REAL_VGA
        sas_fillsw_16(dest, (attr << 8)|' ', colsdiff);
#else
    #ifdef JAPAN
        // for mskkbug #875
        if (!screen_updated)
        {
            // mode73h support
        #ifdef i386
//"dest" is on DOS address space, so we must use "sas" function to access it.
            if (!is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73 ))
            {
                unsigned long *destptr = (unsigned long*)dest;
                int i;

                for (i = 0; i < colsdiff; i++)
                {
                    *destptr++ = (attr << 8)|' ';
                }
            }
            else
            {
                sas_fillsw(dest, (attr << 8)|' ', colsdiff);
            }
        #else // !i386
            sas_fillsw(dest, (attr << 8)|' ', colsdiff);
            if (!is_us_mode())
                sas_fillsw(destV, attrW, colsdiff);
        #endif // !i386
        #ifdef i386
// "p" (Int10Flag) is on 32 bit address space, so we must no use "sas" function
// to access 32 bit address.
            sas_fills( (sys_addr)p, ( INT10_SBCS | INT10_CHANGED ), colsdiff );
        #else // !i386
            {
                register int i = colsdiff;
                register byte *pp = p;
                while (i--)
                {
                    *pp++ = ( INT10_SBCS | INT10_CHANGED );
                }
            }
        #endif // !i386
        }
    #else // !JAPAN
        if (!screen_updated)
            sas_fillsw(dest, (IU16)((attr << 8)|' '), colsdiff);
    #endif // !JAPAN
#endif
        dest -= col_incr;
#ifdef JAPAN
    #if !defined(i386)
        destV -= col_incr;
    #endif // !i386
        p -= vd_cols_on_screen;
#endif // JAPAN
    }
}

LOCAL void sensible_graph_scroll_down IFN6(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr)
{
    sys_addr   source, dest;
    int     i,colour;
    boolean    screen_updated;

    rowsdiff *= 4;    /* 8 scans per char, 4 per bank */
    lines *= 4;

    if (sas_hw_at_no_check(vd_video_mode) != 6)
    {
        colour = attr & 0x3;
        colsdiff *= 2;    /* 4 pixels/byte */

        source = vd_medium_offset(l_col, t_row)+video_pc_low_regen;
    }
    else
    {
        colour = attr & 0x1;
        source = vd_high_offset(l_col, t_row)+video_pc_low_regen;
    }

    /* Try to scroll the host screen */

    screen_updated = (*update_alg.scroll_down)(source,colsdiff,rowsdiff,attr,lines,colour);

    if (screen_updated && ( video_adapter != CGA ))
        return;

    dest = source + (rowsdiff-1)*SCAN_LINE_LENGTH;
    source = dest - lines*SCAN_LINE_LENGTH;

    /*
     * NB if we are just doing a clear area, the scrolling 'for' loop
     * will terminate immediately
     */

    for (i = 0; i < rowsdiff-lines; i++)
    {
        /*
         * graphics mode has to do odd & even banks
         */

#ifdef REAL_VGA
        VcopyStr(&M[dest],&M[source], colsdiff);
        VcopyStr(&M[dest+ODD_OFF],&M[source+ODD_OFF], colsdiff);
#else
        sas_move_bytes_forward (source, dest, colsdiff);
        sas_move_bytes_forward (source+ODD_OFF, dest+ODD_OFF, colsdiff);
#endif
        source -= SCAN_LINE_LENGTH;
        dest -= SCAN_LINE_LENGTH;
    }

    /* moved all the data we were going to move - blank the cleared region */

    while (lines--)
    {
#ifdef REAL_VGA
        sas_fills_16(dest, attr, colsdiff);
        sas_fills_16(dest+ODD_OFF, attr, colsdiff);
#else
        sas_fills(dest, (IU8)attr, colsdiff);
        sas_fills(dest+ODD_OFF, (IU8)attr, colsdiff);
#endif
        dest -= SCAN_LINE_LENGTH;
    }
}

LOCAL void kinky_scroll_down IFN7(int, t_row, int, l_col, int, rowsdiff, int, colsdiff, int, lines, int, attr, int, vd_cols_on_screen)
{
    register sys_addr   source, dest;
    register int  col_incr;
    register int  i;
    half_word is_alpha;

    switch (sas_hw_at_no_check(vd_video_mode))
    {

    case 0:
    case 1:
    case 2:
    case 3:
    case 7:
        is_alpha = TRUE;
        col_incr = vd_cols_on_screen * 2;
        source = sas_w_at_no_check(VID_ADDR)+vd_page_offset(l_col, t_row)+video_pc_low_regen;  /* top left */
        break;

    case 4:
    case 5:
    case 6:
        is_alpha = FALSE;
        rowsdiff *= 4;    /* 8 scans per char, 4 per bank */
        lines *= 4;
        col_incr = SCAN_LINE_LENGTH;
        if (sas_hw_at_no_check(vd_video_mode) != 6)
        {
            colsdiff *= 2;      /* 4 pixels/byte */
            source = vd_medium_offset(l_col, t_row)+video_pc_low_regen;
        }
        else
            source = vd_high_offset(l_col, t_row)+video_pc_low_regen;
        break;

    default:
#ifndef PROD
        trace("bad video mode\n",DUMP_REG);
#endif
        ;
    }

    /* set origin of data movement for calculating screen refresh */
    dest = source + (rowsdiff-1)*col_incr;
    source = dest -lines*col_incr;

    /*
     * NB if we are just doing a clear area, the scrolling 'for' loop
     * will terminate immediately
     */

    if (is_alpha)
    {
        for (i = 0; i < rowsdiff-lines; i++)
        {
#ifdef REAL_VGA
            VcopyStr(&M[dest],&M[source], colsdiff*2);
#else
            sas_move_bytes_forward (source, dest, colsdiff*2);
#endif
            source -= col_incr;
            dest -= col_incr;
        }
    }
    else
    {
        for (i = 0; i < rowsdiff-lines; i++)
        {
#ifdef REAL_VGA
            VcopyStr(&M[dest],&M[source], colsdiff);
#else
            sas_move_bytes_forward (source, dest, colsdiff);
#endif
            /*
             * graphics mode has to do odd & even banks
             */
#ifdef REAL_VGA
            VcopyStr(&M[dest+ODD_OFF],&M[source+ODD_OFF], colsdiff);
#else
            sas_move_bytes_forward (source+ODD_OFF, dest+ODD_OFF, colsdiff);
#endif
            source -= col_incr;
            dest -= col_incr;
        }
    }

    /* moved all the data we were going to move - blank the cleared region */

    if (is_alpha)
    {     /* alpha blank */
        while (lines--)
        {
#ifdef REAL_VGA
            sas_fillsw_16(dest, (attr << 8)|' ', colsdiff);
#else
            sas_fillsw(dest, (IU16)((attr << 8)|' '), colsdiff);
#endif
            dest -= col_incr;
        }
    }
    else
    {        /* graphics blank */

        while (lines--)
        {
#ifdef REAL_VGA
            sas_fills_16(dest, attr, colsdiff);
            sas_fills_16(dest+ODD_OFF, attr, colsdiff);
#else
            sas_fills(dest, (IU8)attr, colsdiff);
            sas_fills(dest+ODD_OFF, (IU8)attr, colsdiff);
#endif
            dest -= col_incr;
        }
    }
}


GLOBAL void vd_read_attrib_char IFN0()
{
    /*
     * Routine to read character and attribute from the current cursor
     * position.
     * Parameters:
     *  AH - current video mode
     *  BH - display page (alpha modes)
     * Returns:
     *  AL - character read
     *  AH - attribute read
     */

    register sys_addr   cpos, cgen;
    register half_word  i, ext_no;
    word         chattr;      /* unfortunately want to take addr */
    word    vd_cols_on_screen;
    half_word          match[CHAR_MAP_SIZE], tmp[CHAR_MAP_SIZE];
    half_word vd_cursor_col, vd_cursor_row;

    /* Load internal variables with the values stored in BIOS
     * data area.
     */

    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + getBH()*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + getBH()*2 + 1);

    if (alpha_num_mode())
    {    /* alpha */
#if defined(JAPAN) && defined(i386)
        // mode73h support
        if (( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
            cpos = video_pc_low_regen + vd_cursor_offset(getBH()) * 2;
        else
#endif // JAPAN && i386
            cpos = video_pc_low_regen + vd_cursor_offset(getBH());
#ifdef A2CPU
        (*read_pointers.w_read)( (ULONG)get_byte_addr(cpos) );
        chattr = (*get_byte_addr (cpos));
        chattr |= (*get_byte_addr (cpos+1)) << 8;
#else
        sas_loadw(cpos,&chattr);
#endif /* A2CPU */
        setAX(chattr);       /* hmm that was easy */
    }
#ifdef EGG
    else if (ega_mode())
        ega_read_attrib_char(vd_cursor_col,vd_cursor_row,getBH());
    #ifdef VGG
    else if (vga_256_mode())
        vga_read_attrib_char(vd_cursor_col,vd_cursor_row,getBH());
    #endif
#endif
    else
    {
        /*
         * graphics not so easy - have to build 8 byte string with all
         * colour attributes masked out then match that in the character
         * generator table (and extended character set if necessary)
         */
        if (sas_hw_at_no_check(vd_video_mode) != 6)
            cpos = video_pc_low_regen
                   + 2 * (((vd_cursor_row * vd_cols_on_screen) << 2) + vd_cursor_col);
        else
            cpos = video_pc_low_regen
                   + vd_high_offset(vd_cursor_col,vd_cursor_row);
        if (sas_hw_at_no_check(vd_video_mode) == 6)
        {   /* high res */
            for (i = 0; i < 4; i++)
            {  /* build 8 byte char string */
                sas_load(cpos, &match[i*2]);
                sas_load(cpos+ODD_OFF, &match[i*2+1]);
                cpos += 80;
            }
        }
        else
        {          /* med res */
            /*
             * Note that in the following, the attribute byte must end
             * up in the LOW byte. That's why the bytes are swapped after the
             * sas_loadw().
             */
            for (i = 0; i < 4; i++)
            {     /* to build char string, must */
                sas_loadw(cpos,&chattr);
                chattr = ((chattr>>8) | (chattr<<8)) & 0xffff;

                /* mask out foreground colour */
                match[i*2] = fgcolmask(chattr);

                sas_loadw(cpos+ODD_OFF,&chattr);
                chattr = ((chattr>>8) | (chattr<<8)) & 0xffff;

                /* mask out foreground colour */
                match[i*2+1] = fgcolmask(chattr);
                cpos += 80;
            }
        }
#ifdef EGG
        if (video_adapter == EGA || video_adapter == VGA)
            cgen = extend_addr(EGA_FONT_INT*4);
        else
            cgen = CHAR_GEN_ADDR;        /* match in char generator */
#else
        cgen = CHAR_GEN_ADDR;         /* match in char generator */
#endif
        if (cgen != 0)
            for (i = 0; i < CHARS_IN_GEN; i++)
            {
                sas_loads (cgen, tmp, sizeof(tmp));
                if (memcmp(tmp, match, sizeof(match)) == 0) /* matched */
                    break;
                cgen += CHAR_MAP_SIZE; /* next char string */
            }
        else
            i = CHARS_IN_GEN;

        if (i < CHARS_IN_GEN)            /* char found */
            setAL(i);
        else
        {
            /*
             * look for char in extended character set
             */
            if ((cgen = extend_addr(BIOS_EXTEND_CHAR*4)) != 0)
                for (ext_no = 0; ext_no < CHARS_IN_GEN; ext_no++)
                {
                    sas_loads (cgen, tmp, sizeof(tmp));
                    if (memcmp(tmp, match, sizeof(match)) == 0) /* matched */
                        break;
                    cgen += CHAR_MAP_SIZE;  /* still valid char len */
                }
            else
                ext_no = CHARS_IN_GEN;

            if (ext_no < CHARS_IN_GEN)      /* match found... */
                setAL((UCHAR)(ext_no + CHARS_IN_GEN));
            else
                setAL(0);         /* no match, return 0 */
        }
    }
}


GLOBAL void vd_write_char_attrib IFN0()
{
/*
* Routine to write character and attribute from the current cursor
* position.
* Parameters:
*  AH - current video mode
*  BH - display page (alpha & EGA modes)
*  CX - # of characters to write
*  AL - Character to write
*  BL - attribute of character to write. If in graphics mode then
*       attribute is foreground colour. In that case if bit 7 of BL
*       is set then char is XOR'ed into buffer.
*/

    register word i, cpos;
    word vd_cols_on_screen;
    half_word vd_cursor_col, vd_cursor_row;
#ifdef JAPAN
    word vram_addr;
    static int DBCSState = FALSE;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + getBH()*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + getBH()*2 + 1);

    if (alpha_num_mode())
    {
#ifdef JAPAN
        // stress test sets cursor over 25line
        if (!is_us_mode())
        {
            if (vd_cursor_row > 25)
                return; // we can't write VRAM!!
        }
    #ifdef i386
        // mode73h support
        if (( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
            cpos = vd_cursor_offset(getBH()) * 2;
        else
    #endif // !i386
#endif // JAPAN
            cpos = vd_cursor_offset(getBH());

#ifdef JAPAN
        // Int10Flag set
        Int10FlagCnt++;
        vram_addr = vd_page_offset(vd_cursor_col,vd_cursor_row)/2;
#endif // JAPAN
        /* place in memory */

#ifdef REAL_VGA
        sas_fillsw_16(video_pc_low_regen + cpos, (getBL() << 8) | getAL(), getCX());
#else
        for (i = 0; i < getCX(); i++)
        {
    #if ( defined(NTVDM) && defined(MONITOR) ) || defined(GISP_SVGA)/* No Ega planes... */
            *((unsigned short *)( video_pc_low_regen + cpos)) = (getBL() << 8) | getAL();
    #else
        #ifdef   EGG
            if (( (video_adapter != CGA) && (EGA_CPU.chain != CHAIN2) )
            #ifdef CPU_40_STYLE
                || (getVM())   /* if we are in V86 mode, the memory may be mapped... */
            #endif
               )
                sas_storew(video_pc_low_regen + cpos, (getBL() << 8) | getAL());
            else
        #endif   /* EGG */
                (*bios_ch2_word_wrt_fn)( (getBL() << 8) | getAL(), cpos );
    #endif   /* NTVDM & MONITOR */
    #if defined(JAPAN) && defined(i386)
            // mode73h support
            if (( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
                cpos += 4;
            else
    #endif // JAPAN && i386
                cpos += 2;
    #ifdef JAPAN
            // Int10Flag set
        #if 0
            DbgPrint( "vd_write_char_attrib: Int10Flag Offset=%04X\n", vram_addr );
        #endif
            if (DBCSState)
            {
                Int10Flag[vram_addr] = INT10_DBCS_TRAILING | INT10_CHANGED;
                DBCSState = FALSE;
            }
            else if (DBCSState = is_dbcs_first( getAL() ))
            {
                Int10Flag[vram_addr] = INT10_DBCS_LEADING | INT10_CHANGED;
            }
            else
            {
                Int10Flag[vram_addr] = INT10_SBCS | INT10_CHANGED;
            }
            vram_addr++;
    #endif // JAPAN
        }
#endif
    }
#ifdef EGG
    else if (ega_mode())
        ega_graphics_write_char(vd_cursor_col,vd_cursor_row,getAL(),getBL(),getBH(),getCX());
    #ifdef VGG
    else if (vga_256_mode())
        vga_graphics_write_char(vd_cursor_col,vd_cursor_row,getAL(),getBL(),getBH(),getCX());
    #endif
#endif
    else
        /* rather more long winded - call common routine as vd_write_char() */
        graphics_write_char(vd_cursor_col, vd_cursor_row, getAL(), getBL(), getCX());
}


GLOBAL void vd_write_char IFN0()
{
    /*
     * Write a character a number of times starting from the current cursor
     * position.  Parameters are held in the following registers.
     *
     * AH - Crt Mode
     * AL - Character to write
     * CX - Number of characters
     * BH - display page
     *
     */

    register word i, cpos;
    word vd_cols_on_screen;
    half_word vd_cursor_col, vd_cursor_row;
#ifdef JAPAN
    static int DBCSState = FALSE;
    word vram_addr;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    vd_cursor_col = sas_hw_at_no_check(VID_CURPOS + getBH()*2);
    vd_cursor_row = sas_hw_at_no_check(VID_CURPOS + getBH()*2 + 1);

    /*
     * handle alphanumeric here:
     */

    if (alpha_num_mode())
    {
#ifdef JAPAN
        // stress test sets cursor over 25line
        if (!is_us_mode())
        {
            if (vd_cursor_row > 25)
                return; // we can't write VRAM!!
        }
    #ifdef i386
        // mode73h support
        if (( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
            cpos = vd_cursor_offset(getBH()) * 2;
        else
    #endif // i386
#endif // JAPAN
            cpos = vd_cursor_offset(getBH());
#ifdef JAPAN
        // Int10Flag set
        Int10FlagCnt++;
        //vram_addr = vd_cursor_offset(getBH()) >> 1;
        vram_addr = vd_page_offset(vd_cursor_col,vd_cursor_row)/2; //7/23/1993 V-KazuyS
#endif // JAPAN

        /* store in memory, skipping attribute bytes */

        for (i = 0; i < getCX(); i++)
        {
#if ( defined(NTVDM) && defined(MONITOR) ) || defined( GISP_SVGA )
            *((unsigned char *)( video_pc_low_regen + cpos)) =  getAL();
#else
    #ifdef   EGG
            if (( (video_adapter != CGA) && (EGA_CPU.chain != CHAIN2) )
        #ifdef CPU_40_STYLE
                || (getVM())   /* if we are in V86 mode, the memory may be mapped... */
        #endif
               )
                sas_store(video_pc_low_regen + cpos, getAL());
            else
    #endif   /* EGG */
                (*bios_ch2_byte_wrt_fn)( getAL(), cpos );
#endif   /* NTVDM & MONITOR */
#if defined(JAPAN) && defined(i386)
            // mode73h support
            if (( !is_us_mode() ) && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
                cpos += 4;
            else
#endif // JAPAN && i386
                cpos += 2;
#ifdef JAPAN
            // Int10Flag set
    #if 0
            DbgPrint( "vd_write_char(%d,%d): Int10Flag Offset=%04X\n", vd_cursor_row, vd_cursor_col, vram_addr );
    #endif
            if (DBCSState)
            {
                Int10Flag[vram_addr] = INT10_DBCS_TRAILING | INT10_CHANGED;
                DBCSState = FALSE;
            }
            else if (DBCSState = is_dbcs_first( getAL() ))
            {
                Int10Flag[vram_addr] = INT10_DBCS_LEADING | INT10_CHANGED;
            }
            else
            {
                Int10Flag[vram_addr] = INT10_SBCS | INT10_CHANGED;
            }
            vram_addr++;
#endif // JAPAN
        }
    }

    /*
     * handle graphics seperately - I know what you're thinking - why pass
     * BL as the attribute when this routine is meant to leave the attribute
     * well alone. Well this is the way it's done in the bios! If it causes
     * problems then we'll need to do a vd_read_char_attr here and then pass the
     * attribute gleaned from that.
     */
#ifdef EGG
    else if (ega_mode())
        ega_graphics_write_char(vd_cursor_col,vd_cursor_row,getAL(),getBL(),getBH(),getCX());
    #ifdef VGG
    else if (vga_256_mode())
        vga_graphics_write_char(vd_cursor_col,vd_cursor_row,getAL(),getBL(),getBH(),getCX());
    #endif
#endif
    else
        graphics_write_char(vd_cursor_col, vd_cursor_row, getAL(), getBL(), getCX());
}


GLOBAL void vd_set_colour_palette IFN0()
{
    /*
     * Set Colo[u]r Palette. Established background, foreground & overscan
     * colours.
     * Parameters:
     *   BH - Colour Id
     *   BL - Colour to set
     *      if BH == 0 background colour set from low bits of BL
     *      if BH == 1 selection made based on low bit of BL
     */

    /* Load internal variables with the values stored in BIOS
     * data area.
     */

    if (getBH() == 1)
    {    /* use low bit of BL */
        sas_store_no_check (vd_crt_palette, (IU8)(sas_hw_at_no_check(vd_crt_palette) & 0xDF));
        if (getBL() & 1)
            sas_store_no_check (vd_crt_palette, (IU8)(sas_hw_at_no_check(vd_crt_palette) | 0x20));
    }
    else
        sas_store_no_check (vd_crt_palette, (IU8)((sas_hw_at_no_check(vd_crt_palette) & 0xE0) | (getBL() & 0x1F)));

    /* now tell the 6845 */
    outb(CGA_COLOUR_REG, sas_hw_at_no_check(vd_crt_palette));

}


GLOBAL void vd_write_dot IFN0()
{
    /*
     * Write dot
     * Parameters:
     *  DX - row (0-349)
     *  CX - column (0-639)
     *  BH - page
     *  AL - dot value; right justified 1,2 or 4 bits mode dependant
     *       if bit 7 of AL == 1 then XOR the value into mem.
     */

    half_word  dotval, data;
    int  dotpos, lsb;         /* dot posn in memory */
    half_word  right_just, bitmask;

#ifdef EGG
    if (ega_mode())
    {
        ega_write_dot(getAL(),getBH(),getCX(),getDX());
        return;
    }
    #ifdef VGG
    else if (vga_256_mode())
    {
        vga_write_dot(getAL(),getBH(),getCX(),getDX());
        return;
    }
    #endif
#endif
    dotpos = getDL();         /* row */

    if (dotpos & 1)        /* set up for odd or even banks */
        dotpos = ODD_OFF-40 + 40 * dotpos;
    else
        dotpos *= 40;

    /*
     * different pixel memory sizes for different graphics modes. Mode 6
     * is high res, mode 4,5 medium res
     */

    dotval = getAL();

    if (sas_hw_at_no_check(vd_video_mode) < 6)
    {
        /*
         * Modes 4 & 5 (medium res)
         */
        dotpos += getCX() >> 2;    /* column offset */
        right_just = (getCL() & 3) << 1;/* displacement in byte */
        dotval = (dotval & 3) << (6-right_just);
        bitmask = (0xC0 >> right_just); /* bits of interest */

#ifdef EGG
        /*
         * EGA & VGA can be told which byte has changed, CGA is
         * only told that screen has changed.
         */
        if (video_adapter != CGA)
            (*update_alg.mark_byte) ( dotpos );
        else
#endif
            setVideodirty_total(getVideodirty_total() + 2);

        /*
         * if the top bit of the value to write is set then value is xor'ed
         * onto the screen, otherwise it is or'ed on.
         */

        if (getAL() & 0x80)
        {
#ifdef   EGG
            if (video_adapter != CGA)
            {
                lsb = dotpos & 1;
                dotpos = (dotpos >> 1) << 2;
                dotpos |= lsb;

                data = EGA_planes[dotpos];
                EGA_planes[dotpos] =  data ^ dotval;
            }
            else
#endif   /* EGG */
            {
                data = *(UTINY *) get_screen_ptr( dotpos );
                *(UTINY *) get_screen_ptr( dotpos ) =
                data ^ dotval;
            }
        }
        else
        {
#ifdef   EGG
            if (video_adapter != CGA)
            {
                lsb = dotpos & 1;
                dotpos = (dotpos >> 1) << 2;
                dotpos |= lsb;

                data = EGA_planes[dotpos];
                EGA_planes[dotpos] = (data & ~bitmask) |
                                     dotval;
            }
            else
#endif   /* EGG */
            {
                data = *(UTINY *) get_screen_ptr( dotpos );
                *(UTINY *) get_screen_ptr( dotpos ) =
                (data & ~bitmask) | dotval;
            }
        }
    }
    else
    {
        /*
         * Mode 6 (hi res)
         */
        dotpos += getCX() >> 3;
        right_just = getCL() & 7;
        dotval = (dotval & 1) << (7-right_just);
        bitmask = (0x80 >> right_just);

#ifdef EGG
        /*
         * EGA & VGA can be told which byte has changed, CGA is
         * only told that screen has changed.
         */
        if (video_adapter != CGA)
            (*update_alg.mark_byte) ( dotpos );
        else
#endif
            setVideodirty_total(getVideodirty_total() + 2);

        /*
         * if the top bit of the value to write is set then value is xor'ed
         * onto the screen, otherwise it is or'ed on.
         */

        if (getAL() & 0x80)
        {
#ifdef   EGG
            if (video_adapter != CGA)
            {
                data = EGA_planes[dotpos << 2];
                EGA_planes[dotpos << 2] =  data ^ dotval;
            }
            else
#endif   /* EGG */
            {
                data = *(UTINY *) get_screen_ptr( dotpos );
                *(UTINY *) get_screen_ptr( dotpos ) =
                data ^ dotval;
            }
        }
        else
        {
#ifdef   EGG
            if (video_adapter != CGA)
            {
                data = EGA_planes[dotpos << 2];
                EGA_planes[dotpos << 2] = (data & ~bitmask) |
                                          dotval;
            }
            else
#endif   /* EGG */
            {
                data = *(UTINY *) get_screen_ptr( dotpos );
                *(UTINY *) get_screen_ptr( dotpos ) =
                (data & ~bitmask) | dotval;
            }
        }
    }
}

extern void ega_read_dot (int, int, int);

GLOBAL void vd_read_dot IFN0()
{
    /*
     * Read dot
     * Parameters:
     *  DX - row (0-349)
     *  CX - column (0-639)
     * Returns
     *  AL - dot value read, right justified, read only
     */

    int  dotpos;        /* dot posn in memory */
    half_word  right_just, bitmask, data;

#ifdef EGG
    if (ega_mode())
    {
        ega_read_dot(getBH(),getCX(),getDX());
        return;
    }
    #ifdef VGG
    else if (vga_256_mode())
    {
        vga_read_dot(getBH(),getCX(),getDX());
        return;
    }
    #endif
#endif
    dotpos = getDL();         /* row */
    if (dotpos & 1)        /* set up for odd or even banks */
        dotpos = ODD_OFF-40 + 40 * dotpos;
    else
        dotpos *= 40;
    /*
     * different pixel memory sizes for different graphics modes. Mode 6
     * is high res, mode 4,5 medium res
     */

    if (sas_hw_at_no_check(vd_video_mode) < 6)
    {
        dotpos += getCX() >> 2;    /* column offset */
        right_just = (3 - (getCL() & 3)) << 1;/* displacement in byte */
        bitmask = 3;         /* bits of interest */
    }
    else
    {
        dotpos += getCX() >> 3;
        right_just = 7 - (getCL() & 7);
        bitmask = 1;
    }
    /*
     * get value of memory at that position, shifted down to bottom of byte
     * Result returned in AL.
     */

    sas_load(video_pc_low_regen+dotpos, &data);
    setAL((UCHAR)(( data >> right_just) & bitmask));
}


#ifdef CPU_40_STYLE

/* Optimisations are not possible, IO virtualisation may be active. */
    #define OUTB(port, val) outb(port, val)

#else

    #ifdef NTVDM
        #define OUTB( port, val ) {  hack=get_outb_ptr(port); \
                             (**hack)(port,val); }
    #else
        #define OUTB( port, val )  (**get_outb_ptr( port ))( port, val )
    #endif /* NTVDM */

#endif /* CPU_40_STYLE */

GLOBAL void vd_write_teletype IFN0()
{
    /*
     * Provide a teletype interface.  Put a character to the screen
     * allowing for scrolling etc.  The parameters are
     *
     * AL - Character to write
     * BL - Foreground colour in graphics mode
     */

    register char ch;
    register sys_addr   ch_addr;
    int        cur_pos;
    word vd_addr_6845 = sas_w_at_no_check(VID_INDEX);
    half_word     scroll_required = FALSE;
    half_word     attrib;
    register half_word  vd_cursor_row,vd_cursor_col;
    word       vd_cols_on_screen;
#ifdef ANSI
    IMPORT VOID (**get_outb_ptr(io_addr))(io_addr address, half_word value);
#else
    IMPORT VOID (**get_outb_ptr())();
#endif
#ifdef NTVDM
    void (** hack)(io_addr address, half_word value);
#endif

    unsigned short savedAX, savedBX, savedCX, savedIP, savedCS, savedDX;
    unsigned short re_entrant = FALSE;
#ifdef JAPAN
    static short dbcs_status = FALSE;
    half_word   move_cursor_lines = 0;
#endif // JAPAN

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    ch = getAL();
    if (stream_io_enabled)
    {
        if (*stream_io_dirty_count_ptr >= stream_io_buffer_size)
            stream_io_update();
        stream_io_buffer[(*stream_io_dirty_count_ptr)++] = ch;
        return;
    }

    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);

#if defined(NTVDM) && defined(MONITOR)
    /*
    ** Tim August 92, Microsoft. Need to change this test, cos INT 10
    ** vector now points into the NTIO.SYS driver on X86.
    */
    {
        extern word int10_seg;

        re_entrant = (sas_w_at_no_check(0x42) != int10_seg);
    }
#else
    #if defined(JAPAN)
    // In case of loading msimei.sys drivers by "devicehigh",
    // re_entrant will be FALSE because msimei.sys hucked Int10 vector.
    // If re_entrant is FALSE ntvdm cannot handle DBCS string correctly.
    {
        register word  SegInt10 = sas_w_at_no_check(0x42);
        re_entrant = ((SegInt10 < 0xa000) || (SegInt10 >= 0xc800));
    }
    #else // !JAPAN
    re_entrant = (sas_w_at_no_check(0x42) < 0xa000);
    #endif // !JAPAN
#endif

    vd_cursor_col = sas_hw_at_no_check(current_cursor_col);
    vd_cursor_row = sas_hw_at_no_check(current_cursor_row);

#ifdef JAPAN
    if (dbcs_status == FALSE)
    {
        if (is_dbcs_first(ch))
        {
            if (vd_cursor_col + 1 == vd_cols_on_screen)
            {
                savedAX = getAX();
                savedBX = getBX();
                setAL( 0x20 );            /* space */
                vd_write_teletype();
                setBX( savedBX );
                setAX( savedAX );
                // get new col and row
                vd_cursor_col = sas_hw_at_no_check(current_cursor_col);
                vd_cursor_row = sas_hw_at_no_check(current_cursor_row);
            }
            dbcs_status = TRUE;
            goto write_char;
        }
    }
    else
    {         /* if kanji second byte then write */
        dbcs_status = FALSE;
        goto write_char;
    }

#endif // JAPAN
    /*
     * First check to see if it is a control character and if so action
     * it here rather than call the write char function.
     */

    switch (ch)
    {
    case VD_BS:         /* Backspace   */
        if (vd_cursor_col != 0)
        {
            vd_cursor_col--;
        }
        break;

    case VD_CR:         /* Return   */
        vd_cursor_col = 0;
        break;

    case VD_LF:         /* Line feed   */
        /* Row only should be checked for == (25-1), so in principle
         * it ignores LF off the top of the screen.
         */
#ifdef JAPAN
        // scroll problem when start VDM 24line with $IAS.SYS
    #ifdef JAPAN_DBG
// DbgPrint("LF---vd_row=%d, VD_ROWS=%d\n", vd_cursor_row, VD_ROWS_ON_SCREEN );
    #endif
        if (vd_cursor_row > VD_ROWS_ON_SCREEN)
        {
            move_cursor_lines = vd_cursor_row - VD_ROWS_ON_SCREEN;
            if (move_cursor_lines >= VD_ROWS_ON_SCREEN)   // 8/28/1993
                move_cursor_lines =  0; //VD_ROWS_ON_SCREEN - 1; // Stress test
            vd_cursor_row = VD_ROWS_ON_SCREEN;
            scroll_required = TRUE;
        }
        else
#endif // JAPAN
            if (vd_cursor_row == VD_ROWS_ON_SCREEN)
            scroll_required = TRUE;
        else
            vd_cursor_row++;
        break;

    case VD_BEL:        /* Bell     */
        host_ring_bell(BEEP_LENGTH);
        return;         /* after all, shouldn't cause a scroll */

    default:
#ifdef JAPAN
        write_char:
#endif // JAPAN
        /*
         * It's a real character, place it in the regen buffer.
         */
        if (alpha_num_mode())
        {
            if (re_entrant)
            {
                savedAX = getAX();
                savedBX = getBX();
                savedCX = getCX();
                savedIP = getIP();
                savedCS = getCS();

                setAH(WRITE_A_CHAR);
                setBH(sas_hw_at_no_check(vd_current_page));
                setCX(1);

#if defined(NTVDM) && defined(X86GFX)
                /*
                ** Tim August 92 Microsoft. INT 10 caller code is now
                ** in NTIO.SYS
                */
                {
                    extern word int10_seg, int10_caller;

                    exec_sw_interrupt( int10_seg, int10_caller );
                }
#else
                setCS(VIDEO_IO_SEGMENT);
                setIP(VIDEO_IO_RE_ENTRY);
                host_simulate();

#endif   /* NTVDM & MONITOR */

                /*
                 * Note: Always make sure CS comes before IP
                 */
                setCS(savedCS);
                setIP(savedIP);
                setCX(savedCX);
                setBX(savedBX);
                setAX(savedAX);
            }
            else
            {
#if defined(JAPAN) && defined(i386)
                // alpha always uses EGA plane.
                // mode73h support
                if (!is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73 ))
                {
    #ifdef JAPAN_DBG
                    DbgPrint( "@" );
    #endif
                    ch_addr = sas_w_at_no_check(VID_ADDR) +
                              vd_page_offset(vd_cursor_col,vd_cursor_row) * 2;
                }
                else
                {
                    ch_addr = sas_w_at_no_check(VID_ADDR) +
                              vd_page_offset(vd_cursor_col,vd_cursor_row);
                }
#else // !JAPAN || !i386
                ch_addr = sas_w_at_no_check(VID_ADDR) +
                          vd_page_offset(vd_cursor_col,vd_cursor_row);
#endif // !JAPAN && !i386

                /*
                 * Call the C code to do the biz rather than brothel
                 * around in SAS.
                 */

#if ( defined(NTVDM) && defined(MONITOR) ) || defined( GISP_SVGA )
                *((unsigned char *)( video_pc_low_regen + ch_addr)) = ch;
#else
    #ifdef   EGG
                if (( (video_adapter != CGA) && (EGA_CPU.chain != CHAIN2) )
        #ifdef CPU_40_STYLE
                    || (getVM())   /* if we are in V86 mode, the memory may be mapped... */
        #endif
                   )
                    sas_store(video_pc_low_regen + ch_addr, ch);
                else
    #endif   /* EGG */
                    (*bios_ch2_byte_wrt_fn)( ch, ch_addr );
#endif   /* ( NTVDM & MONITOR ) | GISP_SVGA */
            }
        }
#ifdef EGG
        else if (ega_mode())
            ega_graphics_write_char(vd_cursor_col, vd_cursor_row, ch, getBL(),sas_hw_at_no_check(vd_current_page), 1);
    #ifdef VGG
        else if (vga_256_mode())
            vga_graphics_write_char(vd_cursor_col, vd_cursor_row, ch, getBL(),sas_hw_at_no_check(vd_current_page), 1);
    #endif
#endif
        else
            graphics_write_char(vd_cursor_col, vd_cursor_row, ch, getBL(), 1);

        vd_cursor_col++;
        /*
         * Now see if we have gone off the edge of the screen
         */

        if (vd_cursor_col == vd_cols_on_screen)
        {
            vd_cursor_col = 0;

            /* Row only should be checked for == (25-1) and
             * only if there was a line wrap.
             */
#ifdef JAPAN
            // scroll problem when start VDM 24line with $IAS.SYS
    #ifdef JAPAN_DBG
// DbgPrint("col==80 --vd_row=%d, VD_ROWS=%d\n", vd_cursor_row, VD_ROWS_ON_SCREEN );
    #endif
            if (vd_cursor_row > VD_ROWS_ON_SCREEN)
            {
                move_cursor_lines = vd_cursor_row - VD_ROWS_ON_SCREEN;
                if (move_cursor_lines >= VD_ROWS_ON_SCREEN)   // 8/28/1993
                    move_cursor_lines =  0; //VD_ROWS_ON_SCREEN - 1; // Stress test
                vd_cursor_row = VD_ROWS_ON_SCREEN;
                scroll_required = TRUE;
            }
            else
#endif // JAPAN
                if (vd_cursor_row == VD_ROWS_ON_SCREEN)
                scroll_required = TRUE;
            else
                vd_cursor_row++;
        }

        /* cursor_row validity actually never checked unless processing a
         * Line Feed or a wrapping at the end of line.
    *
    * The BYTE "text" benchmark program contains an off-by-one error
    * which causes it to set the cursor position off the end of the
    * screen: SoftPC was incorrectly deciding to scroll, with consequent
    * horrendous time penalties...
    */
    }

    /*
     * By this point we have calculated the new cursor position
     * so output the cursor position and the character
     */

    if (alpha_num_mode())
    {
#ifdef REAL_VGA
        /*
         * tell the 6845 all about the change
         */
        cur_pos = (sas_w_at_no_check(VID_ADDR)+vd_page_offset(vd_cursor_col,
                                                              vd_cursor_row))>>1; /* Word address, not byte */
        outb(vd_addr_6845, R14_CURS_ADDRH);
        outb(vd_addr_6845+1,  cur_pos >> 8);
        outb(vd_addr_6845, R15_CURS_ADDRL);
        outb(vd_addr_6845+1,  cur_pos & 0xff);
        /*
         * save the current cursor position in the bios
         */
        sas_store_no_check(current_cursor_col, vd_cursor_col);
        sas_store_no_check(current_cursor_row , vd_cursor_row);
#else
        if (re_entrant)
        {
            savedAX = getAX();
            savedBX = getBX();
            savedDX = getDX();
            savedIP = getIP();
            savedCS = getCS();

            setAH(SET_CURSOR_POS);
            setBH(sas_hw_at_no_check(vd_current_page));
            setDH(vd_cursor_row);
            setDL(vd_cursor_col);

    #if defined(NTVDM) && defined(X86GFX)
            /*
            ** Tim August 92 Microsoft. INT 10 caller code is now
            ** in NTIO.SYS
            */
            {
                extern word int10_seg, int10_caller;

                exec_sw_interrupt( int10_seg, int10_caller );
            }
    #else
            setCS(VIDEO_IO_SEGMENT);
            setIP(VIDEO_IO_RE_ENTRY);
            host_simulate();

    #endif   /* NTVDM & MONITOR */

            /*
             * Note: Always make sure CS comes before IP
             */

            setCS(savedCS);
            setIP(savedIP);
            setDX(savedDX);
            setBX(savedBX);
            setAX(savedAX);
        }
        else
        {
            /*
          ** tell the 6845 all about the change
          */

            /* Set the current position - word address, not byte */
            cur_pos = (sas_w_at_no_check(VID_ADDR) +
                       vd_page_offset(vd_cursor_col, vd_cursor_row)) >> 1;

            OUTB(M6845_INDEX_REG, R14_CURS_ADDRH);
            OUTB(M6845_DATA_REG,  (IU8)(cur_pos >> 8));
            OUTB(M6845_INDEX_REG, R15_CURS_ADDRL);
            OUTB(M6845_DATA_REG,  (IU8)(cur_pos & 0xff));

            /*
            * store the new cursor position in the
            * bios vars (this should be done by the re-entrant
            * code called above)
            */
            sas_store_no_check (current_cursor_col , vd_cursor_col);
            sas_store_no_check (current_cursor_row , vd_cursor_row);

        }
#endif
    }
    else
    {
        /*
        * store the new cursor position in the
        * bios vars for graphics mode
        */
        sas_store_no_check (current_cursor_col , vd_cursor_col);
        sas_store_no_check (current_cursor_row , vd_cursor_row);
    }

    if (scroll_required)
    {
        /*
         * Update the memory to be scrolled
         */
        if (alpha_num_mode())
        {
#ifdef A2CPU
            ch_addr = video_pc_low_regen + sas_w_at_no_check(VID_ADDR)+vd_page_offset(vd_cursor_col,vd_cursor_row) + 1;
            (*read_pointers.b_read)( (ULONG)get_byte_addr(ch_addr) );
            attrib = (*get_byte_addr (ch_addr));
#else
            sas_load( video_pc_low_regen + sas_w_at_no_check(VID_ADDR)+vd_page_offset(vd_cursor_col,vd_cursor_row) + 1, &attrib);
#endif /* A2CPU */

#ifdef JAPAN
    #ifdef JAPAN_DBG
//               DbgPrint("Scroll_required!!!\n" );
    #endif
            sensible_text_scroll_up( 0, 0,
                                     VD_ROWS_ON_SCREEN + 1 + move_cursor_lines,
                                     vd_cols_on_screen,
                                     1 + move_cursor_lines,
                                     attrib);
            // #3920: CR+LFs are needed when using 32bit cmd in command.com
            // 12/9/93 yasuho
            Int10FlagCnt++;
#else // !JAPAN
            sensible_text_scroll_up(0,0, VD_ROWS_ON_SCREEN+1,vd_cols_on_screen,1,attrib);
#endif // !JAPAN

        }
#ifdef EGG
        else if (ega_mode())
            ega_sensible_graph_scroll_up(0,0, VD_ROWS_ON_SCREEN+1,vd_cols_on_screen,1,0);
    #ifdef VGG
        else if (vga_256_mode())
            vga_sensible_graph_scroll_up(0,0, VD_ROWS_ON_SCREEN+1,vd_cols_on_screen,1,0);
    #endif
#endif
        else  /* graphics mode */

            sensible_graph_scroll_up(0,0, VD_ROWS_ON_SCREEN+1,vd_cols_on_screen,1,0);

#ifdef EGA_DUMP
        if (!alpha_num_mode())attrib=0;
        dump_scroll(sas_hw_at_no_check(vd_video_mode),0,video_pc_low_regen,sas_w_at_no_check(VID_ADDR),sas_w_at_no_check(VID_COLS),
                    0,0,vd_rows_on_screen+1,vd_cols_on_screen,1,attrib);
#endif

    }
}

GLOBAL void vd_write_string IFN0()
{
    /*
     * AL = write mode (0-3)
     *      Specical for NT: if AL = 0xff then write character string
     *      with existing attributes.
     * BH = page
     * BL = attribute (if AL=0 or 1)
     * CX = length
     * DH = Y coord
     * DL = x coord
     * ES:BP = pointer to string.
     *
     *  NB. This routine behaves very strangely wrt line feeds etc -
     *  These ALWAYS affect the current page!!!!!
     */
    int i,op;
    UCHAR col,row;
    USHORT len;
    UCHAR save_col,save_row;
    sys_addr ptr;
    boolean ctl;
#ifdef NTVDM
    word  count, avail;
#endif
#ifdef JAPAN
    // Big fix for multiplan
    // ntraid:mskkbug#2784: Title of VJE-PEN is strange
    // ntraid:mskkbug#3014: VJE-PEN: function keys don't work on windowed
    // 11/5/93 yasuho
    // Don't broken AX, BX, DX register !!
    IU16 saveAX, saveBX, saveDX;
#endif // JAPAN

    op = getAL();

#ifdef NTVDM
    if (op == 0xff)                 /* Special for MS */
    {

        if (stream_io_enabled)
        {
            count = getCX();
            avail = stream_io_buffer_size - *stream_io_dirty_count_ptr;
            ptr = effective_addr(getES(), getDI());
            if (count <= avail)
            {
                sas_loads(ptr, stream_io_buffer + *stream_io_dirty_count_ptr, count);
                *stream_io_dirty_count_ptr += count;
            }
            else
            {   /* buffer overflow */
                if (*stream_io_dirty_count_ptr)
                {
                    stream_io_update();
                }
                while (count)
                {
                    if (count >= stream_io_buffer_size)
                    {
                        sas_loads(ptr, stream_io_buffer, stream_io_buffer_size);
                        *stream_io_dirty_count_ptr = stream_io_buffer_size;
                        stream_io_update();
                        count -= stream_io_buffer_size;
                        ptr += stream_io_buffer_size;
                    }
                    else
                    {
                        sas_loads(ptr, stream_io_buffer, count);
                        *stream_io_dirty_count_ptr = count;
                        break;
                    }
                }
            }

            setAL(1);
            return;
        }

        if (sas_hw_at_no_check(vd_video_mode) < 4)  /* text mode */
        {
            ptr = effective_addr(getES(), getDI());
            /* sudeepb 28-Sep-1992 taken out for int10h/13ff fix */
            /* vd_set_cursor_position(); */   /* set to start from DX */
            for (i = getCX(); i > 0; i--)
            {
                setAL(sas_hw_at_no_check(ptr));
                vd_write_teletype();
                ptr++;
            }
            setAL(1);       /* success - string printed */
        }
        else
        {
            setAL(0);       /* failure */
        }
        return;
    }

    #ifdef X86GFX
    else if (op == 0xfe)
    {
        disable_stream_io();
        return;
    }
    #endif

#endif   /* NTVDM */

#ifdef JAPAN
    // DOS/V function support
    if (op == 0x10)
    {
        unsigned short *Offset;
        int i;
        unsigned long addr;

        // DbgPrint( "\nNTVDM: INT 10 AH=13, AL=%02x\n", op );
        addr = ( getES() << 4 ) + getBP();
        col = getDL();
        row = getDH();
        len = getCX();

        // mode73h support
    #ifdef i386
        if (!is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73))
            Offset = (unsigned short*)get_screen_ptr( row * get_bytes_per_line()*2 + (col * 4) );
        else
            Offset = (unsigned short*)get_screen_ptr( row * get_bytes_per_line() + (col * 2) );
    #else // !i386
        if (is_us_mode())
            return;          //In us mode, do nothing

        Offset = get_screen_ptr( row * get_bytes_per_line()*2 + (col * 4) );
    #endif  // !i386

        //assert1( len >= 0, "vd_write_string len=%x\n", len );
        //DbgPrint( "\nread_str len=%d ADDR:%04x ", len, addr );
        for (i = len; i > 0; i--)
        {
            sas_storew_no_check( addr, *Offset );
            //DbgPrint( " %04x", (*Offset) );
            addr += 2;
    #ifdef i386
            if (!is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73))
                Offset += 2;
            else
                Offset++;
    #else // !i386
            Offset += 2;
    #endif  // !i386
        }
        return;
    }
    else if (op == 0x11)
    {
        // copy from op == 0x10
        unsigned short *Offset;
        int i;
        unsigned long addr;

    #ifdef i386
        if (sas_hw_at_no_check(DosvModePtr) != 0x73 || is_us_mode())
    #else // !i386
        if (is_us_mode())
            // In us mode, videomode 73h has no meaning.
    #endif  // !i386     REAL DOS/V acts like this.
            return;

        // DbgPrint( "\nNTVDM: INT 10 AH=13, AL=%02x\n", op );
        addr = ( getES() << 4 ) + getBP();
        col = getDL();
        row = getDH();
        len = getCX();

        Offset = (unsigned short*) get_screen_ptr( row * (get_bytes_per_line()*2) + (col * 4) );
        assert1( len >= 0, "vd_write_string len=%x\n", len );
        //DbgPrint( "\nread_str len=%d ADDR:%04x ", len, addr );
        for (i = len; i > 0; i--)
        {
            sas_storew_no_check( addr, *Offset ); // char, attr1
            addr += 2;
            Offset++;
            sas_storew_no_check( addr, *Offset ); // attr2, attr3
            addr += 2;
            Offset++;
        }
        return;
    }
    else if (op == 0x20)
    {
        // copy from original routine, and delete ctl check
    #ifndef i386
        if (is_us_mode())
            return;        // In us mode, do nothing.

    #endif // !i386
        ptr = effective_addr( getES(), getBP() );
        col = getDL();
        row = getDH();
        len = getCX();
        saveAX = getAX();
        saveBX = getBX();
        saveDX = getDX();
        vd_get_cursor_position();
        save_col = getDL(); save_row = getDH();
        setCX( 1 );
        setDL( col ); setDH( row );
        for (i = len; i > 0; i--)
        {
            vd_set_cursor_position();
            setAL( sas_hw_at_no_check( ptr++ ) );
            setBL( sas_hw_at_no_check( ptr++ ) );
            vd_write_char_attrib();

            if (++col >= sas_w_at_no_check(VID_COLS))
            {
                if (++row > VD_ROWS_ON_SCREEN)
                {
                    //setAL( 0xa );
                    //vd_write_teletype();
                    row--;
                }
                col = 0;
            }
            setDL( col ); setDH( row );
        }
        // restore cursor position
        setDL( save_col ); setDH( save_row );
        vd_set_cursor_position();
        setCX( len );
        setDX( saveDX );
        setAX( saveAX );
        setBX( saveBX );
        return;
    }
    else if (op == 0x21)
    {
        // 5/27/1993 V-KazuyS
        // copy from 0x20 routine

        unsigned short *Offset;

    #ifdef i386
        if (sas_hw_at_no_check(DosvModePtr) != 0x73 || is_us_mode())
            return;
    #else // !i386
        register sys_addr Vptr = DosvVramPtr;
        if (is_us_mode()) //In us mode, videomode 73h is meanless.
            return;
    #endif // !i386

        ptr = effective_addr( getES(), getBP() );
        col = getDL();
        row = getDH();
        len = getCX();
        saveAX = getAX();
        saveBX = getBX();
        saveDX = getDX();
        Offset = (unsigned short*)get_screen_ptr( row * (get_bytes_per_line()*2) + (col * 4) );
    #ifndef i386
        // we now use DosvVram to hold extended attribute
        Vptr += row * get_bytes_per_line() + (col *2);
    #endif // !i386
        vd_get_cursor_position();
        save_col = getDL(); save_row = getDH();
        setCX( 1 );
        setDL( col ); setDH( row );
        for (i = len; i > 0; i--)
        {
            vd_set_cursor_position();
            setAL( sas_hw_at_no_check( ptr++ ) );
            setBL( sas_hw_at_no_check( ptr++ ) );
            vd_write_char_attrib();

            // V-KazuyS copy ext. attrib
            Offset++;
            *Offset = sas_w_at_no_check( ptr );
    #ifndef i386
            sas_move_bytes_forward(ptr, Vptr, 2);
            Vptr += 2;
    #endif // !i386
            ptr += 2;                      // Attrib 2 byte
            Offset++;

            if (++col >= sas_w_at_no_check(VID_COLS))
            {
                if (++row > VD_ROWS_ON_SCREEN)
                {
                    row--;
                }
                col = 0;
            }
            setDL( col ); setDH( row );
        }
        // restore cursor position
        setDL( save_col ); setDH( save_row );
        vd_set_cursor_position();
        setCX( len );
        setDX( saveDX );
        setAX( saveAX );
        setBX( saveBX );
        return;
    }
#endif // JAPAN
    ptr =  effective_addr(getES(),getBP()) ;
    col = getDL();
    row = getDH();
    len = getCX();
    vd_get_cursor_position();
    save_col = getDL(); save_row = getDH();
    setCX(1);
    setDL(col); setDH(row);
    vd_set_cursor_position();
    for (i=len;i>0;i--)
    {
        ctl = sas_hw_at_no_check(ptr) == 7 || sas_hw_at_no_check(ptr) == 8 || sas_hw_at_no_check(ptr) == 0xa || sas_hw_at_no_check(ptr) == 0xd;
        setAL(sas_hw_at_no_check(ptr++));
        if (op > 1)setBL(sas_hw_at_no_check(ptr++));
        if (ctl)
        {
            vd_write_teletype();
            vd_get_cursor_position();
            col = getDL(); row = getDH();
            setCX(1);
        }
        else
        {
            vd_write_char_attrib();
            if (++col >= sas_w_at_no_check(VID_COLS))
            {

                if (++row > VD_ROWS_ON_SCREEN)
                {
                    setAL(0xa);
                    vd_write_teletype();
                    row--;
                }
                col = 0;
            }
            setDL(col); setDH(row);
        }
        vd_set_cursor_position();
    }
    if (op==0 || op==2)
    {
        setDL(save_col); setDH(save_row);
        vd_set_cursor_position();
    }
}


GLOBAL void vd_get_mode IFN0()
{
    /*
     * Returns the current video mode.  Registers are set up viz:
     *
     * AL - Video mode
     * AH - Number of columns on screen
     * BH - Current display page
     */

    word vd_cols_on_screen;
    half_word   video_mode;

    /* Load internal variables with the values stored in BIOS
     * data area.
     */
    vd_cols_on_screen = sas_w_at_no_check(VID_COLS);
    video_mode = sas_hw_at_no_check(vd_video_mode);

    setAL(video_mode);
    setAH((UCHAR)vd_cols_on_screen);
    setBH(sas_hw_at_no_check(vd_current_page));
}


/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

/*
 * function to return the (host) address stored at Intel address 'addr'
 * or 0 if not present
 */
LOCAL sys_addr extend_addr IFN1(sys_addr,addr)
{
    word  ext_seg, ext_off; /* for segment & offset addrs */

    /* get vector */
    ext_off = sas_w_at_no_check(addr);
    ext_seg = sas_w_at_no_check(addr+2);
    /* if still defaults then no extended chars */
    if (ext_seg == EXTEND_CHAR_SEGMENT && ext_off == EXTEND_CHAR_OFFSET)
        return (0);  /* no user set char gen table */
    else
        return ( effective_addr( ext_seg , ext_off ) );
}


/*
* routine to establish the foreground colour mask for the appropriate
* medium res. word forming part (1/8th) of the char.
* See vd_read_attrib_char() above.
*/
LOCAL half_word fgcolmask IFN1(word, rawchar)
{
    register word mask, onoff = 0;

    mask = 0xC000;    /* compare with foreground colour */
    onoff = 0;
    do
    {
        if ((rawchar & mask) == 0) /* not this bit, shift */
            onoff <<= 1;
        else
            onoff = (onoff << 1) | 1;  /* set this bit */
        mask >>= 2;
    } while (mask);    /* 8 times thru loop */
    return ((half_word)onoff);
}


/*
* double all bits in lower byte of 'lobyte' into word.
* Have tried to speed this up using ffs() to only look at set bits but
* add overhead while calculating result shifts
*/
LOCAL word expand_byte IFN1(word, lobyte)
{
    register word mask = 1, res = 0;

    while (mask)
    {
        res |= lobyte & mask;   /* set res bit if masked bit in lobyte set*/
        lobyte <<= 1;
        mask <<= 1;
        res |= lobyte & mask;   /* and duplicate */
        mask <<= 1;    /* next bit */
    }
    return (res);
}


/*
* Routine to do 'how_many' char writes of 'wchar' with attribute 'attr' from
* position (x,y) in graphics mode
*/
GLOBAL void graphics_write_char IFN5(half_word, x, half_word, y, half_word, wchar, half_word, attr, word, how_many)
{
    register sys_addr   gpos; /* gpos holds character address &...*/
    register sys_addr   cpos; /*cpos steps through scanlines for char*/
    register word j, colword,  colmask;
    register sys_addr   iopos, char_addr;
    register half_word  i, xor;
    half_word     current;

    /*
     * if the high bit of the attribute byte is set then xor the char
     * onto the display
     */
    xor = (attr & 0x80) ? 1 : 0;
    if (wchar >= 128)
    {   /* must be in user installed extended char set */
        if ((char_addr = extend_addr(4*BIOS_EXTEND_CHAR)) == 0)
        {
#ifndef PROD
            trace("want extended char but no ex char gen set \n",DUMP_REG);
#endif
            return;
        }
        else
            char_addr += (wchar - 128) * CHAR_MAP_SIZE;
    }
#ifdef EGG
    else if (video_adapter == EGA || video_adapter == VGA)
        char_addr = extend_addr(EGA_FONT_INT*4)+ CHAR_MAP_SIZE *wchar;
#endif
    else
        char_addr = CHAR_GEN_ADDR+ CHAR_MAP_SIZE *wchar; /* point to entry in std set */

    if (sas_hw_at_no_check(vd_video_mode) == 6)
    {        /* high res */

        gpos = vd_high_offset(x, y);  /* sys & host memory offsets */
        gpos += video_pc_low_regen;

        for (j = 0; j < how_many; j++)
        {      /* number of chars to store */
            cpos = gpos++;         /* start of this character */
            for (i = 0; i < 4; i++)
            {     /* 8 bytes per char */
                if (xor)
                {     /* XOR in char */
                    sas_load(cpos, &current); /* even bank */
                    sas_store(cpos, (IU8)(current ^ sas_hw_at_no_check(char_addr + i*2)));
                    sas_load(cpos+ODD_OFF, &current);
                    current ^= sas_hw_at_no_check(char_addr + i*2+1);
                }
                else
                {            /* just store new char */
                    sas_store(cpos, sas_hw_at_no_check(char_addr + i*2));
                    current = sas_hw_at_no_check(char_addr + i*2+1);
                }
                sas_store(cpos+ODD_OFF, current);   /* odd bank */
                cpos += SCAN_LINE_LENGTH;        /* next scan line */
            }
        }
    }

    else
    {           /* medium res */

        gpos = vd_medium_offset(x, y);   /* sys & host memory offsets */
        gpos += video_pc_low_regen;

        /* build colour mask from attribute byte */
        attr &= 3;        /* only interested in low bits */
        colmask = attr;         /* replicate low bits across word */
        for (i = 0; i < 3; i++)
            colmask = (colmask << 2) | attr;
        colmask = (colmask << 8) | colmask;

        for (j = 0; j < how_many; j++)
        {
            cpos = gpos;
            gpos += 2;
            for (i = 0; i < 8; i++)
            {     /* 16 bytes per char */

                if ((i & 1) == 0)    /* setup for odd/even bank */
                    iopos = cpos;
                else
                {
                    iopos = cpos+ODD_OFF;
                    cpos += SCAN_LINE_LENGTH; /* next scan line */
                }

                colword = expand_byte(sas_hw_at_no_check(char_addr + i));  /*char in fg colour*/
                colword &= colmask;
                if (xor)
                {                  /* XOR in char */
                    sas_load(iopos, &current);
                    sas_store(iopos++, (IU8)(current ^ (colword >> 8)));
                    sas_load(iopos, &current);
                    sas_store(iopos, (IU8)(current ^ (colword & 0xFF)));
                }
                else
                {                 /* just store char */
                    sas_store(iopos++, (IU8)((colword >> 8)));
                    sas_store(iopos, (IU8)((colword & 0xFF)));
                }
            }
        }
        how_many *= 2;
    }
}


/*
 * Initialise the M6845 registers for the given mode.
 */

LOCAL void M6845_reg_init IFN2(half_word, mode, word, base)
{
    UCHAR i, table_index;

    switch (mode)
    {
    case 0:
    case 1:  table_index = 0;
        break;
    case 2:
    case 3:  table_index = NO_OF_M6845_REGISTERS;
        break;
    case 4:
    case 5:
    case 6:  table_index = NO_OF_M6845_REGISTERS * 2;
        break;
    default: table_index = NO_OF_M6845_REGISTERS * 3;
        break;
    }

    for (i = 0; i < NO_OF_M6845_REGISTERS; i++)
    {
        /*
         * Select the register in question via the index register (== base)
         * and then output the actual value.
         */

        outb(base, i);
        outb((IU16)(base + 1), (IU8)(sas_hw_at_no_check(VID_PARMS+table_index + i)));
    }
}

LOCAL void vd_dummy IFN0()
{
}

#ifdef REAL_VGA
/* STF */
GLOBAL sas_fillsw_16 IFN3(sys_addr, address, word, value, sys_addr, length)
{
    register word *to;

    to = (word *)&M[address];
    while (length--)
        *to++ = value;
}

GLOBAL sas_fills_16 IFN3(sys_addr, address, half_word, value, sys_addr, length)
{
    register half_word *to;

    to = (half_word *)&M[address];
    while (length--)
        *to++ = value;
}
/* STF */

GLOBAL VcopyStr IFN3(half_word *, to, half_word *, from, int, len)
{
    while (len--)
        *to++ = *from++;
}
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
    #include "SOFTPC_INIT.seg"
#endif

GLOBAL void video_init IFN0()
{
    UCHAR mode;
    word vd_addr_6845;
    word curmod;
#ifdef HERC
    EQUIPMENT_WORD equip_flag;
#endif /* HERC */


    /*
     * Initialise BIOS data area variables
     */

    curmod = 0x607;  /* default cursor is scans 6-7 */

    switch (video_adapter)
    {
    case MDA:
        mode = 0x7;
        vd_addr_6845  = 0x3B4;
        video_pc_low_regen = MDA_REGEN_START;
        video_pc_high_regen = MDA_REGEN_END;
        break;
#ifdef HERC
    case HERCULES:
        /* put the BW card in the equipment list */
        equip_flag.all = sas_w_at_no_check(EQUIP_FLAG);
        equip_flag.bits.video_mode = VIDEO_MODE_80X25_BW;
        sas_storew_no_check(EQUIP_FLAG, equip_flag.all);
        mode = 0x7;
        vd_addr_6845  = 0x3B4;
        video_pc_low_regen = HERC_REGEN_START;
        video_pc_high_regen = HERC_REGEN_END;
        herc_video_init();
        curmod = 0xb0c;   /* cursor is scans 11-12 */
        break;
#endif /* HERC */
#ifdef EGG
    case EGA:
    case VGA:
        mode = 0x3;
        vd_addr_6845  = 0x3D4;
        sas_storew_no_check(VID_INDEX, vd_addr_6845);
        sure_sub_note_trace0(CURSOR_VERBOSE,"setting bios vbls start=6, end=7");
        sas_storew_no_check(VID_CURMOD, 0x607);
        setAL(mode);
        ega_video_init();
        return;
        break;
#endif
    default: /* Presumably CGA */
        video_pc_low_regen = CGA_REGEN_START;
        video_pc_high_regen = CGA_REGEN_END;
        mode = 0x3;
        vd_addr_6845  = 0x3D4;
    }

    sas_storew_no_check(VID_INDEX, vd_addr_6845);
    sure_sub_note_trace2(CURSOR_VERBOSE,"setting bios vbls start=%d, end=%d",
                         (curmod>>8)&0xff, curmod&0xff);
    sas_storew_no_check(VID_CURMOD, curmod);

    /* Call vd_set_mode() to set up 6845 chip */
    setAL(mode);
    (video_func[SET_MODE])();
}

#ifdef HERC
GLOBAL void herc_video_init IFN0()
{

/* Initialize the INTs */
    sas_storew(BIOS_EXTEND_CHAR*4, EGA_INT1F_OFF);
    sas_storew(BIOS_EXTEND_CHAR*4+2, EGA_SEG);
    sas_move_bytes_forward(BIOS_VIDEO_IO*4, 0x42*4, 4);  /* save old INT 10 as INT 42 */
    #ifdef GISP_SVGA
    if ((ULONG) config_inquire(C_GFX_ADAPTER, NULL) == CGA)
        sas_storew(int_addr(0x10), CGA_VIDEO_IO_OFFSET);
    else
    #endif      /* GISP_SVGA */
        sas_storew(BIOS_VIDEO_IO*4, VIDEO_IO_OFFSET);
    sas_storew(BIOS_VIDEO_IO*4+2, VIDEO_IO_SEGMENT);


/* Now set up the EGA BIOS variables */
    sas_storew(EGA_SAVEPTR,VGA_PARMS_OFFSET);
    sas_storew(EGA_SAVEPTR+2,EGA_SEG);
    sas_store(ega_info, 0x00);   /* Clear on mode change, 64K, EGA active, emulate cursor */
    sas_store(ega_info3, 0xf9);  /* feature bits = 0xF, EGA installed, use 8*14 font */
    set_VGA_flags(S350 | VGA_ACTIVE | VGA_MONO);
    host_memset(EGA_planes, 0, 4*EGA_PLANE_SIZE);
    host_mark_screen_refresh();
    init_herc_globals();
    load_herc_font(EGA_CGMN,256,0,0,14);   /* To initialize font */
}


GLOBAL void herc_char_gen IFN0()
{
    switch (getAL())
    {
    case 3:
        break;
    case 0:
    case 0x10:
        load_herc_font(effective_addr(getES(),getBP()),getCX(),getDX(),getBL(),getBH());
        if (getAL()==0x10)
            recalc_text(getBH());
        break;
    case 1:
    case 0x11:
        load_herc_font(EGA_CGMN,256,0,getBL(),14);
        if (getAL()==0x11)
            recalc_text(14);
        break;

    case 0x30:
        setCX(sas_hw_at(ega_char_height));
        setDL(VD_ROWS_ON_SCREEN);
        switch (getBH())
        {
        case 0:
            setBP(sas_w_at(BIOS_EXTEND_CHAR*4));
            setES(sas_w_at(BIOS_EXTEND_CHAR*4+2));
            break;
        case 1:
            setBP(sas_w_at(EGA_FONT_INT*4));
            setES(sas_w_at(EGA_FONT_INT*4+2));
            break;
        case 2:
            setBP(EGA_CGMN_OFF);
            setES(EGA_SEG);
            break;

        default:
            assert2(FALSE,"Illegal char_gen subfunction %#x %#x",getAL(),getBH());
        }
        break;
    default:
        assert1(FALSE,"Illegal char_gen %#x",getAL());
    }
}

GLOBAL load_herc_font IFN5(sys_addr, table, int, count, int, char_off, int, font_no, int, nbytes)
{
    register int i, j;
    register host_addr font_addr;
    register sys_addr data_addr;
    SAVED word font_off[] = { 0, 0x4000, 0x8000, 0xc000, 0x2000, 0x6000, 0xa000, 0xe000};

    /*
     * Work out where to put the font. We know where
     * it's going to end up in the planes so ...
     */

    font_addr = &EGA_planes[FONT_BASE_ADDR] +
                (font_off[font_no] << 2) + (FONT_MAX_HEIGHT*char_off << 2);
    data_addr = table;

    assert2( FALSE, "Font No. = %4d, No. of Bytes/char. def. = %4d", font_no, nbytes );

    for (i=0; i<count; i++)
    {

        for (j=0; j<nbytes; j++)
        {
            *font_addr = sas_hw_at(data_addr++);
            font_addr += 4;
        }

        font_addr += ((FONT_MAX_HEIGHT - nbytes) << 2);
    }

    host_update_fonts();
}

GLOBAL void herc_alt_sel IFN0()
{
    /*
     * The code previously here caused *ALL* Hercules Display AutoDetect
* programs to fail and to believe that the adaptor is an EGA Mono -vs-
* Hercules. It was designed to allow International Code Pages for DOS
* under Herc Mode. Removing it makes AutoDetect programs work and Herc
 Mono CodePages still work ok for dos versions 4.01 and 5.00
     */
}
#endif /* HERC */

#ifdef NTVDM
void enable_stream_io(void)
{
    #ifdef MONITOR
/* for non RISC machine the buffer is from 16bits code bop from spckbd.asm */
    host_enable_stream_io();
    stream_io_enabled = TRUE;
    #else
    stream_io_buffer = (half_word *)malloc(STREAM_IO_BUFFER_SIZE_32);
    if (stream_io_buffer != NULL)
    {
        host_enable_stream_io();
        stream_io_dirty_count_ptr = &stream_io_dirty_count_32;
        stream_io_buffer_size = STREAM_IO_BUFFER_SIZE_32;
        stream_io_enabled = TRUE;
        *stream_io_dirty_count_ptr = 0;
    }
    #endif

}

void disable_stream_io(void)
{

    stream_io_update();
    stream_io_enabled = FALSE;
    host_disable_stream_io();
    #ifndef MONITOR
    free(stream_io_buffer);
    #endif
}
#endif

#if defined(JAPAN) || defined(KOREA)

//;;;;;;;;;;;;;;;;;;; MS-DOS/V BOP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    #ifdef i386
        #define CONSOLE_BUFSIZE (80*50*2*2)
GLOBAL byte FromConsoleOutput[CONSOLE_BUFSIZE];

GLOBAL int FromConsoleOutputFlag=FALSE;

GLOBAL byte SaveDosvVram[DOSV_VRAM_SIZE];
    #endif // i386

// use GetStringBitmap()
    #define BITMAPBUFSIZ 128
extern HDC hdcVDM;
extern HFONT hFont24;
extern HFONT hFont16;

extern BOOL VDMForWOW;

// For GetStringBitmap()
typedef struct tagSTRINGBITMAP
{
    UINT uiWidth;
    UINT uiHeight;
    BYTE ajBits[1];
} STRINGBITMAP, *LPSTRINGBITMAP;

typedef struct
{
    BYTE ajBits[19];
} FONTBITMAP8x19;

typedef struct
{
    BYTE ajBits[16];
} FONTBITMAP8x16;

typedef struct
{
    BYTE ajBits[48];
} FONTBITMAP12x24;

typedef struct
{
    BYTE ajBits[32];
} FONTBITMAP16x16;

typedef struct
{
    BYTE ajBits[72];
} FONTBITMAP24x24;

typedef struct
{
    BYTE is_used[189];
    FONTBITMAP16x16 font16x16[189];
} FONT16CACHE, *PFONT16CACHE;

typedef struct
{
    BYTE is_used[189];
    FONTBITMAP24x24 font24x24[189];
} FONT24CACHE, *PFONT24CACHE;

FONTBITMAP8x19  font8x19[256];
FONTBITMAP8x16  font8x16[256];
FONTBITMAP12x24  font12x24[256];

BYTE            font16table[256];
HLOCAL          hFont16mem[128];
HLOCAL          hFont24mem[128];

    #define USED (1)
    #define NOT_USED (0)

void GetVerticallineFlag( int *VFlag );

UINT
GetStringBitmapA(
                HDC             hdc,
                LPSTR           pc,
                UINT            cch,
                UINT            cbData,
                LPSTRINGBITMAP  pSB
                );

void LoadBitmapFont()
{
    char code[3];
    static char sb[BITMAPBUFSIZ];
    LPSTRINGBITMAP psb;
    int i, j;
    int n;
    int VFlag[256];

    // first 8x16, 8x19 font
    #ifdef JAPAN_DBG
    DbgPrint( "NTVDM:Loading NTFONT 8x16,8x19\n" );
    #endif
    GetVerticallineFlag( VFlag );
    SelectObject( hdcVDM, hFont16 );
    psb = (LPSTRINGBITMAP)sb;
    code[1] = '\0';
    for (i = 0; i < 256; i++)
    {
        code[0] = (char)i;

        GetStringBitmapA( hdcVDM, code, 1, BITMAPBUFSIZ, psb );

        RtlCopyMemory( &(font8x16[i].ajBits[0]), &(psb->ajBits[0]), 16 );

        for (j = 0; j < (19-18) * 1; j++)
        {
            if (VFlag[i])
                font8x19[i].ajBits[0] = psb->ajBits[0];
            else
                font8x19[i].ajBits[0] = 0x00;
        }
        RtlCopyMemory( &(font8x19[i].ajBits[1]), &(psb->ajBits[0]), 18 );
    }

    // second 12x24 font
    #ifdef JAPAN_DBG
    DbgPrint( "NTVDM:Loading NTFONT 12x24\n" );
    #endif
    SelectObject( hdcVDM, hFont24 );
    psb = (LPSTRINGBITMAP)sb;
    code[1] = '\0';
    for (i = 0; i < 256; i++)
    {
        code[0] = (char)i;
        GetStringBitmapA( hdcVDM, code, 1, BITMAPBUFSIZ, psb );

        // 12x24 dot font is console 12x27 font.
        RtlCopyMemory( &(font12x24[i].ajBits[0]), &(psb->ajBits[2]), 48 );
    }



    // make table
    for (i = 0, n = 0; i < 256; i++)
    {  // Leading byte
        if (is_dbcs_first(i))
        {
            font16table[i] = n++;
        }
    }
    #ifdef JAPAN_DBG
    DbgPrint( "NTVDM:Loading font... end\n" );
    #endif
}

// This is only stub routine
// finally, this information gets from registry
void GetVerticallineFlag( int *VFlag )
{
    int i;

    for (i = 0; i < 256; i++)
    {
        VFlag[i] = FALSE;
    }
    VFlag[0x03] = TRUE;
    VFlag[0x04] = TRUE;
    VFlag[0x05] = TRUE;
    VFlag[0x10] = TRUE;
    VFlag[0x15] = TRUE;
    VFlag[0x17] = TRUE;
    VFlag[0x19] = TRUE;
    VFlag[0x1d] = TRUE;

    return;
}



void GetBitmap()
{
    sys_addr ptr;
    int i;
    int width, height;
    char code[3];
    static char sb[BITMAPBUFSIZ];
    LPSTRINGBITMAP psb;
    int index;
    PFONT16CACHE pCache16;
    PFONT24CACHE pCache24;

    #ifdef JAPAN_DBG
    DbgPrint( "NTFONT BOP 02\n" );
    DbgPrint( "ES:SI=%x:%x\n", getES(), getSI() );
    DbgPrint( "BH,BL=%x,%x\n", getBH(), getBL() );
    DbgPrint( "CH,CL=%x,%x\n", getCH(), getCL() );
    #endif

    width = getBH();
    height = getBL();
    ptr =  effective_addr(getES(),getSI());

    if (getCH() == 0)
    {
        if (( width == 8 ) && ( height == 16 ))
        {
            sas_stores_from_transbuf(ptr,
                                     (host_addr)&(font8x16[getCL()].ajBits[0]),
                                     (sys_addr)16 );
            setAX(0);
        }
        else if (( width == 8 ) && ( height == 19 ))
        {
            sas_stores_from_transbuf(ptr,
                                     (host_addr)&(font8x19[getCL()].ajBits[0]),
                                     (sys_addr)19 );
            setAX(0);
        }
        else if (( width == 12 ) && ( height == 24 ))
        {
            sas_stores_from_transbuf(ptr,
                                     (host_addr)&(font12x24[getCL()].ajBits[0]),
                                     (sys_addr)48 );
            setAX(0);
        }
        else
        {
            DbgPrint( "Illegal Fontsize %xh, %xh\n", getBH(), getBL() );
            setAH(1);
        }
    }
    else
    {
        if (!is_dbcs_first( getCH() ))
        {
            setAH( 5 );
            return;
        }
        if (getCL() < 0x40 || getCL() > 0xfc || getCL() == 0x7f)
        {
            setAH( 5 );
            return;
        }
        if (width == 16 && height == 16)
        {
            index = font16table[getCH()];

            if (!hFont16mem[index])
                hFont16mem[index] = LocalAlloc(LHND, sizeof(FONT16CACHE));
            if (hFont16mem[index])
            {
                pCache16 = LocalLock( hFont16mem[index] );
                if (pCache16->is_used[getCL()-0x40] != USED)
                {
                    code[0] = getCH();
                    code[1] = getCL();
                    code[2] = '\0';
                    psb = (LPSTRINGBITMAP)sb;
                    SelectObject( hdcVDM, hFont16 );
                    GetStringBitmapA(hdcVDM, code, 2, BITMAPBUFSIZ, psb);

                    RtlCopyMemory(&(pCache16->font16x16[getCL()-0x40].ajBits[0]),
                                  &(psb->ajBits[0]),
                                  32);
                    pCache16->is_used[getCL()-0x40] = USED;
                }
                sas_stores_from_transbuf(ptr,
                                         (host_addr)&(pCache16->font16x16[getCL()-0x40].ajBits[0]),
                                         (sys_addr)32);
                LocalUnlock( hFont16mem[index] );

                setAX(0);
                return;
            }
        }
        else if (width == 24 && height == 24)
        {
            index = font16table[getCH()];
            if (!hFont24mem[index])
                hFont24mem[index] = LocalAlloc(LHND, sizeof(FONT24CACHE));

            if (hFont24mem[index])
            {
                pCache24 = LocalLock( hFont24mem[index] );
                if (pCache24->is_used[getCL()-0x40] != USED)
                {
                    code[0] = getCH();
                    code[1] = getCL();
                    code[2] = '\0';
                    psb = (LPSTRINGBITMAP)sb;
                    SelectObject( hdcVDM, hFont24 );
                    GetStringBitmapA( hdcVDM, code, 2, BITMAPBUFSIZ, psb );

                    RtlCopyMemory(&(pCache24->font24x24[getCL()-0x40].ajBits[0]),
                                  &(psb->ajBits[0]),
                                  72 );
                    pCache24->is_used[getCL()-0x40] = USED;
                }
                sas_stores_from_transbuf(ptr,
                                         (host_addr)&(pCache24->font24x24[getCL()-0x40].ajBits[0]),
                                         (sys_addr)72 );
                LocalUnlock( hFont24mem[index] );

                setAX(0);
                return;
            }

        }
        else
        {
            DbgPrint("Illegal Fontsize %xh, %xh\n", getBH(), getBL());
            setAH(1);
            return;
        }
        DbgPrint("GETBITMAP: out of memory\n");
        setAH(1);
        return;
    } // bouble byte case
}

// SetBitmap() save the font image to cache,
// and call SetConsoleLocalEUDC() to display in windowed.
void SetBitmap()
{
    sys_addr ptr;
    int i;
    SHORT width, height;
    int index;
    PFONT16CACHE pCache16;
    PFONT24CACHE pCache24;
    COORD cFontSize;

    #ifdef JAPAN_DBG
    DbgPrint( "NTFONT BOP 03\n" );
    DbgPrint( "ES:SI=%x:%x\n", getES(), getSI() );
    DbgPrint( "BH,BL=%x,%x\n", getBH(), getBL() );
    DbgPrint( "CH,CL=%x,%x\n", getCH(), getCL() );
    #endif

    width = getBH();
    height = getBL();
    ptr =  effective_addr(getES(),getSI());

    if (getCH() == 0)
    {
        if (( width == 8 ) && ( height == 16 ))
        {
            sas_loads_to_transbuf(ptr,
                                  (host_addr)&(font8x16[getCL()].ajBits[0]),
                                  (sys_addr)16 );
            setAL(0);
        }
        else if (( width == 8 ) && ( height == 19 ))
        {
            sas_loads_to_transbuf(ptr,
                                  (host_addr)&(font8x19[getCL()].ajBits[0]),
                                  (sys_addr)19 );
            setAL(0);
        }
        else if (( width == 12 ) && ( height == 24 ))
        {
            sas_loads_to_transbuf(ptr,
                                  (host_addr)&(font12x24[getCL()].ajBits[0]),
                                  (sys_addr)48 );
            setAL(0);
        }
        else
        {
            DbgPrint( "Illegal Fontsize %xh, %xh\n", getBH(), getBL() );
            setAL(1);
        }
    }
    else
    {
        if (!is_dbcs_first( getCH() ))
        {
            setAL( 5 );
            return;
        }
        if (getCL() < 0x40 || getCL() > 0xfc || getCL() == 0x7f)
        {
            setAL( 5 );
            return;
        }
        if ((width == 16) && (height == 16))
        {
            index = font16table[getCH()];
            if (!hFont16mem[index])
                hFont16mem[index] = LocalAlloc(LHND, sizeof(FONT16CACHE));

            if (hFont16mem[index])
            {
                pCache16 = LocalLock(hFont16mem[index]);
                sas_loads_to_transbuf(ptr,
                                      (host_addr)&(pCache16->font16x16[getCL()-0x40].ajBits[0]),
                                      (sys_addr)32);
                pCache16->is_used[getCL()-0x40] = USED;
                LocalUnlock(hFont16mem[index]);
                cFontSize.X = width;
                cFontSize.Y = height;

                if (!SetConsoleLocalEUDC(sc.OutputHandle,
                                         getCX(),
                                         cFontSize,
                                         (PCHAR)(pCache16->font16x16[getCL()-0x40].ajBits)))
                    DbgPrint("NTVDM: SetConsoleEUDC() Error. CodePoint=%04x\n",
                             getCX());
                setAL(0);
                return;
            }
        }
        else if ((width == 24) && (height == 24))
        {
            index = font16table[getCH()];
            if (!hFont24mem[index])
                hFont24mem[index] = LocalAlloc(LHND, sizeof(FONT24CACHE));

            if (hFont24mem[index])
            {
                pCache24 = LocalLock(hFont24mem[index]);
                sas_loads_to_transbuf(ptr,
                                      (host_addr)&(pCache24->font24x24[getCL()-0x40].ajBits[0]),
                                      (sys_addr)72 );
                pCache24->is_used[getCL()-0x40] = USED;
                LocalUnlock( hFont24mem[index] );
                cFontSize.X = width;
                cFontSize.Y = height;

                if (!SetConsoleLocalEUDC(sc.OutputHandle,
                                         getCX(),
                                         cFontSize,
                                         (PCHAR)(pCache24->font24x24[getCL()-0x40].ajBits)))
                    DbgPrint("NTVDM: SetConsoleEUDC() Error. CodePoint=%04x\n",
                             getCX() );
                setAL(0);
                return;
            }
        }
        else
        {
            DbgPrint("Illegal Fontsize %xh, %xh\n", getBH(), getBL());
            setAL(1);
            return;
        }

        DbgPrint("SETBITMAP: out of memory\n");
        setAL(1);
        return;
    }
}

// ntraid:mskkbug#3167: works2.5: character corrupted -yasuho
// generate single byte charset
void GenerateBitmap()
{
    sys_addr ptr;
    int      size, nchars, offset;
    char     mode;

    mode = sas_hw_at_no_check(DosvModePtr);
    if (is_us_mode() || (mode != 0x03 && mode != 0x73))
        return;
    ptr =  effective_addr(getES(), getBP());
    size = getBH();
    nchars = getCX();
    offset = getDX();
    if (nchars + offset > 0x100)
    {
        setCF(1);
        return;
    }
    if (size == 16)
    {
        sas_loads_to_transbuf(ptr,
                              (host_addr)&(font8x16[offset].ajBits[0]),
                              (sys_addr)(nchars * size));
        setCF(0);
    }
    else if (size == 19)
    {
        sas_loads_to_transbuf(ptr,
                              (host_addr)&(font8x19[offset].ajBits[0]),
                              (sys_addr)(nchars * size));
        setCF(0);
    }
    else if (size == 24)
    {
        sas_loads_to_transbuf(ptr,
                              (host_addr)&(font12x24[offset].ajBits[0]),
                              (sys_addr)(nchars * size));
        setCF(0);
    }
    else
    {
        DbgPrint("Illegal Fontsize %xh\n", size);
        setCF(1);
    }
}


/*
 * MS_DosV_bop()
 *
 * The type of operation is coded into the AH register.
 *
 *  AH = 00 - ff  for $NTFONT.SYS
 *     = 10    DBCS vector adress(DS:SI)
 *     = 11 - 1f  reserved
 *     = 20    Window information packet adress(DS:SI)
 *     = 21    Text Vram save & restore
 *     = 22    palette and DAC registers operations
 *     = 23    monitoring IME status lines
 *     = 24 - ff     reserved
 *
 */
    #if defined(JAPAN)
void MS_DosV_bop IFN0()
    #else // JAPAN
void MS_HDos_bop IFN0()
    #endif // KOREA
{
    int op;

    op = getAH();
    switch (op)
    {
    case 0x00:

// inquery font type
//
// input
//   ES:SI pointer of buffer
//   CX    buffersize
// output
//   CX    number of font element
//   AL    if CX < N(number of element) then 1
//   ES:SI --> x0, y0(byte)  -- font size
//             x1, y1
//             ......
//             x(N-1), y(N-1)

        {
            sys_addr ptr;
            int bufsize;
            int N;
            int i;
    #ifdef JAPAN_DBG
            DbgPrint( "NTFONT BOP 00\n" );
            DbgPrint( "ES:SI=%x:%x\n", getES(), getSI() );
            DbgPrint( "CX=%x\n", getCX() );
    #endif
            if (VDMForWOW)
            {
                setCF(1);
                return;
            }
            ptr =  effective_addr(getES(),getSI());
            bufsize = getCX();

            // now only 8x16, 8,19, 16x16 font -- July 13 V-KazuyS
            N = 5;

            if (N > bufsize)
            {
                N = bufsize;
                setAL(1);
            }
            else
            {
                setAL(0);
            }
            setCX((IU16)N);

            sas_store_no_check( ptr++,  8 );  // x
            sas_store_no_check( ptr++, 16 );  // y
            sas_store_no_check( ptr++,  8 );  // x
            sas_store_no_check( ptr++, 19 );  // y
            sas_store_no_check( ptr++, 12 );  // x
            sas_store_no_check( ptr++, 24 );  // y
            sas_store_no_check( ptr++, 16 );  // x
            sas_store_no_check( ptr++, 16 );  // y
            sas_store_no_check( ptr++, 24 );  // x
            sas_store_no_check( ptr++, 24 );  // y
        }
        break;

    case 0x01:
        // Load font image from Gre
    #ifdef JAPAN_DBG
        DbgPrint( "NTFONT BOP 01\n" );
    #endif
        if (VDMForWOW)
        {
            setCF(1);
            return;
        }
        LoadBitmapFont();
        break;

    case 0x02:
        // Read font image
        if (VDMForWOW)
        {
            setCF(1);
            return;
        }
        GetBitmap();
        break;

    case 0x03:
    #ifdef JAPAN_DBG
        //DbgPrint( "NTFONT BOP 03 CH:CL=%02x:%02x\n", getCH(), getCL() );
    #endif
        if (VDMForWOW)
        {
            setCF(1);
            return;
        }
        SetBitmap();
        break;


    case 0x10:
    #ifdef JAPAN_DBG
        DbgPrint( "NTVDM: DBCS vector address=%04x:%04x\n", getDS(), getSI() );
    #endif
        {
            // NOTE: This routine is called ONLY ONE from $NtDisp1.sys !
            sys_addr ptr;
            word vector;
            extern UINT ConsoleInputCP;
            extern UINT ConsoleOutputCP;

            DBCSVectorAddr =  effective_addr(getDS(),getSI());
            // Save DBCS vector
            DBCSVectorLen = 0;
            for (ptr = DBCSVectorAddr;
                vector = sas_w_at_no_check( ptr ); ptr += 2)
            {
                SaveDBCSVector[DBCSVectorLen] = vector;
                DBCSVectorLen++;
            }
            assert0( ConsoleInputCP == ConsoleOutputCP, "InputCP != OutputCP" );

            BOPFromNtDisp1Flag = TRUE;

    #ifdef JAPAN_DBG
            DbgPrint( "BOP from $NTDISP1\n" );
    #endif
        }
        break;

    case 0x20:
    #ifdef JAPAN_DBG
        DbgPrint( "NTVDM: Information packet address=%04x:%04x\n", getDS(), getSI() );
    #endif
        /* information packet is
         *
         *   offset   bytes mode  information
         *   +0x0  2       r   packet length
         *   +0x2   4    r  virtual text VRAM address seg:off
         *   +0x6   4    r  MS-DOS/V display mode address seg:off
         *   +0xa   4 w  Windowed or Fullscreen flag address seg:       *   +0xe   4 r  NT console mode flag address seg:off
         *                          when VDM terminate, this flag == 1
         *   +0x12  4 r  Switch to FullScreen subroutine address seg:      */
        {
            sys_addr ptr;
            extern UINT ConsoleInputCP;
            extern UINT ConsoleOutputCP;
    #ifdef i386
            extern word useHostInt10;
            extern word int10_seg;
    #endif

            ptr =  effective_addr(getDS(),getSI());

            DosvVramOff = sas_w_at_no_check( ptr+0x02 );
            DosvVramSeg = sas_w_at_no_check( ptr+0x04 );
            DosvVramPtr = effective_addr( DosvVramSeg, DosvVramOff );

            // disp_win.sys don't know VramSize.
            // because $disp.sys doesn't have get_vram_size function, now.
            DosvVramSize = DOSV_VRAM_SIZE;
    #ifdef JAPAN_DBG
            DbgPrint( "NTVDM:DosvVirtualTextVRAM addr = %04x:%04x\n", DosvVramSeg, DosvVramOff );
    #endif

            DosvModeOff = sas_w_at_no_check( ptr+0x06 );
            DosvModeSeg = sas_w_at_no_check( ptr+0x08 );
            DosvModePtr = effective_addr( DosvModeSeg, DosvModeOff );
    #ifdef JAPAN_DBG
            DbgPrint( "NTVDM:DosvVideoMode addr = %04x:%04x\n", DosvModeSeg, DosvModeOff );
    #endif

    #ifndef i386   // !!! remeber to change DISP_WIN.SYS since it relies on this.
            sas_storew_no_check( ptr+0x0a, 0 );
            sas_storew_no_check( ptr+0x0c, 0 );
    #else
            sas_storew_no_check( ptr+0x0a, useHostInt10 );
            sas_storew_no_check( ptr+0x0c, int10_seg );
    #endif


            NtConsoleFlagOff = sas_w_at_no_check( ptr+0x0e );
            NtConsoleFlagSeg = sas_w_at_no_check( ptr+0x10 );
            NtConsoleFlagPtr = effective_addr( NtConsoleFlagSeg, NtConsoleFlagOff );
    #ifdef JAPAN_DBG
            DbgPrint( "NTVDM:ConsoleFlagAddr = %04x:%04x\n", NtConsoleFlagSeg, NtConsoleFlagOff );
    #endif

    #ifdef i386
// RISC never use following value.
// Swtich to fullscreen, call these address..
            DispInitOff = sas_w_at_no_check( ptr+0x12 );
            DispInitSeg = sas_w_at_no_check( ptr+0x14 );
        #ifdef JAPAN_DBG
            DbgPrint( "NTVDM:Disp Init Addr = %04x:%04x\n", DispInitSeg, DispInitOff );
        #endif

            FullScreenResumeOff = sas_w_at_no_check(ptr + 0x16);
            FullScreenResumeSeg = sas_w_at_no_check(ptr + 0x18);
    #endif // !i386
            SetModeFlagPtr = effective_addr(
                                           sas_w_at_no_check( ptr+0x1c ),
                                           sas_w_at_no_check( ptr+0x1a ));
            if (BOPFromNtDisp1Flag)
                BOPFromDispFlag = TRUE;

            SetDBCSVector( ConsoleInputCP );
            PrevCP = ConsoleOutputCP;

    #ifdef JAPAN_DBG
            DbgPrint( "BOP from $NTDISP2\n" );
    #endif
        }
        break;

    #ifdef i386
    case 0x21:
        // Vram save restore function
        // AL == 00 save
        // AL == 01 restore
        // AL == 02 GetConsoleBuffer
        // AL == 03 Get FromConsoleOutput
        {
            sys_addr ptr;
            int op;
            int count;
            int i;

            op = getAL();
            ptr =  effective_addr(getES(),getDI());
            count = getCX();

            if (op == 0x02)
            {
                if (count > DOSV_VRAM_SIZE)
                    count = DOSV_VRAM_SIZE;
                //for ( i = 0; i < 2; i++ ) {
                if (FromConsoleOutputFlag)
                {
        #ifdef JAPAN_DBG
                    DbgPrint( "NTVDM: MS-DOS/V BOP 21\n" );
        #endif
        #ifdef i386
//FromConsoleOutput is on 32bit address space not on DOS address space.
                    sas_move_bytes_forward((sys_addr) FromConsoleOutput,
                                           (sys_addr) ptr,
                                           (sys_addr) count
                                          );
        #else
                    sas_stores_from_transbuf(ptr,
                                             (host_addr) FromConsoleOutput,
                                             (sys_addr) count
                                            );
        #endif
                    FromConsoleOutputFlag = FALSE;
                    break;
                }
                else
                {
                    DbgPrint( "NTVDM: MS-DOS/V BOP 21 can't get console screen data!! \n" );
                    //Sleep( 1000L );
                }
                //}
                break;
            }

            if (count > DOSV_VRAM_SIZE)
                count = DOSV_VRAM_SIZE;

            if (op == 0x00)
            {       // save function
        #ifdef JAPAN_DBG
                DbgPrint( "NTVDM:MS_DOSV_BOP 0x21, %02x %04x:%04x(%04x)\n", op, getES(), getDI(), count );
        #endif
//SaveDosvVram is on 32bit address space not on DOS address space.
                sas_loads_to_transbuf(ptr,
                                      (host_addr)SaveDosvVram,
                                      (sys_addr)count
                                     );

            }
            else if (op == 0x01)
            {  // restore function
        #ifdef JAPAN_DBG
                DbgPrint( "NTVDM:MS_DOSV_BOP 0x21, %02x %04x:%04x(%04x)\n", op, getES(), getDI(), count );
        #endif
// DEC-J comment
// SaveDosvVram is on 32bit address space not on DOS address space.
// for C7 PWB.
// This is internal bop
// It doesn't need check memory type.
                RtlCopyMemory( (void*)ptr,
                               (void*)SaveDosvVram,
                               (unsigned long)count
                             );
            }
            // #3086: VDM crash when exit 16bit apps of video mode 11h
            // 12/2/93 yasuho
            else if (op == 0x03)
            { // Get from FromConsoleOutput
                RtlCopyMemory( (void*)ptr,
                               (void*)FromConsoleOutput,
                               (unsigned long) count
                             );
            }
        }
        break;
    #endif // i386

    case 0x22:
        // #3176: vz display white letter on white screen
        // 12/1/93 yasuho (reviewed by williamh)
        // palette and DAC registers operations
        // Input   AH = 22H
        //      AL = 00H : get from simulated value for windowed
        //      ES:DI = ptr to palette/DAC buffer
        {
            sys_addr ptr;
            byte     op;
            static void get_cur_pal_and_DAC(sys_addr);

            op = getAL();
            ptr = effective_addr(getES(), getDI());
    #ifdef   VGG
            if (op == 0x00)
            { // get from simulated value for windowed
                get_cur_pal_and_DAC(ptr);
            }
    #endif   //VGG
        }
        break;

    #if !defined(KOREA)
    case 0x23:
        // #4183: status line of oakv(DOS/V FEP) doesn't disappear
        // 12/11/93 yasuho
        // monitoring IME status lines
        // Input   AH = 23H
        //      AL = number of IME status lines
        {
            IMEStatusLines = getAL();
        }
        break;
    #endif

        // kksuzuka #6168 screen attributes for DOS fullscreen
    case 0x24:
        // set console attributes for fullscreen
        // Input AH = 23H
        //      AL = none
        // Output   AL 4-7 bit = back ground color
        //      AL 0-3 bit = fore ground color
        {
            setAX(textAttr);
        }
        break;

    #if !defined(KOREA)
    case 0xff:
        // Int10 Function FF
        // ES: Vram seg, DI: Vram Off, CX:counter
        {
            register int i;
            register int vram_addr;
            int DBCSState = FALSE;
            register  char *p;
        #ifndef i386
            register sys_addr V_vram = effective_addr(getES(),getDI());
        #endif // !i386

            if (is_us_mode())
            {
                setCF(1);
                return;
            }
            if (sas_hw_at_no_check(DosvModePtr) != 0x03)
            {
        #ifdef JAPAN_DBG
                DbgPrint( "NTVDM: mode != 0x03, int10 FF not support\n" );
        #endif
                setCF(1);
                return;
            }
        #if 0
            DbgPrint( "Addr %04x:%04x, CX=%x, ", getES(), getDI(), getCX() );
            DbgPrint( "%d, %d, CX=%d\n", getDI() < 160 ? 0 : getDI()/160,
                      getDI() < 160 ? 0 : (getDI() - (getDI()/160)*160)/2, getCX() );
        #endif
            Int10FlagCnt++;
            vram_addr = getDI() >> 1;
        #ifdef i386
            p = get_screen_ptr( getDI() );
        #else // !i386 uses the EGA plane.
            p = get_screen_ptr( getDI()<<1 );

            // for speed up!!
            i = getCX();
            if (vram_addr + i > DOSV_VRAM_SIZE / 2)
            {
                i = DOSV_VRAM_SIZE / 2 - vram_addr;
            #ifdef JAPAN_DBG
                DbgPrint("NTVDM:Int10 FF over VRAM(DI)=%04x\n", getDI() );
            #endif
            }
        #endif // !i386

        #ifdef i386
            for (i = 0; i < getCX(); i++)
            {
                if (vram_addr >= DOSV_VRAM_SIZE/2)
                {
                    DbgPrint("NTVDM:Int10 FF over VRAM(DI)=%04x\n", getDI() );
                    break;
                }
                else if (DBCSState)
                {
        #else // !i386
            //for speed up!!
            while (i--)
            {
                sas_loadw(V_vram++, (word *)p);
                V_vram++;
                setVideodirty_total(getVideodirty_total() + 2);
                if (DBCSState)
                {
        #endif // !i386
                    Int10Flag[vram_addr] = INT10_DBCS_TRAILING | INT10_CHANGED;
                    DBCSState = FALSE;
                }
                else if (DBCSState = is_dbcs_first( *p ))
                {
                    Int10Flag[vram_addr] = INT10_DBCS_LEADING | INT10_CHANGED;
                }
                else
                {
                    Int10Flag[vram_addr] = INT10_SBCS | INT10_CHANGED;
                }
                vram_addr++;
        #ifdef i386
                p += 2;
        #else // !i386 uses the EGA plane.
                p += 4;
        #endif  // !i386
            }
            // Last char check! for Vz
            if (DBCSState && ( vram_addr % 80 != 0 ))
                Int10Flag[vram_addr] = INT10_DBCS_TRAILING | INT10_CHANGED;

        }
        break;
    #endif

    default:
        DbgPrint("NTVDM: Not support MS-DOS/V BOP:%d\n", op );
        setCF(1);
        return;
    }
    setCF(0);
}

// mskkbug #3176 vz display white letter on white screen -yasuho
    #ifdef   VGG
static void get_cur_pal_and_DAC(ptr)
sys_addr ptr;
{
    register i;
    byte     temp;
    struct _rgb
    {
        byte  red, green, blue;
    } rgb;

    // get palette and overscan
    for (i = 0; i < 16; i++)
    {
        outb(EGA_AC_INDEX_DATA, (IU8)i); /* set index */
        inb(EGA_AC_SECRET, &temp);
        sas_store(ptr, temp);
        inb(EGA_IPSTAT1_REG, &temp);
        ptr++;
    }
    outb(EGA_AC_INDEX_DATA, 17); /* overscan index */
    inb(EGA_AC_SECRET, &temp);
    sas_store(ptr++, temp);
    inb(EGA_IPSTAT1_REG, &temp);
    outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);
    // get DAC registers
    for (i = 0; i < 256; i++)
    {
        outb(VGA_DAC_RADDR, (IU8)i);
        inb(VGA_DAC_DATA, &rgb.red);
        inb(VGA_DAC_DATA, &rgb.green);
        inb(VGA_DAC_DATA, &rgb.blue);
        sas_store(ptr++, rgb.red);
        sas_store(ptr++, rgb.green);
        sas_store(ptr++, rgb.blue);
    }
}
    #endif   //VGG

//;;;;;;;;;;;;;;;;;;; end of MS-DOS/V BOP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#endif // JAPAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\video_io.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title        : Bios Virtual Screen Interface
 *
 * Description  : Top level call to the video interface.  Uses a function
 *                jump table to call the lower level functions.
 *
 * Author       : Henry Nash
 *
 * Notes        : None
 * SCCS ID      : @(#)video_io.c        1.8 08/19/94
 *
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "VIDEO_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "bios.h"
#include "video.h"

#include "debug.h"
#include "idetect.h"

#define check_video_func(AH)    (AH < EGA_FUNC_SIZE)

void video_io()
{


#if defined(NTVDM) && !defined(X86GFX)
    if (stream_io_enabled && getAH()!= 0x0E &&  getAX() != 0x13FF)
        disable_stream_io();
#endif


    /*
     * The type of operation is coded into the AH register.  Some PC code
     * calls AH functions that are for other more advanced cards - so we
     * ignore these.
     */

    assert1(check_video_func(getAH()),"Illegal VIO:%#x",getAH());
    if (check_video_func(getAH()))
    {
        IDLE_video();
        (*video_func[getAH()])();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\biosseg.inc ===
; BIOSSEG.INC
;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.


datagrp	group	Bios_Data,Bios_Data_Init


Bios_Data	segment	word public 'Bios_Data'
Bios_Data	ends

Bios_Data_Init	segment word public 'Bios_Data_Init'
Bios_Data_Init	ends

Filler		segment para public 'Filler'
Filler		ends

Bios_Code	segment word public 'Bios_Code'
Bios_Code	ends

Filler2		segment para public 'Filler2'
Filler2         ends

sysinitgrp group sysinitseg, SpcKbdSeg, SpcMseSeg, SpcEmmSeg

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

SpcKbdSeg       segment para public 'SoftpcKeyboard'
SpcKbdSeg       ends

SpcMseSeg       segment para public 'SoftpcMouse'
SpcMseSeg       ends

SpcEmmSeg       segment para public 'SoftpcEmm'
SpcEmmSeg       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\base\video\v7_video.c ===
#include "insignia.h"
#include "host_def.h"
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		v7_video.c

 Description:
		Code for the BIOS extended functions of the Video 7 VGA.

 Author:
		Phil Taylor

 Date:
		12 October 1990

 SccsID       "@(#)v7_video.c	1.21 07/04/95 Copyright Insignia Solutions Ltd."

======================================================================
]*/


#ifdef VGG
#ifdef V7VGA

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "error.h"
#include "config.h"
#include "ios.h"
#include "bios.h"
#include "debug.h"
#include "egagraph.h"
#include "video.h"
#include "egavideo.h"
#include "egacpu.h"
#include "egaports.h"
#include "vgaports.h"
#include CpuH
#include "sas.h"

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "VIDEO_BIOS_VGA.seg"
#endif


IMPORT	struct	sequencer sequencer;
IMPORT	struct	crt_controller crt_controller;
IMPORT	struct	graphics_controller graphics_controller;
IMPORT	struct	attribute_controller attribute_controller;
IMPORT  IU8     Currently_emulated_video_mode;

IMPORT	void	low_set_mode();
IMPORT	void	load_font();
IMPORT	void	recalc_text();

FORWARD	void	v7vga_inquire();
FORWARD	void	v7vga_get_info();
FORWARD	void	v7_not_imp();
FORWARD	void	v7vga_get_mode_and_screen_res();
FORWARD	void	v7vga_extended_set_mode();
FORWARD	void	v7vga_select_autoswitch_mode();
FORWARD	void	v7vga_get_memory_configuration();

GLOBAL	void		(*v7vga_video_func[]) () =
{
	v7vga_inquire,
	v7vga_get_info,
	v7_not_imp,
	v7_not_imp,
	v7vga_get_mode_and_screen_res,
	v7vga_extended_set_mode,
	v7vga_select_autoswitch_mode,
	v7vga_get_memory_configuration
};

/*(
----------------------------------------------------------------------

Function:	
		v7vga_func_6f()

Purpose:
		Perform the int 10 extended BIOS function 6F

Input:
		None

Output:
		If invalid subfunction, AH = 2

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_func_6f()
{
#ifndef NEC_98
	byte al;

	note_entrance0("v7vga_func_6f");
	al = getAL();
	if (al >= 0 && al < 8)
		(*v7vga_video_func[al])();
	else
		setAH(2);
		/* setCF(1) ?? */
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_inquire()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 0

Input:
		None

Output:
		BX is set to 'V7' (indicates extensions are present)

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_inquire()
{
#ifndef NEC_98
	note_entrance0("v7vga_inquire");

	setAX(0x6f6f);
	setBX(0x5637);
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_get_info()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 1

Input:
		None

Output:
		AL = reserved
		AH = status register information

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_get_info()
{
#ifndef NEC_98
	note_entrance0("v7vga_get_info");

	/* Reserved */
	setAL(0x10); /* This is what our V7VGA puts there */
	/* Status register information */
	setAH(0x04); /* Bit 5 = 0 -> colour. Bit 4 = 0 -> hi-res. Bit 0 = 0 -> display enabled. */
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7_not_imp()

Purpose:
		Emulate the unimplemented int 10 extended BIOS functions 6F - Subfunctions 2 & 3

Input:
		None

Output:
		None

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7_not_imp()
{
	note_entrance0("v7_not_imp");
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_get_mode_and_screen_res()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 4

Input:
		None

Output:
		AL = current video mode
		BX = horizontal columns/pixels (text/graphics)
		CX = vertical   rows/pixels    (text/graphics)

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_get_mode_and_screen_res()
{
#ifndef NEC_98
	half_word video_mode;

	note_entrance0("v7vga_get_mode_and_screen_res");

	video_mode = sas_hw_at_no_check(vd_video_mode);
	if ((video_mode == 1) && extensions_controller.foreground_latch_1)
		video_mode = extensions_controller.foreground_latch_1;
	else if (video_mode > 0x13)
		video_mode += 0x4c;

	setAL(video_mode);

	if (alpha_num_mode())
	{
		setBX(sas_w_at_no_check(VID_COLS));
		setCX(sas_w_at_no_check(vd_rows_on_screen)+1);
	}
	else
	{
		setBX(get_chars_per_line()*get_char_width());
		if (sas_hw_at_no_check(vd_video_mode) > 0x10)
			setCX(get_screen_height()/get_pc_pix_height()/get_char_height());
		else
			setCX(get_screen_height()/get_pc_pix_height());
	}
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_extended_set_mode()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 5

Input:
		BL = mode value

Output:
		None

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_extended_set_mode()
{
#ifndef NEC_98
	UTINY pag;
	sys_addr save_addr,font_addr;
	half_word temp_word;
	byte mode_byte;
	byte video_mode;
	ULONG font_offset;
	word clr_char;
#ifndef PROD
	trace("setting video mode", DUMP_REG);
#endif
	set_host_pix_height(1);
	set_banking( 0, 0 );

	if (is_bad_vid_mode(getBL()) && !is_v7vga_mode(getBL()))
		return;

	video_mode = getBL() & 0x7F; /* get rid of top bit - indicates clear or not */

	/*
	 * The method of storing an extended video mode according to a real BIOS is
	 * if it is an text mode then put 1 in the BIOS mode variable and store
	 * the video mode in the extensions foreground latch register 1 (Index EC).
	 * If it is a graphics mode then store (mode - 4C) in the mode variable.
	 */

	if (video_mode < 0x40)
	{
		sas_store_no_check(vd_video_mode, video_mode);
		extensions_controller.foreground_latch_1 = 0;
	}
	else if (video_mode < 0x46)
	{
		sas_store_no_check(vd_video_mode, 1);
		extensions_controller.foreground_latch_1 = video_mode;
	}
	else 
	{
		sas_store_no_check(vd_video_mode, video_mode - 0x4c);
	}

	Currently_emulated_video_mode = video_mode;

   	sas_store_no_check(ega_info, (sas_hw_at_no_check(ega_info) & 0x7F ) | (getBL() & 0x80)); /* update screen clear flag in ega_info */ 

	save_addr = follow_ptr(EGA_SAVEPTR);
	if(alpha_num_mode())
	{
		/* load_font will do the mode change for us */
		if (video_adapter == VGA)
		{
		    switch (get_VGA_lines())
		    {
			case S350:
				load_font(EGA_CGMN,256,0,0,14);
				break;
			case S400:
				switch (video_mode)
				{
					case 0x42:
					case 0x40:
					case 0x43:
					case 0x44:
					case 0x46:
						load_font(EGA_CGDDOT,256,0,0,8);
						if (video_mode == 0x42)
							set_host_pix_height(2);
						break;
					case 0x41:
					case 0x45:
						load_font(EGA_CGMN,256,0,0,14);
						set_host_pix_height(2);
						break;
					default:
						load_font(EGA_HIFONT,256,0,0,16);
				}
				break;
			default:
				load_font(EGA_CGDDOT,256,0,0,8);
		    }
		}
		else
		{
		    if(get_EGA_switches() & 1)
			load_font(EGA_CGMN,256,0,0,14);
		    else
			load_font(EGA_CGDDOT,256,0,0,8);
		}
		/* Now see if we have a nasty font to load */
		font_addr = follow_ptr(save_addr+ALPHA_FONT_OFFSET);
		if(font_addr != 0)
		{
			/* See if it applies to us */
			font_offset = 11;
			do
			{
				mode_byte = sas_hw_at_no_check(font_addr+font_offset);
				if (mode_byte == video_mode)
				{
					load_font(follow_ptr(font_addr+6),sas_w_at_no_check(font_addr+2),
						sas_w_at_no_check(font_addr+4), sas_hw_at_no_check(font_addr+1),
							sas_hw_at_no_check(font_addr));
					recalc_text(sas_hw_at_no_check(font_addr));
					if(sas_hw_at_no_check(font_addr+10) != 0xff)
						sas_store_no_check(vd_rows_on_screen, sas_hw_at_no_check(font_addr+10)-1);
					break;
				}
				font_offset++;
			} while (mode_byte != 0xff);
		}
	}
	else
	{
		/* graphics mode. No font load, so do mode change ourselves */
		low_set_mode(video_mode);
		/* Set up default graphics font */
		sas_storew_no_check(EGA_FONT_INT*4+2,EGA_SEG);
		if(video_mode == 16)
			sas_storew_no_check(EGA_FONT_INT*4,EGA_CGMN_OFF);
		else
		    if (video_mode == 17 || video_mode == 18 || video_mode == 0x66 || video_mode == 0x67)
				sas_storew_no_check(EGA_FONT_INT*4,EGA_HIFONT_OFF);
		    else
				sas_storew_no_check(EGA_FONT_INT*4,EGA_CGDDOT_OFF);
		/* Now see if we have a nasty font to load */
		font_addr = follow_ptr(save_addr+GRAPH_FONT_OFFSET);
		if(font_addr != 0)
		{
		/* See if it applies to us */
			font_offset = 7;
			do
			{
				mode_byte = sas_hw_at_no_check(font_addr+font_offset);
				if (mode_byte == video_mode)
				{
					sas_store_no_check(vd_rows_on_screen, sas_hw_at_no_check(font_addr)-1);
					sas_store_no_check(ega_char_height, sas_hw_at_no_check(font_addr)+1);
					sas_move_bytes_forward(font_addr+3, 4*EGA_FONT_INT,4);
					break;
				}
				font_offset++;
			} while (mode_byte != 0xff);
		}
	}

    sas_store_no_check(vd_current_page, 0);
    sas_storew_no_check((sys_addr)VID_ADDR, 0);
    sas_storew_no_check((sys_addr)VID_INDEX, EGA_CRTC_INDEX);
/*
 * CGA bios fills this entry in 'vd_mode_table' with 'this is a bad mode'
 * value, so make one up for VGA - used in VGA bios disp_func
 */
	if(video_mode < 8)
		sas_store_no_check(vd_crt_mode, vd_mode_table[video_mode].mode_control_val);
    else
	if(video_mode < 0x10)
	    sas_store_no_check(vd_crt_mode, 0x29);
	else
	    sas_store_no_check(vd_crt_mode, 0x1e);
    if(video_mode == 6)
		sas_store_no_check(vd_crt_palette, 0x3f);
    else
		sas_store_no_check(vd_crt_palette, 0x30);

	for(pag=0; pag<8; pag++)
		sas_storew_no_check(VID_CURPOS + 2*pag, 0);
/* Clear screen */
    if(!get_EGA_no_clear())
    {
		if (video_mode >= 0x60)
			clr_char = vd_ext_graph_table[video_mode-0x60].clear_char;
		else if (video_mode >= 0x40)
			clr_char = vd_ext_text_table[video_mode-0x40].clear_char;
		else
			clr_char = vd_mode_table[video_mode].clear_char;
#ifdef REAL_VGA
   		sas_fillsw_16(video_pc_low_regen, clr_char,
				 	(video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#else
    	sas_fillsw(video_pc_low_regen, clr_char,
				 (video_pc_high_regen - video_pc_low_regen)/ 2 + 1);
#endif
    }
    inb(EGA_IPSTAT1_REG,&temp_word);
    outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);	/* re-enable video */
#ifndef PROD
    trace("end of video set mode", DUMP_NONE);
#endif
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_select_autoswitch_mode()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 6

Input:
		BL = autoswitch mode select
		BH = enable/disable

Output:
		None

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_select_autoswitch_mode()
{
#ifndef NEC_98
	note_entrance0("v7vga_select_autoswitch_mode");

/***
	I reckon we shouldn't support this
***/
	setAH(0x2);
#endif  //NEC_98
}

/*(
----------------------------------------------------------------------

Function:	
		v7vga_get_memory_configuration()

Purpose:
		Perform the int 10 extended BIOS function 6F - Subfunction 7

Input:
		None

Output:
		AL = 6Fh
		AH = 82h - 2 x 256K blocks of V-RAM video memory
		BH = 70h - chip revision 3
		BL = 70h - chip revision 3
		CX = 0

----------------------------------------------------------------------
)*/

GLOBAL VOID
v7vga_get_memory_configuration()
{
#ifndef NEC_98
	note_entrance0("v7vga_get_memory_configuration");

	setAX(0x826f);
	setBX(0x7070);
	setCX(0x0);
#endif  //NEC_98
}

#endif /* V7VGA */
#endif /* VGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\msend.asm ===
page	,160
;
;----------------------------------------------------------------------------
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------

;	Define end labels for each segment in
;	   IO.SYS.  Make the segments paragraph aligned
;	   to save the trouble of rounding up at run-time.
;
;	also defines a special segment called dos_load_seg which is
;	  used to figure out where to load MSDOS (after sysinit)

Bios_Data	segment	para public 'Bios_Data'
	assume	cs:Bios_Data
	public	BData_end
BData_end:
Bios_Data	ends

Bios_Code	segment para public 'Bios_Code'
	assume	cs:Bios_Code
	public	BCode_end
BCode_end:
Bios_Code       ends

sysinitseg      segment para public 'system_init'
	assume	cs:sysinitseg
sysinitseg     ends

SpcKbdSeg       segment para public 'SoftpcKeyboard'
        assume  cs:SpcKbdSeg
SpcKbdSeg      ends

SpcMseSeg       segment para public 'SoftpcMouse'
        assume  cs:SpcMseSeg
SpcMseSeg       ends

SpcEmmSeg       segment para public 'SoftpcEmm'
        assume  cs:SpcEmmSeg
        public  SI_end
SI_end:
SpcEmmSeg      ends


dos_load_seg    segment para public 'dos_load_seg'
dos_load_seg	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\msgroup.inc ===
tocode	macro
Bios_Data	ends
Bios_Code	segment
	assume	cs:Bios_Code
	endm

todata	macro
Bios_Code	ends
Bios_Data	segment
	assume	cs:Bios_Data
	endm

;align the segment on word boundary to allow for even alignment of data

Bios_Data	segment
	assume	cs:Bios_Data

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\msint13.asm ===
page	,160
	title	MS-DOS BIOS int 2f handler
; 
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

; THIS FILE SHOULD BE NAMED INT2f.ASM RATHER THAN INT13.ASM AS I HAVE RIPPED
; THE INT 13 SUPPORT. TO REDUCE CONFUSION WHEN PICKING FIXES FROM DOS 5.1
; THE NAME IS RETAINED AS IT IS.

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include	msequ.inc
	include	biostruc.inc

        include msgroup.inc     ; establish Bios_Data segment
        include vint.inc

multMULT		equ	4ah
multMULTGETHMAPTR	equ	1
multMULTALLOCHMA	equ	2


Win386_RelTS	equ	80h
NT_WAIT_BOP	equ	5Ah

bop MACRO callid
    db 0c4h,0c4h,callid
endm

;SR;
; Include file for WIN386 support
;
	include win386.inc


	extrn	SysinitPresent:byte
	extrn	FreeHMAPtr:word
	extrn	MoveDOSIntoHMA:dword

;SR; 
;New variables for Win386 support
;
	extrn	IsWin386:byte
	extrn	Win386_SI:byte
	extrn	SI_Next:dword


; close data, open Bios_code segment

	tocode

	extrn	Bios_Data_Word:word

; Int 2f functions to support communication of external block device
; drivers with msdisk are not supported. It also does'nt support
; function 13h which replaces the int 13 vector.
;

	public	i2f_handler
i2f_handler proc far
	assume	ds:nothing,es:nothing

	cmp	ah,13h
	jz	i2f_iret
	cmp	ah,8
	jz	i2f_iret

;
;Check for WIN386 startup and return the BIOS instance data
;
	cmp	ah,MULTWIN386
	jz	win386call

	cmp	ah, multMULT
	jne	i2f_iret
	jmp	handle_multmult

i2f_iret:
        FIRET


;WIN386 startup stuff is done here. If starting up we set our WIN386 present
;flag and return instance data. If exiting, we reset the WIN386 present flag
;NOTE: We assume that the BIOS int 2fh is at the bottom of the chain.

win386call:
	push	ds
	mov	ds,cs:Bios_Data_Word
	assume	ds:Bios_Data

	cmp	al, Win386_Init		; is it win386 initializing?
	je	Win386Init
	cmp	al, Win386_Exit		; is it win386 exiting?
	je	Win386Exit
	cmp	al, Win386_RelTS	; is it app release timeslice call?
	jne	win_iret		; if not, continue int2f chain

	push	ax			; It's the idling case - call MS BOP A
	xor	ax,ax			; with AX = 0
	bop	NT_WAIT_BOP
	pop	ax
	xor	al, al
	jmp	short win_iret

Win386Exit:
	test	dx, 1			; is it win386 or win286 dos extender?
	jnz	win_iret		; if not win386, then continue
	and	[IsWin386], 0		; indicate that win386 is not present
	jmp	short win_iret

Win386Init:
	test	dx, 1			; is it win386 or win286 dos extender?
	jnz	win_iret		; if not win386, then continue

	or	[IsWin386], 1		; Indicate WIN386 present
	mov	word ptr [SI_Next], bx	; Hook our structure into chain
	mov	word ptr [SI_Next + 2], es
	mov	bx, offset Win386_SI	; point ES:BX to Win386_SI
	push	ds
	pop	es

win_iret:
	pop	ds
	assume 	ds:nothing
        jmp     i2f_iret                ;return back up the chain

handle_multmult:
	cmp	al, multMULTGETHMAPTR
	jne	try_2

	push	ds
	call	HMAPtr			; get offset of free HMA
	mov	bx, 0ffffh
	mov	es, bx			; seg of HMA
	mov	bx, di
	not	bx
	or	bx, bx
	jz	@f
	inc	bx
@@:
	pop	ds
	jmp	i2f_iret
try_2:
	cmp	al, multMULTALLOCHMA
	jne	try_3

	push	ds
	mov	di, 0ffffh		; assume not enough space
	mov	es, di
	call	HMAPtr			; get offset of free HMA
	assume	ds:Bios_Data
	cmp	di, 0ffffh
	je	InsuffHMA		
	neg	di			; free space in HMA
	cmp	bx, di
	jbe	@f
	mov	di, 0ffffh
	jmp	short InsuffHMA
@@:
	mov	di, FreeHMAPtr
	add	bx, 15
	and	bx, 0fff0h
	add	FreeHMAPtr, bx		; update the free pointer
	jnz	InsuffHMA
	mov	FreeHMAPtr, 0ffffh	; no more HMA if we have wrapped
InsuffHMA:
	pop	ds
	assume	ds:nothing
	jmp	i2f_iret
try_3:
	jmp	i2f_iret
i2f_handler endp

;
;--------------------------------------------------------------------------
;
; procedure : HMAPtr
;
;		Gets the offset of the free HMA area ( with respect to
;							seg ffff )
;		If DOS has not moved high, tries to move DOS high.
;		In the course of doing this, it will allocate all the HMA
;		and set the FreeHMAPtr to past the end of the BIOS and 
;		DOS code.  The call to MoveDOSIntoHMA (which is a pointer)
;		enters the routine in sysinit1 called FTryToMoveDOSHi.
;
;	RETURNS : offset of free HMA in DI
;		  BIOS_DATA, seg in DS
;
;--------------------------------------------------------------------------
;
HMAPtr	proc	near
	mov	ds, Bios_Data_Word
	assume	ds:Bios_Data
	mov	di, FreeHMAPtr
	cmp	di, 0ffffh
	jne	@f
	cmp	SysinitPresent, 0
	je	@f
	call	MoveDOSIntoHMA
	mov	di, FreeHMAPtr
@@:
	ret
HMAPtr	endp


Bios_Code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\spcemm.asm ===
;
; spcemm.asm,
;
; 10-Dec-1992 Jonle , adapted from em_drvr.asm from Insignia solutions
;
; This code serves as a stub device driver for emm memory manager.
; Its sole purpose is for apps to be able to identify that an emm driver is
; loaded and that LIM services are available. This code is linked into the
; device driver chain contains a strategy, interrupt and device header
;
; The driver should only be loaded if emm memory is available
; from NTVDM.
;

BOP     MACRO   callid
        db      0c4h, 0c4h, callid
endm


;
; Request Header, for initialization
;
REQHEAD  STRUC
ReqLen   DB      ?               ; Length in bytes of request block
ReqUnit  DB      ?               ; Block Device unit number
ReqFunc  DB      ?               ; Type of request
ReqStat  DW      ?               ; Status Word
REQHEAD  ENDS

;
; Segment definitions for ntio.sys,
;
include biosseg.inc
include vint.inc

SpcEmmSeg    segment

        assume  cs:SpcEmmSeg,ds:nothing,es:nothing

;
; SpcEmmBeg - SpcEmmEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 11-Dec-1992 Jonle
;

        public SpcEmmBeg

SpcEmmBeg    label  byte


;
; character device Header
; must be first in the .sys file
;
        dd      -1               ;pointer to next device driver
        dw      8000H            ;attribute (plain character device)
        dw      offset STRATEGY  ;pointer to device "strategy" routine
        dw      offset Interrupt ;pointer to device "interrupt" routine
        db      'EMMXXXX0'       ;8 byte name DO NOT CHANGE THE NAME

;
; Request Header address, saved here by strategy routine
;
pReqHdr   dd ?


;
; Device "strategy" entry point, save request header address
;
Strategy proc far
         mov     word ptr cs:pReqHdr, bx
         mov     word ptr cs:pReqHdr+2, es
         ret
Strategy endp


; EmmIsr  - int 67h isr
;
EmmIsr:          ; LIM Isr
        bop     67h
emmiret:
        FIRET

; ret trap for em function 'alter page map & call'
EmmRet:
        bop     68h
        jmp     emmiret



;----------------------------------------------------------------------
; 	Device "interrupt" entry point
;----------------------------------------------------------------------
Interrupt PROC FAR

        push    es
        push    di

        les     di, cs:pReqHdr           ; check for valid commands
        cmp     es:[di.ReqFunc], 0ah
        je      validcmd
        cmp     es:[di.ReqFunc], 0
        je      validcmd

        mov     ax, 8003h                ; we don't handle anything else
        jmp     short irptexit

validcmd:
        xor     ax,ax

irptexit:
        or      ax, 0100h          ;tell em we finished
        mov     es:[di.ReqStat],AX ;store status in request header

        pop    di
        pop    es
        ret

Interrupt ENDP

          public SpcEmmEnd
SpcEmmEnd label  byte

          public InitSpcEmm
;
; InitSpcEmm  Initializes Spc 32 bit memory manager
;             returns ax=0 for success
;
; Inputs:  ds is expected seg for drv code, cs is temporary sysinitseg
; Outputs: ax zero for success
;
InitSpcEmm  proc near

           ; BOP 66 - initialize LIM memory
           ; pass the address of bop 68 to the em manager
           ; in ds:dx and to return the number of em pages in BX
           ;
           ; NOTE: All EMM options come from pif file
           ;       There are NO command line options
           xor     bx, bx
           mov     dx, offset EmmRet
           bop     66h
           cmp     bx, 0ffffh     ;ffff means incorrect config (eg no 64K gap)
           je      fail
           cmp     bx, 0          ;check expanded memory is available
           je      fail

           ; set up IVT for INT 67h
           FCLI
           xor     ax, ax
           mov     es, ax
           mov     bx, offset EmmIsr
           mov     word ptr es:[67h*4], bx
           mov     word ptr es:[(67h*4)+2], ds
           FSTI

           ret
fail:
           mov ax, 0ffffh
           ret

InitSpcEmm endp

SpcEmmSeg  ends
           end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\msbio1.asm ===
page	,160
	title	msbio1.asm - Bios_Data definition and device driver entry/exit

;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------
;
	include version.inc	; set build flags
	include biosseg.inc	; define BIOS segments

	include	devsym.inc
	include	msequ.inc
	include vint.inc


; Assembly conditional for stack switching
;
STACKSW		equ	1

Bios_Data	segment

	assume	cs:Bios_Data
	public	BData_start
BData_start:


	assume	ds:nothing,es:nothing

	public	hdrv_pat
hdrv_pat label	word			; patched by msinit
	assume	cs:Bios_Data

	extrn	init:near		; this is in msinit

	jmp	init			; go to initialization code


;	define some stuff that is also used by msdos.sys from an include file

In_Bios	=	0ffffh	; define flag for msbdata.inc
	include	msbdata.inc


	public	inHMA,xms
inHMA	db	0		; flag indicates we're running from HMA
xms	dd	0		; entry point to xms if above is true

	align	4

	public	ntvdmstate
ntvdmstate  dd	0
IF 2
.errnz	ntvdmstate-BData_start-FIXED_NTVDMSTATE_OFFSET
ENDIF


	public	ptrsav
ptrsav	dd	0

	public	auxbuf
auxbuf	db	0,0,0,0   	;set of 1 byte buffers for com 1,2,3, and 4
	public	zeroseg
zeroseg dw	0		; easy way to load segment registers with zero

	public	auxnum
auxnum	dw	0			;which aux device was requested


	public	res_dev_list

res_dev_list	label	byte
	p_attr	=	chardev+outtilbusy+dev320+IOQUERY+DEVOPCL
; **	p_attr	=	chardev+outtilbusy+dev320

	sysdev <auxdev2,8013h,strategy,con_entry,'CON     '>
auxdev2 sysdev <prndev2,8000h,strategy,aux0_entry,'AUX     '>
prndev2 sysdev <timdev,p_attr,strategy,prn0_entry,'PRN     '>
timdev	sysdev <com1dev,8008h,strategy,tim_entry,'CLOCK$  '>
com1dev sysdev <lpt1dev,8000h,strategy,aux0_entry,'COM1    '>
lpt1dev sysdev <lpt2dev,p_attr,strategy,prn1_entry,"LPT1    ">
lpt2dev sysdev <lpt3dev,p_attr,strategy,prn2_entry,"LPT2    ">
lpt3dev sysdev <com2dev,p_attr,strategy,prn3_entry,"LPT3    ">
com2dev sysdev <com3dev,8000h,strategy,aux1_entry,"COM2    ">
com3dev sysdev <com4dev,8000h,strategy,aux2_entry,"COM3    ">
com4dev dw	-1,Bios_Data,8000h,strategy,aux3_entry
	db	"COM4    "


		public	RomVectors
RomVectors	label	byte
	public	Old10,	Old15, Old19, Old1B
	db	10h					; M028
Old10	dd	(?)					; M028
	db	15h
Old15	dd	(?)
	db	19h
Old19	dd	(?)
	db	1bh
Old1B	dd	(?)
EndRomVectors	equ	$
		public	NUMROMVECTORS
NUMROMVECTORS	equ	((EndRomVectors - RomVectors)/5)

	public	spc_mse_int10
spc_mse_int10	dd	(?)

	public	int29Perf
int29Perf	dd	(?)


	public	keyrd_func
	public	keysts_func

; moved altah to inc\msbdata.inc so it could go in instance table in DOS

keyrd_func	db	0	; default is conventional keyboard read
keysts_func	db	1	; default is conventional keyboard status check.

	public printdev
printdev	db	0		; index into above array

		public	multrk_flag
multrk_flag	dw	0

; the following variable can be modified via ioctl sub-function 16. in this
; way, the wait can be set to suit the speed of the particular printer being
; used. one for each printer device.

	public wait_count
wait_count	dw	4 dup (50h)	; array of retry counts for printer

	public	int19sem
int19sem db	0			; indicate that all int 19
					; initialization is complete

;	we assume the following remain contiguous and their order doesn't change
i19_lst:
	irp	aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
	public	int19old&aa
		db	aa&h	; store the number as a byte
int19old&aa	dd	-1	;orignal hardware int. vectors for int 19h.
	endm

num_i19 =	((offset $) - (offset i19_lst))/5


;variables for dynamic relocatable modules
;these should be stay resident.

	public	int6c_ret_addr
int6c_ret_addr	dd	?		; return address from int 6c for p12 machine

;
;   data structures for real-time date and time
;
	public	bin_date_time
	public	month_table
	public	daycnt2
	public	feb29

bin_date_time:
	db	0		; century (19 or 20) or hours (0-23)
	db	0		; year in century (0...99) or minutes (0-59)
	db	0		; month in year (1...12) or seconds (0-59)
	db	0		; day in month (1...31)

month_table:
	dw	0		; january
	dw	31		; february
	dw	59
	dw	90
	dw	120
	dw	151
	dw	181
	dw	212
	dw	243
	dw	273
	dw	304
	dw	334		; december
daycnt2 dw	0000		; temp for count of days since 1-1-80
feb29	db	0		; february 29 in a leap year flag


;************************************************************************
;*									*
;*	entry points into Bios_Code routines.  The segment values	*
;*	  are plugged in by seg_reinit.					*
;*									*
;************************************************************************

	public	cdev
cdev	dd	chardev_entry
bcode_i2f dd	i2f_handler
end_BC_entries:

;************************************************************************
;*									*
;*	cbreak - break key handling - simply set altah=3 and iret	*
;*									*
;************************************************************************

	public	cbreak
cbreak	proc	near
	assume	ds:nothing,es:nothing

	mov	altah,3		;indicate break key set

	public	intret		; general purpose iret in the Bios_Data seg
intret:
        FIRET
cbreak	endp

;************************************************************************
;*									*
;*	strategy - store es:bx (device driver request packet)		*
;*		     away at [ptrsav] for next driver function call	*
;*									*
;************************************************************************

	public	strategy
strategy proc	far
	assume	ds:nothing,es:nothing

	mov	word ptr cs:[ptrsav],bx
	mov	word ptr cs:[ptrsav+2],es
	ret
strategy endp

;************************************************************************
;*									*
;*	device driver entry points.  these are the initial		*
;*	  'interrupt' hooks out of the device driver chain.		*
;*	  in the case of our resident drivers, they'll just		*
;*	  stick a fake return address on the stack which		*
;*	  points to dispatch tables and possibly some unit		*
;*	  numbers, and then call through a common entry point		*
;*	  which can take care of a20 switching				*
;*									*
;************************************************************************

con_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry	; call into code segment handler
	dw	con_table

con_entry endp

;--------------------------------------------------------------------

prn0_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	0,0		; device numbers

prn0_entry endp

;--------------------------------------------------------------------

prn1_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	0,1

prn1_entry endp

;--------------------------------------------------------------------

prn2_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	1,2

prn2_entry endp

;--------------------------------------------------------------------

prn3_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	2,3

prn3_entry endp

;--------------------------------------------------------------------

aux0_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	0

aux0_entry endp

;--------------------------------------------------------------------

aux1_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	1

aux1_entry endp

;--------------------------------------------------------------------

aux2_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	2

aux2_entry endp

;--------------------------------------------------------------------

aux3_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	3

aux3_entry endp

;--------------------------------------------------------------------

tim_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	tim_table

tim_entry endp

;--------------------------------------------------------------------

;************************************************************************
;*									*
;*	Ensure A20 is enabled before jumping into code in HMA.		*
;*	This code assumes that if Segment of Device request packet is	*
;*	DOS DATA segment then the Device request came from DOS & that	*
;*	A20 is already on.						*
;*									*
;************************************************************************

cdev_entry proc	near
	assume	ds:nothing,es:nothing
;
; M064 - BEGIN
;
	cmp	inHMA, 0
	je	ce_enter_codeseg; optimized for DOS in HMA

	push	ax
	mov	ax, DosDataSg
	cmp	word ptr [ptrsav+2], ax
	pop	ax
	jne	not_from_dos	; jump is coded this way to fall thru
				;	in 99.99% of the cases
ce_enter_codeseg:
	jmp	cdev
not_from_dos:
	call	EnsureA20On
;
; M064 - END
;
	jmp	short ce_enter_codeseg
cdev_entry endp

;************************************************************************
;*									*
;*	outchr - this is our int 29h handler.  it writes the		*
;*	   character in al on the display using int 10h ttywrite	*
;*									*
;************************************************************************

	public	outchr
outchr	proc	far
	assume	ds:nothing,es:nothing

	push	ax
	push	si
	push	di
	push	bp
	push	bx
	mov	ah,0eh		; set command to write a character
	mov	bx,7		; set foreground color
	int	10h		; call rom-bios
	pop	bx
	pop	bp
	pop	di
	pop	si
	pop	ax
        jmp     intret
outchr	endp

; M001 - BEGIN

;************************************************************************
;*									*
;*	EnsureA20On - ensure that a20 is enabled if we're running	*
;*	  in the HMA before interrupt entry points into Bios_Code	*
;*									*
;************************************************************************

HiMem	label	dword
	dw	90h
	dw	0ffffh

LoMem	label	dword
	dw	80h
	dw	0h

EnsureA20On	proc near
	assume	ds:nothing,es:nothing
	call	IsA20Off
	jz	ea_enable
	ret

EnableA20	proc	near	; M041
ea_enable:
	push	ax
	push	bx
	mov	ah,5		; localenablea20
	call	xms
	pop	bx
	pop	ax
bie_done:
	ret
EnableA20	endp		; M041

EnsureA20On	endp
;
; M001 - END

; M041 : BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : IsA20Off
;
;----------------------------------------------------------------------------
;
IsA20Off	proc	near
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, HiMem
		les	di, LoMem
		mov	cx, 8
		rep	cmpsw
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		ret
IsA20Off	endp

;
;----------------------------------------------------------------------------
;
; procedure : DisableA20
;
;----------------------------------------------------------------------------
;
DisableA20	proc	near
		push	ax
		push	bx
		mov	ah,6		; localdisable a20
		call	xms
		pop	bx
		pop	ax
		ret
DisableA20	endp

; M041 : END

;************************************************************************
;*									*
;*	int19 - bootstrap interrupt -- we must restore a bunch of the	*
;*	  interrupt vectors before resuming the original int19 code	*
;*									*
;************************************************************************


	public	int19
int19	proc	far
	assume	ds:nothing,es:nothing

	push	cs
	pop	ds
	assume	ds:Bios_Data

	mov	es,zeroseg

	mov	cx, NUMROMVECTORS	; no. of rom vectors to be restored
	mov	si, offset RomVectors	; point to list of saved vectors
next_int:
	lodsb				; get int number
	cbw				; assume < 128
	shl	ax, 1
	shl	ax, 1			; int * 4
	mov	di, ax
	lodsw
	stosw
	lodsw
	stosw				; install the saved vector
	loop	next_int

	cmp	byte ptr int19sem,0	; don't do the others unless we
	jz	doint19			; set our initialization complete flag

;	stacks code has changed these hardware interrupt vectors
;	stkinit in sysinit1 will initialize int19holdxx values.

	mov	si,offset i19_lst
	mov	cx,num_i19

i19_restore_loop:
	lodsb			; get interrupt number
	cbw			; assume < 128
	mov	di,ax		; save interrupt number
	lodsw			; get original vector offset
	mov	bx,ax		; save it
	lodsw			; get original vector segment
	cmp	bx,-1		; check for 0ffffh (unlikely segment)
	jz	i19_restor_1	;opt no need to check selector too
	cmp	ax,-1		;opt 0ffffh is unlikely offset
	jz	i19_restor_1

	add	di,di
	add	di,di
	xchg	ax,bx
	stosw
	xchg	ax,bx
	stosw			; put the vector back

i19_restor_1:
	loop	i19_restore_loop

doint19:
	int	19h
int19	endp
;
; M036 - BEGIN
;
;
;----------------------------------------------------------------------------
;
; procedure : int15
;
;		Int15 handler for recognizing ctrl-alt-del seq.
;
;----------------------------------------------------------------------------
;
DELKEY		equ	53h
	public	Int15
Int15	proc	far
	assume	ds:nothing
	cmp	ax, (4fh shl 8) + DELKEY	; del keystroke ?
	je	@f
	jmp	dword ptr Old15			
@@:
	stc
	jmp	dword ptr Old15
Int15	endp
;
;
;************************************************************************
;*									*
;*	the int2f handler chains up to Bios_Code through here.		*
;*	  it returns through one of the three functions that follow.	*
;*	  notice that we'll assume we're being entered from DOS, so	*
;*	  that we're guaranteed to be A20 enabled if needed		*
;*									*
;************************************************************************

int_2f	proc	far
	assume	ds:nothing,es:nothing
	jmp	bcode_i2f
int_2f	endp



;************************************************************************
;*									*
;*	re_init - called back by sysinit after a bunch of stuff		*
;*		is done.  presently does nothing.  affects no		*
;*		registers!						*
;*									*
;************************************************************************

	public	re_init
re_init proc	far
	assume	ds:nothing,es:nothing
	ret
re_init endp


;SR; WIN386 support
; WIN386 instance data structure
;
;
; Here is a Win386 startup info structure which we set up and to which
; we return a pointer when Win386 initializes.
;

public	Win386_SI, SI_Version, SI_Next

Win386_SI	label	byte		; Startup Info for Win386
SI_Version	db	3, 0		; for Win386 3.0
SI_Next		dd	?		; pointer to next info structure
		dd	0		; a field we don't need
		dd	0		; another field we don't need
SI_Instance	dw	Instance_Table, Bios_Data ; far pointer to instance table

;
; This table gives Win386 the instance data in the BIOS and ROM-BIOS data
; areas.  Note that the address and size of the hardware stacks must
; be calculated and inserted at boot time.
;
Instance_Table	label	dword
	dw	00H, 50H		; print screen status...
	dw	02			; ...2 bytes
	dw	0Eh, 50H		; ROM Basic data...
	dw	14H			; ...14H bytes
	dw	ALTAH, Bios_Data	; a con device buffer...
	dw	01			; ... 1 byte
IF STACKSW
public NextStack
NextStack	label dword

;	NOTE:  If stacks are disabled by STACKS=0,0, the following
;		instance items WILL NOT be filled in by SYSINIT.
;		That's just fine as long as these are the last items
;		in the instance list since the first item is initialized
;		to 0000 at load time.

	dw	0, 0		; pointer to next stack to be used...
	dw	02			; ...2 bytes
; The next item in the instance table must be filled in at sysinit time
public IT_StackLoc, IT_StackSize
IT_StackLoc	dd	?		; location of hardware stacks
IT_StackSize	dw	?		; size of hardware stacks
ENDIF
	dd	0			; terminate the instance table

;SR;
; Flag to indicate whether Win386 is running or not
;
public	IsWin386
IsWin386		db	0

;
;This routine was originally in BIOS_CODE but this causes a lot of problems
;when we call it including checking of A20. The code being only about
;30 bytes, we might as well put it in BIOS_DATA
;
PUBLIC	V86_Crit_SetFocus

V86_Crit_SetFocus	PROC	FAR

			push	di
			push	es
			push	bx
			push	ax

			xor	di,di
			mov	es,di
			mov	bx,0015h	;Device ID of DOSMGR device
			mov	ax,1684h	;Get API entry point
			int	2fh
			mov	ax,es
			or	ax,di		
			jz	Skip
;
;Here, es:di is address of API routine. Set up stack frame to simulate a call
;
			push	cs		;push return segment
			mov	ax,OFFSET Skip
			push	ax		;push return offset
			push	es
			push	di		;API far call address
			mov	ax,1		;SetFocus function number
			retf			;do the call
Skip:
			pop	ax
			pop	bx
			pop	es
			pop	di
			ret
V86_Crit_SetFocus	ENDP



;
;End WIN386 support
;

		public	FreeHMAPtr
		public	MoveDOSIntoHMA
FreeHMAPtr	dw	-1
MoveDOSIntoHMA	dd	sysinitseg:FTryToMovDOSHi


;SR;
; A communication block has been setup between the DOS and the BIOS. All
;the data starting from SysinitPresent will be part of the data block.
;Right now, this is the only data being communicated. It can be expanded
;later to add more stuff
;
		public	SysinitPresent
		public	DemInfoFlag
SysinitPresent	db	0
DemInfoFlag     db      0


; this will be the end of the BIOS data if no hard disks are in system

	public	endBIOSData
endBIOSData label byte

Bios_Data ends

;
;	okay.  so much for Bios_Data.  Now let's put our device driver
;	  entry stuff up into Bios_Code.

Bios_Code	segment
	assume	cs:Bios_Code

; ORG a bit past zero to leave room for running in HMA...

	org	30h
	public	BCode_start
BCode_start:

;	device driver entry point tables

	extrn	con_table:near
	extrn	tim_table:near
	extrn	prn_table:near
	extrn	aux_table:near

	extrn	i2f_handler:far

	public	Bios_Data_Word
Bios_Data_Word	dw	Bios_Data

;************************************************************************
;*									*
;*	seg_reinit is called with ax = our new code segment value,	*
;*	  trashes di, cx, es						*
;*									*
;*	cas -- should be made disposable!				*
;*									*
;************************************************************************

	public	seg_reinit
seg_reinit	proc	far
	assume	ds:nothing,es:nothing

	mov	es,Bios_Data_Word
	assume	es:Bios_Data
	mov	di,2+offset cdev
	mov	cx,((offset end_BC_entries) - (offset cdev))/4

seg_reinit_1:
	stosw				; modify Bios_Code entry points
	inc	di
	inc	di
	loop	seg_reinit_1
	ret
seg_reinit	endp

;************************************************************************
;*									*
;*	chardev_entry - main device driver dispatch routine		*
;*	   called with a dummy parameter block on the stack		*
;*	   dw dispatch_table, dw prn/aux numbers (optional)		*
;*									*
;*	will eventually take care of doing the transitions in		*
;*	   out of Bios_Code						*
;*									*
;************************************************************************

chardev_entry	proc	far
	assume	ds:nothing,es:nothing

	push	si
	push	ax
	push	cx
	push	dx
	push	di
	push	bp
	push	ds
	push	es
	push	bx
	mov	bp,sp			; point to stack frame
	mov	si,18[bp]		; get return address (dispatch table)
	mov	ds,Bios_Data_Word	;  load ds: -> Bios_Data
	assume	ds:Bios_Data
	mov	ax,word ptr 2[si]	; get the device number if present
	mov	byte ptr [auxnum],al
	mov	byte ptr [printdev],ah
	mov	si,word ptr [si]	; point to the device dispatch table

	les	bx,[ptrsav]		;get pointer to i/o packet

	mov	al,byte ptr es:[bx].unit	;al = unit code
	mov	ah,byte ptr es:[bx].media	;ah = media descrip
	mov	cx,word ptr es:[bx].count	;cx = count
	mov	dx,word ptr es:[bx].start	;dx = start sector

	xchg	di,ax
	mov	al,byte ptr es:[bx].cmd
	cmp	al,cs:[si]
	jae	command_error

	cbw				; note that al <= 15 means ok
	shl	ax,1

	add	si,ax
	xchg	ax,di

	les	di,dword ptr es:[bx].trans

	cld				; ***** always clear direction
	call	cs:word ptr [si+1] 	;go do command
	assume	ds:nothing

	jc	already_got_ah_status	; if function returned status, don't
	mov	ah,1			;  load with normal completion

already_got_ah_status:
	mov	ds,Bios_Data_Word	; cas///// note: shouldn't be needed!
	assume	ds:Bios_Data
	lds	bx,[ptrsav]
	assume	ds:nothing
	mov	word ptr [bx].status,ax ;mark operation complete

	pop	bx
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	dx
	pop	cx
	pop	ax
	pop	si
	add	sp,2		; get rid of fake return address

chardev_entry endp		; fall through into bc_retf

	public	bc_retf
bc_retf	proc	far
	assume	ds:nothing,es:nothing

	ret

bc_retf	endp


command_error:
	call	bc_cmderr
	jmp	short already_got_ah_status

;
;----------------------------------------------------------------------------
; The following piece of hack is for supporting CP/M compatibility
; Basically at offset 5 we have a far call into 0:c0. But this does not call
; 0:c0 directly instead it call f01d:fef0, because it needs to support 'lhld 6'
; The following hack has to reside at ffff:d0 (= f01d:fef0) if BIOS is loaded
; high.
;----------------------------------------------------------------------------


; BUGBUG sudeepb 21-May-1991 ; We can save these 30 bytes by moving
; off_d0 to right place.

	db	1fh dup (?)	; pad to bring offset to 0d0h

if2
	if ( offset off_d0 - 0d0h )
		%out CP/M compatibilty broken!!!
		%out Please re-pos hack to ffff:d0
	endif
endif

	public	off_d0
off_d0	db	5 dup (?)	; 5 bytes from 0:c0 will be copied onto here
				;  which is the CP/M call 5 entry point
	.errnz (offset off_d0 - 0d0h)


;----------------------------------------------------------
;
;	exit - all routines return through this path
;

	public	bc_cmderr
bc_cmderr:
	mov	al,3			;unknown command error

;	now zero the count field by subtracting its current value,
;	  which is still in cx, from itself.


;	subtract the number of i/o's NOT YET COMPLETED from total
;	  in order to return the number actually complete


	public	bc_err_cnt
bc_err_cnt:
	assume	ds:Bios_Data
	les	bx,[ptrsav]
	assume	es:nothing
	sub	es:word ptr [bx].count,cx;# of successful i/o's
	mov	ah,81h			;mark error return
	stc				; indicate abnormal end
	ret

Bios_Code	ends


;	the last real segment is sysinitseg

sysinitseg	segment
	assume	cs:sysinitseg
	extrn	FTryToMovDOSHi:far
	public	SI_start
SI_start:
sysinitseg	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\msequ.inc ===
ftoobig 	equ	80h
fbig		equ	40h
romstatus	equ	1
romread 	equ	2
romwrite	equ	3
romverify	equ	4
romformat	equ	5


rsinit	=	0a3h	;rs232 initialization
			;9600 baud:no parity:1 stop:8 bit word

lf	=	10	;line feed
cr	=	13	;carriage return
backsp	=	8	;backspace
brkadr	=	1bh * 4	;006c	1bh break vector address
timadr	=	1ch * 4	;0070	1ch timer interrupt
dskadr	=	1eh * 4	;address of ptr to disk parameters
sec9	=	522h	;address of disk parameters
headsettle=	sec9+9	;address of head settle time
normsettle=	15	;normal head settle
speedsettle=	0	;speed up settle time
initspot=	534h	;ibm wants 4 zeros here
akport	=	20h
eoi	=	20h

cmdlen	=	0	;length of this command
unit	=	1	;sub unit specifier
cmd	=	2	;command code
status	=	3	;status
media	=	13	;media descriptor
trans	=	14	;transfer address
count	=	18	;count of blocks or characters
start	=	20	;first block to transfer
extra	=	22	;usually a pointer to vol id for error 15
start_l =	26	; extended start sector (low)
start_h =	28	; extended start sector (high)


chrout	=	29h
maxerr	=	5
lstdrv	=	504h

bootbias	=	200h
notbusystatus	=	10000000b	; not busy
ackstatus	=	01000000b	; acknowledge (for what?)
nopaperstatus	=	00100000b	; no more paper
.selectedstatus	=	00010000b	; the printer said it was selected
ioerrstatus	=	00001000b	; some kinda error
reserved	=	00000110b	; nops
timeoutstatus	=	00000001b	; time out.
error_unknown_media = 7			; for use in build bpb call



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\msinit.asm ===
page	,160
	title	msinit for BIOS
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------
;

EXTENDEDKEY	equ	1	; use extended keyboard functions

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include	msequ.inc
	include dossym.inc
	include	dosmac.inc
	include biostruc.inc
        include dossvc.inc
        include vint.inc

;	the following segment follows sysinit.  It is used to define
;	the location to load MSDOS.SYS into.

dos_load_seg	segment	para public 'dos_load_seg'
dos_load_seg	ends

	extrn	RomVectors:dword
	extrn	NUMROMVECTORS:abs
	extrn	res_dev_list:word
	extrn	keyrd_func:byte 	; for mscon. defined in msdata.
	extrn	keysts_func:byte	; for mscon. defined in msdata.
	extrn	endBIOSData:byte

	extrn	dosdatasg:word

	extrn	Int15:far		; M036
	extrn	int19:far
	extrn	intret:near
	extrn	cbreak:near
	extrn	outchr:near
	extrn	outchr:near

sysinitseg segment 
	assume	cs:sysinitseg
	extrn	current_dos_location:word
	extrn	device_list:dword
	extrn	memory_size:word
	extrn	sysinit:far
sysinitseg ends

Bios_Data_Init segment
	assume	cs:datagrp

;*********************************************************
;	system initialization
;
;	the entry conditions are established by the bootstrap
;	loader and are considered unknown. the following jobs
;	will be performed by this module:
;
;	1.	all device initialization is performed
;
;	2.	a local stack is set up and ds:si are set
;		to point to an initialization table. then
;		an inter-segment call is made to the first
;		byte of the dos
;
;	3.	once the dos returns from this call the ds
;		register has been set up to point to the start
;		of free memory. the initialization will then
;		load the command program into this area
;		beginning at 100 hex and transfer control to
;		this program.
;
;********************************************************



;===========================================================================
;
; entry from boot sector.  the register contents are:
;
;   dl = int 13 drive number we booted from
;   ch = media byte
;   bx = first data sector on disk.
;   ax = first data sector (high)
;   di = sectors/fat for the boot media.
;
	public	init
init	proc	near
	assume	ds:nothing,es:nothing

        FCLI
	xor	ax,ax
	mov	ds,ax

; Save a pack of interrupt vectors...

	push	cs
	pop	es			; cannot use cs override for stos

	mov	cx, NUMROMVECTORS     	; no. of rom vectors to be saved
	mov	si, offset RomVectors	; point to list of int vectors
next_int:				
	lods	byte ptr cs:[si]	; get int number
	cbw				; assume < 128
	shl	ax, 1
	shl	ax, 1			; int no * 4
	mov	di, ax
	xchg	si, di
	lodsw
	stosw
	lodsw
	stosw				; save the vector
	xchg	si, di
	loop	next_int

; set up int 15 for new action				; M036

	mov	word ptr ds:[15h*4],offset Int15	; M036
	mov	ds:[15h*4+2],cs				; M036



; set up int 19 for new action

	mov	word ptr ds:[19h*4],offset int19
	mov	ds:[19h*4+2],cs

;
	xor	dx,dx
	mov	ss,dx
	mov	sp,700h 		;local stack
        FSTI
	assume	ss:nothing

       ; NTVDM we do not intialize the com,prn ports here
       ; to stay seamless with the host OS
       ; 15-Sep-1992 Jonle
       ;
       ; mov     al,3            ; init com4
       ; call    aux_init
       ; mov     al,2            ; init com3
       ; call    aux_init
       ; mov     al,1            ; init com2
       ; call    aux_init
       ; xor     al,al           ; init com1
       ; call    aux_init
       ;
       ; mov     al,2            ; init lpt3
       ; call    print_init
       ; mov     al,1            ; init lpt2
       ; call    print_init
       ; xor     al,al           ; init lpt1
       ; call    print_init

        xor     dx,dx
	mov	ds,dx		; to initialize print screen vector
	mov	es,dx

	xor	ax,ax
	mov	di,initspot
	stosw			; init four bytes to 0
	stosw

	mov	ax,cs		; fetch segment

	mov	ds:word ptr brkadr,offset cbreak ;break entry point
	mov	ds:brkadr+2,ax		;vector for break

	mov	ds:word ptr chrout*4,offset outchr
	mov	ds:word ptr chrout*4+2,ax

	mov	di,4
	mov	bx,offset intret	;will initialize rest of interrupts
	xchg	ax,bx
	stosw				;location 4
	xchg	ax,bx
	stosw				;int 1	;location 6
	add	di,4
	xchg	ax,bx
	stosw				;location 12
	xchg	ax,bx
	stosw				;int 3	;location 14
	xchg	ax,bx
	stosw				;location 16
	xchg	ax,bx
	stosw				;int 4	;location 18

	mov	ds:word ptr 500h,dx	;set print screen & break =0
	mov	ds:word ptr lstdrv,dx	;clean out last drive spec


	mov	dx,sysinitseg
	mov	ds,dx

	assume	ds:sysinitseg

; set pointer to resident device driver chain

	mov	word ptr device_list,offset res_dev_list
	mov	word ptr device_list+2,cs


	mov	current_dos_location,dos_load_seg ; will load MSDOS here


ifdef	EXTENDEDKEY

; we will check if the system has ibm extended keyboard by
; looking at a byte at 40:96.  if bit 4 is set, then extended key board
; is installed, and we are going to set keyrd_func to 10h, keysts_func to 11h
; for the extended keyboard function. use cx as the temporary register.

	xor	cx,cx
	mov	ds,cx
	assume	ds:nothing
	mov	cl,ds:0496h			; get keyboard flag
	test	cl,00010000b
	jz	org_key				; orginal keyboard
	mov	byte ptr keyrd_func,10h		; extended keyboard
	mov	byte ptr keysts_func,11h	; change for ext. keyboard functions
org_key:

endif

	push	cs
	pop	ds
	push	cs
	pop	es

	assume	ds:datagrp, es:datagrp

	mov	di, offset endBIOSData	; BIOS data segment end address
	shr	di,1
	shr	di,1
	shr	di,1
	shr	di,1			; Converted to segmnet
	inc	di			; para align

	add	di,datagrp		; Add segment of BIOS data
	mov	[dosdatasg],di		; di = to be dos data segment

	mov	di,dos_load_seg

	SVC	SVC_DEMLOADDOS		; di is segment to load DOS
					; If it fails it never comes back

	jmp	sysinit

init	endp


;--------------------------------------------------------------------

; al = device number

print_init proc	near
	assume	ds:nothing,es:nothing

	cbw
	mov	dx,ax			; get printer port number into dx
	mov	ah,1			;initalize printer port
	int	17h			;call rom-bios routine
	ret

print_init endp

;--------------------------------------------------------------------

aux_init proc	near
	assume	ds:nothing,es:nothing

	cbw
	mov	dx,ax
	mov	al,rsinit		;2400,n,1,8 (msequ.inc)
	mov	ah,0			;initalize aux port
	int	14h			;call rom-bios routine
	ret

aux_init endp

Bios_Data_Init	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\biostruc.inc ===
; rom bios call packet structures

;*******************************
;system service call ( int 15h )
;*******************************
;function ah = 0c0h, return system configuration
;for pc and pcjr on return:
;	(ah)	= 80h
;	(cy)	= 1
;for pcxt, pc portable and pcat on return:
;	(ah)	= 86h
;	(cy)	= 1
;for all others:
;	(ah)	= 0
;	(cy)	= 0
;	(es:bx) = pointer to system descriptor vector in ros
; system descriptor :
;	dw	xxxx		length of descriptor in bytes,
;				minimum length = 8
;	db	xx		model byte
;				0ffh	= pc
;				0feh	= pc/xt, portable
;				0fdh	= pc/jr
;				0fch	= pc/at, 6mhz pc/at,
;					  6mhz pc/at running coprocessor(?),
;					  ps/2 model 50, 50 z
;				0fah	= ps/2 model 25, 30
;				0f9h	= pc convertible
;				0f8h	= ps/2 model 80
;				0f7h	= nova
;				0e0 thru 0efh = reserved
;
;	db	xx		secondary model byte
;				000h	= pc1
;				000h	= pc/xt, portable
;				000h	= pc/jr
;				000h	= pc/at
;				001h	= 6mhz pc/at
;				003h	= 6mhz pc/at running coprocessor(?)
;				004h	= ps/2 model 50, 50z
;				001h	= ps/2 model 25
;				000h	= pc convertible
;				000h	= ps/2 model 80
;				000h	= nova
;
;	db	xx		bios revision level
;				00 for first release, subsequent release
;				of code with same model byte and
;				secondary model byte require revison level
;				to increase by one.
;
;	db	xx		feature information byte 1
;				x0000000 = 1, bios use dma channel 3
;					 = 0, dma channel 3 not used
;
;				0x000000 = 1, 2nd interrupt chip present
;					 = 0, 2nd interrupt chip not present
;
;				00x00000 = 1, real time clock present
;					 = 0, real time clock not present
;
;				000x0000 = 1, keyboard escape sequence(int15h)
;						called in keyboard interrupt
;						(int 09h).
;					 = 0, keyboard escape sequence not
;						called.
;				0000xxxx reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;

bios_system_descriptor	struc
bios_sd_leng		dw	?
bios_sd_modelbyte	db	?
bios_sd_scnd_modelbyte	db	?
			db	?
bios_sd_featurebyte1	db	?
			db   4 dup (?)
bios_system_descriptor ends

;featurebyte1	bit map equates
dmachannel3		equ 10000000b
scndintcontroller	equ 01000000b
realtimeclock		equ 00100000b
keyescapeseq		equ 00010000b
;
;model byte
mdl_pc1 	equ	0ffh
mdl_xt		equ	0feh
mdl_jr		equ	0fdh
mdl_at		equ	0fch
mdl_convert	equ	0f9h

mdl_ps2_30	equ	0fah
mdl_ps2_80	equ	0f8h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\devmark.inc ===
;structure, equtes for devmark for mem command.

devmark struc
devmark_id	  db	  0
devmark_seg	  dw	  0
devmark_size	  dw	  0
devmark_dum	  db	  3 dup (?)
devmark_filename  db	  8 dup (' ')
devmark ends

devmark_stk	equ	'S'
devmark_device	equ	'D'
devmark_ifs	equ	'I'
devmark_buf	equ	'B'
devmark_cds	equ	'L' ;lastdrive
devmark_files	equ	'F'
devmark_fcbs	equ	'X'
devmark_inst    equ     'T' ;used for sysinit base for install= command.

devmark_spc     equ     'Q' ;used for spckbd,spcmse

setbrkdone	equ	00000001b
for_devmark	equ	00000010b
not_for_devmark equ	11111101b
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\mschar.asm ===
page	,160
	title	mschar - character and clock devices
;
;----------------------------------------------------------------------------
;
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;
;----------------------------------------------------------------------------
;

	.xlist

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include msequ.inc
	include	devsym.inc
        include ioctl.inc
        include vint.inc

break	macro
	endm

        include biosbop.inc

	include error.inc
	.list

	include msgroup.inc	; define Bios_Data segment


	extrn	ptrsav:dword

	extrn	altah:byte
	extrn	keyrd_func:byte
	extrn	keysts_func:byte

	extrn	auxnum:word
	extrn	auxbuf:byte

	extrn	wait_count:word
	extrn	printdev:byte
	extrn	Old10:dword
	extrn	spc_mse_int10:dword
	extrn	int29Perf:dword


; close Bios_Data and open Bios_Code segment

	tocode

	extrn	bc_cmderr:near
	extrn	bc_err_cnt:near

MODE_CTRLBRK	equ	0ffh		; M013

;************************************************************************
;*									*
;*	device driver dispatch tables					*
;*									*
;*	each table starts with a byte which lists the number of		*
;*	legal functions, followed by that number of words.  Each	*
;*	word represents an offset of a routine in Bios_Code which	*
;*	handles the function.  The functions are terminated with	*
;*	a near return.  If carry is reset, a 'done' code is returned	*
;*	to the caller.  If carry is set, the ah/al registers are	*
;*	returned as abnormal completion status.  Notice that ds		*
;*	is assumed to point to the Bios_Data segment throughout.	*
;*									*
;************************************************************************

	public	con_table
con_table:
	db	(((offset con_table_end) - (offset con_table) - 1)/2)
	dw	bc_exvec	; 00 init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	con_read	; 04
	dw	con_rdnd	; 05
	dw	bc_exvec	; 06
	dw	con_flush	; 07
	dw	con_writ	; 08
	dw	con_writ	; 09
	dw	bc_exvec	; 0a
con_table_end:

	public	prn_table
prn_table	label	byte
	db	(((offset prn_table_end) - (offset prn_table) -1)/2)
	dw	bc_exvec	; 00 init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	prn_input	; 04 indicate zero chars read
	dw	z_bus_exit	; 05 read non-destructive
	dw	bc_exvec	; 06
	dw	bc_exvec	; 07
	dw	prn_writ	; 08
	dw	prn_writ	; 09
	dw	prn_stat	; 0a
	dw	bc_exvec	; 0b
	dw	bc_exvec	; 0c
	dw	prn_open	; 0d
	dw	prn_close	; 0e
	dw	bc_exvec	; 0f
	dw	prn_tilbusy	; 10
	dw	bc_exvec	; 11
	dw	bc_exvec	; 12
	dw	prn_genioctl	; 13
	dw	bc_exvec	; 14
	dw	bc_exvec	; 15
	dw	bc_exvec	; 16
	dw	bc_exvec	; 17
	dw	bc_exvec	; 18
	dw	prn_ioctl_query	; 19
prn_table_end:



	public	aux_table
aux_table	label	byte
	db	(((offset aux_table_end) - (offset aux_table) -1)/2)

	dw	bc_exvec	; 00 - init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	aux_read	; 04 - read
	dw	aux_rdnd	; 05 - read non-destructive
	dw	bc_exvec	; 06
	dw	aux_flsh	; 07
	dw	aux_writ	; 08
	dw	aux_writ	; 09
	dw	aux_wrst	; 0a
aux_table_end:


	public	tim_table
tim_table	label	byte
	db	(((offset tim_table_end) - (offset tim_table) -1)/2)
	dw	bc_exvec	; 00
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	bc_cmderr	; 04
	dw	z_bus_exit	; 05
	dw	bc_exvec	; 06
	dw	bc_exvec	; 07
	dw	bc_cmderr	; 08
	dw	bc_cmderr	; 09
tim_table_end:

;************************************************************************
;*									*
;*	con_read - read cx bytes from keyboard into buffer at es:di	*
;*									*
;************************************************************************

con_read proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	con_exit

con_loop:
	call	chrin		;get char in al
	stosb			;store char at es:di
	loop	con_loop

con_exit:
	clc
	ret
con_read endp

;************************************************************************
;*									*
;*	chrin - input single char from keyboard into al			*
;*									*
;*	  we are going to issue extended keyboard function, if		*
;*	  supported.  the returning value of the extended keystroke	*
;*	  of the extended keyboard function uses 0e0h in al		*
;*	  instead of 00 as in the conventional keyboard function.	*
;*	  this creates a conflict when the user entered real		*
;*	  greek alpha charater (= 0e0h) to  distinguish the extended	*
;*	  keystroke and the greek alpha.  this case will be handled	*
;*	  in the following manner:					*
;*									*
;*	      ah = 16h							*
;*	      int 16h							*
;*	      if al == 0, then extended code (in ah)			*
;*	      else if al == 0e0h, then					*
;*	      if ah <> 0, then extended code (in ah)			*
;*		else greek_alpha character.				*
;*									*
;*	also, for compatibility reason, if an extended code is		*
;*	  detected, then we are going to change the value in al		*
;*	  from 0e0h to 00h.						*
;*									*
;************************************************************************


chrin	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah,keyrd_func		; set by msinit. 0 or 10h
	xor	al,al
	xchg	al,altah		;get character & zero altah

	or	al,al
	jnz	keyret

	int	16h			; do rom bios keyrd function

alt10:
	or	ax,ax			;check for non-key after break
	jz	chrin

	cmp	ax,7200h		;check for ctrl-prtsc
	jnz	alt_ext_chk

	mov	al,16
	jmp	short keyret

alt_ext_chk:

;**************************************************************
;  if operation was extended function (i.e. keyrd_func != 0) then
;    if character read was 0e0h then
;      if extended byte was zero (i.e. ah == 0) then
;	 goto keyret
;      else
;	 set al to zero
;	 goto alt_save
;      endif
;    endif
;  endif

	cmp	byte ptr keyrd_func,0
	jz	not_ext
	cmp	al,0e0h
	jnz	not_ext

	or	ah,ah
	jz	keyret
ifdef	DBCS
ifdef   KOREA                           ; Keyl  1990/11/5
        cmp     ah, 0f0h                ; If hangeul code range then
        jb      EngCodeRange1           ; do not modify any value.
        cmp     ah, 0f2h
        jbe     not_ext
EngCodeRange1:
endif	; KOREA
endif	; DBCS
	xor	al,al
	jmp	short alt_save

not_ext:

	or	al,al			;special case?
	jnz	keyret

alt_save:
	mov	altah,ah		;store special key
keyret:
	ret
chrin	endp

;************************************************************************
;*									*
;*	con_rdnd - keyboard non destructive read, no wait		*
;*									*
;*	pc-convertible-type machine: if bit 10 is set by the dos	*
;*	in the status word of the request packet, and there is no	*
;*	character in the input buffer, the driver issues a system	*
;*	wait request to the rom. on return from the rom, it returns	*
;*	a 'char-not-found' to the dos.					*
;*									*
;************************************************************************

con_rdnd proc	near
	assume	ds:Bios_Data,es:nothing

	mov	al,[altah]
	or	al,al
	jnz	rdexit

	mov	ah,keysts_func		; keyboard i/o interrupt - get
	int	16h			;  keystroke status (keysts_func)
	jnz	gotchr

;
; pc-convertible checking is not needed on NTVDM
; if no key in buff return immediatly with busy status
;04-Aug-1992 Jonle
;
;	cmp	fhavek09,0
;	jz	z_bus_exit		; return with busy status if not k09
;
;       les     bx,[ptrsav]
;       assume  es:nothing
;       test    es:[bx].status,0400h    ; system wait enabled?
;       jz      z_bus_exit              ;  return with busy status if not
;
;	need to wait for ibm response to request for code
;	on how to use the system wait call.
;
;        mov     ax,4100h                ; wait on an external event
;        xor     bl,bl                   ; M055; wait for any event
;        int     15h                     ; call rom for system wait

z_bus_exit:
	stc
	mov	ah,3			; indicate busy status
	ret

gotchr:
	or	ax,ax
	jnz	notbrk			;check for null after break

	mov	ah,keyrd_func		; issue keyboard read function
	int	16h
	jmp	con_rdnd		;and get a real status

notbrk:
	cmp	ax,7200h		;check for ctrl-prtsc
	jnz	rd_ext_chk

	mov	al,'P' and 1fh		; return control p
	jmp	short rdexit

rd_ext_chk:
	cmp	keyrd_func,0		; extended keyboard function?
	jz	rdexit			; no. normal exit.

	cmp	al,0e0h 		; extended key value or greek alpha?
	jne	rdexit

ifdef	DBCS
ifdef   KOREA
        cmp     ah, 0f0h                ; If hangeul code range then
        jb      EngCodeRange            ; do not modify any value.
        cmp     ah, 0f2h
        jbe     rdexit                  ; Keyl 90/11/5
EngCodeRange:
endif	; KOREA
endif	; DBCS

	cmp	ah,0			; scan code exist?
	jz	rdexit			; yes. greek alpha char.
	mov	al,0			; no. extended key stroke.
					;  change it for compatibility

rdexit:
	les	bx,[ptrsav]
	assume	es:nothing
	mov	es:[bx].media,al	; *** return keyboard character here

bc_exvec:
	clc				; indicate normal termination
	ret

con_rdnd endp

;************************************************************************
;*									*
;*	con_write - console write routine				*
;*									*
;*	entry:	es:di -> buffer						*
;*		cx    =  count						*
;*									*
;************************************************************************

con_writ proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	bc_exvec

	push	es

	mov	bx,word ptr [int29Perf]
	mov	dx,word ptr [int29Perf+2] ;DX:BX is original INT 29h vector
	sub	ax,ax
	mov	es,ax
	cmp	BX,es:[29h*4+0]
	jne	con_lp1 		; if not the same do single int10s
	cmp	DX,es:[29h*4+2]
	jne	con_lp1 		; if not the same do single int10s
	mov	bx,word ptr [spc_mse_int10]
	mov	dx,word ptr [spc_mse_int10+2] ;DX:BX is original INT 10h vector
	cmp	BX,es:[10h*4+0]
	jne	con_lp1 		; if not the same do single int10s
	cmp	DX,es:[10h*4+2]
	jne	con_lp1 		; if not the same do single int10s

	pop	es

	; Sudeepb 21-Jul-1992:	We know that no one has hooked in10 so we
	; can optimize it by calling a private in1t10h which takes a full
	; string, displays it with the same attribute as present on the
	; screen and moves the cursor to the end.

	mov	ax,46h		; sounds like a good flag value
	push	ax		; make an iret frame
	push	cs
	mov	ax, offset ret_adr
	push	ax
	push	dx		; dx:bx is pointing to softpc int10 handler
	push	bx		; make the retf frame
	mov	ax,13FFh	; AH = WRITESTRING, AL = subfunction
	retf
ret_adr:
	jmp	short cc_ret

con_lp1:
	pop	es

con_lp:
	mov	al,es:[di]		;get char
	inc	di
	int	chrout			;output char
	loop	con_lp			;repeat until all through

cc_ret:
	clc
	ret
con_writ	endp

;************************************************************************
;*									*
;*	con_flush - flush out keyboard queue				*
;*									*
;************************************************************************

	public	con_flush	; called from msbio2.asm for floppy swapping
con_flush proc	near
	assume	ds:Bios_Data,es:nothing


	mov	[altah],0		;clear out holding buffer

;	while (charavail()) charread();

flloop:
	mov	ah,1			; command code for check status
	int	16h			; call rom-bios keyboard routine
	jz	cc_ret			; return carry clear if none

	xor	ah,ah			; if zf is nof set, get character
	int	16h			; call rom-bios to get character
	jmp	flloop

con_flush endp

;************************************************************************
;*									*
;*	some equates for rom bios printer i/o				*
;*									*
;************************************************************************

; ibm rom status bits (i don't trust them, neither should you)
; warning!!!  the ibm rom does not return just one bit.  it returns a
; whole slew of bits, only one of which is correct.


notbusystatus	=   10000000b		; not busy
nopaperstatus	=   00100000b		; no more paper
prnselected	=   00010000b		; printer selected
ioerrstatus	=   00001000b		; some kinda error
timeoutstatus	=   00000001b		; time out.

noprinter	=   00110000b		; no printer attached

;************************************************************************
;*									*
;*	prn_input - return with no error but zero chars read		*
;*									*
;*	enter with cx = number of characters requested			*
;*									*
;************************************************************************

prn_input proc	near
	assume	ds:Bios_Data,es:nothing

	call	bc_err_cnt	; reset count to zero (sub reqpkt.count,cx)
	clc			;  but return with carry reset for no error
	ret

prn_input endp

;************************************************************************
;*									*
;*	prn_writ - write cx bytes from es:di to printer device		*
;*									*
;*	auxnum has printer number					*
;*									*
;************************************************************************

prn_writ proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	prn_done		;no chars to output

prn_loop:
	mov	bx,2			;retry count

prn_out:
	call	prnstat 		; get status
	jnz	TestPrnError		; error

	mov	al,es:[di]		; get character to print
	xor	ah,ah
	call	prnop			; print to printer
	jz	prn_con			; no error - continue

	cmp	ah, MODE_CTRLBRK	; M013
	jne	@f			; M013
	mov	al, error_I24_gen_failure ; M013
	mov	altah, 0		; M013
	jmp	short pmessg		; M013
@@:
	test	ah,timeoutstatus
	jz	prn_con			; not time out - continue

TestPrnError:
	dec	bx			;retry until count is exhausted.
	jnz	prn_out

pmessg:
	jmp	bc_err_cnt		; return with error

; next character

prn_con:
	inc	di			;point to next char and continue
	loop	prn_loop

prn_done:
	clc
	ret
prn_writ	endp

;************************************************************************
;*									*
;*	prn_stat - device driver entry to return printer status		*
;*									*
;************************************************************************

prn_stat proc	near

	call	prnstat 		;device in dx
	jnz	pmessg			; other errors were found
	test	ah,notbusystatus
	jnz	prn_done		;no error. exit
	jmp	z_bus_exit		; return busy status
prn_stat endp

;************************************************************************
;*									*
;*	prnstat - utilty function to call ROM BIOS to check		*
;*		 printer status.  Return meaningful error code		*
;*									*
;************************************************************************

prnstat proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah, 2			; set command for get status
prnstat	endp				; fall into prnop

;************************************************************************
;*									*
;*	prnop - call ROM BIOS printer function in ah			*
;*		return zero true if no error				*
;*		return zero false if error, al = error code		*
;*									*
;************************************************************************

prnop	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	dx,[auxnum]		; get printer number
	int	17h			; call rom-bios printer routine

		; This check was added to see if this is a case of no
		; printer being installed. This tests checks to be sure
		; the error is noprinter (30h)

	push	ax			; M044
	and	ah, noprinter		; M044
	cmp	AH,noprinter		; Chk for no printer
	pop	ax			; M044

	jne	NextTest
	and	AH,NOT nopaperstatus
	or	AH,ioerrstatus

; examine the status bits to see if an error occurred.	unfortunately, several
; of the bits are set so we have to pick and choose.  we must be extremely
; careful about breaking basic.

NextTest:
	test	ah,(ioerrstatus+nopaperstatus) ; i/o error?
	jz	checknotready		; no, try not ready

; at this point, we know we have an error.  the converse is not true.

	mov	al,error_I24_out_of_paper
					; first, assume out of paper
	test	ah,nopaperstatus	; out of paper set?
	jnz	ret1			; yes, error is set
	inc	al			; return al=10 (i/o error)
ret1:
	ret				; return with error

checknotready:
	mov	al,2			; assume not-ready
	test	ah,timeoutstatus	; is time-out set?
	ret				; if nz then error, else ok
prnop endp

;************************************************************************
;*                                                                      *
;*      prn_open    - send bop to disable auto-close, and wait for      *
;*                   a DOS close                                        *
;*                                                                      *
;*      inputs:                                                         *
;*      outputs: BOP has been issued                                    *
;*                                                                      *
;************************************************************************

prn_open proc near
        push    si
        push    dx
        push    ds
        mov     dx,40h
        mov     ds,dx
        test    word ptr ds:[FIXED_NTVDMSTATE_REL40],  EXEC_BIT_MASK
        pop     ds
        jnz     po_nobop
        xor     dh, dh
        mov     dl, [printdev]
        or      dl, dl
        jz      @f
        dec     dl
@@:
        mov     si,PRNIO_OPEN
        bop     %BIOS_PRINTER_IO
po_nobop:
        pop     dx
        pop     si
        ret
prn_open endp

;************************************************************************
;*                                                                      *
;*      prn_close   - send bop to close actual printer, and re-enable   *
;*                   autoclose                                          *
;*                                                                      *
;*      inputs:                                                         *
;*      outputs: BOP has been issued                                    *
;*                                                                      *
;************************************************************************

prn_close proc near
        push    si
        push    dx
        push    ds
        mov     dx,40h
        mov     ds,dx
        test    word ptr ds:[FIXED_NTVDMSTATE_REL40],  EXEC_BIT_MASK
        pop     ds
        jnz     pc_nobop
        xor     dh, dh
        mov     dl, [printdev]
        or      dl, dl
        jz      @f
        dec     dl
@@:
        mov     si,PRNIO_CLOSE
        bop     %BIOS_PRINTER_IO
pc_nobop:
        pop     dx
        pop     si
        ret
prn_close endp

;************************************************************************
;*									*
;*	prn_tilbusy - output until busy.  Used by print spooler.	*
;*		     this entry point should never block waiting for	*
;*		     device to come ready.				*
;*									*
;*	inputs:	cx = count, es:di -> buffer				*
;*	outputs: set the number of bytes transferred in the		*
;*		 device driver request packet				*
;*									*
;************************************************************************

prn_tilbusy proc near

	mov	si,di			; everything is set for lodsb

prn_tilbloop:
	push	cx

	push	bx
	xor	bh,bh
	mov	bl,[printdev]
	shl	bx,1
	mov	cx,wait_count[bx]	; wait count times to come ready
	pop	bx

prn_getstat:
	call	prnstat 		; get status
	jnz	prn_bperr		; error
	test	ah,10000000b		; ready yet?
	loopz	prn_getstat		; no, go for more

	pop	cx			; get original count
	jz	prn_berr		; still not ready => done

	lods	es:byte ptr [si]
	xor	ah,ah
	call	prnop
	jnz	prn_berr		; error

	loop	prn_tilbloop		; go for more

	clc				; normal no-error return
	ret				;   from device driver

prn_bperr:
	pop	cx			; restore transfer count from stack

prn_berr:
	jmp	bc_err_cnt
prn_tilbusy endp

;************************************************************************
;*									*
;*	prn_genioctl - get/set printer retry count			*
;*									*
;************************************************************************

prn_genioctl proc near
	assume	ds:Bios_Data,es:nothing

	les	di,[ptrsav]
	cmp	es:[di].majorfunction,ioc_pc
	jz	prnfunc_ok

prnfuncerr:
	jmp	bc_cmderr

prnfunc_ok:
	mov	al,es:[di].minorfunction
	les	di,es:[di].genericioctl_packet
	xor	bh,bh
	mov	bl,[printdev]		; get index into retry counts
	shl	bx,1
	mov	cx,wait_count[bx]	; pull out retry count for device

	cmp	al,get_retry_count
	jz	prngetcount

	cmp	al,set_retry_count
	jnz	prnfuncerr

	mov	cx,es:[di].rc_count
prngetcount:
	mov	wait_count[bx],cx	; place "new" retry count
	mov	es:[di].rc_count,cx	; return current retry count
	clc
	ret
prn_genioctl endp

;************************************************************************
;*									*
;*  prn_ioctl_query							*
;*									*
;*  Added for 5.00							*
;************************************************************************

prn_ioctl_query PROC NEAR
	assume	ds:Bios_Data,es:nothing

	les	di,[ptrsav]
	cmp	es:[di].majorfunction,ioc_pc
	jne	prn_query_err

	mov	al,es:[di].minorfunction
	cmp	al,get_retry_count
	je	IOCtlSupported
	cmp	al,set_retry_count
	jne	prn_query_err

IOCtlSupported:
	clc
	ret

prn_query_err:
	stc
	jmp	BC_CmdErr

prn_ioctl_query ENDP

;************************************************************************
;*									*
;*	aux port driver code -- "aux" == "com1"				*
;*									*
;*	the device driver entry/dispatch code sets up auxnum to		*
;*	give the com port number to use (0=com1, 1=com2, 2=com3...)	*
;*									*
;************************************************************************

;	values in ah, requesting function of int 14h in rom bios

auxfunc_send	 equ	1	;transmit
auxfunc_receive  equ	2	;read
auxfunc_status	 equ	3	;request status

;	error flags, reported by int 14h, reported in ah:

flag_data_ready  equ	01h	;data ready
flag_overrun	 equ	02h	;overrun error
flag_parity	 equ	04h	;parity error
flag_frame	 equ	08h	;framing error
flag_break	 equ	10h	;break detect
flag_tranhol_emp equ	20h	;transmit holding register empty
flag_timeout	 equ	80h	;timeout

;	these flags reported in al:

flag_cts	 equ	10h	;clear to send
flag_dsr	 equ	20h	;data set ready
flag_rec_sig	 equ	80h	;receive line signal detect

;************************************************************************
;*									*
;*	aux_read - read cx bytes from [auxnum] aux port to buffer	*
;*		   at es:di						*
;*									*
;************************************************************************

aux_read proc near
	assume	ds:Bios_Data,es:nothing

	jcxz	exvec2		; if no characters, get out

	call	getbx		; put address of auxbuf in bx
	xor	al,al		; clear al register
	xchg	al,[bx] 	; get character , if any, from
				;   buffer and clear buffer
	or	al,al		; if al is nonzero there was a
				;   character in the buffer
	jnz	aux2		; if so skip first auxin call

aux1:
	call	auxin		; get character from port
;		^^^^^ 		  won't return if error
aux2:
	stosb			; store character
	loop	aux1		; if more characters, go around again

exvec2:
	clc			; all done, successful exit
	ret

aux_read endp

;************************************************************************
;*									*
;*	auxin - call rom bios to read character from aux port		*
;*		if error occurs, map the error and return one		*
;*		level up to device driver exit code, setting		*
;*		the number of bytes transferred appropriately		*
;*									*
;************************************************************************

;
; M026 - BEGIN
;
auxin	proc	near
	mov	ah,auxfunc_receive
	call	auxop		;check for frame, parity, or overrun errors
	 			;warning: these error bits are unpredictable
				; if timeout (bit 7) is set
	test	ah, flag_frame or flag_parity or flag_overrun
	jnz	arbad		; skip if any error bits set
	ret			; normal completion, ah=stat, al=char

;	error getting character

arbad:
	pop	ax		; remove return address (near call)
	xor	al,al
	or	al,flag_rec_sig or flag_dsr or flag_cts
	jmp	bc_err_cnt

auxin	endp

IFDEF	COMMENTEDOUT
auxin	proc	near
	push	cx
	mov	cx, 20		; number of retries on time out errors
@@:
	mov	ah,auxfunc_receive
	call	auxop		;check for frame, parity, or overrun errors
	 			;warning: these error bits are unpredictable
				; if timeout (bit 7) is set
	test	ah, flag_timeout
	jz	no_timeout
	loop	@b
no_timeout:
	pop	cx
	test	ah, flag_timeout or flag_frame or flag_parity or flag_overrun
	jnz	arbad		; skip if any error bits set
	ret			; normal completion, ah=stat, al=char

;	error getting character

arbad:
	pop	ax		; remove return address (near call)
	xor	al,al
	or	al,flag_rec_sig or flag_dsr or flag_cts
	jmp	bc_err_cnt

auxin	endp
ENDIF

;
; M026 - END
;
;************************************************************************
;*									*
;*	aux_rdnd - non-destructive aux port read			*
;*									*
;************************************************************************

aux_rdnd proc	near
	assume	ds:Bios_Data,es:nothing

	call	getbx		; have bx point to auxbuf
	mov	al,[bx] 	; copy contents of buffer to al
	or	al,al		; if al is non-zero (char in buffer)
	jnz	auxrdx		;   then return character

	call	auxstat 	;   if not, get status of aux device
	test	ah,flag_data_ready ; test data ready
	jz	auxbus		;   then device is busy (not ready)

	test	al,flag_dsr	;test data set ready
	jz	auxbus		;   then device is busy (not ready)

	call	auxin		;   else aux is ready, get character
	mov	[bx],al 	; save character in buffer

auxrdx:
	jmp	rdexit		; return al in [packet.media]

auxbus:
	jmp	z_bus_exit	; return busy status
aux_rdnd endp

;************************************************************************
;*									*
;*	aux_wrst - return aux port write status				*
;*									*
;************************************************************************

aux_wrst proc	near
	assume	ds:Bios_Data,es:nothing

	call	auxstat 	; get status of aux in ax
	test	al,flag_dsr	; test data set ready
	jz	auxbus		;   then device is busy (not ready)
	test	ah,flag_tranhol_emp ;test transmit hold reg empty
	jz	auxbus		;   then device is busy (not ready)
	clc
	ret
aux_wrst endp

;************************************************************************
;*									*
;*	auxstat - call rom bios to determine aux port status		*
;*									*
;*	exit:	ax = status						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxstat	proc near
	mov	ah,auxfunc_status
auxstat endp			; fall into auxop

;************************************************************************
;*									*
;*	auxop - perform rom-biox aux port interrupt			*
;*									*
;*	entry:	ah = int 14h function number				*
;*	exit:	ax = results						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxop	proc	near
				;ah=function code
				;0=init, 1=send, 2=receive, 3=status
	mov	dx,[auxnum]	; get port number
	int	14h		; call rom-bios for status
	ret
auxop	endp

;************************************************************************
;*									*
;*	aux_flsh - flush aux input buffer - set contents of		*
;*		   auxbuf [auxnum] to zero				*
;*									*
;*	cas - shouldn't this code call the rom bios input function	*
;*	      repeatedly until it isn't ready?  to flush out any	*
;*	      pending serial input queue if there's a tsr like MODE	*
;*	      which is providing interrupt-buffering of aux port?	*
;*									*
;************************************************************************

aux_flsh proc	near
	call	getbx		; get bx to point to auxbuf
	mov	byte ptr [bx],0 ; zero out buffer
	clc			; all done, successful return
	ret
aux_flsh endp

;************************************************************************
;*									*
;*	aux_writ - write to aux device					*
;*									*
;************************************************************************

aux_writ proc	near
	assume	ds:Bios_Data 	; set by aux device driver entry routine
	jcxz	exvec2		; if cx is zero, no characters
				;   to be written, jump to exit
aux_loop:
	mov	al,es:[di]	; get character to be written
	inc	di		; move di pointer to next character
	mov	ah,auxfunc_send ;value=1, indicates a write
	call	auxop		;send character over aux port

	test	ah,flag_timeout ;check for error
	jz	awok		;   then no error
	mov	al,10		;   else indicate write fault
	jmp	bc_err_cnt 	; call error routines

				; if cx is non-zero, still more
awok:
	loop	aux_loop	; more characrter to print
	clc			; all done, successful return
	ret
aux_writ endp

;************************************************************************
;*									*
;*	getbx - return bx -> single byte input buffer for		*
;*		selected aux port ([auxnum])				*
;*									*
;************************************************************************

getbx	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	bx,[auxnum]
	add	bx,offset auxbuf
	ret
getbx	endp

Bios_Code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\spckbd.asm ===
;******************************************************************************
;
;       Copyright (c) 1992 Insignia Solutions Ltd.
;
;       Program:
;
;       Purpose:
;
;       Version:
;
;       Author:         Dave Bartlett
;	Modifications:
;		1) Tim June 92. Changes to get DEC PC working. Take over
;		   IVT entries 6h (illegal instruction), 11h (equipment
;		   check), 16h (keyboard BIOS), 17h (printer),
;		   42h (default video).
;		2) Tim June 92. Changed version to 1.11
;		3) Tim June 92. Avoid accesses to host ROM as far as
;		   possible. Take over lots of IVT entries and continue to
;		   point them at this driver.
;		4) Tim July 92. Version num 1.12, put pseudo ROM stuff back in.
;               5) Tim July 92. v 1.13, use SoftPC video BIOS when windowed.
;
;      6) 12-Sep-1992 Jonle, Merged with ntio.sys
;                            cleanup usage of assumes espcially with ES
;                            optimized loading of IVT
;                            other general cleanup
;
;      This obj module is intially loaded in a temporary memory location
;      along with ntio.sys. Ntio.sys will copy the resident code (marked by
;      SpcKbdBeg, SpcKbdEnd) into the permanent memory location which resides
;      just below the normal device drivers loaded by config.sys.
;
;      The nonresident intialization code is run with CS= temp seg
;      and DS= final seg.
;
;******************************************************************************


.286

include vint.inc

;================================================================
; Macros and includes
;================================================================

bop MACRO callid
    db 0c4h,0c4h,callid
endm


BIOS_CPU_QUIT   equ     0FEh
BIOS_KB_INT     equ     9
BIOS_INT15      equ     15h
BIOS_PRINTER_IO	equ	17h
UNEXP_BOP       equ     2
RTC_WAIT_FLAG   equ     0a0h     ; offset of rtc_wait_flag in bios data seg
VERSIONID       equ     0BEEFh

FULLSCREEN	equ	1
MAX_VIDEO_FUNC	equ	1Ch
GET_FONT_FUNC	equ	11h

VID_MODECHANGE	equ	0
MOUSE_LIGHT_PEN	equ	4
MIN_MOUSE_FUNC	equ	0F0H
MAX_MOUSE_FUNC	equ	0F7H
XTRA_MOUSE_FUNC	equ	0FAH
MS_VIDEO_STRING	equ	13FFH

MOUSE_VID_BOP	equ	0BEh
EGA_VIDEO_BOP	equ	42h

PRT_NOTBUSY	equ	80h
PRT_NUM_PORTS	equ	3
PRT_STATE_READY	equ	0
PRT_IRQ		equ	10h
PRT_LPT_BUSY    equ     1

TIMER_LOW       equ 6ch
TIMER_HIGH      equ 6eh
TIMER_OVFL      equ 70h
MOTOR_STATUS    equ 3fh
MOTOR_COUNT     equ 40h

; Keyboard buf ptrs
BUFFER_HEAD     equ 1ah
BUFFER_TAIL     equ 1ch
BUFFER_START    equ 80h
BUFFER_END      equ 82h

; kb_flag and LED bits
KB_FLAG         equ  17h
CAPS_STATE      equ  40h
NUM_STATE       equ  20h
SCROLL_STATE    equ  10h

KB_FLAG_1       equ  18h

KB_FLAG_2       equ  97h
KB_LEDS         equ  07h   ; Keyboard LED state bits
KB_PR_LED       equ  40h   ; Mode indicator update


KB_FLAG_3       equ  96h
LC_E1           equ  01h
LC_E0           equ  02h




;..............................................keyboard constants

; bits in kb_flag
	RIGHT_SHIFT = 1
	LEFT_SHIFT = 2
	CTL_SHIFT = 4
	ALT_SHIFT = 8


; bit in kb_flag_1
	HOLD_STATE = 8
	SCROLL_SHIFT = 10h
	NUM_SHIFT = 20h
	CAPS_SHIFT = 40h
        INS_SHIFT = 80h
        SYS_SHIFT = 04h


; IBM scan codes
	CTL_KEY = 29
	LEFT_SHIFTKEY = 42
	RIGHT_SHIFTKEY = 54
	ALT_KEY = 56
	CAPS_KEY = 58
	NUM_KEY = 69
	SCROLL_KEY = 70
	INS_KEY = 82    



;
; Segment definitions for ntio.sys,
;
include biosseg.inc


SpcKbdSeg    segment

        assume  cs:SpcKbdSeg,ds:nothing,es:nothing

;
; SpcKbdBeg - SpcKbdEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 13-Sep-1992 Jonle
;
        public SpcKbdBeg

SpcKbdBeg    label  byte

;
; Reduced data table for Video 7 modes 0 and 2.
; This table is extracted from our video7 ROM. Only text modes are
; required, mode 0 and 1 are identical as are modes 2 and 3.
;
ega_parm_setup:

;--40x25--
	DB 40,24,16	; width,height,character height
	DW 00800H	; Page size in bytes

	DB 008H, 003H, 000H, 002H	; Sequencer Parameters

	DB 067H	;Misc Reg

; CRTC Parameters
	DB 02dH, 027H, 028H, 090H, 02bH
	DB 0a0H, 0bfH, 01fH, 000H, 04fH
	DB 00dH, 00eH, 000H, 000H, 000H
	DB 000H, 09cH, 0aeH, 08fH, 014H
	DB 01fH, 096H, 0b9H, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 00cH, 000H, 00fH, 008H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00eH, 000H, 0ffH

;--80x25--
	DB 80,24,16	; width,height,character height
	DW 01000H	; Page size in bytes

	DB 000H, 003H, 000H, 002H	; Sequencer Parameters

	DB 067H	;Misc Reg

; CRTC Parameters
	DB 05fH, 04fH, 050H, 082H, 055H
	DB 081H, 0bfH, 01fH, 000H, 04fH
	DB 00dH, 00eH, 000H, 000H, 000H
	DB 000H, 09cH, 08eH, 08fH, 028H
	DB 01fH, 096H, 0b9H, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 00cH, 000H, 00fH, 008H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00eH, 000H, 0ffH

;--80x25 mono--
	DB 80,24,16	; width,height,character height
	DW 01000H	; Page size in bytes

	DB 000H, 003H, 000H, 003H	; Sequencer Parameters

	DB 0a6H	;Misc Reg

; CRTC Parameters
	DB 05fH, 04fH, 050H, 082H, 055H
	DB 081H, 0bfH, 01fH, 000H, 04dH
	DB 00bH, 00cH, 000H, 000H, 000H
	DB 000H, 083H, 0a5H, 05dH, 028H
	DB 00dH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 008H, 008H, 008H, 008H
	DB 008H, 008H, 008H, 010H, 018H
	DB 018H, 018H, 018H, 018H, 018H
	DB 018H, 00eH, 000H, 00fH, 008H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00aH, 000H, 0ffH

; Mode b (font load)

	DB 5eh,32H,8	; width,height,character height
	DW 09700H	; Page size in bytes

	DB 001H, 00fH, 000H, 006H	; Sequencer Parameters

	DB 0e7H	;Misc Reg

; CRTC Parameters
	DB 06dH, 05dH, 05eH, 090H, 061H
	DB 08fH, 0bfH, 01fH, 000H, 040H
	DB 000H, 000H, 000H, 000H, 000H
	DB 000H, 0a2H, 08eH, 099H, 02fH
	DB 000H, 0a1H, 0b9H, 0e3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 001H, 000H, 00fH, 000H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 000H, 005H, 00fH, 0ffH


;--350 scanline 40x25
	DB 40,24,14	; width,height,character height
	DW 00800H	; Page size in bytes

	DB 009H, 003H, 000H, 002H	; Sequencer Parameters

	DB 0a3H	;Misc Reg

; CRTC Parameters
	DB 02dH, 027H, 028H, 090H, 02bH
	DB 0a0H, 0bfH, 01fH, 000H, 04dH
	DB 00bH, 00cH, 000H, 000H, 000H
	DB 000H, 083H, 0a5H, 05dH, 014H
	DB 01fH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 008H, 000H, 00fH, 000H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00eH, 000H, 0ffH

;--350 scanline 80x25
	DB 80,24,14	; width,height,character height
	DW 01000H	; Page size in bytes

	DB 001H, 003H, 000H, 002H	; Sequencer Parameters

	DB 0a3H	;Misc Reg

; CRTC Parameters
	DB 05fH, 04fH, 050H, 082H, 055H
	DB 081H, 0bfH, 01fH, 000H, 04dH
	DB 00bH, 00cH, 000H, 000H, 000H
	DB 000H, 083H, 0a5H, 05dH, 028H
	DB 01fH, 063H, 0baH, 0a3H, 0ffH

; Attribute parameters
	DB 000H, 001H, 002H, 003H, 004H
	DB 005H, 014H, 007H, 038H, 039H
	DB 03aH, 03bH, 03cH, 03dH, 03eH
	DB 03fH, 008H, 000H, 00fH, 000H

; Graph parameters
	DB 000H, 000H, 000H, 000H, 000H
	DB 010H, 00eH, 000H, 0ffH

;
; End of baby mode table.
;
; Table of VGA bios 'capability' info for func 1b to point at.
vga_1b_table    db 07fh, 060h, 00fh, 000h, 000h, 000h, 000h, 007h
                db 002h, 008h, 0ffh, 00eh, 000h, 000h, 03fh, 000h

; Configuration table for INT 15 Func C0 to point at.
conf_table      dw 008h
;;		db 000h, 0fch, 002h, 000h, 070h, 000h, 000h, 000h, 000h
		db 000h, 0fch, 002h, 074h, 070h, 000h, 000h, 000h, 000h


PRT_BUF_SIZE     equ     255

;================================================================
; Printer status table
;================================================================
prt_status	db PRT_NUM_PORTS dup (?)
prt_state	db PRT_NUM_PORTS dup (?)
prt_control	db PRT_NUM_PORTS dup (?)
prt_lpt_stat    db PRT_NUM_PORTS dup (?)
cur_buf_size    dw PRT_BUF_SIZE
prt_data_buf    db PRT_BUF_SIZE dup (?) ; buffer in the 16bit side for perf.
cur_lpt         db 0ffh                 ; buffer is not being used
cur_count       dw ?
cur_busy        db 0                    ; initially not busy

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; Keyboard tables
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


shift_keys:                                                     ;K6
	DB INS_KEY,CAPS_KEY,NUM_KEY,SCROLL_KEY
	DB ALT_KEY,CTL_KEY,LEFT_SHIFTKEY,RIGHT_SHIFTKEY

shift_masks:                                                    ;K7
	DB INS_SHIFT,CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT
	DB ALT_SHIFT,CTL_SHIFT,LEFT_SHIFT,RIGHT_SHIFT

ctl_n_table:                                                    ;K8
	DB  27,  -1,   0,  -1,  -1,  -1,  30,  -1
	DB  -1,  -1,  -1,  31,  -1, 127, 148,  17
	DB  23,   5,  18,  20,  25,  21,   9,  15
	DB  16,  27,  29,  10,  -1,   1,  19,   4
	DB   6,   7,   8,  10,  11,  12,  -1,  -1
	DB  -1,  -1,  28,  26,  24,   3,  22,   2
	DB  14,  13,  -1,  -1,  -1,  -1, 150,  -1
	DB ' ',  -1

ctl_f_table:                                                    ;K9
	DB  94,  95,  96,  97,  98,  99, 100, 101
	DB 102, 103,  -1,  -1, 119, 141, 132, 142
	DB 115, 143, 116, 144, 117, 145, 118, 146
	DB 147,  -1,  -1,  -1, 137, 138

lowercase:
	DB  27, '1', '2', '3', '4', '5', '6', '7', '8', '9'     ;K10
	DB '0', '-', '=',   8,   9, 'q', 'w', 'e', 'r', 't'
	DB 'y', 'u', 'i', 'o', 'p', '[', ']',  13, -1,  'a'
	DB 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',  39
	DB  96,  -1,  92, 'z', 'x', 'c', 'v', 'b', 'n', 'm'
	DB ',', '.', '/',  -1, '*',  -1, ' ',  -1

lc_tbl_scan:
	DB  59,  60,  61,  62,  63,  64,  65,  66,  67,  68
	DB  -1,  -1

base_case:
	DB  71,  72,  73,  -1,  75,  -1,  77,  -1,  79,  80
	DB  81,  82,  83,  -1,  -1,  92, 133, 134               ;K15

uppercase:							;K11
	DB  27, '!', '@', '#', '$', '%', '^', '&', '*', '('
	DB ')', '_', '+',   8,   0, 'Q', 'W', 'E', 'R', 'T'
	DB 'Y', 'U', 'I', 'O', 'P', '{', '}',  13,  -1, 'A'
	DB 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"'
	DB 126,  -1, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M'
	DB '<', '>', '?',  -1,	 0,  -1, ' ',  -1;

ucase_scan:
	DB  84,  85,  86,  87,  88,  89,  90,  91,  92,  93
	DB  -1,  -1

numb_state:
	DB '7', '8', '9', '-', '4', '5', '6', '+', '1', '2'	;K14
	DB '3', '0', '.' , -1,	-1, 124, 135, 136

alt_table:
	DB 82,	79,  80,  81,  75,  76,  77,  71,  72,	73	;K30
	DB 16,  17,  18,  19,  20,  21,  22,  23,  24,  25
	DB 30,  31,  32,  33,  34,  35,  36,  37,  38,  44
	DB 45,	46,  47,  48,  49,  50

;================================================================
; Keyboard break caller
;================================================================

keyboard_break_caller:
	int 1bh	    ;keyboard break
	bop %BIOS_CPU_QUIT

;================================================================
; Print screen caller
;================================================================

print_screen_caller:
	int 5h		    ;print screen
	bop %BIOS_CPU_QUIT

;================================================================
; Int 15 caller
;================================================================
; Tim modified int 15 caller. Copied from BIOS2. It gives CPU
; a chance to take other interrupts. Suspect the extra jumps are
; now harmless with IRET hooking.
;int15h_caller:
	;int	15h
	;bop	%BIOS_CPU_QUIT
int15h_caller:
	int	15h	; Cassette I/O.
	jmp	k1
k1:	jmp	k2
k2:	jmp	k3
k3:	BOP	%BIOS_CPU_QUIT

;================================================================
; Unexpected interrupt handler
;================================================================

unexp_int:
	bop %UNEXP_BOP
        jmp     iret_com

;================================================================
;Int 13 caller
;================================================================
int13h_caller:
	int	13h
	bop %BIOS_CPU_QUIT


;================================================================
; New interrupt 9h handler
;================================================================

int09h_vector:
        push    ax
        xor     ax, ax
        bop     %BIOS_KB_INT
        pop     ax
        jmp     iret_com

        ; CarbonCopy traces int 9 in order to gain control
        ; over where the kbd data is coming from (the physical kbd
        ; or the serial link) The kbd_inb instruction must be visible
        ; in the 16 bit code via int 1 tracing, for CarbonCopy to work.
        ; Softpc assumes the exact location of the first nop
        ; relative to the bop just above.
        nop
        nop
        in      al, 60h      ; keyba_io_buffers
        nop
        nop
        BOP     %BIOS_CPU_QUIT





;=================================================================
; IRET hooks bop table
;=================================================================


IRET_HOOK = 5dh 		;IRET hook BOP

iret_bop_table:
	bop %IRET_HOOK
	db 0
iret_end_first_entry:
	bop %IRET_HOOK
	db 1
	bop %IRET_HOOK
	db 2
	bop %IRET_HOOK
	db 3
	bop %IRET_HOOK
	db 4
	bop %IRET_HOOK
	db 5
	bop %IRET_HOOK
	db 6
	bop %IRET_HOOK
	db 7
	bop %IRET_HOOK
	db 8
	bop %IRET_HOOK
	db 9
	bop %IRET_HOOK
	db 10
	bop %IRET_HOOK
	db 11
	bop %IRET_HOOK
	db 12
	bop %IRET_HOOK
	db 13
	bop %IRET_HOOK
	db 14
	bop %IRET_HOOK
	db 15

;================================================================
; New interrupt 13h handler
;================================================================

int13h_vector:
	cmp	dl,80h		; 0 - 7f are floppy commands
	jb	int40h_vector

	cmp     ah,2		; we fail the direct access commands
	jb	diskcmd		; read/write/seek/verify/format
	cmp	ah,5		; but let others go through (disk tables etc)
	jbe	faildisk
	cmp	ah,0ah
	jb	diskcmd
	cmp	ah,0ch
	ja	diskcmd
faildisk:
	push	ax
	mov	ax,1		; direct access error panel
	bop	59h
	pop	ax		; preserve AL for safety sake
	mov	ah, 80h		; error - timeout
	stc
	retf	2

diskcmd:
	bop	13h
	retf	2

;================================================================
; New interrupt 40h handler
;================================================================

int40h_vector:
;	cmp	ah,2		; we fail the direct access commands
;	jb	flopcmd		; read/write/seek/verify/format
;	cmp	ah,5		; but let others go through (disk tables etc)
;	jbe	failflop
;	cmp	ah,0ah
;	jb	flopcmd
;	cmp	ah,0ch
;	ja	flopcmd
failflop:
;	push	ax
;	mov	ax,0		; direct access error panel
;	bop	59h
;	pop	ax
;	mov	ah, 80h		; error - timeout
;	stc
;	retf	2

flopcmd:
	bop	40h
	retf	2

;; waiting for diskette interrupt
wait_int:
	push	ds
	push	ax
	push	cx
	mov	ax, 40h
	mov	ds, ax
	mov	cx, 10h
wait_int_loop:
	mov	al, [3Eh]
	test	al, 80h
	loopz	wait_int_loop
	pop	cx
	pop	ax
	pop	ds
	bop	%BIOS_CPU_QUIT

;; floppy parameters table
floppy_table	label	byte

	DB	01				;; 360KB in 360KB
	DW	OFFSET md_tbl1
	DB	82H				;; 360KB in 1,2MB
	DW	OFFSET md_tbl2
	DB	02				;; 1.2MB in 1.2MB
	DW	OFFSET md_tbl3
	DB	03				;; 720KB in 720KB
	DW	OFFSET md_tbl4
	DB	84H				;; 720KB in 1.44MB
	DW	OFFSET md_tbl5
	DB	04				;; 1.44MB in 1.44MB
	DW	OFFSET md_tbl6
	DB	85h				;; 720KB in 2.88MB
	DW	OFFSET md_tbl7
	DB	85h				;; 1.44MB in 2.88MB
	DW	OFFSET md_tbl8
	DB	5				;; 2.88MB in 2.88MB
	DW	OFFSET md_tbl9


md_tbl1:
	; MEDIA = 40 track low data rate; DRIVE = 40 track low data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 39		; maximum track number
	DB 80H		; transfer rate

md_tbl2:
	; MEDIA = 40 track low data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 39		; maximum track number
	DB 40H		; transfer rate

md_tbl3:
	; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 15		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 054h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 0		; transfer rate

md_tbl4:
	; MEDIA = 80 track low data rate; DRIVE = 80 track low data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start ime
	DB 79		; maximum track number
	DB 80H		; transfer rate

md_tbl5:
	; MEDIA = 80 track low data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 80H		; transfer rate

md_tbl6:
	; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
	DB 0AFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 06Ch		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 0		; transfer rate

md_tbl7:
	;MEDIA = 80 tracks, 9 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

	DB 0E1h		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start ime
	DB 79		; maximum track number
	DB 80H		; transfer rate
md_tbl8:
	;MEDIA = 80 tracks, 18 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

	DB 0D1h		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 065h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 0		; transfer rate

md_tbl9:
	;MEDIA = 80 tracks, 36 sectors/track; DRIVE = 80 tracks, 36 sectotrs per track

	DB 0A1h		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 36		; sectors/track
	DB 038h		; gap length
	DB 0FFh		; data length
	DB 053h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB 0C0h 	; transfer rate



floppy_table_len    equ $ - floppy_table

bios_floppy_table   label   byte
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB 25H		; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 054h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
bios_floppy_table_len	equ $ - bios_floppy_table

;===============================================================
; New interrupt 15h handler
;================================================================
; Tim, modified this to be like a "normal" SoftPC ROM.
; Copied from BIOS2, but rtc_wait_flag is now referenced via ES not
; DS.
;
;  17-Sep-1992 Jonle , ES ref to rtc_wait was change from assume ES
;  to seg overides to prevent accidents in assuming.
;

;int15h_vector:
	;bop	  %BIOS_INT15
	;iret
;;;;;;;;;STF hide this int15h_vector:
int15h_vector:
        call    DOSTI
	cmp ah, 88h
	je lbl1
	cmp ah, 91h
	je lbl1
	cmp ah, 86h
	je lbl2
	BOP 15h
	RETF 2
lbl1:	BOP 15h
        jmp iret_com
lbl2:	BOP 15h
	jc lbl5
	push cx
	push dx
	push es				; Tim, save ES not DS.
        mov ax, 40                      ; point es to biosdata
        mov es, ax
	xchg dx, cx
lbl3:
        test byte ptr es:[RTC_WAIT_FLAG], 080h ; check for end of wait
        loopz lbl3                             ; dec timeout delay
        jnz lbl4                               ; exit if wait ended
        sub dx, 1                              ; dec error timeout counter
        jnc lbl3                               ; loop till counters timeout
lbl4:
        mov byte ptr es:[RTC_WAIT_FLAG], 0   ; set function inactive
        pop es                               ; Kipper, restore ES not DS.
	pop dx
	pop cx
	clc
lbl5:	
	RETF 2

;=================================================================
; Regular SoftPC int 17 handler	(especially important for DEC PCs)
;=================================================================

int17h_vector:
;
;    Do a get status purely in 16-bit code but only if the printer is ready and
;we don't have interrupts turned on. Otherwise we must do a BOP and let 32-bit
;code handle it.
;
	push	si
	push	dx
	push	ax
	mov	ax, dx			; dx = adapter no., ensure it is no
	xor	dx, dx			; greater than PRT_NUM_PORTS.
	mov	si, PRT_NUM_PORTS
	div	si
	mov	si, dx
	pop	ax
        cmp     ah, 2
        je      do_prt_status
        or      ah,ah
        je      do_write
        jmp     do_print_bop

do_prt_status:
	cmp	byte ptr cs:[si + prt_state], PRT_STATE_READY
	jne	do_print_bop
	test	byte ptr cs:[si + prt_control], PRT_IRQ
        je      get_status
        jmp     short do_print_bop

do_write:
        cmp     byte ptr cs:[cur_lpt],0ffh
        jne     check_lpti
        mov     byte ptr cs:[cur_lpt],dl
        mov     word ptr cs:[cur_count],0
        mov     byte ptr cs:[cur_busy],0ffh
        jmp     short do_print_bop
check_lpti:
        cmp     byte ptr cs:[cur_lpt],dl
        je      buf_ok
        push    si
        xor     si,si
        bop     %BIOS_PRINTER_IO
        pop     si
        mov     word ptr cs:[cur_count],0
        mov     byte ptr cs:[cur_lpt],dl
        jmp     short do_print_bop
buf_ok:
        mov     dx,word ptr cs:[cur_count]
        mov     si,dx
        mov     byte ptr cs:[si + prt_data_buf],al
        inc     word ptr cs:[cur_count]
        cmp     word ptr cs:[cur_count],PRT_BUF_SIZE
        jne     no_flushing
        xor     si,si                       ; sub-function 0 for this bop
        bop     %BIOS_PRINTER_IO
        test    ah,08h
        jz      flush_ok
        dec     word ptr cs:[cur_count]
        jmp     short int17h_end
flush_ok:
        mov     word ptr cs:[cur_count],0
no_flushing:
        mov     ah,90h
        jmp     short int17h_end

do_print_bop:
        mov     si,0ffffh                     ; sub-function 1
	bop     %BIOS_PRINTER_IO
        jmp     int17h_end

get_status:
	test	byte ptr cs:[si + prt_lpt_stat], PRT_LPT_BUSY
	jne	noset
	or	byte ptr cs:[si + prt_status], PRT_NOTBUSY
noset:
	mov	ah, cs:[si + prt_status]
	and	ah, 0f8h
	xor	ah, 48h
int17h_end:
	pop	dx
        pop     si
iret_com:
        FIRET


;=================================================================
; Pseudo-ROM vectuz, copied from BIOS2.ASM
;=================================================================

dummy_vector:           ; Copied from BIOS2.ASM
        jmp iret_com
illegal_bop_vector:
	bop     72h
        jmp     iret_com
intD11_vector:
	bop     72h
        jmp     iret_com

int05h_vector:		; Print Screen func. copied from BIOS2.ASM
        call DOSTI
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH DS
	;::::::::::::::::::::::::::::::::: Setup DS to point to BIOS data area
	MOV AX,40H
	MOV DS,AX
	;::::::::::::::::::::::::::::::: Print screen already in progress ????
	CMP BYTE PTR DS:[100H],1
	JE end_print
	;::::::::::::::::::::::::::::::::::::::::::::::: Set print screen busy
	MOV BYTE PTR DS:[100h],1
	;:::::::::::::::::::::::::::::::::::::::::::::::::::: Get video status
	MOV AH,15
	INT 10H
	MOV CH,AH	    ;No of columns
	;:::::::::::::::::::::::::::::::::: Setup no. of columns/rows to print
	BOP 80H		;(BIOS_PS_PRIVATE_1)
	MOV CL,AL	    ;No of rows
	;::::::::::::::::::::::::::::::::::: Print line feed / carriage return
	CALL print_crlf
	;:::::::::::::::::::::::::::::::::::::::::: Get current cursor postion
	PUSH CX
	MOV AH,3
	INT 10H
	POP CX
	;::::::::::::::::::::::::::::::::::::::::::::::::: Save cursor postion
	PUSH DX 		    ;save current cursor postion
	XOR DH,DH		    ;current row being processed
start_print_col:
	XOR DL,DL		    ;current column being processed
	;::::::::::::::::::::::::::::::::::::::::::::::: Start printing screen
start_print_row:
	;:::::::::::::::::::::::::::::::::::::::::::::::::: Set cursor postion
	PUSH DX 		    ;save current row,column
	MOV AH,2
	INT 10H
	;::::::::::::::::::::::::::::::::::: Read character at current postion
	MOV AH,8
	INT 10H
	;::::::::::::::::::::::::::::::::::::::::::::::::::::: Print character
	OR al,al
	JNZ print_char
	MOV AL,20H
print_char:
	XOR DX,DX
	XOR AH,AH
	INT 17H
	;:::::::::::::::::::::::::::::::::::::::::::: Check for printer errors
	POP DX			;Restore current row,column
	AND AH,25H
	JZ  cont2
	MOV BYTE PTR DS:[100H],0FFH
	JMP short exit_print
	;::::::::::::::::::::::::::::::::::::::::::: Move to mext print column
cont2:
	INC DL			;Inc current column
	CMP DL,CH		;Current col compared to no. of cols
	JB start_print_row
	;:::::::::::::::::::::::::::::::::::::::::: End of column, print CR/LF
	CALL print_crlf
	;:::::::::::::::::::::::::::::::::::::::::::::::::: More rows to print
	INC DH			;Inc current row
	CMP DH,CL		;Current row compared to no. of rows
	JBE start_print_col
	MOV BYTE PTR DS:[0100H],0
	;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Exit print
exit_print:
	;:::::::::::::::::::::::::::::::::::::; Restore orginal cursor postion
	POP DX
	MOV AH,2
	INT 10H
	;:::::::::::::::::::::::::::::::::::::::::::::::::::: Tidy up and exit
end_print:
	POP DS
	POP DX
	POP CX
	POP BX
	POP AX
        jmp iret_com

	;::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Print CR/LF
print_crlf:
	PUSH DX
	XOR DX,DX
	MOV AX,0DH
	INT 17H
	XOR DX,DX
	MOV AX,0AH
	INT 17H
	POP DX
	RET
;	End of int05_vector (print screen).

int06h_vector:
	bop     06h
        jmp     iret_com

; IVT 7 is set to unexpected interrupt.


int08h_vector:
; The usual int8 handler modified for optimum performance.
; - stays in 16 bit code (no BOP)
; - keeps interrupts off when not needed
; - calls int 1c directly
;
        call  DOCLI                ; make sure interrupts stay off until iret

        push  es
        push  ds                  ; save some registers
        push  ax
        push  dx

        mov   ax, 40h             ; set ds to bios data area
        mov   ds, ax
        xor   ax, ax
        mov   es, ax              ; set es to IVT seg for i1c callout

        inc   word ptr ds:[TIMER_LOW]        ; inc time counters
        jnz   i8v1
        inc   word ptr ds:[TIMER_HIGH]
i8v1:
        cmp   word ptr ds:[TIMER_HIGH], 018h  ; check for 24 hours, wrap point
        jnz   i8v2
        cmp   word ptr ds:[TIMER_LOW], 0b0h
        jnz   i8v2


        mov   word ptr ds:[TIMER_HIGH], ax    ; 24 hour wrap, set OVFL bit
        mov   word ptr ds:[TIMER_LOW], ax
        mov   byte ptr ds:[TIMER_OVFL], 1
        or    al, 8                ; set Overflow bit for fake flags

        ;---                       ; skip floppy motor stuff


i8v2:                              ; handle the floppy motor stuff
        push  ax
        dec   byte ptr ds:[MOTOR_COUNT]
        jnz   i8v3
        and   byte ptr ds:[MOTOR_STATUS], 0f0h
        mov   al, 0ch
        mov   dx, 03f2h            ; costly outb happens 1/256 timer tics...
        out   dx, al

i8v3:
        pop   ax
                                   ; call int1c user routine directly
        lahf                       ; get lobyte of flags for fake flags
        xchg  ah,al
        push  ax                   ; put fake flags on the stack
        call  dword ptr es:[1ch*4] ; do it!
        call  DOCLI                ; make sure interrupts stay off until iret

        mov   al, 20h              ; send eoi
        out   20h, al

        pop   dx                   ;restore the stack
        pop   ax
        pop   ds
        pop   es

        jmp     iret_com



int0e_vector:
	bop	0eh
        jmp     iret_com

DOCLI:
        FCLI
        ret

DOSTI:
        FSTI
        ret

;
; Tim August 92. Video BIOS grabber.
; Call SPC BIOS when in windowed mode and the host BIOS when in full-screen.
; Controled by value of 'use_host_int10'. 
; Try to limit bops by validating calling values. Mouse has to get first shot
; and then video bios.
;

use_host_int10     db 01h	; native/softpc bios flag
changing_mode	   db 01h	; delay handshake if in bios mode change

PUBLIC int10h_vector

int10h_vector:
        cmp     use_host_int10, FULLSCREEN
        je      nativebios

	cmp	ah,VID_MODECHANGE	; mode change??
	je	modechange
	cmp	ah,MAX_VIDEO_FUNC	; range check
	ja	mousecheck		; not a vid func but mouse has higher
	cmp	ah,MOUSE_LIGHT_PEN	; light pen special case
	je	mousebios
spcbios:
	bop	EGA_VIDEO_BOP		; regular windowed Int 10
	jmp	viddone

mousecheck:
	cmp	ah,MIN_MOUSE_FUNC	; range check mouse fn f0-f7 + fa.
	jb	badvid
	cmp	ah,MAX_MOUSE_FUNC
	jbe	mousebios
	cmp	ah,XTRA_MOUSE_FUNC
	jne	badvid

mousebios:				; call softpc mouse video entrypoint
	bop	MOUSE_VID_BOP
	jmp	viddone

modechange:			; windowed modechange. Mouse gets a look
	mov	changing_mode,1	; then softpc video bios. If gfx mode then
	bop	MOUSE_VID_BOP	; will go fullscreen
	;;;nop
	;;;nop			; nops aid debugging
	;;;bop	EGA_VIDEO_BOP	; will go fullscreen here
	nop
	nop
	push	ax		; save video mode which may have top bit set
	and	ax,7fh
	cmp	al,3
	jbe	endmode		; if graphics mode, repeat modechange to setup
	cmp	al,7		; video card, else fall through
	je	endmode
	pop	ax
	jmp	nativebios
endmode:
	pop	ax
	mov	changing_mode,0	; Clear 'mode changing' flag.

viddone:
        jmp     iret_com

badvid:				; unrecognised video func
	stc
	jmp viddone
	
nativebios:
	mov	changing_mode,0		; Clear 'mode changing' flag.
	cmp	ax,MS_VIDEO_STRING	; ensure not MS special video string fn
	je	ms_wrt_string

	cmp	ah,MIN_MOUSE_FUNC	; could be a mouse call
	jb	chk_mse_vid
	cmp	ah,MAX_MOUSE_FUNC	; range check mouse fn f0-f7 + fa.
	jbe	mousebios
	cmp	ah,XTRA_MOUSE_FUNC
	je	mousebios
	jmp	jmp_native		; probably bad func but...

chk_mse_vid:
        cmp     ah,MOUSE_LIGHT_PEN      ; mouse handles light pen
        je      mousebios
        cmp     ah,VID_MODECHANGE
        jne     chk_font_change
        bop     MOUSE_VID_BOP   ; mouse wants first sniff at mode changes
        jmp     jmp_native      ; then fall through
chk_font_change:
        cmp     ah,GET_FONT_FUNC
        jne     jmp_native
        bop     MOUSE_VID_BOP   ; select mouse buffer for new no. of lines
                                ; then fall through

jmp_native:
                   db      0EAh     ; far jump
host_int10	   dd	   ?	    ; to native int 10 vector

ms_wrt_string:
	push	si
	push	di
	push	bp
go_loop1:
	mov	dx,46h		; looks a good value for flags
	push	dx		; make an iret frame
	push	cs
	mov	bx, offset go_cont
	push	bx
	mov	bx,7		; set foreground color
	mov	ah,0eh		; set command to write a character
	mov	al,es:[di]	; get char
	inc	di
	jmp	jmp_native	; make far jmp to int 10 vector

go_cont:
	loop	go_loop1	;repeat until all through
	pop	bp
	pop	di
	pop	si
	mov	ax,1		; return success
	jmp	viddone
;
; int 42 - 'old' video bios entry point. Use same windowed/fullscreen
; redirection as Int 10 above.
;
int42h_vector:
        cmp     use_host_int10, FULLSCREEN
        jz      maybe_host_42_bios

	bop	10h	; old video bop
        jmp     iret_com

	; If it's the special BIOS print string function, don't call the
	; host video BIOS cos it won't know what we are talking about.
	; It's only in our video BIOS.
maybe_host_42_bios:
	cmp	AH, 013h
	jnz	gogo_host_42_bios
	cmp	AL, 0ffh
	jz	ms_wrt_string		; reuse path from Int 10

gogo_host_42_bios:
                   db      0EAh     ; far jump
host_int42         dd      ?        ; to native int 42 vector

int10h_caller:
	int	10h	; Re-entrant video entry point.
	bop	0feh

int11h_vector:		; Equipment check.
	bop     11h
        jmp     iret_com
int12h_vector:		; Get memory size, copied from BIOS2.ASM
	bop     12h
        jmp     iret_com

; IVT 13 is floppy io, grabbed above to fake error status.

int14h_vector:		; RS-232 serial comms, copied from BIOS2
	bop     14h
        jmp     iret_com

; Int 15 cassette io, is done above.



; Idle indicators- All word sized, and dword aligned
; Int 16 keyboard vector

        align   4
        public Icounter,CharsPerTick,MinTicks

Icounter        dw  0
                dw  0
CharsPerTick    dw  0
                dw  0
MinTicks        dw  50
                dw  0

int16h_vector:
        push    ds
        push    bx
        mov     bx, 40h           ; bios data adressable
        mov     ds, bx
        cmp     ah, 10h
        call    DOCLI             ; make sure interrupts are off
        jb      i16vStdFns
        jmp     i16vExtFns


        ; The dispatch code must preserve the jz,dec,dec pattern
        ; to return the same ah value as is returned by the
        ; standard bios (0 for supported unless otherwise documented
        ; and nonzero for unsupported). This is because some apps look
        ; at the ret value of ah even tho it is a side effect of the
        ; original dispatch code in the rom bios.

i16vStdFns:
        or      ah, ah
        jz      i16v00h           ; read key, wait
        dec     ah
        jz      i16v01h           ; read key no wait
        dec     ah
        jz      i16v02h           ; get shift state
        dec     ah
        jz      i16viret          ; we don't support ah=3, set kbd rate
        dec     ah
        jz      i16viret          ; undefined function
        dec     ah
        jz      i16v05h           ; push char into kbd buffer
                                  ; the rest are undefined\unsupported

        ; normal iret exit
i16viret:
        pop     bx
        pop     ds
        jmp     iret_com


        ; return shift state in al
i16v02h:
        mov     al, ds:[KB_FLAG]
        jmp     i16viret


i16v05h:
        push    si
        mov     bx, word ptr ds:[BUFFER_TAIL]
        mov     si, bx
        call    IncrBuffPtr
        cmp     bx, word ptr ds:[BUFFER_HEAD]
        je      i16v05h1
        mov     word ptr ds:[si], cx
        mov     word ptr ds:[BUFFER_TAIL], bx
        mov     al, 0
        pop     si
        jmp     i16viret

i16v05h1:
        mov     al, 1
        pop     si
        jmp     i16viret


        ; read a character, wait if none available
i16v00h:
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        jne     i16v00h1
        call    DOSTI
        mov     ax, 09002h
        int     15h              ; wait device

i16v00h0:
        call    DOCLI
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]

i16v00h1:
        call    UpdateLed
        jne     i16v00h2
        call    IdlePoll
        jmp     i16v00h0

i16v00h2:        ; translate.....
        mov     ax, [bx]
        call    IncrBuffPtr
        mov     word ptr ds:[BUFFER_HEAD], bx
        call    TranslateStd
        jc      i16v00h0
        call    IdleInit
        jmp     i16viret


        ; read a character, nowait if none available
i16v01h:
        mov     bx, word ptr ds:[BUFFER_HEAD]  ;;maybe should turn IF on ??
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        mov     ax, [bx]
        call    UpdateLed
        je      i16vretf1

        call    IdleInit
        call    TranslateStd
        call    DOSTI
        jnc     i16vretf5             ; got a key, all done!
        call    IncrBuffPtr           ; throw away key
        mov     word ptr ds:[BUFFER_HEAD], bx
        jmp     i16v01h               ; go for the next one


        ; ExtKbd read a character, nowait if none available
i16v11h:
        mov     bx, word ptr ds:[BUFFER_HEAD]  ;;maybe should turn IF on ??
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        mov     ax, [bx]
        call    UpdateLed
        je      i16vretf1          ; common retf stuff for nowait

        call    IdleInit
        call    TranslateExt
        call    DOSTI
        jmp     i16vretf5


         ; retf2 exit preserving flags
i16vretf1:
        call  DOSTI
        push  ax
        lahf
        push  ax

        mov   ax, cs:Icounter
        cmp   ax, cs:MinTicks
        jb    i16vretf2

        mov   ah, 1               ; polling kbd, idle now
        BOP   16h
        jmp   i16vretf4

i16vretf2:
        inc   cs:CharsPerTick


i16vretf4:
        pop  ax
        sahf
        pop  ax

i16vretf5:
        pop     bx
        pop     ds
        retf    2



i16vExtFns:
        sub     ah, 10h
        jz      i16v10h           ; extended read key, wait
        dec     ah
        jz      i16v11h           ; extended read key, nowait
        dec     ah
        jz      i16v12h           ; extended shift status
        jmp     i16viret          ; undefined


        ; return extended shift state
i16v12h:
        mov     al, ds:[KB_FLAG_1]
        mov     ah, al
        and     al, SYS_SHIFT
        push    cx
        mov     cl, 5
        shl     al, cl
        pop     cx
        and     ah, NOT (SYS_SHIFT+HOLD_STATE+INS_SHIFT)
        or      al, ah
        mov     ah, ds:[KB_FLAG_3]
        and     ah, NOT (LC_E1+LC_E0)
        or      ah, al
        mov     al, ds:[KB_FLAG]
        jmp     i16viret


        ; ExtKbd read a character, wait if none available
i16v10h:
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]
        jne     i16v10h1
        call    DOSTI
        mov     ax, 09002h
        int     15h              ; wait device

i16v10h0:
        call    DOCLI
        mov     bx, word ptr ds:[BUFFER_HEAD]
        cmp     bx, word ptr ds:[BUFFER_TAIL]

i16v10h1:
        call    UpdateLed
        jne     i16v10h2
        call    IdlePoll
        jmp     i16v10h0

i16v10h2:        ; translate.....
        mov     ax, [bx]
        call    IncrBuffPtr
        mov     word ptr ds:[BUFFER_HEAD], bx
        call    TranslateExt
        call    IdleInit
        jmp     i16viret



; IdlePoll  - Spins waiting for a key, doing idle callouts as needed
;             flags trashed, all registers preserved
;             interrupts are left on upon exit
;
IdlePoll  proc near
          push  ax

          call  DOSTI
          mov   ah, 2                          ; Idle_waitio
          BOP   16h
IPoll1:
          mov   bx, word ptr ds:[BUFFER_HEAD]
          cmp   bx, word ptr ds:[BUFFER_TAIL]  ; interrupts are off only
          jne   IPoll3                         ; safe to peek for change

          mov   ax, cs:Icounter
          cmp   ax, cs:MinTicks
          jae   IPoll2
          inc   cs:CharsPerTick
          jmp   IPoll1
IPoll2:
          mov   ah, 1                          ; idle now
          BOP   16h
IPoll3:
          pop   ax
          ret
IdlePoll  endp




; IdleInit - reinits the idle indicators, dups functionality
;            of IDLE_init()
;
IdleInit  proc near

          mov cs:Icounter, 0
          mov cs:CharsPerTick, 0

          ret
IdleInit  endp


;  TranslateExt - Retrieves and translates next scan code
;  pair for extended kbd
;
;  input:   ax - raw scan code pair
;  output:  ax - translated scan code pair
;
;  all other flags,registers preserved

TranslateExt proc near

             push    bx
             push    ax
             lahf
             mov     bx, ax
             pop     ax
             push    bx

             cmp     al, 0f0h
             jne     TExt1
             or      ah, ah
             jz      TExt1
             xor     al, al
TExt1:
             mov     bx, ax
             pop     ax
             sahf
             mov     ax, bx
             pop     bx
             ret

TranslateExt endp


;  TranslateStd - Retrieves and translates next scan code
;  pair for standard kbd
;
;  input:   ax - raw scan code pair
;  output:  ax - translated scan code pair
;  returns carry for throw away
;  all other flags,registers preserved

TranslateStd proc near

            push    bx
            push    ax
            lahf
            mov     bx, ax
            pop     ax
            push    bx

            cmp     ah, 0e0h
            jne     TStd1

            ; keypad enter or '/'
            mov     ah, 1ch        ; assume enter key
            cmp     al, 0dh
            je      TStdNoCarry
            cmp     al, 0ah
            je      TStdNoCarry
            mov     ah, 35h        ; oops it was key pad!
            jmp     TStdNoCarry

TStd1:
            cmp     ah, 84h
            ja      TStdCarry      ; extended key ?

            cmp     al, 0f0h       ; fill in key ?
            jne     TStd2
            or      ah, ah         ; ah = 0 is special
            jz      TStdNoCarry
            jmp     TStdCarry

TStd2:
            cmp     al, 0e0h       ; convert to compatible output
            jne     TStdNoCarry
            or      ah, ah
            jz      TStdNoCarry
            xor     al, al

TStdNoCarry:
            mov     bx, ax
            pop     ax
            sahf
            mov     ax, bx
            pop     bx
            clc
            ret

TStdCarry:
            mov     bx, ax
            pop     ax
            sahf
            mov     ax, bx
            pop     bx
            stc
            ret
TranslateStd endp



; IncrBuffPtr - increments the buffer pointer
;
; input:  ds:bx - curr buf ptr
; output: ds:bx - new buf ptr
; does not update the bios buf ptr

IncrBuffPtr  proc near
             inc bx
             inc bx
             cmp bx, word ptr ds:[BUFFER_END]
             jne ibpExit
             mov bx, word ptr ds:[BUFFER_START]
ibpExit:
             ret
IncrBuffPtr  endp



; UpdateLed - forms the data byte for the mode indicators
;             updates the led bits (MAKE_LED,SEND_LED)
;
; input:  none
; output: led bits updated
;
; Caveats: all low flags,registers preserved
;          MUST be called with interrupts off
;          does not update the kbd hardware (send_led)
;
UpdateLed  proc near

           push bx
           push cx
           push ax
           lahf
           push ax

           ; make_led
           mov  al, byte ptr ds:[KB_FLAG]            ; get led bits
           and  al, CAPS_STATE+NUM_STATE+SCROLL_STATE
           mov  cl, 4
           rol  al, cl                               ; shift for kb_flag_2
           and  al, KB_LEDS                          ; only led mode bits

           mov  bl, byte ptr ds:[KB_FLAG_2]
           xor  bl, al                               ; see of different
           and  bl, KB_LEDS                          ; only led mode bits
           jz   UledExit


           test byte ptr ds:[KB_FLAG_2], KB_PR_LED   ;if update under way
           jnz  ULedExit                             ;    skip update
           or   byte ptr ds:[KB_FLAG_2], KB_PR_LED   ;else upd in progress

           mov   ah, 3                               ; inform softpc to set lights
           BOP   16h

           and  byte ptr ds:[KB_FLAG_2], NOT KB_LEDS   ;clear led bits
           or   byte ptr ds:[KB_FLAG_2], al            ;stick in new led bits
           and  byte ptr ds:[KB_FLAG_2], NOT KB_PR_LED ;clear upd bit

ULedExit:
           pop  ax
           sahf
           pop  ax
           pop  cx
           pop  bx

           ret
UpdateLed  endp




; IVT 17 is printer IO, done above.

int18h_vector:		; ROM BASIC, copied from BIOS2.ASM
	bop     18h
        jmp     iret_com
int19h_vector:		; reboot vector, we terminate vdm!
	bop	19h
        jmp     iret_com


IdleTicLo   dw  0
IdleTicHi   dw  0
IdleTicNum  db  0

int1Ah_vector:          ; Time of day.
        call    DOSTI
        cmp     ah, 2
        jl      i1aTic1

        bop     1ah
        jmp     iret_com

i1aTic1:
        push    ds                                  ; bios data adressable
        push    bx
        push    ax
        mov     ax, 40h
        mov     ds, ax
        pop     ax
        call    DOCLI

        or      ah, ah                              ; fn 0 or fn 1 ?
        jnz     i1aTic5

i1aTic2:
        mov     al, byte ptr ds:[TIMER_OVFL]        ; GetTickCount
        mov     cx, word ptr ds:[TIMER_HIGH]
        mov     dx, word ptr ds:[TIMER_LOW]


        ; If time stamp is within 1 tic of curr tic count
        ; do idle polling managment

        cmp     cs:IdleTicHi, cx                    ; check TIMER_HIGH
        jnz     i1aTic8

        mov     bx, cs:IdleTicLo                    ; check TIMER_LOW
        cmp     bx, dx
        jz      i1aTic3
        inc     bx
        cmp     bx, dx
        jnz     i1aTic8


i1aTic3:
        inc     cs:IdleTicNum                       ; Yes, inc poll count
        cmp     cs:IdleTicNum, 16                   ; Is poll count too hi ?
        jb      i1aTic9

        call    DOSTI
        xor     ax,ax                               ; Yes, do idle BOP
        dec     cs:IdleTicLo                        ; make sure only bop once
        BOP     5ah
        call    DOCLI
        jmp     short i1aTic2

i1aTic5:
        mov     word ptr ds:[TIMER_LOW], dx         ; SetTickCount
        mov     word ptr ds:[TIMER_HIGH], cx

i1aTic8:
        mov     cs:IdleTicNum, 0                    ; reset idle indicators

i1aTic9:
        mov     cs:IdleTicLo, dx                    ; store time stamp
        mov     cs:IdleTicHi, cx
        mov     byte ptr ds:[TIMER_OVFL], 0         ; common TicCount exit
        pop     bx
        pop     ds
        jmp     iret_com


; IVT 1B is keyboard break, set to dummy.


int1Eh_vector:
	bop     1eh
        jmp     iret_com

int70h_vector:		; Real time clock, copied from BIOS1.ASM
	bop     70h	; rtc_bios.c:rtc_int()
        jmp     iret_com

int4Ah_caller:
        call    DOSTI   ; Called from base\bios\rtc_bios.c:rtc_int()
	int	4ah	; User installed alarm.
	jmp	r1
r1:	jmp	r2
r2:	jmp	r3
r3:
        call    DOCLI
	bop	0feh

int71h_vector:		; redirect, copied from BIOS1.ASM
	bop     71h
	int	0Ah
        jmp     iret_com
int75h_vector:		; NPX 287.
	bop     75h
	int	02h
        jmp     iret_com
;=================================================================
; End of pseudo-ROM vectuz.
;=================================================================


;================================================================
; Wait for interrupts
;================================================================

cpu_nop_code:
        call    DOSTI
	jmp	short nxt1
nxt1:	jmp	short nxt2
nxt2:	jmp	short nxt3
nxt3:   bop     %BIOS_CPU_QUIT

           public SpcKbdEnd
SpcKbdEnd  label byte

	align	4			;; makes MIPS happy

; offset table for redirected functions
kio_table dw  29 dup(?)

        public InstSpcKbd

;
; InstSpcKbd - Installs the softpc custom interrupt hooks
;
; Inputs:  ds == Resident location of SysInitSeg
; Outputs: None
;
InstSpcKbd   proc near

        pusha
        call    DOCLI

        ; The following vectors are used for both x86\mips
        ; The dos interrupts Int 25\Int26 are handled by the dos kerenl
        xor     ax, ax
        mov     es, ax
        mov     word ptr es:[08h*4], offset int08h_vector
        mov     word ptr es:[(08h*4)+2], ds
        mov     word ptr es:[09h*4], offset int09h_vector
        mov     word ptr es:[(09h*4)+2], ds
        mov     word ptr es:[13h*4], offset int13h_vector
        mov     word ptr es:[(13h*4)+2], ds
        mov     word ptr es:[16h*4], offset int16h_vector
        mov     word ptr es:[(16h*4)+2], ds
        mov     word ptr es:[40h*4], offset int40h_vector
	mov	word ptr es:[(40h*4)+2], ds
	mov	word ptr es:[19h*4], offset int19h_vector
        mov     word ptr es:[(19h*4)+2], ds
        mov     word ptr es:[1ah*4], offset int1Ah_vector
        mov     word ptr es:[(1ah*4)+2], ds



        ; BOP 5F - send interesting addresses to softpc C BIOS
        ;  CS seg of kio_table
        ;  DS seg of resident keyboard code
        ;  DI offset of bop table
        ;  CX size of bop table entry
        ;  SI offset of kio_table
	mov	si,offset sysinitgrp:kio_table
	push	ds
	push	cs
	pop	ds
	mov	word ptr [si],	  offset shift_keys	;K6
	mov	word ptr [si+2],  offset shift_masks   ;K7
	mov	word ptr [si+4],  offset ctl_n_table   ;K8
	mov	word ptr [si+6],  offset ctl_f_table   ;K9
	mov	word ptr [si+8],  offset lowercase     ;K10
	mov	word ptr [si+10], offset uppercase     ;K11
	mov	word ptr [si+12], offset alt_table     ;K30
	mov	word ptr [si+14], offset dummy_vector
	mov	word ptr [si+16], offset print_screen_caller
	mov	word ptr [si+18], offset int15h_caller
	mov	word ptr [si+20], offset cpu_nop_code
        mov     word ptr [si+22], offset int15h_vector
        mov     word ptr [si+24], offset Icounter
        mov     word ptr [si+26], offset int4Ah_caller
	mov	word ptr [si+28], offset keyboard_break_caller
	mov	word ptr [si+30], offset int10h_caller
	mov	word ptr [si+32], offset int10h_vector
	mov	word ptr [si+34], offset use_host_int10
	mov	word ptr [si+36], offset ega_parm_setup
	mov	word ptr [si+38], offset changing_mode
	mov	word ptr [si+40], offset prt_status
	mov	word ptr [si+42], offset wait_int
        mov     word ptr [si+44], offset floppy_table
	mov	word ptr [si+46], offset vga_1b_table
        mov     word ptr [si+48], offset conf_table
        mov     word ptr [si+50], offset int08h_vector
	mov	word ptr [si+52], offset int13h_vector
	mov	word ptr [si+54], offset int13h_caller
; The last entry is reserved for assertion checking
	mov	word ptr [si+56], VERSIONID
	pop	ds

	; mov	 si, offset kio_table
        mov     di, offset iret_bop_table
        mov     cx, offset iret_end_first_entry  - offset iret_bop_table
        mov     ax, VERSIONID
        bop     5fh
        jc      isk_int9
        jmp     isk_Exit
isk_int9:

        ; save old video int
        xor     ax, ax
        mov     es, ax
        mov     bx, es:[40h]
        mov     si, offset host_int10
        mov     word ptr ds:[si], bx
        mov     bx, es:[42h]
        mov     word ptr ds:[si+2], bx

	; save old secondary video int (42h)
        mov     bx, es:[108h]
        mov     si, offset host_int42
        mov     word ptr ds:[si], bx
        mov     bx, es:[10ah]
        mov     word ptr ds:[si+2], bx


;-----------------------------------------------------------
;
; Crazy vector grabber
;
; Works OK on DEC PC when grab INT's 6, 11, 16, 17, 42.
; Now try and avoid all accesses to host ROM.
;
; At this point we assume ES=0
;-----------------------------------------------------------

     ; Grab some prominent vectors for pseudo-ROM routines.
     ; start at Int 0h and work our way up as needed
     cld

     mov   di, 20
     mov   ax, offset int05h_vector  ; INT 05h
     stosw                                             ; Print screen
     mov   ax, ds
     stosw
     mov   ax, offset int06h_vector  ; INT 06h
     stosw                                             ; Illegal instruction.
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 07h
     stosw
     mov   ax, ds
     stosw

     ; int 8h Timer hardware vector already done for both x86\mips
     ; int 9h kbd hardware vector already done for both x86\mips
     add   di, 8

     mov   ax, offset unexp_int      ; INT 0ah
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0bh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0ch
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0dh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int0e_vector   ; INT 0eh
     stosw                                             ; Floppy hardware int.
     mov   ax, ds
     stosw
     mov   ax, offset unexp_int      ; INT 0fh
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int10h_vector  ; INT 10h
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int11h_vector  ; INT 11h
     stosw                                             ; Equipment check.
     mov   ax, ds
     stosw
     mov   ax, offset int12h_vector  ; INT 12h
     stosw                                             ; Get memory size.
     mov   ax, ds
     stosw

     ; int 13h already done (see above) for both mips\x86

     mov   di, 14h*4                                   ; Communications.
     mov   ax, offset int14h_vector
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int15h_vector  ; INT 15h
     stosw
     mov   ax, ds
     stosw

     ; int 16h kbd hardware vector already done for both x86\mips
     add   di, 4

     mov   ax, offset int17h_vector  ; INT 17h
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int18h_vector  ; INT 18h
     stosw                                             ; ROM BASIC.
     mov   ax, ds
     stosw

     ; int 19h (reboot vector) already done for both x86\mips

     ; int 1ah, time of day, already done for both x86\mips

     mov   di, 1Bh*4
     mov   ax, offset dummy_vector   ; INT 1Bh
     stosw                                             ; Keyboard break.
     mov   ax, ds
     stosw
     mov   ax, offset dummy_vector  ; INT 1Ch
     stosw                                             ; Timer tick.
     mov   ax, ds
     stosw

     mov   di, 1Eh*4                                   ; Floppy parameters.
     mov   ax, offset bios_floppy_table
     stosw
     mov   ax, ds
     stosw

     ; int 40h already done (see above) for both mips\x86

     mov   di, 41h*4
     mov   ax, offset unexp_int      ; INT 41h
     stosw                                             ; Hard disk parameters.
     mov   ax, ds
     stosw
     mov   ax, offset int42h_vector  ; INT 42h
     stosw                                             ; Default video.
     mov   ax, ds
     stosw

     mov   di, 70h*4                                    ; Real time clock init.
     mov   ax, offset int70h_vector
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int71h_vector  ; INT 71h Redirect.
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 72h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 73h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 74h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset int75h_vector  ; INT 75h 287 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 76h D11 int
     stosw
     mov   ax, ds
     stosw
     mov   ax, offset intD11_vector  ; INT 77h D11 int
     stosw
     mov   ax, ds
     stosw


isk_Exit:
     call  DOSTI
     popa
     ret

InstSpcKbd  endp

SpcKbdSeg    ends
             end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\spcmse.asm ===
;       Program:        Installable Device Driver for Mouse.
;
;       Purpose:        to provide compatability with the
;                       Microsoft MOUSE.SYS device driver.
;                       the code here installs the driver and
;                       hooks the IVT in exactly the same
;                       way as the current Insignia MOUSE.COM.
;
;       Version:        1.00    Date: 28th October 1992.
;
;       Author:         Andrew Watson
;
;       Revisions:
;
;	23-June-1994 Williamh, made mode 4/5 and 12 work.
;
;       12-Sep-1992 Jonle, Merged with ntio.sys
;                          optimized loading of IVT
;
;       5-March-1993 Andyw, Moved fullscreen text pointer code
;                           from 32bit land to 16bit driver for
;                           for speed purposes.
;
;      This obj module is intially loaded in a temporary memory location
;      along with ntio.sys. Ntio.sys will copy the resident code (marked by
;      SpcMseBeg, SpcMseEnd) into the permanent memory location which resides
;      just below the normal device drivers loaded by config.sys.
;
;      The nonresident intialization code is run with CS= temp seg
;      and DS= final seg.
;
;
;****************************************************************

.286
        include vint.inc

;================================================================
; Defined constants used in the driver.
;================================================================


        VERSIONID       equ     0BEEFh
        MAXCMD          equ     16
        UNKNOWN         equ     8003h
        DONE            equ     0100h
        MOUSEVER        equ     0003h
        INT1_BOP        equ     0BAh
        INT2_BOP        equ     0BBh
        IO_LANG_BOP     equ     0BCh
        IO_INTR_BOP     equ     0BDh
        VIDEO_IO_BOP    equ     0BEh
        UNSIMULATE_BOP  equ     0FEh
        VIDEO           equ     010h
        UNEXP_BOP       equ     2
        FORCE_YODA      equ     05bh
        ANDYS_BOP       equ     060h
        STACKSIZE       equ     200h-1

        TRUE            equ     0
        FALSE           equ     1
        STORED          equ     0
        NOTSTORED       equ     1
        ON              equ     0
        OFF             equ     1

        MAJOR_RELEASE_NUMBER    equ     6
        MINOR_RELEASE_NUMBER    equ     26



;MACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROS

bop MACRO callid
    db 0c4h,0c4h,callid
endm



;=============================================================================
; Macro to reassign the stack segment register to point at the driver code
; segment and the stack pointer to point to the most significant word in an
; array reserved as the driver stack.
;=============================================================================


;; !!!! interrupt must be disabled before calling this function !!!!!!

make_stack      MACRO
        LOCAL   reent                   ;; a local symbol to this macro
;;	 call	 DOCLI			 ;; turn off interrupts during this
                                        ;; macro's execution even if the CPU
                                        ;; does this for you when modifying SS
        inc     cs:reentrant            ;; has the interrupt been nested?
        jnz     reent                   ;; not reentrant if == zero

        ;; The driver code is not reentrant, so start the stack at the beginning

        mov     cs:top_of_stack,ss      ;; save the entry SS
        mov     cs:top_of_stack-2,sp    ;; save SP on the stack
        push    cs                      ;; the current code/data segment
        pop     ss                      ;; point SS at CS

        ;; point SP at the next free stack location.

        mov     sp,offset top_of_stack-2 ;; The current stack pointer position

reent:  ;; REENTRANT > 0 therefore reentrancy exists
        ;; The driver has gone reentrant due to a nested interrupt, so just
        ;; leave the stack alone because it is the same under reentrancy.

;;	 call  DOSTI				 ;; reenable interrupts

        ENDM

;=============================================================================
; Macro to return the stack pointer and segment back to what it was when
; the driver was called.
;=============================================================================

kill_stack      MACRO
        LOCAL   reent1
;;	 cli
        cmp     cs:reentrant,0          ;; is the code currently reentrant?
        jg      reent1                  ;; yes it is
        mov     sp,cs:top_of_stack-2    ;; pop SP
        mov     ss,cs:top_of_stack      ;; pop SS
reent1:
        dec     cs:reentrant            ;; reduce the level of reentrancy
;;	 call	 DOSTI
        ENDM

;MACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROSMACROS

;
; Segment definitions for ntio.sys,
;
include biosseg.inc




SpcMseSeg    segment
             assume  cs:SpcMseSeg, ds:nothing, es:nothing

;
; SpcMseBeg - SpcMseEnd
;
; Marks the resident code, anything outside of these markers
; is discarded after intialization
; 15-Sep-1992 Jonle
;

        public SpcMseBeg

SpcMseBeg    label  byte

  ; CAUTION: for crazy apps mouse recognition
  ;
  ; The offset for int33h_vector must not be Zero for Borlands QuattroPro
  ; The segment must not be in ROM area for pctools
  ; to keep the int33h_vector from having an offset of ZERO
  ; I have moved the data above it
  ; 25-Sep-1992 Jonle


; describe the default screen and cursor masks
; remember that x86 machines are little-endian

        ;;; include     pointer.inc
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;;; We'll Get this back to an include file soon but I'm including it like
 ;;;; this for 'diplomatic' reasons. (ie I want to check this in without
 ;;;; also doing an 'addfile' at this stage)!!! - Simon.
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; This data will be accessed, on occasion, word by word, so
; be tidy and align to a word boundary

align   2

; Describe the default mouse pointer image. This is used if the
; user decides to switch on the pointer without specifying an image.

default_cursor		dw	0011111111111111b
			dw	0001111111111111b
			dw	0000111111111111b
			dw	0000011111111111b
			dw	0000001111111111b
			dw	0000000111111111b
			dw	0000000011111111b
			dw	0000000001111111b
			dw	0000000000111111b
			dw	0000000000011111b
			dw	0000000111111111b
			dw	0001000011111111b
			dw	0011000011111111b
			dw	1111100001111111b
			dw	1111100001111111b
			dw	1111110001111111b
			dw	0000000000000000b
			dw	0100000000000000b
			dw	0110000000000000b
			dw	0111000000000000b
			dw	0111100000000000b
			dw	0111110000000000b
			dw	0111111000000000b
			dw	0111111100000000b
			dw	0111111110000000b
			dw	0111110000000000b
			dw	0110110000000000b
			dw	0100011000000000b
			dw	0000011000000000b
			dw	0000001100000000b
			dw	0000001100000000b
			dw	0000000000000000b

        ; Set up the memory where the working cursor is situated. It is
        ; initialised to the default cursor image

;****************** ALIGNED FOR PIXEL ZERO *******************************

                ; screen mask

even
current_cursor          db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,01111111b,11111111b
                        db      00000000b,00111111b,11111111b
                        db      00000000b,00011111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,10000000b,00000000b
                        db      01111111b,11000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignData1:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,01111111b,11111111b
                        db      10000000b,00111111b,11111111b
                        db      10000000b,00011111b,11111111b
                        db      10000000b,00001111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,01111111b,11111111b
                        db      10011000b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111110b,00111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,10000000b,00000000b
                        db      00111111b,11000000b,00000000b
                        db      00111111b,11100000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignData2:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000000b,00111111b,11111111b
                        db      11000000b,00011111b,11111111b
                        db      11000000b,00001111b,11111111b
                        db      11000000b,00000111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000100b,00111111b,11111111b
                        db      11001100b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111111b,00011111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,10000000b,00000000b
                        db      00011111b,11000000b,00000000b
                        db      00011111b,11100000b,00000000b
                        db      00011111b,11110000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignData3:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,01111111b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100000b,00011111b,11111111b
                        db      11100000b,00001111b,11111111b
                        db      11100000b,00000111b,11111111b
                        db      11100000b,00000011b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100010b,00011111b,11111111b
                        db      11100110b,00011111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,10001111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,10000000b,00000000b
                        db      00001111b,11000000b,00000000b
                        db      00001111b,11100000b,00000000b
                        db      00001111b,11110000b,00000000b
                        db      00001111b,11111000b,00000000b
                        db      00001101b,10000000b,00000000b
                        db      00001000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignData4:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,01111111b,11111111b
                        db      11110000b,00111111b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110000b,00001111b,11111111b
                        db      11110000b,00000111b,11111111b
                        db      11110000b,00000011b,11111111b
                        db      11110000b,00000001b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110001b,00001111b,11111111b
                        db      11110011b,00001111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,11000111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,10000000b,00000000b
                        db      00000111b,11000000b,00000000b
                        db      00000111b,11100000b,00000000b
                        db      00000111b,11110000b,00000000b
                        db      00000111b,11111000b,00000000b
                        db      00000111b,11111100b,00000000b
                        db      00000110b,11000000b,00000000b
                        db      00000100b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignData5:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,00111111b,11111111b
                        db      11111000b,00011111b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,00000111b,11111111b
                        db      11111000b,00000011b,11111111b
                        db      11111000b,00000001b,11111111b
                        db      11111000b,00000000b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,10000111b,11111111b
                        db      11111001b,10000111b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11100011b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,10000000b,00000000b
                        db      00000011b,11000000b,00000000b
                        db      00000011b,11100000b,00000000b
                        db      00000011b,11110000b,00000000b
                        db      00000011b,11111000b,00000000b
                        db      00000011b,11111100b,00000000b
                        db      00000011b,11111110b,00000000b
                        db      00000011b,01100000b,00000000b
                        db      00000010b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignData6:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00011111b,11111111b
                        db      11111100b,00001111b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,00000011b,11111111b
                        db      11111100b,00000001b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000000b,01111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,01000011b,11111111b
                        db      11111100b,11000011b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11110001b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,11000000b,00000000b
                        db      00000001b,11100000b,00000000b
                        db      00000001b,11110000b,00000000b
                        db      00000001b,11111000b,00000000b
                        db      00000001b,11111100b,00000000b
                        db      00000001b,11111110b,00000000b
                        db      00000001b,11111111b,00000000b
                        db      00000001b,10110000b,00000000b
                        db      00000001b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignData7:

                        db      11111110b,01111111b,11111111b
                        db      11111110b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00001111b,11111111b
                        db      11111110b,00000111b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00000001b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,01111111b
                        db      11111110b,00000000b,00111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00100001b,11111111b
                        db      11111110b,01100001b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11111000b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11100000b,00000000b
                        db      00000000b,11110000b,00000000b
                        db      00000000b,11111000b,00000000b
                        db      00000000b,11111100b,00000000b
                        db      00000000b,11111110b,00000000b
                        db      00000000b,11111111b,00000000b
                        db      00000000b,11111111b,10000000b
                        db      00000000b,11011000b,00000000b
                        db      00000000b,10001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000000b,00000000b


; Data area reserved for the clipped cursor images. When the pointer
; reaches byte 78 in the current raster, the image needs to be clipped
; to prevent it from being wrapped to the left hand edge of the screen.
; The image below stops that from happening by loading the image with
; a 1's partial AND mask and a 0's partial XOR mask.
; Note that byte 79 also needs a clipped image set.

even
clip_cursor78           db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,01111111b,11111111b
                        db      00000000b,00111111b,11111111b
                        db      00000000b,00011111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,10000000b,00000000b
                        db      01111111b,11000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignClip178:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,01111111b,11111111b
                        db      10000000b,00111111b,11111111b
                        db      10000000b,00011111b,11111111b
                        db      10000000b,00001111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,01111111b,11111111b
                        db      10011000b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111110b,00111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,10000000b,00000000b
                        db      00111111b,11000000b,00000000b
                        db      00111111b,11100000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignClip278:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000000b,00111111b,11111111b
                        db      11000000b,00011111b,11111111b
                        db      11000000b,00001111b,11111111b
                        db      11000000b,00000111b,11111111b
                        db      11000000b,01111111b,11111111b
                        db      11000100b,00111111b,11111111b
                        db      11001100b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111111b,00011111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,10000000b,00000000b
                        db      00011111b,11000000b,00000000b
                        db      00011111b,11100000b,00000000b
                        db      00011111b,11110000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,10000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignClip378:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,01111111b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100000b,00011111b,11111111b
                        db      11100000b,00001111b,11111111b
                        db      11100000b,00000111b,11111111b
                        db      11100000b,00000011b,11111111b
                        db      11100000b,00111111b,11111111b
                        db      11100010b,00011111b,11111111b
                        db      11100110b,00011111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,00001111b,11111111b
                        db      11111111b,10001111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,10000000b,00000000b
                        db      00001111b,11000000b,00000000b
                        db      00001111b,11100000b,00000000b
                        db      00001111b,11110000b,00000000b
                        db      00001111b,11111000b,00000000b
                        db      00001101b,10000000b,00000000b
                        db      00001000b,11000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignClip478:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,01111111b,11111111b
                        db      11110000b,00111111b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110000b,00001111b,11111111b
                        db      11110000b,00000111b,11111111b
                        db      11110000b,00000011b,11111111b
                        db      11110000b,00000001b,11111111b
                        db      11110000b,00011111b,11111111b
                        db      11110001b,00001111b,11111111b
                        db      11110011b,00001111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,10000111b,11111111b
                        db      11111111b,11000111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,10000000b,00000000b
                        db      00000111b,11000000b,00000000b
                        db      00000111b,11100000b,00000000b
                        db      00000111b,11110000b,00000000b
                        db      00000111b,11111000b,00000000b
                        db      00000111b,11111100b,00000000b
                        db      00000110b,11000000b,00000000b
                        db      00000100b,01100000b,00000000b
                        db      00000000b,01100000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignClip578:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,00111111b,11111111b
                        db      11111000b,00011111b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,00000111b,11111111b
                        db      11111000b,00000011b,11111111b
                        db      11111000b,00000001b,11111111b
                        db      11111000b,00000000b,11111111b
                        db      11111000b,00001111b,11111111b
                        db      11111000b,10000111b,11111111b
                        db      11111001b,10000111b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11000011b,11111111b
                        db      11111111b,11100011b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,10000000b,00000000b
                        db      00000011b,11000000b,00000000b
                        db      00000011b,11100000b,00000000b
                        db      00000011b,11110000b,00000000b
                        db      00000011b,11111000b,00000000b
                        db      00000011b,11111100b,00000000b
                        db      00000011b,11111110b,00000000b
                        db      00000011b,01100000b,00000000b
                        db      00000010b,00110000b,00000000b
                        db      00000000b,00110000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignClip678:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,01111111b,11111111b
                        db      11111100b,00111111b,11111111b
                        db      11111100b,00011111b,11111111b
                        db      11111100b,00001111b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,00000011b,11111111b
                        db      11111100b,00000001b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000000b,11111111b
                        db      11111100b,00000111b,11111111b
                        db      11111100b,01000011b,11111111b
                        db      11111100b,11000011b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11100001b,11111111b
                        db      11111111b,11110001b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,10000000b,00000000b
                        db      00000001b,11000000b,00000000b
                        db      00000001b,11100000b,00000000b
                        db      00000001b,11110000b,00000000b
                        db      00000001b,11111000b,00000000b
                        db      00000001b,11111100b,00000000b
                        db      00000001b,11111110b,00000000b
                        db      00000001b,11111111b,00000000b
                        db      00000001b,10110000b,00000000b
                        db      00000001b,00011000b,00000000b
                        db      00000000b,00011000b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignClip778:

                        db      11111110b,01111111b,11111111b
                        db      11111110b,00111111b,11111111b
                        db      11111110b,00011111b,11111111b
                        db      11111110b,00001111b,11111111b
                        db      11111110b,00000111b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00000001b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000000b,11111111b
                        db      11111110b,00000011b,11111111b
                        db      11111110b,00100001b,11111111b
                        db      11111110b,01100001b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11110000b,11111111b
                        db      11111111b,11111000b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,10000000b,00000000b
                        db      00000000b,11000000b,00000000b
                        db      00000000b,11100000b,00000000b
                        db      00000000b,11110000b,00000000b
                        db      00000000b,11111000b,00000000b
                        db      00000000b,11111100b,00000000b
                        db      00000000b,11111110b,00000000b
                        db      00000000b,11111111b,00000000b
                        db      00000000b,11111111b,00000000b
       			db      00000000b,11011000b,00000000b
                        db      00000000b,10001100b,00000000b
                        db      00000000b,00001100b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000110b,00000000b
                        db      00000000b,00000000b,00000000b


clip_cursor79           db      00111111b,11111111b,11111111b
                        db      00011111b,11111111b,11111111b
                        db      00001111b,11111111b,11111111b
                        db      00000111b,11111111b,11111111b
                        db      00000011b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000000b,11111111b,11111111b
                        db      00000001b,11111111b,11111111b
                        db      00010000b,11111111b,11111111b
                        db      00110000b,11111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111000b,01111111b,11111111b
                        db      11111100b,01111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      01000000b,00000000b,00000000b
                        db      01100000b,00000000b,00000000b
                        db      01110000b,00000000b,00000000b
                        db      01111000b,00000000b,00000000b
                        db      01111100b,00000000b,00000000b
                        db      01111110b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01111111b,00000000b,00000000b
                        db      01101100b,00000000b,00000000b
                        db      01000110b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL ONE *******************************

                ; screen mask

AlignClip179:
                        db      10011111b,11111111b,11111111b
                        db      10001111b,11111111b,11111111b
                        db      10000111b,11111111b,11111111b
                        db      10000011b,11111111b,11111111b
                        db      10000001b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10000000b,11111111b,11111111b
                        db      10001000b,11111111b,11111111b
                        db      10011000b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00100000b,00000000b,00000000b
                        db      00110000b,00000000b,00000000b
                        db      00111000b,00000000b,00000000b
                        db      00111100b,00000000b,00000000b
                        db      00111110b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00111111b,00000000b,00000000b
                        db      00110110b,00000000b,00000000b
                        db      00100011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL TWO *******************************

                ; screen mask

AlignClip279:
                        db      11001111b,11111111b,11111111b
                        db      11000111b,11111111b,11111111b
                        db      11000011b,11111111b,11111111b
                        db      11000001b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000000b,11111111b,11111111b
                        db      11000100b,11111111b,11111111b
                        db      11001100b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00010000b,00000000b,00000000b
                        db      00011000b,00000000b,00000000b
                        db      00011100b,00000000b,00000000b
                        db      00011110b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011111b,00000000b,00000000b
                        db      00011011b,00000000b,00000000b
                        db      00010001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL THREE *******************************

                ; screen mask

AlignClip379:
                        db      11100111b,11111111b,11111111b
                        db      11100011b,11111111b,11111111b
                        db      11100001b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100000b,11111111b,11111111b
                        db      11100010b,11111111b,11111111b
                        db      11100110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00001100b,00000000b,00000000b
                        db      00001110b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001111b,00000000b,00000000b
                        db      00001101b,00000000b,00000000b
                        db      00001000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FOUR *******************************

                ; screen mask

AlignClip479:
                        db      11110011b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110000b,11111111b,11111111b
                        db      11110001b,11111111b,11111111b
                        db      11110011b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000111b,00000000b,00000000b
                        db      00000110b,00000000b,00000000b
                        db      00000100b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL FIVE *******************************

                ; screen mask
AlignClip579:

                        db      11111001b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111000b,11111111b,11111111b
                        db      11111001b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000011b,00000000b,00000000b
                        db      00000010b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SIX *******************************

                ; screen mask

AlignClip679:
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111100b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000001b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b


;****************** ALIGNED FOR PIXEL SEVEN *******************************

                ; screen mask
AlignClip779:

                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111110b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b
                        db      11111111b,11111111b,11111111b

                ; cursor mask

                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b
                        db      00000000b,00000000b,00000000b

CursorOffsetLUT         dw      current_cursor
                        dw      AlignData1
                        dw      AlignData2
                        dw      AlignData3
                        dw      AlignData4
                        dw      AlignData5
                        dw      AlignData6
                        dw      AlignData7
ClipOffsetLUT78         dw      clip_cursor78
                        dw      AlignClip178
                        dw      AlignClip278
                        dw      AlignClip378
                        dw      AlignClip478
                        dw      AlignClip578
                        dw      AlignClip678
                        dw      AlignClip778
ClipOffsetLUT79         dw      clip_cursor79
                        dw      AlignClip179
                        dw      AlignClip279
                        dw      AlignClip379
                        dw      AlignClip479
                        dw      AlignClip579
                        dw      AlignClip679
                        dw      AlignClip779

; pointer to the current look up table set for the pointer image.
; The LUTs are swapped when the pointer enters bytes 78 and 79
; along a scanline to prevent the pointer wrapping around the screen.

PointerLUT              label   word
                        dw      offset  CursorOffsetLUT
 ;;;;;;;;;;;;;;;;;;;;;;;
 ;;;; End of what should be an include for pointer.inc
 ;;;;;;;;;;;;;;;;;;;;;;;

	even
        clrgend		dw	06e41h,07964h,05720h,07461h,06f73h,0f36eh
	hiresylut	dw	350,350,480,480
		
;============================================================================
; Surprisingly, a look up table multiply is much faster than
; the shift - add instruction sequence for multiplying by 80.
; So it would be silly not to use it eh? Times by 80 is needed
; to convert a raster location (1 raster = 80 bytes) in pixel
; y coordinates into a video buffer byte index
; Note: Multiply by 80 is also used for text mode calculations
; now! Andy on the 9/3/93
;============================================================================
        even

        mult80lut       label   word

                mulsum=0
                REPT    480             ; number of VGA scanlines for mode 12h
                dw      mulsum
                mulsum=mulsum+80
                ENDM

;============================================================================
; A table to do a multiply by 320. This is used for converting number of
; rasters into video buffer offsets for mode 13h (256 VGA colour mode).
;============================================================================
        even

        mult320lut      label   word

                mulsum=0
                REPT    200             ; number of VGA scanlines for mode 13h
                dw      mulsum
                mulsum=mulsum+320
                ENDM
        even

;============================================================================
; Look up table for use with modes 10h and 12h. This table provides the means
; for the selection of a clipped or unclipped pointer image depending on the
; current x position of the pointer.
;============================================================================

        ChooseImageLUT  label   word

                REPT    624
                dw      offset CursorOffsetLUT
                ENDM

                REPT    8
                dw      offset ClipOffsetLUT78
                ENDM

                REPT    8
                dw      offset ClipOffsetLUT79
                ENDM

;============================================================================
; Buffer arranged for 4 plane EGA video modes. The screen where
; the pointer is going to be drawn is scanned plane by plane and
; saved as bitplane separations.
;============================================================================

        even            ; make sure that this data is word aligned

        behindcursor    dw      24 dup(?)       ; Plane 0
                        dw      24 dup(?)       ; Plane 1
                        dw      24 dup(?)       ; Plane 2
                        dw      24 dup(?)       ; Plane 3


;============================================================================
; a table of the video buffer segment for the supported
; BIOS text and graphics modes.
;============================================================================

        even            ; make sure that this data is word aligned

        videomodetable  dw      0b800h,0b800h   ; modes 0,1
                        dw      0b800h,0b800h   ; modes 2,3
                        dw      0b800h,0b800h   ; modes 4,5
                        dw      0b800h,0b000h   ; modes 6,7
                        dw      0ffffh,0ffffh   ; n/a
                        dw      0ffffh,0ffffh   ; n/a
                        dw      0ffffh,0a000h   ; n/a,mode 0dh
                        dw      0a000h,0a000h   ; modes 0eh,0fh
                        dw      0a000h,0a000h   ; modes 10h,11h
                        dw      0a000h,0a000h   ; modes 12h,13h
        videobufferseg  dw      ?

        even            ; make sure that this data is word aligned

        hotspot         dw      2 dup(0)

	VRAMlasttextcelloff	label	word	; last text offset in VRAM
        VRAMlastbyteoff dw      ?               ; Last offset in VRAM
	VRAMlastbitoff	dw	?		; LSB: Where pointer is in byte
						; MSB: ODD/EVEN of the pointer
						;      first scan line
	LastXCounters	dw	?		; last X looping counter
	LastYCounters	dw	?		; last Y looping counter
						; ODD in LSB and EVEN in MSB
	lasttextimage	dw	?		; text cell from last time

        background      dw      NOTSTORED       ; STORED if data in buffer
        current_position_x      dw      ?
        current_position_y      dw      ?
        vidbytealigned  dw      ?
        lastmaskrotate  dw      ?
        lastvidmode     db      0ffh    ; the video mode during the last int.
        internalCF      db      0ffh    ; the mouse driver keeps a flag called
                                        ; the internal cursor flag. If the flag
                                        ; = 0, then int 33h f1 will display the
                                        ; pointer, -1 = default value.

 	; 32 bit code writes to this area on a hardware interrupt and
	; when an app does an int 33h function 3, it reads the data
	; directly from here.
	; Data format is: word 0 -> button status
	;                 word 1 -> x virtual coordinate
	;                 word 2 -> y virtual coordinate

	function3data	dw	3 dup(?)

	conditional_off db	0	;!= 0 if conditional off is on
					;
;=============================================================================
; Data to determine the address of where the latches should be saved in the
; video buffer for the current video mode.
; latchcache contains the value looked up by saveVGAregisters and used by
; restoreVGAregisters.
;=============================================================================


        latchcache      dw      ?       ; location of latch cache in VRAM
even
latchhomeLUT    label   word
                        dw      ?               ; mode 0
                        dw      ?               ; mode 1
                        dw      ?               ; mode 2
                        dw      ?               ; mode 3
                        dw      ?               ; mode 4
                        dw      ?               ; mode 5
                        dw      ?               ; mode 6
                        dw      ?               ; mode 7
                        dw      ?               ; mode 8
                        dw      ?               ; mode 9
                        dw      ?               ; mode a
                        dw      ?               ; mode b
                        dw      ?               ; mode c
                        dw      ?               ; mode d
                        dw      80*200+78       ; mode e
                        dw      80*350+78       ; mode f
                        dw      80*350+78       ; mode 10
                        dw      80*480+78       ; mode 11
                        dw      80*480+78       ; mode 12

;=============================================================================
; CGA video mode 4 is a 2 bit per pixel graphics mode. The pointer images
; received from the application (or the default images for that matter) are
; described by a one bit per pixel map. This look up table provides the means
; of conversion from one to two bits per pixel.
;=============================================================================
even
LUT1to2bit      label   word
        dw      00000h,00003h,0000Ch,0000Fh,00030h,00033h,0003Ch,0003Fh
        dw      000C0h,000C3h,000CCh,000CFh,000F0h,000F3h,000FCh,000FFh
        dw      00300h,00303h,0030Ch,0030Fh,00330h,00333h,0033Ch,0033Fh
        dw      003C0h,003C3h,003CCh,003CFh,003F0h,003F3h,003FCh,003FFh
        dw      00C00h,00C03h,00C0Ch,00C0Fh,00C30h,00C33h,00C3Ch,00C3Fh
        dw      00CC0h,00CC3h,00CCCh,00CCFh,00CF0h,00CF3h,00CFCh,00CFFh
        dw      00F00h,00F03h,00F0Ch,00F0Fh,00F30h,00F33h,00F3Ch,00F3Fh
        dw      00FC0h,00FC3h,00FCCh,00FCFh,00FF0h,00FF3h,00FFCh,00FFFh

        dw      03000h,03003h,0300Ch,0300Fh,03030h,03033h,0303Ch,0303Fh
        dw      030C0h,030C3h,030CCh,030CFh,030F0h,030F3h,030FCh,030FFh
        dw      03300h,03303h,0330Ch,0330Fh,03330h,03333h,0333Ch,0333Fh
        dw      033C0h,033C3h,033CCh,033CFh,033F0h,033F3h,033FCh,033FFh
        dw      03C00h,03C03h,03C0Ch,03C0Fh,03C30h,03C33h,03C3Ch,03C3Fh
        dw      03CC0h,03CC3h,03CCCh,03CCFh,03CF0h,03CF3h,03CFCh,03CFFh
        dw      03F00h,03F03h,03F0Ch,03F0Fh,03F30h,03F33h,03F3Ch,03F3Fh
        dw      03FC0h,03FC3h,03FCCh,03FCFh,03FF0h,03FF3h,03FFCh,03FFFh

        dw      0C000h,0C003h,0C00Ch,0C00Fh,0C030h,0C033h,0C03Ch,0C03Fh
        dw      0C0C0h,0C0C3h,0C0CCh,0C0CFh,0C0F0h,0C0F3h,0C0FCh,0C0FFh
        dw      0C300h,0C303h,0C30Ch,0C30Fh,0C330h,0C333h,0C33Ch,0C33Fh
        dw      0C3C0h,0C3C3h,0C3CCh,0C3CFh,0C3F0h,0C3F3h,0C3FCh,0C3FFh
        dw      0CC00h,0CC03h,0CC0Ch,0CC0Fh,0CC30h,0CC33h,0CC3Ch,0CC3Fh
        dw      0CCC0h,0CCC3h,0CCCCh,0CCCFh,0CCF0h,0CCF3h,0CCFCh,0CCFFh
        dw      0CF00h,0CF03h,0CF0Ch,0CF0Fh,0CF30h,0CF33h,0CF3Ch,0CF3Fh
        dw      0CFC0h,0CFC3h,0CFCCh,0CFCFh,0CFF0h,0CFF3h,0CFFCh,0CFFFh

        dw      0F000h,0F003h,0F00Ch,0F00Fh,0F030h,0F033h,0F03Ch,0F03Fh
        dw      0F0C0h,0F0C3h,0F0CCh,0F0CFh,0F0F0h,0F0F3h,0F0FCh,0F0FFh
        dw      0F300h,0F303h,0F30Ch,0F30Fh,0F330h,0F333h,0F33Ch,0F33Fh
        dw      0F3C0h,0F3C3h,0F3CCh,0F3CFh,0F3F0h,0F3F3h,0F3FCh,0F3FFh
        dw      0FC00h,0FC03h,0FC0Ch,0FC0Fh,0FC30h,0FC33h,0FC3Ch,0FC3Fh
        dw      0FCC0h,0FCC3h,0FCCCh,0FCCFh,0FCF0h,0FCF3h,0FCFCh,0FCFFh
        dw      0FF00h,0FF03h,0FF0Ch,0FF0Fh,0FF30h,0FF33h,0FF3Ch,0FF3Fh
        dw      0FFC0h,0FFC3h,0FFCCh,0FFCFh,0FFF0h,0FFF3h,0FFFCh,0FFFFh

;============================================================================
;   Table for selection of the correct pointer image for the current location
;   in the video buffer, when using video BIOS mode 4.
;============================================================================

mode4pointerLUT label   word
        REPT    76              ; for the first 76 bytes of scanline, use these
        dw      current_cursor
        dw      AlignData1
        dw      AlignData2
        dw      AlignData3
        ENDM
        dw      clip_cursor78
        dw      AlignClip178
        dw      AlignClip278
        dw      AlignClip378
        dw      AlignClip478
        dw      AlignClip578
        dw      AlignClip678
        dw      AlignClip778
        dw      clip_cursor79
        dw      AlignClip179
        dw      AlignClip279
        dw      AlignClip379
        dw      AlignClip479
        dw      AlignClip579
        dw      AlignClip679
        dw      AlignClip779

;============================================================================
;   Look up table to adjust CX on clipping in mode 4. This allows the mode4
;   pointer drawing algorithm to use the modes 10h/12h clipped pointer data
;   without having to modify it. The problem is that mode 10/12 expects the
;   data to be 4 bits per pixel and aligned to a word, whereas mode 4 is 2 bits
;   per pixel and aligns to a byte.
;============================================================================

mode4clipCXadjustLUT    label   word
        adjtemp=0               ; data for pixel x-coordinates 0 -> 307
        REPT    77
        dw      4 dup(adjtemp)
        adjtemp=adjtemp+1
        ENDM
        dw      4 dup(76)       ; data for pixels 308 -> 311
        dw      8 dup(78)       ; data for pixels 312 -> 319


;============================================================================
; The CGA buffer is split at 2000h. Therefore if the pointer starts writing
; below scanline 199 on the video display, the odd scanline video buffer
; will become corrupted. In these cases, the pointer should be clipped to
; display scanline 199. The look up table below maps loop counters to a
; display scanline for this purpose.
;
;       table arrangement       (odd scanline data, even scanline data)
;
;============================================================================

mode4clipDXLUT  label   word

        db      200-15  dup(8,8)        ; scanlines 0 -> 184
        db                  8,7         ; scanline  185
        db                  7,7         ; scanline  186
        db                  7,6         ; scanline  187
        db                  6,6         ; scanline  188
        db                  6,5         ; scanline  189
        db                  5,5         ; scanline  190
        db                  5,4         ; scanline  191
        db                  4,4         ; scanline  192
        db                  4,3         ; scanline  193
        db                  3,3         ; scanline  194
        db                  3,2         ; scanline  195
        db                  2,2         ; scanline  196
        db                  2,1         ; scanline  197
        db                  1,1         ; scanline  198
        db                  1,0         ; scanline  199

mode4SelectedPointer    label   word
        dw      ?

;==========================================================================
;   Some space into which the Medium resolution graphics pointer background
;   gets stored. Note that the 256 colour mode buffer encroaches on that of
;   mode 4.
;==========================================================================

bkgrnd256       label   byte            ; 256 colour buffer = 24*16 @ 1 byte/pix
        db      384-64  dup(?)          ; share the CGA buffer(=64 bytes)

CGAbackgrnd     label   byte

        db      24/4*16 dup(?)          ; 24 pixels/row @ 4 pixels/byte for 16
                                        ; rows.

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   Pointer drawing routines.
;===========================================================================
even
drawpointerJMPT label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  drawTextPointer         ; mode 2
        dw      offset  drawTextPointer         ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  drawMediumResPointer    ; mode 4
	dw	offset	drawMediumResPointer	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  drawTextPointer         ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  drawHiResPointer        ; mode f
        dw      offset  drawHiResPointer        ; mode 10
        dw      offset  drawHiResPointer        ; mode 11
        dw      offset  drawHiResPointer        ; mode 12
        dw      offset  drawC256pointer         ; mode 13

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   INT 33h Function 1 support modules.
;===========================================================================
even
int33function1JMPT      label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function1      ; mode 2
        dw      offset  TextInt33Function1      ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  MediumResInt33Function1 ; mode 4
	dw	offset	MediumResInt33Function1	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function1      ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  HiResInt33Function1     ; mode f
        dw      offset  HiResInt33Function1     ; mode 10
        dw      offset  HiResInt33Function1     ; mode 11
        dw      offset  HiResInt33Function1     ; mode 12
        dw      offset  C256Int33Function1      ; mode 13

;===========================================================================
;   Jump table to redirect the code flow according to the current video mode.
;   Used in the 32 bit entry point procedure.
;   INT 33h Function 2 support modules.
;===========================================================================
even
int33function2JMPT      label   word
        dw      offset  not_supported           ; mode 0
        dw      offset  not_supported           ; mode 1
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function2      ; mode 2
        dw      offset  TextInt33Function2      ; mode 3
ELSE
        dw      offset  not_supported		; mode 2
        dw      offset  not_supported		; mode 3
ENDIF
        dw      offset  MediumResInt33Function2 ; mode 4
	dw	offset	MediumResInt33Function2	; mode 5
        dw      offset  not_supported           ; mode 6
IFDEF SIXTEENBIT
        dw      offset  TextInt33Function2      ; mode 7
ELSE
        dw      offset  not_supported		; mode 7
ENDIF
        dw      offset  not_supported           ; mode 8
        dw      offset  not_supported           ; mode 9
        dw      offset  not_supported           ; mode a
        dw      offset  not_supported           ; mode b
        dw      offset  not_supported           ; mode c
        dw      offset  not_supported           ; mode d
        dw      offset  not_supported           ; mode e
        dw      offset  HiResInt33Function2     ; mode f
        dw      offset  HiResInt33Function2     ; mode 10
        dw      offset  HiResInt33Function2     ; mode 11
        dw      offset  HiResInt33Function2     ; mode 12
        dw      offset  C256Int33Function2      ; mode 13



;==========================================================================
;   Some storage space for the critical VGA registers.
;==========================================================================

;Sequencer Registers

seqregs         label   byte
                db      4 dup(?)        ; N.B. sequencer reset reg doesn't
                                        ; get saved.

; Graphics Controller Registers

GCregs          label   byte
                db      9 dup(?)

;==========================================================================
; The mouse driver's very own stack. To prevent unnecessary tears,
; particulary from the application running in DOS land, a stack is
; maintained by the driver. This prevents the driver routines from
; blowing a very full stack elsewhere.
; N.B. on leaving the driver, the stack should be empty!
;==========================================================================

even
mouse_stack     dw      STACKSIZE dup(?)
top_of_stack    label   word
                dw      ?       ; this is where the stack starts

;===========================================================================
; The memory variable below is incremented on entry to the 16 bit code
; and on exit, decremented. If an interrupt occurs during the execution of
; this 16 bit code, the flag is incremented again, and thus greater than zero
; so it is known that the code has been reentered and the stack must be
; maintained accordingly.
;===========================================================================

reentrant       dw      -1

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;   END OF DATA
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



;================================================================
; code to redirect the flow of control from the segment:offset for
; the mouse interrupt (33h) as indicated in the IVT (the IVT entry
; has been set to point to here) to the Insignia mouse driver code.
;================================================================
int33h_vector:

        jmp     short   skip

; High level language entry point.

lvector db      0EAh    ; far jump opcode
loffset dw      ?       ; destination offset
lseg    dw      ?       ; destination segment

; The  pointer set to our interrupt 33h handler

skip:   

;
; Let's just jump to the C mouse_io_interrupt code for
; RISC and bypass the ROM like 4.0 does.
;

	bop	0BDh
	iret



db      0EAh    ; far jump opcode
moff    dw      ?       ; will be filled in by the driver code from the IVT
mseg    dw      ?       ; as before

DOCLI:
        FCLI
        ret

DOSTI:
        FSTI
        ret

DOIRET:
        FIRET


;================================================================
; Functions moved out of ROM - real ROMS mapped in
;================================================================

unexp_int:
        bop     UNEXP_BOP
        jmp     DOIRET

mouse_io:
	;
	; INT 33h entry point
	;

        jmp     mio_hack
        nop
mouse_io_lang:                  ; entry point for HLL
        pushf                   ; check ASAP if redundant show/hide cursor
        push    di              ; save di,
        mov     di, [di+14]     ; get first parameter (mouse function),
                                ; then duplicate mio_hack below.
                                ; this has to be done to preserve
                                ; compatibility between both ways to
                                ; call the mouse.
        jz      lbop            ; F0
        cmp     di,2
        jg      lbop            ; >F2
        je      miol_2
miol_1:
	mov	conditional_off, 0  ; disable conditonal off
        cmp     [internalCF],0  ; is the flag already zero?
        je      miol_12_quit    ; if so, do nothing
        inc     [internalCF]    ; increment it
        jz      lbop
miol_12_quit:
        pop     di
        popf
        jmp     DOIRET

miol_2:
        dec     [internalCF]      ; decrement the pointer internal flag
        cmp     [internalCF], 0ffh; currently displayed?
        jne     miol_12_quit
lbop:
        pop     ax
        popf
        bop     IO_LANG_BOP
        retf    8

mio_hack:			; int 33h handler
        pushf                   ; save up the flags
        cmp     ax,1		; mouse show cursor.
        je      mio_1		
        cmp     ax,2		; mouse hide cursor.
        je      mio_2
        cmp     ax,3		; get button status and mouse position.
        je      mio_3
        cmp     ax,9		; set graphics cursor
        je	mio_9
        cmp     ax,10		; set text cursor - not supported
        je	mio_quit	; return straight back to app.

        jmp short hack1bop      ; none of the above, so goto 32 bit land

mio_1:
	mov	conditional_off, 0  ; disable conditional off
        cmp     [internalCF],0  ; is the flag already zero?
        je      mio_quit        ; if so, do nothing
        inc     [internalCF]    ; increment it
        jz      hack1bop	; just turned zero, so turn pointer on
                                 ; via the 32 bit code.
mio_quit:
        popf
        jmp     DOIRET

mio_2:
        dec     [internalCF]      ; decrement the pointer internal flag
        cmp     [internalCF], 0ffh; currently displayed?
        jne      mio_quit	  ; Already turned off, so quit

hack1bop:
        popf
        bop     IO_INTR_BOP	; BOP to the 32 bit part of the handler
        jmp     DOIRET		; return back after the BOP to caller
mio_9:
	call	int33function9	; change the shape of the graphics pointer
        popf			; restore the flag state
        jmp     DOIRET		; back to the caller
mio_3:
	mov	bx,[function3data]	; return button status
	mov	cx,[function3data+2]	; return x coordinate
	mov	dx,[function3data+4]	; return x coordinate
        popf				; return back to the application
        jmp     DOIRET			; via an iret.


IFDEF MOUSE_VIDEO_BIOS

mouse_video_io:

        pushf
        or      ah,ah
        jne     mvio1
        jmp     do_bop
mvio1:
        cmp     ax,6f05h
        jne     mvio2
        jmp     do_bop
mvio2:
        cmp     ah,4
        jne     mvio3
        jmp     do_bop
mvio3:

;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

        ; Microsoft EGA.LIB function support
        ; input: AH = the function required

        cmp     ah,0f0h         ; is function F0 or greater?
        jge     mvio4           ; YES, so check to see if less than or == F7
        jmp     go_rom          ; NO, so do rom stuff
mvio4:
        cmp     ah,0f7h         ; is it greater than F7
        jg      mvio5           ; YES, so test for == FA
        jmp     ega_lib         ; NO, but in range F0 to F7, so do EGALIB emm
mvio5:
        cmp     ah,0fah
        jne     mvio6
        jmp     egaFA
mvio6:
        jmp     go_rom

        ; to get here, must want to do mouse video functions 0f0h to 0f7h or
        ; function 0fah.

        jmp     ega_lib

        ; data area for EGA.LIB function support
        ; Notice that the sequencer register buffer only has space
        ; for four entrys even though it actually has five addressable
        ; registers. The Sequencer RESET status is not stored, so the buffer
        ; is arranged thus:
        ;                  buffer offset   0   1   2   3
        ;                  register index  1   2   3   4
        ;

        even

        ega_current_crtc        db      25 dup(?) ; driver's copy of CRTC regs
        ega_current_seq         db      4  dup(?) ; driver's copy of Seq regs
        ega_current_graph       db      9  dup(?) ; driver's copy of GC regs
        ega_current_attr        db      20 dup(?) ; driver's copy of AC regs
        ega_current_misc        db      ?         ; driver's copy of misc reg
        dirty_crtc              db      25 dup(?)
        dirty_seq               db      4  dup(?)
        dirty_graph             db      9  dup(?)
        dirty_attr              db      20 dup(?)
        ega_default_crtc        db      25 dup(?) ; default EGA register values
        ega_default_seq         db      4  dup(?) ; as set by the application
        ega_default_graph       db      9  dup(?) ; through a call to F7
        ega_default_attr        db      20 dup(?)
        ega_default_misc        db      ?

        relnum                  label   word

        release_major           db      MAJOR_RELEASE_NUMBER
        release_minor           db      MINOR_RELEASE_NUMBER

        even

        egalibjmp       label   word    ; crafty jump table to replace a base
                                        ; switch
                                dw      egaF0   ; 0F0h - read one EGA register
                                dw      egaF1   ; 0F1h - write one EGA register
                                dw      egaF2   ; 0F2h - read register range
                                dw      egaF3   ; 0F3h - write register range
                                dw      egaF4   ; 0F4h - read register set
                                dw      egaF5   ; 0F5h - write register set
                                dw      egaF6   ; 0F6h - revert to default regs
                                dw      egaF7   ; 0F7h - define deflt reg table
                                dw      noint   ; 0F8h is not a valid function
                                dw      noint   ; 0F9h is not a valid function
                                dw      egaFA   ; 0FAh - interrogate driver
ega_lib:

        xor     al,al
        sub     ax,0f0h                 ; create a jump table index
        shl     ax,1                    ; remember that a word pointer is reqd
        mov     si,ax
        jmp     [egalibjmp+si]          ; get the relavent jump address

egaF0:  ;--- Read an EGA register ----------------------------------------------

        pusha
        and     bx,0ffh                 ; just want the lower byte (BL)
F00:
        cmp     dx,0
        jne     F08
        mov     bl,byte ptr [ega_current_crtc+bx]
        popa
        jmp     noint
F08:
        cmp     dx,8
        jne     F010
        dec     bx                      ; note that RESET is not stored
        mov     bl,byte ptr [ega_current_seq+bx]
        popa
        jmp     noint
F010:
        cmp     dx,010h
        jne     F018
        mov     bl,byte ptr [ega_current_graph+bx]
        popa
        jmp     noint
F018:
        cmp     dx,018h
        jne     F020
        mov     bl,byte ptr [ega_current_attr+bx]
        popa
        jmp     noint
F020:
        cmp     dx,020h
        jne     F028
        mov     bl,byte ptr [ega_current_misc]

F028:   ; do nothing for this case
F0quit:
        popa
        jmp     noint

egaF1:  ;--- Write an EGA register --------------------------------------------

F10:
        pusha
        cmp     dx,0
        jne     F18
        mov     dx,03d4h                ; write to the CRTC index register
        mov     ax,bx                   ; values to write to ports 3d4/3d5
        out     dx,ax                   ; do the write
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_crtc+di],bh
        mov     byte ptr [dirty_crtc+di],1
        popa
        jmp     noint
F18:
        cmp     dx,8
        jne     F110
        mov     dx,03c4h                ; write to the Sequencer index register
        mov     ax,bx                   ; values to write to ports 3c4/3c5
        out     dx,ax                   ; do the write
        cmp     bl,0                    ; Cannot index reset because it its
        jle     F18bra1                 ; not stored. range = 1->4
        and     bx,0ffh                 ; just want BL
        dec     bx                      ; actually, one less than that
        mov     byte ptr [ega_current_seq+bx],ah
        mov     byte ptr [dirty_seq+bx],1
F18bra1:
        popa
        jmp     noint
F110:
        cmp     dx,010h
        jne     F118
        mov     dx,03ceh                ; write to the Graphics controller
        mov     ax,bx                   ; values to write to ports 3ce/3cf
        out     dx,ax                   ; do the write
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_graph+di],bh
        mov     byte ptr [dirty_graph+di],1
        popa
        jmp     noint
F118:
        cmp     dx,018h
        jne     F120
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        mov     ax,bx                   ; need to write BX to the ports
        mov     dx,03c0h                ; Attribute Controller index register
        out     dx,ax                   ; do the write
        inc     dx
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; enable the palette
        mov     di,bx                   ; save the written values to memory
        and     di,0ffh                 ; get just the lower 8 bits
        mov     byte ptr [ega_current_graph+di],bh
        mov     byte ptr [dirty_graph+di],1
        popa
        jmp     noint
F120:
        cmp     dx,020h
        jne     F128
        mov     dx,03c2h                ; EGA miscellaneous register
        mov     al,bl
        out     dx,al                   ; write to the register
        mov     [ega_current_misc],bl
        popa
        jmp     noint
F128:
        cmp     dx,028h
        jne     F128
        mov     dx,03dah                ; EGA feature register
        mov     al,bl
        out     dx,al
F1quit:
        popa
        jmp     noint

egaF2:  ;--- Read a register range ---------------------------------------------

        pusha
        cmp     dx,0
        jne     F28
F20:
        lea     si,ega_current_crtc     ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F28:
        cmp     dx,8
        jne     F210
        lea     si,ega_current_seq      ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        dec     cx                      ; RESET is not stored, so index-1
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F210:
        cmp     dx,010h
        jne     F218
        lea     si,ega_current_graph    ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy to the app's register block
        popa
        jmp     noint
F218:
        cmp     dx,018h
        jne     F2quit
        lea     si,ega_current_attr     ; get the address of this buffer
        mov     dx,cx                   ; save this value
        xchg    ch,cl                   ; create an index with CH
        and     cx,0ffh                 ; only need CH (now CL)
        add     si,cx                   ; SOURCE adjust the address
        xor     dh,dh                   ; only want the old CL value
        mov     cx,dx                   ; restore CX
        mov     di,bx                   ; DESTINATION got from the application
        rep     movsb                   ; copy the application's register block
F2quit:
        popa
        jmp     noint

egaF3:  ;--- Write a register range to the EGA adapter ------------------------

        pusha
        push    ds
        push    es
F31:
        cmp     dx,0
        jne     F38
        lea     di,ega_current_crtc     ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_crtc           ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03d4h                ; CRTC index register
        mov     ah,ch                   ; CRTC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F31cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_crtc array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F31cp
        jmp     F3quit
F38:
        cmp     dx,8
        jne     F310
        lea     di,ega_current_seq      ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        dec     di                      ; RESET is not stored, so index-1
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_seq            ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        inc     bx
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03c4h                ; Sequencer index register
        mov     ah,ch                   ; Sequencer register to start at
        inc     ah
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F38cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_seq array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F38cp
        assume  ds:SpcMseSeg
        jmp     F3quit
F310:
        cmp     dx,010h
        jne     F318
        lea     di,ega_current_graph    ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_graph          ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03ceh                ; Graphics Controller index register
        mov     ah,ch                   ; GC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F310cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_graph array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F310cp
        assume  ds:SpcMseSeg
        jmp     short F3quit
F318:
        cmp     dx,018h
        jne     F3quit
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        lea     di,ega_current_attr     ; write the application data here
        mov     al,ch                   ; adjust the write position as required
        cbw
        add     di,ax                   ; DESTINATION specified address
        mov     si,bx                   ; SOURCE from the application
        lea     bx,dirty_attr           ; need to write some data into here
        add     bx,ax                   ; well, at this offset anyway
        mov     ax,es                   ; The application is the source
        mov     ds,ax                   ; so point to its segment
        mov     dx,03c0h                ; Attribute Controller index register
        mov     ah,ch                   ; AC register to start at
        xor     ch,ch                   ; CX is now the loop counter
        assume  ds:nothing
F318cp:
        mov     byte ptr cs:[bx],1      ; fill in the dirty_attr array
        inc     bx
        movsb                           ; get the value from the app to write
                                        ; and write to the internal buffer
        out     dx,ax                   ; write to the EGA adapter
        loop    F318cp
        assume  ds:SpcMseSeg
F3quit:
        pop     es
        pop     ds
        popa
        jmp     noint

egaF4:  ;--- Read EGA register set -------------------------------------------
        ;
        ; note that the incoming/outgoing data is structured thus:
        ;
        ;       from application -->    db      Port number
        ;                        -->    db      must be zero
        ;                        -->    db      pointer value
        ;       to application   <--    db      data read from register

        pusha
F4lp:
        mov     al,byte ptr es:[bx]     ; get the type of the next EGA register
        mov     dl,byte ptr es:[bx+2]   ; load up the offset required
        xor     dh,dh                   ; convert DL to a word (DX)
        add     bx,3                    ; point to where the data should
                                        ; be written for the application
F40:
        cmp     al,0
        jne     F48
        lea     di,ega_current_crtc     ; point to the internal CRTC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F48:
        cmp     al,8
        jne     F410
        lea     di,ega_current_seq      ; point to the internal Sequencer buffer
        add     di,dx                   ; index into the buffer
        dec     di                      ; RESET is not stored, so index off 1
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F410:
        cmp     al,010h
        jne     F418
        lea     di,ega_current_graph    ; point to the internal GC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F418:
        cmp     al,018h
        jne     F420
        lea     di,ega_current_attr     ; point to the interal AC reg. buffer
        add     di,dx                   ; index into the buffer
        mov     al,byte ptr [di]        ; get the register value from the driver
        mov     byte ptr es:[bx],al     ; store the register value
        jmp     short F4lp2             ; do the next loop iteration
F420:
        cmp     al,020h
        jne     F4lp2
        mov     al,[ega_current_misc]   ; load contents of miscellaneous reg
        mov     byte ptr[di],al         ; store the register value

        ; the C code actually loads BL here but I don't know why!
F4lp2:
        inc     bx               ; point to the next 'record'
        loop    F4lp
        popa
        jmp     noint

egaF5:  ;--- Write EGA register set -------------------------------------------
        ;
        ; note that the incoming data is structured thus:
        ;
        ;       from application -->    db      Port number
        ;                        -->    db      must be zero
        ;                        -->    db      pointer value
        ;                        -->    db      data read from register

        pusha
F5lp:
        mov     al,byte ptr es:[bx]     ; get the type of the next EGA register
        mov     dl,byte ptr es:[bx+2]   ; load up the offset required
        xor     dh,dh                   ; turn from 8 bit to a word quantity
        mov     si,dx                   ; need this when accessing buffers
        add     bx,3                    ; point to where the data should
                                        ; be written for the application
        mov     ah,byte ptr es:[bx]     ; load data to send to the port
        inc     bx                      ; point to the next 'record'
F50:
        cmp     al,0
        jne     F58
        mov     al,dl                   ; also the port offset to access
        mov     dx,03d4h                ; index register for CRTC
        out     dx,ax                   ; write to the specified port
        mov     byte ptr [ega_current_crtc+si],ah
        mov     byte ptr [dirty_crtc+si],1
        jmp     short F5lp2
F58:
        cmp     al,8
        jne     F510
        mov     al,dl                   ; also the port offset to access
        mov     dx,03c4h                ; index register for Sequencer
        out     dx,ax                   ; write to the specified port
        dec     si                      ; RESET is not stored, so index off 1
        mov     byte ptr [ega_current_seq+si],ah
        mov     byte ptr [dirty_seq+si],1
        jmp     short F5lp2
F510:
        cmp     al,010h
        jne     F518
        mov     al,dl                   ; also the port offset to access
        mov     dx,03ceh                ; index register for GC
        out     dx,ax                   ; write to the specified port
        mov     byte ptr [ega_current_graph+si],ah
        mov     byte ptr [dirty_graph+si],1
        jmp     short F5lp2
F518:
        cmp     al,018h
        jne     F520
        mov     dx,03dah                ; clear attribute controller index
        in      al,dx                   ; the read clears this register
        lea     di,ega_current_attr     ; write the application data here
        mov     al,dl                   ; also the port offset to access
        mov     dx,03c0h                ; index register for AC
        out     dx,ax                   ; write to the specified port
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; reenable the video
        mov     byte ptr [ega_current_attr+si],ah
        mov     byte ptr [dirty_attr+si],1
        jmp     short F5lp2
F520:
        cmp     al,020h
        jne     F528
        mov     byte ptr [ega_current_misc],ah
        mov     dx,03c2h                ; Miscellaneous output register
        xchg    ah,al
        out     dx,al                   ; write one byte
        jmp     short F5lp2
F528:
        xchg    ah,al
        mov     dx,03dah                ; EGA feature register
        out     dx,al
F5lp2:
        dec     cx
        cmp     cx,0
        jz      F5quit
        jmp     F5lp
F5quit:
        popa
        jmp     noint

egaF6:  ;--- Restore the EGA default register values --------------------------
        pusha
        push    es

        ; copy the default EGA register sets to the driver's internal cache

        mov     ax,ds
        mov     es,ax

        mov     cx,25
        lea     di,ega_current_crtc
        lea     si,ega_default_crtc
        rep     movsb
        mov     cx,4
        lea     di,ega_current_seq
        lea     si,ega_default_seq
        rep     movsb
        mov     cx,9
        lea     di,ega_current_graph
        lea     si,ega_default_graph
        rep     movsb
        mov     cx,20
        lea     di,ega_current_attr
        lea     si,ega_default_attr
        rep     movsb
        mov     al,[ega_default_misc]
        mov     [ega_current_misc],al

        ; Set up the Sequencer defaults

        mov     dx,03c4h                ; Sequencer index register
        mov     ax,0100h                ; Synchronous reset
        out     dx,ax                   ; do the work

        xor     bx,bx                   ; do the four non reset registers
        inc     al                      ; point to the next Sequencer register
F6lp1:
        cmp     [dirty_seq+bx],1        ; has the dirty bit been set?
        jne     F6ne1
        mov     ah,[ega_default_seq+bx] ; default value to send to the register
        out     dx,ax                   ; do the work
F6ne1:
        inc     bx                      ; point to the next buffer location
        inc     al                      ; point to the next Sequencer register
        cmp     bx,3                    ; copy elements 0->3 to ports
        jl      F6lp1
        mov     ax,0300h                ; Clear synchronous reset
        out     dx,ax                   ; do the work

        ; Set up the default Miscellaneous Output Register value.

        mov     dx,03c2h                ; Miscellaneous o/p register address
        mov     al,[ega_default_misc]   ; the default value
        out     dx,al                   ; write to the EGA/VGA

        ; Set up the Cathode Ray Tube Controller in the default fashion

        mov     dx,03d4h                ; Index to the CRTC
        xor     bx,bx                   ; clear an index register
F6lp2:
        cmp     [dirty_crtc+bx],1       ; has the dirty bit been set?
        jne     F6ne2
        mov     ax,bx                   ; index for the CRTC index register
        mov     ah,[ega_default_crtc+bx] ; default value for the selected reg.
        out     dx,ax
F6ne2:
        inc     bx                      ; point to the next location
        cmp     bx,25                   ; 25 registers to copy
        jl      F6lp2

        ; Set up the Attribute Controller default values
        ; Remember that this is a funny beast which uses a flip-flop
        ; off just one address/data port

        mov     dx,03dah                ; CRT status register
        in      al,dx                   ; set the AC flip-flop
        mov     dx,03c0h                ; Attibute controller address/data regs
        xor     bx,bx                   ; clear an index register
F6lp3:
        cmp     [dirty_attr+bx],1       ; has the dirty bit been set?
        jne     F6ne3
        mov     ax,bx                   ; index for the CRTC index register
        mov     ah,[ega_default_attr+bx] ; default value for the selected reg.
        out     dx,al                   ; index the register, then flip the flop
        xchg    al,ah                   ; get the default data for this register
        out     dx,al                   ; write the data out
F6ne3:
        inc     bx                      ; point to the next location
        cmp     bx,20                   ; 20 registers to copy

        ; Set the Graphics Controller default values

        mov     dx,03ceh                ; Index to the GC
        xor     bx,bx                   ; clear an index register
F6lp4:
        cmp     [dirty_graph+bx],1      ; has the dirty bit been set?
        jne     F6ne4
        mov     ax,bx                   ; index for the GC index register
        mov     ah,[ega_default_graph+bx] ; default value for the selected reg.
        out     dx,ax
F6ne4:
        inc     bx                      ; point to the next location
        cmp     bx,9                    ; 9 registers to copy
        jl      F6lp2

        ; Reenable the video

        mov     dx,03c0h                ; index register for AC
        mov     al,020h                 ; EGA palette enable
        out     dx,al                   ; reenable the video

        ; Clean out the dirty register arrays

        xor     al,al                   ; put a nice zero in all the dirty
                                        ; registers
        mov     cx,25+4+9+20            ; do the CRTC, SEQ, GC and AC in
        mov     di,offset dirty_crtc    ; one go
        rep     stosb

        pop     es
        popa
        jmp     noint

egaF7:  ;---Define default register table -------------------------------------
        pusha
        push    es
        push    ds

        ; Load a new set of default registers for a particular EGA/VGA component


        mov     si,bx           ; SOURCE of the incoming data from the app
        mov     ax,es           ; save the SOURCE segment register
        mov     bx,ds           ; save the DESTINATION offset
        mov     ds,ax           ; DS is now the SOURCE segment in the app
        mov     es,bx           ; ES is now the DESTINATION segment in the dvr

        assume ds:nothing, es:SpcMseSeg

F70:    ; Set the default CRTC registers

        cmp     dx,0
        jne     F78
        mov     cx,25           ; copy 25 register entries
        mov     di,offset ega_default_crtc
        rep     movsb           ; do the copy
        jmp     short F7dirty

F78:    ; Set the default Sequencer registers

        cmp     dx,8
        jne     F710
        mov     cx,4            ; copy 4 register entries
        mov     di,offset ega_default_seq
        rep     movsb           ; do the copy
        jmp     short F7dirty

F710:   ; Set the default Graphic Controller registers

        cmp     dx,10
        jne     F718
        mov     cx,9            ; copy 9 register entries
        mov     di,offset ega_default_graph
        rep     movsb           ; do the copy
        jmp     short F7dirty

F718:   ; Set the default Attribute Controller registers

        cmp     dx,18
        jne     F720
        mov     cx,20           ; copy 20 register entries
        mov     di,offset ega_default_attr
        rep     movsb           ; do the copy
        jmp     short F7dirty

F720:   ; Set the default Miscellaneous Output register

        cmp     dx,20
        jne     F7quit
        mov     word ptr cs:[ega_default_misc],si

F7dirty:

        ; Set all the dirty register arrays

        mov     al,1                    ; put a nice one in all the dirty
                                        ; registers
        mov     cx,25+4+9+20            ; dirty all the registers in one go
        mov     di,offset dirty_crtc
        rep     stosb

F7quit:
        pop     ds              ; need to restore the segment registers
        pop     es

        assume  ds:SpcMseSeg, es:nothing

        popa

        jmp     noint

egaFA:  ;--- Interrogate driver -----------------------------------------------
        ; The real Microsoft mouse driver gets this wrong (release 7.03)

        push    ax
        mov     ax,cs
        mov     es,ax
        mov     bx,offset relnum        ; return the address of the mouse
                                        ; driver version number
        pop     ax
        jmp     noint

;=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

ENDIF ; MOUSE_VIDEO_BIOS

do_bop:

        bop     VIDEO_IO_BOP    ;BOP BE
        nop
        nop
        jnc     noint
go_rom:
        popf
        db      0EAh    ; this is a far jump
old_vid_int     dd ?    ; far pointer to the old int 10h vector
        jmp     DOIRET
noint:
        popf
        jmp     DOIRET

mouse_int1:
        bop     INT1_BOP
        jmp     DOIRET

mouse_version:
        dw      04242h
        dw      0000h

mouse_copyright:
        db      "Windows NT MS-DOS subsystem Mouse Driver"

video_io:
        int     VIDEO
        bop     UNSIMULATE_BOP

mouse_int2:
        bop     INT2_BOP
        jmp     DOIRET

mouseINB:
        in      al,dx
        bop     0feh

mouseOUTB:
        out     dx,al
        bop     0feh

mouseOUTW:
        out     dx,ax
        bop     0feh


;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;16 BIT ENTRY POINT 16 BIT ENTRY POINT 16 BIT ENTRY POINT 16 BIT ENTRY POINT
;
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure that provides the driver interface to 32 bit land. This is
;   the entry point to the Intel 16 bit driver from the mouse interrupt
;   handler in the host mouse code.
;
;   This procedure determines the current video mode from the BIOS data
;   area, and depending on this branches to the correct display routines
;   for this mode.
;
;   N.B. This function MUST NOT modify CX and DX because the next level
;   of functions in the driver heirarchy requires the values passed in
;   them from 32 bit land.
;========================================================================

        assume  ds:SpcMseSeg

entry_point_from_32bit  proc    near
        make_stack              ; use the driver's own stack
        push    ds
        push    ax
        push    bx

        mov     ax,cs
        mov     ds,ax

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [drawpointerJMPT+bx]    ; jump to the correct routine

        pop     bx
        pop     ax
        pop     ds
        kill_stack              ; return to the previous stack

        bop     0FEh            ; return to the 32 bit side

entry_point_from_32bit  endp


;========================================================================
;   Procedure to set the cursor draw flag to DO DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 1.
;
;   In accordance with the Microsoft Programmer's Reference, the internal
;   cursor flag (internalCF) has a default value of -1. If intenalCF = 0
;   then the cursor is drawn. If the flag is already 0, then this function
;   does nothing.
;
;   Note: with calls to int 33h AX = 2, it is legal to
;   make internalCF less than -1.
;========================================================================

int33function1  proc    near

        make_stack              ; use the driver's own stack
        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI

        ; check to see if the pointer should be drawn

;        cmp     [internalCF],0  ; is the flag already zero?
;        jz      fn1quit         ; if so, do nothing

	; pointer is not ON, so increment the flag to try to turn it ON

;        inc     [internalCF]    ; increment the pointer internal flag
;        cmp     [internalCF],0  ; if 0, then the pointer can be drawn
;        jl      fn1quit         ; it is < 0, so don't draw the pointer.

	; The internal cursor flag hits zero for the first time, so
	; draw the pointer.

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [Int33function1JMPT+bx] ; do the correct function 1 handler
fn1quit:
;;	call	DOSTI
        pop     ds
        pop     bx
        pop     ax
        kill_stack              ; return to the previous stack
        bop     0FEh            ; back to jolly old 32 bit land

int33function1  endp



;========================================================================
;   Procedure to set the cursor draw flag to DONT DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 2
;
;   Note: with calls to int 33h AX = 2, it is legal to
;   make internalCF less than -1.
;========================================================================

int33function2  proc    near

        make_stack              ; use the driver's own stack
        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI

;        dec     [internalCF]    ; decrement the pointer internal flag

	; if the internal cursor flag is less than -1, then do not try
	; do remove the pointer from the screen because this has already
	; been done.

;        cmp     [internalCF],0ffh
;        jl      fn2quit		; do nothing if < -1

	; Internal flag hits -1, so remove the pointer from the screen.

        call    getBIOSvideomode; read the BIOS data area
        xor     bx,bx           ; clear the jump table index
        shl     al,1            ; create a table index for word sized entries
        mov     bl,al           ; move into a base register
        call    [Int33function2JMPT+bx] ; do the correct function 1 handler
fn2quit:
;;	call	DOSTI
        pop     ds
        pop     bx
        pop     ax
        kill_stack              ; return to the previous stack

        bop     0feh

int33function2  endp

;========================================================================
;   Procedure to return straight back to cloud 32. This is needed if an
;   unsupported video mode is found in the BIOS data area.
;========================================================================

not_supported   proc    near
        ret                     ; cant't BOP 0feh here or the stack will die
                                ; (out of balance with CS:IP stored from call)
not_supported   endp

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; END 16 BIT ENTRY END 16 BIT ENTRY END 16 BIT ENTRY END 16 BIT ENTRY
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display for
;   high resolution graphics modes.
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================


drawHiResPointer        proc    near

        ; save the video card's read/write context

;;	call	 DOCLI
        pusha
        push    ds
        mov     ax,cs           ; make sure that DS points to the
        mov     ds,ax           ; right segment


        call    saveVGAregisters
        call    check_for_mode_change


        mov     bx,cx           ; get X coordinate into a base register
        shl     bx,1            ; calculate a word index
        mov     ax,[ChooseImageLUT+bx] ; select the right image LUT
        mov     [PointerLUT],ax ; store the LUT address

	xor	ax,ax		; assume carry clear after the next call
        call    determineboundary
	jnc	detcont		; pointer in buonds if carry clear
	not	ax		; carry was set, so set AX non zero

detcont:

        ; Coordinates are now transformed from Cartesian to physical VRAM
        ; memory byte and bit offsets.

        mov     di,dx           ; store DX for later

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition

        cmp     [internalCF],0
        jnz     end_the_if              ; request to turn pointer on
        cmp     [background],STORED
        jne     end_the_if

        mov     si,cx
        mov     di,dx
        mov     dx,[VRAMlastbyteoff]
        mov     cx,[VRAMlastbitoff]
        call    restore_background

	cmp	ax,0		; should the pointer be drawn?
	jnz	end_the_if	; if the pointer has gone off the edge of
				; the screen, then quit

        mov     [VRAMlastbyteoff],di    ; save the current position
        mov     [VRAMlastbitoff],si
        mov     cx,si
        mov     dx,di
        call    save_background
        mov     cx,si
        mov     dx,di
        call    drawEGApointer

end_the_if:

        call    restoreVGAregisters

        pop     ds
        popa
;;	call	 DOSTI
        ret

drawHiResPointer        endp

;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display.for
;   medium resolution graphics modes.
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

drawMediumResPointer    proc    near

        pusha
;;	call	DOCLI

        shr     cx,1                    ; map from 640 virtual to 320 real

        ; CX,DX = x,y cartesian coordinates here.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition


        cmp     [internalCF],0
        jnz     cant_draw_ptr           ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_ptr
	mov	si, cx			; save new cursor position
	mov	di, dx
	mov	dx,[VRAMlastbyteoff]	;
        mov     cx,[VRAMlastbitoff]
	mov	bp,[LastYCounters]	; Y looping counter
        call    restorebkgrndmode4
	mov	cx, si			; restore new cursor position
	mov	dx, di
	call	detboundmode4		; calculate new byte offset
	jc	cant_draw_ptr		; don't draw new cursor of out of scrn

	mov	[VRAMlastbyteoff], dx	; byte offset
	mov	[VRAMlastbitoff], cx	; MSB = 0FFh if start with ODD line
					; LSB = bit offset
	mov	[LastYCounters], bp	; MSB: even counter, LSB for odd
        call    savebkgrndmode4
        call    drawmode4pointer

cant_draw_ptr:

;;	call	DOSTI
        popa
        ret

drawMediumResPointer    endp

;========================================================================
;   Procedure to draw a cursor on the fullscreen X86 graphics display for
;   medium resolution, 256 colour graphics mode. (video bios mode 13h).
;   This procedure saves the area about to be written over, blts the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

drawC256Pointer proc    near
        pusha
;;	call	DOCLI
        shr     cx,1                    ; map from 640 virtual to 320 real x

        ; CX,DX = x,y cartesian coordinates here.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition


        cmp     [internalCF],0
        jnz     cant_draw_256ptr        ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_256ptr

        mov     si,cx
        mov     di,dx
        mov     dx,[VRAMlastbyteoff]
	mov	cx,[LastXCounters]
	mov	bp,[LastYCounters]
        call    restorebkgrndmode13
	mov	cx, si
	mov	dx, di
	call	detboundmode13
	jc	cant_draw_256ptr

	mov	[VRAMlastbyteoff],dx	 ; save the current position
	mov	[LastXCounters],cx
	mov	[LastYCounters], bp
        call    savebkgrndmode13
        call    draw256pointer

cant_draw_256ptr:
;;	call	DOSTI
        popa
        ret
drawC256Pointer endp

;========================================================================
;   Procedure to draw a pointer on the fullscreen X86 text display for
;   BIOS modes 3 and 7.
;   This procedure saves the area about to be written over, XORs the
;   pointer image onto the screen and restores the background from whence
;   cursor has just come.
;
;   Input:      CX = x-coordinate
;               DX = y-coordinate
;   Output:     None
;========================================================================

IFDEF SIXTEENBIT

drawTextPointer proc    near
        pusha
	push	es

        ; CX,DX = x,y virtual pixel coordinates here.
	; 0 <= x < 640
	; 0 <= y < 200	for 25 line mode
	; 0 <= y < 344	for 43 line mode
	; 0 <= y < 400	for 50 line mode
	; The virtual character size is always 8x8 virtual pixels.

        call    check_for_mode_change

        ; internalCF     = the current pointer status
        ; background     = indicates if a background has been stored or not
        ;
        ; if(internalCF == Zero && background == STORED)
        ; The normal cursor ON condition

        cmp     [internalCF],0
        jnz     cant_draw_text_ptr     ; request to turn pointer on
        cmp     [background],STORED
        jne     cant_draw_text_ptr


        ; Calculate the current cell location as an offset
        ; into the text buffer segment starting at B800:0
        ; Note: The following kinky shifts allow for the fact that the text
        ;       video buffer consists of word elements of the form char:attr.
        ;       So, if a row = 80 characters wide on the screen, it is 160
        ;       bytes wide in VRAM.

        mov     bx,dx                   ; create a word table index
        shr     bx,3                    ; virtual char height = 8, but 160 bytes
                                        ; per text row, so save some shifts.
        shl     bx,1                    ; make a word table index
        mov     di,[mult80lut+bx]       ; multiply by 80 words per text row.
        shl     di,1
        shr     cx,3                    ; divide the x virtual pixel coordinate
                                        ; by 8 = virtual char width and mult
                                        ; by 2 to get word offset in text row.
        shl     cx,1
        add     di,cx                   ; full VRAM location now in DI

        ; Restore the text cell previously overwritten.

        mov     si,[VRAMlasttextcelloff]; address of last modified text cell
        mov     [VRAMlasttextcelloff],di; store the current cell location

        mov     ax,0b800h               ; the text buffer segment
        mov     es,ax                   ; ES now points there

        ; The text pointer uses the same magic as the graphics code
        ; to place a pointer on the screen.

        mov     bx,07700h               ; the magic cursor mask for pointer
        mov     cx,077ffh               ; the magic screen mask for pointer

        assume es:nothing

        mov     ax,[lasttextimage]      ; restore the background
        mov     es:[si],ax              ; from last time
        mov     ax,es:[di]              ; load the cell to be modifyed
        mov     [lasttextimage],ax      ; save this cell for next time
        and     ax,cx                   ; apply the screen mask
        xor     ax,bx                   ; apply the cursor mask
        mov     es:[di],ax              ; and write back

        assume es:SpcMseSeg

cant_draw_text_ptr:

	pop	es
        popa
	ret
drawTextPointer endp

ENDIF ;; SIXTEENBIT

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Interrupt 33h support functions.
; These functions are called via a jump table from the 16 bit entry
; point code.
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure to set the cursor draw flag to DO DRAW. This is called from
;   SoftPC code via a host_simulate(). This routine is called when the
;   application does an INT 33h, function 1
;========================================================================

int33function0  proc    near

        make_stack                      ; use the driver's own stack
        push    ds
        push    es
        pusha

        ; sort out the segments

        mov     ax,cs
        mov     ds,ax
        mov     ax,cs
        mov     es,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI
        ; set the internal pointer flag to its default value.

        mov     [internalCF],0ffh

        ; set the default hotspot location = (0,0)

        xor     ax,ax
        mov     [hotspot],ax
        mov     [hotspot+2],ax

        ; copy the default pointer to the working pointer buffer

        lea     si,default_cursor
        lea     di,current_cursor
        call    copy_pointer_to_current

        ; clear the pointer enabled flag, turn the pointer off by restoring
        ; the background.

        mov     [background],NOTSTORED  ; there is no stored background now

;;	call	DOSTI
        popa
        pop     es
        pop     ds
        kill_stack                      ; restore the previous stack
        bop     0FEh

int33function0  endp



;========================================================================
;   Procedure to accept a cursor bit image from the current application
;   at ES:DX. This is stored as the current pointer image for use by
;   the driver.
;========================================================================

assume es:nothing

int33function9  proc    near
	call	DOCLI
        make_stack                      ; use the driver's own stack
        push    ds
        push    es
        pusha


        mov     ax,cs                   ; point at the driver data segment
        mov     ds,ax
;; do not allow mouse int comes in while we are updating the cursor.
;;	call	DOCLI
        ; Read in the hotspot cartesian coordinate values for the
        ; new pointer image. If the hotspot values are out of range
        ; i.e. >127 | < -128, then reset to the boundary value
        ; Now using kinky non modRM short forms by clever use of AX

        mov     ax,127                  ; load accumulator with 127
        mov     bp,ax                   ; store this constant in a register
        cmp     ax,bx                   ; compare X value of hotspot with 127
        jg      test_low_x              ; if 127 > BX, BX is within upper limit
        xchg    ax,bx                   ; BX > 127, so set to 127
        jmp     short check_y_hotspot   ; now test the Y values

test_low_x:

        not     ax                      ; change accumulator from 127 to -128
        cmp     ax,bx                   ; compare X value of hotspot with -128
        jl      check_y_hotspot         ; if -128 < BX, BX is within lower lim.
        xchg    ax,bx                   ; BX < -128, so set it to -128

check_y_hotspot:

        mov     ax,bp                   ; reload AX with 127
        cmp     ax,cx                   ; compare Y value of hotspot with 127
        jg      test_low_y              ; if 127 > CX, Cx is within upper limit
        xchg    ax,cx                   ; CX > 127, so set CX to 127
        jmp     short done_hotspot_check; both hotspot coords tested, so save

test_low_y:

        not     ax                      ; change accumulator from 127 to -128
        cmp     ax,cx                   ; compare Y value of hotspot with -128
        jl      done_hotspot_check      ; if -128 < CX, CX is within lower lim.
        xchg    ax,cx                   ; CX < -128, so set it to -128

done_hotspot_check:

        mov     [hotspot],bx            ; save the hotspot x,y
        mov     [hotspot+2],cx          ; y component of the hotspot

        ; DESTINATION: the driver current pointer buffer
        ; Note: the SOURCE is already being pointed at by DX

        lea     di,current_cursor       ; this is the bit that must change
        mov     si,dx

        ; copy in the new application pointer

        mov     ax,es
        mov     ds,ax                   ; DS now points to where ES points
        mov     ax,cs
        mov     ax,es                   ; ES points to our data area now
        call    copy_pointer_to_current ; Copy the pointer image appropriately

        popa
        pop     es
        pop     ds
        kill_stack                      ; restore the previous stack
	call	DOSTI
        ret				; this code is called from within this
					; 16 bit driver, so don't BOP
int33function9  endp

;============================================================================
;   Procedure to display the pointer image in HIRES graphics modes
;============================================================================

HiResInt33Function1     proc    near

        pusha
        call    check_for_mode_change
        call    saveVGAregisters
        mov     cx,[current_position_x] ; get the last known cursor position
        mov     dx,[current_position_y] ; from the OS via the event loop
        call    determineboundary       ; convert to VRAM coordinates
	jc	end_function1		; if the pointer has gone off the edge
					; of the screen, then quit
        mov     [VRAMlastbyteoff],dx    ; save the restore background location
        mov     [VRAMlastbitoff],cx
        mov     si,cx
        mov     di,dx
        call    save_background
        mov     cx,si
        mov     dx,di
        call    drawEGApointer
        mov     [background],STORED
end_function1:
        call    restoreVGAregisters
        popa
        ret                             ; return to driver surface manager code

HiResInt33Function1     endp

;============================================================================
;   Procedure to display the pointer image in MEDIUMRES graphics modes
;   Note that this function does a conversion from virtual pixel coordinates
;   to real screen coordinates as required if the stored values in the
;   current_position memory locations are greater than 320 for X or 200
;   for Y.
;============================================================================

MediumResInt33Function1 proc    near

        pusha
        call    check_for_mode_change
        mov     cx,[current_position_x] ; get the last known cursor position
        mov     dx,[current_position_y] ; from the OS via the event loop
	shr	cx,1			; virtual coor -> screen coor
        call    detboundmode4           ; convert to VRAM coordinates
	jc	MediumResFunction1_exit

        mov     [VRAMlastbyteoff],dx    ; save the restore background location
        mov     [VRAMlastbitoff],cx
	mov	[LastYCounters], bp
        call    savebkgrndmode4
        call    drawmode4pointer
        mov     [background],STORED

MediumResFunction1_exit:
        popa
        ret

MediumResInt33Function1 endp

;============================================================================
;   Procedure to display the pointer image in VGA 256 colour graphics modes
;============================================================================

C256Int33Function1      proc    near
        pusha
        call    check_for_mode_change
        call    modifyentry255          ; make sure that DAC entry 255 is white
        mov     cx,[current_position_x] ; get the last known cursor position
	mov	dx,[current_position_y]
	shr	cx, 1			; virtual coor -> screen coord
        call    detboundmode13          ; convert to VRAM coordinates
	jc	C256Function1_exit

        mov     [VRAMlastbyteoff],dx    ; save the restore background location
	mov	[LastXCounters],cx	; X loop counter
	mov	[LastYCounters], bp	; Y loop counter
        call    savebkgrndmode13
        call    draw256pointer
        mov     [background],STORED

C256Function1_exit:
        popa
        ret                             ; return to driver surface manager code

C256Int33Function1      endp

;============================================================================
; Procedure to show the TEXT pointer
;============================================================================
IFDEF SIXTEENBIT

TextInt33Function1     proc    near

        pusha
        push    es

        mov     [background],STORED
        call    check_for_mode_change

        mov     cx,[current_position_x] ; get the last known cursor position
        mov     bx,[current_position_y] ; from the OS via the event loop

        shr     bx,3                    ; virtual char height = 8, but 160 bytes
                                        ; per text row.
        shl     bx,1                    ; make a word table index
        mov     di,[mult80lut+bx]       ; multiply by 80 words per text row.
        shl     di,1                    ; remember 160 bytes NOT 80 in a row
        shr     cx,3                    ; divide the x virtual pixel coordinate
                                        ; by 8 = virtual char width and mult
                                        ; by 2 to get word offset in text row.
        shl     cx,1
        add     di,cx                   ; full VRAM location now in DI

        mov     [VRAMlasttextcelloff],di; store the current cell location

        mov     ax,0b800h               ; the text buffer segment
        mov     es,ax                   ; DS now points there

        mov     bx,07700h               ; the magic cursor mask for pointer
        mov     cx,077ffh               ; the magic screen mask for pointer

        assume es:nothing

        mov     ax,es:[di]              ; load the cell to be modifyed
        mov     [lasttextimage],ax      ; save this cell for next time
        and     ax,cx                   ; apply the screen mask
        xor     ax,bx                   ; apply the cursor mask
        mov     es:[di],ax              ; and write back

        assume es:SpcMseSeg

        pop     es
        popa
        ret                             ; return to driver surface manager code

TextInt33Function1     endp

ENDIF ;; SIXTEENBIT
;============================================================================
;   Procedure to remove the pointer image in HIRES graphics modes
;============================================================================

HiResInt33Function2     proc    near

        push    cx
        push    dx

        call    saveVGAregisters
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     no_background_stored    ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
        mov     cx,[VRAMlastbitoff]
        call    restore_background      ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

no_background_stored:

        call    restoreVGAregisters

        pop     dx
        pop     cx
        ret

HiResInt33Function2     endp

;============================================================================
;   Procedure to remove the pointer image in MEDIUMRES graphics modes
;============================================================================

MediumResInt33Function2 proc    near
        push    cx
        push    dx
	push	bp
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     nobkgrndstored          ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
        cmp     dx,80*100               ; mustn't be greater than buffer size
        jl      vidoffok                ; it's OK, so do nothing
        mov     dx,80*10-1              ; modify DX to fit in the buffer
vidoffok:
	mov	cx,[VRAMlastbitoff]	; CL = bit offset
					; CH = odd/even flag
	and	cl,3			; cannot be greater than bit 3( 2bits/p)
	mov	bp, [LastYCounters]
        call    restorebkgrndmode4      ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

nobkgrndstored:
	pop	bp
        pop     dx
        pop     cx
        ret
MediumResInt33Function2 endp

;============================================================================
;   Procedure to remove the pointer image in MEDIUMRES graphics modes
;============================================================================

C256Int33Function2      proc    near
        push    cx
        push    dx
	push	bp
        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     nobkgrndstored256       ; no, so don't restore it
        mov     dx,[VRAMlastbyteoff]
	mov	cx,[LastXCounters]
	mov	bp,[LastYCounters]
        call    restorebkgrndmode13     ; restored the background at correct
        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag
nobkgrndstored256:

	pop	bp
        pop     dx
        pop     cx
        ret

C256Int33Function2      endp

;============================================================================
;   Procedure to remove the pointer image in TEXT modes
;============================================================================

IFDEF SIXTEENBIT

TextInt33Function2     proc    near

	push	ax
	push	si
	push	es

        call    check_for_mode_change

        cmp     [background],STORED     ; is there some stored background?
        jne     no_text_background_stored    ; no, so don't restore it

        mov     [background],NOTSTORED  ; place. Set buffer cleared Flag

	; Restore the text cell previously overwritten.

        mov	si,[VRAMlasttextcelloff]; address of last modified text cell

	mov	ax,0b800h		; the text buffer segment
	mov	es,ax			; DS now points there

	assume es:nothing

	mov	ax,[lasttextimage]	; restore the background
	mov	es:[si],ax		; from last time

no_text_background_stored:

	assume	es:SpcMseSeg

        pop     es
        pop     si
        pop     ax
        ret

TextInt33Function2     endp

ENDIF ;; SIXTEENBIT

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; End of Interrupt 33h support functions.
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; Mouse driver general support functions
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


;========================================================================
;  Procedure to determine if the application has changed video modes since
;  the last mouse interrupt. If it has, then the image that is saved in the
;  background restore buffer is invalid and should not be drawn.
;========================================================================

check_for_mode_change   proc    near

        push    ax

        call    getBIOSvideomode; peek at the BIOS data area for video mode
        cmp     al,[lastvidmode]; compare with the last mode value
                                ; from the preceding interrupt
        jnz     mode_change     ; a mode change has occurred
        pop     ax              ; no mode change, so quit
        ret
mode_change:
        mov     [background],NOTSTORED
        mov     byte ptr [lastvidmode],al       ; store the new mode
        pop     ax

        ret
check_for_mode_change   endp

;========================================================================
; Procedure to read the BIOS data area and get the current video mode
; Output:   AL = BIOS video mode
; Modifies: memory variable -> currentvidmode, puts the video found in
;           the BIOS data area in this memory location.
;========================================================================

getBIOSvideomode        proc    near

        push    es
        push    bx
        mov     ax,40h          ; BIOS data area segment
        mov     es,ax

        mov     al,es:[49h]     ; get the BIOS video mode data

        mov     bl,al           ; copy the video mode value
        xor     bh,bh
        shl     bx,1            ; create a word table index
        mov     bx,[latchhomeLUT+bx] ; get the latch hiding place for this
                                ; video mode
        mov     [latchcache],bx ; save in memory for use in save and restore
                                ; vga registers.

        pop     bx
        pop     es              ; restore the 'normal' data segment
        ret

getBIOSvideomode        endp

;=========================================================================
; Function to modify the 256th palette entry for 256 colour mode. The
; driver requires white to be set in this DAC register triple.
;=========================================================================
modifyentry255  proc    near
        push    ax
        push    dx
        mov     dx,03c8h
        mov     al,0ffh
        out     dx,al
        inc     dx
        out     dx,al
        out     dx,al
        out     dx,al
        pop     dx
        pop     ax
        ret
modifyentry255  endp


;========================================================================
;   Procedure to copy the required pointer image to the snapshot
;   buffers. Each buffer holds a different instance of the mouse
;   pointer for each possible alignment of the pointer image in
;   a VRAM byte.
;
;   INPUT DS:SI = pointer to the source image
;
;========================================================================

assume  ds:nothing

copy_pointer_to_current proc    near

        push    ds
        push    es
        pusha


        ; Set up the destination for the copy

        mov     ax,cs                   ; point ES to this segment
        mov     es,ax
        lea     di,current_cursor       ; this is the bit that must change
        mov     bx,di                   ; save this address for a while
        mov     bp,si                   ; save the application source address

        ; Fill the AND buffer with 1s and then fill the XOR buffer with
        ; 0s for the byte aligned pointer condition. This is done so that
        ; the last byte in the 3byte scanline sequence is set to the correct
        ; value to prevent image loss from the screen.

        cld                             ; move low mem -> high mem
        mov     ax,24                   ; avoid doing a modRM load of immediate
        mov     cx,ax                   ; 24 words to fill.
        mov     dx,ax                   ; store this for a while
        xor     ax,ax                   ; clear AX (AX = 0)
        not     ax                      ; AX = 0ffffh -> fill AND mask with it.
        rep     stosw                   ; fill the screen mask (AND mask)
        mov     cx,dx                   ; do the next 24 words (XOR mask)
        not     ax                      ; AX = 0h -> fill XOR mask with it
        rep     stosw                   ; Fill the cursor mask

        ; Now fill the prepared 48 word buffer with the user defined
        ; AND and XOR masks
        ; Note that the image passed in from the application is little-endian.
        ; To write to the VGA planes byte by byte, the image has to be reversed
        ; to big-endian for the purpose of quick drawing since the VGA can only
        ; read and write one byte from/to its latches.

        mov     di,bx                   ; point to the top of the buffer again
        mov     si,bp                   ; point to the new pointer image

	mov	cx,32
norept1:
        lodsw                           ; read in the required image word
        xchg    al,ah                   ; convert little endian to big endian
        stosw                           ; write into local buffer
        inc     di                      ; remember local buffer in 3 bytes wide
	dec	cx
	jnz	norept1

        ; Now, the aligned mask must be rotated, then copied into each of
        ; the seven unaligned image buffers.

        mov     ax,cs
        mov     ds,ax                   ; return to the default data segment

        mov     bp,1000000000000000b    ; a mask for the MSBit

        lea     di,AlignData1           ; point to the buffer for 1 bit offset
        mov     si,bx                   ; source = byte aligned pointer image

	push	bx
	mov	bx,32*7
norept2:
        lodsw                           ; load the word from 3 byte sequence
        xchg    al,ah                   ; put into little-endian format
        mov     cl,byte ptr [si]        ; load the remaining byte
        shr     ax,1                    ; LSB now stored in CF
        rcr     cl,1                    ; CF into MSB, lsb into CF
        jnc     $+4                     ; CF=0 -> don't need to do anything
        or      ax,bp                   ; OR in the carried bit from CF
        xchg    al,ah                   ; return to bitstream format
        stosw                           ; write the rotated data
        mov     byte ptr[di],cl
        inc     si                      ; point to the next source scanline
        inc     di                      ; point to the next dest scanline

	dec	bx
	jnz	norept2
	pop	bx

        ; Just to do a little bit more work, the rotated buffers created
        ; above must be copied to the instances for byte 78 and byte 79
        ; of the scanline. These images are then cunningly clipped in the
        ; process to the edge of the screen!

        mov     si,bx                   ; BX points to the top of current buffer
                                        ; Note DI points to clip_cursor78 now

        ; may as well use the nice string functions now that I don't
        ; have to XCHG bytes. (how space and cycle efficient

        xor     al,al                   ; constant for putting in masks

        ; there are 8 instances for bits 0 to 7

	mov	bx,8
norept3:

        ; Do the AND mask modifications for byte 78

        not     al                      ; AL = 11111111b
        REPT    16                      ; 16 scanlines
        movsw                           ; copy contents of AND word
        stosb                           ; Nice clear AND mask = 11111111b
        inc     si                      ; point to the first image byte in
                                        ; the next scanline
        ENDM

        ; Do the XOR mask modifications for byte 78

        not     al                      ; AL = 00000000b
        REPT    16                      ; 16 scanlines
        movsw                           ; copy contents of XOR word
        stosb                           ; Nice clear XOR mask = 00000000b
        inc     si                      ; point to the first image byte in
                                        ; the next scanline
        ENDM

	dec	bx
	jnz	norept3

        ; prepare the BYTE 79 instances
        ; SI and DI should be in the right place

        xor     ax,ax                   ; constant for putting in masks
        mov     bx,2                    ; constant for addressing source

        ; there are 8 instances for bits 0 to 7

	mov	cx,8
norept4:

        ; Do the AND mask modifications for byte 79

        not     ax                      ; AX = 0ffffh
        REPT    16                      ; 16 scanlines
        movsb                           ; copy contents of AND byte
        stosw                           ; Nice clear AND mask (=0ffffh)
        add     si,bx                   ; point to the first image byte in
                                        ; the next scanline
        ENDM

        ; Do the XOR mask modifications for byte 79

        not     ax                      ; AX = 0h
        REPT    16                      ; 16 scanlines
        movsb                           ; copy contents of XOR byte
        stosw                           ; Nice clear XOR mask
        add     si,bx                   ; point to the first image byte in
                                        ; the next scanline
        ENDM

	dec	cx
	jz	norept4quit
	jmp	norept4
norept4quit:
	
        popa
        pop     es
        pop     ds

        ret
copy_pointer_to_current endp

;========================================================================
;   Procedure to determine the segment of the video buffer for
;   the current display mode.
;========================================================================

assume ds:SpcMseSeg

getvideobuffer  proc    near

        push    ax
        push    si

        ; determine the current video mode from the BIOS and save it.
        ; Use this value to determine the video buffer segment address.

        mov     ah,0fh                  ; use the bios to get the video mode
        int     10h
        cbw                             ; create a table index
        shl     ax,1                    ; word sized table entries
        mov     si,ax
        mov     ax,[videomodetable+si]  ; use video mode to index the table
        mov     [videobufferseg],ax


        pop     si
        pop     ax
        ret

getvideobuffer  endp

IFDEF DEBUGMOUSE

;=========================================================================
; Code to provide 32 bit side with a dump of the VGA registers on request.
;=========================================================================

VGAregs db      9+5+25 dup(?)           ; enough room for sequencer, GC and CTRC

dumpVGAregs     proc    near

        call    DOCLI
        pusha
        push    ds


        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg

        ; Save the Graphics Controller registers

        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register
        xor     ax,ax

        mov	cx,9            ; save 9 G.C. registers
norept5:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; Sequencer index register
	dec	cx
	jnz	norept5

        ; Save the Sequencer registers

        mov     dx,03c4h        ; Sequencer index register
        xor     ax,ax

        mov	cx,5            ; save 5 sequencer registers
norept6:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; Sequencer index register
	dec	cx
	jnz	norept6

        ; Save the CRTC registers

        mov     dx,03d4h        ; CRTC index register
        xor     ax,ax

        mov	cx,25              ; save 25 sequencer registers
norept7:
        mov     al,ah
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [VGAregs+bx],al ; Save the register
        inc     bx              ; index to next array entry
        inc     ah
        dec     dx              ; CRTC index register
	dec	cx
	jnz	norept7

        pop     ds
        popa
        call    DOSTI
        bop     0feh                    ; return to 32 bit land

dumpVGAregs     endp

ENDIF   ; DEBUGMOUSE


;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
; End of Mouse driver general support functions
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

;========================================================================
;   Procedure to draw an EGA pointer image on the graphics screen at a
;   specified bit location.
;
;   Input:      CX = pointer offset in the current VRAM byte.
;               DX = offset in the video buffer to pointer
;   Output:     None
;   Modifies:   AX,BX,CX,DX,BP,SI,DI
;========================================================================

        assume  ds:SpcMseSeg
.286
even

drawEGApointer  proc    near

        push    es
        push    ds

        mov     ax,cs
        mov     ds,ax

        cld                 ; index from low memory to high for LODSB

        ; point to the video buffer

        mov     ax,0a000h
        mov     es,ax
        mov     bp,dx       ; save the byte offset in VRAM for the XOR code

        ; Select the Graphics Controller

        mov     dx,03ceh

        ;************ AND MASK OPERATION **************************

        ; use the bit position to select the relavent pointer image

        shl     cx,1        ; need a word offset into LUT
        mov     di,cx       ; need an index register
        mov     bx,[PointerLUT]
        mov     si,[bx+di]  ; Point to the screen (AND) mask
        mov     di,bp       ; point to the byte offset in VRAM
        mov     ax,0803h    ; Index the data rotate register and select AND
        out     dx,ax       ; do it
        mov     ax,80-2     ; Avoid modRM loading of CX
        mov     cx,ax       ; A constant handily kept in a register

                            ; The pointer contains 16 words of information
	push	bx
	mov	bx,16
norept8:

        lodsw               ; Load 2 bytes from the AND mask into AL and AH
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        xchg    ah,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        lodsb               ; Load a byte from the AND mask into AL
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        add     di,cx       ; point to the next byte in VRAM on the next scan
                            ; line to write to. CX contains 80-2

	dec	bx
	jnz	norept8
	pop	bx

        ;************ XOR MASK OPERATION **************************

        ; Note: SI points to current_cursor+48 now, automatically
        ; i.e. at the start of the XOR mask.

        mov     di,bp       ; point to the byte offset in VRAM
        mov     ax,1803h    ; Index the DATA ROTATE REGISTER and
                            ; Select the XOR function to XOR CPU data in
        out     dx,ax       ; Do the deed

	push	bx
	mov	bx,16
norept9:

        lodsw               ; Load 2 bytes from the AND mask into AL and AH
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        xchg    ah,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        inc     di          ; point to the next byte in VRAM

        lodsb               ; Load a byte from the XOR mask into AL
        xchg    al,es:[di]  ; Latch the 8 pixels for updating.
                            ; and write them back out with new data
        add     di,cx       ; point to the next byte in VRAM on the next scan
                            ; line to write to. CX contains 80-2
	dec	bx
	jnz	norept9
	pop	bx

        pop     ds
        pop     es
        ret

drawEGApointer  endp

;========================================================================
; Procedure to determine what the byte and bit offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine. A flag is set,
; also, to relay whether or not the cursor bitmap is byte aligned or not.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  : DX    = byte offset to top left hand pointer pixel
;        CX    = bit offset in the byte
;	 CF    = set if it is not possible to draw the pointer on the
;                screen because of the hotspot adjustment. (Usually a
;		 negative hotspot value will cause clipping and wrapping
;		 problems at the right and bottom screen boundaries.
;========================================================================

determineboundary       proc    near

        push    ax
        push    bx
	push	es


        ; do the adjustment in x,y for pointer hotspot
        ; Also test for top or left screen boundary problems
	; and zero the coordinate if it goes negative.

	
        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_x     ; if x goes negative, assume zero
        xor     cx,cx
dont_zero_x:
        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_y     ; if y goes negative, assume zero
        xor     dx,dx
dont_zero_y:

	; Now check the right and bottom bounds to prevent the pointer
	; image wrapping if the hotspot adjustment forces either of
	; the coordinates to exceed the screen bounds.
 	; First, for all video modes that this function handles, the
	; X bound is always x < 640 ... check this first.

	cmp	cx,640
	jl	didntexceedX
	stc			; Oh oh - failed, so set carry flag.
	jmp	short quitdet	; bye bye.

didntexceedX:

	; Now check out the y value by finding the maximum extent from
	; a lut based on the current BIOS video mode.

	mov	ax,40h		; B.D.A. segment
	mov	es,ax		; and ES points to it.
	mov	al,byte ptr es:[49h]
	sub	al,0fh		; table is normalized. mode f is in entry
				; zero.
	xor	ah,ah		; create a look up table index
	shl	ax,1		; for a table with word sized elements.
	xchg	bx,ax		; use a suitable register as index

	cmp	dx,[hiresylut+bx]	; get the extent and compare y coord.
	jl	didntexceedY
	stc			; Oh oh - failed, so set carry flag.
	jmp	short quitdet	; bye bye.

didntexceedY:

        ; determine the byte offset from the start of the video buffer
        ; for the modified coordinates. First calculate how many bytes
        ; there are for the number of scanlines -1 to where the pointer
        ; is.

        mov     ax,dx           ; copy Y position into AX
	shl     ax,1            ; create a word table index
	xchg    ax,bx           ; copy table index into a base register
	mov     dx,[mult80lut+bx]       ; do a fast LUT multiply by 80

        ; determine the byte position of the pixel in question

        mov     ax,cx           ; save the x-coordinate displacement
        and     ax,7            ; do a modulus 8 to find the pixel position
                                ; in the byte. The bit number is in DX.

        ; add the whole number of bytes in the current row to the number
        ; of complete-row bytes

        shr     cx,3            ; divide pixels by 8 to get bytes
        add     dx,cx           ; DX hold the complete byte offset.
        xchg    ax,cx           ; CX = bit offset in the byte.

	; the pointer has not exceeded the screen buonds, so clear
	; the carry flag to signify this.

	clc

	; Wind up the routine and return with the carry flag:
	; SET if cursor exceeded screen bounds.
	; CLEAR otherwise.
quitdet:

	pop	es
        pop     bx
        pop     ax
        ret

determineboundary       endp

;========================================================================
; Procedure to buffer up the data over which the cursor will next be
; drawn. This data will be used to replace the cursor at a later point
; when the cursor position has changed and for generating a cursor image
; To prevent having separate routines for aligned and unaligned pointer
; saves, this routine saves a pixel block 24 x 16 deep in all cases. The
; start offset is a byte location into VRAM in which the pointer TLHC lives.
;
; Input:        DX = VRAM byte
; Modifies:     AX,BX,DI,CX,DX,ES
;
;========================================================================

assume ds:SpcMseSeg

even

save_background proc    near

        push    ds
        push    es
        pusha

        mov     ax,cs           ; point DS briefly at the driver data
        mov     ds,ax
        mov     es,ax           ; point ES to the driver segment

        lea     di,behindcursor ; DESTINATION: a nice, safe place in the
                                ; driver segment
        mov     ax,0a000h       ; point DS at VRAM
        mov     ds,ax

        assume  ds:nothing

        mov     bp,dx           ; save DX=VRAM byte offset for later use
        mov     dx,03ceh        ; VGA GC index register
        mov     al,4            ; select the read map select reg
        out     dx,al           ; Index in the map select register
        inc     dx              ; DX holds port address to map select register
        xor     al,al           ; plane 0 will be selected first

        cld                     ; make sure to address forward in memory
        mov     ah,3            ; number of bytes to copy per pointer scanline
        xor     cx,cx           ; counter for the REP MOVSB
        mov     bx,80-3         ; another handy constant: move to next scanline
                                ; byte.

        REPT    4               ; read the 4 EGA planes individually

        mov     si,bp           ; SOURCE: somewhere in VRAM
        out     dx,al           ; do the plane selection
        inc     al              ; select the next plane to latch

        ; note that only one byte at a time may be read from the latches

                                ; do 16 scanlines for each plane
	push	dx
	mov	dx,16
@@:
        mov     cl,ah           ; CX now contains 3
        rep     movsb           ; copy 3 bytes from VRAM to data segment
        add     si,bx           ; move down to the first byte in next scanline
	dec	dx
	jnz	@B		; norept10
	pop	dx

        ENDM

        popa
        pop     es
        pop     ds

        ret

save_background endp

;========================================================================
;   Procedure to restore the area of the screen that was behind the cursor
;   before it had moved.
;
;   Note. Currently (2/12/92) this is the only routine that modifies the
;   VGA sequencer. Therefore, the code from save and restore vga registers
;   that maintain the sequencer registers has been moved to here for
;   centralisation purposes.
;
;   Input:      DX = VRAM byte
;   Output:     None
;   Modifies:   AX,BX,CX,DX,DI,SI
;========================================================================
assume  ds:SpcMseSeg

even

restore_background      proc    near
        push    ds
        push    es
        pusha

;;	call	 DOCLI		 ; turn off interrupts
        mov     ax,cs
        mov     ds,ax           ; point at the driver data segment
        mov     ax,0a000h       ; videobufferseg
        mov     es,ax           ; point ES at VRAM segment
        mov     bp,dx           ; save the pointer for later
        mov     si,offset behindcursor ; SOURCE: point at the stored planes

        ; set up the Graphic Controller for the restore.

        mov     dx,03ceh        ; VGA GC index register
        mov     ax,0003h        ; Select copy into latches function
        out     dx,ax           ; i.e. data rotate -> replace
        mov     ax,0ff08h       ; bitmask register reset
        out     dx,ax

        ; do the 4 plane restore.

        mov     cx,80-2         ; point to the first byte in image on next line
        cld                     ; write forward in memory
        mov     bx,0102h        ; BH = initial plane mask value
                                ; plane 0 is selected with a 1
                                ; BL = map mask register offset
        mov     dx,03c4h        ; index register for sequencer

        mov     al,bl           ; point to the map mask register in sequencer
        out     dx,al           ; index the register into 03c5h
        inc     dx              ; point to the data register
        in      al,dx           ; read the data register value in
        dec     dx              ; restore DX to 03c4h
        mov     [seqregs],al    ; save the map mask register value

        REPT    4               ; 4 planes to restore

        mov     di,bp           ; DESTINATION: pointer into VRAM
        mov     ax,bx           ; select the plane to mask and map mask register
        out     dx,ax           ; do the mask
        shl     bh,1            ; point to the mask for the next iteration

	push	dx
	mov	dx,16
@@:

        lodsw                   ; load the old background data (ONE WORD)
        xchg    al,es:[di]      ; latch the VRAM data and swap with the
        inc     di              ; point to next byte to replace
        xchg    ah,es:[di]      ; latch the VRAM data and swap with the
        inc     di              ; point to next byte to replace
        lodsb                   ; load the old background data (ONE BYTE)
        xchg    al,es:[di]      ; latch the VRAM data and swap with the
        add     di,cx           ; point to the first byte in image on next line

	dec	dx
	jnz	@B		; norept11
	pop	dx

        ENDM

        mov     ah,[seqregs]    ; the old map mask value
        mov     al,bl           ; need to restore the map mask register
        out     dx,ax           ; do the restore
;;	call	 DOSTI		 ; reenable interrupts.
        popa
        pop     es
        pop     ds
        ret
restore_background      endp


;==========================================================================
;   Procedure to save the register state of the VGA card on receiving a
;   mouse pointer update interrupt. This procedure also sets up the following
;   VGA registers to nice values for the driver.
;
;   mode register               <write mode 0, read mode 0>
;   data rotate register        <do not rotate, no logical ops>
;   enable set/reset register   <disable set/reset>
;
;==========================================================================

even
assume ds:SpcMseSeg

saveVGAregisters        proc    near

        push    dx
        push    di
        push    es

        ; Save the Graphics Controller registers that the
        ; Driver uses

        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register
        xor     al,al

	push	cx
        mov	cx,9            ; save 9 G.C. registers
norept12:
        out     dx,al           ; Select it
        inc     dx              ; Address the register
        in      al,dx           ; Get the register contents
        mov     [GCregs+bx],al  ; Save the register
        inc     bx              ; index to next array entry
        mov     al,bl
        dec     dx              ; G.C. index register
	dec	cx
	jnz	norept12
	pop	cx

        ; save the latches to location in a bit of video buffer
        ; off the screen.

        mov     ax,0a000h       ; point to the video buffer
        mov     es,ax

        assume  es:nothing

        mov     ax,0105h        ; select write mode 1 to squirt latches out
        out     dx,ax           ; do the selection
        mov     di,[latchcache] ; 1 byte over the last location
        mov     es:[di],al      ; write the latches out to the planes

        ; disable the enable set/reset register

        mov     ax,01h          ; select enable set/reset register and clear it
        out     dx,ax

        ; clear the data rotate register (no logical operations).

        inc     ax
        inc     ax              ; select data rotate register and clear it
        out     dx,ax           ; AX = 3 therefore points to the DRR

        ; set write mode 0 for the graphics display
        ; conveniently, this also sets read mode to 0 which is needed too!

        inc     ax
        inc     ax              ; select write mode 0
        out     dx,ax           ; AX = 5, i.e. the mode register

	; color don't care. don't care for all planes
	inc	ax		;register 7, color don't care
	inc	ax
	out	dx, ax
	; bit mask register. enable all planes
	;
	inc	ax		;register 8, bit mask
	not	ah
	out	dx, ax
        pop     es
        pop     di
        pop     dx
        ret

saveVGAregisters        endp

;==========================================================================
;   Procedure to restore the register state of the VGA card after dealing
;   with mouse pointer update interrupt.
;==========================================================================

restoreVGAregisters     proc    near

        assume  ds:SpcMseSeg

        push    es
        push    di
        push    bx

        ; restore the latches that where saved in the video planes

        mov     ax,0a000h       ; point to the video buffer
        mov     es,ax

        assume  es:nothing

        mov     di,[latchcache] ; the byte just off the end of the buffer
        mov     al,es:[di]      ; read in the latches

        ; Restore the Graphics Controller registers that the
        ; Driver uses

        xor     ax,ax           ; create an index
        xor     bx,bx           ; Index into the G.C. register saving array
        mov     dx,03ceh        ; Graphics Controller index register

norept13:
        mov     ah,[GCregs+bx]  ; restore the register
        out     dx,ax           ; Select it
        inc     al              ; index for the next register
        inc     bx              ; index to next array entry
	cmp	al,9
	jne	norept13

        pop     bx
        pop     di
        pop     es
        ret

restoreVGAregisters     endp

;=======================================================================
;   Procedure to draw a BIOS Mode 4 graphics pointer to the display.
;   Input:    DX = byte offset
;	      CL = bit offset in the byte
;	      CH = 0FFh if ODD, 0 if EVEN
;	      BP = Y loop counter, ODD in LSB, EVEN in MSB
;=======================================================================
drawmode4pointer        proc    near

        pusha
        push    es
        cld

	xchg	dx, bp			;
	mov	di, bp			; bp = di = byte offset, dx = y counters
        mov     ax,0b800h               ; point a segment register to
        mov     es,ax                   ; the CGA video buffer.
	or	ch, ch			;
	je	drawonevenscanline	;
        jmp     drawonoddscanline       ; otherwise do an ODD job

; ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN ANDEVEN

drawonevenscanline:

        mov     si,[mode4SelectedPointer]
        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

	xor	cx, cx
	mov	cl, dh			; number of even scanlines to draw
	push	dx
evensl1:
	mov	dx,3
norept14:
        lodsb                           ; load 8 pixels from pointer bitmap
        xor     bh,bh                   ; want a zero extended 16 bit value
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah                   ; little-endianise
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept14

        add     si,3
        add     di,80-6
        loop    evensl1
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     si,3
        mov     di,bp
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer
        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl1:
	mov	dx,3
norept15:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept15

        add     si,3
        add     di,80-6
        loop    oddsl1
	pop	dx

; XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN XOREVEN


        mov     si,[mode4SelectedPointer]
        add     si,48

        mov     di,bp                   ; offset into video buffer

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        mov     cl,dh                   ; number of even scanlines to draw
	push	dx
evensl2:
	mov	dx,3
norept16:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept16

        add     si,3
        add     di,80-6
        loop    evensl2
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     si,48+3
        mov     di,bp
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer
        mov     cl,dl                   ; number of odd scanlines to draw
oddsl2:
	mov	dx,3
norept17:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept17

        add     si,3
        add     di,80-6
        loop    oddsl2
        pop     es
        popa
        ret


; ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD ANDODD
;
;       This part of the code draws the pointer on an odd numbered scanline
;       of the video display. Since the video buffer is split, 0000 to 1fff
;       containing even scanlines and 2000 to 3fff containing odd, the data
;       must be manipulated in a subtly different fashion than that of the
;       even display scanline code.
;       The even scanline code display arrangement falls through naturally,
;       with an even scanline drawing thus:
;                                               buffer 0: scanline 0
;                                               buffer 1: scanline 0
;                                               buffer 0: scanline 1
;                                               buffer 1: scanline 1
;                                               buffer 0: scanline 2
;                                               buffer 1: scanline 2 etc.
;       whereas in the odd case:
;                                               buffer 1: scanline 0
;                                               buffer 0: scanline 0
;                                               buffer 1: scanline 1
;                                               buffer 0: scanline 1
;                                               buffer 1: scanline 2
;                                               buffer 0: scanline 2 etc.
;       and this requires that the odd image scanlines must be placed
;       one scanline lower in the even buffer than the even image scanlines
;       do in the odd buffer

drawonoddscanline:


        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     si,[mode4SelectedPointer]
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer

        xor     cx,cx
        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl3:
	mov	dx,3
norept18:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept18

        add     si,3
        add     di,80-6
        loop    oddsl3
	pop	dx


        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        and     dh,dh
        jz      dontdothis1             ; can't do the loop 0 times

        mov     si,[mode4SelectedPointer]
        add     si,3
        mov     di,bp
        add     di,6                    ; This is required to align the
                                        ; even and odd scanlines together
        mov     cl,dh                   ; number of even scanlines to draw
	push	dx
evensl3:
        add     di,80-6                 ; remember even BELOW odd
	mov	dx,3
norept19:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        and     ax,bx                   ; AND the AND mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept19
        add     si,3
        loop    evensl3
	pop	dx

dontdothis1:

; XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD XORODD


        mov     si,[mode4SelectedPointer]
        add     si,48
        mov     di,bp                   ; offset into video buffer
        add     di,02000h               ; offset into video buffer
                                        ; the video buffer

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for odd scanlines

        mov     cl,dl                   ; number of odd scanlines to draw
	push	dx
oddsl4:
	mov	dx,3
norept20:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept20
        add     si,3
        add     di,80-6
        loop    oddsl4
	pop	dx

        ; Load a word of the pointer image, convert it to two bits per
        ; pixel and write to the screen for even scanlines

        and     dh,dh                   ; can't do a loop 0 times
        jz      dontdothis2

        mov     si,[mode4SelectedPointer]
        add     si,48+3
        mov     di,bp
        add     di,6

        mov     cl,dh                   ; number of even scanlines to draw
	
evensl4:
        add     di,80-6
	mov	dx,3
norept21:
        lodsb                           ; load 8 pixels from bitmap
        xor     bh,bh
        mov     bl,al                   ; copy into a base register
        shl     bx,1                    ; create a word address
        mov     ax,[LUT1to2bit+bx]      ; get the byte to word conversion
        xchg    al,ah
        mov     bx,es:[di]              ; get the current displayed 8 pixels
        xor     ax,bx                   ; XOR the XOR mask in
        stosw                           ; write to the video buffer
	dec	dx
	jnz	norept21

        add     si,3
        loop    evensl4

dontdothis2:

; XORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXORXOR

        pop     es
        popa
        ret
drawmode4pointer        endp

;========================================================================
; Procedure to determine what the byte and bit offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine.
; Y looping counter(ODD and EVEN) are also returned
; The CGA buffer is interleaved, and runs from B800:0000 to B800:1999 for
; odd scanlines and from B800:2000 for even scanlines.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  :
;	 carry set if either X or Y is out of screen
;	 DX	= byte offset to top left hand pointer pixel of the pointer
;	 CL	= bit offset in the byte
;	 CH	= 0FFh if ODD, 0 if EVEN
;	 BP	= Y loop counter(ODD in LSB and EVEN in MSB)
;========================================================================

detboundmode4   proc    near

	push	ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg


        ; do the adjustment in x,y for pointer hotspot
        ; modify the raw X,Y values for hotspot

        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_xmode4; if x goes negative, assume zero
        xor     cx,cx

dont_zero_xmode4:

        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_ymode4; if y goes negative, assume zero
        xor     dx,dx

dont_zero_ymode4:

	cmp	cx, 320 		;
	jae	detboundmode4_exit	; CY is cleared
	cmp	dx, 200
	jae	detboundmode4_exit	; CY is cleared
        ; determine the byte offset from the start of the video buffer
        ; for the modified coordinates. First calculate how many bytes
        ; there are for the number of scanlines -1 to where the pointer
        ; is. Also if the pointer starts on a odd scanline, set CF, else
        ; clear CF.

        mov     ax,dx           ; copy Y position into AX
        mov     bp,dx           ; copy Y position into BP for use later

        ; CGA video buffer is split in two. Therefore, screen scanline 0 maps
        ; to video buffer scanline 0 and screen scanline 1 maps to video
        ; buffer+2000h, scanline 0

        and     ax,0fffeh       ; do the mapping 0->0, 1->0, 2->1, 3->1 etc.
                                ; and create a word table index
	mov	bx, ax		; copy table index into a base register
				; 2bits/pixel -> 4 pixels/byte
				; sine x total is 320, we have 80bytes
				; so a shl bx, 1 will be wrong.
	mov     dx,[mult80lut+bx]       ; do a fast LUT multiply by 80

        ; determine the byte position of the pixel in question

        mov     ax,cx           ; save the x-coordinate displacement
        and     ax,3            ; do a modulus 4 to find the pixel position
                                ; in the byte. The byte number will be in DX.

        ; add the whole number of bytes in the current row to the number
        ; of complete-row bytes. Note that mode 4 is 2bits per pixel, so
        ; there are four pixels represented by one byte.

        mov     bx,cx           ; Save in a base reg. to create a table index
        shl     bx,1            ; Create a table index for word sized entries
        add     dx,[mode4clipCXadjustLUT+bx]; DX hold the complete byte offset.
	mov	cx, ax		; CX = bit offset in the byte.

	mov	ax, [mode4pointerLUT + bx]  ; select appropriate pointer
	mov	[mode4SelectedPointer], ax

        ; Odd or Even scanline? note BP contains y cartesian coordinate

	mov	bx, bp		; y coordinate
	shr	bp, 1		; shift right to determine if odd or even
				; CF if odd, or 0 if even.
	sbb	ch, ch		; CH = 0FFh if ODD, 0 if EVEN
	shl	bx, 1
	mov	bp, [mode4clipDXLUT + bx] ;the Y counters
	stc			; we are fine, set the CY so we will return
				; CY cleared.
detboundmode4_exit:
	cmc				; revese the CY
        pop     ds
        pop     bx
	pop	ax
        ret

detboundmode4   endp



;=============================================================================
;   Procedure to save the area of CGA video buffer into which the pointer will
;   be drawn. The memory buffer in which this data is stored is arranged odd
;   scanlines first, then even. So, the first 48 bytes are the odd scanline
;   data.
;
;   Input:    DX = byte offset
;	      CL = bit offset in the byte
;	      CH = 0FFh if ODD, 0 if EVEN
;	      BP = Y loop counter, ODD in LSB, EVEN in MSB
;
;=============================================================================

savebkgrndmode4 proc    near

        pusha
        push    es
        push    ds

        ; set up the segment registers as required

        mov     ax,ds
        mov     es,ax
        mov     ax,0b800h
        mov     ds,ax
        assume  ds:nothing, es:SpcMseSeg
        mov     si,dx                   ; start the save.
	or	ch, ch
	je	svbkeven		 ; check the returned carry flag

        ; the image's first scanline is odd

        mov     di,offset CGAbackgrnd   ; where the background will be saved
        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; don't want unwanted mess in MSB
        add     si,2000h                ; odd part of buffer starts at 2000h
svodd1:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the image scanline save
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     svodd1                  ; do more scanlines if necessary

        ; save some even scanlines if need be.

        mov     si,dx                   ; offset into CGA buffer
	add	si, 80
        mov     bx,bp                   ; set up the loop counter
        xchg    bl,bh                   ; get the even part of loop counter
        xor     bh,bh                   ; trash the top end trash
        and     bx,bx                   ; check for a zero loop
        jz      misseven                ; can't have a loop which execs 0 times
        mov     di,offset CGAbackgrnd+48; where the background will be saved
sveven1:
        mov     cx,3                    ; copy six bytes = 24 pixels
        rep     movsw                   ; do the scanline save
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     sveven1                 ; do more scanlines if necessary

misseven:       ; jump to here if there are no even scanlines to draw

        jmp     short endsavemode4

svbkeven: ; the image's first scanline is even

        mov     di,offset CGAbackgrnd+48; where the background will be saved

        mov     bx,bp                   ; get the loop counter
        xchg    bl,bh                   ; rearrage to get the even part
        xor     bh,bh                   ; clear out the trash
sveven2:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the copy
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     sveven2                 ; do more scanlines if necessary

        mov     si,dx                   ; offset into CGA buffer
        add     si,2000h                ; odd part of the video buffer
        mov     di,offset CGAbackgrnd   ; where to save the odd scanlines
        mov     bx,bp                   ; get the loop counter
        xor     bh,bh                   ; clear out the unwanted trash
svodd2:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the copy
        add     si,80-6                 ; point to the next scanline
        dec     bx                      ; decrement the loop counter
        jnz     svodd2                  ; do more scanlines if necessary

endsavemode4:
        assume  ds:SpcMseSeg, es:nothing

        pop     ds
        pop     es
        popa
        ret
savebkgrndmode4 endp

;=============================================================================
;   Procedure to restore the area of CGA video buffer into which the pointer
;   was drawn. The memory buffer in which this data is stored is arranged
;   odd scanlines first, then even. So, the first 48 bytes are the odd scanline
;   data.
;
;   Input:
;	 DX	= byte offset to top left hand pointer pixel of the pointer
;	 CL	= bit offset in the byte
;	 CH	= 0FFh if ODD, 0 if EVEN
;	 BP	= Y loop counter(ODD in LSB and EVEN in MSB)
;
;=============================================================================

restorebkgrndmode4      proc    near

        pusha
        push    es

        ; set up the segment registers as required

        mov     ax,0b800h
        mov     es,ax
        mov     di,dx                   ; restore background
	or	ch, ch
	je	rsbkeven		 ; check the returned carry flag

        ; the image's first scanline is odd. The CGA buffer is translated
        ; so that a scanline (row N) from the even part of the buffer appears
        ; on the screen at raster I. The scanline at position N from the
        ; odd part of the video buffer maps to screen position I+1. If the
        ; 1st. scanline is odd, then this is drawn at raster A and the
        ; following algorithm draws the 1st. even row at raster A+1 to
        ; compensate for the video buffer arrangement.

        mov     si,offset CGAbackgrnd   ; where the background is be saved
        add     di,2000h                ; do the odd buffer

        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; clear out the MSB trash
rsodd1:
        mov     cx,3                    ; copy six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next odd scanline
        dec     bx                      ; decrement the loop counter
        jnz     rsodd1                  ; restore more even scanlines if needed

        mov     bx,bp                   ; let the loop counter
        xchg    bl,bh                   ; get the even part
        xor     bh,bh                   ; clear out the MSB trash
        and     bx,bx                   ; test for zero even scanlines
        jz      misseven1rs             ; can't have a zero execute loop
        mov     di,dx                   ; offset into CGA buffer
        add     di,80                   ; get the odd/even scanlines instep
        mov     si,offset CGAbackgrnd+48; where the background is be saved
rseven1:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next even scanline
        dec     bx                      ; decrement the loop counter
        jnz     rseven1                 ; restore more even scanlines if needed

misseven1rs:    ; jump to here if there are no even scanlines to be restored.

        jmp     short endrestoremode4

rsbkeven: ; the image's first scanline is even

        mov     si,offset CGAbackgrnd+48; where the background will be saved

        mov     bx,bp                   ; get the loop counter
        xchg    bl,bh                   ; get the even part of the loop counter
        xor     bh,bh                   ; scrap the MSB trash
rseven2:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next even scanline
        dec     bx                      ; decrement the loop counter
        jnz     rseven2                 ; do more even scanlines if needed

        mov     di,dx                   ; offset into CGA buffer
        add     di,2000h                ; do the odd buffer
        mov     si,offset CGAbackgrnd   ; where to save the odd scanlines

        mov     bx,bp                   ; set the loop counter up
        xor     bh,bh                   ; scrap the MSB trash
rsodd2:
        mov     cx,3                    ; restore six bytes
        rep     movsw                   ; do the restore
        add     di,80-6                 ; point to the next  odd scanline
        dec     bx                      ; decrement the loop counter
        jnz     rsodd2                  ; restore more odd scanlines if needed

endrestoremode4:
        assume  ds:SpcMseSeg, es:nothing

        pop     es
        popa
        ret
restorebkgrndmode4      endp

;============================================================================
;   Procedure to draw the pointer image into the video buffer for mode 13h
;   VGA graphics.
;
;   Input:
;	   DX = byte offset
;	   BP = Y loop counter
;	   CX = X loop counter
;
;============================================================================

draw256pointer  proc    near
        pusha
        push    es
        push    ds

        mov     ax,0a000h       ; point to the 256 colour mode video buffer
        mov     es,ax
        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg, es:nothing

        cld                     ; write forward through the buffer
	; DX = TLHC pixel offset in the video buffer.
        mov     di,dx           ; point DI at the video buffer location of fun
	mov	si, offset current_cursor   ; we only use this cursor shape
					    ; because every pixel is on byte
					    ; boundary. The X counter would
					    ; take care of X clipping
y_256:
	push	cx
	lodsw			    ;and mask
	mov	dx, [si + 48 - 2]   ;xor mask
	inc	si		    ;we don't need the third byte
	xchg	al, ah		    ; byte sequence
	xchg	dh, dl		    ;
x_256:
	shl	ax, 1		    ;AND mask bit
	sbb	bl, bl		    ; bl = 0FFf if CY, 0 if not CY
	and	bl, es:[di]	    ;and the target and save the result
	shl	dx, 1		    ;XOR mask bit
	sbb	bh, bh		    ;
	xor	bl, bh		    ;xor with the save result
	mov	es:[di], bl	    ;update the target
	inc	di		    ;next pixel
	loop	x_256		    ;until this scan line is done
	pop	cx		    ;recovery X loop counter
	add	di, 320 	    ;target address to next scan line
	sub	di, cx
	dec	bp		    ;Y counter
	jne	y_256

        pop     ds
        pop     es
        popa
        ret
draw256pointer  endp

;=============================================================================
;   Procedure to save the area of 256 colour mode video buffer into which the
;   pointer will be drawn. The memory buffer in which this data is stored is
;   arranged odd scanlines first, then even. So, the first 48 bytes are the odd
;   scanline data.
;
;   Input:
;	    DX = byte offset
;	    BP = Y loop counter
;	    CX = X loop counter
;
;=============================================================================

savebkgrndmode13        proc    near
        pusha
        push    es
        push    ds

        mov     di,offset bkgrnd256     ; point to the area in which backgound
                                        ; data will be saved
        mov     si,dx           ; SOURCE: the video buffer at x,y

        mov     ax,0a000h
        mov     ds,ax
        mov     ax,cs
        mov     es,ax
	mov	bx, cx			;x counter
	mov	dx, 320
	sub	dx, bx
        assume  ds:nothing, es:SpcMseSeg
	cld
save_256_loop:
	mov	cx, bx
	shr	cx, 1
	rep	movsw
	adc	cl, 0
	rep	movsb
	add	si, dx			; next scan line offset
	dec	bp			; until Y counter is done
	jne	save_256_loop

        pop     ds
        pop     es

        assume  es:nothing, ds:SpcMseSeg

        popa
        ret
savebkgrndmode13        endp

;=============================================================================
;   Procedure to replace an existing pointer image in the 256 colour video
;   buffer with the data that was there previous to the pointer draw operation.
;   The data is stored in an internal (to the driver) buffer.
;
;   Input:
;	 DX = byte offset
;	 BP = Y loop counter
;	 CX = X loop counter
;
;=============================================================================

restorebkgrndmode13     proc    near
        pusha
        push    es

        mov     di,dx           ; DESTINATION: in the VRAM
        mov     ax,0a000h       ; point a segment register at video buffer
        mov     es,ax

        assume  es:nothing
	mov	bx, cx
        mov     si,offset bkgrnd256     ; where the data is saved
	mov	dx, 320
	sub	dx, bx

        cld                     ; write forward in memory
restore_256_loop:
	mov	cx, bx
	shr	cx, 1
	rep	movsw
	adc	cl, 0
	rep	movsb
	add	di, dx
	dec	bp
	jne	restore_256_loop

        pop     es
        popa
        ret
restorebkgrndmode13     endp

;========================================================================
; Procedure to determine what the byte offset is, in the current
; VGA buffer for the top left hand corner of the pointer bitmap.
; The X,Y value is modified for hotspot in this routine. X and Y looping
; counters are also returned.
;
; INPUT: CX,DX = pointer x,y coordinates
; OUT  :
;	carry set if either X or Y is out of screen
;	DX	= byte offset to top left hand pointer pixel of the pointer
;	CX	= X counter
;	BP	= Y counter
;========================================================================

detboundmode13  proc    near

        push    ax
        push    bx
        push    ds

        mov     ax,cs
        mov     ds,ax

        assume  ds:SpcMseSeg


        ; do the adjustment in x,y for pointer hotspot
        ; modify the raw X,Y values for hotspot

        sub     cx,[hotspot]    ; adjust the x cartesian coord for hotspot
        jns     dont_zero_xmode13; if x goes negative, assume zero
        xor     cx,cx

dont_zero_xmode13:

        sub     dx,[hotspot+2]  ; adjust the y cartesian coord for the hotspot
        jns     dont_zero_ymode13; if y goes negative, assume zero
        xor     dx,dx

dont_zero_ymode13:
	cmp	cx, 320
	jae	detboundmode13_exit ; CY is cleared
	cmp	dx, 200 	    ;
	jae	detboundmode13_exit ; CY is cleared

        ; CX and DX are now validated for the following section: buffer
        ; offset determination. Note, unlike other video modes, mode 13
        ; provides a direct mapping of the video display to video buffer.
        ; in other words; 1 byte represents 1 pixel. From this, it is not
        ; necessary to provide byte alignment data.

        mov     bx,dx                   ; save in a base register
	shl	bx,1			; create a word table index
        mov     dx,[mult320LUT+bx]      ; do the multiply by 320
        ; add in the offset along the current raster.

        add     dx,cx                   ; cx contains the byte offset from
	mov	ax,[mode4clipDXLUT + bx]; get Y loop counter from table
	add	al, ah			; the table has ODD/EVEN counters
	cbw
	mov	bp, ax			; the final Y counter
					; column 0.
	mov	ax, 320 		; calculate X loop counter
	sub	ax, cx
	cmp	ax, 16			;
	jl	set_new_x_counter
	mov	ax, 16
set_new_x_counter:
	mov	cx, ax			; X counter
	stc				; everything is fine, set CY
					; so we will return CY cleared
detboundmode13_exit:
	cmc				; complement the CY
        pop     ds
        pop     bx
        pop     ax
        ret

detboundmode13  endp


          public SpcMseEnd
SpcMseEnd label  byte

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;   Installation Code From Here Downwards
;
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

; segment:offset table for redirected mouse functions for real rom version.

mio_table       dw      38 dup(?)



        assume  cs:SpcMseSeg,ds:nothing,es:nothing

        public InstSpcMse
;
; InstSpcMse - Installs the softpc mouse driver code
;
; Inputs:  ds == Resident location of SpcMseSeg
; Outputs: None
;
InstSpcMse   proc    near

        ;;;;;;;;;;;;;;;;do ret to use old mouse driver;;; ret

        pusha

        ; save old int 10 vector
        xor     ax,ax
        mov     es,ax
        mov     ax,es:[40h]
        mov     si,offset old_vid_int
        mov     word ptr ds:[si],ax
        mov     ax,es:[42h]
        mov     word ptr ds:[si+2],ax

        mov     bx,ds
        mov     si,offset sysinitgrp:mio_table
        push    ds
        push    cs
        pop     ds

        mov     word ptr ds:[si], offset mouse_io
        mov     word ptr ds:[si+2],bx

IFDEF MOUSE_VIDEO_BIOS

        mov     word ptr ds:[si+4],offset mouse_video_io
        mov     word ptr ds:[si+6],bx

ENDIF ; MOUSE_VIDEO_BIOS

        mov     word ptr ds:[si+8],offset mouse_int1
        mov     word ptr ds:[si+10],bx
        mov     word ptr ds:[si+12], offset mouse_version
        mov     word ptr ds:[si+14],bx
        mov     word ptr ds:[si+16],offset mouse_copyright
        mov     word ptr ds:[si+18],bx
        mov     word ptr ds:[si+20],offset video_io
        mov     word ptr ds:[si+22],bx
        mov     word ptr ds:[si+24],offset mouse_int2
        mov     word ptr ds:[si+26],bx
        mov     word ptr ds:[si+28],offset entry_point_from_32bit
        mov     word ptr ds:[si+30],bx
        mov     word ptr ds:[si+32],offset int33function0
        mov     word ptr ds:[si+34],bx
        mov     word ptr ds:[si+36],offset int33function1
        mov     word ptr ds:[si+38],bx
        mov     word ptr ds:[si+40],offset int33function2
        mov     word ptr ds:[si+42],bx
        mov     word ptr ds:[si+44],offset int33function9
        mov     word ptr ds:[si+46],bx
        mov     word ptr ds:[si+48],offset current_position_x
        mov     word ptr ds:[si+50],bx
        mov     word ptr ds:[si+52],offset current_position_y
        mov     word ptr ds:[si+54],bx
        mov     word ptr ds:[si+56],offset mouseINB
        mov     word ptr ds:[si+58],bx
        mov     word ptr ds:[si+60],offset mouseOUTB
        mov     word ptr ds:[si+62],bx
        mov     word ptr ds:[si+64],offset mouseOUTW
        mov     word ptr ds:[si+66],bx
        mov     word ptr ds:[si+68],offset VRAMlasttextcelloff
        mov     word ptr ds:[si+70],bx
        mov     word ptr ds:[si+72],offset internalCF
        mov     word ptr ds:[si+74],bx
        mov     word ptr ds:[si+76],offset function3data
        mov     word ptr ds:[si+78],bx
	mov	word ptr ds:[si+80],offset conditional_off
	mov	word ptr ds:[si+82],bx
        pop     ds
        mov     bx, offset sysinitgrp:mio_table
        bop     0C8h            ; Host mouse installer BOP

; get the freshly written int 33h vector from IVT
; write the vector segment:offset data to the jump patch

        xor     ax,ax
        mov     es,ax
        mov     ax,es:[33h*4]
        mov     bx,es:[(33h*4)+2]
        mov     si,offset moff
        mov     word ptr ds:[si],ax
        mov     word ptr ds:[si+2],bx
        add     ax,2                          ; HLL entry point
        mov     si,offset loffset
        mov     word ptr ds:[si],ax
        mov     word ptr ds:[si+2],bx

; write the new value to the IVT
        call    DOCLI
        mov     bx, offset int33h_vector
        mov     word ptr es:[33h*4], bx
        mov     bx, ds
        mov     word ptr es:[(33h*4)+2], bx
        call    DOSTI

        popa
        ret
InstSpcMse  endp

SpcMseSeg    ends
             end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\sysimes.asm ===
page	,160
	;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

	include	version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

sysinitseg segment

	public	badopm,crlfm,badsiz_pre,badld_pre,badcom,badcountry
	public	badmem,badblock,badstack
	public	insufmemory,badcountrycom
	public	badorder,errorcmd
	public	badparm
        public  toomanydrivesmsg			;M029

	include msbio.cl3

sysinitseg	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\sysinit2.asm ===
page	,160
title	bios system initialization

;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------


	include version.inc		; set version build flags
	include biosseg.inc		; establish bios segment structure

lf	equ	10
cr	equ	13
tab	equ	9

; the following depends on the positions of the various letters in switchlist

switchnum	equ 11111000b		; which switches require number

	include syscall.inc
	include doscntry.inc
	include devsym.inc
	include ioctl.inc
	include devmark.inc	; needed


stacksw equ	true		;include switchable hardware stacks

	if	ibmjapver
noexec	equ	true
	else
noexec	equ	false
	endif


sysinitseg segment public

assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing

	extrn	badopm:byte,crlfm:byte,badcom:byte,badmem:byte,badblock:byte
	extrn	badsiz_pre:byte,badld_pre:byte

	extrn	dosinfo:dword
	extrn	memory_size:word,fcbs:byte,keep:byte
	extrn	default_drive:byte,confbot:word,alloclim:word
	extrn	buffers:word,zero:byte,sepchr:byte
	extrn	files:byte
	extrn	count:word,chrptr:word
	extrn	bufptr:byte,memlo:word,prmblk:byte,memhi:word
	extrn	ldoff:word,area:word,packet:byte,unitcount:byte,
	extrn	break_addr:dword,bpb_addr:dword,drivenumber:byte
	extrn	com_level:byte, cmmt:byte, cmmt1:byte, cmmt2:byte
	extrn	cmd_indicator:byte
	extrn	donotshownum:byte
	extrn	multdeviceflag:byte
	extrn	devmark_addr:word
	extrn	setdevmarkflag:byte
	extrn	org_count:word

	extrn	pararound:near
	extrn	getchr:near
	extrn	stall:near
	extrn	error_line:near

	extrn	DevEntry:dword

	insert_blank	db	0	; M051: indicates that blank has been
					; M051: inserted 

	public	int24,open_dev,organize,mem_err,newline,calldev,badload
	public	prndev,auxdev,config,commnd,condev,getnum,badfil,prnerr
	public	round,delim,print
	public	parseline,
	public	setdoscountryinfo,set_country_path,move_asciiz
	public	cntry_drv,cntry_root,cntry_path
	public	delim
        public  pathstring

        public  MseDev                  ; NTVDM internal mouse driver



;
;----------------------------------------------------------------------------
;
; procedure : parseline
;
; entry point is parseline. al contains the first character in command line.
;
;----------------------------------------------------------------------------
;

parseline	proc	near
					; don't get character first time
	push	ds

	push	cs
	pop	ds
	assume	ds:sysinitseg

nextswtch:
	cmp	al,cr			; carriage return?
	jz	done_line
	cmp	al,lf			; linefeed?
	jz	put_back		; put it back and done

; anything less or equal to a space is ignored.

	cmp	al,' '                  ; space?
	jbe	get_next		; skip over space
	cmp	al,'/'
	jz	getparm
	stc				; mark error invalid-character-in-input
	jmp	short exitpl

getparm:
	call	check_switch
	mov	word ptr switches,bx	; save switches read so far
	jc	swterr

get_next:
	call	getchr
	jc	done_line
	jmp	nextswtch

swterr:
	jmp	short exitpl		; exit if error

done_line:
	test	word ptr switches,flagdrive  ; see if drive specified
	jnz	okay
	stc				; mark error no-drive-specified
	jmp	short exitpl

okay:
;	mov	ax,word ptr switches
;	and	ax,0003h	    ; get flag bits for changeline and non-rem
;	mov	word ptr deviceparameters.dp_deviceattributes,ax
;	mov	word ptr deviceparameters.dp_tracktableentries, 0
;	clc			    ; everything is fine
;	call	setdeviceparameters
exitpl:
	pop	ds
	ret

put_back:
	inc	count			; one more char to scan
	dec	chrptr			; back up over linefeed
	jmp	short done_line

parseline	endp

;
;----------------------------------------------------------------------------
;
; procedure : check_switch
;
; processes a switch in the input. it ensures that the switch is valid, and
; gets the number, if any required, following the switch. the switch and the
; number *must* be separated by a colon. carry is set if there is any kind of
; error.
;
;----------------------------------------------------------------------------
;

check_switch	proc	near

	call	getchr
	jc	err_check
	and	al,0dfh 	    ; convert it to upper case
	cmp	al,'A'
	jb	err_check
	cmp	al,'Z'
	ja	err_check

	push	es

	push	cs
	pop	es

	mov	cl,byte ptr switchlist	; get number of valid switches
	mov	ch,0
	mov	di,1+offset switchlist	; point to string of valid switches
	repne	scasb

	pop	es
	jnz	err_check

	mov	ax,1
	shl	ax,cl			; set bit to indicate switch
	mov	bx,word ptr switches	; get switches so far
	or	bx,ax			; save this with other switches
	mov	cx,ax
	test	ax, switchnum		; test against switches that require number to follow
	jz	done_swtch

	call	getchr
	jc	err_swtch

	cmp	al,':'
	jnz	err_swtch

	call	getchr
	push	bx			; preserve switches
	mov	byte ptr cs:sepchr,' '	; allow space separators
	call	getnum
	mov	byte ptr cs:sepchr,0
	pop	bx			; restore switches

; because getnum does not consider carriage-return or line-feed as ok, we do
; not check for carry set here. if there is an error, it will be detected
; further on (hopefully).

	call	process_num

done_swtch:
	clc
	ret

err_swtch:
	xor	bx,cx			; remove this switch from the records
err_check:
	stc
	ret

check_switch	endp

;
;----------------------------------------------------------------------------
;
; procedure : process_num
;
; this routine takes the switch just input, and the number following (if any),
; and sets the value in the appropriate variable. if the number input is zero
; then it does nothing - it assumes the default value that is present in the
; variable at the beginning. zero is ok for form factor and drive, however.
;
;----------------------------------------------------------------------------
;

process_num	proc	near
	test	word ptr switches,cx	; if this switch has been done before,
	jnz	done_ret		; ignore this one.
	test	cx,flagdrive
	jz	try_f
	mov	byte ptr drive,al
	jmp	short done_ret

try_f:
	test	cx,flagff
	jz	try_t

; ensure that we do not get bogus form factors that are not supported

;	mov	byte ptr deviceparameters.dp_devicetype,al
	jmp	short done_ret

try_t:
	or	ax,ax
	jz	done_ret		; if number entered was 0, assume default value
	test	cx,flagcyln
	jz	try_s

;	mov	word ptr deviceparameters.dp_cylinders,ax
	jmp	short done_ret

try_s:
	test	cx,flagseclim
	jz	try_h
	mov	word ptr slim,ax
	jmp	short done_ret

; must be for number of heads

try_h:
	mov	word ptr hlim,ax

done_ret:
	clc
	ret

process_num	endp

;
;----------------------------------------------------------------------------
;
; procedure : organize
;
;----------------------------------------------------------------------------
;
		assume ds:nothing, es:nothing
organize	proc	near

	mov	cx,[count]
	jcxz	nochar1
	call	mapcase
	xor	si,si
	mov	di,si
	xor	ax,ax
	mov	com_level, 0

;org1:	 call	 get			 ;skip leading control characters
;	 cmp	 al,' '
;	 jb	 org1
org1:
	call	skip_comment
	jz	end_commd_line		; found a comment string and skipped.
	call	get2			; not a comment string. then get a char.
	cmp	al, lf
	je	end_commd_line		; starts with a blank line.
	cmp	al, ' '
	jbe	org1			; skip leading control characters
	jmp	short findit

end_commd_line:
	stosb				; store line feed char in buffer for the linecount.
	mov	com_level, 0		; reset the command level.
	jmp	org1

nochar1:
	stc
	ret

findit:
	push	cx
	push	si
	push	di
	mov	bp,si
	dec	bp
	mov	si,offset comtab	;prepare to search command table
	mov	ch,0
findcom:
	mov	di,bp
	mov	cl,[si]
	inc	si
	jcxz	nocom
	repe	cmpsb
	lahf
	add	si,cx			;bump to next position without affecting flags
	sahf
	lodsb				;get indicator letter
	jnz	findcom
	cmp	byte ptr es:[di], cr	;the next char might be cr,lf
	je	gotcom0 		; such as in "rem",cr,lf case.
	cmp	byte ptr es:[di], lf
	je	gotcom0
	push	ax
	mov	al, byte ptr es:[di]	;now the next char. should be a delim.
	call	delim
	pop	ax
	jnz	findcom
gotcom0:
	pop	di
	pop	si
	pop	cx
	jmp	short gotcom

nocom:
	pop	di
	pop	si
	pop	cx
	mov	al,'Z'
	stosb				; save indicator char.
skip_line:
	call	get2
	cmp	al, lf			; skip this bad command line
	jne	skip_line
	jmp	end_commd_line		; handle next command line

gotcom: stosb				;save indicator char in buffer
	mov	cmd_indicator, al	; save it for the future use.

org2:	call	get2			;skip the commad name until delimiter
	cmp	al, lf
	je	org21
	cmp	al, cr
	je	org21

	call	delim
	jnz	org2
	jmp	short org3

org21:					;if cr or lf then
	dec	si			; undo si, cx register
	inc	cx			;  and continue

org3:
	cmp	cmd_indicator, 'Y'	; comment= command?
	je	get_cmt_token
	cmp	cmd_indicator, 'I'	; install= command?
	je	org_file
	cmp	cmd_indicator, 'D'	; device= command?
	je	org_file
	cmp	cmd_indicator, 'S'	; shell= is a special one!!!
	je	org_file
	cmp	cmd_indicator, '1'	; switches= command?
	je	org_switch

	jmp	org4

org_switch:
	call	skip_comment
	jz	end_commd_line_brdg

	call	get2
	call	org_delim
	jz	org_switch

	stosb
	jmp	org5

org_file:			; get the filename and put 0 at end,
	call	skip_comment
	jz	org_put_zero

	call	get2		; not a comment
	call	delim
	jz	org_file	; skip the possible delimeters

	stosb			; copy the first non delim char found in buffer

org_copy_file:
	call	skip_comment	; comment char in the filename?
	jz	org_put_zero	; then stop copying filename at that point

	call	get2
	cmp	al, '/' 	; a switch char? (device=filename/xxx)
	je	end_file_slash	; this will be the special case.

	stosb			; save the char. in buffer
	call	delim
	jz	end_copy_file

	cmp	al, ' '
	ja	org_copy_file	; keep copying
	jmp	short end_copy_file ; otherwise, assume end of the filename.

get_cmt_token:			; get the token. just max. 2 char.
	call	get2
	cmp	al, ' ' 	; skip white spaces or "=" char.
	je	get_cmt_token	; (we are allowing the other special
	cmp	al, tab 	;  charaters can used for comment id.
	je	get_cmt_token	;  character.)
	cmp	al, '=' 	; = is special in this case.
	je	get_cmt_token
	cmp	al, cr
	je	get_cmt_end	; cannot accept the carridge return
	cmp	al, lf
	je	get_cmt_end

	mov	cmmt1, al	; store it
	mov	cmmt, 1 	; 1 char. so far.
	call	get2
	cmp	al, ' '
	je	get_cmt_end
	cmp	al, tab
	je	get_cmt_end
	cmp	al, cr
	je	get_cmt_end
	cmp	al, lf
	je	end_commd_line_brdg

	mov	cmmt2, al
	inc	cmmt

get_cmt_end:
	call	get2
	cmp	al, lf
	jne	get_cmt_end		; skip it.

end_commd_line_brdg: jmp end_commd_line ; else jmp to end_commd_line

org_put_zero:				; make the filename in front of
	mov	byte ptr es:[di], 0	;  the comment string to be an asciiz.
	inc	di
	jmp	end_commd_line		;  (maybe null if device=/*)

end_file_slash: 			; al = "/" option char.
	mov	byte ptr es:[di],0	; make a filename an asciiz
	inc	di			; and
	stosb				; store "/" after that.
	jmp	short org5		; continue with the rest of the line

end_copy_file:
	mov	byte ptr es:[di-1], 0	; make it an asciiz and handle the next char.
	cmp	al, lf
	je	end_commd_line_brdg
	jmp	short org5

org4:					; org4 skips all delimiters after the command name except for '/'
	call	skip_comment
	jz	end_commd_line_brdg

	call	get2
	call	org_delim		; skip delimiters except '/' (mrw 4/88)
	jz	org4
	jmp	short org51

org5:					; rest of the line
	call	skip_comment		; comment?
	jz	end_commd_line_brdg
	call	get2			; not a comment.

org51:
	stosb				; copy the character
	cmp	al, '"' 		; a quote ?
	je	at_quote
	cmp	al, ' '
	ja	org5
					; M051 - Start

	cmp	cmd_indicator, 'U'	; Q: is this devicehigh
	jne	not_dh			; N: 
	cmp	al, lf			; Q: is this line feed
	je	org_dhlf		; Y: stuff a blank before the lf
	cmp	al, cr			; Q: is this a cr
	jne	org5			; N: 
	mov	byte ptr es:[di-1], ' '	; overwrite cr with blank
	stosb				; put cr after blank
	inc	[insert_blank]		; indicate that blank has been 
					; inserted
	jmp	org5
not_dh:					; M051 - End

	cmp	al, lf			; line feed?
	je	org1_brdg		; handles the next command line.
	jmp	org5			; handles next char in this line.

org_dhlf:				; M051 - Start
	cmp	[insert_blank], 1	; Q:has a blank already been inserted
	je	org1_brdg		; Y:
	mov	byte ptr es:[di-1], ' '	; overwrite lf with blank
	stosb				; put lf after blank
					; M051 - End

org1_brdg: 
	mov	[insert_blank], 0	; M051: clear blank indicator for 
					; M051: devicehigh
	jmp	org1

at_quote:
	cmp	com_level, 0
	je	up_level
	mov	com_level, 0		; reset it.
	jmp	org5

up_level:
	inc	com_level		; set it.
	jmp	org5

organize	endp

;
;----------------------------------------------------------------------------
;
; procedure : get2
;
;----------------------------------------------------------------------------
;
get2	proc	near
	jcxz	noget
	mov	al,es:[si]
	inc	si
	dec	cx
od_ret:
	ret
noget:
	pop	cx
	mov	count,di
	mov	org_count, di
	xor	si,si
	mov	chrptr,si
ng_ret:
	ret
get2	endp


;
;----------------------------------------------------------------------------
;
; procedure : skip_comment
;
;skip the commented string until lf, if current es:si-> a comment string.
;in) es:si-> sting
;	 cx -> length.
;out) zero flag not set if not found a comment string.
;	  zero flag set if found a comment string and skipped it. al will contain
;	  the line feed charater at this moment when return.
;	  ax register destroyed.
;	  if found, si, cx register adjusted accordingly.
;
;----------------------------------------------------------------------------
;
skip_comment	proc	near

	jcxz	noget		; get out of the organize routine.
	cmp	com_level, 0	; only check it if parameter level is 0.
	jne	no_commt	;  (not inside quotations)

	cmp	cmmt, 1
	jb	no_commt

	mov	al, es:[si]
	cmp	cmmt1, al
	jne	no_commt

	cmp	cmmt, 2
	jne	skip_cmmt

	mov	al, es:[si+1]
	cmp	cmmt2, al
	jne	no_commt

skip_cmmt:
	jcxz	noget		; get out of organize routine.
	mov	al, es:[si]
	inc	si
	dec	cx
	cmp	al, lf		; line feed?
	jne	skip_cmmt

no_commt:
	ret

skip_comment	endp

;
;----------------------------------------------------------------------------
;
; procedure : delim
;
;----------------------------------------------------------------------------
;
delim	proc	near
	cmp	al,'/'		; ibm will assume "/" as an delimeter.
	jz	delim_ret

	cmp	al, 0		; special case for sysinit!!!
	jz	delim_ret

org_delim:			; used by organize routine except for getting
	cmp	al,' '          ;the filename.
	jz	delim_ret
	cmp	al,9
	jz	delim_ret
	cmp	al,'='
	jz	delim_ret
	cmp	al,','
	jz	delim_ret
	cmp	al,';'
delim_ret:
	ret
delim	endp

;
;----------------------------------------------------------------------------
;
; procedure : newline
;
;  newline returns with first character of next line
;
;----------------------------------------------------------------------------
;

newline	proc	near

	call	getchr			;skip non-control characters
	jc	nl_ret
	cmp	al,lf			;look for line feed
	jnz	newline
	call	getchr
nl_ret:
	ret

newline	endp

;
;----------------------------------------------------------------------------
; 
; procedure : mapcase
;
;----------------------------------------------------------------------------
;
mapcase	proc	near
	push	cx
	push	si
	push	ds

	push	es
	pop	ds

	xor	si,si

convloop:
	lodsb

	ifdef	DBCS
	call	testkanj
	jz	normconv		; if this is not lead byte

	mov	ah,al
	lodsb				; get tail byte
	cmp	ax,DB_SPACE
	jnz	@f			; if this is not dbcs space
	mov	word ptr [si-2],'  '	; set 2 single space
@@:

	dec	cx
	jcxz	convdone		;just ignore 1/2 kanji error
	jmp	short noconv

;fall through, know al is not in 'a'-'z' range

normconv:
	endif

	cmp	al,'a'
	jb	noconv
	cmp	al,'z'
	ja	noconv
	sub	al,20h
	mov	[si-1],al
noconv:
	loop	convloop

convdone:
	pop	ds
	pop	si
	pop	cx
	ret

	ifdef	DBCS

	public	testkanj
testkanj:
	push	si
	push	ds

	push	ax
	mov	ax,6300h		; get dos dbcs vector
	int	21h
	pop	ax

bdbcs_do:

	cmp	ds:word ptr [si],0	; end of lead byte info?
	jz	bdbcs_notfound		; jump if so
	cmp	al,ds:[si]		; less than first byte character?
	jb	bdbcs_next		; jump if not
	cmp	al,ds:[si+1]		; grater than first byte character?
	ja	bdbcs_next

bdbcs_found:

	push	ax
	xor	ax,ax
	inc	ax			; reset zero flag
	pop	ax

bdbcs_exit:

	pop	ds
	pop	si
	ret

bdbcs_notfound:

	push	ax
	xor	ax,ax			; set zero flag
	pop	ax
	jmp	short bdbcs_exit

bdbcs_next:

	add	si,2			; points next lead byte table
	jmp	short bdbcs_do

	endif  ; DBCS

mapcase	endp

;
;----------------------------------------------------------------------------
;
; procedure : round
;
; round the values in memlo and memhi to paragraph boundary.
; perform bounds check.
;
;----------------------------------------------------------------------------
;

round	proc	near

	push	ax
	mov	ax,[memlo]

	call	pararound		; para round up

	add	[memhi],ax
	mov	[memlo],0
	mov	ax,memhi		; ax = new memhi
	cmp	ax,[alloclim]		; if new memhi >= alloclim, error
	jae	mem_err
	test	cs:[setdevmarkflag], for_devmark
	jz	skip_set_devmarksize
	push	es
	push	si
	mov	si, cs:[devmark_addr]
	mov	es, si
	sub	ax, si
	dec	ax
	mov	es:[devmark_size], ax	; paragraph
	and	cs:[setdevmarkflag], not_for_devmark
	pop	si
	pop	es
skip_set_devmarksize:
	pop	ax
	clc				;clear carry
	ret

mem_err:
	mov	dx,offset badmem
	push	cs
	pop	ds
	call	print
	jmp	stall

round	endp

;
;----------------------------------------------------------------------------
;
; procedure : calldev
;
;----------------------------------------------------------------------------
;
calldev	proc	near

	mov	ds,word ptr cs:[DevEntry+2]
	add	bx,word ptr cs:[DevEntry]	;do a little relocation
	mov	ax,ds:[bx]

	push	word ptr cs:[DevEntry]
	mov	word ptr cs:[DevEntry],ax
	mov	bx,offset packet
	call	[DevEntry]
	pop	word ptr cs:[DevEntry]
	ret

calldev	endp

;
;----------------------------------------------------------------------------
;
; procedure : todigit
;
;----------------------------------------------------------------------------
;
todigit	proc	near
	sub	al,'0'
	jb	notdig
	cmp	al,9
	ja	notdig
	clc
	ret
notdig:
	stc
	ret
todigit	endp

;
;----------------------------------------------------------------------------
;
; procedure : getnum
;
; getnum parses a decimal number.
; returns it in ax, sets zero flag if ax = 0 (may be considered an
; error), if number is bad carry is set, zero is set, ax=0.
;
;----------------------------------------------------------------------------
;

getnum	proc	near

	push	bx
	xor	bx,bx			; running count is zero

b2:
	call	todigit 		; do we have a digit
	jc	badnum			; no, bomb

	xchg	ax,bx			; put total in ax
	push	bx			; save digit
	mov	bx,10			; base of arithmetic
	mul	bx			; shift by one decimal di...
	pop	bx			; get back digit
	add	al,bl			; get total
	adc	ah,0			; make that 16 bits
	jc	badnum			; too big a number

	xchg	ax,bx			; stash total

	call	getchr			;get next digit
	jc	b1			; no more characters
	cmp	al, ' ' 		; space?
	jz	b15			; then end of digits
	cmp	al, ',' 		; ',' is a seperator!!!
	jz	b15			; then end of digits.
	cmp	al, tab 		; tab
	jz	b15
	cmp	al,sepchr		; allow 0 or special separators
	jz	b15
	cmp	al,'/'			; see if another switch follows
	nop				; cas - remnant of old bad code
	nop
	jz	b15
	cmp	al,lf			; line-feed?
	jz	b15
	cmp	al,cr			; carriage return?
	jz	b15
	or	al,al			; end of line separator?
	jnz	b2			; no, try as a valid char...

b15:
	inc	count			; one more character to s...
	dec	chrptr			; back up over separator
b1:
	mov	ax,bx			; get proper count
	or	ax,ax			; clears carry, sets zero accordingly
	pop	bx
	ret
badnum:
	mov	sepchr,0
	xor	ax,ax		; set zero flag, and ax = 0
	pop	bx
	stc			; and carry set
	ret

getnum	endp

;*****************************************************************

setdoscountryinfo	proc	near

;input: es:di -> pointer to dos_country_cdpg_info
;	ds:0  -> buffer.
;	si = 0
;	ax = country id
;	dx = code page id. (if 0, then use ccsyscodepage as a default.)
;	bx = file handle
;	this routine can handle maxium 438 country_data entries.
;
;output: dos_country_cdpg_info set.
;	 carry set if any file read failure or wrong information in the file.
;	 carry set and cx = -1 if cannot find the matching country_id, codepage
;	 _id in the file.

	push	di
	push	ax
	push	dx

	xor	cx,cx
	xor	dx,dx
	mov	ax,512			;read 512 bytes
	call	readincontrolbuffer	;read the file header
	jc	setdosdata_fail

	push	es
	push	si

	push	cs
	pop	es

	mov	di,offset country_file_signature
	mov	cx,8			;length of the signature
	repz	cmpsb

	pop	si
	pop	es
	jnz	setdosdata_fail 	;signature mismatch

	add	si,18			;si -> county info type
	cmp	byte ptr ds:[si],1	;only accept type 1 (currently only 1 header type)
	jne	setdosdata_fail 	;cannot proceed. error return

	inc	si			;si -> file offset
	mov	dx,word ptr ds:[si]	;get the info file offset.
	mov	cx,word ptr ds:[si+2]
	mov	ax,6144			;read 6144 bytes.
	call	readincontrolbuffer	;read info
	jc	setdosdata_fail

	mov	cx, word ptr ds:[si]	;get the # of country, codepage combination entries
	cmp	cx, 438			;cannot handle more than 438 entries.
					;	
	ja	setdosdata_fail

	inc	si
	inc	si			;si -> entry information packet
	pop	dx			;restore code page id
	pop	ax			;restore country id
	pop	di

setdoscntry_find:			;search for desired country_id,codepage_id.
	cmp	ax, word ptr ds:[si+2]	;compare country_id
	jne	setdoscntry_next

	cmp	dx, 0			;no user specified code page ?
	je	setdoscntry_any_codepage;then no need to match code page id.
	cmp	dx, word ptr ds:[si+4]	;compare code page id
	je	setdoscntry_got_it

setdoscntry_next:
	add	si, word ptr ds:[si]	;next entry
	inc	si
	inc	si			;take a word for size of entry itself
	loop	setdoscntry_find

	mov	cx, -1			;signals that bad country id entered.
setdoscntry_fail:
	stc
	ret

setdosdata_fail:
	pop	si
	pop	cx
	pop	di
	jmp	short setdoscntry_fail

setdoscntry_any_codepage:		;use the code_page_id of the country_id found.
	mov	dx, word ptr ds:[si+4]

setdoscntry_got_it:			;found the matching entry
	mov	cs:cntrycodepage_id, dx ;save code page id for this country.
	mov	dx, word ptr ds:[si+10] ;get the file offset of country data
	mov	cx, word ptr ds:[si+12]
	mov	ax, 512 		;read 512 bytes
	call	readincontrolbuffer
	jc	setdoscntry_fail

	mov	cx, word ptr ds:[si]	;get the number of entries to handle.
	inc	si
	inc	si			;si -> first entry

setdoscntry_data:
	push	di			;es:di -> dos_country_cdpg_info
	push	cx			;save # of entry left
	push	si			;si -> current entry in control buffer

	mov	al, byte ptr ds:[si+2]	;get data entry id
	call	getcountrydestination	;get the address of destination in es:di
	jc	setdoscntry_data_next	;no matching data entry id in dos

	mov	dx, word ptr ds:[si+4]	;get offset of data
	mov	cx, word ptr ds:[si+6]
	mov	ax,4200h
	stc
	int	21h			;move pointer
	jc	setdosdata_fail

	mov	dx,512			;start of data buffer
	mov	cx,20			;read 20 bytes only. we only need to
	mov	ah,3fh			;look at the length of the data in the file.
	stc
	int	21h			;read the country.sys data
	jc	setdosdata_fail 	;read failure

	cmp	ax,cx
	jne	setdosdata_fail

	mov	dx,word ptr ds:[si+4]	;get offset of data again.
	mov	cx,word ptr ds:[si+6]
	mov	ax,4200h
	stc
	int	21h			;move pointer back again
	jc	setdosdata_fail

	push	si
	mov	si,(512+8)		;get length of the data from the file
	mov	cx,word ptr ds:[si]
	pop	si
	mov	dx,512			;start of data buffer
	add	cx,10			;signature + a word for the length itself
	mov	ah,3fh			;read the data from the file.
	stc
	int	21h
	jc	setdosdata_fail

	cmp	ax, cx
	jne	setdosdata_fail

	mov	al,byte ptr ds:[si+2]	;save data id for future use.
	mov	si,(512+8)		;si-> data buffer + id tag field
	mov	cx,word ptr ds:[si]	;get the length of the file
	inc	cx			;take care of a word for lenght of tab
	inc	cx			;itself.
	cmp	cx,(2048 - 512 - 8)	;fit into the buffer?
	ja	setdosdata_fail

	if	bugfix
	call	setdbcs_before_copy
	endif

	cmp	al, setcountryinfo	;is the data for setcountryinfo table?
	jne	setdoscntry_mov 	;no, don't worry

	push	word ptr es:[di+ccmono_ptr-cccountryinfolen]	;cannot destroy ccmono_ptr address. save them.
	push	word ptr es:[di+ccmono_ptr-cccountryinfolen+2]	;at this time di -> cccountryinfolen
	push	di			;save di

	push	ax
	mov	ax,cs:cntrycodepage_id	;do not use the code page info in country_info
	mov	ds:[si+4], ax		;use the saved one for this !!!!
	pop	ax

setdoscntry_mov:
	rep	movsb			;copy the table into dos
	cmp	al, setcountryinfo	;was the ccmono_ptr saved?
	jne	setdoscntry_data_next

	pop	di			;restore di
	pop	word ptr es:[di+ccmono_ptr-cccountryinfolen+2]	 ;restore
	pop	word ptr es:[di+ccmono_ptr-cccountryinfolen]

setdoscntry_data_next:
	pop	si			;restore control buffer pointer
	pop	cx			;restore # of entries left
	pop	di			;restore pointer to dso_country_cdpg
	add	si, word ptr ds:[si]	;try to get the next entry
	inc	si
	inc	si			;take a word of entry length itself
	dec	cx
	cmp	cx,0
	je	setdoscntry_ok
	jmp	setdoscntry_data

setdoscntry_ok:
	ret
setdoscountryinfo	endp

	if	bugfix
setdbcs_before_copy	proc	near

	cmp	al,setdbcs		; dbcs vector set?
	jnz	@f			; jump if not
	cmp	word ptr es:[di], 0	; zero byte data block?
	jz	@f			; jump if so

	push	di
	push	ax
	push	cx
	mov	cx,es:[di]		; load block length
	add	di,2			; points actual data
	xor	al,al			; fill bytes
	rep	stosb			; clear data block
	pop	cx
	pop	ax
	pop	di
@@:
	ret
setdbcs_before_copy	endp
	endif

getcountrydestination	proc	near

;get the destination address in the dos country info table.
;input: al - data id
;	es:di -> dos_country_cdpg_info
;on return:
;	es:di -> destination address of the matching data id
;	carry set if no matching data id found in dos.

	push	cx
	add	di,ccnumber_of_entries	;skip the reserved area, syscodepage etc.
	mov	cx,word ptr es:[di]	;get the number of entries
	inc	di
	inc	di			;si -> the first start entry id

getcntrydest:
	cmp	byte ptr es:[di],al
	je	getcntrydest_ok
	cmp	byte ptr es:[di],setcountryinfo ;was it setcountryinfo entry?
	je	getcntrydest_1

	add	di,5			;next data id
	jmp	short getcntrydest_loop

getcntrydest_1:
	add	di,new_country_size + 3 ;next data id
getcntrydest_loop:
	loop	getcntrydest
	stc
	jmp	short getcntrydest_exit

getcntrydest_ok:
	cmp	al,setcountryinfo	;select country info?
	jne	getcntrydest_ok1

	inc	di			;now di -> cccountryinfolen
	jmp	short getcntrydest_exit

getcntrydest_ok1:
	les	di,dword ptr es:[di+1]	;get the destination in es:di

getcntrydest_exit:
	pop	cx
	ret
getcountrydestination	endp


readincontrolbuffer	proc	near

;move file pointer to cx:dx
;read ax bytes into the control buffer. (should be less than 2 kb)
;si will be set to 0 hence ds:si points to the control buffer.
;entry:  cx,dx offset from the start of the file where the read/write pointer
;	 be moved.
;	 ax - # of bytes to read
;	 bx - file handle
;	 ds - buffer seg.
;return: the control data information is read into ds:0 - ds:0200.
;	 cx,dx value destroyed.
;	 carry set if error in reading file.

	push	ax			;# of bytes to read
	mov	ax, 4200h
	stc
	int	21h			;move pointer
	pop	cx			;# of bytes to read
	jc	ricb_exit

	xor	dx,dx			;ds:dx -> control buffer
	xor	si,si
	mov	ah,3fh			;read into the buffer
	stc
	int	21h			;should be less than 1024 bytes.

ricb_exit:
	ret
readincontrolbuffer	endp


set_country_path	proc	near

;in:  ds - sysinitseg, es - confbot, si -> start of the asciiz path string
;     dosinfo_ext, cntry_drv, cntry_root, cntry_path
;     assumes current directory is the root directory.
;out: ds:di -> full path (cntry_drv).
;     set the cntry_drv string from the country=,,path command.
;     ds, es, si value saved.

	push	si

	push	ds			;switch ds, es
	push	es
	pop	ds
	pop	es			;now ds -> confbot, es -> sysinitseg

	call	chk_drive_letter	;current ds:[si] is a drive letter?
	jc	scp_default_drv 	;no, use current default drive.

	mov	al, byte ptr ds:[si]
	inc	si
	inc	si			;si -> next char after ":"
	jmp	short scp_setdrv

scp_default_drv:
	mov	ah, 19h
	int	21h
	add	al, "A"			;convert it to a character.

scp_setdrv:
	mov	cs:cntry_drv, al	;set the drive letter.
	mov	di, offset cntry_path
	mov	al, byte ptr ds:[si]
	cmp	al, "\"
	je	scp_root_dir

	cmp	al,"/"			;let's accept "/" as an directory delim
	je	scp_root_dir

	jmp	short scp_path

scp_root_dir:
	dec	di			;di -> cntry_root
scp_path:
	call	move_asciiz		;copy it

	mov	di, offset cntry_drv
scpath_exit:

	push	ds			;switch ds, es
	push	es
	pop	ds
	pop	es			;ds, es value restored

	pop	si
	ret
set_country_path	endp


chk_drive_letter	proc	near
;check if ds:[si] is a drive letter followed by ":".
;assume that every alpha charater is already converted to upper case.
;carry set if not.

	push	ax
	cmp	byte ptr ds:[si], "A"
	jb	cdletter_no
	cmp	byte ptr ds:[si], "Z"
	ja	cdletter_no
	cmp	byte ptr ds:[si+1], ":"
	jne	cdletter_no

	jmp	short cdletter_exit

cdletter_no:
	stc

cdletter_exit:
	pop	ax
	ret
chk_drive_letter	endp


move_asciiz	proc	near
;in: ds:si -> source es:di -> target
;out: copy the string until 0.
;assumes there exists a 0.

masciiz_loop:
	movsb
	cmp	byte ptr ds:[si-1],0	;was it 0?
	jne	masciiz_loop
	ret
move_asciiz	endp

;
;	ds:dx points to string to output (asciz)
;
;	prints <badld_pre> <string> <badld_post>

badfil:
	push	cs
	pop	es

	mov	si,dx
badload:
	mov	dx,offset badld_pre	;want to print config error
	mov	bx, offset crlfm

prnerr:
	push	cs
	pop	ds
	call	print

prn1:
	mov	dl,es:[si]
	or	dl,dl
	jz	prn2
	mov	ah,std_con_output
	int	21h
	inc	si
	jmp	prn1

prn2:
	mov	dx,bx
	call	print
	cmp	donotshownum,1		; suppress line number when handling command.com
	je	prnexit
	call	error_line
prnexit:
	ret

print:
        cmp     cs:bEchoConfig, 0      ; NTVDM skip print call, Jonle
        je      prnexit

	mov	ah,std_con_string_output
        int     21h

        ret

	if	noexec

; load non exe file called [ds:dx] at memory location es:bx

ldfil:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	ds
	push	bx

	xor	ax,ax			;open the file
	mov	ah,open
	stc				;in case of int 24
	int	21h
	pop	dx			;clean stack in case jump
	jc	ldret

	push	dx
	mov	bx,ax			;handle in bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	stc				;in case of int 24
	int	21h			; get file size in dx:ax
	jc	ldclsp

	or	dx,dx
	jnz	lderrp			; file >64k
	pop	dx

	push	dx
	mov	cx,es			; cx:dx is xaddr
	add	dx,ax			; add file size to xaddr
	jnc	dosize
	add	cx,1000h		; ripple carry
dosize:
	mov	ax,dx
	call	pararound
	mov	dx,ax

	add	cx,dx
	cmp	cx,[alloclim]
	jb	okld
	jmp	mem_err

okld:
	xor	cx,cx
	xor	dx,dx
	mov	ax,lseek shl 8		;reset pointer to beginning of file
	stc				;in case of int 24
	int	21h
	jc	ldclsp

	pop	dx

	push	es			;read the file in
	pop	ds			;trans addr is ds:dx

	mov	cx,0ff00h		; .com files arn't any bigger than
					; 64k-100h
	mov	ah,read
	stc				;in case of int 24
	int	21h
	jc	ldcls

	mov	si,dx			;check for exe file
	cmp	word ptr [si],"ZM"
	clc				; assume ok
	jnz	ldcls			; only know how to do .com files

	stc
	jmp	short ldcls

lderrp:
	stc
ldclsp:
	pop	dx			;clean stack
ldcls:
	pushf
	mov	ah,close		;close the file
	stc
	int	21h
	popf

ldret:	pop	ds
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
	endif

;
;  open device pointed to by dx, al has access code
;   if unable to open do a device open null device instead
;
open_dev:
	call	open_file
	jnc	open_dev3

open_dev1:
	mov	dx,offset nuldev
	call	open_file
of_ret:
	ret

open_dev3:
	mov	bx,ax			; handle from open to bx
	xor	ax,ax			; get device info
	mov	ah,ioctl
	int	21h
	test	dl,10000000b
	jnz	of_ret

	mov	ah,close
	int	21h
	jmp	open_dev1

open_file:
	mov	ah,open
	stc
	int	21h
	ret

; test int24. return back to dos with the fake user response of "fail"

int24:
	mov	al, 3			; fail the system call
	iret				; return back to dos.

include copyrigh.inc			; copyright statement

nuldev	db	"NUL",0
condev	db	"CON",0
auxdev	db	"AUX",0
prndev  db      "PRN",0
MseDev  db      "MOUSE",0               ; NTVDM for internal spc mouse




; NTVDM we use a temp file for config.sys 23-Nov-1992 Jonle
; config  db      "C:\CONFIG.SYS",0
config  db       64 dup (0)

cntry_drv   db	  "A:"
cntry_root  db	  "\"
cntry_path  db	  "COUNTRY.SYS",0
	    db	  52 dup (0)

country_file_signature db 0ffh,'COUNTRY'

cntrycodepage_id dw ?

commnd	db	"\COMMAND.COM",0
	db	51 dup (0)

pathstring db	64 dup (0)

comtab	label	byte

;            cmd len    command       cmd code
;            -------    -------       --------
;
	db	7,	"BUFFERS",	'B'
	db	5,	"BREAK",	'C'
	db	6,	"DEVICE",	'D'
	db	10,	"DEVICEHIGH",	'U'
	db	5,	"FILES",	'F'
	db	4,	"FCBS", 	'X'
	db	9,	"LASTDRIVE",	'L'
	db	10,	"MULTITRACK",	'M'
	db	8,	"DRIVPARM",	'P'
if     stacksw
	db	6,	"STACKS",	'K'
endif
	db	7,	"COUNTRY",	'Q'
	db	5,	"SHELL",	'S'
	db	7,	"INSTALL",	'I'
	db	7,	"COMMENT",	'Y'
	db	3,	"REM",		'0'
	db	8,	"SWITCHES",	'1'
        db      3,      "DOS",          'H'
        db      10,     "ECHOCONFIG",   'E'  ; NTVDM 14-Aug-1992 Jonle
        db      11,     "NTCMDPROMPT",  'T'  ; NTVDM 06-May-1993 sudeepb
        db      7,      "DOSONLY",      'O'  ; NTVDM 06-May-1993 sudeepb
	db	0

hlim	    dw	    2
slim        dw      9

public bEchoConfig       ; NTVDM - 14-Aug-1992 Jonle
bEchoConfig db  0

public drive
drive       db  ?

public switches
switches    dw	0


switchlist  db	8,"FHSTDICN"	     ; preserve the positions of n and c.

; the following depend on the positions of the various letters in switchlist

;switchnum	equ 11111000b		; which switches require number

flagec35	equ 00000100b		; electrically compatible 3.5 inch disk drive
flagdrive	equ 00001000b
flagcyln	equ 00010000b
flagseclim	equ 00100000b
flagheads	equ 01000000b
flagff		equ 10000000b

sysinitseg	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\convert\convert.c ===
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#include "windows.h"

#include "stdio.h"
#include "stdlib.h"

int convert(char *buffer, char *filename);

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: */

__cdecl main(int argc, char *argv[])
{
    char *buffer = malloc(1000*1024);
    int index;

    /* Validate input parameters */
    if(argc < 2)
    {
        printf("Invalid usage : CONVERT <filenames>\n");
        return(1);
    }

    for(index = 1; index < argc; index++)
	convert(buffer, argv[index]);

    return(0);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Convert file */

int convert(char *buffer, char *filename)
{
    FILE *FH;
    char *ptr;
    int chr;
    int last_chr = -1;


    /*.............................................. Open file to convert */

    if((FH = fopen(filename,"r+b")) == NULL)
    {
	printf("Failed to open file %s\n", filename);
        return(1);
    }

    /*........................................... Read in and convert file */

    ptr = buffer;
    while((chr = fgetc(FH)) != EOF)
    {
        switch(chr)
        {
            case 0xa :
                if(last_chr == 0xd)  break;
                /* Fall throught and insert CR/LF in output buffer */

            case 0xd :
                *ptr++ = 0xd;
                *ptr++  = 0xa;
                break;

            default:
                *ptr++ = chr;
                break;
        }

        last_chr = chr;
    }

    /* Remove Control Z from end of file */
    if(*(ptr-1) == 0x1a)
	*(ptr-1) = 0;
    else
	*ptr = 0; /* terminate output buffer */

    /* Write out converted file */
    fseek(FH, 0, 0);   /* Reset file pointer */
    fputs(buffer, FH);
    fclose(FH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\sysconf.asm ===
page	,160
	title	bios system initialization
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

	include version.inc		; set version build flags
	include biosseg.inc		; establish bios segment structure

lf	equ	10
cr	equ	13
tab	equ	 9

have_install_cmd      equ     00000001b ; config.sys has install= commands
has_installed	      equ     00000010b ; sysinit_base installed.

default_filenum = 8

	break	macro	; dummy empty macro
	endm

	include sysvar.inc
	include	pdb.inc			; M020
	include syscall.inc
	include doscntry.inc
	include devsym.inc
	include devmark.inc

	include	umb.inc
	include	dossym.inc
        include dossvc.inc
        include cmdsvc.inc
        include softpc.inc

stacksw equ	true		;include switchable hardware stacks

	if	ibmjapver
noexec	equ	true
	else
noexec	equ	false
	endif




; external variable defined in ibmbio module for multi-track

multrk_on	equ	10000000b	;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
multrk_off1	equ	00000000b	;initial value. no "multitrack=" command entered.
multrk_off2	equ	00000001b	;user specified multitrack=off.

Bios_Data segment 
	extrn	multrk_flag:word
	extrn	keyrd_func:byte
	extrn	keysts_func:byte
Bios_Data ends

; end of multi-track definition.

sysinitseg	segment 

assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing

	extrn	badopm:byte,crlfm:byte,badcom:byte,badmem:byte,badblock:byte
	extrn	badsiz_pre:byte,badld_pre:byte
	extrn	badstack:byte,badcountrycom:byte
	extrn	badcountry:byte,insufmemory:byte
	extrn	condev:byte,auxdev:byte,prndev:byte,commnd:byte,config:byte
	extrn	cntry_drv:byte,cntry_root:byte,cntry_path:byte
	extrn	memory_size:word
	extrn	buffers:word
	extrn	files:byte,num_cds:byte
	extrn	dosinfo:dword
	extrn	fcbs:byte,keep:byte
	extrn	confbot:word,alloclim:word,command_line:byte
	extrn	zero:byte,sepchr:byte
	extrn	count:word,chrptr:word,cntryfilehandle:word
	extrn	memlo:word,memhi:word,prmblk:word,ldoff:word
	extrn	packet:byte,unitcount:byte,break_addr:dword
	extrn	bpb_addr:dword,drivenumber:byte,sysi_country:dword
	extrn	config_size:word
	extrn	install_flag:word
	extrn	badorder:byte
	extrn	errorcmd:byte
	extrn	linecount:word
	extrn	showcount:byte
	extrn	buffer_linenum:word
	extrn	h_buffers:word
	extrn	badparm:byte
	extrn	configmsgflag:word
	extrn	org_count:word
	extrn	multi_pass_id:byte

	extrn	mem_err:near,setdoscountryinfo:near
	extrn	pararound:near,tempcds:near
	extrn	set_country_path:near,move_asciiz:near,delim:near
	extrn	badfil:near,round:near
	extrn	do_install_exec:near
	extrn	setdevmark:near

	extrn	print:near,organize:near,newline:near
	extrn	parseline:near
	extrn	badload:near,calldev:near,prnerr:near

	extrn	runhigh:byte
	extrn	IsXMSLoaded:near

	extrn	TryToMovDOSHi:near

ifdef DBCS
	extrn	testkanj:near
endif

        extrn   bEchoConfig:byte  ; NTVDM flag off\on echo of cfg processing

	if	stacksw

; internal stack parameters

entrysize	equ	8

mincount	equ	8
defaultcount	equ	9
maxcount	equ	64

minsize 	equ	32
defaultsize	equ	128
maxsize 	equ	512

DOS_FLAG_OFFSET	equ	86h

	extrn  stack_count:word
	extrn  stack_size:word
	extrn  stack_addr:dword

	endif

	public doconf
	public getchr
	public multi_pass
        public AllocUMB
        public AllocUMBLow      ; NTVDM
	public	multdeviceflag
multdeviceflag	db	0
	public	devmark_addr
devmark_addr	dw	?		;segment address for devmark.
	public	setdevmarkflag
setdevmarkflag	    db	    0		;flag used for devmark

ems_stub_installed  db	    0

IFDEF	DONT_LOAD_OS2_DD		; M045

Os2ChkBuf	DD	0		; Tmp read buffer

ENDIF					; M045

badparm_ptr	label	dword
badparm_off	dw	0
badparm_seg	dw	0

;******************************************************************************
;take care of config.sys file.
;system parser data and code.
;******************************************************************************

;*******************************************************************
; parser options set for msbio sysconf module
;*******************************************************************
;
;**** default assemble swiches definition **************************

	ifndef	farsw
farsw	equ	0	; near call expected
	endif

	ifndef	datesw
datesw	equ	0	; check date format
	endif

	ifndef	timesw
timesw	equ	0	; check time format
	endif

	ifndef	filesw
filesw	equ	1	; check file specification
	endif

	ifndef	capsw
capsw	equ	0	; perform caps if specified
	endif

	ifndef	cmpxsw
cmpxsw	equ	0	; check complex list
	endif

	ifndef	numsw
numsw	equ	1	; check numeric value
	endif

	ifndef	keysw
keysw	equ	0	; support keywords
	endif

	ifndef	swsw
swsw	equ	1	; support switches
	endif

	ifndef	val1sw
val1sw	equ	1	; support value definition 1
	endif

	ifndef	val2sw
val2sw	equ	0	; support value definition 2
	endif

	ifndef	val3sw
val3sw	equ	1	; support value definition 3
	endif

	ifndef	drvsw
drvsw	equ	1	; support drive only format
	endif

	ifndef	qussw
qussw	equ	0	; support quoted string format
	endif


	include parse.asm		;together with psdata.inc

;control block definitions for parser.
;---------------------------------------------------
; buffer = [n | n,m] {/e}

p_parms struc
	dw	?
	db	1		; an extra delimiter list
	db	1		; length is 1
	db	';'		; delimiter
p_parms ends

p_pos	struc
	dw	?		; numeric value??
	dw	?		; function
	dw	?		; result value buffer

; note: by defining result_val before this structure, we could remove
;  the "result_val" from every structure invocation

	dw	?		; value list
	db	0		; no switches/keywords
p_pos	ends

p_range struc
	db	1		; range definition
	db	1		; 1 definition of range
	db	1		; item tag for this range
	dd	?		; numeric min
	dd	?		; numeric max
p_range ends

buf_parms p_parms <buf_parmsx>
buf_parmsx dw	201h,buf_pos1,buf_pos2	; min 1, max 2 positionals
	   db	1			; one switch
	   dw	sw_x_ctrl
	   db	0			; no keywords

buf_pos1    p_pos   <8000h,0,result_val,buf_range_1> ; numeric
buf_range_1 p_range <,,,1,99>			     ; M050
buf_pos2    p_pos   <8001h,0,result_val,buf_range_2> ; optional num.
buf_range_2 p_range <,,,0,8>

sw_x_ctrl p_pos <0,0,result_val,noval,1> ; followed by one switch
switch_x  db	'/X',0			; M016

p_buffers	dw	0	; local variables
p_h_buffers	dw	0
p_buffer_slash_x db	0

;common definitions ------------
noval	db	0

result_val	label	byte
	db	?		; type returned
	db	?		; item tag returned
	dw	?		; es:offset of the switch defined
rv_byte 	label	byte
rv_dword dd	?		; value if number,or seg:offset to string.
;-------------------------------

; break = [ on | off ]

brk_parms	p_parms  <brk_parmsx>

brk_parmsx dw	101h,brk_pos	; min,max = 1 positional
	   db	0		; no switches
	   db	0		; no keywords

brk_pos p_pos	<2000h,0,result_val,on_off_string> ; simple string

on_off_string	label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	2		; 2 strings for choice
	db	1		; the 1st string tag
	dw	on_string
	db	2		; the 2nd string tag
	dw	off_string

on_string	db	"ON",0
off_string	db	"OFF",0

p_ctrl_break	db	0	; local variable

;--------------------------------

; country = n {m {path}}
; or
; country = n,,path

cntry_parms	p_parms <cntry_parmsx>

cntry_parmsx dw	301h,cntry_pos1,cntry_pos2,cntry_pos3 ; min 1, max 3 pos.
	     db	0		; no switches
	     db	0		; no keywords

cntry_pos1 p_pos <8000h,0,result_val,cc_range> ; numeric value
cc_range p_range <,,,1,999>
cntry_pos2 p_pos <8001h,0,result_val,cc_range> ; optional num.
cntry_pos3 p_pos <201h,0,result_val,noval>     ; optional filespec

p_cntry_code	dw	0	; local variable
p_code_page	dw	0	; local variable

;--------------------------------

; files = n

files_parms	p_parms <files_parmsx>

files_parmsx dw	101h,files_pos	; min,max 1 positional
	     db	0		; no switches
	     db	0		; no keywords

files_pos   p_pos   <8000h,0,result_val,files_range,0> ; numeric value
files_range p_range <,,,8,255>

p_files db	0		; local variable

;-------------------------------

; fcbs = n,m

fcbs_parms	p_parms <fcbs_parmsx>

fcbs_parmsx dw	201h,fcbs_pos_1,fcbs_pos_2 ; min,max = 2 positional
	    db	0		; no switches
	    db	0		; no keywords

fcbs_pos_1	p_pos	<8000h,0,result_val,fcbs_range> ; numeric value
fcbs_range	p_range	<,,,1,255>
fcbs_pos_2	p_pos	<8000h,0,result_val,fcbs_keep_range> ; numeric value
fcbs_keep_range p_range <,,,0,255>

p_fcbs	db	0		; local variable
p_keep	db	0		; local variable

;-------------------------------
; lastdrive = x

ldrv_parms	p_parms <ldrv_parmsx>

ldrv_parmsx dw	101h,ldrv_pos	; min,max = 1 positional
	    db	0		; no switches
	    db	0		; no keywords

ldrv_pos p_pos	<110h,10h,result_val,noval> ; drive only, ignore colon
					    ; remove colon at end
p_ldrv	db	0		; local variable

;-------------------------------

; stacks = n,m

stks_parms	p_parms <stks_parmsx>

stks_parmsx dw	202h,stks_pos_1,stks_pos_2 ; min,max = 2 positionals
	    db	0		; no switches
	    db	0		; no keywords

stks_pos_1     p_pos   <8000h,0,result_val,stks_range> ; numeric value
stks_range     p_range <,,,0,64>
stks_pos_2     p_pos   <8000h,0,result_val,stk_size_range> ; numeric value
stk_size_range p_range <,,,0,512>

p_stack_count	dw	0	; local variable
p_stack_size	dw	0	; local variable

;-------------------------------

; multitrack = [ on | off ]

mtrk_parms	p_parms <mtrk_parmsx>

mtrk_parmsx dw	101h,mtrk_pos	; min,max = 1 positional
	    db	0		; no switches
	    db	0		; no keywords

mtrk_pos p_pos	<2000h,0,result_val,on_off_string> ; simple string

p_mtrk	db	0		; local variable

;-------------------------------
; switches=/k

swit_parms	p_parms <swit_parmsx>

swit_parmsx dw	0		; no positionals
	    db	3		; 2 switches for now.	M059 M063
	    dw	swit_k_ctrl	; /k control
	    dw	swit_t_ctrl	; /t control		M059
	    dw	swit_w_ctrl	; /w control		M063
	    db	0		; no keywords

swit_k_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_k db	'/K',0
swit_t_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M059
swit_t db	'/T',0			   ;				M059
swit_w_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M063
swit_w db	'/W',0			   ;				M063

p_swit_k	db     0	; local variable
p_swit_t	db     0	; local variable			M059
p_swit_w	db     0	; local variable			M063

;-------------------------------

; DOS = [ high | low ]

dos_parms	p_parms  <dos_parmsx>

dos_parmsx db	1		; min parameters
	   db	2		; max parameters
	   dw	dos_pos		; 
	   dw	dos_pos		; 
	   db	0		; no switches
	   db	0		; no keywords

dos_pos p_pos	<2000h,0,result_val,dos_strings> ; simple string
        p_pos	<2000h,0,result_val,dos_strings> ; simple string

dos_strings	label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	4		; 4 strings for choice
	db	1		; the 1st string tag
	dw	hi_string
	db	2		; the 2nd string tag
	dw	lo_string
	db	3
	dw	umb_string
	db	4
	dw	noumb_string

hi_string	db	"HIGH",0
lo_string	db	"LOW",0
umb_string	db	"UMB",0
noumb_string	db	"NOUMB",0

p_dos_hi	db	0	; local variable
				; BUGBUG : I dont know whether PARSER uses
				;          this variable or not



;******************************************************************************

		public	DevEntry

DevSize		dw	?	; size of the device driver being loaded(paras)
DevLoadAddr	dw	?	; Mem addr where the device driver is 2 b loaded
DevLoadEnd	dw	?	; MaxAddr to which device can be loaded
DevEntry	dd	?	; Entry point to the device driver
DevBrkAddr	dd	?	; Break address of the device driver
;
DevUMB		db	0	; byte indicating whether to load DDs in UMBs
DevUMBAddr	dw	0	; cuurent UMB used fro loading devices (paras)
DevUMBSize	dw	0	; Size of the current UMB being used   (paras)
DevUMBFree	dw	0	; Start of free are in the current UMB (paras)
;
DevXMSAddr	dd	?
;
DevExecAddr	dw	?	; Device load address parameter to Exec call
DevExecReloc	dw	?	; Device load relocation factor
;
DeviceHi	db	0	; Flag indicating whther the current device
				;  is being loaded into UMB
DevSizeOption	dw	?	; SIZE= option
;
Int12Lied	db	0	; did we trap int 12 ?
OldInt12Mem	dw	?	; value in 40:13h (int 12 ram)
ThreeComName	db	'PROTMAN$'	; 3Com Device name
;
FirstUMBLinked	db	0
DevDOSData	dw	?	; segment of DOS Data
DevCmdLine	dd	?	; Current Command line
DevSavedDelim	db	?	; The delimiter which was replaced with null
				; to use the file name in the command line
;
;----------------------------------------------------------------------------
;
; procedure : doconf
;
;             Config file is parsed intitially with this routine. For the
;             Subsequent passes 'multi_pass' entry is used .
;
;----------------------------------------------------------------------------
;
doconf	proc	near
	push	cs
	pop	ds
	assume	ds:sysinitseg

	mov	ax,(char_oper shl 8)	;get switch character
	int	21h
	mov	[command_line+1],dl	; set in default command line

	mov	dx,offset config	;now pointing to file description
	mov	ax,open shl 8		;open file "config.sys"
	stc				;in case of int 24
	int	21h			;function request
	jnc	noprob			; brif opened okay
	mov	multi_pass_id,11	; set it to unreasonable number
	ret
noprob: 				;get file size (note < 64k!!)
	mov	bx,ax
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	int	21h
	mov	[count],ax

	xor	dx,dx
	mov	ax,lseek shl 8		;reset pointer to beginning of file
	int	21h

	mov	dx,[confbot]		;use current confbot value
	mov	ax,[count]
	mov	[config_size],ax	;save the size of config.sys file.
	call	pararound
	sub	dx,ax
	sub	dx,11h			;room for header
	mov	[confbot],dx		; config starts here. new conbot value.
	call	tempcds 		; finally get cds to "safe" location
	assume	ds:nothing,es:nothing

	mov	dx,[confbot]
	mov	ds,dx
	mov	es,dx
	xor	dx,dx
	mov	cx,[count]
	mov	ah,read
	stc				;in case of int 24
	int	21h			;function request
	pushf

; find the eof mark in the file.  if present,then trim length.

	push	ax
	push	di
	push	cx
	mov	al,1ah			; eof mark
	mov	di,dx			; point ro buffer
	jcxz	puteol			; no chars
	repnz	scasb			; find end
	jnz	puteol			; none found and count exahusted

; we found a 1a.  back up

	dec	di			; backup past 1a

;  just for the halibut,stick in an extra eol

puteol:
	mov	al,cr
	stosb
	mov	al,lf
	stosb
	sub	di,dx			; difference moved
	mov	count,di		; new count

	pop	cx
	pop	di
	pop	ax

	push	cs
	pop	ds
	assume	ds:sysinitseg

	push	ax
	mov	ah,close
	int	21h
	pop	ax
	popf
	jc	conferr 		;if not we've got a problem
	cmp	cx,ax
	jz	getcom			;couldn't read the file

conferr:
	mov	dx,offset config	;want to print config error
	call	badfil
endconv:
	ret
;
;----------------------------------------------------------------------------
;
; entry : multi_pass
;
;             called to execute device=,install= commands
;
;----------------------------------------------------------------------------
;

multi_pass:
	push	cs
	pop	ds

	cmp	multi_pass_id,10
	jae	endconv 		; do nothing. just return.

	push	confbot
	pop	es			; es -> confbot

	mov	si,org_count
	mov	count,si		; set count
	xor	si,si
	mov	chrptr,si		; reset chrptr,linecount
	mov	linecount,si
	call	getchr
	jmp	short conflp

getcom:
	call	organize		;organize the file
	call	getchr

conflp: jc	endconv

;***	call	reset_dos_version	; still need to reset version even ibmdos handles this through
;***					; function 4bh call,since ibmdos does not know when load/overlay call finishes.

	inc	linecount		; increase linecount.
	mov	multdeviceflag,0	; reset multdeviceflag.
	mov	setdevmarkflag,0	; reset setdevmarkflag.
	cmp	al,lf			; linefeed?
	je	blank_line		;  then ignore this line.

	mov	ah,al
	call	getchr
	jnc	tryi

	cmp	multi_pass_id,2
	jae	endconv 		;do not show badop again for multi_pass.
	jmp	badop

coff:	push	cs
	pop	ds
	call	newline
	jmp	conflp

blank_line:
	call	getchr
	jmp	conflp

coff_p:
	push	cs
	pop	ds


;to handle install= commands,we are going to use multi-pass.
;the first pass handles the other commands and only set install_flag when
;it finds any install command.	 the second pass will only handle the
;install= command.

;------------------------------------------------------------------------------
;install command
;------------------------------------------------------------------------------
tryi:
        cmp     multi_pass_id,0         ; the initial pass for DOS=HI
        je      multi_try_doshi

        cmp     multi_pass_id,2         ; the second pass was for ifs=
        je      coff                    ; now it is NOPs
					; This pass can be made use of if
					; we want do some config.sys process
					; after device drivers are loaded
					; and before install= commands
					; are processed

	cmp	multi_pass_id,3		; the third pass for install= ?
	je	multi_try_i
	cmp	ah, 'H'
        je      coff
        cmp     ah, 'E'
        je      coff
	cmp	ah,'I'			; install= command?
	jne	tryb				; the first pass is for normal operation.
	or	install_flag,have_install_cmd	; set the flag
	jmp	coff				; and handles the next command

multi_try_i:
	cmp	ah,'I'			; install= command?
	jne	multi_pass_filter	; no. ignore this.
	call	do_install_exec 	;install it.
	jmp	coff			;to handle next install= command.

multi_pass_filter:
	cmp	ah,'Y'			; comment?
	je	multi_pass_adjust
	cmp	ah,'Z'			; bad command?
	je	multi_pass_adjust
	cmp	ah,'0'			; rem?
        jne     coff         ; ignore the rest of the commands.

multi_pass_adjust:			; these commands need to
	dec	chrptr			;  adjust chrptr,count
	inc	count			;  for newline proc.

multi_pass_coff:
	jmp	coff			; to handle next install= commands.



;----------------------------------------------------------------------------
; DOS=HIGH/LOW command
;
; EchoConfig command turns on con echo for config processing
;            NTVDM 14-Aug-1992 Jonle
;----------------------------------------------------------------------------
;
multi_try_doshi:
	cmp	ah, 'H'
        je      it_is_h
        cmp     ah, 'E'
        jne     multi_pass_filter

        mov     cs:bEchoConfig, ah     ; init console
        CMDSVC  SVC_CMDINITCONSOLE
        jmp     coff


it_is_h:                                ; M003 - removed initing DevUMB
					;	 & runhigh
	mov	di,offset dos_parms
	xor	cx,cx
	mov	dx,cx
h_do_parse:
	call	sysinit_parse
	jnc	h_parse_ok		; parse error
h_badparm:
	call	badparm_p		;  show message and end the serach loop.
	jmp	short h_end

h_parse_ok:
	cmp	ax,$p_rc_eol		; end of line?
	jz	h_end			; then end the $endloop
	call	ProcDOS
	jmp	short h_do_parse
h_end:
	jmp	coff


;------------------------------------------------------------------------------
; buffer command
;------------------------------------------------------------------------------
;*******************************************************************************
;									      *
; function: parse the parameters of buffers= command.			      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	buffers set							      *
;	buffer_slash_x	flag set if /x option chosen.			      *
;	h_buffers set if secondary buffer cache specified.		      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di points to buf_parms;  /*parse control definition*/	      *
;	set dx,cx to 0; 						      *
;	reset buffer_slash_x;						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val.$p_synonym_ptr == slash_e) then /*not a switch  *
;		    buffer_slash_x = 1					      *
;	       else if	 (cx == 1) then 	    /* first positional */    *
;			  buffers = result_val.$p_picked_val;		      *
;		    else  h_buffers = result_val.$p_picked_val; 	      *
;	  else	{show error message;error exit} 			      *
;	};								      *
;	if (buffer_slash_x is off & buffers > 99) then show_error;	      *
; };									      *
;									      *
;*******************************************************************************

tryb:
	cmp	ah,'B'
        jnz     tryc

        ; NTVDM - buffers command is ignored
        ; 15-Aug-1992 Jonle
        jmp     coff

if  0
        mov     p_buffer_slash_x,0
        mov     di,offset buf_parms
        xor     cx,cx
        mov     dx,cx

do7:
        call    sysinit_parse
        jnc     if7                     ; parse error,
        call    badparm_p               ;   and show messages and end the search loop.
        jmp     short sr7

if7:
        cmp     ax,$p_rc_eol            ; end of line?
        jz      en7                     ;  then jmp to $endloop for semantic check
        cmp     result_val.$p_synonym_ptr,offset switch_x
        jnz     if11

;       mov     p_buffer_slash_x,1      ; set the flag M016
	jmp	short en11

if11:
	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if13

	mov	p_buffers,ax
	jmp	short en11

if13:
	mov	p_h_buffers,ax
en11:
	jmp	do7

en7:
	cmp	p_buffers,99
	jbe	if18
;	cmp	p_buffer_slash_x,0	; M016
;	jnz	if18

	call	badparm_p
	mov	p_h_buffers,0
	jmp	short sr7

if18:
	mov	ax,p_buffers	; we don't have any problem.
	mov	buffers,ax	; now,let's set it really.

	mov	ax,p_h_buffers
	mov	h_buffers,ax

;	mov	al,p_buffer_slash_x	; M016
;	mov	buffer_slash_x,al

	mov	ax,linecount
	mov	buffer_linenum,ax ; save the line number for the future use.

sr7:
        jmp     coff
endif


;------------------------------------------------------------------------------
; break command
;------------------------------------------------------------------------------
;****************************************************************************
;									    *
; function: parse the parameters of break = command.			    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	turn the control-c check on or off.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di to brk_parms;						    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val.$p_item_tag == 1) then	  /*on		 */ *
;		   set p_ctrl_break,on;					    *
;	       else					  /*off 	 */ *
;		   set p_ctrl_break,off;				    *
;	  else {show message;error_exit};				    *
;	};								    *
;	if (no error) then						    *
;	   dos function call to set ctrl_break check according to	    *
; };									    *
;									    *
;****************************************************************************

tryc:
	cmp	ah,'C'
	jnz	trym
	mov	di,offset brk_parms
	xor	cx,cx
	mov	dx,cx
do22:
	call	sysinit_parse
	jnc	if22			; parse error
	call	badparm_p		;  show message and end the serach loop.
	jmp	short sr22

if22:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en22			; then end the $endloop
	cmp	result_val.$p_item_tag,1
	jnz	if26

	mov	p_ctrl_break,1		; turn it on
	jmp	short en26

if26:
	mov	p_ctrl_break,0		; turn it off
en26:
	jmp	short do22		; we actually set the ctrl break

en22:
	mov	ah,set_ctrl_c_trapping ; if we don't have any parse error.
	mov	al,1
	mov	dl,p_ctrl_break
	int	21h
sr22:
	jmp	coff

;------------------------------------------------------------------------------
; multitrack command
;------------------------------------------------------------------------------
;******************************************************************************
;									      *
; function: parse the parameters of multitrack= command.		      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	turn multrk_flag on or off.					      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di to brk_parms;						      *
;	set dx,cx to 0; 						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val.$p_item_tag == 1) then	  /*on		 */   *
;		   set p_mtrk,on;					      *
;	       else					  /*off 	 */   *
;		   set p_mtrk,off;					      *
;	  else {show message;error_exit};				      *
;	};								      *
;	if (no error) then						      *
;	   dos function call to set multrk_flag according to p_mtrk.	      *
;									      *
; };									      *
;									      *
;******************************************************************************

trym:
	cmp	ah,'M'
	jnz	tryu

	mov	di,offset mtrk_parms
	xor	cx,cx
	mov	dx,cx
do31:
	call	sysinit_parse
	jnc	if31		; parse error
	call	badparm_p	;  show message and end the serach loop.
	jmp	short sr31
if31:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en31		; then end the $endloop

	cmp	result_val.$p_item_tag,1
	jnz	if35

	mov	p_mtrk,1	; turn it on temporarily.
	jmp	short en35

if35:
	mov	p_mtrk,0	; turn it off temporarily.
en35:
	jmp	short do31	; we actually set the multrk_flag here

en31:
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data

	cmp	p_mtrk,0
	jnz	if39

	mov	multrk_flag,multrk_off2	; 0001h
	jmp	short en39

if39:
	mov	multrk_flag,multrk_on	; 8000h
en39:
	pop	ds
	assume	ds:sysinitseg
sr31:
	jmp	coff


;
;-----------------------------------------------------------------------------
; devicehigh command
;-----------------------------------------------------------------------------
;
	assume	ds:nothing
tryu:
	cmp	ah, 'U'
	jne	tryd
	mov	badparm_off, si		; stash it there in case of an error
	mov	badparm_seg, es
	call	ParseSize		; process the size= option
	jnc	@f
	call	badparm_p
	jmp	coff
@@:
	push	si
	push	es
@@:
	mov	al, es:[si]
	cmp	al, cr
	je	@f
	cmp	al, lf
	je	@f
	call	delim
	jz	@f
	inc	si
	jmp	@b
@@:
	mov	DevSavedDelim, al	; Save the delimiter before replacing
					;  it with null
	mov	byte ptr es:[si], 0
	pop	es
	pop	si

	mov	DeviceHi, 0
	cmp	DevUMB, 0		; do we support UMBs
	je	LoadDevice		; no, we don't
	mov	DeviceHi, 1
	jmp	short LoadDevice
;
;------------------------------------------------------------------------------
; device command
;------------------------------------------------------------------------------

	assume	ds:nothing
tryd:
	cmp	ah,'D'
	jz	gotd
	jmp	tryq
gotd:
	mov	DeviceHi, 0		; not to be loaded in UMB ;M007
	mov	DevSizeOption, 0
	mov	DevSavedDelim, ' '	; In case of DEVICE= the null has to
					;  be replaced with a ' '

LoadDevice:
	mov	bx,cs			;device= or devicehigh= command.
	mov	ds,bx

	mov	word ptr [bpb_addr],si	; pass the command line to the dvice
	mov	word ptr [bpb_addr+2],es

	mov	word ptr DevCmdLine, si	; save it for ourself
	mov	word ptr DevCmdLine+2, es

	call	round

	call	SizeDevice
        jc      BadFile

        call    InitDevLoad

	mov	ax, DevLoadAddr
	add	ax, DevSize
	jc	NoMem
	cmp	DevLoadEnd, ax
	jae	LoadDev

NoMem:
	jmp	mem_err

BadFile:
	cmp	byte ptr es:[si], cr
	jne	@f
	jmp	badop
@@:
	call	badload
	jmp	coff

LoadDev:
	push	es
	pop	ds
	assume	ds:nothing
	mov	dx,si			;ds:dx points to file name

	if	noexec
	les	bx,dword ptr cs:[memlo]
	call	ldfil			;load in the device driver

	else

	call	ExecDev			; load device driver using exec call

	endif

badldreset:
	push	ds
	pop	es			;es:si back to config.sys
	push	cs
	pop	ds			;ds back to sysinit
	jc	BadFile
goodld:
	push	es
	push	si			; ???

	call	RemoveNull

        push    es
        push    si

	push	cs
	pop	es


;NTVDM: block device drivers are not supported.
;       Putup user warning popup for unsupported device driver
;       29-Sep-1992 Jonle
;
        push    ds
	push	si
        lds     si, DevEntry                    ; peek the header attribute
        test    word ptr ds:[si.sdevatt],devtyp ; IS block device driver?
        pop     si
        pop     ds
        jnz     got_device_com_cont             ; no!

        pop     si                              ;clear the stack
        pop     es

        mov     ax, NOSUPPORT_DRIVER
        BOP     BOP_NOSUPPORT
        jmp     short erase_dev_do

got_device_com_cont:

	call	LieInt12Mem
	call	UpdatePDB		; update the PSP:2 value M020

	cmp	cs:multdeviceflag, 0	; Pass limit only for the 1st device
					;  driver in the file ; M027
	jne	skip_pass_limit		;		      ; M027

	mov	word ptr break_addr, 0	; pass the limit to the DD
	mov	bx, DevLoadEnd
	mov	word ptr break_addr+2, bx
skip_pass_limit:					      ; M027
	mov	bx,sdevstrat
	call	calldev 		;   calldev (sdevstrat);
	mov	bx,sdevint
	call	calldev 		;   calldev (sdevint);

	call	TrueInt12Mem

	mov	ax, word ptr break_addr	; move break addr from the req packet
	mov	word ptr DevBrkAddr, ax
	mov	ax, word ptr break_addr+2
	mov	word ptr DevBrkAddr+2, ax

	assume	ds:nothing

	cmp	DevUMB, 0
	jz	@f
	call	AllocUMB
@@:

;
;------ If we are waiting to be moved into hma lets try it now !!!
;
	cmp	runhigh, 0ffh
	jne	@f

	call	TryToMovDOSHi		; move DOS into HMA if reqd
@@:

	pop	si
	pop	ds
	mov	byte ptr [si],0 	;   *p = 0;

	push	cs
	pop	ds

	jmp	short was_device_com


erase_dev_do:                           ; modified to show message "error in config.sys..."
	pop	si
	pop	es

	push	cs
	pop	ds

;	test	[setdevmarkflag],setbrkdone	;if already set_break is done,
;	jnz	skip1_resetmemhi		; then do not
;	dec	[memhi] 			;adjust memhi by a paragrah of devmark.

skip1_resetmemhi:
	cmp	configmsgflag,0
	je	no_error_line_msg

	call	error_line		; no "error in config.sys" msg for device driver. dcr d493
	mov	configmsgflag,0		;set the default value again.

no_error_line_msg:
	jmp	coff
;
;----------------------------------------------------------------------------
;
was_device_com:
	mov	ax,word ptr [DevBrkAddr+2]
	cmp	ax,DevLoadEnd
	jbe	breakok

	pop	si
	pop	es
	jmp	BadFile

breakok:
        lds     si,DevEntry             ;ds:si points to header
        les     di,cs:[dosinfo]         ;es:di point to dos info
        mov     ax,ds:[si.sdevatt]      ;ax    Dev attributes
;
;------ lets deal with character devices,
;       NTVDM: removed check for block drivers, jonle
;
ischardev:
        or      cs:[setdevmarkflag],for_devmark
	call	DevSetBreak		; go ahead and alloc mem for device
        jc      erase_dev_do            ;device driver's init routine failed.

	test	ax,iscin		;is it a console in?
	jz	tryclk

        mov     word ptr es:[di.sysi_con],si
	mov	word ptr es:[di.sysi_con+2],ds

tryclk: test	ax,isclock		;is it a clock device?
        jz      linkit

        mov     word ptr es:[di+sysi_clock],si
	mov	word ptr es:[di+sysi_clock+2],ds

linkit:

        mov     cx,word ptr es:[di.sysi_dev]    ;dx:cx = head of list
	mov	dx,word ptr es:[di.sysi_dev+2]

        mov     word ptr es:[di.sysi_dev],si    ;set head of list in dos
	mov	word ptr es:[di.sysi_dev+2],ds
	mov	ax,ds:[si]			;get pointer to next device
	mov	word ptr cs:[DevEntry],ax	;and save it

	mov	word ptr ds:[si],cx		;link in the driver
	mov	word ptr ds:[si+2],dx

enddev:
	pop	si
	pop	es
	inc	ax			;ax = ffff (no more devs if yes)?
	jz	coffj3

	inc	cs:multdeviceflag	; possibly multiple device driver.
	call	DevBreak		; M009
	jmp	goodld			; otherwise pretend we loaded it in

coffj3: mov	cs:multdeviceflag,0	; reset the flag
	call	DevBreak
	jmp	coff

bad_bpb_size_sector:
	pop	si
	pop	es
	mov	dx,offset badsiz_pre
	mov	bx,offset crlfm
	call	prnerr

;	test	[setdevmarkflag],setbrkdone ;if already set_break is done,
;	jnz	skip2_resetmemhi	; then do not
;	dec	[memhi] 		;adjust memhi by a paragrah of devmark.

skip2_resetmemhi:
	jmp	coff


;------------------------------------------------------------------------------
; country command
;      the syntax is:
;	country=country id {,codepage {,path}}
;	country=country id {,,path}	:default codepage id in dos
;------------------------------------------------------------------------------

tryq:
	cmp	ah,'Q'
	jz	tryq_cont
	jmp	tryf
tryq_cont:

	mov	cntry_drv,0		; reset the drive,path to default value.
	mov	p_code_page,0
	mov	di,offset cntry_parms
	xor	cx,cx
	mov	dx,cx
do52:
	call	sysinit_parse
	jnc	if52			; parse error,check error code and

	call	cntry_error		;  show message and end the search loop.
	mov	p_cntry_code,-1		; signals that parse error.
	jmp	short sr52

if52:
	cmp	ax,$p_rc_eol		; end of line?
	jz	sr52			; then end the search loop

	cmp	result_val.$p_type,$p_number	; numeric?
	jnz	if56

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if57

	mov	p_cntry_code,ax
	jmp	short en57

if57:
	mov	p_code_page,ax
en57:
	jmp	short en56		; path entered

if56:
	push	ds
	push	es
	push	si
	push	di

	push	cs
	pop	es

	lds	si,rv_dword		; move the path to known place.
	mov	di,offset cntry_drv
	call	move_asciiz

	pop	di
	pop	si
	pop	es
	pop	ds

en56:
	jmp	do52

sr52:
	cmp	p_cntry_code,-1		; had a parse error?
	jne	tryq_open
	jmp	coff

tryqbad:				;"invalid country code or code page"
       stc
       mov     dx,offset badcountry
       jmp     tryqchkerr

tryq_open:
	cmp	cntry_drv,0
	je	tryq_def
	mov	dx,offset cntry_drv
	jmp	short tryq_openit

tryq_def:
	mov	dx,offset cntry_root
tryq_openit:
	mov	ax,3d00h		;open a file
	stc
	int	21h
	jc	tryqfilebad		;open failure

	mov	cs:cntryfilehandle,ax	;save file handle
	mov	bx,ax
	mov	ax,cs:p_cntry_code
	mov	dx,cs:p_code_page	; now,ax=country id,bx=filehandle
	mov	cx,cs:[memhi]
	add	cx,384			; need 6k buffer to handle country.sys
					; M023
	cmp	cx,cs:[alloclim]
	ja	tryqmemory		;cannot allocate the buffer for country.sys

	mov	si,offset cntry_drv	;ds:si -> cntry_drv
	cmp	byte ptr [si],0 	;default path?
	jne	tryq_set_for_dos

	inc	si
	inc	si			;ds:si -> cntry_root

tryq_set_for_dos:
	les	di,cs:sysi_country	;es:di -> country info tab in dos
	push	di			;save di
	add	di,ccpath_countrysys
	call	move_asciiz		;set the path to country.sys in dos.
	pop	di			;es:di -> country info tab again.

	mov	cx,cs:[memhi]
	mov	ds,cx
	xor	si,si			;ds:si -> 2k buffer to be used.
	call	setdoscountryinfo	;now do the job!!!
	jnc	tryqchkerr		;read error or could not find country,code page combination

	cmp	cx,-1			;could not find matching country_id,code page?
	je	tryqbad 		;then "invalid country code or code page"

tryqfilebad:
	push	cs
	pop	es
	cmp	cs:cntry_drv,0		;is the default file used?
	je	tryqdefbad

	mov	si,offset cntry_drv
	jmp	short tryqbadload

tryqdefbad:				;default file has been used.
	mov	si,offset cntry_root	;es:si -> \country.sys in sysinit_seg
tryqbadload:
	call	badload 		;ds will be restored to sysinit_seg
	mov	cx,cs:[confbot]
	mov	es,cx			;restore es -> confbot.
	jmp	short coffj4

tryqmemory:
	mov	dx,offset insufmemory
tryqchkerr:
	mov	cx,cs:[confbot]
	mov	es,cx			;restore es -> confbot seg
	push	cs
	pop	ds			;retore ds to sysinit_seg
	jnc	coffj4			;if no error,then exit

	call	print			;else show error message
	call	error_line

coffj4:
	mov	bx,cntryfilehandle
	mov	ah,3eh
	int	21h			;close a file. don't care even if it fails.
	jmp	coff

cntry_error	proc	near

;function: show "invalid country code or code page" messages,or
;		"error in country command" depending on the error code
;		in ax returned by sysparse;
;in:	ax - error code
;	ds - sysinitseg
;	es - confbot
;out:	show message.  dx destroyed.

	cmp	ax,$p_out_of_range
	jnz	if64
	mov	dx,offset badcountry	;"invalid country code or code page"
	jmp	short en64

if64:
	mov	dx,offset badcountrycom ;"error in contry command"
en64:
	call	print
	call	error_line
	ret
cntry_error	endp

;------------------------------------------------------------------------------
; files command
;------------------------------------------------------------------------------
;*******************************************************************************
; function: parse the parameters of files= command.			       *
;									       *
; input :								       *
;	es:si -> parameters in command line.				       *
; output:								       *
;	variable files set.						       *
;									       *
; subroutines to be called:						       *
;	sysinit_parse							       *
; logic:								       *
; {									       *
;	set di points to files_parms;					       *
;	set dx,cx to 0; 						       *
;	while (end of command line)					       *
;	{ sysinit_parse;						       *
;	  if (no error) then						       *
;	     files = result_val.$p_picked_val				       *
;	  else								       *
;	     error exit;						       *
;	};								       *
; };									       *
;									       *
;*******************************************************************************
tryf:
	cmp	ah,'F'
	jnz	tryl

	mov	di,offset files_parms
	xor	cx,cx
	mov	dx,cx

do67:
	call	sysinit_parse
	jnc	if67			; parse error
	call	badparm_p		;   and show messages and end the search loop.
	jmp	short sr67

if67:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en67			; then end the $endloop
	mov	al,byte ptr result_val.$p_picked_val
	mov	p_files,al		; save it temporarily
	jmp	short do67

en67:
	mov	al,p_files
	SVC	SVC_DEMWOWFILES 	; For WOW VDM Set the file= to max.
	mov	files,al		; no error. really set the value now.

sr67:
	jmp	coff

;------------------------------------------------------------------------------
; lastdrive command
;------------------------------------------------------------------------------
;*******************************************************************************
; function: parse the parameters of lastdrive= command. 		       *
;									       *
; input :								       *
;	es:si -> parameters in command line.				       *
; output:								       *
;	set the variable num_cds.					       *
;									       *
; subroutines to be called:						       *
;	sysinit_parse							       *
; logic:								       *
; {									       *
;	set di points to ldrv_parms;					       *
;	set dx,cx to 0; 						       *
;	while (end of command line)					       *
;	{ sysinit_parse;						       *
;	  if (no error) then						       *
;	     set num_cds to the returned value; 			       *
;	  else	/*error exit*/						       *
;	     error exit;						       *
;	};								       *
; };									       *
;									       *
;*******************************************************************************

tryl:
	cmp	ah,'L'
        jnz     tryp
        jmp     coff

;NTVDM Ignore the lastdrive command. Dos will figure this from the host OS.
;      17-Aug-1992 Jonle
if 0

	mov	di,offset ldrv_parms
	xor	cx,cx
	mov	dx,cx

do73:
	call	sysinit_parse
	jnc	if73		; parse error
	call	badparm_p	;   and show messages and end the search loop.
	jmp	short sr73

if73:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en73		; then end the $endloop
	mov	al,rv_byte	; pick up the drive number
	mov	p_ldrv,al	; save it temporarily
	jmp	do73

en73:
	mov	al,p_ldrv
	mov	num_cds,al	; no error. really set the value now.
sr73:
        jmp     coff
endif


;--------------------------------------------------------------------------
; setting drive parameters
;--------------------------------------------------------------------------

tryp:
	cmp	ah,'P'
        jnz     tryk
        jmp     coff

; sudeepb 04-Mar-1991 : Ignoring DRIVEPARM command
;       call    parseline
;       jc      trypbad
;
;	call	setparms
;	call	diddleback
;	jc	trypbad
;       jmp     coff
;trypbad:jmp     badop

;--------------------------------------------------------------------------
; setting internal stack parameters
; stacks=m,n where
;	m is the number of stacks (range 8 to 64,default 9)
;	n is the stack size (range 32 to 512 bytes,default 128)
; j.k. 5/5/86: stacks=0,0 implies no stack installation.
;	any combinations that are not within the specified limits will
;	result in "unrecognized command" error.
;--------------------------------------------------------------------------

;****************************************************************************
;									    *
; function: parse the parameters of stacks= command.			    *
;	    the minimum value for "number of stacks" and "stack size" is    *
;	    8 and 32 each.  in the definition of sysparse value list,they   *
;	    are set to 0.  this is for accepting the exceptional case of    *
;	    stacks=0,0 case (,which means do not install the stack.)	    *
;	    so,after sysparse is done,we have to check if the entered	    *
;	    values (stack_count,stack_size) are within the actual range,    *
;	    (or if "0,0" pair has been entered.)			    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	set the variables stack_count,stack_size.			    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di points to stks_parms;					    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	     { if (cx == 1) then /* first positional = stack count */	    *
;		   p_stack_count = result_val.$p_picked_val;		    *
;	       if (cx == 2) then /* second positional = stack size */	    *
;		   p_stack_size = result_val.$p_picked_val;		    *
;	     }								    *
;	  else	/*error exit*/						    *
;	     error exit;						    *
;	};								    *
;	here check p_stack_count,p_stack_size if it meets the condition;    *
;	if o.k.,then set stack_count,stack_size;			    *
;	 else error_exit;						    *
; };									    *
;****************************************************************************

tryk:
	cmp	ah,'K'
	je	do_tryk
	jmp	trys

		if	stacksw

do_tryk:
	mov	di,offset stks_parms
	xor	cx,cx
	mov	dx,cx

do79:
	call	sysinit_parse
	jnc	if79			; parse error

	mov	dx,offset badstack	; "invalid stack parameter"
	call	print			;  and show messages and end the search loop.
	call	error_line
	jmp	sr79

if79:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en79			; then end the $endloop

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if83

	mov	p_stack_count,ax
	jmp	short en83

if83:
	mov	p_stack_size,ax
en83:
	jmp	do79

en79:
	cmp	p_stack_count,0
	jz	if87

	cmp	p_stack_count,mincount
	jb	ll88
	cmp	p_stack_size,minsize
	jnb	if88

ll88:
	mov	p_stack_count,-1	; invalid
if88:
	jmp	short en87

if87:
	cmp	p_stack_size,0
	jz	en87
	mov	p_stack_count,-1	; invalid
en87:
	cmp	p_stack_count,-1	; invalid?
	jnz	if94

	mov	stack_count,defaultcount ;reset to default value.
	mov	stack_size,defaultsize
	mov	word ptr stack_addr,0

	mov	dx,offset badstack
	call	print
	call	error_line
	jmp	short sr79

if94:
	mov	ax,p_stack_count
	mov	stack_count,ax
	mov	ax,p_stack_size
	mov	stack_size,ax
	mov	word ptr stack_addr,-1	; stacks= been accepted.
sr79:
	jmp	coff

	endif

;------------------------------------------------------------------------
; shell command
;------------------------------------------------------------------------

trys:
	cmp	ah,'S'
	jnz	tryx

	mov	[command_line+1],0
	mov	di,offset commnd + 1
	mov	[di-1],al

storeshell:
	call	getchr
	or	al,al
	jz	getshparms

	cmp	al," "
	jb	endsh

	mov	[di],al
	inc	di
	jmp	storeshell

endsh:
	mov	byte ptr [di],0
;	push	di
;	mov	di,offset commnd
;	SVC	SVC_SETSHELLNAME
;	pop	di

	call	getchr
	cmp	al,lf
	jnz	conv

	call	getchr
conv:	jmp	conflp

getshparms:
	mov	byte ptr [di],0
	mov	di,offset command_line+1

parmloop:
	call	getchr
	cmp	al," "
	jb	endsh
	mov	[di],al
	inc	di
	jmp	parmloop

;------------------------------------------------------------------------
; fcbs command
;------------------------------------------------------------------------

;************************************************************************
; function: parse the parameters of fcbs= command.			*
;									*
; input :								*
;	es:si -> parameters in command line.				*
; output:								*
;	set the variables fcbs,keep.					*
;									*
; subroutines to be called:						*
;	sysinit_parse							*
; logic:								*
; {									*
;	set di points to fcbs_parms;					*
;	set dx,cx to 0; 						*
;	while (end of command line)					*
;	{ sysparse;							*
;	  if (no error) then						*
;	     { if (cx == 1) then /* first positional = fcbs */		*
;		   fcbs = result_val.$p_picked_val;			*
;	       if (cx == 2) then /* second positional = keep */ 	*
;		   keep = result_val.$p_picked_val;			*
;	     }								*
;	  else	/*error exit*/						*
;	     error exit;						*
;	};								*
; };									*
;************************************************************************

tryx:
	cmp	ah,'X'
	jnz	tryy

	mov	di,offset fcbs_parms
	xor	cx,cx
	mov	dx,cx

do98:
	call	sysinit_parse
	jnc	if98			; parse error
	call	badparm_p		;  and show messages and end the search loop.
	jmp	short sr98

if98:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en98		; then end the $endloop

	mov	al,byte ptr result_val.$p_picked_val
	cmp	cx,1		; the first positional?
	jnz	if102
	mov	p_fcbs,al
	jmp	short en102

if102:
	mov	p_keep,al
en102:
	jmp	do98

en98:
	mov	al,p_fcbs	; M017
	mov	fcbs,al		; M017
	mov	keep,0		; M017
sr98:
	jmp	coff

;-------------------------------------------------------------------------
; comment= do nothing. just decrese chrptr,and increase count for correct
;		line number
;-------------------------------------------------------------------------

tryy:
	cmp	ah,'Y'
	jne	try0

donothing:
	dec	chrptr
	inc	count
	jmp	coff

;------------------------------------------------------------------------
; rem command
;------------------------------------------------------------------------

try0:				;do nothing with this line.
	cmp	ah,'0'
	je	donothing

;-----------------------------------------------------------------------
; switches command
;-----------------------------------------------------------------------
;****************************************************************************
;									    *
; function: parse the option switches specified.			    *
; note - this command is intended for the future use also.  when we need to *
; to set system data flag,use this command.				    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	p_swit_k set if /k option chosen.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di points to swit_parms;  /*parse control definition*/	    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val.$p_synonym_ptr == swit_k) then		    *
;		    p_swit_k = 1					    *
;	       endif							    *
;	  else {show error message;error exit}				    *
;	};								    *
; };									    *
;									    *
;****************************************************************************

	cmp	ah,'1'		;switches= command entered?
	je	do_try1
	jmp	tryt
do_try1:
	mov	di,offset swit_parms
	xor	cx,cx
	mov	dx,cx

do110:
	call	sysinit_parse
	jnc	if110		; parse error
	call	badparm_p	;  and show messages and end the search loop.
	jmp	short sr110

if110:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en110		; then jmp to $endloop for semantic check

	cmp	result_val.$p_synonym_ptr,offset swit_k
	jnz	if115		;				;M059
	mov	p_swit_k,1	; set the flag
	jmp	do110
if115:								;M059
	cmp	result_val.$p_synonym_ptr, offset swit_t	;M059
	jne	if116						;M059 M063
	mov	p_swit_t, 1					;M059
	jmp	do110						;M059
if116:
	cmp	result_val.$p_synonym_ptr, offset swit_w	;M063
	jne	do110						;M063
	mov	p_swit_w, 1					;M063
	jmp	do110						;M063
en110:
	cmp	p_swit_k,1	;if /k entered,

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data
	jnz	if117
	mov	keyrd_func,0	;use the conventional keyboard functions
	mov	keysts_func,1
if117:
;	mov	al, p_swit_t					;M059
;	mov	t_switch, al					;M059

	cmp	p_swit_w, 0					;M063
	je	skip_dos_flag					;M063
	push	es
	push	bx
	mov	ah, GET_IN_VARS					;M063
	int	21h						;M063
	or	byte ptr es:[DOS_FLAG_OFFSET], SUPPRESS_WINA20	;M063
	pop	bx
	pop	es
skip_dos_flag:							;M063
	pop	ds
	assume	ds:sysinitseg

sr110:
	jmp	coff

;------------------------------------------------------------------------
; NTCMDPROMPT command. This command forces SCS functionality to use
; cmd.exe prompt rather than command.com's prompt on shelling out
; and on finding a TSR.
;------------------------------------------------------------------------
tryt:
	cmp	ah,'T'
	je	tryt_5
        jmp     short tryo

tryt_5:
	push	si
	push	bp
	xor	ax,ax
	mov	bp,ax
	mov	si,ax
	mov	al,4
	mov	ah,setdpb
	int	21h
	pop	bp
	pop	si
	jmp	coff

;------------------------------------------------------------------------
; DOSONLY command. This command forces only DOS binaries to run from
; command.com prompt. non_dos binaries will putup the stub message
; of unable to run it under DOS.
;------------------------------------------------------------------------
tryo:
        cmp     ah,'O'
        je      tryo_5
        jmp     short tryz

tryo_5:
	push	si
	push	bp
	xor	ax,ax
	mov	bp,ax
	mov	si,ax
        mov     al,6
	mov	ah,setdpb
	int	21h
	pop	bp
	pop	si
        jmp     coff

;------------------------------------------------------------------------
; bogus command
;------------------------------------------------------------------------

tryz:
	cmp	ah,0ffh
	je	tryff

	dec	chrptr
	inc	count
	jmp	short badop

;------------------------------------------------------------------------
; null command
;------------------------------------------------------------------------

tryff:				;skip this command.
	jmp	donothing

doconf	endp

;------------------------------------------------------------------------------

sysinit_parse	proc
;set up registers for sysparse
;in)	es:si -> command line in  confbot
;	di -> offset of the parse control defintion.
;
;out)	calls sysparse.
;	carry will set if parse error.
;	*** the caller should check the eol condition by looking at ax
;	*** after each call.
;	*** if no parameters are found,then ax will contain a error code.
;	*** if the caller needs to look at the synomym@ of the result,
;	***  the caller should use cs:@ instead of es:@.
;	cx register should be set to 0 at the first time the caller calls this
;	 procedure.
;	ax - exit code
;	bl - terminated delimeter code
;	cx - new positional ordinal
;	si - set to pase scanned operand
;	dx - selected result buffer

	push	es			;save es,ds
	push	ds

	push	es
	pop	ds			;now ds:si -> command line

	push	cs
	pop	es			;now es:di -> control definition

	mov	cs:badparm_seg,ds	;save the pointer to the parm
	mov	cs:badparm_off,si	; we are about to parse for badparm msg.
	mov	dx,0
	call	sysparse
	cmp	ax,$p_no_error		;no error

;**cas note:  when zero true after cmp, carry clear

	jz	ll4
	cmp	ax,$p_rc_eol		;or the end of line?
	jnz	if4

ll4:
	clc
	jmp	short en4

if4:
	stc
en4:
	pop	ds
	pop	es
	ret
sysinit_parse	endp

;
;----------------------------------------------------------------------------
;
; procedure : badop_p
;
;             same thing as badop,but will make sure to set ds register back
;             to sysinitseg and return back to the caller.
;
;----------------------------------------------------------------------------
;
badop_p proc	near


	push	cs
	pop	ds			;set ds to configsys seg.
	mov	dx,offset badopm
	call	print
	call	error_line
	ret

badop_p endp
;
;----------------------------------------------------------------------------
;
; label : badop
;
;----------------------------------------------------------------------------
;
badop:	mov	dx,offset badopm	;want to print command error "unrecognized command..."
	call	print
	call	error_line		;show "error in config.sys ..." .
	jmp	coff


;
;----------------------------------------------------------------------------
;
; procedure : badparm_p
;
;             show "bad command or parameters - xxxxxx"
;             in badparm_seg,badparm_off -> xxxxx
;
;----------------------------------------------------------------------------
;
badparm_p	proc	near


	push	ds
	push	dx
	push	si

	push	cs
	pop	ds

	mov	dx,offset badparm
	call	print			;"bad command or parameters - "
	lds	si,badparm_ptr

;	print "xxxx" until cr.

do1:
	mov	dl,byte ptr [si]	; get next character
	cmp	dl,cr			; is a carriage return?
	jz	en1			; exit loop if so

	mov	ah,std_con_output	; function 2
	int	21h			; display character
	inc	si			; next character
	jmp	do1
en1:
	push	cs
	pop	ds

	mov	dx,offset crlfm
	call	print
	call	error_line

	pop	si
	pop	dx
	pop	ds
badparmp_ret:
	ret
badparm_p	endp

;
;----------------------------------------------------------------------------
;
; procedure : getchr
;
;----------------------------------------------------------------------------
;
getchr	proc	near
	push	cx
	mov	cx,count
	jcxz	nochar

	mov	si,chrptr
	mov	al,es:[si]
	dec	count
	inc	chrptr
	clc
get_ret:
	pop	cx
	ret

nochar: stc
	jmp	short get_ret
getchr	endp

;
;----------------------------------------------------------------------------
;
; procedure : incorrect_order
;
;             show "incorrect order in config.sys ..." message.
;
;----------------------------------------------------------------------------
;

incorrect_order proc	near

	mov	dx,offset badorder
	call	print
	call	showlinenum
	ret

incorrect_order endp

;
;----------------------------------------------------------------------------
;
; procedure : error_line
;
;             show "error in config.sys ..." message.
;
;----------------------------------------------------------------------------
;
		public	error_line
error_line	proc	near


	push	cs
	pop	ds
	mov	dx,offset errorcmd
	call	print
	call	showlinenum
	ret

error_line	endp

;
;----------------------------------------------------------------------------
;
; procedure : showlinenum
;
; convert the binary linecount to decimal ascii string in showcount
;and display showcount at the current curser position.
;in.) linecount
;
;out) the number is printed.
;
;----------------------------------------------------------------------------
;
showlinenum	proc	near


	push	es
	push	ds
	push	di

	push	cs
	pop	es		; es=cs

	push	cs
	pop	ds

	mov	di,offset showcount+4	; di -> the least significant decimal field.
	mov	cx,10			; decimal devide factor
	mov	ax,cs:linecount

sln_loop:
	cmp	ax,10			; < 10?
	jb	sln_last

	xor	dx,dx
	div	cx
	or	dl,30h			; add "0" (= 30h) to make it an ascii.
	mov	[di],dl
	dec	di
	jmp	sln_loop

sln_last:
	or	al,30h
	mov	[di],al
	mov	dx,di
	call	print			; show it.
	pop	di
	pop	ds
	pop	es
	ret
showlinenum	endp

comment ^
set_devmark	proc	near
;***************************************************************************
; function: set a paragraph of informations infront of a device file or    *
;	    an ifs file to be loaded for mem command.			   *
;	    the structure is:						   *
;	      devmark_id	byte "d" for device,"i" for ifs		   *
;	      devmark_size	size in para for the device loaded	   *
;	      devmark_filename	11 bytes. filename			   *
;									   *
; input :								   *
;	    [memhi] = address to set up devmark.			   *
;	    [memlo] = 0 						   *
;	    es:si -> pointer to [drive][path]filename,0 		   *
;	    [ifs_flag] = is_ifs bit set if ifs= command.		   *
;									   *
; output:   devmark_id,devmark_filename set				   *
;	    cs:[devmark_addr] set.					   *
;	    ax,cx register destroyed.					   *
;***************************************************************************

	push	ds
	push	si
	push	es
	push	di

	mov	di,cs:[memhi]
	mov	ds,di
	assume	ds:nothing
	mov	[devmark_addr],di	; save the devmark address for the future.
	mov	ds:[devmark_id],devmark_device	; 'd'
	inc	di
	mov	ds:[devmark_seg],di
	xor	al,al
	push	si
	pop	di			; now es:si = es:di = [path]filename,0
	mov	cx,128			; maximum 128 char
	repnz	scasb			; find 0
	dec	di			; now es:di-> 0
sdvmk_backward: 			; find the pointer to the start of the filename.
	mov	al,byte ptr es:[di]	; we do this by check es:di backward until
	cmp	al,'\' 		        ; di = si or di -> '\' or di -> ':'.
	je	sdvmk_gotfile
	cmp	al,':'
	je	sdvmk_gotfile
	cmp	di,si
	je	sdvmk_fileptr
	dec	di
	jmp	sdvmk_backward
sdvmk_gotfile:
	inc	di
sdvmk_fileptr:				; now es:di -> start of file name
	push	di			; cas - holy sh*t!!!  CODE!
	pop	si			; save di to si.

	push	ds			; switch es,ds
	push	es
	pop	ds
	pop	es			; now,ds:si -> start of filename

	mov	di,devmark_filename
	push	di
	mov	al,' '
	mov	cx,8
	rep	stosb			; clean up memory.
	pop	di
	mov	cx,8			; max 8 char. only
sdvmk_loop:
	lodsb
	cmp	al,'.'
	je	sdvmk_done
	cmp	al,0
	je	sdvmk_done
	stosb
	loop	sdvmk_loop

sdvmk_done:
	pop	di
	pop	es
	pop	si
	pop	ds
	ret
set_devmark	endp
^
; =========================================================================
;reset_dos_version	proc	near
;
;;function: issue ax=122fh,dx=0,int 2fh to restore the dos version.
;
;	push	ax
;	push	dx
;	mov	ax,122fh
;	mov	dx,0
;	int	2fh
;	pop	dx
;	pop	ax
;	ret
;reset_dos_version	endp
;
;
; =========================================================================

IFDEF	DONT_LOAD_OS2_DD		; M045

EXE_SIG		EQU	5a4dh		; .EXE file signature
OS2_SIG 	EQU	454eh		; OS2 .EXE file signature

SIGNATURE_LEN	EQU	2		; Lenght of .EXE signature in bytes
SIZE_DWORD	EQU	4

SEG_SIG_OFFSET	EQU	18h		; Offset of segmented .EXE signature
SEG_EXE_SIG	EQU	40h		; Signature of a segmented .EXE file
SEG_HEADER_PTR	EQU	3ch		; Offsets of ptr to segmented header

; =========================================================================
; CheckForOS2 PROC
;
; Examines an open file to see if it is really an OS2 executable file.
;
; REGISTERS:	AX	- Open file handle
; RETURNS:	Carry	- Carry set if file is an OS2 executable or error.
; DESTROYS:	NOTHING
;		NOTE:	The file ptr is assumed to be set to start of file
;			on entry and is not reset to begining of the file
;			on exit.
;
; Strategy:	If word value at 00h == 454eh file is OS2
;		else if word value at 00h == 5a4dh and
;		        (word value at 18h == 40h and the dword ptr at 3ch
;			 points to word value of 454eh) file is OS2.
;
; =========================================================================

CheckForOS2 PROC NEAR

	push	AX
	push	BX
	push	CX
	push	DX
	push	DS
	push	BP

	push	CS				; BUGBUG
	pop	DS				; NOT ROM DOS COMPATIBLE

	mov	BX,AX				; Put open file handle in BX
	mov	BP,offset DS:Os2ChkBuf		; Save buff offset for latter

		; First we need to read in the first 2 bytes of the file
		; to see if it's an OS2 .EXE file and if not see if 
		; it is a DOS .EXE file. 

	mov	AX,(read shl 8)			; AH = DOS read function
	mov	CX,SIGNATURE_LEN		; CX = size of word value
	mov	DX,BP				; DS:DX --> tmp buffer
	int	21h
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

	mov	AX, WORD PTR DS:Os2ChkBuf
	cmp	AX, OS2_SIG			; Check for 454eh
	je	IsOS2				; Return is OS2 if match
	cmp	AX, EXE_SIG			; Now see if it's a DOS .EXE
	jne	NotOS2				; If no match can't be OS2

		; Here we know the file has a valid DOS .EXE signature so
		; now we need to see if it's a segmented .EXE file by looking
		; for the segmented .EXE signature at file offset 18h

	mov	AX,(lseek shl 8)		; AX = Seek from begining
	xor	CX,CX
	mov	DX,SEG_SIG_OFFSET		; CX:DX = offset of segmented
	int	21h				; Seek to offset 18h
	jc	OS2ChkExit			; Return carry on error

	mov	AX,read shl 8			; AX = Read file
	mov	CX,SIGNATURE_LEN		; CX = size of word value
	mov	DX,BP				; Restore buffer offset
	int	21h 				; DS:DX -> buffer
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

	cmp	WORD PTR DS:Os2ChkBuf,SEG_EXE_SIG ; Chk for segmented .EXE file
	jne	NotOS2				; Can't be OS2 if no match

		; Here we know we have a segmented .EXE file so we have
		; to get the offset of the start of the segmented  header
		; from offset 3ch in the file.

	mov	AX,(lseek shl 8)		; AX = Seek from begining
	xor	CX,CX
	mov	DX,SEG_HEADER_PTR		; CX:DX = offset of head ptr
	int	21h				; Seek to offset 3ch
	jc	OS2ChkExit			; Return carry on error

	mov	AX,(read shl 8)			; AX = Read file
	mov	CX,SIZE_DWORD			; CX = size of dword (4 bytes)
	mov	DX,BP				; Restore buffer offset
	int	21h 				; Read in 4 byte offset
	jc	OS2ChkExit			; Return carry on error

	cmp	AX,SIZE_DWORD			; Check number of byte read
	jne	NotOs2				; Must be at end of file

		; At this point OS2ChkBuf has a 4 byte offset into the file
		; to the start of a segmented .EXE header so we need to read
		; the 2 bytes at this location to see if they are 454eh

	mov	DX,WORD PTR DS:Os2ChkBuf
	mov	CX,WORD PTR DS:Os2ChkBuf[2]	; CX:DX = offset of new header
	mov	AX,(lseek shl 8)		; AX = Seek from begining
	int	21h				; Seek to offset 3ch
	jc	OS2ChkExit			; Return carry on error

	mov	AX,(read shl 8)			; AX = Read file
	mov	CX,SIGNATURE_LEN		; CX = size of word (2 bytes)
	mov	DX,BP				; DS:DX --> Os2ChkBuf
	int	21h 				; Read in 4 byte offset
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

		; We have the segmented .EXE header in OS2ChkBuf so all
		; we have left to do is see if it's a .EXE signature.

	cmp	WORD PTR DS:OS2ChkBuf,OS2_SIG	; Check for 454eh
	jne	NotOs2				; Not OS2 if it doesn't match

IsOs2:
	stc					; Signal error or OS2 .EXE
	jmp	SHORT OS2ChkExit
NotOs2:
	clc					; Signal no err and not OS2

OS2ChkExit:
	pop	BP
	pop	DS
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret

CheckForOS2 ENDP

ENDIF						; M045

;
;----------------------------------------------------------------------------
;
; procedure : ProcDOS
;
;	Process the result of DOS= parsing
;
;	result_val.$p_item_tag	= 1 for DOS=HIGH
;				= 2 for DOS=LOW
;				= 3 for DOS=UMB
;				= 4 for DOS=NOUMB
;----------------------------------------------------------------------------
;
ProcDOS	proc	near
	assume	ds:nothing, es:nothing
	xor	ah, ah
	mov	al, result_val.$p_item_tag
	dec	ax
	jz	pd_hi
	dec	ax
	jz	pd_lo
	dec	ax
	jz	pd_umb
	mov	DevUMB, 0
	ret
pd_umb:
	mov	DevUMB, 0ffh
	ret
pd_lo:
	mov	runhigh, 0
	ret
pd_hi:
	mov	runhigh, 0ffh
	ret
ProcDOS	endp

;
;----------------------------------------------------------------------------
;
; procedure : LieInt12Mem
;
;	Input : DevEntry points to Device Start address (offset == 0)
;		alloclim set to the limit of low memory.
;
;	Output : none
;
;	Changes the ROM BIOS variable which stores the total low memory
;	If a 3com device driver (any character device with name 'PROTMAN$')
;	is being loaded alloclim is converted into Ks and stored in 40:13h
;	Else if a device driver being loaded into UMB the DevLoadEnd is
;	converted into Ks and stored in 40:13h
;
;----------------------------------------------------------------------------
;
LieInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		mov	ax, alloclim		; lie INT 12 as alloclim
						; assuming that it is 3Com
		call	IsIt3Com?		; Is it 3Com driver?
		je	lim_set			; yes, lie to him differently
		cmp	DeviceHi, 0		; Is the DD being loaded in UMB
		je	limx			; no, don't lie
		mov	ax, DevLoadEnd		; lie INT 12 as end of UMB
lim_set:
		call	SetInt12Mem
limx:
		ret
LieInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : SetInt12Mem
;
;	Input : AX = Memory size to be set (in paras)
;	Output : none
;
;	Sets the variable 40:13 to the memory size passed in AX
;	It saves the old value in 40:13 in OldInt12Mem,
;	It also sets a flag Int12Lied to 0ffh, which is checked before
;	restoring the value of 40:13
;
;----------------------------------------------------------------------------
;
SetInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		push	ds
		mov	bx, 40h
		mov	ds, bx			; ROM BIOS Data Segment
		mov	bx, word ptr ds:[13h]	; INT 12 memory variable
		mov	OldInt12Mem, bx		; save it
		mov	cl, 6
		shr	ax, cl			; convert paras into Ks
		mov	word ptr ds:[13h], ax	; Lie
		mov	Int12Lied, 0ffh		; mark that we are lying
		pop	ds
		ret
SetInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : TrueInt12Mem
;
;	Input : Int12Lied = 0 if we are not lying currently
;			  = 0ffh if we are lying
;		OldInt12Mem = Saved value of 40:13h
;
;	Output : none
;
;	Resets the INT 12 Memory variable if we were lying about int 12
;	and resets the flag which indicates that we were lying
;
;----------------------------------------------------------------------------
;
TrueInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		cmp	Int12Lied, 0		; were we lying so far?
		mov	Int12Lied, 0		; reset it anyway
		je	timx			; no, we weren't
		push	ds
		mov	ax, 40h
		mov	ds, ax
		mov	ax, OldInt12Mem
		mov	word ptr ds:[13h], ax	; restore INT 12 memory
		pop	ds
timx:
		ret
TrueInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : IsIt3Com?
;
;	Input : DevEntry = Seg:0 of device driver
;	Output : Zero flag set if device name is 'PROTMAN$'
;		 else Zero flag is reset
;
;----------------------------------------------------------------------------
;
IsIt3Com?	proc	near
		assume	ds:nothing, es:nothing, ss:nothing
		push	ds
		push	es
		push	si
		lds	si, DevEntry		; ptr to device header
		add	si, sdevname		; ptr device name
		push	cs
		pop	es
		mov	di, offset ThreeComName
		mov	cx, 8			; name length
		rep	cmpsb
		pop	si
		pop	es
		pop	ds
		ret
IsIt3Com?	endp

;M020 : BEGIN
;
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;
UpdatePDB	proc	near
		assume	ds:nothing
		push	ds
		mov	ah, 62h
		int	21h
		mov	ds, bx
		mov	bx, alloclim
		mov	ds:[PDB_Block_Len], bx
		pop	ds
		ret
UpdatePDB	endp
;
; M020 : END
;
;----------------------------------------------------------------------------
;
; procedure : InitDevLoad
;
;	Input : DeviceHi = 0 indicates load DD in low memory
;			 = 1 indicates load in UMB
;		DevSize  = Size of the device driver file in paras
;
;	Output : none
;
;	Initializes DevLoadAddr, DevLoadEnd & DevEntry.
;	Also sets up a header for the Device driver entry for mem utility
;
;----------------------------------------------------------------------------
;
InitDevLoad	proc	near

		assume	ds:nothing, es:nothing

		cmp	DeviceHi, 0		; Are we loading in UMB
		je	InitForLo		; no, init for lo mem
		call	SpaceInUMB?		; Do we have space left in the
						;  current UMB ?
		jnc	InitForHi		; yes, we have
		call	ShrinkUMB		; shrink the current UMB in use
		call	GetUMBForDev		; else try to allocate new UMB
		jc	InitForLo		; we didn't succeed, so load
						;  in low memory
InitForHi:
		mov	ax, DevUMBFree		; get Para addr of free mem
		mov	dx, DevUMBAddr		; UMB start addr
		add	dx, DevUMBSize		; DX = UMB End addr
		jmp	short idl1
		
InitForLo:
		mov	DeviceHi, 0		; in case we failed to load
						;  into UMB indicate that we
						;  are loading low
		mov	ax, memhi		; AX = start of Low memory
		mov	dx, alloclim		; DX = End of Low memory
idl1:
		call	DevSetMark		; setup a sub-arena for DD
		mov	DevLoadAddr, ax		; init the Device load address
		mov	DevLoadEnd, dx		; init the limit of the block
		mov	word ptr DevEntry, 0	; init Entry point to DD
		mov	word ptr DevEntry+2, ax
		ret
InitDevLoad     endp


;------------------------------------------------------------------
; NTVDM  08-Dec-1992 Jonle
;
; AllocUMBLow- Allocates a chunk from memory from UMB area
;              or from low memory area in case UMB memory
;              is unavailable.
;
; The arena is marked as
;
; Input:  es:di addr of arena name to copy
;         cx    size to allocate
;
; Output: es:di points to memory allocated
;
;------------------------------------------------------------------
AllocUMBLow  proc    near

             assume  ds:nothing, es:nothing

             mov     ax, cx              ; convert size to paras
             add     ax, 18              ; extra for dummy dev header for mem.exe
             call    pararound
             mov     DevSize, ax

             mov     word ptr [bpb_addr],   di  ; fake cmd line for dev name
             mov     word ptr [bpb_addr+2], es

             mov     al, DevUMB                 ; we want UMB
             mov     DeviceHi, al

             call    InitDevLoad

             mov     ax, word ptr DevEntry+2    ; mark arena for mem.exe
             dec     ax
             mov     es, ax
             mov     byte ptr es:[devmark_id], devmark_spc

             inc     ax                         ; mark final size
             add     ax, DevSize
             mov     word ptr DevBrkAddr+2,ax
             mov     word ptr DevBrkAddr, 0
             call    DevBreak

             mov     di, word ptr DevEntry      ; es:di -> deventry
             mov     ax, word ptr DevEntry+2
             mov     es, ax

AllocUMBLow  endp


;
;----------------------------------------------------------------------------
;
; procedure : SpaceInUMB?
;
;	Input : DevUMBAddr, DevUMBSize, DevUMBFree & DevSize
;	Output : Carry set if no space in UMB
;		 Carry clear if Space is available for the device in
;		   current UMB
;
;----------------------------------------------------------------------------
;
SpaceInUMB?	proc	near

		assume	ds:nothing, es:nothing

		mov	ax, DevUMBSize
		add	ax, DevUMBAddr		; End of UMB
		sub	ax, DevUMBFree		; - Free = Remaining space
		or	ax, ax			; Nospace ?
		jnz	@f
		stc
		ret
@@:
		dec	ax			; space for sub-arena
		cmp	ax, DevSize		; do we have space ?
		ret
SpaceInUMB?	endp

;
;----------------------------------------------------------------------------
;
; procedure : GetUMBForDev
;
;	Input : DevSize
;	Output : Carry set if couldn't allocate a UMB to fit the
;		 the device.
;		 If success carry clear
;
;	Allocates the biggest UMB for loading devices and updates
;	DevUMBSize, DevUMBAddr & DevUMBFree if it succeeded in allocating
;	UMB.
;
;	This routine relies on the fact that all of the low memory
;	is allocated, and any DOS alloc calls should return memory
;	from the UMB pool.
;
;----------------------------------------------------------------------------
;
GetUMBForDev	proc	near

		assume	ds:nothing, es:nothing

if 0
;;
		mov	bx, 0ffffh
		mov	ax, 4800h
		int	21h

		or	bx, bx
		jz	gufd_err

		dec	bx
		cmp	DevSize, bx
		ja	gufd_err
		inc	bx
		mov	ax, 4800h
		int	21h
		jc	gufd_err

		push	ds
		dec	ax
		mov	ds, ax
		mov	word ptr ds:[arena_owner], 8
		mov	word ptr ds:[arena_name], 'DS'
		inc	ax
		pop	ds

		mov	DevUMBSize, bx		; update the UMB Variables
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		clc				; mark no error
		ret
gufd_err:
		xor	ax, ax
		mov	DevUMBSize, ax		; erase the previous values
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		stc
		ret
else
;; we changed the allocation strategy to best-fit for NT. This is because
;; we want to reserve bigger blocks for loadhigh command. In most case,
;; device drivers are smaller than TSR(ran from loadhigh). This change give
;; us a better chance to load the big tsr like DOSX.EXE to UMB and
;; give applications more free conventional memory.
;; The following implementation seems slow because every time we need an
;; UMB, we go through the chain. This is done because each request has
;; different size - We can grab all UMBs from the very beginning and put
;; them in a list, but we have to maintain the list. -williamh
		push	cx
		push	dx
		push	es
		xor	cx, cx			;; allocated count = 0
		mov	dx, DevSize
		inc	dx			;; minimum size in paras
						;; bios needs its sub-arena
search_for_best_block:
		mov	bx, 0ffffh		;; get largest block size
		mov	ah, 48h 		;; so far
		int	21h
		cmp	bx, dx			;; will this satisfy ours?
		jb	allocate_the_block	;; no, break
		mov	ah, 48h			;; allocate this block
		int	21h
		jc	allocate_the_block	;; failed, use the previous one
		inc	cx			;; we have one more allocated
		push	bx			;; save the size
		push	ax			;; save the address
		jmp	short search_for_best_block

allocate_the_block:
;; the block saved on the top of the stack is the best fit one
;; grab it if there is one
		jcxz	gufd_err		;; no block found, error
		pop	ax			;; get the address
		pop	DevUMBSize		;; and size
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		dec	ax
		push	ds
		mov	ds, ax
		mov	word ptr ds:[arena_owner], 8
		mov	word ptr ds:[arena_name], 'DS'
		pop	ds
		dec	cx
;; now free those unnecessary blocks
		jcxz	allocate_done
free_allocated_blocks:
		pop	es			;; get the address
		add	sp, 2			;; discard the size
		mov	ah, 49h 		;; free it
		int	21h
		loop	free_allocated_blocks
allocate_done:
		clc				; mark no error
		jmp	short GetUMBForDevExit
gufd_err:
		xor	ax, ax
		mov	DevUMBSize, ax		; erase the previous values
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		stc
GetUMBForDevExit:
		pop	es
		pop	dx
		pop	cx
		ret
endif

GetUMBForDev	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevSetMark
;
;	Input : AX - Free segment were device is going to be loaded
;	Output : AX - Segment at which device can be loaded (AX=AX+1)
;
;	Creates a sub-arena for the device driver
;	puts 'D' marker in the sub-arena
;	Put the owner of the sub-arena as (AX+1)
;	Copies the file name into sub-arena name field
;
;	Size field of the sub-arena will be set only at succesful
;	completion of Device load.
;
;----------------------------------------------------------------------------
;
DevSetMark	proc	near

		assume	ds:nothing, es:nothing

		push	es
		push	di
		push	ds
		push	si
		mov	es, ax
		mov	byte ptr es:[devmark_id], devmark_device	; 'D'
		inc	ax
		mov	word ptr es:[devmark_seg], ax
;
;-------------- Copy file name
;
		push	ax			; save load addr
		lds	si, bpb_addr		; command line is still there
;M004 - BEGIN
		mov	di, si
		cld
dsm_again:
		lodsb
		cmp	al, ':'
		jne	isit_slash
		mov	di, si
		jmp	dsm_again
isit_slash:
		cmp	al, '\'
		jne	isit_null
		mov	di, si
		jmp	dsm_again
isit_null:

ifdef DBCS
		call	testkanj
		jz	@f		; if this is not lead byte
		lodsb			; get tail byte
@@:
endif

		or	al, al
		jnz	dsm_again
		mov	si, di
;M004 - END
		mov	di, devmark_filename
		mov	cx, 8			; maximum 8 characters
dsm_next_char:
		lodsb
		or	al, al
		jz	blankout
		cmp	al, '.'
		jz	blankout
		stosb
		loop	dsm_next_char
blankout:
		jcxz	dsm_exit
		mov	al, ' '
		rep	stosb			; blank out the rest
dsm_exit:
		pop	ax			; restore load addr
		pop	si
		pop	ds
		pop	di
		pop	es
		ret
DevSetMark	endp

;
;----------------------------------------------------------------------------
;
; procedure : SizeDevice
;
;	Input : ES:SI - points to device file to be sized
;
;	Output : Carry set if file cannot be opened or if it is an OS2EXE file
;
;	Calculates the size of the device file in paras and stores it
;	in DevSize
;
;----------------------------------------------------------------------------
;
SizeDevice	proc	near

		assume	ds:nothing, es:nothing

		push	es
		pop	ds
		mov	dx, si			; ds:dx -> file name
		mov	ax, 3d00h		; open
		int	21h
		jc	sd_err			; open failed

IFDEF	DONT_LOAD_OS2_DD			; M045
		call	CheckForOS2		; is it a OS2 EXE file ?
		jc	sd_close		; yeah, we dont load them
ENDIF						; M045

		mov	bx, ax			; BX - file handle
		mov	ax, 4202h		; seek
		xor	cx, cx
		mov	dx, cx			; to end of file
		int	21h
		jc	sd_close		; did seek fail (impossible)
		add	ax, 15			; para convert
		adc	dx, 0
		test	dx, 0fff0h		; size > 0ffff paras ?
		jz	@f			; no
		mov	DevSize, 0ffffh		; invalid device size
						; assuming that we fail later
		jmp	short sd_close
@@:
		mov	cl, 4			; conver it to paras
		shr	ax, cl
		mov	cl, 12
		shl	dx, cl
		or	ax, dx			;
		cmp	ax, DevSizeOption
		ja	@f
		mov	ax, DevSizeOption
@@:
		mov	DevSize, ax		; save file size
		clc
sd_close:
		pushf				; let close not spoil our
						;  carry flag
		mov	ax, 3e00h		; close
		int	21h			; we are not checking for err
		popf
sd_err:
		ret
SizeDevice	endp

;
;----------------------------------------------------------------------------
;
; procedure : ExecDev
;
;	Input : ds:dx -> device to be executed
;		DevLoadAddr - contains where device has to be loaded
;
;	Output : Carry if error
;		 Carry clear if no error
;
;	Loads a device driver using the 4b03h function call
;
;----------------------------------------------------------------------------
;
ExecDev		proc	near

		assume	ds:nothing, es:nothing

		mov	bx, DevLoadAddr
		mov	DevExecAddr, bx		; Load the parameter block
						;  block for exec with
						;  Load address
		mov	DevExecReloc, bx
		mov	bx,cs
		mov	es,bx
		mov	bx,offset DevExecAddr	;es:bx points to parameters
		mov	al,3
		mov	ah,exec
		int	21h			;load in the device driver
		ret
ExecDev		endp

;
;----------------------------------------------------------------------------
;
; procedure : RemoveNull
;
;	Input : ES:SI points to a null terminated string
;
;	Output : none
;
;	Replaces the null at the end of a string with blank
;
;----------------------------------------------------------------------------
;

RemoveNull	proc	near

		assume	ds:nothing, es:nothing

rn_next:
		mov	bl, es:[si]
		or	bl, bl			; null ?
		jz	rn_gotnull
		inc	si			; advance the pointer
		jmp	rn_next
rn_gotnull:
		mov	bl, DevSavedDelim
		mov	byte ptr es:[si], bl	; replace null with blank
		ret
RemoveNull	endp

;
;----------------------------------------------------------------------------
;
; procedure : RoundBreakAddr
;
;	Input : DevBrkAddr
;	Output : DevBrkAddr
;
;	Rounds DevBrkAddr to a para address so that it is of the form xxxx:0
;
;----------------------------------------------------------------------------
;
RoundBreakAddr	proc	near

		assume	ds:nothing, es:nothing

		mov	ax, word ptr DevBrkAddr
		call	pararound
		add	word ptr DevBrkAddr+2, ax
		mov	word ptr DevBrkAddr, 0
		mov	ax, DevLoadEnd
		cmp	word ptr DevBrkAddr+2, ax
		jbe	rba_ok
		jmp	mem_err
rba_ok:
		ret
RoundBreakAddr	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevSetBreak
;
;	Input : DevBrkAddr
;	Output : Carry set if Device returned Init failed
;		 Else carry clear
;
;----------------------------------------------------------------------------
;
DevSetBreak	proc	near

		assume	ds:nothing, es:nothing

		push	ax

		mov	ax,word ptr [DevBrkAddr+2]  ;remove the init code
		cmp	multdeviceflag, 0
		jne	set_break_continue	    ;do not check it.
		cmp	ax, DevLoadAddr
		jne	set_break_continue	    ;if not same, then o.k.

		cmp	word ptr [DevBrkAddr],0
		je	break_failed		;[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0

set_break_continue:
		call	RoundBreakAddr
		pop	ax
		clc
		ret
break_failed:
		pop	ax
		stc
		ret
DevSetBreak	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevBreak
;
;	Input : DevLoadAddr & DevBrkAddr
;	Output : none
;
;	Marks a succesful install of a device driver
;	Sets device size field in sub-arena &
;	Updates Free ptr in UMB or adjusts memhi
;
;----------------------------------------------------------------------------
;
DevBreak	proc	near

		assume	ds:nothing, es:nothing

		push	ds
		mov	ax, DevLoadAddr
		mov	bx, word ptr [DevBrkAddr+2]
		dec	ax			; seg of sub-arena
		mov	ds, ax
		inc	ax			; Back to Device segment
		sub	ax, bx
		neg	ax			; size of device in paras
		mov	ds:[devmark_size], ax	; store it in sub-arena
		cmp	DeviceHi, 0
		je	db_lo
		mov	DevUMBFree, bx		; update Free ptr in UMB
		jmp	short db_exit
db_lo:
		mov	memhi, bx
		mov	memlo, 0
db_exit:
		pop	ds
		ret
DevBreak	endp
;
;----------------------------------------------------------------------------
;
; procedure : ParseSize
;
;	Parses the command line for SIZE= command
;
;	ES:SI = command line to parsed
;
;	returns ptr to command line after SIZE= option in ES:SI
;	updates the DevSizeOption variable with value supplied
;	in SIZE=option
;	Returns carry if the SIZE option was invalid
;
;----------------------------------------------------------------------------
;
ParseSize	proc	near

		assume	ds:nothing, es:nothing

		mov	DevSizeOption, 0	; init the value
		mov	word ptr DevCmdLine, si
		mov	word ptr DevCmdLine+2, es
		call	SkipDelim
		cmp	word ptr es:[si], 'IS'
		jne	ps_no_size
		cmp	word ptr es:[si+2], 'EZ'
		jne	ps_no_size
		mov	al, es:[si+4]
		call	delim
		jne	ps_no_size
		add	si, 5
		call	GetHexNum
		jc	ps_err
		mov	DevSizeOption, ax
		call	SkipDelim
ps_no_size:
		clc
		ret
ps_err:
		stc
		ret
ParseSize	endp
;
;----------------------------------------------------------------------------
;
; procedure : SkipDelim
;
;	Skips delimiters in the string pointed to by ES:SI
;	Returns ptr to first non-delimiter character in ES:SI
;
;----------------------------------------------------------------------------
;
SkipDelim	proc	near

		assume	ds:nothing, es:nothing

sd_next_char:
		mov	al, es:[si]
		call	delim
		jnz	sd_ret
		inc	si
		jmp	sd_next_char
sd_ret:
		ret
SkipDelim	endp
;
;----------------------------------------------------------------------------
;
; procedure : GetHexNum
;
;	Converts an ascii string terminated by a delimiter into binary.
;	Assumes that the ES:SI points to a Hexadecimal string
;
;	Returns in AX the number number of paras equivalent to the
;	hex number of bytes specified by the hexadecimal string.
;
;	Returns carry in case it encountered a non-hex character or
;	if it encountered crlf
;
;----------------------------------------------------------------------------
;
GetHexNum	proc	near

		assume	ds:nothing, es:nothing

		xor	ax, ax
		xor	dx, dx
ghn_next:
		mov	bl, es:[si]
		cmp	bl, cr
		je	ghn_err
		cmp	bl, lf
		je	ghn_err
		push	ax
		mov	al, bl
		call	Delim
		pop	ax
		jz	ghn_into_paras
		call	GetNibble
		jc	ghn_err
		mov	cx, 4
ghn_shift1:
		shl	ax, 1
		rcl	dx, 1
		loop	ghn_shift1
		or	al, bl
		inc	si
		jmp	ghn_next
ghn_into_paras:
		add	ax, 15
		adc	dx, 0
		test	dx, 0fff0h
		jnz	ghn_err
		mov	cx, 4
ghn_shift2:
		clc
		rcr	dx, 1
		rcr	ax, 1
		loop	ghn_shift2
		clc
		ret
ghn_err:
		stc
		ret
GetHexNum	endp
;
;----------------------------------------------------------------------------
;
; procedure : GetNibble
;
;	Convert one nibble (hex digit) in BL into binary
;
;	Retruns binary value in BL
;
;	Returns carry if BL contains non-hex digit
;
;----------------------------------------------------------------------------
;
GetNibble	proc	near
		cmp	bl, '0'
		jb	gnib_err
		cmp	bl, '9'
		ja	is_it_hex
		sub	bl, '0'			; clc
		ret
is_it_hex:
		cmp	bl, 'A'
		jb	gnib_err
		cmp	bl, 'F'
		ja	gnib_err
		sub	bl, 'A'- 10		; clc
		ret
gnib_err:
		stc
		ret
GetNibble	endp
;
;
;============================================================================
;============================================================================
;
;----------------------------------------------------------------------------
;
; procedure : AllocUMB
;
;	Allocate all UMBs and link it to DOS arena chain
;
;----------------------------------------------------------------------------
;
AllocUMB	proc	near
		call	InitAllocUMB		; link in the first UMB
		jc	au_exit			; quit on error
au_next:
		call	umb_allocate		; allocate
		jc	au_coalesce
		call	umb_insert		; & insert till no UMBs
		jmp	short au_next
au_coalesce:
		call	umb_coalesce		; coalesce all UMBs
au_exit:
		ret
AllocUMB	endp
;
;----------------------------------------------------------------------------
;
; procedure : InitAllocUMB
;
;----------------------------------------------------------------------------
;
InitAllocUMB	proc	near
		call	IsXMSLoaded
		jnz	iau_err			; quit on no XMS driver
		mov	ah, 52h
		int	21h			; get DOS DATA seg
		mov	DevDOSData, es		; & save it for later
		mov	ax, 4310h
		int	2fh
		mov	word ptr DevXMSAddr, bx	; get XMS driver address
		mov	word ptr DevXMSAddr+2, es
		cmp	FirstUMBLinked, 0	; have we already linked a UMB?
		jne	@f			; quit if we already did it
		call	LinkFirstUMB		; else link the first UMB
		jc	iau_err
		mov	FirstUMBLinked, 0ffh	; mark that 1st UMB linked
@@:
		clc
		ret
iau_err:
		stc
		ret
InitAllocUMB	endp

;-------------------------------------------------------------------------
;
; Procedure Name	: umb_allocate
;
; Inputs		: DS = data
;
; Outputs		: if UMB available
;				Allocates the largest available UMB and 
;			  	BX = segment of allocated block
;				DX = size of allocated block
;				NC
;			  else 
;				CY
;
; Uses			: BX, DX
;
;-------------------------------------------------------------------------

umb_allocate	proc	near

		push	ax
		mov	ah, XMM_REQUEST_UMB
		mov	dx, 0ffffh		; try to allocate largest
						;   possible
		call	dword ptr DevXMSAddr
						; dx now contains the size of
						; the largest UMB
		or	dx, dx
		jz	ua_err
	
		mov	ah, XMM_REQUEST_UMB
		call	dword ptr DevXMSAddr

		cmp	ax, 1			; Q: was the reqst successful
		jne	ua_err			; N: error

		clc

ua_done:
		pop	ax
		ret		

ua_err:
		stc
		jmp	short ua_done

umb_allocate	endp



;---------------------------------------------------------------------------
;
; Procedure Name	: umb_insert
;
; Inputs		: DOSDATA:UMB_HEAD = start of umb chain
;			: BX = seg address of UMB to be linked in
;			: DX = size of UMB to be linked in paras
;			; DS = data
;
; Outputs		: links the UMB into the arena chain
;
; Uses			: AX, CX, ES, DX, BX
;
;---------------------------------------------------------------------------


umb_insert	proc	near

		push	ds

		mov	ds, [DevDOSData]
		mov	ds, ds:[UMB_ARENA]	; es = UMB_HEAD
		mov	ax, ds
		mov	es, ax

ui_next:
		cmp	ax, bx			; Q: is current block above
						;    new block
		ja	ui_insert     		; Y: insert it
						; Q: is current block the
						;    last
		cmp	es:[arena_signature], arena_signature_end
		jz	ui_append		; Y: append new block to chain
						; N: get next block

		mov	ds, ax			; M005
		call	get_next		; ax = es = next block
		jmp	short ui_next

ui_insert:
	
		mov	cx, ds			; ds = previous arena
		inc	cx			; top of previous block

		sub	cx, bx
		neg	cx			; cx = size of used block
		mov	ds:[arena_signature], arena_signature_normal
		mov	ds:[arena_owner], 8	; mark as system owned
		mov	ds:[arena_size], cx	
		mov	word ptr ds:[arena_name], 'CS'

; prepare the arena at start of new block

		mov	es, bx
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], arena_owner_system
						; mark as free
		sub	dx, 2			; make room for arena at
						; start & end of new block
		mov	es:[arena_size], dx	
		
; prepare arena at end of new block
	
		add	bx, dx
		inc	bx
		mov	es, bx			; es=arena at top of new block
		inc	bx			; bx=top of new block

						; ax contains arena just above
						; this block
		sub	ax, bx			; ax = size of used block
	
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'

		jmp	short ui_done

ui_append:

						; es = arena of last block	

		add	ax, es:[arena_size]	; ax=top of last block-1 para
		sub	es:[arena_size], 1	; reflect the space we are
						; going to rsrv on top of this 
						; block for the next arena.
		mov	es:[arena_signature], arena_signature_normal

		mov	cx, ax			; cx=top of prev block-1
		inc	ax
		sub	ax, bx			; ax=top of prev block - 
						;    seg. address of new block

		neg	ax

		mov	es, cx			; ds = arena of unused block


		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'

; prepare the arena at start of new block

		mov	es, bx
		mov	es:[arena_signature], arena_signature_end
		mov	es:[arena_owner], arena_owner_system
						; mark as free
		dec	dx			; make room for arena
		mov	es:[arena_size], dx	

ui_done:
		pop	ds
		ret

umb_insert	endp


;
;----------------------------------------------------------------------------
;
;**	umb_coalesce - Combine free blocks ahead with current block
;
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	cx, di, ds, es
;
;----------------------------------------------------------------------------
;

umb_coalesce	proc	near



		xor	di, di

		mov	es, [DevDOSData]
		mov	es, es:[UMB_ARENA]	; es = UMB_HEAD

uc_nextfree:
		mov	ax, es
		mov	ds, ax
		cmp	es:[arena_owner], di	; Q: is current arena free
		jz	uc_again		; Y: try to coalesce with next block
						; N: get next arena
		call	get_next		; es, ax = next arena
		jc	uc_done
		jmp	short uc_nextfree
uc_again:
		call	get_next		; ES, AX <- next block
		jc	uc_done
uc_check:
		cmp     es:[arena_owner],di	; Q: is arena free
		jnz	uc_nextfree		; N: get next free arena
						; Y: coalesce
		mov     cx,es:[arena_size]      ; cx <- next block size
		inc     cx                      ; cx <- cx + 1 (for header size)
		add     ds:[arena_size],cx      ; current size <- current size + cx
		mov     cl,es:[di]              ; move up signature
		mov     ds:[di],cl
		jmp     short uc_again		; try again
uc_done:
		ret

umb_coalesce	endp

;
;----------------------------------------------------------------------------
;
;**	get_next - Find Next item in Arena
;
;	ENTRY	dS - pointer to block head
;	EXIT	AX,ES - pointers to next head
;		'C' set iff arena damaged
;
;----------------------------------------------------------------------------
;

get_next	proc	near

		cmp	byte ptr ds:[0], arena_signature_end
		je	gn_err

		mov     ax,ds                   ; ax=current block
		add     ax,ds:[arena_size]      ; ax=ax + current block length
		inc     ax                      ; remember that header!
		mov	es, ax
		clc
		ret
gn_err:
		stc
		ret

get_next	endp

;
;----------------------------------------------------------------------------
;
; procedure : LinkFirstUMB
;
;----------------------------------------------------------------------------
;
LinkFirstUMB	proc	near

		call	umb_allocate
		jc	lfu_err

; bx = segment of allocated UMB
; dx = size of UMB

		int	12h			; ax = size of memory
		mov	cl, 6
		shl	ax, cl			; ax = size in paragraphs

		mov	cx, ax			; cx = size in paras
		sub	ax, bx			; ax = - size of unused block

		neg	ax

		sub	cx, 1			; cx = first umb_arena
		mov	es, cx			; es = first umb_arena
	
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
					
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'


; put in the arena for the first UMB

		mov	es, bx			; es has first free umb seg
		mov	es:[arena_signature], arena_signature_end
		mov	es:[arena_owner], arena_owner_system	
						; mark as free 
		dec	dx			; make room for arena
		mov	es:[arena_size], dx	


		mov	es, [DevDOSData]
		mov	di, UMB_ARENA
		mov	es:[di], cx		; initialize umb_head in DOS
						;  data segment with the arena
						;  just below Top of Mem

; we must now scan the arena chain and update the size of the last
; arena

		mov	di, DOS_ARENA
		mov	es, word ptr es:[di]	; es = start arena
		xor	di, di

	
scan_next:
		cmp	byte ptr es:[di], arena_signature_end
		jz	got_last
	
		mov	ax, es
		add	ax, es:[arena_size]
		inc	ax
		mov	es, ax
		jmp	short scan_next

got_last:
;; -williamh- we reserved the last paragraph for UMB_HEAD already.
;; refer to sysinit1.asm!goinit
;; The following instruction was commentted out for this reason.
;;		sub	es:[arena_size], 1
;;
		mov	es:[arena_signature], arena_signature_normal
		clc
		ret

lfu_err:
		stc
		ret
LinkFirstUMB	endp

;
;----------------------------------------------------------------------------
;
; procedure : ShrinkUMB
;
;	Shrinks the current UMB in use, so that the unused portions
;	of the UMB is given back to the DOS free mem pool
;
;----------------------------------------------------------------------------
;
		public	ShrinkUMB

ShrinkUMB	proc	near
		cmp	DevUMBAddr, 0
		je	su_exit
		push	es
		push	bx
		mov	bx, DevUMBFree
		sub	bx, DevUMBAddr
		mov	es, DevUMBAddr
		mov	ax, 4a00h
		int	21h
		mov	ax, es
		dec	ax
		mov	es, ax
		mov	word ptr es:[arena_owner], 8
		pop	bx
		pop	es
su_exit:
		ret
ShrinkUMB	endp

;M002 - BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : UnlinkUMB
;
;	Unlinks the UMBs from the DOS arena chain
;
;----------------------------------------------------------------------------
;
		public	UnlinkUMB

UnlinkUMB	proc	near
		push	ds
		push	es
		cmp	FirstUMBLinked, 0
		je	ulu_x			; nothing to unlink
		mov	es, DevDOSData		; get DOS data seg
		mov	ds, es:[DOS_ARENA]
		mov	di, es:[UMB_ARENA]
ulu_next:
		call	get_next
		jc	ulu_x
		cmp	di, ax			; is the next one UMB ?
		je	ulu_found
		mov	ds, ax
		jmp	ulu_next
ulu_found:
		mov	ds:[arena_signature], 'Z'	
ulu_x:
		pop	es
		pop	ds
		ret
UnlinkUMB	endp

;M002 - END

; =========================================================================
;
sysinitseg	ends
		end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\bios\sysinit1.asm ===
page	,160
	title	bios	system initialization
;
;----------------------------------------------------------------------------
;
; Modification history
;
; 26-Feb-1991  sudeepb	Ported for NT DOSEm
;----------------------------------------------------------------------------

break	macro	; dummy empty macro
	endm
	include version.inc
	include biosseg.inc
	include sysvar.inc
	include curdir.inc
	include pdb.inc
	include exe.inc
	include sf.inc
	include arena.inc
	include syscall.inc
	include devsym.inc
	include ioctl.inc
	include biostruc.inc
	include dossym.inc
	include	dosmac.inc
	include	mult.inc
        include dossvc.inc
        include dbgsvc.inc
        include cmdsvc.inc
        include xmssvc.inc
        include vint.inc

Bios_Code	segment
	extrn	BCode_start:near
	extrn	BCode_end:near
	extrn	seg_reinit:far

Bios_Code	ends

	include devmark.inc
	include cputype.inc


true	equ	0ffffh
false	equ	0
cr	equ	13
lf	equ	10
tab	equ	9

;multMULT		equ	4ah
multMULTGETHMAPTR	equ	1
multMULTALLOCHMA	equ	2


stacksw equ     true                    ;include switchable hardware stacks
mycds_size equ	71			; size of curdir_list. if it is not
					;the same, then will generate compile error.

if DEBUG				; BUGBUG - Jeez, remove this!
  dossize equ	0b200h
else
  dossize equ	0a000h
endif

	if	ibmjapver
noexec	equ	   true
	else
noexec	equ	   false
	endif

;     if mycds_size <> curdirlen,then force a compilatiaon error.

	if	mycds_size ne curdirlen
	%out	!!! sysinit1 compilation failed. different cds size !!!
	.errne	mycds_size eq curdirlen
	endif

	if	not ibmjapver
	extrn	 re_init:far
	endif

	ifdef	TAIWAN
	extrn	cdosinit:near
	endif

;---------------------------------------

Bios_Data	segment

;equates for main stack and stack initialization program

	if	stacksw

	extrn	NextStack:dword		; Win386 Instance table stuff
	extrn	IT_StackLoc:dword	;  we have to plug in so that our
	extrn	IT_StackSize:word	;  stacks can be instanced

entrysize   equ     8

mincount    equ     8
defaultcount equ    9
maxcount    equ     64

minsize     equ     32
defaultsize equ     128
maxsize     equ     512

allocbyte   equ     0
intlevel    equ     1
savedsp     equ     2
savedss     equ     4
newsp	    equ     6

free	    equ     0
allocated   equ     1
overflowed  equ     2
clobbered   equ     3






;	 external variables in ibmbio for int19h handling rouitne.

	extrn	 int19sem:byte

	irp	   aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
	extrn	 int19old&aa:dword
	endm
	endif


;---------------------------------------
; external variable defined in ibmbio module for multi-track
multrk_on equ	10000000b		;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
multrk_off1 equ 00000000b		;initial value. no "multitrack=" command entered.
multrk_off2 equ 00000001b		;user specified multitrack=off.

	extrn	multrk_flag:word
;
;SR; Win386 present flag
;
	extrn	IsWin386:BYTE
;
;SR; Added for SetFocus routine for WIN386 support
;
         extrn	V86_Crit_SetFocus:far

	extrn	xms:dword		; entry point for xms driver
	extrn	inHMA:byte		; flag meaning we're running high

	extrn	FreeHMAPtr:word
	extrn	MoveDOSIntoHMA:dword
	extrn	SysinitPresent:byte
        extrn   DemInfoFlag:byte
	extrn	spc_mse_int10:dword
	extrn	int29Perf:dword

	extrn	outchr:near
Bios_Data       ends

; NTVDM 16-Sep-1992 Jonle
; Softpc Kbd, mouse, emm drivers
SpcKbdSeg  segment
        extrn   InstSpcKbd:near
        extrn   SpcKbdBeg:byte
        extrn   SpcKbdEnd:byte
	extrn	int10h_vector:near
SpcKbdSeg  ends

SpcMseSeg  segment
        extrn   InstSpcMse:near
        extrn   SpcMseBeg:byte
        extrn   SpcMseEnd:byte
SpcMseSeg  ends

SpcEmmSeg  segment
        extrn   InitSpcEmm:near
        extrn   SpcEmmBeg:byte
        extrn   SpcEmmEnd:byte
	extrn	SI_end:byte
SpcEmmSeg  ends




sysinitseg segment
        assume  cs:sysinitseg, ds:nothing,es:nothing,ss:nothing

	extrn	badcom:byte
        extrn   condev:byte
	extrn	auxdev:byte
        extrn   prndev:byte
        extrn   commnd:byte
	extrn	devmark_addr:word
	extrn	setdevmarkflag:byte
	extrn	pathstring:byte

	extrn	print:near
	extrn	int24:near
	extrn	mem_err:near
	extrn	doconf:near
        extrn   multi_pass:near

	extrn	badload:near
	extrn	error_line:near

	extrn	ShrinkUMB:near
	extrn	UnlinkUMB:near					;M002
	extrn	AllocUMB:near
        extrn   toomanydrivesmsg:byte                           ; M029


        ;NTVDM
        extrn   MseDev:byte              ; internal mouse driver name
        extrn   AllocUMBLow:near         ; mem alloc for new internal drivers
        extrn   bEchoConfig:byte
        extrn   config:byte

        public  current_dos_location
	public	device_list
	public	sysi_country
	public	memory_size
	public	default_drive
	public	buffers
	public	files
	public	num_cds
	public	sysinit
	public	cntryfilehandle
	public	command_line

	if	stacksw 		; internal stack information
	public	stack_count
	public	stack_size
	public	stack_addr
	endif

	public	dosinfo
	public	fcbs
	public	keep
	public	confbot
	public	alloclim
	public	zero
	public	sepchr
	public	count
	public	chrptr
	public	org_count
	public	bufptr
	public	memlo
	public	prmblk
	public	memhi
	public	ldoff
	public	area
	public	packet
	public	unitcount
	public	break_addr
        public  bpb_addr
	public	drivenumber
	public	config_size
	public	install_flag
	public	com_level
	public	cmmt
	public	cmmt1
	public	cmmt2
	public	cmd_indicator
	public	linecount
	public	showcount
	public	buffer_linenum
	public	donotshownum
	public	h_buffers
	public	configmsgflag
	public	do_install_exec
	public	multi_pass_id
	public	temp_bcode_seg
	public	seg_reinit_ptr

        public toomanydrivesflag			; M029

sysinit$:
	if	stacksw
.sall

;	interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - at level)
;	should follow the standard interrupt sharing scheme which has
;	a standard header structure.
;	fyi, the following shows the relations between
;	the interrupt vector and interrupt level.
; vec(hex)    2  8  9  a  b  c	d  e  70  72  73  74  76  77
; lvl(deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
;	msstack module modifies the following interrupt vectors
;	to meet the standard interrupt sharing standard;
;	  a, b, c, d, e, 72, 73, 74, 76, 77.
;	also, for interrupt level 7 and 15, the firstflag in a standard header
;	should be initialized to indicat whether this interrupt handler is
;	the first (= 80h) or not.  the firstflag entry of int77h's
;	program header is initialized in this module.
;	firstflag is only meaningful for interrupt level 7 and 15.
;

;  user specifies the number of stack elements - default = 9
;						 minimum = 8
;						 maximum = 64
;
;  intercepts asynchronous hardware interrupts only
;
;  picks a stack from pool of stacks and switches to it
;
;  calls the previously saved interrupt vector after pushing flags
;
;  on return, returns the stack to the stack pool
;


; this is a modification of stacks:
; 1. to fix a bug which was causing the program to take up too much space.
; 2. to dispense stack space from hi-mem first rather than low-mem first.
;    . clobbers the stack that got too big instead of innocent stack
;    . allows system to work if the only stack that got too big was the most
;      deeply nested one
; 3. disables nmi interrupts while setting the nmi vector.
; 4. double checks that a nested interrupt didn't get the same stack.
; 5. intercepts ints 70, 72-77 for pc-ats and other future products

		even
		dw	0	; spare field but leave these in order
stackcount	dw	0
stackat 	dw	0
stacksize	dw	0
stacks		dw	0
		dw	0

firstentry	dw	stacks
lastentry	dw	stacks+(defaultcount*entrysize)-entrysize
nextentry	dw	stacks+(defaultcount*entrysize)-entrysize


; these are the individual interrupt handlers

	assume	ds:nothing,es:nothing,ss:nothing

public	int02
public	old02
	old02	dd	0
int02	proc	far

;; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;;
;; *********************************************************************
;;
;; this is special support for the pc convertible / nmi handler
;;
;;       on the pc convertible, there is a situation where an nmi can be
;;       caused by using the "out" instructions to certain ports.  when this
;;       occurs, the pc convertible hardware *guarantees* that **nothing**
;;       can stop the nmi or interfere with getting to the nmi handler.  this
;;       includes other type of interrupts (hardware and software), and
;;       also includes other type of nmi's.  when any nmi has occured,
;;       no other interrtupt (hardware, software or nmi) can occur until
;;       the software takes specific steps to allow further interrupting.
;;
;;       for pc convertible, the situation where the nmi is generated by the
;;       "out" to a control port requires "fixing-up" and re-attempting.  in
;;       otherwords, it is actually a "restartable exception".  in this
;;       case, the software handler must be able to get to the stack in
;;       order to figure out what instruction caused the problem, where
;;       it was "out"ing to and what value it was "out"ing.  therefore,
;;       we will not switch stacks in this situation.  this situation is
;;       detected by interrogating port 62h, and checking for a bit value
;;       of 80h.  if set, *****do not switch stacks*****.
;;
;; *********************************************************************
;
;        push    ax
;        push    es
;        mov     ax,0f000h
;        mov     es,ax
;        cmp     byte ptr es:[0fffeh],mdl_convert        ;check if convertible
;        pop     es
;        jne     normal02
;
;        in      al,62h
;        test    al,80h
;        jz      normal02
;
;special02:
;        pop     ax
;        jmp     dword ptr old02
;
;normal02:
;        pop     ax
;

        call    do_int_stacks
        dw      old02

int02	endp

public	int08
public	old08
old08	dd	0
int08	proc	far
	call	do_int_stacks
	dw	old08
int08	endp

public	int09
public	old09
old09	dd	0
int09	proc	far

; keyboard interrupt must have a three byte jump, a nop and a zero byte
; as its first instruction for compatibility reasons

	ifidn	<09>,<09>
	jmp	short keyboard_lbl
	nop
	db	0
keyboard_lbl	label	near
	endif

	call	do_int_stacks
	dw	old09
int09	endp

public	int70
public	old70
old70	dd	0
int70	proc	far
	call	do_int_stacks
	dw	old70
int70	endp

	irp	a,<0a,0b,0c,0d,0e,72,73,74,76,77>
public	int&a
public	old&a
public	firstflag&a
int&a	proc	far
	jmp	short entry_int&a&_stk
old&a	dd	  0		;forward pointer
	dw	  424bh 	;compatible signature for int. sharing
firstflag&a db   0		;the firstly hooked.
	jmp	short intret_&a	;reset routine. we don't care this.
	db	7 dup (0)	;reserved for future.
entry_int&a&_stk:
	call	do_int_stacks
	dw	old&a
intret_&a:
        jmp     DOIRET
int&a	endp
        endm


DOCLI:
    FCLI
    ret
DOSTI:
    FSTI
    ret
DOIRET:
    FIRET


;********************************************************************
;common routines

;	do interrupt stack switching.  the fake return address holds
;	  a pointer to the far-pointer of the actual interrupt
;	  service routine

do_int_stacks:
	push	ax
	push	bp
	push	es
	mov	es, cs:[stacks+2]	; get segment of stacks

	mov	bp,nextentry		; get most likely candidate
	mov	al,allocated
	xchg	es:byte ptr allocbyte[bp],al		; grab the entry
	cmp	al,free 		; still avail?
	jne	notfree02

	sub	nextentry,entrysize	; set for next interrupt

found02:
	mov	es:word ptr savedsp[bp],sp		; save sp value
	mov	es:word ptr savedss[bp],ss		; save ss also

	mov	ax,bp			; temp save of table offset


	mov	bp,es:word ptr newsp[bp]		; get new sp value
	cmp	es:[bp],ax		; check for offset into table
	jne	foundbad02

	push	bp
	mov	bp,sp
	mov	ax,8[bp]		; get offset of interrupt vector
	pop	bp

	push	es			; ss:sp = new stack
	pop	ss
	mov	sp,bp

	mov	bp,ax			; get pointer to interrupt vector
	mov	bp,cs:[bp]
	pushf				; go execute the real interrupt handler
	call	cs:dword ptr [bp]	; call the old interrupt vector

	mov	bp,sp			; retrieve the table offset for us
	mov	bp,es:[bp]		;  but leave it on the stack
	mov	ss,es:word ptr savedss[bp]		; get old stack back
	mov	sp,es:word ptr savedsp[bp]


	mov	es:byte ptr allocbyte[bp],free		; free the entry
	mov	nextentry,bp		; setup to use next time

newerror02:
	pop	es
	pop	bp			; saved on entry
	pop	ax			; saved on entry
	add	sp,2			; lose the fake return address

intret_02:
        jmp     DOIRET                  ; done with this interrupt

notfree02:
	cmp	al,allocated		; error flag
	je	findnext02		;  no, continue
	xchg	es:byte ptr allocbyte[bp],al		;  yes, restore error value

findnext02:
	call	longpath
	jmp	found02

foundbad02:
	cmp	bp,firstentry
	jc	findnext02
	mov	bp,ax			; flag this entry
	mov	es:byte ptr allocbyte[bp],clobbered
	jmp	findnext02		; keep looking
longpath:
	mov	bp,lastentry		; start with last entry in table

lploopp:
	cmp	es:byte ptr allocbyte[bp],free		; is entry free?
	jne	inuse			;  no, try next one

	mov	al,allocated
	xchg	es:byte ptr allocbyte[bp],al		; allocate entry
	cmp	al,free 		; is it still free?
	je	found			;  yes, go use it

	cmp	al,allocated		; is it other than allocated or free?
	je	inuse			;  no, check the next one

	mov	es:byte ptr allocbyte[bp],al		;  yes, put back the error state

inuse:
	cmp	bp,firstentry
	je	fatal
	sub	bp,entrysize
	jmp	lploopp

found:
	ret

fatal   proc    near

; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;
;        push    ds
;        mov     ax, 0f000h              ;look at the model byte
;        mov     ds, ax
;        cmp     ds:byte ptr [0fffeh], mdl_convert ;convertible?
;        pop     ds
;        jne     skip_nmis
;
;        mov     al,07h                          ; disable pc convertible nmis
;        out     72h,al
;
;skip_nmis:

        call    DOCLI                           ; disable and mask
	mov	al,0ffh 			;   all other ints
	out	021h,al
	out	0a1h,al

	mov	si,cs
	mov	ds,si
	mov	si,offset fatal_msg

;SR;
;   We set all foci to this VM to issue the stack failure message
;
	push	ax
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume 	ds:Bios_Data

	test	ds:[IsWin386],1
	pop	ds
	pop	ax
	assume	ds:nothing
	jz	fatal_loop	;win386 not present, continue

	call	V86_Crit_SetFocus	;set focus to this VM
;
;SR; We do not bother about the returned status of this call.
;

fatal_loop:
	lodsb
	cmp	al,'$'
	je	fatal_done

	mov	bl,7
	mov	ah,14
	int	010h			; whoops, this enables ints
	jmp	fatal_loop

fatal_done:
	jmp	fatal_done
fatal	endp

	include msbio.cl5		;fatal stack error message
.xall
	public	endstackcode
endstackcode label  byte
	endif

sysinit:
	jmp	goinit
;
;----------------------------------------------------------------------------
;
DDHighInfo	struc
 ddhigh_CSegPtr	dd	?		; pointer to code segment to be relocated
 ddhigh_CSegLen	dw	?		; length of code segment to be relocated
 ddhigh_CallBak	dd	?		; pointer to the call back routine
DDHighInfo	ends

		public	runhigh
runhigh		db	0h


dosinfo	dd	0		; address of the DOS Sysini Variables

dos_temp_location label	dword
dosinit	dw	0
current_dos_location dw 0

device_list dd	0

sysi_country dd	0			; pointer to country table in dos

dos_segreinit	dw	0,0		; room for dword

lo_doscod_size	dw	0		; dos code size when in low mem
hi_doscod_size	dw	0		; dos code size when in HMA

def_php		dw	0


; M022--
; pointer for calling into Bios_Code for re-initializing segment values.
;  call with ax = new segment for Bios_Code.  Notice that we'll
;  call it in its temporary home, cuz seg_reinit won't get moved to
;  the new home.

seg_reinit_ptr	label dword

		dw	offset Bios_Code:seg_reinit
temp_bcode_seg	dw	Bios_Code


;variables for stack initialization program.

	if	stacksw
stack_count dw	    defaultcount
stack_size  dw	    defaultsize
stack_addr  dd	    0
	endif

; various default values

memory_size	dw	1
RPLMemTop	dw	0
default_drive	db	0		;initialized by ibminit.
buffers 	dw	-1		; initialized during buffer allocation
h_buffers	dw	0		; # of the heuristic buffers. initially 0.
singlebuffersize dw	?		; maximum sector size + buffer header

files	db	8			; enough files for pipe
fcbs	db	4			; performance for recycling
keep	db	0			; keep original set
num_cds db	1			; minimum needed is 1, so that initialization does'nt have a problem
confbot dw	?
alloclim dw	?
DirStrng db	"A:\",0                 ; string for the root directory of a drive
command_line db 2,0,"P" 		;default command.com args
	db	125 dup (0)
zero	db	0
sepchr	db	0
linecount dw	0			;  line count in config.sys
showcount db	'     ',cr,lf,'$'	;  used to convert linecount to ascii.
buffer_linenum dw 0			; line count for "buffers=" command if entered.


buf_prev_off dw 0

	if	not noexec
comexe	exec0	 <0,command_line,default_drive,zero>
	endif

;------------------------------------------------------------------
;	variables for install= command.

multi_pass_id	db	0		; parameter passed to multi_pass
					;  indicating the pass number
					; 0 - do scan for DOS=HIGH/LOW
					; 1 - load device drivers
					; 2 - was to load IFS
					;      now it is unused
					; 3 - do install=
					; >3 - nop
install_flag	dw	0

have_install_cmd equ	00000001b	; config.sys has install= commands
has_installed	equ	00000010b	; sysinit_base installed.

config_size	dw	0		; size of config.sys file. set by sysconf.asm
sysinit_base_ptr dd	0		; pointer to sysinit_base
sysinit_ptr	dd	0		; returning addr. from sysinit_base
checksum	dw	0		; used by sum_up

ldexec_fcb	db	20 dup (' ')	;big enough
ldexec_line	db	0		;# of parm characters
ldexec_start	db	' '
ldexec_parm	db	80 dup (0)

instexe exec0	<0,ldexec_line,ldexec_fcb,ldexec_fcb>

;------------------------------------------------------------------
;variables for comment=

com_level	db	0		;level of " " in command line
cmmt		db	0		;length of comment string token
cmmt1		db	0		;token
cmmt2		db	0		;token
cmd_indicator	db	?
donotshownum	db	0

;------------------------------------------------------------------
count		dw	0
org_count	dw	0
chrptr		dw	0
cntryfilehandle dw	0
old_area	dw	0
impossible_owner_size dw 0		; paragraph
;------------------------------------------------------------------

bucketptr label dword
bufptr	label	dword			;leave this stuff in order!
memlo	dw	0
prmblk	label	word
memhi	dw	0
ldoff	dw	0
area	dw	0

packet	db	24			; was 22
	db	0
	db	0			;initialize code
	dw	0
	db	8 dup (?)

unitcount	db	0
break_addr	dd	0
bpb_addr	dd	0
drivenumber	db	0
configmsgflag	dw	0		; used to control "error in config.sys line #" message

toomanydrivesflag db    0               ;>24 fixed disk partitions flag   ; M029

BCodeSeg        dw      Bios_Code




;SR;
; This is the communication block between the DOS and the BIOS. It starts at
;the SysinitPresent flag. Any other data that needs to be communicated
;to the DOS should be added after SysinitPresent. The pointer to this block
;is passed to DOS as part of the DOSINIT call.
;

BiosComBlock	dd	Bios_Data:SysinitPresent

tempstack db	80h dup (?)

goinit:

ifdef JAPAN
	mov	ah,50h			; set crt mode
	mov	al,0
	mov	bx,81			; for JAPAN
	int	10h
	mov	ah,50h			; set keyboard mode
	mov	al,0
	mov	bx,81			; for JAPAN
	int	16h
endif
	cld

;; Before we installed spckbd.asm (we hook a lot of vectors there),
;; we shouldn't invoke any interrupt calls directly to bios(they will
;; go directly to ROM bios). Since we do know what exactly those ROM
;; bios(s) do, a safer manner is to issue bop to our 32 bits side.
;;	int	12h			; Get Memory in 1k
	BOP	12h
	mov	cl,6
	shl	ax,cl			;convert to 16-byte blocks(segment no.)
	mov	cx,ax
	dec	cx			; one para for an arena at end of mem
					; in case of UMBs
	mov	memory_size,cx

	push	cs
	pop	ds
	xor	si,si
	mov	di,si
        mov     ax, offset sysinitgrp:SI_end   ; need this much room for sysinit
	call	off_to_para
	sub	cx,ax

; we need to leave room for the DOS and for the BIOS
; code above sysinit in memory
;
	sub	cx,dossize/16		; leave this much room for DOS

	mov	ax,offset BCode_end
	call	off_to_para		; leave this much room for BIOS code
	sub	cx,ax

	mov	es,cx			; offset where sysinit will be located
        mov     cx,offset sysinitgrp:SI_end
	shr	cx,1			;divide by 2 to get words
	rep	movsw			;relocate sysinit

	push	es			; push relocated segment
	mov	ax,offset sysin
	push	ax			; push relocated entry point

	retf				; far jump to relocated sysinit


;	move the dos to its proper location

sysin:
	assume	ds:nothing,es:nothing,ss:nothing

	mov	ax, Bios_Data		; point DS to BIOS data
	mov	ds, ax

	assume	ds:Bios_Data

	mov	word ptr MoveDOSIntoHMA+2, cs	; set seg of routine to move DOS
	mov	SysinitPresent, 1	; flag that MoveDOSIntoHMA can be called

        SVC     SVC_ISDEBUG
        mov     DemInfoFlag, al

        test    al,ISDBG_DEBUGGEE
        je      @f
        SAVEREG <bx,dx,es>
        mov     bx, cs                  ; current base of BIOS
        xor     cx, cx
        mov     dx, current_dos_location; get offset of end of code
        sub     dx, bios_data           ; add in length of data segment
        REPT    4
        shl     dx, 1
        rcl     cx, 1
        endm

        mov     ax, SYMOP_LOAD SHL 8 + ID_NTIO
        SVC     SVC_DEMSYSTEMSYMBOLOP

        mov     bx, 1                   ; bugbug: Hardcoded segment number
        mov     ax, ds                  ; low segment location
        mov     es, ax                  ; relocated segment

        mov     ax, SYMOP_MOVE SHL 8 + ID_NTIO
        SVC     SVC_DEMSYSTEMSYMBOLOP

        RESTOREREG <es,dx,bx>
@@:

; first move the MSDOS.SYS image up to a harmless place
; on top of our new sysinitseg

        mov     ax,offset sysinitgrp:SI_end        ; how big is sysinitseg?
	call	off_to_para
	mov	cx,cs			; pick a buffer for msdos above us
	add	ax,cx
	mov	es,ax
	xor	si,si
	mov	di,si

	mov	ds,[current_dos_location] ; where it is (set by msinit)

	assume	ds:nothing

	mov	cx,dossize/2
	rep	movsw
	mov	[current_dos_location],es

; The DOS code is ORGed at a non-zero value to allow it to be located in
; HIMEM.  Thus, the DOS segment location must be adjusted accordingly.

	mov	ax,ds:word ptr 3	; get offset of dos
	mov	[dosinit],ax		; that's the entry point offset
	call	off_to_para		; subtract this much from segment
	sub	[current_dos_location],ax


; BIOS code is moved to the top of memory
; until it is determined whether it will be running in HIMEM or not.


; now put Bios_Code up on top of that.  Assume Bios_Code + dossize < 64k

	mov	ax,es
	add	ax,dossize/16		; get paragraph of end of dos
	mov	es,ax
	xchg	ax,temp_bcode_seg	; swap with original home of Bios_Code
	mov	ds,ax			; point to loaded image of Bios_Code

	assume	ds:nothing

	mov	si,offset BCode_start
	mov	di,si
	mov	cx,offset BCode_end
	sub	cx,si
	shr	cx,1
	rep	movsw			; move Bios_Code into place

	mov	ax,es			; tell it what segment it's in
	call	[seg_reinit_ptr]	; far call to seg_reinit in Bios_Code (M022)


;	now call dosinit while it's in its temporary home

	les	di,cs:[BiosComBlock]	; ptr to BIOS communication block
	lds	si,cs:[device_list]	; set for call to dosinit

	assume	ds:nothing, es:nothing

	mov	dx,cs:[memory_size]	; set for call to dosinit

        call    DOCLI
	mov	ax,cs
	mov	ss,ax
	align	2		; assembler wouldn't let me do an "and 0fffeh"
locstack label	byte		;  on the mov sp,offset locstack
	mov	sp,offset locstack	; set stack

        call    DOSTI


; This call to DOSINIT will relocate the DOS data from its present location
; at the top of memory, to its final location in low memory just above the
; BIOS data.  It will then build important DOS data structures in low
; memory following the DOS data.  It returns (among many other things) the
; new starting address of free memory.

	call	[dos_temp_location]	; call dosinit
					;es:di -> sysinitvars_ext

	mov	[def_php],ds		; save pointer to PSP
	mov	[hi_doscod_size],ax	; size of doscode (including exepatch)
	mov	[lo_doscod_size],cx	; (not including exepatch)
	mov	[dos_segreinit],dx	; save offset of segreinit

	mov	ax,word ptr es:[di.sysi_initvars]
	mov	word ptr dosinfo,ax
	mov	ax,word ptr es:[di.sysi_initvars+2]
	mov	word ptr [dosinfo+2],ax ;set the sysvar pointer

	mov	ax,word ptr es:[di.sysi_country_tab]
	mov	word ptr [sysi_country],ax
	mov	ax,word ptr es:[di.sysi_country_tab+2]
	mov	word ptr [sysi_country+2],ax ;set the sysi_country pointer

	mov	es,[current_dos_location]	; give dos its temporary loc.
	mov	[dos_segreinit+2],es
;
	les	di,dosinfo		;es:di -> dosinfo

	clc				;get the extended memory size

;	execute the get extended memory size subfunction in the bios int 15h
;	if the function reports an error do nothing else store the extended
;	memory size reported at the appropriate location in the dosinfo buffer
;	currently pointed to by es:di.	use the offsets specified in the
;	definition of the sysinitvars struct in inc\sysvar.inc

	mov	ah,88h
;; IBM ps/2 90 int 15(ah = 88h) read a coms byte(0B6h) which we don't support.
;; it returns 0 on this query.
;; we issue a bop to 32bits to get the real extended memeory size
;;	int	15h			;check extended memory size
	BOP	15h
;;	jc	no_ext_memory
	mov	es:[di].sysi_ext_mem,ax ;save extended memory size
;;	or	ax, ax
no_ext_memory:
	mov	ax,es:[di.sysi_maxsec]	; get the sector size
	add	ax,bufinsiz		; size of buffer header
	mov	[singlebuffersize],ax	; total size for a buffer

	SVC	SVC_DEMGETBOOTDRIVE
	mov	[default_drive],al
	mov	es:[di.sysi_boot_drive],al ; set sysi_boot_drive

; determine if 386 system...
if 1
        get_cpu_type                    ; macro to determine cpu type
        cmp     ax,2                    ; is it a 386?
        jne     not_386_system          ; no: don't mess with flag
endif

	mov	es:[di.sysi_dwmove],1
not_386_system:
	mov	al,es:[di.sysi_numio]
	mov	drivenumber,al		; save start of installable block drvs

	mov	ax,cs
	sub	ax,11h			; room for PSP we will copy shortly
	mov	cx,[singlebuffersize]	; temporary single buffer area
	shr	cx,1			
	shr	cx,1			; divide size by 16...
	shr	cx,1
	shr	cx,1			; ...to get paragraphs...
	inc	cx			; ... and round up

;	cas note:  this unorthodox paragraph rounding scheme wastes a byte if
;	  [singlebuffersize] ever happens to be zero mod 16.  Could this
;	  ever happen?  Only if the buffer overhead was zero mod 16, since
;	  it is probably safe to assume that the sector size always will be.
;
;	 mohans also found a bug in CONFIG.SYS processing where it replaces
;	  EOF's with cr,lf's, without checking for collision with [confbot].
;	  perhaps the extra byte this code guarantees is what has kept that
;	  other code from ever causing a problem???

	sub	ax,cx
	mov	[confbot],ax		; temp "unsafe" location
;	push	es			; preserve pointer to DOSINFO data
;	push	di

; setup and initialize the temporary buffer

;	les	di,es:[di.sysi_buf]	;get the buffer chain entry pointer
;	mov	word ptr es:[di.Dirty_Buff_Count],0
;	mov	word ptr es:[di.Buff_Queue],0
;	mov	word ptr es:[di.Buff_Queue+2],ax
;	mov	es,ax
;	xor	ax,ax
;	mov	di,ax			;es:di -> single buffer

;	mov	es:[di.buf_next],ax	;points to itself
;	mov	es:[di.buf_prev],ax	;points to itself

;	mov	word ptr es:[di.buf_id],00ffh ;free buffer,clear flag
;	mov	word ptr es:[di.buf_sector],0
;	mov	word ptr es:[di.buf_sector+2],0

;	pop	di			; restore pointer to DOSINFO data
;	pop	es

	push	cs
	pop	ds

	assume	ds:sysinitseg

	call	tempcds 		; set up cdss so re_init and sysinit
					;   can make disk system calls
	assume	ds:nothing		; tempcds trashes ds

	mov	ds,[def_php]		; retreive pointer to PSP returned by DOSINIT

	if	not ibmjapver
	call	re_init			; re-call the bios
	endif

        call    DOSTI                   ; ints ok
	cld				; make sure

; dosinit has set up a default "process" (php) at ds:0. we will move it out
; of the way by putting it just below sysinit at end of memory.

	mov	bx,cs
	sub	bx,10h
	mov	es,bx
	xor	si,si
	mov	di,si
	mov	cx,80h
	rep	movsw

	mov	word ptr es:[pdb_jfn_pointer + 2],es ; relocate
	mov	ah,set_current_pdb
	int	21h			; tell dos we moved it

	push	ds			; preserve DS returned by DOSINIT
	push	cs
	pop	ds			; point DS to sysinitseg

	assume	ds:sysinitseg

	; set up temp. critical error handler
	mov	dx,offset int24 	;set up int 24 handler
	mov	ax,(set_interrupt_vector shl 8) or 24h
	int	21h

        cmp     byte ptr [TooManyDrivesFlag],0  ;Q: >24 partitions? M029
        je      no_err                          ;  N: continue      M029
        mov     dx,offset TooManyDrivesMsg      ;  Y: print error message M029
        call	print                           ;		    M029
no_err:						;		    M029

	pop	ds			; start of free memory

	assume	ds:nothing

	mov	dl,[default_drive]
	or	dl,dl
	jz	nodrvset		; bios didn't say
	dec	dl			; a = 0
	mov	ah,set_default_drive
	int	21h			;select the disk

nodrvset:

;
; Process the CONFIG.SYS file
;

ProcessConfig:

;
; NTVDM store temp file name for config.sys, 23-Nov-1992 Jonle
;
        push    ds
        push    cs
        pop     ds
        assume  ds:sysinitseg
        mov     dx,offset config        ; ds:dx points file description
        CMDSVC  SVC_GETCONFIGSYS
        pop     ds
        assume  ds:nothing


ifndef  TAIWAN

	call	doconf			;do pre-scan for dos=high/low

else	; taiwan

	call	chkoemlocaldrv
	mov	cs:oemdriverinst,ax
	call	cdosinit
	push	es
	push	bx

	pop	bx
	pop	es
	call	maketempvector		;make dummy int service routine

	call	doconf			;do pre-scan for dos=high/low

	call	chklocalexist		;check if local dev drv exist
					;if not found,system halt
	call	recovercsiint		;recover csi interrupt vector
endif	; taiwan



; Now, we decide what to do with the DOS code.
; It will either be relocated to low memory, above the DOS data structures,
; or else it will be located in HiMem, in which case a stub with the DOS
; code entry points will be located in low memory.  Dos_segreinit is used
; to tell the DOS data where the code has been placed, and to install the
; low memory stub if necessary.  If the DOS is going to go into HiMem, we
; must first initialize it in its present location and load the installable
; device drivers.  Then, if a HiMem driver has been located, we can actually
; relocate the DOS code into HiMem.
;

; M025 begin

	cmp	runhigh, 0		; Did user choose to run low ?
	je	dont_install_stub	; yes, don't install dos low mem stub
;
;------ user chose to load high
;


	mov	es,[current_dos_location]	; give dos its temporary loc.

	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit
	jmp	short do_multi_pass
	
;
;------ User chose to load dos low
;
dont_install_stub:

	xor	bx, bx			; M012
					;  don't use int 21 call to alloc mem

	call	MovDOSLo		; move it !


	mov	ax, 1			; dont install stub
	mov	es, current_dos_location; set_dos_final_position set it up
	call	dword ptr dos_segreinit	; inform dos about new seg


do_multi_pass:

	call	AllocFreeMem		; allocate all the free mem
					;  & update [memhi] & [area]
					; start of free memory.

; M025 end



; NTVDM
; Copy softpc keyboard driver resident code to start of free mem
; Install Softpc IVT hooks
        mov     al,devmark_spc
        call    setdevmark
        mov     es, cs:[devmark_addr]
        mov     word ptr es:[arena_name], 'BK'
        mov     word ptr es:[arena_name+2], 'D'

        cld
	mov	ax,[memhi]
        push    ds
        mov     cx,Bios_Data
	mov	ds,cx
	assume	ds:Bios_Data
	mov	word ptr spc_mse_int10,offset int10h_vector
	mov	word ptr spc_mse_int10+2,ax
	mov	word ptr int29Perf,offset outchr    ; sudeepb 03-Nov-1992
	mov	word ptr int29Perf+2,ds 	    ; added for int10 performance
	pop	ds
        assume  ds:nothing

        mov     es,ax           ;es dest seg. for SpcKbd
        push    es
        push    cs
        pop     ds              ;ds src seg for SpcKbd
        mov     si,offset sysinitgrp:SpcKbdBeg
        mov     cx,offset sysinitgrp:SpcKbdEnd
        sub     cx,si
        xor     di,di
        mov     [memlo],cx
        or      [setdevmarkflag],for_devmark
        call    round
        rep     movsb
        pop     ds
        call    sysinitgrp:InstSpcKbd

        ; save value of int09 for int 09 hardware stack disable
        xor     ax,ax
        mov     ds,ax
        mov     si, 09h*4
        lodsw
        mov     word ptr cs:old09, ax
        lodsw
        mov     word ptr cs:old09+2, ax

        ; save value of int08 for int 08 hardware stack disable
        mov     si, 08h*4
        lodsw
        mov     word ptr cs:old08, ax
        lodsw
        mov     word ptr cs:old08+2, ax


; NTVDM
; Attempt to init emm memory manager. if we have emm
; then load internal emm stub device driver.
;
        ; check if emm memory is available
        mov    ax, [memhi]
        inc    ax                              ;1 para for arena header
        mov    ds, ax                          ;expected seg for emm drv
        call   sysinitgrp:InitSpcEmm
        cmp    ax, 0
        jne    NoEmmServices

        ; fill in the arena name
        mov     al, devmark_device
        call    setdevmark
        mov     es, cs:[devmark_addr]
        mov     word ptr es:[arena_name], 'ME'
        mov     word ptr es:[arena_name+2], 'M'

        ; copy in emm stub driver code
        cld
	mov	ax,[memhi]
        mov     es,ax
        push    es                              ;save for diddling devheader
        push    cs
        pop     ds
        mov     si,offset sysinitgrp:SpcEmmBeg
        mov     cx,offset sysinitgrp:SpcEmmEnd
        sub     cx,si
        xor     di,di
        mov     [memlo],cx
        or      [setdevmarkflag],for_devmark
        call    round
        rep     movsb

        ; link in emm stub driver
        ; so apps can find emm driver
        pop     ds
        xor     si, si                          ;ds:si = device header
        les     di, cs:[dosinfo]                ;es:di = to dos info
        mov     cx,word ptr es:[di.sysi_dev]    ;dx:cx = head of list
        mov     dx,word ptr es:[di.sysi_dev+2]
        mov     word ptr es:[di.sysi_dev],si    ;set head of list in dos
        mov     word ptr es:[di.sysi_dev+2],ds
        mov     word ptr ds:[si],  cx           ;link in the driver
        mov     word ptr ds:[si+2], dx

NoEmmServices:


; Now, process config.sys some more.
; Load the device drivers and install programs
        inc     cs:multi_pass_id        ; multi_pass_id = 1
        call    multi_pass              ; load device drivers


; NTVDM
; Install Softpc Mouse driver in UMB if can else in LOW memory
; This must be done after himem.sys is loaded for umb support
;
        mov     cx, offset sysinitgrp:SpcMseEnd
        sub     cx, offset sysinitgrp:SpcMseBeg  ; cx,    size of SpceMse
        mov     di, offset MseDev
        push    cs
        pop     es                      ; es:di,  dest
        push    cx                      ; preserve cx
        call    AllocUMBLow
        pop     cx
        push    es                      ; save to pass to InstSpcMse

        mov     si, offset sysinitgrp:SpcMseBeg
        push    cs
        pop     ds                      ; ds:si, Source of SpcMse code
        rep     movsb

        pop     ds
        call    sysinitgrp:InstSpcMse



        call    ShrinkUMB
	call	UnlinkUMB		; unlink all UMBs	;M002
	inc	cs:multi_pass_id	; multi_pass_id = 2
        call    multi_pass              ; was load ifs (now does nothing)
        call    endfile                 ; setup fcbs, files, buffers etc

;
;Reset SysinitPresent flag here. This is needed for the special fix for lying
;to device drivers. This has been moved up to this point to avoid problems
;with overlays called from installed programs
;
	mov	ax,Bios_Data
	mov	es,ax			; point ES to bios data

	assume	es:Bios_Data

	mov	es:SysinitPresent,0	; clear SysinitPresent flag

	test	install_flag,have_install_cmd ; are there install commands?
	jz	dolast			; no, no need for further processing
	inc	cs:multi_pass_id	; mult_pass_id = 3
	call	multi_pass		; execute install= commands
dolast:
	assume	es:nothing

; [area] has the segment address for the allocated memory of sysinit, confbot.
;  free the confbot area used for config.sys and sysinit itself.


; Now if DOS is supposed to run high, we actually move it into high memory
; (if HiMem manager is available).
;
; There is also this little hack for CPM style DOS calls that needs to
; be done when A20 is set...

	cmp	runhigh, 0ffh		; are we still waiting to be moved?
	jne	@f			; no, our job is over
	call	LoadDOSHiOrLo
@@:

	cmp	runhigh, 0		; are we running low
	je	@f			; yes, no CPM hack needed
	call	CPMHack			; make ffff:d0 same as 0:c0
@@:


; We are now done with CONFIG.SYS processing

ConfigDone:
;; let NTVDM knows that we have done config.sys processing
	xor	al, al			;config.sys done
	BOP	BOP_NOTIFICATION	;
	call	AllocUMB		; allocate remaining UMBs if there are any
        mov     cs:[donotshownum],1     ; done with config.sys. do not show line number message.
	mov	es,[area]

	assume	es:nothing

	mov	ah,49h			; free allocated memory for command.com
	int	21h

	test	cs:[install_flag],has_installed ; sysinit_base installed?
	jz	skip_free_sysinitbase	; no.

;set block from the old_area with impossible_owner_size.
;this will free the unnecessary sysinit_base that had been put in memory to
;handle install= command.

	push	es
	push	bx
	mov	es,cs:[old_area]
	mov	bx,cs:[impossible_owner_size]
	mov	ah,setblock
	int	21h
	mov	ax,es
	dec	ax
	mov	es,ax			;point to arena
	mov	es:[arena_owner],8	;set impossible owner
	mov	word ptr es:[arena_name], 'DS'	; System Data
	pop	bx
	pop	es

skip_free_sysinitbase:

if	noexec
	mov	bp,ds			;save command.com segment
	push	ds
	pop	es
	mov	bx,cs
	sub	bx,10h			; point to current php
	mov	ds,bx
	xor	si,si
	mov	di,si
	mov	cx,80h
	rep	movsw			; copy it to new location for shell
	mov	word ptr es:[pdb_jfn_pointer + 2],es ; relocate
	mov	bx,es
	mov	ah,set_current_pdb
	int	21h			; tell dos we moved it
	mov	es:[pdb_parent_pid],es	;we are the root
endif ; noexec

	push	cs
	pop	ds			; point DS to sysinitseg

	assume	ds:sysinitseg

; set up the parameters for command

	mov	si,offset command_line+1

if	noexec
	mov	di,81h
else
	push	ds
	pop	es
	mov	di,si
endif

	mov	cl,-1
comtranlp:				;find length of command line
	inc	cl
	lodsb
	stosb				;copy command line in
	or	al,al
	jnz	comtranlp
	dec	di
	mov	al,cr			; cr terminate
	stosb

if	noexec
	mov	es:[80h],cl		; set up header
	mov	al,[default_drive]
	mov	es:[5ch],al
else
	mov	[command_line],cl	;count
endif

	mov	dx,offset commnd	;now pointing to file description


if	noexec
	mov	es,bp		;set load address
	mov	bx,100h
	call	dfil		;read in command
	jc	comerr
	mov	ds,bp
	mov	dx,80h
	mov	ah,set_dma	;set disk tranfer address
	int	21h
        call    DOCLI
	mov	ss,bp
	mov	sp,dx
        call    DOSTI
	xor	ax,ax		;push a word of zeros
	push	ax
	push	bp		;set high part of jump address
	mov	ax,100h
	push	ax		;set low part of jump address
	retf			;crank up command!

else ; not noexec

; we are going to open the command interpreter and size it as is done in
; ldfil.  the reason we must do this is that sysinit is in free memory.  if
; there is not enough room for the command interpreter,exec will probably
; overlay our stack and code so when it returns with an error sysinit won't be
; here to catch it.  this code is not perfect (for instance .exe command
; interpreters are possible) because it does its sizing based on the
; assumption that the file being loaded is a .com file.  it is close enough to
; correctness to be usable.

	push	dx		; save pointer to name

; first, find out where the command interpreter is going to go.

	mov	bx,0ffffh
	mov	ah,alloc
	int	21h		;get biggest piece
	mov	ah,alloc
	int	21h		; second time gets it
	jc	memerrjx	; oooops

	mov	es,ax
	mov	ah,dealloc
	int	21h		; give it right back
	mov	bp,bx

; es:0 points to block,and bp is the size of the block
;   in para.

; we will now adjust the size in bp down by the size of sysinit. we
;   need to do this because exec might get upset if some of the exec
;   data in sysinit is overlayed during the exec.

	mov	bx,[memory_size] ; get location of end of memory
	mov	ax,cs		; get location of beginning of sysinit
	sub	bx,ax		; bx is size of sysinit in para
	add	bx,11h		; add the sysinit php
	sub	bp,bx		; sub sysinit size from amount of free memory
	jc	memerrjx	; if there isn't even this much memory, give up

	mov	ax,(open shl 8)	;open the file being execed
	stc			;in case of int 24
	int	21h
	jc	comerr		; ooops

	mov	bx,ax		;handle in bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	stc			;in case of int 24
	int	21h		; get file size in dx:ax
	jc	comerr
				; convert size in dx:ax to para in ax
	add	ax,15		; round up size for conversion to para
	adc	dx,0
	call	off_to_para
	mov	cl,12
	shl	dx,cl		; low nibble of dx to high nibble
	or	ax,dx		; ax is now # of para for file
	add	ax,10h		; 100h byte php
	cmp	ax,bp		; will command fit in available mem?
	jb	okld		; jump if yes.
memerrjx:
	jmp	mem_err

okld:
	mov	ah,close
	int	21h		; close file

	pop	dx		; recover pointer to name
	push	cs		; point es to sysinitseg
	pop	es
	mov	bx,offset comexe ; point to exec block
	mov	word ptr [bx.exec0_com_line+2],cs ; set segments
	mov	word ptr [bx.exec0_5c_fcb+2],cs
	mov	word ptr [bx.exec0_6c_fcb+2],cs
	xor	ax,ax		;load and go
	mov	ah,exec
	stc			;in case of int 24
	int	21h		;go start up command
	endif

; note fall through if exec returns (an error)

comerr:
	mov	dx,offset badcom ;want to print command error
	extrn	badfil:near
	call	badfil
	public	stall
stall:	SVC	SVC_DEMEXITVDM		; Will Kill The VDM

;
;----------------------------------------------------------------------------
; procedure : AllocFreeMem
;
; Allocate Max memory from DOS to find out where to load DOS.
; DOS is at temporary location when this call is being made
;
; Inputs : None
; Outputs: The biggest chunk of memory is allocated (all mem at init time)
;	   [area] & [memhi] set to the para value of the start of the
;	   free memory.
;
; Uses   : AX, BX
;
;----------------------------------------------------------------------------
;
AllocFreeMem	proc	near

	assume	es:nothing, ds:nothing
	mov	bx,0ffffh
	mov	ah,alloc
	int	21h			;first time fails
	mov	ah,alloc
	int	21h			;second time gets it
	mov	[area],ax
	mov	[memhi],ax		; memhi:memlo now points to
	ret
					; start of free memory
AllocFreeMem	endp

;	start M000
	include	msbio.cl6
;	end M000

;
;----------------------------------------------------------------------------
;
; procedure : LoadDOSHiOrLo
;
;		Tries to move DOS into HMA. If it fails then loads
;		DOS into Low memory.
;
;----------------------------------------------------------------------------
;

LoadDOSHiOrLo	proc	near
	call	TryToMovDOSHi			; Try moving it into HMA (M024)
	jc	LdngLo				; If that don't work...
	ret
LdngLo:
	push	cs
	pop	ds
	mov	ah, 9
	mov	dx, offset DOSLOMSG		; inform user that we are
	int	21h				;  loading low

	; actually move the dos, and reinitialize it.

	mov	bx, 1				; M012
						;  use int 21 alloc for mem
	call	MovDOSLo
	mov	es,[current_dos_location]	; give dos its temporary loc.
	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit

	mov	runhigh, 0			; mark that we are running lo
	ret
LoadDOSHiOrLo	endp


;
;----------------------------------------------------------------------------
;
; procedure : TryToMovDOSHi
;
;		This tries to move DOS into HMA.
;		Returns CY if it failed.
;		If it succeeds returns with carry cleared.
;
;
;----------------------------------------------------------------------------
;

		public	TryToMovDOSHi

TryToMovDOSHi	proc	near
	call	MovDOSHi
	jc	ttldhx


	mov	es,[current_dos_location]	; give dos its temporary loc.

	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit

	mov	runhigh, 1
	clc
ttldhx:
	ret
TryToMovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOSHi
;
;		Tries to allocate HMA and Move DOS/BIOS code into HMA
;
;		Returns : CY if it failed
;
;----------------------------------------------------------------------------
;

MovDOSHi	proc	near
	call	AllocHMA
	jc	mdhx				; did we get HMA?
	mov	ax, 0ffffh			; yes, HMA seg = 0ffffh
	mov	es, ax

	; actually move the BIOS and DOS

	call	MovBIOS				; First move BIOS into HMA

	; ES:DI points to free HMA after BIOS

	mov	cx, hi_doscod_size		; pass the code size of DOS
						;  when it is in HMA
	call	MovDOS				; and move it

	; ES:DI points to free HMA after DOS

	call	SaveFreeHMAPtr			; Save the Free HMA ptr
	clc
mdhx:
	ret
MovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOSLo
;
;		Allocates memory from DOS and moves BIOS/DOS code into it
;
;----------------------------------------------------------------------------
;


MovDOSLo	proc	near
	call	AllocMemForDOS			; 
	mov	es, ax				; pass the segment to MovBIOS
	call	MovBIOS
;
;------ ES:DI points memory immediately after BIOS
;
	mov	cx, lo_doscod_size		; DOS code size when loaded
						;  low
	call	MovDOS
	ret
MovDOSLo	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovBIOS
;
;		Moves BIOS code into requested segment
;
;	In : ES - segment to which BIOS is to be moved
;		  ( it moves always into offset BCode_Start)
;
;	Out : ES:DI - pointer to memory immediately after BIOS
;
;----------------------------------------------------------------------------
;


MovBIOS	proc	near
	mov	ds, temp_bcode_seg		; current BIOS code seg
	mov	si, offset BCode_Start
	mov	di, si
	mov	cx, offset BCode_End
	sub	cx, si				; size of BIOS
	shr	cx, 1				; Both the labels are para
						;  aligned
	rep	movsw
	push	es
	push	di				; save end of BIOS
	mov	ax, es
	mov	BCodeSeg, ax			; save it for later use
	call	[seg_reinit_ptr]		; far call to seg_reinit (M022)
	pop	di
	pop	es				; get back end of BIOS
	ret
MovBIOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOS
;
;		Moves DOS code into requested area
;
;	In : ES:DI - pointer to memory where DOS is  to be moved
;	     CX    - size of DOS code to be moved
;
;	Out : ES:DI - pointer to memory immediately after DOS
;
;----------------------------------------------------------------------------
;


MovDOS	proc	near
	push	es
	push	di
	lds	si, dos_temp_location		; current location of DOS
	rep	movsb
	pop	bx				; get back offset into which
						;  DOS was moved
	mov	ax, dosinit			; get the offset at which DOS
						;  wants to run
	sub	ax, bx
	call	off_to_para
	pop	bx				; get the segment at which
						;  we moved DOS into
	sub	bx, ax				; Adjust segment
	mov	current_dos_location, bx	; and save it
	ret
MovDOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : AllocMemForDOS
;
;		Allocate memory for DOS/BIOS code from DOS !!!
;
;	Out : AX - seg of allocated memoryblock
;
;----------------------------------------------------------------------------
;


AllocMemForDOS	proc	near
	mov	ax, offset BCode_end
	sub	ax, offset BCode_start		; BIOS code size
	add	ax, lo_doscod_size		; + DOS code size
	add	ax, 15
	call	off_to_para			; convert to para
	or	bx, bx				; M012
						;  can we use int 21 for alloc
	mov	bx, ax
	jz	update_arena			; M012
	mov	ah, 48h				; request DOS
	int	21h
	jc	FatalErr			; IF ERR WE ARE HOSED
	sub	ax, 3				; Take care ORG 30h of
						;  BIOS code
	mov	es, ax
	mov	word ptr es:[20h+arena_owner], 08h	; mark it as system
	mov	word ptr es:[20h+arena_name], 'CS'	;  code area
	ret

;
; M012 : BEGIN
;
update_arena:
	push	ds
	push	di
	push	cx
	push	dx
	lds	di, dosinfo			; get ptr to DOS var
	dec	di
	dec	di				; Arena head is immediately
						;  before sysvar
	mov	es, ds:[di]			; es = arena head
	mov	cx, es:[arena_size]		; cx = total low mem size
	cmp	cx, bx				; is it sufficient ?
	jb	FatalErr			; no, fatal error
	mov	dl, es:[arena_signature]
	mov	ax, es
	add	ax, bx				; ax = new arena head
	mov	ds:[di], ax			; store it in DOS data area
	mov	ds, ax
	mov	byte ptr ds:[arena_signature], dl	; type of arena
	mov	word ptr ds:[arena_owner], 0		; free
	sub	cx, bx				; size of the new block
	mov	word ptr ds:[arena_size], cx	; store it in the arena
	mov	ax, es				; return seg to the caller
	sub	ax, 3				; Take care ORG 30h of
						;  BIOS code
	pop	dx
	pop	cx
	pop	di
	pop	ds
	ret
;
; M012 : END
;
FatalErr:
	push	cs
	pop	ds
	mov	dx, offset FEMsg
	mov	ah, 9h
	int	21h
        cli
	hlt
AllocMemForDOS	endp


;
;----------------------------------------------------------------------------
;
; procedure : AllocHMA
;
;	grab_the_hma tries to enable a20 and make sure there is memory
;	  up there.  If it gets any sort of error, it will return with
;	  carry set so that we can resort to running low.
;
;	It also returns ES: -> 0ffffh if it returns success
;
;----------------------------------------------------------------------------
;

AllocHMA	proc near
	assume	ds:nothing,es:nothing
;
;	cas note:  The pre-286 check is no longer needed here since the
;		   presence of XMS is sufficient.  However, this code hasn't
;		   been deleted because it can be recycled for skipping the
;		   extra pass of CONFIG.SYS and assuming we're running low
;		   in the case of a pre-286.

;
;;	see if we're running on a pre-286.  If not, force low.
;
;	xor	ax,ax
;	pushf			; save flags (like int)
;	push	ax
;	popf
;	pushf
;	pop	ax
;	popf			; restore original flags (like int)
;	and	ax,0f000h
;	cmp	ax,0f000h	; 8088/8086?
;	jz	grab_hma_error
;
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume 	ds:Bios_Data

	call	IsXMSLoaded
	jnz	grabhma_error

	mov	ax,4310h
	int	2fh		; get the vector into es:bx
	mov	word ptr xms,bx
	mov	word ptr xms+2,es

	mov	ah,1		; request HMA
	mov	dx,0ffffh
	call	xms
	dec	ax
	jz	@f		; error if not able to allocate HMA

;
;------ Himem may be lying because it has allocated mem for int 15
;
	mov	ah, 88h
	int	15h
	cmp	ax, 64		; less than 64 K of hma ?
	jb	grabhma_error

@@:	mov	ah,5		; localenableA20
	call	xms
	dec	ax
	jnz	grabhma_error	; error if couldn't enable A20

	mov	ax,0ffffh
	mov	es,ax
	mov	es:word ptr 10h,1234h	; see if we can really read/write there
	cmp	es:word ptr 10h,1234h
	jnz	grabhma_error	; don't try to load there if XMS lied

	clc
	pop	ds
	ret

grabhma_error:
	stc
	pop	ds
	assume	ds:nothing
	ret

AllocHMA	endp

;
;----------------------------------------------------------------------------
;
; procedure : IsXMSLoaded
;
;             Checks whether a XMS driver is loaded
;
; Returns : Z flag set if XMS driver loaded
;           Z flag reset if no XMS drivers are present
;
;----------------------------------------------------------------------------
;
		public	IsXMSLoaded

IsXMSLoaded	proc	near
		mov	ax,4300h
		int	2fh
		cmp	al,80h		; XMS installed?
		ret
IsXMSLoaded	endp

;
;
;----------------------------------------------------------------------------
; procedure : FTryToMovDOSHi
;
;		Called from HMA suballoc calls
;	
;----------------------------------------------------------------------------
;
;

		public	FTryToMovDOSHi
FTryToMovDOSHi	proc	far

		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	ds
		push	es
		cmp	runhigh, 0ffh
		jne	@f

		call	TryToMovDOSHi
@@:
		pop	es
		pop	ds
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax

		ret
FTryToMovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : SaveFreeHMAPtr
;
;		Save the Free HMA pointer in BIOS variable for later use.
;		(INT 2f ax==4a01 call returns pointer to free HMA)
;		Normalizes the pointer to ffff:xxxx format and stores only
;		the offset.
;
; Inputs : ES:DI - pointer to free HMA
; Output : FreeHMAPtr in BIOS data segment updated
;
;----------------------------------------------------------------------------
;
SaveFreeHMAPtr	proc	near
		mov	bx, es
		mov	ax, 0ffffh		; HMA segment
		sub	ax, bx
		add	di, 15			; para round
		and	di, 0fff0h
		mov	cl, 4
		shl	ax, cl
		sub	di, ax
		push	ds
		mov	ax, Bios_Data
		mov	ds, ax
		assume	ds:Bios_Data
		mov	FreeHMAPtr, di
		mov	inHMA, 0ffh
		pop	ds
		assume	ds:nothing
		ret
SaveFreeHMAPtr	endp
;
;
;----------------------------------------------------------------------------
;
; procedure : CPMHack
;
;		Copies the code from 0:c0 into ffff:0d0h
;		for CPM comatibilty
;
;----------------------------------------------------------------------------
;
CPMHack		proc	near
		push	ds
		mov	cx, 0ffffH
		mov	es, cx		; ES = FFFF
		xor	cx, cx
		mov	ds, cx		; DS = 0
		mov	si, 0c0h
		mov	di, 0d0h
		mov	cx, 5
		cld
		rep	movsb		; move 5 bytes from 0:C0 to FFFF:D0
		pop	ds
		ret
CPMHack		endp
	
;
;----------------------------------------------------------------------------
;
; procedure : off_to_para
;
;----------------------------------------------------------------------------
;

off_to_para proc near
	shr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	ret
off_to_para endp


;**	TempCDS - Create (Temporary?) CDS
;
;	ENTRY	?? BUGBUG
;		(DS) = SysInitSeg
;	EXIT	?? BUGBUG
;	USES	?? BUGBUG

	public	tempcds
Procedure TempCDS

    assume ds:sysinitseg
	les	di,dosinfo
	mov	cl,byte ptr es:[di.sysi_numio]
	xor	ch,ch			; (cx) = # of block devices
	mov	es:[di.sysi_ncds],cl	; one CDS per device
	mov	al,cl
	mov	ah,size curdir_list
	mul	ah			; (ax) = byte size for those CDSs
	call	pararound		; (ax) = paragraph size for CDSs
	mov	si,[confbot]
;	BUGBUG - we don't update confbot - won't someone else use it?
	sub	si,ax
	mov	[alloclim],si		; can't alloc past here!
	mov	word ptr es:[di.sysi_cds + 2],si
	mov	ax,si
	mov	word ptr es:[di.sysi_cds],0	; set address of CDS list
	assume	ds:nothing
	mov	es,ax
	xor	di,di			; (es:di) = address of 1st CDS



;*	Initialize our temporary CDSs.
;
;	(cx) = count of CDSs left to process
;	(si) = 0 based drive being processed
;	(es:di) = address of next CDS

fooset:
        xor     dx,dx                   ; indicator to stop removable checks
foogo:
        mov     ax,word ptr DirStrng
	.errnz	CURDIR_TEXT		; setup the root as the curdir
	stosw
	mov	ax,word ptr DirStrng+2
	stosw
	xor	ax,ax
	push	cx
	.errnz	CURDIR_FLAGS - CURDIR_TEXT - size CURDIR_TEXT
	mov	cx,curdir_flags - 4
	rep	stosb			; zero out rest of CURDIR_TEXTs

; Here es:di points to CURDIR_FLAGS

        or      dx,dx                   ; have we found one fixed drive?
        jnz     fixed_drv2              ; NZ -> yes dont do IOCTL check

        cmp     byte ptr DirStrng, 'B'
        jbe     not_fixed               ; 'A' and 'B' are always removable

        mov     bl,byte ptr DirStrng
        sub     bl,'A'
        inc     bl                      ; C is 3
        mov     ax,4408h
        int     21h                     ; Is drive removable
        jc      fixed_drv               ; Could'nt find means NET hence fixed
        or      ax,ax
        jnz     fixed_drv

not_fixed:
        mov     ax,CURDIR_LOCAL OR CURDIR_INUSE
        jmp     short fill_in


fixed_drv:
        inc     dx
fixed_drv2:
        mov     ax,CURDIR_LOCAL OR CURDIR_INUSE OR CURDIR_NT_FIX

fill_in:

	FOLLOWS CURDIR_FLAGS,CURDIR_TEXT,2
	stosw				; Save Flags

	mov	ax,2
	FOLLOWS CURDIR_END,CURDIR_FLAGS,2
	stosw				; Save CURDIR_END

	inc	byte ptr DirStrng
	pop	cx
        loop    foogo
	mov	byte ptr DirStrng,"A"
	ret

EndProc TempCDS


;**	EndFile - Build DOS structures
;
; This procedure is called after the config.sys has been processed and
; installable device drivers have been loaded (but before "install="
; programs are loaded) to create the dos structures such as SFTs, buffers,
; FCBs, CDSs, etc.  It also loads the sysinit_base module in low memory
; to allow for the safe EXECing of "install=" programs.  All memory
; above these structures is deallocated back to DOS.
;
;	ENTRY	?? BUGBUG
;	EXIT	?? BUGBUG
;	USES	?? BUGBUG


;------------------------------------------------------------------------------
; allocate files
;------------------------------------------------------------------------------

endfile:

; we are now setting up final cdss,buffers,files,fcss strings etc.  we no
; longer need the space taken by the temp stuff below confbot,so set alloclim
; to confbot.

;	if this procedure has been called to take care of install= command,
;	    then we have to save es,si registers.

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data

	cmp	multrk_flag,multrk_off1 ;=0,multrack= command entered?
	jne	multrk_flag_done
	or	multrk_flag,multrk_on	; default will be on.
multrk_flag_done:

	pop	ds
	assume	ds:nothing

	mov	ax,[confbot]
	mov	[alloclim],ax

	push	cs
	pop	ds
	extrn	round:near
	call	round
	mov	al,[files]
	sub	al,5
	jbe	dofcbs

	push	ax
	mov	al,devmark_files
	call	setdevmark		; set devmark for sfts (files)
	pop	ax
	xor	ah,ah			; do not use cbw instruction!!!!!
					;  it does sign extend.
	mov	bx,[memlo]
	mov	dx,[memhi]
	lds	di,dosinfo		;get pointer to dos data
	lds	di,[di+sysi_sft]	;ds:bp points to sft
	mov	word ptr [di+sflink],bx
	mov	word ptr [di+sflink+2],dx ;set pointer to new sft

	push	cs
	pop	ds

	les	di,dword ptr [memlo]	;point to new sft
	mov	word ptr es:[di+sflink],-1
	mov	es:[di+sfcount],ax
	mov	bl,size sf_entry
	mul	bl			;ax = number of bytes to clear
	mov	cx,ax
	add	[memlo],ax		;allocate memory
	mov	ax,6
	add	[memlo],ax		;remember the header too
	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before the stosb
	add	di,ax
	xor	ax,ax
	rep	stosb			;clean out the stuff

;------------------------------------------------------------------------------
; allocate fcbs
;------------------------------------------------------------------------------

dofcbs:
	push	cs
	pop	ds
	call	round
	mov	al,devmark_fcbs		;='x'
	call	setdevmark
	mov	al,[fcbs]
	xor	ah,ah			; do not use cbw instruction!!!!!
					;  it does sign extend.
	mov	bx,[memlo]
	mov	dx,[memhi]
	lds	di,dosinfo		;get pointer to dos data
	assume	ds:nothing

	mov	word ptr [di+sysi_fcb],bx
	mov	word ptr [di+sysi_fcb+2],dx ;set pointer to new table
	mov	bl,cs:keep
	xor	bh,bh
	mov	[di+sysi_keep],bx

	push	cs
	pop	ds
	assume	ds:sysinitseg

	les	di,dword ptr [memlo]	;point to new table
	mov	word ptr es:[di+sflink],-1
	mov	es:[di+sfcount],ax
	mov	bl,size sf_entry
	mov	cx,ax
	mul	bl			;ax = number of bytes to clear
	add	[memlo],ax		;allocate memory
	mov	ax,size sf-2
	add	[memlo],ax		;remember the header too
	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before the stosb
	add	di,ax			;skip over header
	mov	al,"A"
fillloop:
	push	cx			; save count
	mov	cx,size sf_entry	; number of bytes to fill
	cld
	rep	stosb			; filled

	mov	word ptr es:[di-(size sf_entry)+sf_ref_count],0
	mov	word ptr es:[di-(size sf_entry)+sf_position],0
	mov	word ptr es:[di-(size sf_entry)+sf_position+2],0

	pop	cx
	loop	fillloop

;------------------------------------------------------------------------------
; allocate cdss
;------------------------------------------------------------------------------
buf1:
	call	round

	push	ax
	mov	ax,devmark_cds		;='l'
	call	setdevmark
	pop	ax

	les	di,dosinfo
        mov     cl,byte ptr es:[di.sysi_numio]

;NTVDM Ignore the lastdrive command. There exists only one cds for all
;      network drives and dos has already set sysi_numio to be
;      num real drives + 1 for all network drives 17-Aug-1992 Jonle
;
;        cmp     cl,[num_cds]
;        jae     gotncds                 ; user setting must be at least numio
;        mov     cl,[num_cds]
;gotncds:
;
	xor	ch,ch
	mov	es:[di.sysi_ncds],cl
	mov	ax,[memhi]
	mov	word ptr es:[di.sysi_cds + 2],ax
	mov	ax,[memlo]
	mov	word ptr es:[di.sysi_cds],ax
	mov	al,cl
	mov	ah,size curdir_list
	mul	ah
	call	pararound
	add	[memhi],ax

	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before initializing
	assume	ds:nothing
	les	di,es:[di.sysi_cds]
	call	fooset

;------------------------------------------------------------------------------
; allocate space for internal stack
;------------------------------------------------------------------------------

	if	stacksw

	push	cs
	pop	ds
	assume	ds:sysinitseg

doinstallstack:
	mov	ax,[stack_count]	; stack_count = 0?
	or	ax,ax			;then,stack size must be 0 too.
	jz	skipstack		;don't install stack.

;	dynamic relocation of stack code.

	call	round			;[memhi] = seg. for stack code
					;[memlo] = 0

; set devmark block into memory for mem command
; devmark_id = 's' for stack

	mov	al,devmark_stk	;='s'
	call	setdevmark

	mov	ax,[memhi]
	mov	es,ax		;es -> seg. the stack code is going to move.
	assume	es:nothing
	push	cs
	pop	ds
	xor	si,si		;!!we know that stack code is at the beginning of sysinit.
	xor	di,di
	mov	cx,offset endstackcode
	mov	[memlo],cx
	call	round		;have enough space for relocation?
	rep	movsb

	push	ds		; stick the location of the NextStack entry
	mov	ax,Bios_Data	; into the Win386 Instance Data tables
	mov	ds,ax
	assume	ds:Bios_Data
	mov	word ptr NextStack,offset nextentry
	mov	word ptr NextStack+2,es

	mov	ax,[memlo]
	mov	word ptr [stack_addr],ax ;set for stack area initialization
	mov	word ptr IT_StackLoc,ax	; pass it as Instance Data, too
	mov	ax,[memhi]	;this will be used by stack_init routine.
	mov	word ptr [stack_addr+2],ax
	mov	word ptr IT_StackLoc+2,ax

;	space for internal stack area = stack_count(entrysize + stack_size)

	mov	ax,entrysize
	add	ax,[stack_size]
	mul	[stack_count]

	mov	IT_StackSize,ax		; pass through to Instance Tables

	pop	ds			; no more need to access Instance Table
	assume	ds:nothing

	call	pararound	; convert size to pargraphs
	add	[memhi],ax
	or	[setdevmarkflag],for_devmark ;to set the devmark_size for stack by round routine.
	call	round		; check for memory error before
				; continuing
	call	stackinit	; initialize hardware stack. cs=ds=sysinitseg,es=relocated stack code & data

skipstack:
	endif

	push	cs
	pop	ds
	assume	ds:sysinitseg

	mov	al,[files]
	xor	ah,ah		; do not use cbw instruction!!!!!
				;  it does sign extend.
	mov	cx,ax
	xor	bx,bx		;close standard input
	mov	ah,close
	int	21h
;; go directly to the handle table; donot close any invalid handles
	push	si
	mov	ah, Get_Current_PDB	;
	int	21h
	les	si, es:[pdb_jfn_pointer]
	mov	bx, 2
rcclloop:
	cmp	byte ptr es:[bx][si], 0FFh	;skip invalid handle
	je	skip_the_handle
	mov	ah,close	; need output so we can print message
	int	21h		; in case we can't get new one open.
skip_the_handle:
	inc	bx
	loop	rcclloop
	pop	si

	mov	dx,offset condev
	mov	al,2
	mov	ah,open 	;open con for read/write
	stc			; set for possible int 24
	int	21h
	jnc	goaux
	call	badfil
	jmp	short goaux2

goaux:	push	ax
	mov	bx,1		;close standard output
	mov	ah,close
	int	21h
	pop	ax

	mov	bx,ax		;new device handle
	mov	ah,xdup
	int	21h		;dup to 1,stdout
	mov	ah,xdup
	int	21h		;dup to 2,stderr

goaux2: mov	dx,offset auxdev
	mov	al,2		;read/write access
	extrn	open_dev:near
	call	open_dev

	mov	dx,offset prndev
	mov	al,1		;write only
	call	open_dev

;global rearm command for shared interrupt devices attached in the system;
;shared interrupt attachment has some problem when it issues interrupt
;during a warm reboot.	once the interrupt is presented by the attachment,
;no further interrupts on that level will be presented until a global rearm
;is issued.  by the request of the system architecture group, msbio will
;issue a global rearm after every device driver is loaded.
;to issue a global rearm:	;for pc1,xt,palace
;
;			  out 02f2h,xx  ; interrupt level 2
;			  out 02f3h,xx  ; interrupt level 3
;			  out 02f4h,xx  ; interrupt level 4
;			  out 02f5h,xx  ; interrupt level 5
;			  out 02f6h,xx  ; interrupt level 6
;			  out 02f7h,xx  ; interrupt level 7
;
;	for pc at,in addition to the above commands,
;	need to handle the secondary interrupt handler
;
;			  out 06f2h,xx  ; interrupt level 10
;			  out 06f3h,xx  ; interrupt level 11
;			  out 06f4h,xx  ; interrupt level 12
;			  out 06f6h,xx  ; interrupt level 14
;			  out 06f7h,xx  ; interrupt level 15
;
;	for round-up machine
;
;			  none.

; where xx stands for any value.
;
; for your information,after naples level machine,the system service bios
; call (int 15h),function ah=0c0h returns the system configuration parameters
;
;
; Sudeepb 31-Dec-1991 Commented out for NT
if 0
	push	ax
	push	bx
	push	dx
	push	es

	mov	al,0ffh 		;reset h/w by writing to port
	mov	dx,2f2h 		;get starting address
	out	dx,al			; out 02f2h,0ffh
	inc	dx
	out	dx,al			; out 02f3h,0ffh
	inc	dx
	out	dx,al			; out 02f4h,0ffh
	inc	dx
	out	dx,al			; out 02f5h,0ffh
	inc	dx
	out	dx,al			; out 02f6h,0ffh
	inc	dx
	out	dx,al			; out 02f7h,0ffh

;sb secondary global rearm

	mov	ax,0f000h		;get machine type
	mov	es,ax
	cmp	byte ptr es:[0fffeh],0fch ;q:is it a at type machine
	je	startrearm		; *if at no need to check

	mov	ah,0c0h 		;get system configuration
	int	15h			; *
	jc	finishrearm		; *jmp if old rom

; test feature byte for secondary interrupt controller

	test	es:[bx.bios_sd_featurebyte1],scndintcontroller
	je	finishrearm		;jmp if it is there

startrearm:
	mov	al,0ffh 		;write any pattern to port
	mov	dx,6f2h 		;get starting address
	out	dx,al			;out 06f2h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f3h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f4h,0ffh
	inc	dx			;bump address
	inc	dx			;bump address
	out	dx,al			;out 06f6h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f7h,0ffh

finishrearm:
	pop	es
	pop	dx
	pop	bx
	pop	ax
endif

;    global rearm end *******************

;------------------------------------------------------------------------------
; allocate sysinit_base for install= command
;------------------------------------------------------------------------------
; sysinit_base allocation.
;   check if endfile has been called to handle install= command.

set_sysinit_base:

;--------------------------------------------------------------------------
;sysinit_base will be established in the secure area of
;lower memory when it handles the first install= command.
;sysinit_base is the place where the actual exec function will be called and
;will check sysinit module in high memory if it is damaged by the application
;program.  if sysinit module has been broken,then "memory error..." message
;is displayed by sysinit_base.
;--------------------------------------------------------------------------

	push	ax			; set devmark for mem command
	mov	ax,[memhi]
	sub	ax,[area]
	mov	[impossible_owner_size],ax ;remember the size in case.
	mov	al,devmark_inst
	call	setdevmark
	pop	ax

	mov	di,[memhi]
	mov	es,di
	assume	es:nothing
	mov	word ptr [sysinit_base_ptr+2],di ; save this entry for the next use.
	xor	di,di
	mov	word ptr [sysinit_base_ptr],di ; es:di -> destination.
	mov	si,offset sysinit_base	;ds:si -> source code to be relocated.
	mov	cx,(offset end_sysinit_base) - (offset sysinit_base)
	add	[memlo],cx
	or	cs:[setdevmarkflag],for_devmark
	call	round			; check mem error. also,readjust memhi for the next use.
	rep	movsb			; reallocate it.

	mov	word ptr [sysinit_ptr],offset sysinitptr ; returing address from
	mov	word ptr [sysinit_ptr+2],cs ;	sysinit_base back to sysinit.
	or	[install_flag],has_installed ; set the flag.

;------------------------------------------------------------------------------
; free the rest of the memory from memhi to confbot.  still from confbot to
; the top of the memory will be allocated for sysinit and config.sys if
; have_install_cmd.
;------------------------------------------------------------------------------

	call	round
	mov	bx,[memhi]
	mov	ax,[area]
	mov	[old_area],ax		; save [area]
	mov	es,ax			;calc what we needed
	sub	bx,ax
	mov	ah,setblock
	int	21h			;give the rest back

	push	es
	mov	ax,es
	dec	ax
	mov	es,ax			;point to arena
	mov	es:[arena_owner],8	;set impossible owner
	mov	word ptr es:[arena_name], 'DS'	; System Data
	pop	es

	mov	bx,0ffffh
	mov	ah,alloc
	int	21h
	mov	ah,alloc
	int	21h			; allocate the rest of the memory

	mov	[memhi],ax		; start of the allocated memory
	mov	[memlo],0		;   to be used next.

;;;; at this moment,memory from [memhi]:0 to top-of-the memory is
;;;; allocated.
;;;; to protect sysinit,confbot module (from confbot (or =alloclim at
;;;; this time) to the top-of-the memory),here we are going to
;;;; 1). "setblock" from memhi to confbot.
;;;; 2). "alloc" from confbot to the top of the memory.
;;;; 3). "free alloc memory" from memhi to confbot.

;memory allocation for sysinit,confbot module.

	mov	es,ax
	mov	bx,[confbot]
	sub	bx,ax			; confbot - memhi
	dec	bx			; make a room for the memory block id.
	dec	bx			; make sure!!!.
	mov	ah,setblock
	int	21h			; this will free (confbot to top of memory)
	mov	bx,0ffffh
	mov	ah,alloc
	int	21h
	mov	ah,alloc
	int	21h			; allocate (confbot to top of memory)
	mov	[area],ax		; save allocated memory segment.
					; need this to free this area for command.com.
	mov	es,[memhi]
	mov	ah,49h			; free allocated memory.
	int	21h			; free (memhi to confbot(=area))

endfile_ret:
	ret

; End of "EndFile" DOS structure configuration.


;-------------------------------------------------------------------------
; Do_Install_Exec
;
; This procedure is used to EXEC a program being loaded via the
; "install=" mechanism in config.sys.  It does this by setting up
; the parameters, and then jumping to sysinit_base, which has been
; setup in low memory.  When complete, sysinit_base will jump back
; up to this procedure (if sysinit remains uncorrupted by the installed
; program).

do_install_exec proc near		; now,handles install= command.

	push	si			; save si for config.sys again.

; we are going to call load/exec function.
; set es:bx to the parameter block here;;;;;;;
; set ds:dx to the asciiz string. remember that we already has 0
; after the filename. so parameter starts after that. if next
; character is a line feed (i.e. 10),then assume that the 0
; we already encountered used to be a carrage return. in this
; case,let's set the length to 0 which will be followed by
; carridge return.

; es:si -> command line in config.sys. points to the first non blank
;character after =.

	push	es
	push	ds
	pop	es
	pop	ds			; es->sysinitseg,ds->confbot seg
	assume	ds:nothing
	mov	dx,si			; ds:dx->file name,0 in config.sys image.

	xor	cx,cx
	cld
	mov	cs:ldexec_start,' '	; clear out the parm area
	mov	di,offset ldexec_parm
installfilename:			;  skip the file name
	lodsb				;  al = ds:si; si++
	cmp	al,0
	je	got_installparm
	jmp	installfilename
got_installparm:			;  copy the parameters to ldexec_parm
	lodsb
	mov	es:[di],al
	cmp	al,lf			;  line feed?
	je	done_installparm
	inc	cl			;  # of char. in the parm.
	inc	di
	jmp	got_installparm
done_installparm:
	mov	byte ptr cs:[ldexec_line],cl ;	length of the parm.
	cmp	cl,0			;if no parm,then
	jne	install_seg_set 	; let the parm area
	mov	byte ptr cs:[ldexec_start],cr ;	starts with cr.
install_seg_set:
	mov	word ptr cs:0,0		; make a null environment segment
	mov	ax,cs			; by overlap jmp instruction of sysinitseg.

;hkn; the environment pointer is made 0. so the current environment ptr.
;hkn; will be the same as pdb_environ which after dosinit is 0.

	mov	cs:[instexe.exec0_environ],0 ; set the environment seg.


	mov	word ptr cs:[instexe.exec0_com_line+2],ax ; set the seg.
	mov	word ptr cs:[instexe.exec0_5c_fcb+2],ax
	mov	word ptr cs:[instexe.exec0_6c_fcb+2],ax
	call	sum_up
	mov	es:checksum,ax		; save the value of the sum
	xor	ax,ax
	mov	ah,exec			; load/exec
	mov	bx,offset instexe	; es:bx -> parm block.
	push	es			; save es,ds for load/exec
	push	ds			; these registers will be restored in sysinit_base.
	jmp	cs:dword ptr sysinit_base_ptr ; jmp to sysinit_base to execute
					; load/exec function and check sum.

;j.k. this is the returning address from sysinit_base.

sysinitptr:				; returning far address from sysinit_base
	pop	si			; restore si for config.sys file.
	push	es
	push	ds
	pop	es
	pop	ds			; now ds - sysinitseg,es - confbot
	jnc	exec_exit_code


	push	si			; error in loading the file for install=.
	call	badload 		; es:si-> path,filename,0.
	pop	si
	jmp	short install_exit_ret

exec_exit_code:
	mov	ah,4dh
	int	21h
	cmp	ah,3			;only accept "stay resident" prog.
	je	install_exit_ret
	call	error_line		;inform the user

	stc

install_exit_ret:
	ret

do_install_exec endp



;**	ParaRound - Round Up length to paragraph multiple
;
;	ParaRound rounds a byte count up to a multiple of 16, then divides
;	by 16 yielding a "length in paragraphs" value.
;
;	ENTRY	(ax) = byte length
;	EXIT	(ax) = rounded up length in paragraphs
;	USES	ax, flags

Procedure ParaRound

	add	ax,15
	rcr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	ret

EndProc   ParaRound


;------------------------------------------------------------------------------
; sysinit_base module.
;
; This module is relocated by the routine EndFile to a location in low
; memory.  It is then called by SYSINIT to perform the EXEC of programs
; that are being loaded by the "install=" command.  After the EXEC call
; completes, this module performs a checksum on the SYSINIT code (at the
; top of memory) to be sure that the EXECed program did not damage it.
; If it did, then this module will print an error message and stop the
; system.  Otherwise, it returns control to SYSINIT.
;
;
;in: after relocation,
;    ax = 4b00h - load and execute the program dos function.
;    ds = confbot. segment of config.sys file image
;    es = sysinitseg. segment of sysinit module itself.
;    ds:dx = pointer to asciiz string of the path,filename to be executed.
;    es:bx = pointer to a parameter block for load.
;    SI_end (byte) - offset vaule of end of sysinit module label
;    bigsize (word) - # of word from confbot to SI_end.
;    chksum (word) - sum of every byte from confbot to SI_end in a
;			word boundary moduler form.
;    sysinit_ptr (dword ptr) - return address to sysinit module.
;
;note: sysinit should save necessary registers and when the control is back

	public	sysinit_base
sysinit_base:
	mov	word ptr cs:sysinit_base_ss,ss	; save stack
	mov	word ptr cs:sysinit_base_sp,sp
	int	21h				; load/exec dos call.
	mov	ss,word ptr cs:sysinit_base_ss	; restore stack
	mov	sp,word ptr cs:sysinit_base_sp
	pop	ds				; restore confbot seg
	pop	es				; restore sysinitseg
	jc	sysinit_base_end		; load/exec function failed.
						; at this time,i don't have to worry about
						; that sysinit module has been broken or not.
	call	sum_up				; otherwise,check if it is good.
	cmp	es:checksum,ax
	je	sysinit_base_end

;	memory broken. show "memory allocation error" message and stall.

	mov	ah,9
	push	cs
	pop	ds
	mov	dx,offset mem_alloc_err_msgx - sysinit_base
	int	21h
	jmp	$			; hang here!!!!

sysinit_base_end: jmp es:sysinit_ptr	;return back to sysinit module

sum_up:

;in:   es - sysinitseg.
;out:  ax - result
;
;remark: since this routine will only check starting from "locstack" to the end of
;	 sysinit segment,the data area, and the current stack area are not
;	 coverd.  in this sense,this check sum routine only gives a minimal
;	 gaurantee to be safe.
;
;first sum up confbot seg.

	push	ds
	mov	ax,es:confbot
	mov	ds,ax
	xor	si,si
	xor	ax,ax
	mov	cx,es:config_size	; if config_size has been broken,then this
					;whole test better fail.
	shr	cx,1			; make it a word count
	jz	sum_sys_code		; when config.sys file not exist.
sum1:
	add	ax,ds:word ptr [si]
	inc	si
	inc	si
	loop	sum1
;now,sum up sysinit module.
sum_sys_code:
	mov	si,offset locstack	; starting after the stack.
					;  this does not cover the possible stack code!!!
        mov     cx,offset sysinitgrp:SI_end    ; SI_end is the label at the end of sysinit
	sub	cx,si			;  from after_checksum to SI_end
	shr	cx,1
sum2:
	add	ax,es:word ptr [si]
	inc	si
	inc	si
	loop	sum2
	pop	ds
	ret

sysinit_base_ss equ $-sysinit_base
	dw	?
sysinit_base_sp equ $-sysinit_base
	dw	?
mem_alloc_err_msgx:

	include msbio.cl4		; memory allocation error message

end_sysinit_base label byte

;------------------------------------------------------------------------------
; ibmstack initialization routine.
	if	stacksw
.sall
;
;	to follow the standard interrupt sharing scheme, msstack.asm
;	has been modified.  this initialization routine also has to
;	be modified because for the interrupt level 7 and 15, firstflag
;	should be set to signal that this interrupt handler is the
;	first handler hooked to this interrupt vector.
;	we determine this by looking at the instruction pointed by
;	this vector.  if it is iret, then this handler should be the
;	first one.  in our case, only the interrupt vector 77h is the
;	interrupt level 15. (we don't hook interrupt level 7.)
;
;	the followings are mainly due to m.r.t; ptm fix of p886 12/3/86
;	some design changes are needed to the above interrupt sharing
;	method.  the above sharing scheme assumes that 1). interrupt
;	sharing is never done on levels that have bios support. 2). "phantom"
;	interrupts would only be generated on levels 7 and 15.
;	these assumptions are not true any more. we have to use the firstflag
;	for every level of interrupt.  we will set the firstflag on the following
;	conditions:
;
;	 a.	 if the cs portion of the vector is 0000, then "first"
;	 b. else if cs:ip points to valid shared header, then not "first"
;	 c. else if cs:ip points to an iret, then "first"
;	 d. else if cs:ip points to dummy, then "first"
;
;	where dummy is - the cs portion must be f000, and the ip portion must
;	be equal to the value at f000:ff01. this location is the initial value
;	from vector_table for interrupt 7, one of the preserved addresses in all
;	the bioses for all of the machines.
;
;	system design group requests bios to handle the phantom interrupts.
;
;	the "phantom" interrupt is an illegal interrupt such as an interrupt
;	produced by the bogus adapter card even without interrupt request is
;	set.  more specifically, 1). the 8259 has a feature when running in
;	edge triggered mode to latch a pulse and present the interrupt when
;	the processor indicates interrupt acknowledge (inta).  the interrupt
;	pulse was exist at the time of inta to get a "phantom" interrupt.
;	2). or, this is caused by adapter cards placing a glitch on the
;	interrupt line.
;
;	to handle those "phantom" interrupts, the main stack code will check
;	the own firstflag, and if it is not "first" (which means the forward
;	pointer points to the legal shared interrupt handler), then pass the
;	control.  if it is the first, then the following action should be
;	taken.	we don't have to implement skack logic in this case.
;
;	to implement this logic, we rather choose a simple method.
;	if ont of the above "firstflag" conditions is met, we are not
;	going to hook this interrupt vector.  the reason is if the original
;	vector points to "iret" and do nothing, we don't need
;	to implement the stack logic for it.  this will simplify implementation
;	while maintaining compatibility with the old version of dos.
;	this implies that in the main stack code, there might be a stack code
;	that will never be used, a dead code.
;
;in - cs, ds -> sysinitseg, es -> relocated stack code & data.

	page
	assume	ds:sysinitseg
stackinit	proc near

	push	ax
	push	ds
	push	es
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	push	bp

;currently es -> stack code area

	mov	ax, cs:[stack_count]		;defined in cs
	mov	es:[stackcount], ax		;defined in stack code area
	mov	ax, [stack_size]		;in cs
	mov	es:[stacksize], ax
	mov	ax, word ptr cs:[stack_addr]	; offset
	mov	word ptr es:[stacks], ax
	mov	ax, word ptr cs:[stack_addr+word] ; segment
	mov	word ptr es:[stacks+word], ax

; initialize the data fields with the parameters

; "firstentry" will always be at stacks

	mov	bp, word ptr es:stacks		; get offset of stack
	mov	es:firstentry,bp

; the stacks will always immediately follow the table entries

	mov	ax,entrysize
	mov	cx,es:stackcount
	mul	cx
	add	ax,bp
	mov	es:stackat,ax
	mov	bx,ax
	sub	bx,2

; zero the entire stack area to start with

	mov	di,es:stackat
	mov	ax,es:stacksize
	mul	cx
	mov	cx,ax
	xor	ax,ax
	push	es
	pop	ds				;ds = relocated stack code seg.
	assume	ds:nothing

;now, ds -> stack code area

	mov	es, word ptr ds:[stacks+2]	; get segment of stack area.
	cld
	rep	stosb

	mov	cx, ds:stackcount

; loop for "count" times, building a table entry
;  cs = sysinitseg, ds = relocated stack code seg , es = segment of stack space
;  cx = number of entries
;  es:bp => base of stacks - 2
;  es:bx => first table entry

buildloop:
	mov	es:byte ptr allocbyte[bp],free
	mov	es:byte ptr intlevel[bp],al	;ax = 0
	mov	es:word ptr savedsp[bp],ax
	mov	es:word ptr savedss[bp],ax
	add	bx,ds:stacksize
	mov	es:word ptr newsp[bp],bx
	mov	es:[bx],bp
	add	bp,entrysize

	loop	buildloop

	sub	bp,entrysize
	mov	ds:lastentry,bp
	mov	ds:nextentry,bp

; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;        push    ds
;        mov     ax, 0f000h                      ;look at the model byte
;        mov     ds, ax
;        cmp     ds:byte ptr [0fffeh], mdl_convert ;convertible?
;        pop     ds
;        jne     skip_disablenmis
;
;        mov     al,07h                          ; disable convertible nmis
;        out     72h,al
;
;skip_disablenmis:

	xor	ax,ax
	mov	es,ax				;es - segid of vector table at 0
	assume	es:nothing			;ds - relocated stack code segment

        call    DOCLI

        irp     aa,<02,70>

	mov	si,aa&h*4		;pass where vector is to be adjusted
	mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
	mov	bx,offset old&aa	;pass where to save original owner pointer
	mov	dx,offset int&aa	;pass where new handler is
	call	new_init_loop		;adjust the vector to new handler,
					;  saving pointer to original owner
        endm


        ; NTVDM int 08, 09, special handling 24-Jan-1993 Jonle
        ;
        ; These Ints are  usually done in the macro above with int 02,70
        ; However, we don't need stack swapping as long as no device
        ; driver has hooked it. These ints are also left alone so that
        ; softpc will know if they have been hooked by an app.

        mov     si, 09h*4
        mov     ax, word ptr es:[si+0]
        cmp     word ptr old09, ax
        jne     do_I9StkSwap
        mov     ax, word ptr es:[si+2]
        cmp     word ptr old09+2, ax
        je      skip_I9StkSwap
do_I9StkSwap:
        mov     di, offset int19old09
        mov     bx,offset old09
        mov     dx,offset int09
        call    new_init_loop
skip_I9StkSwap:

        mov     si, 08h*4
        mov     ax, word ptr es:[si+0]
        cmp     word ptr old08, ax
        jne     do_I8StkSwap
        mov     ax, word ptr es:[si+2]
        cmp     word ptr old08+2, ax
        je      skip_I8StkSwap
do_I8StkSwap:
        mov     di, offset int19old08
        mov     bx,offset old08
        mov     dx,offset int08
        call    new_init_loop
skip_I8StkSwap:


        irp     aa,<0a,0b,0c,0d,0e,72,73,74,76,77>      ;shared interrupts

	mov	si,aa&h*4		;pass where vector is to be adjusted
	push	ds			;save relocated stack code segment
	lds	bx, es:[si]		;ds:bx -> original interrupt handler
	push	ds
	pop	dx			;dx = segment value

	cmp	dx,0
	jz	int&aa&_first

	cmp	byte ptr ds:[bx],0cfh	;does vector point to an iret?
	jz	int&aa&_first

	cmp	word ptr ds:[bx.6],424bh ;magic offset (see int&aa, msstack.inc)
	jz	int&aa&_not_first

	cmp	dx,0f000h		;rom bios segment
	jnz	int&aa&_not_first

	push	es
	push	dx
	mov	dx,0f000h
	mov	es,dx
	cmp	bx,word ptr es:0ff01h
       	pop	dx
	pop	es
	jz	int&aa&_first

int&aa&_not_first:			;not the first. we are going to hook vector.
	pop	ds
	mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
	mov	bx, offset old&aa	;pass where to save original owner pointer
	mov	dx, offset int&aa	;pass where new handler is
	call	new_init_loop		;adjust the vector to new handler, saving
					;pointer to original owner.
	jmp	short int&aa&_end
int&aa&_first:				 ;the first. don't have to hook stack code.
	pop	ds
int&aa&_end:

        endm

; NTVDM support for pc convertable is NOT NEEDED 10-Aug-1992 Jonle
;        push    ds
;        mov     ax, 0f000h              ;loook at the model byte
;        mov     ds, ax
;        cmp     ds:byte ptr [0fffeh], mdl_convert       ;pc convertible?
;        pop     ds
;        jne     skip_enablenmis
;
;        mov     al,27h                          ; enable convertible nmis
;        out     72h,al
;
; skip_enablenmis:

        call    DOSTI
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data


	mov	[int19sem],1		; indicate that int 19
					; initialization is complete

	pop	bp			; restore all
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx

	pop	es
	pop	ds
	assume	ds:sysinitseg

	pop	ax
	ret
stackinit	endp

new_init_loop proc near

;input: si=ofset into vector table of the particular int vector being adjusted
;	bx=ds:offset of oldxx, where will be saved the pointer to original owner
;	dx=ds:offset of intxx, the new interrupt handler
;	di=offset value of int19old&aa variable in bios.
;	es=zero, segid of vector table
;	ds=relocated stack code segment

	mov	ax,es:[si+0]		;remember offset in vector
	mov	word ptr ds:[bx],ax	; to original owner in ds
	mov	ax,es:[si+2]		;remember segid in vector
	mov	word ptr ds:[bx]+2,ax	; to original owner in ds

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax			;set int19oldxx value in bios for
	mov	ax,es:[si+0]		;int 19 handler
	mov	word ptr ds:[di],ax
	mov	ax,es:[si+2]
	mov	word ptr ds:[di]+2,ax
	pop	ds

	mov	word ptr es:[si+0],dx  ;set vector to point to new int handler
	mov	es:[si+2],ds
	ret
new_init_loop endp


.xall
	endif
;------------------------------------------------------------------------------
	public	setdevmark
setdevmark proc

;set the devmark for mem command.
;in: [memhi] - the address to place devmark
;    [memlo] = 0
;    al = id for devmark_id
;out: devmark established.
;     the address saved in cs:[devmark_addr]
;     [memhi] increase by 1.

	push	es
	push	cx

	mov	cx,cs:[memhi]
	mov	cs:[devmark_addr],cx
	mov	es,cx
	mov	es:[devmark_id],al
	inc	cx
	mov	es:[devmark_seg],cx

	pop	cx
	pop	es
	inc	cs:[memhi]
	ret
setdevmark endp


	ifdef	TAIWAN

;---------------------
; entry : none
; exit : ax = 0  --> oem local driver not found
;	    = 1  --> oem local driver found
; destore : ds,es,bx,cx,dx,si,di
; description :
;  search config.sys to find oem local driver.
;  oem local driver should in \csi\driver\ directory .
;  if (found oem local driver in config.sys)
;	ax=1;
;  else
;	ax=0;
;  return;
;  ps. please see state diagram for state description.
;---------------------

chkoemlocaldrv proc near
	push	es
	push	ds
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	call	chkconfig
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ds
	pop	es
	ret
chkoemlocaldrv endp

config_sys db	"C:\CONFIG.SYS",0
sizeofconfig dw 0
filehandle dw	0
workingmemptr dw 0
deviceid db	"DEVICE"
csidrvid db	"CSI\DRIVER\"
localdrvname dw 0
chkconfig proc	near
	call	preprocess
	jnc	initstate
	jmp	notfoundret

;
; processing config.sys
;
; state 0
; ds:si --> current line ( end of line is oah or 0dh )

initstate:
	mov	si,dx
state_0:
	push	cs
	pop	es
	mov	di,offset deviceid
	mov	cx,3
	repz	cmpsw
	jz	state_1
	mov	ax,0ffffh
	jmp	state_10
state_1:
	lodsb
	cmp	al,' '
	jz	state_1
	cmp	al,'='
	jz	state_2
state_10a:
	jmp	state_10
state_2:
	lodsb
	cmp	al,' '
	jz	state_2
	cmp	al,'\'
	jz	state_5
	cmp	al,'A'
	jb	state_10a
	cmp	al,'z'
	ja	state_10a
state_3:
	dec	si
	mov	cs:[localdrvname],si
	inc	si
state_4:
	lodsb
	cmp	al,':'
	jz	state_6
	jmp	state_10
state_5:
	dec	si
	mov	cs:[localdrvname],si
	inc	si
	jmp	state_7
state_6:
	lodsb
	cmp	al,'\'
	jz	state_7
	cmp	al,'c'
	jne	state_10a
	inc	si
state_7:
	mov	di,offset csidrvid
	mov	cx,11
	repz	cmpsb
	jnz	state_10a
state_8:
	lodsb
	cmp	al,'1'
	jb	state_10
	cmp	al,'z'
	ja	state_10
state_9:
tryopenlocaldrv:
	mov	dx,cs:[localdrvname]
	mov	si,dx
chknextbyte:
	lodsb
	cmp	al,0h
	jz	openfile
	cmp	al,' '
	jne	chknextbyte
	dec	si
	mov	byte ptr ds:[si],0
openfile:
	mov	ax,3d00h		; open config.sys
	stc
	int	21h
	jc	notfoundret
	mov	bx,ax			; bx = file handle
	mov	ah,3eh
	int	21h			; close local driver
	jc	notfoundret
	jmp	foundret

state_10:
	cmp	al,1ah			; look current char. == eof ?
	jz	notfoundret
	lodsb
	cmp	al,0
	jz	newlinestate
	cmp	al,1ah
	jz	notfoundret
	jmp	state_10
newlinestate:
	lodsb
	cmp	al,1ah
	jz	notfoundret
	cmp	al,0
	jz	newlinestate
	dec	si
	jmp	state_0
notfoundret:
	mov	ax,0
	jmp	freemem
foundret:
	mov	ax,1
freemem:
	push	ax
	call	freememory
	pop	ax
	ret

chkconfig endp

preprocess proc near
	push	cs
	pop	ds
	mov	dx,offset config_sys
	mov	ax,3d00h		; open config.sys
	stc
	int	21h
	jc	errorfile

; get size of config.sys

	mov	bx,ax			; bx = file handle
	mov	cs:[filehandle],bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,4202h		; move file ptr
	int	21h
	mov	cs:[sizeofconfig],ax	; ax == size of config.sys
	xor	dx,dx			; ignore more than 64k of config
	mov	ax,4200h		; mov file ptr to beginning of file
	int	21h

; allocate for config.sys

	mov	ax,cs:[sizeofconfig]
	add	ax,15			; change to para
	rcr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	add	ax,20h
	mov	bx,ax			; size of memory in para
	mov	ah,48h
	int	21h
	jc	memerr
					; ax --> free memory
	mov	cs:[workingmemptr],ax

; read config.sys

	mov	bx,cs:[filehandle]	; file handle
	mov	cx,cs:[sizeofconfig]	; byte count of reading
	xor	dx,dx
	mov	ds,ax			; ds:dx --> buffer
	mov	ah,3fh
	int	21h
	jc	errorfile

; translate to upper case

	call	transtoupper
	clc
	ret
errorfile:
memerr:
	stc
	ret
preprocess endp

; entry : ds:dx --> buffer
; exit : none
; description : translate all letter in buffer to upper type
;	ps ,don't change ds:dx

transtoupper proc near
	cld
	mov	cx,cs:[sizeofconfig]
	mov	si,dx
transnext:
	lodsb
	cmp	al,'A'
	jb	chklfcr
	cmp	al,'z'
	ja	chkcounter
	sub	al,'a'-'A'
	mov	ds:[si-1],al
	jmp	chkcounter
chklfcr:
	cmp	al,0dh
	jz	setzero
	cmp	al,0ah
	jz	setzero
	jmp	chkcounter
setzero:
	mov	al,0
	mov	ds:[si-1],al
chkcounter:
	loop	transnext
	ret
transtoupper endp

;entry : none ( free memory block ptr in [workingmem] )
;exit : none

freememory proc near
	mov	ax,cs:[workingmemptr]
	mov	es,ax
	mov	ah,49h
	int	21h
	ret
freememory endp


; name : maketempvector
; entry : es:bx -->
;		dd	original int 9 vector	  ( offfset ,segment )
;		dd	original int 10h vector   ( offfset ,segment )
;		dd	original int 16h vector   ( offfset ,segment )
;
; exit : none
; description : 1. save local driver table in static area
;		2. make temp. vector for int9 ,10h ,16h
;
oemdriverinst dw 0
orgvectblptr dd 0

	db	0eah
dummyint9 dd	0
	db	0eah
dummyint10h dd	0
	db	0eah
dummyint16h dd	0

csiint9 dd	0
csiint10h dd	0
csiint16h dd	0

maketempvector proc near
	push	ds
	push	ax
	push	di
	push	si
	push	cx

; save table ptr

	mov	word ptr cs:[orgvectblptr],bx
	mov	word ptr cs:[orgvectblptr+2],es
	cmp	cs:oemdriverinst,0
	jnz	ignoreint9

; make temp. vector for int 9 ,

	mov	bx,9			; int #
	push	cs
	pop	es
	mov	di,offset csiint9	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint9	; ds:si --> dummy int service
	call	dummyvector

ignoreint9:

; make temp. vector for int 10h

	mov	bx,10h			; int #
	push	cs
	pop	es
	mov	di,offset csiint10h	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint10h	; ds:si --> dummy int service
	call	dummyvector

; make temp. vector for  int 16h

	mov	bx,16h			; int #
	push	cs
	pop	es
	mov	di,offset csiint16h	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint16h	; ds:si --> dummy int service
	call	dummyvector
	pop	cx
	pop	si
	pop	di
	pop	ax
	pop	ds
	ret


maketempvector endp

;name	: dummyvector
; entey : ds:si --> dummy int sevice routine
;	  es:di --> point to  csi vector store area
;	  bx  == int number
; exit : none
; description :
;		setting dummy vector of int 9 ,10h,16h
;		for recover csi vector
;		/* phase 1*/
;		[ds:si]=[0:bx*4]
;		[ds:si+2]=[0:bx*4+2]
;		/* phase 2*/
;		[es:di]=[0:bx*4]
;		[es:di+2]=[0:bx*4+2]
;		/* phase 2*/
;		[0:bx*4]=si-1;
;		[0:bx*4+2]=ds;

dummyvector proc near
	shl	bx,1			; bx <- bx*4
	shl	bx,1			; ie ,get offset of vector

; phase 1
; es --> 0
; es:bx --> cpu int vector table

	xor	ax,ax
	push	es
	mov	es,ax
	mov	ax,es:[bx]		; get offset  ds-->0
	mov	ds:[si],ax		; store  offset
	mov	ax,es:[bx+2]		; get offset  ds-->0
	mov	ds:[si+2],ax		; store segment
	pop	es

; phase 2
; ds --> 0
; ds:bx --> cpu int vector table

	xor	ax,ax
	push	ds
	mov	ds,ax
	mov	ax,ds:[bx]		; get offset
	mov	es:[di],ax		; store  offset
	mov	ax,ds:[bx+2]		; get offset
	mov	es:[di+2],ax		; store segment
	pop	ds

; phase 3
; es --> 0
; es:bx --> cpu int vector table

	xor	ax,ax
	push	es
	mov	es,ax
	dec	si
	mov	es:[bx],si
	mov	ax,ds
	mov	es:[bx+2],ax
	pop	es
	ret
dummyvector endp

; name : recovercsiint
; entry : none
; exit :none
; description :
;	recover int 9 ,10h,16h ,for csi vector

recovercsiint proc near
	push	es
	push	ds
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di

;recover int 9

	cmp	cs:oemdriverinst,0
	jnz	ignoreint9recover

	push	cs
	pop	ds
	mov	si,offset dummyint9
	push	cs
	pop	es

	mov	di,offset csiint9
	mov	bx,9
	mov	ax,0
	call	recoverint
ignoreint9recover:

; recover int 10h

	push	cs
	pop	ds
	mov	si,offset dummyint10h
	push	cs
	pop	es
	mov	di,offset csiint10h
	mov	bx,10h
	mov	ax,0+4
	call	recoverint

;recover int 16h

	push	cs
	pop	ds
	mov	si,offset dummyint16h
	push	cs
	pop	es
	mov	di,offset csiint16h
	mov	bx,16h
	mov	ax,0+4+4
	call	recoverint
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	ds
	pop	es
	ret
recovercsiint endp

; name : recoverint
; entey : ds:si --> dummy int sevice routine
;	  es:di --> point to  csi vector store area
;	  bx  == int number
;	  ax  == 0	; int 9
;		 4	; int 10h
;		 4+4	; int 16h
; exit : none
; description :
;	  1. if( [0:bx*4] == si-1  .and.  [es:bx*4+2] == ds )
;	     {
;		 [0:bx*4]   = [es:di];
;		 [0:bx*4+2] = [es:di+2];
;	     }
;	     else
;	     {
;		 /* phase 1 */
;		 [ds:si]  = [(*orgvectblptr)+ax]
;		 [ds:si+2]= [(*orgvectblptr)+ax+2];
;		 /* phase 2 */
;		 [orgvectblptr+ax) ]=[0:bx*4] ;
;		 [orgvectblptr+ax+2 ]=[0:bx*4+2] ;
;		 /* phase 3 */
;		 [0:bx*4]   = [es:di];
;		 [0:bx*4+2] = [es:di+2];
;
;
;	     }

;

recoverint proc near
;chek vector change ?
; es --> 0

	push	es
	mov	cx,ax
	xor	ax,ax
	mov	es,ax
	shl	bx,1
	shl	bx,1			; es:bx --> cpu int vector
	mov	ax,si
	dec	ax
	cmp	es:[bx],ax		; offset same ?
	jne	vectorbechanged

	mov	ax,ds
	cmp	es:[bx+2],ax		; segmnet same ?
	jne	vectorbechanged
	pop	es

; vector not be changed
; ds --> 0

	xor	ax,ax
	mov	ds,ax			; ds:bx --> cpu int vector
	mov	ax,es:[di]
	mov	ds:[bx],ax
	mov	ax,es:[di+2]
	mov	ds:[bx+2],ax
	ret

vectorbechanged:

;phase 1
; di:es --> addres of local driver

	pop	es
	push	di
	push	es
	mov	di,word ptr cs:[orgvectblptr]
	mov	es,word ptr cs:[orgvectblptr+2]
	add	di,cx
	mov	ax,es:[di]
	mov	ds:[si],ax
	mov	ax,es:[di+2]
	mov	ds:[si+2],ax

;phase2
; di:es --> addres of local driver
; ds --> 0

	push	ds
	xor	ax,ax
	mov	ds,ax
	mov	ax,ds:[bx]		; ds:bx --> cpu int vector
	mov	es:[di],ax
	mov	ax,ds:[bx+2]
	mov	es:[di+2],ax
	pop	ds
	pop	es
	pop	di

;phase3
; ds --> 0

	xor	ax,ax
	push	ds
	mov	ds,ax
	mov	cx,es:[di]
	mov	ds:[bx],cx		; ds:bx --> cpu int vector
	mov	cx,es:[di+2]
	mov	ds:[bx+2],cx
	pop	ds
	ret

recoverint endp

;name : chklocalexist
;entry : none
;exit :none
; descriptin : check local driver exist ?
;		if not exist system halt !
;		otherwise null return

chklocalexist proc near
	push	ax
	push	cx
	push	dx
	mov	ah,0dbh
	mov	al,80h			; module_extsysutil
	mov	cx,01			; syscmd_extquerysysmode
	int	16h
	test	ax,8000h		; bit 15 on
	jnz	csisystemerror		; no,system halt
					; yes ,dx == country id
	push	dx			; save current id
	mov	dx,58h
	mov	ah,0dbh
	mov	al,80h			; module_extsysutil
	mov	cx,02			; syscmd_extsetsysmode
	int	16h
	test	ax,8000h		; bit 15 on
	jnz	localdrvnotfound	; no ,local driver error

	pop	cx
	cmp	cx,dx			; current id == previous id ?
	jnz	localdrvnotfound	; no ,local driver error

	pop	dx
	pop	cx
	pop	ax
	ret

localdrvnotfound:
csisystemerror:
	push	cs
	pop	ds
	mov	dx,offset bootfailmsg
	mov	ah,9
	int	21h
	cli
	hlt
	ret

chklocalexist endp
        endif

sysinitseg ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\dat2obj\dat2obj.c ===
#include <windows.h>
#include <insignia.h>
#include <host_def.h>

/* Forced manually here for standalone variant of LCIF generator */
#define WITHSIZE
#define STAND_ALONE

/*[
 * Name:	dat2obj.c
 * Author:	Jerry Sexton (based on William Roberts' version for RS6000)
 * SCCS ID:
 *
 * Created:	7/12/93
 *
 * Purpose:
 *	Convert thread.dat and online.dat into object files.
 *	Called from onGen.
 *
 * The input & output files will be found in SRC_OUT_DIR, which may be
 * overridden using the GENERATOR_OUTPUT_DIRECTORY mechansim.
 *
 * (C) Copyright Insignia Solutions Ltd., 1993.
]*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//#include "gen_file.h"
//#include "host_clo.h"

/* Local defines. */
#define SYMSIZE	sizeof(syms[0])
#define AUXSIZE	sizeof(aux[0])
#define SECNAME ".data\0\0\0"

#ifdef STAND_ALONE

/* Variables needed for stand-alone version. */
LOCAL FILE	*out_file;
#endif /* STAND_ALONE */

/*
 * machineStrings and machineIds - valid environment strings and corresponding
 * machine ID's. The two arrays must be edited in tandem.
 */
LOCAL CHAR	*machineStrings[] =
{
	"I860",
	"I386",
	"R3000",
	"R4000",
	"ALPHA",
	"POWERPC",
	"HPPA"
};

LOCAL IU16	machineIds[] =
{
#ifdef IMAGE_FILE_MACHINE_I860
	IMAGE_FILE_MACHINE_I860,
#else
    0xAAA,
#endif
	IMAGE_FILE_MACHINE_I386,
	IMAGE_FILE_MACHINE_R3000,
	IMAGE_FILE_MACHINE_R4000,
	IMAGE_FILE_MACHINE_ALPHA,
#ifdef IMAGE_FILE_MACHINE_POWERPC
	IMAGE_FILE_MACHINE_POWERPC,
#else
	0x1F0,
#endif
	0x290			/* HPPA currently has no define in ntimage.h */
};

#define MC_TAB_SIZE	(sizeof(machineIds) / sizeof(machineIds[0]))

LOCAL IBOOL	cUnderscore;	/* Does target precede symbols with '_'. */

#ifdef STAND_ALONE
/*(
=============================== open_gen_file ==============================
PURPOSE:
        Open output file if running stand alone.
INPUT:
        file - output file path.
OUTPUT:
        None.
============================================================================
)*/
LOCAL void open_gen_file IFN1(CHAR *, file)
{
	out_file = fopen(file, "wb");
	if (out_file == NULL)
	{
		printf("Could not open %s for writing.\n", out_file);
		exit(-1);
	}
}

/*(
============================== close_gen_file ==============================
PURPOSE:
        Closes the output file if runnong stand-alone.
INPUT:
        None.
OUTPUT:
        None.
============================================================================
)*/
LOCAL void close_gen_file IFN0()
{
	fclose(out_file);
}

/*(
============================== abort_gen_file ==============================
PURPOSE:
        Aborts output if running stand-alone.
INPUT:
        None.
OUTPUT:
        None.
============================================================================
)*/
LOCAL void abort_gen_file IFN0()
{
	printf("Output aborted.\n");
	fclose(out_file);
	exit(-1);
}
#endif /* STAND_ALONE */

/*(
=============================== getMachineId ===============================
PURPOSE:
        Get the machine ID field either from the environment or compiler
	defines.
INPUT:
        None.
OUTPUT:
        A 16-bit machine ID.
============================================================================
)*/
LOCAL IU16 getMachineId IFN0()
{
	CHAR	*mcstr,
		*end;
	IU32	i,
		val;
	IU16	machineId = IMAGE_FILE_MACHINE_UNKNOWN;
	IBOOL	gotMachineId = FALSE;

	/*
	 * Order of priority is (highest priority first):
	 *
	 *	COFF_MACHINE_ID environment variable, which can be a machine
	 *	string (see machineStrings for valid strings) or a hex number.
	 *
	 *	Machine type defined by compiler.
	 *
	 *	Unknown machine type.
	 */

	/* See if an environmenet  variable is set. */
	mcstr = getenv("COFF_MACHINE_ID");
	if (mcstr != NULL)
	{

		/* Check for a valid machine string. */
		for (i = 0; i < MC_TAB_SIZE; i++)
		{
			if (strcmp(mcstr, machineStrings[i]) == 0)
				break;
		}
		if (i < MC_TAB_SIZE)
		{

			/* Got a valid string. */
			machineId = machineIds[i];
			gotMachineId = TRUE;
		}
		else
		{

			/* Is environment variable a 16-bit hex number? */
			val = strtoul(mcstr, &end, 16);
			if ((*end == '\0') && (val < 0x10000))
			{
				machineId = (IU16) val;
				gotMachineId = TRUE;
			}
		}

		/* If environment variable not valid print possibilities. */
		if (!gotMachineId)
		{
			printf("\n=========================================\n");
			printf("COFF_MACHINE_ID=%s invalid\n", mcstr);
			printf("Valid strings are -\n");
			for (i = 0; i < MC_TAB_SIZE; i++)
				printf("\t%s\n", machineStrings[i]);
			printf("\n\tOR\n");
			printf("\n\tA 16-bit hexadecimal number\n");
			printf("=========================================\n\n");
		}
	}

	/*
	 * Get the default machine type according to predefined compiler
	 * defines.
	 */
	if (!gotMachineId)
	{

#ifdef _X86_
		machineId = IMAGE_FILE_MACHINE_I386;
#endif /* _X86_ */

#ifdef _MIPS_
		machineId = IMAGE_FILE_MACHINE_R4000;
#endif /* _MIPS_ */

#ifdef _PPC_
		machineId = IMAGE_FILE_MACHINE_POWERPC;
#endif /* _PPC_ */

#ifdef ALPHA
		machineId = IMAGE_FILE_MACHINE_ALPHA;
#endif /* ALPHA */

		/* Empty brace if none of the above are defined. */
	}
#ifndef PROD
	printf("machineId = %#x\n", machineId);
#endif /* PROD */
	return(machineId);
}

/*(
============================== getDatFileSize ==============================
PURPOSE:
	Get the size of a data file.
INPUT:
	infilepath	- path to input file
	len		- address of variable to hold length
OUTPUT:
	TRUE if length was successfully found,
	FALSE otherwise.
============================================================================
)*/
LOCAL IBOOL getDatFileSize IFN2(CHAR *, infilepath, IU32 *, len)
{
	HANDLE	hInFile;
	DWORD	fileLen;

	/* Get file size. */
	hInFile = CreateFile(infilepath,
			     GENERIC_READ,
			     (DWORD) 0,
			     (LPSECURITY_ATTRIBUTES) NULL,
			     OPEN_EXISTING,
			     (DWORD) 0,
			     (HANDLE) NULL);
	if (hInFile != INVALID_HANDLE_VALUE)
		fileLen = GetFileSize(hInFile, (LPDWORD) NULL);
	if ((hInFile == INVALID_HANDLE_VALUE) || (fileLen == 0xffffffff))
	{
		printf("Cannot get size of %s\n", infilepath);
		return(FALSE);
	}
	if (CloseHandle(hInFile) == FALSE)
	{
		printf("CloseHandle on %s failed.\n", infilepath);
		return(FALSE);
	}
	*len = (IU32) fileLen;
	return(TRUE);
}

/*(
================================= dat2obj ==================================
PURPOSE:
        Produce a COFF object file from an input data file.
INPUT:
        label           - data label name
        datfile         - data file name
	machineId	- 16-bit machine ID stamp
OUTPUT:
	None.
============================================================================
)*/
LOCAL void dat2obj IFN3(char *, label, char *, datfile, IU16, machineId)
{
	IMAGE_FILE_HEADER	fhdr;
	IMAGE_SECTION_HEADER	shdr;
	IMAGE_SYMBOL		syms[2];
	IMAGE_AUX_SYMBOL	aux[2];
	IU32			padding = 4;

	CHAR	labname[9];		/* 8 chars+terminator */
	CHAR	outfilename[11];	/* 8 chars+".o"+terminator */
	CHAR	infilepath[256];
	CHAR	buffer[BUFSIZ];
	IU32	len,
		count;
	IS32	i;
	FILE 	*infile;

	if (cUnderscore)
	{
		labname[0] = '_';
		strncpy(&labname[1], label, 7);	/* will be padded with zeros */
	}
	else
	{
		strncpy(labname, label, 8);	/* will be padded with zeros */
	}
	labname[8] = '\0';

	sprintf(outfilename, "%s.obj", label);
	
	sprintf(infilepath, "%s", datfile);

	/* Get file size. */
	if (getDatFileSize(infilepath, &len) == FALSE)
		return;

	/* construct the various headers */
	fhdr.Machine = machineId;
	fhdr.NumberOfSections = 1;		/* .text */
	fhdr.TimeDateStamp = 0;		/* no timestamps here */

#ifdef WITHSIZE

	/* We add the length of the input file for test purposes. */
	fhdr.PointerToSymbolTable = sizeof(fhdr) + sizeof(shdr) + sizeof(len) +
				    len;
#else
	fhdr.PointerToSymbolTable = sizeof(fhdr) + sizeof(shdr) + len;
#endif /* WITHSIZE */

	fhdr.NumberOfSymbols = 3;	/* Section + Aux. + Label */
	fhdr.SizeOfOptionalHeader = 0;	/* no optional headers */
	fhdr.Characteristics =
		IMAGE_FILE_LINE_NUMS_STRIPPED |		/* No line numbers. */
		IMAGE_FILE_32BIT_MACHINE;		/* 32 bit word. */

	/* no optional header */

	memcpy(shdr.Name, SECNAME, 8);
	shdr.Misc.PhysicalAddress = 0;
	shdr.VirtualAddress = 0;
#ifdef WITHSIZE

	/* We add the length of the input file for test purposes. */
	shdr.SizeOfRawData = sizeof(len) + len;
#else
	shdr.SizeOfRawData = len;	/* assumed a multiple of 4 */
#endif /* WITHSIZE */

	shdr.PointerToRawData = sizeof(fhdr) + sizeof(shdr);

	shdr.PointerToRelocations = 0;	/* no relocation information */
	shdr.PointerToLinenumbers = 0;	/* no line number information */
	shdr.NumberOfRelocations = 0;
	shdr.NumberOfLinenumbers = 0;

	shdr.Characteristics =
		IMAGE_SCN_CNT_INITIALIZED_DATA |	/* Initialized data. */
		IMAGE_SCN_ALIGN_4BYTES |		/* Align4. */
		IMAGE_SCN_MEM_READ |			/* Read. */
		IMAGE_SCN_MEM_WRITE;			/* Write. */

	/* 1st symbol. */
	memcpy(syms[0].N.ShortName, SECNAME, 8);
	syms[0].Value = 0;
	syms[0].SectionNumber = 1;			/* first section */
	syms[0].Type = 0;				/* notype */
	syms[0].StorageClass = IMAGE_SYM_CLASS_STATIC;	/* static */
	syms[0].NumberOfAuxSymbols = 1;

	/* 1st symbol auxiliary. */
#ifdef WITHSIZE

	/* We add the length of the input file for test purposes. */
	aux[0].Section.Length = sizeof(len) + len;
#else
	aux[0].Section.Length = len;
#endif /* WITHSIZE */
	aux[0].Section.NumberOfRelocations = 0;
	aux[0].Section.NumberOfLinenumbers = 0;
	aux[0].Section.CheckSum = 0;
        aux[0].Section.Number = 0;
	aux[0].Section.Selection = 0;

	/* 2nd symbol. */
	memcpy(syms[1].N.ShortName, labname, 8);
	syms[1].Value = 0;
	syms[1].SectionNumber = 1;	
	syms[1].Type = 0;
	syms[1].StorageClass = IMAGE_SYM_CLASS_EXTERNAL;
	syms[1].NumberOfAuxSymbols = 0;

	infile = fopen(infilepath, "rb");
	if (infile == NULL) {
		printf("Unable to open %s for reading\n", infilepath);
		perror(infilepath);
		return;
	}

	open_gen_file(outfilename);
	if (out_file == stderr) {
		return;
	}

	/* Write file header. */
	fwrite(&fhdr, sizeof(fhdr), 1, out_file);

	/* Write section header. */
	fwrite(&shdr, sizeof(shdr), 1, out_file);

#ifdef WITHSIZE

	/* Write size of file for test purposes. */
	fwrite(&len, sizeof(len), 1, out_file);

#endif /* WITHSIZE */

	/* Write data. */
	count = 0;
	do {
		i = fread(buffer, 1, sizeof(buffer), infile);
		if (i < 0) {
			fprintf(stderr, "problem reading %s\n", infilepath);
			perror(infilepath);
			abort_gen_file();
		}
		fwrite(buffer, i, 1, out_file);
		count += i;
	} while (i > 0 && count < len);

	/* Write first symbol. */
	fwrite(&syms[0], SYMSIZE, 1, out_file);
	fwrite(&aux[0], AUXSIZE, 1, out_file);

	/* Write second symbol. */
	fwrite(&syms[1], SYMSIZE, 1, out_file);

	/* Write 04 00 00 00 to the end of the file. Don't know why this */
	/* is necessary, but the linker complains on MIPS and Alpha if   */
	/* isn't there.							 */
	fwrite(&padding, 4, 1, out_file);

	fclose(infile);
	close_gen_file();
}

#ifdef  TEST_CASE
#ifndef PROD
LOCAL IU32 testdata[] = {
	0x31415926,
	0x11223344, 0x55667788, 0x99aabbcc, 0xddeeff00,
	0x14142135 };
#endif
#endif

/*(
========================== host_convert_dat_files ==========================
PURPOSE:
        Convert thread.dat and online.dat to COFF format.
INPUT:
	None.
OUTPUT:
        None.
============================================================================
)*/
#ifdef STAND_ALONE
LOCAL void
#else
GLOBAL void
#endif /* STAND_ALONE */
host_convert_dat_files IFN2(char *,src,char *,dest)
{
	IU16	machineId;

	/* Set underscore flag here if we are part of onGen. */
#ifndef STAND_ALONE
#ifdef C_NO_UL
	cUnderscore = FALSE;
#else
	cUnderscore = TRUE;
#endif /* C_NO_UL */
#endif /* !STAND_ALONE */
	machineId = getMachineId();
	dat2obj(dest, src, machineId);
	//dat2obj("onsub", "online.dat", machineId);

#ifdef  TEST_CASE
#ifndef PROD
	/* Generate a specimen .dat file which we could write as 
	 * a .s file and compile directly: helpful for debugging.
	 */
	open_gen_file("test.dat");
	if (out_file == stderr) {
		return;
	}
	fwrite(&testdata, sizeof(testdata), 1, out_file);
	close_gen_file();

	dat2obj("testd", "test.dat", machineId);
#endif
#endif
}

#ifdef STAND_ALONE
/*(
=================================== main ===================================
PURPOSE:
        Wrapper for host_convert_dat_files if running stand-alone
============================================================================
)*/
__cdecl main(int argc, char *argv[])
{
	IBOOL argerr = FALSE;

	/*
     * Source file is the full filename of the lcif file
     * dest file/name is the name for the .obj and the symbol name within it
	 * one optional argument, -u, which specifies that 'C' symbols should
	 * be preceded by '_'.
	 */
	switch (argc)
	{
	case 3:
		cUnderscore = FALSE;
		break;
	case 4:
		if (strcmp(argv[argc-1], "-u") == 0)
			cUnderscore = TRUE;
		else
			argerr = TRUE;
		break;
	default:
		argerr = TRUE;
		break;
	}
	if (argerr)
	{
		printf("Usage - dat2obj <sourcefile> <dest file/name> [-u]\n");
		printf("\t-u - precede symbols with '_'\n");
		printf("\t<sourcefile> is the full pathname for the input lcif\n");
		printf("\t<dest file/name> is the dest name without the .obj and\n");
		printf("\t\t\tis the name of the symbol within the .obj file\n");
		return(-1);
	}
	host_convert_dat_files(argv[1],argv[2]);
	return(0);
}
#endif /* STAND_ALONE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\cfpu_def.h ===
/*[
 *   Name:		host_npx.h
 *
 *   SCCS ID:		@(#)cfpu_def.h	1.13 10/13/94
 *
 *   Purpose:		More dodgy, non-portable structures!
 *
 * (C) Copyright Insignia Solutions, 1994.
]*/

typedef double 		FPH;

#define FPHOST FP64
#define HOST_MAX_EXP 2047
#if !defined(HOST_BIAS)
#define HOST_BIAS 1023
#endif
typedef struct {
IU32	sign:1;
IU32	exp:8;
IU32	mant:23;
} FP32;

typedef struct {
IU32 	sign:1;
IU32	exp:11;
IU32	mant_hi:20;
} FP64HI;

typedef struct {
IU16	sign:1;
IU16	exp:15;
} FP80SE;

//#ifdef BIGEND

typedef struct {
FP64HI	hiword;
IU32	mant_lo;
} FP64;


typedef struct {
IS32 high_word;
IU32 low_word;
} FPU_I64;

/*
 * The format of an FP80 has to be 
 * struct { IU64 mant; IU16 sign_exp }
 * to match the Acpu.
 */

typedef struct {
IU32	mant_hi;
IU32	mant_lo;
FP80SE	sign_exp;
} FP80;

//#endif

/* HOST_ values are based on a byte ordering where 0 represents the first
 * byte.  They are used to copy n-byte values represented in bigendian-order
 * to a host memory location in host-order. The definition is therefore
 * determined by whether the host is bigendian or littleendian.
 */

#ifdef BIGEND

/* Format for double precision on bigendian host */
#define HOST_R64_BYTE_0 0
#define HOST_R64_BYTE_1 1
#define HOST_R64_BYTE_2 2
#define HOST_R64_BYTE_3 3
#define HOST_R64_BYTE_4 4
#define HOST_R64_BYTE_5 5
#define HOST_R64_BYTE_6 6
#define HOST_R64_BYTE_7 7

/* Format for internal representation of an R80 on bigendian host */
/* This reflects the struct { IU64 mant; IU16 sign_exp } format of FP80 */
#define HOST_R80_BYTE_0 8
#define HOST_R80_BYTE_1 9
#define HOST_R80_BYTE_2 0
#define HOST_R80_BYTE_3 1
#define HOST_R80_BYTE_4 2
#define HOST_R80_BYTE_5 3
#define HOST_R80_BYTE_6 4
#define HOST_R80_BYTE_7 5
#define HOST_R80_BYTE_8 6
#define HOST_R80_BYTE_9 7

#define NPX_LOW_32_BITS  1
#define NPX_HIGH_32_BITS 0
#endif	/* BIGEND */

#ifdef LITTLEND
/* Format for double precision on littleendian host */
#define HOST_R64_BYTE_0 7
#define HOST_R64_BYTE_1 6
#define HOST_R64_BYTE_2 5
#define HOST_R64_BYTE_3 4
#define HOST_R64_BYTE_4 3
#define HOST_R64_BYTE_5 2
#define HOST_R64_BYTE_6 1
#define HOST_R64_BYTE_7 0

/* Format for internal representation of an R80 on littleendian host */
#define HOST_R80_BYTE_0 9
#define HOST_R80_BYTE_1 8
#define HOST_R80_BYTE_2 7
#define HOST_R80_BYTE_3 6
#define HOST_R80_BYTE_4 5
#define HOST_R80_BYTE_5 4
#define HOST_R80_BYTE_6 3
#define HOST_R80_BYTE_7 2
#define HOST_R80_BYTE_8 1
#define HOST_R80_BYTE_9 0

#define NPX_LOW_32_BITS  0
#define NPX_HIGH_32_BITS 1
#endif /* LITTLEND */


#ifdef NTVDM
#include <float.h>

#define HostGetOverflowException()	(_controlfp(0, 0) & _EM_OVERFLOW)
#define HostGetUnderflowException()	(_controlfp(0, 0) & _EM_UNDERFLOW)
#define HostGetPrecisionException()	(_controlfp(0, 0) & _EM_INEXACT)

#define HostClearExceptions()		((VOID)_controlfp(0, _MCW_EM))

#define HostSetRoundToNearest()		((VOID)_controlfp(_RC_NEAR, _MCW_RC))
#define HostSetRoundDown()		    ((VOID)_controlfp(_RC_DOWN, _MCW_RC))
#define HostSetRoundUp()		    ((VOID)_controlfp(_RC_UP, _MCW_RC))
#define HostSetRoundToZero()		((VOID)_controlfp(_RC_CHOP, _MCW_RC))

/*************************************/
#define HUGE_VAL 1.8e308

/*
 *      Useful mathmatical constants:
 *
 * M_E          - e
 * M_LOG2E      - log2(e)
 * M_LOG10E     - log10(e)
 * M_LN2        - ln(2)
 * M_LN10       - ln(10)
 * M_PI         - pi
 * M_PI_2       - pi/2
 * M_PI_4       - pi/4
 * M_1_PI       - 1/pi
 * M_2_PI       - 2/pi
 * M_2_SQRTPI   - 2/sqrt(pi)
 * M_SQRT2      - sqrt(2)
 * M_SQRT1_2    - 1/sqrt(2)
*/

#define M_E        2.7182818284590452354E0  /*Hex  2^ 0 * 1.5bf0a8b145769 */
#define M_LOG2E    1.4426950408889634074E0  /*Hex  2^ 0 * 1.71547652B82FE */
#define M_LOG10E   4.3429448190325182765E-1 /*Hex  2^-2 * 1.BCB7B1526E50E */
#define M_LN2      6.9314718055994530942E-1 /*Hex  2^-1 * 1.62E42FEFA39EF */
#define M_LN10     2.3025850929940456840E0  /*Hex  2^ 1 * 1.26bb1bbb55516 */
#define M_PI       3.1415926535897932385E0  /*Hex  2^ 1 * 1.921FB54442D18 */
#define M_PI_2     1.5707963267948966192E0  /*Hex  2^ 0 * 1.921FB54442D18 */
#define M_PI_4     7.8539816339744830962E-1 /*Hex  2^-1 * 1.921FB54442D18 */
#define M_1_PI     3.1830988618379067154E-1 /*Hex  2^-2 * 1.45f306dc9c883 */
#define M_2_PI     6.3661977236758134308E-1 /*Hex  2^-1 * 1.45f306dc9c883 */
#define M_2_SQRTPI 1.1283791670955125739E0  /*Hex  2^ 0 * 1.20dd750429b6d */
#define M_SQRT2    1.4142135623730950488E0  /*Hex  2^ 0 * 1.6A09E667F3BCD */
#define M_SQRT1_2  7.0710678118654752440E-1 /*Hex  2^-1 * 1.6a09e667f3bcd */


#define MAXFLOAT            ((float)3.40282346638528860e+38)

#	define HUGE 1.8e308
#define M_2PI      6.2831853071795864769E0  /*Hex  2^ 2 * 1.921FB54442D18 */

/* This is the nearest number to the cube root of MAXDOUBLE that   */
/*      doesn't cause the cube of it to overflow.                  */
/* In double precision hex this constant is: 554428a2 f98d728a     */
#define CUBRTHUGE      5.6438030941223618e102
#define INV_CUBRTHUGE  1.7718548704178434e-103

#else	/* !NTVDM */

#define HostGetOverflowException()      (fpgetsticky() & FP_X_OFL)
#define HostGetUnderflowException()     (fpgetsticky() & FP_X_UFL)
#define HostGetPrecisionException()     (fpgetsticky() & FP_X_IMP)

#define HostClearExceptions()           ((VOID)fpsetsticky(FP_X_CLEAR))

#define HostSetRoundToNearest()         ((VOID)fpsetround(FP_RN))
#define HostSetRoundDown()              ((VOID)fpsetround(FP_RM))
#define HostSetRoundUp()                ((VOID)fpsetround(FP_RP))
#define HostSetRoundToZero()            ((VOID)fpsetround(FP_RZ))

#endif	/* !NTVDM */

#ifndef _Fpu_c_h

/* These definitions are for the Ccpu NPX only: in circumstances
 * where both the C NPX and the Assembler NPX are accessed, these
 * definitions should be excluded in favour of the generated ones in
 * Fpu_c.h, hence the #ifndef above.
 */

typedef struct {
FPH fpvalue;
IUH padding;    /* To allow at least 10 bytes for unconverted formats */
IUH tagvalue;
} FPSTACKENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\error.h ===
#ifndef _INS_ERROR_H
#define _INS_ERROR_H
/*[
	Name:		error.h
	Derived From:	Base 2.0
	Author(s):	M.McCusker and J.D.R. (config msgs)
	Created On:	Unknown
	Sccs ID:	@(#)error.h	1.13 9/2/91
	Purpose:	Define the list of error messages and also the
			interface to the host_error family of functions.
	Notes:		This file is guarded against multiple inclusion.

MUST INCLUDE
	insignia.h

DESCRIPTION
	This file provides an interface into the SoftPC error handling system.

	It defines the main generic base error messages in a large enum.

	It also defines a list of error headers and variants.  3.0 host_error
	Now looks up the error code in a table of ERROR_STRUCTs to find what
	header to print and also in which of the possible variants to format
	the error panel.

	Header types are:-
		EH_WARNING		A warning message
		EH_ERROR		Runtime Error
		EH_CONFIG		Configuration File Problem
		EH_INSTALL		installation File Problem.

	Each variant has up to three separate strings that will be printed on
	the panel.  These strings change function depending on the error
	variant.

	Variant types are:-
		EV_SIMPLE		Simple Error Pnael, Message Only.
		EV_EXTRA_CHAR		Extra Char panel, current default.
		EV_BAD_FILE		Config Error variant bad file.
		EV_SYS_BAD_VALUE	Config System Bad Entry.
		EV_BAD_VALUE		Config bad user config entry.
		EV_BAD_INPUT		Input also variant of EV_EXTRA_CHAR.

	Each variant interprets the ErrData structure a little differently.
	The BAD VALUE/INPUT variants also allow input form the error panel
	into string_1 of the ErrData Structure.  For input if the user hits
	the Continue button on the panel the input filed is strcpy'd to
	string_1.  string_1 MUST be a pointer to an adequately sized char[].
	
		Name			Parameters
		EV_SIMPLE		No parameters required.
		EV_EXTRA_CHAR		1 - Extra Char.
		EV_BAD_FILE		1 - Name of problem file.
		EV_SYS_BAD_VALUE	1 - Current Value of entry.
					2 - Bad Option option name.
		EV_BAD_VALUE		1 - Current value char array (i/o).
					2 - Bad Option Name.
					3 - System Default Value.
		EV_BAD_INPUT		1 - Problem Line (i/o).

IMPORTED DATA
Error Description Tables	ERROR_STRUCT base_errors[];
				ERROR_STRUCT host_errors[];

base and host errors	Tables indexed by the error code that provide
			host_error_ext with the header and variant types.

TYPEDEFS

Parameter to extended error	struct
				{
					char *string_1;
					char *string_2;
					char *string_3;
				} ErrData, *ErrDataPtr;

Error Function Pointers		struct
				{
					SHORT (*error_conf)();
					SHORT (*error)();
					SHORT (*error_ext)();
				} ERRORFUNCS;

Ancillary data per error	struct
				{
					CHAR header;
					CHAR variant;
				} ERROR_STRUCT;

The error code enum,		See header file for details.

GLOBAL FUNCTIONS

Current Error Function Table	IMPORT ERRORFUNCS *working_error_funcs;

Error Macros			host_error_conf(panel, num, opts, extra)
				host_error(num, opts, extra)
				host_error_ext(num, opts, data)

host_error_conf

	SHORT host_error_conf
		(int panel, int errCode, int buttons, char *extraChar)

	host_error_conf will not be supported by the 3.0 generic Motif UIF.
	This call will just be a straight front end to a call of
	host_error_ext.

	See Also host_error_ext.

host_error

	SHORT host_error(int errCode, int buttons, char *extraChar)

	This function loads extraChar into string one of a local ErrData
	structure and calls host_error_ext.
	
	See also host_error_ext.

host_error_ext

	SHORT host_error_ext(int errCode, int buttons, ErrDataPtr errDataP)

	ErrCode is an index into either the base_errors array or the
	host_errors array, 1-999 base, 1001-1999 host_errors.  The header
	code and the variant type is looked up in this array.

	A maximum of three buttons can be or'ed into the buttons parameter
	which are: ERR_QUIT, ERR_CONT, ERR_RESET, ERR_DEF & ERR_CONFIG any
	three of these can be used, NB ERR_CONFIG and ERR_DEF are exactly the
	same ERR_CONFIG is provided for backwards compatibility.  The
	following macros are provided for convenience:-
		ERR_QU_CO_RE
		ERR_QU_CO_DE
		ERR_QU_CO
		ERR_QU_RE
		ERR_QU_DE
		ERR_STANDARD		Here for compatibility

	After the panel is displayed, and the user chooses an option button is
	interpreted as follows:-
		ERR_QUIT  - Call terminate(), doesn't return.
		ERR_CONT  - For some variants strcpy the input field.
		ERR_RESET - Calls Reboot.
		ERR_DEF } - No action.
		ERR_CONFIG}

	Finally, host_error_ext returns the option the user selected.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Button bit mask values
 */

#define	ERR_QUIT	1
#define	ERR_CONT	2
#define	ERR_RESET	4
#define	ERR_DEF		8
#define	ERR_CONFIG	8

#define	ERR_QU_CO_RE	( ERR_QUIT | ERR_CONT | ERR_RESET )
#define	ERR_QU_CO_DE	( ERR_QUIT | ERR_CONT | ERR_DEF )
#define	ERR_QU_CO	( ERR_QUIT | ERR_CONT )
#define	ERR_QU_RE	( ERR_QUIT | ERR_RESET )
#define	ERR_QU_DE	( ERR_QUIT | ERR_DEF )

#define	ERR_STANDARD	( ERR_QU_CO_RE )	/* here for compatibility */

/*
 * The following are the Generic Error messages displayed by
 * SoftPC.  Host Specific messages are defined in xxxx_error.h
 * where xxxx is the machine ID.
 *
 */

#define EG_BAD_OP               0
#define EG_OWNUP                1
#define EG_NO_ROM_BASIC         2
#define EG_EXPANDED_MEM_FAILURE 3
#define EG_CONT_RESET           4
////#define EG_NO_REZ_UPDATE        5
////#define EG_REZ_UPDATE           6
#define EG_MALLOC_FAILURE       7
#define EG_SYS_MISSING_SPCHOME  8
#define EG_SYS_MISSING_FILE     9
#define EG_WRITE_ERROR         10
////#define EG_BAD_COMMS_NAME      11
#define EG_BAD_VALUE           12
#define EG_BAD_CONF            13
////#define EG_GATE_A20            14
////#define EG_EMM_CONFIG          15
////#define EG_DATE_FWD            16
////#define EG_DATE_BACK           17
#define EG_PIF_BAD_FORMAT      18
#define EG_PIF_STARTDIR_ERR    19
#define	EG_PIF_STARTFILE_ERR   20
#define EG_PIF_CMDLINE_ERR     21
#define EG_PIF_ASK_CMDLINE     22
#define EG_ENVIRONMENT_ERR     23
#define EG_INSUF_MEMORY        24
#define EG_BAD_OP386           25
#define EG_BAD_EMM_LINE        26
#define EG_BAD_FAULT           27
#define EG_DOS_PROG_EXTENSION  28

#define NUM_BASE_ERRORS        29

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifndef MONITOR
#ifdef ANSI

  /*
   *  Do things the old fashioned way for some of the cpu building tools
   *  which cannot be changed to match our host
   */

typedef struct {
  char *string_1;
  char *string_2;
  char *string_3;
} ErrData, *ErrDataPtr;

typedef struct
{
	SHORT (*error_conf)(int, int, int, char *);
	SHORT (*error)(int, int, char *);
	SHORT (*error_ext)(int, int, ErrDataPtr);
} ERRORFUNCS;

#else /* ANSI */

typedef struct
{
	SHORT (*error_conf)();
	SHORT (*error)();
	SHORT (*error_ext)();
} ERRORFUNCS;

#endif /* ANSI */
#endif


#if !defined(BUILDING_CPU_TOOL)
SHORT host_error(int error_num, int options, char *extra_char);
#define host_error_conf(config_panel, error_num,options,extra_char)  \
        host_error(int error_num, int options, char *extra_char)
#else

IMPORT ERRORFUNCS *working_error_funcs;

#define host_error_conf(panel, num, opts, extra)\
		(*working_error_funcs->error_conf)(panel, num, opts, extra)

#define host_error(num, opts, extra)\
		(*working_error_funcs->error)(num, opts, extra)

#define host_error_ext(num, opts, data)\
		(*working_error_funcs->error_ext)(num, opts, data)
#endif


   // ntvdm specific error message services
// WARINING !! keep the following defines synchronized with softpc.h
#define NOSUPPORT_FLOPPY      0
#define NOSUPPORT_HARDDISK    1
#define NOSUPPORT_DRIVER      2
#define NOSUPPORT_OLDPIF      3
#define NOSUPPORT_ILLBOP      4
#define NOSUPPORT_NOLIM       5
#define NOSUPPORT_MOUSEDRVR   6



VOID host_direct_access_error(ULONG type);
void RcErrorDialogBox(UINT wId, CHAR *msg1, CHAR *msg2);
VOID RcErrorBoxPrintf(UINT wId, CHAR *szMsg);


/*
 *  RcMessageBox\EditBox stuff
 */
#define RMB_ABORT        1
#define RMB_RETRY        2
#define RMB_IGNORE       4
#define RMB_ICON_INFO    8
#define RMB_ICON_BANG   16
#define RMB_ICON_STOP   32
#define RMB_ICON_WHAT   64
#define RMB_EDIT       128
#define RMB_FLAGS_MASK 0x0000FFFF
#define RMB_EDITBUFFERSIZE_MASK 0xFFFF0000
// hiword of dwOptions is reserved for RMB_EDIT text buffer size


int RcMessageBox(UINT wId, CHAR *msg1, CHAR *msg2, ULONG dwOptions);

#ifndef PROD
void HostDebugBreak(void);
#endif



//
// SysErrorBox stuff -- duplicated in usersrv.h *and* kernel.inc
//
#define  SEB_OK         1  /* Button with "OK".     */
#define  SEB_CANCEL     2  /* Button with "Cancel"  */
#define  SEB_YES        3  /* Button with "&Yes"     */
#define  SEB_NO         4  /* Button with "&No"      */
#define  SEB_RETRY      5  /* Button with "&Retry"   */
#define  SEB_ABORT      6  /* Button with "&Abort"   */
#define  SEB_IGNORE     7  /* Button with "&Ignore"  */
#define  SEB_CLOSE      8  /* Button with "&Close"   */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

ULONG WOWSysErrorBox(
    CHAR *szTitle,
    CHAR *szMessage,
    USHORT wBtn1,
    USHORT wBtn2,
    USHORT wBtn3
    );

#endif /* _INS_ERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: host.h
 *
 * Description	: Host specific declarations for the machine dependant
 *		  modules of SoftPC.
 *
 * Author	: Henry Nash
 *
 * Notes	: Everything in here must portable !!!
 *
 * Mods: (r2.13): Added export reference to host_flip_real_floppy_ind(),
 *                which will toggle on or off any indication that the
 *                current SoftPC may be displaying concerning the allocation
 *                of the real floppy drive. This function is exported by
 *                xxxx_graph.c.
 */

/* SccsID[]="@(#)host.h	1.3 8/6/90 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern void host_scroll_screen();
extern void host_move_cursor();
extern void host_enable_cursor();
extern void host_disable_cursor();
extern void host_cursor_off();
extern void host_tty();

extern void host_flip_real_floppy_ind();

extern void host_ring_bell();
extern void host_alarm();
extern void host_sound_start();
extern void host_sound_stop();

extern void host_simulate();
extern void host_cpu_init();
extern void host_cpu_interrupt();


extern void host_floppy_init();
extern void host_floppy_term();
extern void host_reset();
extern void host_start_server();
extern void host_terminate();

extern boolean host_rdiskette_open_drive();

/* Unix Utilities - xxxx_unix.c */
extern char *host_get_cur_dir();

#define C_LPT1 C_LPT1_NAME
#define C_LPT2 C_LPT2_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\debugger\vdmdebug.c ===
/*

    Filename : vdmdebug.c
    Author   : D.A.Bartlett
    Purpose  : Provide a debug window for softpc


*/

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#include "windows.h"

#include "stdio.h"
#include "stdlib.h"

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::: Internal macros */

#define UNREFERENCED_FORMAL_PARAMETER(x) (x)

#define RDNS_OK 	   (0)
#define RDNS_ERROR	   (1)
#define RDNS_INPUT_REQUEST (2)


#define DEFAULT_PIPE_NAME  "\\\\.\\pipe\\softpc"
#define DEFAULT_EVENT_NAME "YodaEvent"
#define DEFAULT_LOG_FILE   "\\vdmdebug.log"

/*:::::::::::::::::::::::::::::::::::::::::::: Internal function protocols */

BOOL GetSendInput(HANDLE pipe, CHAR *LastPrint);
int ReadDisplayNxtString(HANDLE pipe, CHAR *Buf, INT BufSize, DWORD *error);
BOOL CntrlHandler(ULONG CtrlType);
VOID DebugShell(CHAR *LastPrint, CHAR *Command);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Static globals */

HANDLE YodaEvent;
FILE *LogHandle;

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: */

__cdecl main(int argc, char *argv[])
{

    HANDLE pipe;		// Handle of pipe
    char *pipeName;		// Pipe name
    char *eventName;		// Yoda event object name
    CHAR buffer[500];		// Buffer to read pipe data into
    CHAR OrgConsoleTitle[250];	// Orginal console title
    BOOL PipeConnected;
    DWORD ReadError;		// Error returned from ReadFile

    UNREFERENCED_FORMAL_PARAMETER(argc);
    UNREFERENCED_FORMAL_PARAMETER(argv);

    /*:::::::::::::::::::::::::::::::::::::::::::::::::: Display copyright */

    printf("Softpc Debugging shell\n");
    printf("Copyright Insignia Solutions 1991, 1992\n\n");

    /*::::::::::::::::::::::::::::::::::::::::: Register Control-C handler */

    if(!SetConsoleCtrlHandler((PHANDLER_ROUTINE)CntrlHandler,TRUE))
    {
	/*.......................................... Failed to create pipe */

	printf("Failed to register a Control-C handler, error (%d)\n",
	       GetLastError());

	return(-1);
    }


    /*:::::::::::::::::::::::::: Validate environment and input parameters */

    if((pipeName = getenv("PIPE")) == NULL)
	pipeName = DEFAULT_PIPE_NAME;

    /*::::::::::::::::::::::::::::::::::::: Attempt to create a named pipe */

    if((pipe = CreateNamedPipe(pipeName,
			   PIPE_ACCESS_DUPLEX | FILE_FLAG_WRITE_THROUGH,
			   PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE,
			   2, 1024, 1024, 0, NULL)) == (HANDLE) -1)
    {
	/*.......................................... Failed to create pipe */

	printf("Failed to create pipe (%s), error (%d)\n", pipeName,
					    GetLastError());

	return(-1);
    }
    else
	printf("Successfully created communications pipe (%s)\n\n",pipeName);

    /*::::::::::::::::::::::::::::::::::::::::: Get Yoda event object name */

    if((eventName = getenv("EVENT")) == NULL)
	eventName = DEFAULT_EVENT_NAME;

    /*::::::::::::::::::::::::::::::::::::::::::: Create YODA event object */

    if((YodaEvent = CreateEvent(NULL,TRUE,FALSE,eventName))==NULL)
    {
	/*.......................................... Failed to create pipe */

	printf("Failed to create yoda event (%s), error (%d)\n", eventName,
						  GetLastError());

	return(-1);
    }
    else
	printf("Successfully created Yoda event object (%s)\n\n",eventName);

    printf("Use Control-C to break into Yoda\n\n");

    /*:::::::::::::::::::::::::::::::::::::::::::::::: Setup console title */

    GetConsoleTitle(OrgConsoleTitle, sizeof(OrgConsoleTitle));
    SetConsoleTitle("Softpc Debugger");

    /*:::::::::::::::::::::::::: Wait for a process to connect to the pipe */

    while(1)
    {
	ResetEvent(YodaEvent);
	printf("Waiting for ntvdm to connect............\n\n");

	if(!ConnectNamedPipe(pipe,NULL))
	{
	    printf("ConnectNamedPipe failed (%d)\n",GetLastError());
	    SetConsoleTitle(OrgConsoleTitle);
	    return(-1);
	}

	printf("Softpc connected successfully to debug shell....\n\n");
	PipeConnected = TRUE;

	/*::::::::::::::::::::::::::::: Read data from pipe and display it */

	while(PipeConnected)
	{
	    /*........................................ Read data from pipe */

	    switch(ReadDisplayNxtString(pipe,buffer,sizeof(buffer),&ReadError))
	    {
		/*..................................... Handle read errors */

		case RDNS_ERROR :

		    if(ReadError == ERROR_BROKEN_PIPE)
		    {
			printf("\nError Pipe broken\n\n");
			DisconnectNamedPipe(pipe);
			PipeConnected = FALSE;

		    }
		    else
			printf("ReadFile failed (%d)\n",ReadError);

		    break;

		/*................................... Handle input request */

		case RDNS_INPUT_REQUEST :

		    GetSendInput(pipe,buffer);
		    break;
	    }
	}
    }	/* End of connect loop */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::: Get input from console :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

BOOL GetSendInput(HANDLE pipe, CHAR *LastPrint)
{
    char buffer[500];		// Input buffer
    char bufsizstr[2];		// Buffer size string
    int bufsize;
    DWORD BytesWritten;

    /*::::::::::::::::: Get string from the console, remove new line marker */

    while(1)
    {
	gets(buffer);			// Get input from prompt
	if(*buffer != '!') break;	// Enter debug shell ?
	DebugShell(LastPrint, buffer);	// Entry vdmdebug shell
    }

    if((bufsize = strlen(buffer)) == 0)
    {
	bufsize = 1;
	buffer[0] = ' ';
	buffer[1] = 0;
    }

    /*::::::::::::::::::::::::::::: Construct and send buffer size string ! */

    bufsizstr[0] = (char) (bufsize%256);
    bufsizstr[1] = (char) (bufsize/256);

    if(!WriteFile(pipe, bufsizstr, 2, &BytesWritten, NULL))
    {
	printf("\n\nError writing to pipe (%d)\n",GetLastError());
	return(FALSE);
    }

    /*:::::::::::::::::::::::::::::::::::::::::::::::: Write string to pipe */

    if(!WriteFile(pipe, buffer, bufsize, &BytesWritten, NULL))
    {
	printf("\n\nError writing to pipe (%d)\n",GetLastError());
	return(FALSE);
    }

    return(TRUE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::: Read and display next string ::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

int ReadDisplayNxtString(HANDLE pipe, CHAR *Buf, INT BufSize, DWORD *error)
{
    DWORD RtnError = 0;		// Error return by function
    int NxtStringSize;		// Size of next string to read
    DWORD BytesRead;

    /*:::::::::::::::::::::::::::::::::::::::::: Wait for size of next size */

    if(!ReadFile(pipe, Buf, 2, &BytesRead, NULL))
    {
	*error = GetLastError();
	return(RDNS_ERROR);
    }

    /*::::::::::::::::::::::::::::: Have we just received and input request */

    if(Buf[0] == (char) 0xff && Buf[1] == (char) 0xff)
	return(RDNS_INPUT_REQUEST);

    /*:::::::::: Calculate and validate the size of the next string to read */

    NxtStringSize = (Buf[0]&0xff) + ((Buf[1]&0xff)*256);

    if(NxtStringSize >= BufSize)
    {
	printf("\nWARNING : BUFFER OVERFLOW(%x,%x -> %d \n\n",
	       Buf[0]&0xff,Buf[1]&0xff,NxtStringSize);
    }

    /*:::::::::::::::::::::::::::::::::::::::::::::::::::: Read next string */

    if(!ReadFile(pipe, Buf, NxtStringSize, &BytesRead, NULL))
    {
	*error = GetLastError();
	return(RDNS_ERROR);
    }

    /*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Display string */

    Buf[BytesRead] = 0;
    printf("%s",Buf);

    return(RDNS_OK);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::: Control-C handler :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


BOOL CntrlHandler(ULONG CtrlType)
{
    BOOL rtn = FALSE;	   // Default return event not handled

    /*:::::::::::::::::::::::::::::::::::::::::::: Process control  C event */

    if(CtrlType == CTRL_C_EVENT)
    {
	if(YodaEvent)
	{
	    SetEvent(YodaEvent);
	    Beep(0x100,1000);
	}

	rtn = TRUE;	  // Tell call the control event has been handled */
    }

    return(rtn);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::: Enter Debug Shell :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


VOID DebugShell(CHAR *LastPrint, CHAR *Command)
{
    switch(Command[1])
    {
	// Open log file

	case 'o' :
	case 'O' :
	    if((LogHandle = fopen(DEFAULT_LOG_FILE,"rw")) == NULL)
		printf("\nVDMDEBUG : Unable to open log file (%s)\n",DEFAULT_LOG_FILE);
	    else
		printf("\nVDMDEBUG : Opened log file (%s)\n",DEFAULT_LOG_FILE);

	    break;


	// Close log file

	    if(LogHandle == NULL)
		printf("\nVDMDEBUG : Log file not open\n");
	    else
	    {
		fclose(LogHandle);
		printf("\nVDMDEBUG : Closed log file (%s)\n",DEFAULT_LOG_FILE);
	    }
	    break;

	default:
	    printf("\nVDMDEBUG : Unrecognised Command\n");
	    break;
    }


    printf("%s",LastPrint);		// Print out orginal prompt
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\hostsync.h ===
/* @(#)hp_async.gi	1.1 07/12/89 Copyright Insignia Solutions Ltd. */

#define ASYNC_NOMEM	1
#define ASYNC_NBIO	2	
#define ASYNC_AIOOWN	3
#define ASYNC_AIOSTAT	4
#define ASYNC_BADHANDLE	5
#define ASYNC_NDELAY	6
#define ASYNC_BADHANDLER	7
#define ASYNC_BADOPN	8
#define ASYNC_FCNTL	9

#define ASYNC_XON	0
#define ASYNC_XOFF	1
#define ASYNC_IGNORE	2
#define ASYNC_RAW	3

int 	addAsyncEventHandler();
void 	initAsyncMgr();
int 	AsyncOperationMode();
int 	removeAsyncEventHandler();
void 	AsyncMgr();
void	terminateAsyncMgr();
int 	(*changeAsyncEventHandler())();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\hostgrph.h ===
/*
 * SccsID @(#)host_graph.h	1.8 12/3/90 Copyright Insignia Solutions Ltd.
 */

extern long pcwindow;
extern int terminal_type;

/* values for terminal type */
#define TERMINAL_TYPE_DUMB	0
#define TERMINAL_TYPE_SUN	1
#define TERMINAL_TYPE_X11	2
#define TERMINAL_TYPE_DEFAULT	TERMINAL_TYPE_SUN

/*
 * Bit masks for attribute bytes
 */

#define BLINK 		0x80	/* Blink bit		*/
#define BOLD		0x08	/* Bold bit		*/
#define BACKGROUND	0x70    /* Background bits	*/
#define FOREGROUND	0x07    /* Foreground bits	*/

#define MAX_FONT_PATHNAME_LEN	40

 /***********************************************************/
 /* In gfx_update.c/herc_update_screen(), the inner loop of */
 /*  the routine multiplies the row by the char height to   */
 /*  obtain the row to rop the screen data to. Since we     */
 /*  dont need to do this, we dont want an inner loop       */
 /*  performace hit so we remove the multiplication. But,   */
 /*  in keeping with the generic base file rule, we put     */
 /*  the define here in a host file on the Advice of        */
 /*  Andrew.                                                */
 /***********************************************************/

#ifndef SUN_VA
#define HOST_HERC_PAINT_OFFSET(row)	(row * get_char_height())
#else
#define HOST_HERC_PAINT_OFFSET(row)	(row)
#endif /* SUN_VA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_bop.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: host_bop.h
 *
 * Description	: Host dependent definitions for use by the control bop 
 *		  functions.
 *
 * Author	: J. Koprowski
 *
 * Notes	: None
 */


/* SccsID[]=" @(#)host_bop.h	1.2 11/17/89 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */
 
/*
 * Host type.
 */

#define HOST_TYPE		4

/*
 * Return codes from control bop type functions.  N.B. Error codes
 * zero through fifteen are defined in the base include file, cntlbop.h.
 */

#define ERR_NOT_FSA		16	/* Function 1 error. */
#define ERR_CMD_FAILED		17	/* Function 1 error. */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern void runux();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_cpu.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title        : Sparc 2.0 Definitions for the CPU
 *
 * Description  : Structures, macros and definitions for access to the
 *                CPU registers
 *
 * Author       : Andrew Guthrie
 *
 * Notes        : This file is included by cpu.h and should NOT
 *                be included directly by any other module.
 */

/* SccsID[]="@(#)host_cpu.h     1.22 4/15/91 Copyright Insignia Solutions Ltd."; */

#ifdef CPU_30_STYLE

#ifndef _HOST_CPU_H
#define _HOST_CPU_H


#ifdef MONITOR
#include <monregs.h>

#define	 getSTATUS() 	(getCF()        |	\
			getOF()   << 11 |	\
			getZF()   << 6  |	\
			getSF()   << 7  |	\
			getAF()   << 4  |	\
			getPF()   << 2  |	\
			getTF()   << 8  |	\
			getIF()   << 9  |	\
			getDF()   << 10 |	\
			getIOPL() << 12 |	\
			getNT()   << 14)

#endif

/*
 * Union representing different ways of accessing a register
 *
 * Should probably not be here, but is for historical reasons.
 *
 * If it goes, then host_cpu.h should have reached nirvana (i.e. be totally empty)!
 */

#ifdef BIGEND

typedef union
    {
        word    X;
    struct
        {                               /* as two bytes */
        half_word high;
        half_word low;
        word pad;
        } byte;
    struct
        {                               /* as 4 nibbles */
        word n3:4;
        word n2:4;
        word n1:4;
        word n0:4;
        word pad;
        } nibble;
    struct
        {                               /* as 16 bits   */
        word b15:1;
        word b14:1;
        word b13:1;
        word b12:1;
        word b11:1;
        word b10:1;
        word b9:1;
        word b8:1;
        word b7:1;
        word b6:1;
        word b5:1;
        word b4:1;
        word b3:1;
        word b2:1;
        word b1:1;
        word b0:1;
        word pad;
        } bit;
    } reg;

#endif /* BIGEND */


#ifdef LITTLEND

typedef union
    {
        word    X;
    struct
        {                               /* as two bytes */
        half_word low;
        half_word high;
        } byte;
    } reg;

#endif /* LITTLEND */






#endif
#else /* CPU_30_STYLE */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Union representing different ways of accessing a register
 */

typedef union
    {
        word    X;
    struct
        {                               /* as two bytes */
        half_word high;
        half_word low;
        word pad;
        } byte;
    struct
        {                               /* as 4 nibbles */
        word n3:4;
        word n2:4;
        word n1:4;
        word n0:4;
        word pad;
        } nibble;
    struct
        {                               /* as 16 bits   */
        word b15:1;
        word b14:1;
        word b13:1;
        word b12:1;
        word b11:1;
        word b10:1;
        word b9:1;
        word b8:1;
        word b7:1;
        word b6:1;
        word b5:1;
        word b4:1;
        word b3:1;
        word b2:1;
        word b1:1;
        word b0:1;
        word pad;
        } bit;
    } reg;

#ifdef A2CPU

/*
 * The Fast CPU status register structure ....
 */

typedef struct
{
    word pad:5;
    word DF:1;
    word IF:1;
    word TF:1;
    word pad1:8;
} sreg;

#endif A2CPU

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */
extern word m_s_w;

#ifndef EGATEST
#ifdef A2CPU
extern  int     compile_everything;
extern  short   host_event;
extern char *CPU_00[];          /* CPU main jump table            */
extern char *int_table[];       /* CPU interrupt jump table       */
#endif A2CPU


/*  common READ functions  */
#define  getAX()        ((*getAX_func) ())
#define  getAH()        ((*getAH_func) ())
#define  getAL()        ((*getAL_func) ())
#define  getBX()        ((*getBX_func) ())
#define  getBH()        ((*getBH_func) ())
#define  getBL()        ((*getBL_func) ())
#define  getCX()        ((*getCX_func) ())
#define  getCH()        ((*getCH_func) ())
#define  getCL()        ((*getCL_func) ())
#define  getDX()        ((*getDX_func) ())
#define  getDH()        ((*getDH_func) ())
#define  getDL()        ((*getDL_func) ())
#define  getSP()        ((*getSP_func) ())
#define  getBP()        ((*getBP_func) ())
#define  getSI()        ((*getSI_func) ())
#define  getDI()        ((*getDI_func) ())
#define  getIP()        ((*getIP_func) ())
#define  getCS()        ((*getCS_func) ())
#define  getDS()        ((*getDS_func) ())
#define  getES()        ((*getES_func) ())
#define  getSS()        ((*getSS_func) ())
#define  getMSW()       ((*getMSW_func) ())
#define  getDF()        ((*getDF_func) ())
#define  getIF()        ((*getIF_func) ())
#define  getTF()        ((*getTF_func) ())
#define  getPF()        ((*getPF_func) ())
#define  getAF()        ((*getAF_func) ())
#define  getSF()        ((*getSF_func) ())
#define  getZF()        ((*getZF_func) ())
#define  getOF()        ((*getOF_func) ())
#define  getCF()        ((*getCF_func) ())

#ifdef CCPU
/*  CCPU-specific READ functions */
#define getCPL()                ((*getCPL_func) ())
#define getGDTR_base()          ((*getGDTR_base_func) ())
#define getGDTR_limit()         ((*getGDTR_limit_func) ())
#define getIDTR_base()          ((*getIDTR_base_func) ())
#define getIDTR_limit()         ((*getIDTR_limit_func) ())
#define getLDTR()               ((*getLDTR_func) ())
#define getTR()                 ((*getTR_func) ())
#define getMSW_reserved()       ((*getMSW_reserved_func) ())
#define getTS()         ((*getTS_func) ())
#define getEM()         ((*getEM_func) ())
#define getMP()         ((*getMP_func) ())
#define getPE()         ((*getPE_func) ())
#define getNT()         ((*getNT_func) ())
#define getIOPL()       ((*getIOPL_func) ())
#define  getSTATUS()    ((*getSTATUS_func) ())
#endif CCPU

#ifdef A2CPU
/*  Assembler CPU specific READ functions */
#define getOPA()                ((*getOPA_func) ())
#define getOPB()                ((*getOPB_func) ())
#define getOPR()                ((*getOPR_func) ())
#define getSSD()                ((*getSSD_func) ())
#define getDSD()                ((*getDSD_func) ())
#endif A2CPU

/*  common WRITE functions  */
#define  setAX(val)     ((*setAX_func) (val))
#define  setAH(val)     ((*setAH_func) (val))
#define  setAL(val)     ((*setAL_func) (val))
#define  setBX(val)     ((*setBX_func) (val))
#define  setBH(val)     ((*setBH_func) (val))
#define  setBL(val)     ((*setBL_func) (val))
#define  setCX(val)     ((*setCX_func) (val))
#define  setCH(val)     ((*setCH_func) (val))
#define  setCL(val)     ((*setCL_func) (val))
#define  setDX(val)     ((*setDX_func) (val))
#define  setDH(val)     ((*setDH_func) (val))
#define  setDL(val)     ((*setDL_func) (val))
#define  setSP(val)     ((*setSP_func) (val))
#define  setBP(val)     ((*setBP_func) (val))
#define  setSI(val)     ((*setSI_func) (val))
#define  setDI(val)     ((*setDI_func) (val))
#define  setIP(val)     ((*setIP_func) (val))
#define  setCS(val)     ((*setCS_func) (val))
#define  setDS(val)     ((*setDS_func) (val))
#define  setES(val)     ((*setES_func) (val))
#define  setSS(val)     ((*setSS_func) (val))
#define  setMSW(val)    ((*setMSW_func) (val))
#define  setDF(val)     ((*setDF_func) (val))
#define  setIF(val)     ((*setIF_func) (val))
#define  setTF(val)     ((*setTF_func) (val))
#define  setPF(val)     ((*setPF_func) (val))
#define  setAF(val)     ((*setAF_func) (val))
#define  setSF(val)     ((*setSF_func) (val))
#define  setZF(val)     ((*setZF_func) (val))
#define  setOF(val)     ((*setOF_func) (val))
#define  setCF(val)     ((*setCF_func) (val))

#ifdef CCPU
/*  CCPU-specific WRITE functions */
#define setCPL(val)             ((*setCPL_func) (val))
#define setGDTR_base(val)       ((*setGDTR_base_func) (val))
#define setGDTR_limit(val)      ((*setGDTR_limit_func) (val))
#define setIDTR_base(val)       ((*setIDTR_base_func) (val))
#define setIDTR_limit(val)      ((*setIDTR_limit_func) (val))
#define setLDTR(val)            ((*setLDTR_func) (val))
#define setTR(val)              ((*setTR_func) (val))
#define setMSW_reserved(val)    ((*setMSW_reserved_func) (val))
#define setTS(val)              ((*setTS_func) (val))
#define setEM(val)              ((*setEM_func) (val))
#define setMP(val)              ((*setMP_func) (val))
#define setPE(val)              ((*setPE_func) (val))
#define setNT(val)              ((*setNT_func) (val))
#define setIOPL(val)    ((*setIOPL_func) (val))
#endif CCPU

#ifdef A2CPU
/*  Assembler CPU specific WRITE functions */
#define setOPLEN                ((*setOPLEN_func) (val))
#define setOPA()                ((*setOPA_func) (val))
#define setOPB()                ((*setOPB_func) (val))
#define setOPR()                ((*setOPR_func) (val))
#endif A2CPU
#endif EGATEST



/*  HOST_SIMULATE function  */
#define  host_simulate()        ((*host_simulate_func) ())

/*  common access functions. Load at boot and cpu switch times. */
/*  common READ functions  */
extern word             (*getAX_func) ();
extern half_word        (*getAH_func) ();
extern half_word        (*getAL_func) ();
extern word             (*getBX_func) ();
extern half_word        (*getBH_func) ();
extern half_word        (*getBL_func) ();
extern word             (*getCX_func) ();
extern half_word        (*getCH_func) ();
extern half_word        (*getCL_func) ();
extern word             (*getDX_func) ();
extern half_word        (*getDH_func) ();
extern half_word        (*getDL_func) ();
extern word             (*getSP_func) ();
extern word             (*getBP_func) ();
extern word             (*getSI_func) ();
extern word             (*getDI_func) ();
extern word             (*getIP_func) ();
extern word             (*getCS_func) ();
extern word             (*getDS_func) ();
extern word             (*getES_func) ();
extern word             (*getSS_func) ();
extern word             (*getMSW_func) ();
extern word             (*getDF_func) ();
extern word             (*getIF_func) ();
extern word             (*getTF_func) ();
extern word             (*getPF_func) ();
extern word             (*getAF_func) ();
extern word             (*getSF_func) ();
extern word             (*getZF_func) ();
extern word             (*getOF_func) ();
extern word             (*getCF_func) ();
extern word             (*getSTATUS_func) ();

#ifdef CCPU
/* CCPU-specific READ functions */
extern int              (*getCPL_func) ();
extern sys_addr (*getGDTR_base_func) ();
extern word             (*getGDTR_limit_func) ();
extern sys_addr (*getIDTR_base_func) ();
extern word             (*getIDTR_limit_func) ();
extern word             (*getLDTR_func) ();
extern word             (*getTR_func) ();
extern word             (*getMSW_reserved_func) ();
extern word             (*getTS_func) ();
extern word             (*getEM_func) ();
extern word             (*getMP_func) ();
extern word             (*getPE_func) ();
extern word             (*getNT_func) ();
extern word             (*getIOPL_func) ();
#endif CCPU

#ifdef A2CPU
/*  Assembler CPU specific READ functions */
extern double_word      (*getOPA_func) ();
extern double_word      (*getOPB_func) ();
extern double_word      (*getOPR_func) ();
extern sys_addr (*getSSD_func) ();
extern sys_addr (*getDSD_func) ();
#endif A2CPU



/*  common WRITE functions  */
extern void             (*setAX_func) ();
extern void             (*setAH_func) ();
extern void             (*setAL_func) ();
extern void             (*setBX_func) ();
extern void             (*setBH_func) ();
extern void             (*setBL_func) ();
extern void             (*setCX_func) ();
extern void             (*setCH_func) ();
extern void             (*setCL_func) ();
extern void             (*setDX_func) ();
extern void             (*setDH_func) ();
extern void             (*setDL_func) ();
extern void             (*setSP_func) ();
extern void             (*setBP_func) ();
extern void             (*setSI_func) ();
extern void             (*setDI_func) ();
extern void             (*setIP_func) ();
extern void             (*setCS_func) ();
extern void             (*setDS_func) ();
extern void             (*setES_func) ();
extern void             (*setSS_func) ();
extern void             (*setMSW_func) ();
extern void             (*setDF_func) ();
extern void             (*setIF_func) ();
extern void             (*setTF_func) ();
extern void             (*setPF_func) ();
extern void             (*setAF_func) ();
extern void             (*setSF_func) ();
extern void             (*setZF_func) ();
extern void             (*setOF_func) ();
extern void             (*setCF_func) ();

#ifdef CCPU
/* CCPU-specific WRITE functions */
extern void             (*setCPL_func) ();
extern void             (*setGDTR_base_func) ();
extern void             (*setGDTR_limit_func) ();
extern void             (*setIDTR_base_func) ();
extern void             (*setIDTR_limit_func) ();
extern void             (*setLDTR_func) ();
extern void             (*setTR_func) ();
extern void             (*setMSW_reserved_func) ();
extern void             (*setTS_func) ();
extern void             (*setEM_func) ();
extern void             (*setMP_func) ();
extern void             (*setPE_func) ();
extern void             (*setNT_func) ();
extern void             (*setIOPL_func) ();
#endif CCPU

#ifdef A2CPU
/*  Assembler CPU specific WRITE functions */
extern void             (*setOPLEN_func) ();
extern void             (*setOPA_func) ();
extern void             (*setOPB_func) ();
extern void             (*setOPR_func) ();
#endif A2CPU


/*  HOST_SIMULATE function  */
extern void             (*host_simulate_func) ();

/*
 *
 *******************************************************************
 * The Second Assembler cpu register access functions.             *
 *******************************************************************
 *
 */
#ifdef A2CPU
extern sreg INTEL_STATUS;
extern void     (*R_ROUTE)();
extern int      R_INTR;
extern reg R_AX;                /* Accumulator          */
extern reg R_BX;                /* Base                 */
extern reg R_CX;                /* Count                */
extern reg R_DX;                /* Data                 */
extern reg R_SP;                /* Stack Pointer        */
extern reg R_BP;                /* Base pointer         */
extern reg R_SI;                /* Source Index         */
extern reg R_DI;                /* Destination Index    */

extern double_word R_OPA;
extern double_word R_OPB;
extern double_word R_OPR;
extern int      R_MISC_FLAGS;

extern sys_addr R_IP;           /* Instruction Pointer  */

extern sys_addr R_ACT_CS;               /* Code Segment */
extern sys_addr R_ACT_DS;               /* Data Segment */
extern sys_addr R_ACT_SS;               /* Stack Segment */
extern sys_addr R_ACT_ES;               /* Extra Segment */

extern sys_addr R_DEF_SS;               /* Default SS register  */
extern sys_addr R_DEF_DS;               /* Default DS register  */

extern void do_setSF();
extern void do_setOF();
extern void do_setPF();
extern void do_setZF();
extern void do_setCF();

#define BYTE_OPERATION  0x80000000
#define WORD_OPERATION  0
#define IS_BYTE_OP      (R_MISC_FLAGS < 0)
#define REALLY_ZERO     (R_MISC_FLAGS & 1)

/*
        NB. retl does jmp %o7+8
*/
#define setROUTE(val)   R_ROUTE = (void *)((int)(val) - 8)
#define setINTR(val)    R_INTR = ( val )
#define setbitINTR(val) R_INTR |= ( val )
#define clrbitINTR(val) R_INTR &= ~( val )
#define getROUTE()      (R_ROUTE)
#define getINTR()       (R_INTR)
#endif A2CPU

#endif /* CPU_30_STYLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\hosttyps.h ===
/* SccsID = @(#)host_types.h	1.1 11/17/89 Copyright Insignia Solutions Ltd */
/*
 * This file shouldn't really be needed as host_defs.h now suipplies
 * the host dependant include file information. But there are currently
 * too many files using this to make it easy to change over
 */
#include <sys/types.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_gfx.h ===
extern int terminal_type;

/* values for terminal type */
#define TERMINAL_TYPE_DUMB	0
#define TERMINAL_TYPE_SUN	1
#define TERMINAL_TYPE_X11	2
#define TERMINAL_TYPE_DEFAULT	TERMINAL_TYPE_SUN

/*
 * Bit masks for attribute bytes
 */

#define BLINK 		0x80	/* Blink bit		*/
#define BOLD		0x08	/* Bold bit		*/
#define BACKGROUND	0x70    /* Background bits	*/
#define FOREGROUND	0x07    /* Foreground bits	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_emm.h ===
/* SccsID = @(#)host_emm.h	1.1 11/17/89 Copyright Insignia Solutions Ltd.
	
FILE NAME	: host_emm.h

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: July '88


=========================================================================

AMMENDMENTS	:

=========================================================================
/*
 * The following two defines are used to convert the storage identifier
 * (storage_ID) into a byte pointer. This enables the host to use 
 * whatever means it likes for storing this data. The Expanded Memory
 * Manager code always uses USEBLOCK to access the pointer to the 
 * data storage area and always uses FORGETBLOCK when it is finished.
 * FORGETBLOCK is provided for systems like the MAC II that may wish to
 * allocate a block, lock it before use and unlock it when finished.
 */
 
#define	USEBLOCK(x)	(unsigned char *)x
#define FORGETBLOCK(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_gen.h ===
/*
 * VPC-XT Revision 2.0
 *
 * Title	: Host Dependent General Include File (Tk43 Version)
 *
 * Description	: Any defines etc that may change between hosts are
 *		  placed in this file.
 *
 * Author	: Henry Nash
 *
 * Notes	: This file is included by xt.h and should NOT be
 *		  included directly by any other file.
 */

/* static char SccsID[]="@(#)host_gen.h	1.11 4/9/91 Copyright Insignia Solutions Ltd." */

/*
 * Definition of signed 8 bit arithmetic unit of storage
 */

typedef char signed_char;

/*
 * Root directory - this is where fonts are found, and the default
 * place for the data directory.
 */

#define ROOT host_get_spc_home()

extern char *host_get_spc_home();

/*
 * Host-specific defaults.
 */

#define  DEFLT_HDISK_SIZE  10
#define  DEFLT_FSA_NAME    "fsa_dir"

/*
 * The rate at which timer signals/events are generated for softPC.
 * This is defined as the number of microseconds between each tick.
 * On the Sun3 these are the same rate as expected by the PC.
 */

#define SYSTEM_TICK_INTV        54925


/*
 * The amount of memory allowed for the fact that we do not wrap
 * all string instructions as we should. Stuck at end of Intel Memory.
 */
#define NOWRAP_PROTECTION	0x10020

/*
 *	The following macros are used to access Intel address space
 *
 * 	NOTE: 	A write check for Delta needs to be added
 */

#define write_intel_word(s, o, v)	sas_storew(effective_addr(s,o),v)

#define write_intel_byte(s, o, v)	sas_store(effective_addr(s,o),v)

#define write_intel_byte_string(s, o, v, l)  sas_stores(effective_addr(s,o),v,l)

#define read_intel_word(s, o, v)	sas_loadw(effective_addr(s,o),v)

#define read_intel_byte(s, o, v)	sas_load(effective_addr(s,o),v)

#define read_intel_byte_string(s, o, v, l)  sas_loads(effective_addr(s,o),v,l)

#define push_word(w)			setSP((IU16)(getSP()-2 & 0xffff));\
					write_intel_word(getSS(), getSP(), w)

#define push_byte(b)			setSP((getSP()-1) & 0xffff);\
					write_intel_byte(getSS(), getSP(), b)

#define pop_word(w)			read_intel_word(getSS(), getSP(), w);\
					setSP((getSP()+2) & 0xffff)

#define pop_byte(b)			read_intel_byte(getSS(), getSP(), b);\
					setSP((getSP()+1) & 0xffff)

/*
 * Memory size used by reset.c to initialise the appropriate BIOS variable.
 */

#define host_get_memory_size()          640

typedef	half_word	HALF_WORD_BIT_FIELD;
typedef	word	 	WORD_BIT_FIELD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_hfx.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: host_hfx.h 
 *
 * Description	: Host dependent definitions for HFX.
 *
 * Author	: J. Koprowski + L. Dworkin
 *
 * Notes	:
 *
 * Mods		:
 */

#ifdef SCCSID
/* static char SccsID[]="@(#)host_hfx.h	1.7 2/13/91 Copyright Insignia Solutions Ltd."; */
#endif

#ifdef HFX
#ifndef PROD
/*
 * Unix error codes used for debugging purposes.
 */
static char *ecode[]={
"EOK",		/* 0	/* Not an error				*/
"EPERM",	/* 1	/* Not super-user			*/
"ENOENT",	/* 2	/* No such file or directory		*/
"ESRCH",	/* 3	/* No such process			*/
"EINTR",	/* 4	/* interrupted system call		*/
"EIO",		/* 5	/* I/O error				*/
"ENXIO",	/* 6	/* No such device or address		*/
"E2BIG",	/* 7	/* Arg list too long			*/
"ENOEXEC",	/* 8	/* Exec format error			*/
"EBADF",	/* 9	/* Bad file number			*/
"ECHILD",	/* 10	/* No children				*/
"EAGAIN",	/* 11	/* No more processes			*/
"ENOMEM",	/* 12	/* Not enough core			*/
"EACCES",	/* 13	/* Permission denied			*/
"EFAULT",	/* 14	/* Bad address				*/
"ENOTBLK",	/* 15	/* Block device required		*/
"EBUSY",	/* 16	/* Mount device busy			*/
"EEXIST",	/* 17	/* File exists				*/
"EXDEV",	/* 18	/* Cross-device link			*/
"ENODEV",	/* 19	/* No such device			*/
"ENOTDIR",	/* 20	/* Not a directory			*/
"EISDIR",	/* 21	/* Is a directory			*/
"EINVAL",	/* 22	/* Invalid argument			*/
"ENFILE",	/* 23	/* File table overflow			*/
"EMFILE",	/* 24	/* Too many open files			*/
"ENOTTY",	/* 25	/* Not a typewriter			*/
"ETXTBSY",	/* 26	/* Text file busy			*/
"EFBIG",	/* 27	/* File too large			*/
"ENOSPC",	/* 28	/* No space left on device		*/
"ESPIPE",	/* 29	/* Illegal seek				*/
"EROFS",	/* 30	/* Read only file system		*/
"EMLINK",	/* 31	/* Too many links			*/
"EPIPE",	/* 32	/* Broken pipe				*/
"EDOM",		/* 33	/* Math arg out of domain of func	*/
"ERANGE",	/* 34	/* Math result not representable	*/
"ENOMSG",	/* 35	/* No message of desired type		*/
"EIDRM",	/* 36	/* Identifier removed			*/
"ECHRNG",	/* 37	/* Channel number out of range		*/
"EL2NSYNC", 	/* 38	/* Level 2 not synchronized		*/
"EL3HLT",	/* 39	/* Level 3 halted			*/
"EL3RST",	/* 40	/* Level 3 reset			*/
"ELNRNG",	/* 41	/* Link number out of range		*/
"EUNATCH",	/* 42	/* Protocol driver not attached		*/
"ENOCSI",	/* 43	/* No CSI structure available		*/
"EL2HLT",	/* 44	/* Level 2 halted			*/
"EDEADLK",	/* 45	/* Deadlock condition.			*/
"ENOLCK",	/* 46	/* No record locks available.		*/

"EOK",		/* 47	/* Not an error				*/
"EOK",		/* 48	/* Not an error				*/
"EOK",		/* 49	/* Not an error				*/

"EBADE",	/* 50	/* invalid exchange			*/
"EBADR",	/* 51	/* invalid request descriptor		*/
"EXFULL",	/* 52	/* exchange full			*/
"ENOANO",	/* 53	/* no anode				*/
"EBADRQC",	/* 54	/* invalid request code			*/
"EBADSLT",	/* 55	/* invalid slot				*/
"EDEADLOCK", 	/* 56	/* file locking deadlock error		*/
"EBFONT",	/* 57	/* bad font file fmt			*/

"EOK",		/* 58	/* Not an error				*/
"EOK",		/* 59	/* Not an error				*/

"ENOSTR",	/* 60	/* Device not a stream			*/
"ENODATA",	/* 61	/* no data (for no delay io)		*/
"ETIME",	/* 62	/* timer expired			*/
"ENOSR",	/* 63	/* out of streams resources		*/
"ENONET",	/* 64	/* Machine is not on the network	*/
"ENOPKG",	/* 65	/* Package not installed                */
"EREMOTE",	/* 66	/* The object is remote			*/
"ENOLINK",	/* 67	/* the link has been severed */
"EADV",		/* 68	/* advertise error */
"ESRMNT",	/* 69	/* srmount error */
"ECOMM",	/* 70	/* Communication error on send		*/
"EPROTO",	/* 71	/* Protocol error			*/
"EOK",		/* 72	/* Not an error				*/
"EOK",		/* 73	/* Not an error				*/
"EMULTIHOP", 	/* 74	/* multihop attempted */
"EOK",		/* 75	/* Not an error				*/
"EDOTDOT", 	/* 76	/* Cross mount point (not really error)*/
"EBADMSG", 	/* 77	/* trying to read unreadable message	*/
"EOK",		/* 78	/* Not an error				*/
"EOK",		/* 79	/* Not an error				*/
"ENOTUNIQ", 	/* 80	/* given log. name not unique */
"EBADFD",	/* 81	/* f.d. invalid for this operation */
"EREMCHG",	/* 82	/* Remote address changed */
"ELIBACC",	/* 83	/* Can't access a needed shared lib.	*/
"ELIBBAD",	/* 84	/* Accessing a corrupted shared lib.	*/
"ELIBSCN",	/* 85	/* .lib section in a.out corrupted.	*/
"ELIBMAX",	/* 86	/* Attempting to link in too many libs.	*/
"ELIBEXEC",	/* 87	/* Attempting to exec a shared library.	*/
};
#endif

/*
 * Return values from host_map_file function.
 */

/*
 * Returned if a match was required and was successful.
 */
#define FILE_MATCH 0
/*
 * Returned if a match was required and failed.
 */
#define MATCH_FAIL 1
/*
 * Returned if no match was required and no mapping took place.
 */
#define NAME_LEGAL 2
/*
 * Returned if no match was required and mapping took place.
 */
#define NAME_MAPPED 3

/*
 * Tables for conversion from base forty one to legal DOS characters.
 */
#define HOST_CHAR_TABLE1 "!#$%&@^_~0123456789XYZADFGHIJKLMNOPQRSUVW"
#define HOST_CHAR_TABLE2 "!#$%&@^_~0123456789ABCDFGHJKLMNPQRTUVWXYZ"
#define HOST_CHAR_TABLE3 "!#$%&@^_~0123456789ADFGHIJKLMNOPQRSUVWXYZ"

/*
 * Illegal file name specification.  This is the name
 * used when a host filename is completely illegal under
 * DOS.
 */
#define ILLEGAL_NAME "ILLEGAL"
#define ILLEGAL_NAME_LENGTH 7
/*
 * Codes passed to host_validate_path function.
 */
/*
 * HFX_NEW_FILE indicates that the path may be mapped, but not the filename
 * itself.  In this case the last field is not validated, but is simply
 * concatenated to the host name generated.
 */
#define HFX_NEW_FILE 0
/*
 * HFX_OLD_FILE indicates that the file concerned may already exist
 * and require mapping.  Thus, checks are made to see if the last field
 * exists, doing a directory search for mapped names if necessary.
 */
#define HFX_OLD_FILE 1
/*
 * HFX_PATH_ONLY acts in the same way as HFX_NEW_FILE except that the
 * final name field is not concatenated to the host name output.
 * In the current version the path will be output with a slash as the final
 * character.
 */
#define HFX_PATH_ONLY 2
/*
 * External function declarations.
 */
extern boolean host_file_search();
extern word host_gen_err();

#ifndef access
#include <io.h>     /* IO.H contains define of access to _acccess */
#endif

#define host_access access

#define host_opendir opendir
#define host_readdir readdir
#define host_closedir closedir
#define host_malloc malloc
#define host_free free
#define host_getpid getpid

/*
 * Global variable external references.
 */
/* extern char *hfx_root[]; */
extern char *get_hfx_root  IPT1(half_word, hfx_entry);

/*
 * Directory type definitions.
 */
 #define HOST_DIR int           /*ADE*/
 typedef struct hfx_found_dir_entry
 {
       half_word                       attr;
       char                            *host_name;
       char                            *dos_name;
       int                             direntry;
       struct hfx_found_dir_entry      *next;
 } HFX_FOUND_DIR_ENT;

/* This is a base structure defined in the host
 * include file due to the dependence on the host
 * specific HOST_DIR type
 */
typedef struct hfx_direntry
{
	HOST_DIR			*dir;
	char				*name;
        char                            *template;
	int				direntry;
        HFX_FOUND_DIR_ENT               *found_list_head;
        boolean                         first_find;
	struct hfx_direntry		*next;
	struct hfx_direntry		*last;
} HFX_DIR;


/*
 * Host maximum file name length including path.  N.B. This may
 * need increasing.
 */
#define MAX_PATHLEN 256

#endif /* HFX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_qev.h ===
typedef LONGLONG q_ev_handle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_def.h ===
/***************************************************************\
* This file is a prototype for a host include file.		*
* Take this file & modify it to suit your environment.		*
*								*
* It should be included in ALL source files, before anything	*
* else. Its purpose is to #define the names of system include	*
* files (like sys/types.h) which vary from host to host, & to	*
* define those #defines which are always required for a given	*
* port (BIT_ORDER1, for instance). This hopefully will simplify	*
* various base bits, & the `m' script.				*
*								*
* Bod. 11th May, 1988						*
\***************************************************************/

#include "ctype.h"

/* put the invariant #defines for your host here, eg:*/

#define BIT_ORDER2
#define LITTLEND

#define TWO_HARD_DISKS

#define RDCHK
#define EGG
#define VGG
#define M_IS_POINTER
#ifndef MONITOR
#define BIGWIN
#endif
#define HOST_OPEN(a,b,c)    open(a,b,c)
#define PROF_REZ_ID	0
#define ROMS_REZ_ID	1
#define HOST_IDEAL_ALARM			SYSTEM_TICK_INTV
#define YYLENG_ADJUST 0

#ifdef MONITOR
#define CpuH "cpu.h"
#else
#define CpuH "cpu4.h"
#endif

// reduce unused param warnings.
#define UNREFERENCED_FORMAL_PARAMETER(x)   (x)
//#define UNUSED(x)	UNREFERENCED_FORMAL_PARAMETER(x)

/*
	Define delays for quick event manager
*/
typedef struct 
{
	int	com_delay;
	int	keyba_delay;
	int	timer_delay;
	int	fdisk_delay_1;
	int	fdisk_delay_2;
	int	fla_delay;
        int     timer_delay_size;
} quick_event_delays;

extern	quick_event_delays	host_delays;

#define HOST_COM_INT_DELAY 		host_delays.com_delay
#define HOST_KEYBA_INST_DELAY 		host_delays.keyba_delay
#define HOST_TIMER_INT_DELAY 		host_delays.timer_delay
#define HOST_FDISK_DELAY_1		host_delays.fdisk_delay_1
#define HOST_FDISK_DELAY_2		host_delays.fdisk_delay_2
#define HOST_FLA_DELAY			host_delays.fla_delay
#define HOST_TIMER_DELAY_SIZE           host_delays.timer_delay_size

#define host_malloc		malloc
#define host_calloc		calloc
#define host_free               free
#define host_getenv             getenv

#ifndef CCPU
#ifndef WINWORLD
#define NPX
#endif
#endif

#define host_flush_cache_host_read(addr, size)
#define host_flush_cache_host_write(addr, size)
#define host_flush_global_mem_cache()
#define host_process_sigio()
#define host_rom_init()
#define HOST_BOP_IP_FUDGE     -2

#ifndef EGATEST
#ifndef MONITOR
#define BIGWIN
#endif
#endif /* EGATEST */

/***************************************************************\
*	system parameter defines				*
\***************************************************************/
#ifndef NUM_PARALLEL_PORTS
#if defined(NEC_98)
#define NUM_PARALLEL_PORTS      1
#else  // !NEC_98
#define NUM_PARALLEL_PORTS	3
#endif // !NEC_98
#endif /* NUM_PARALLEL_PORTS */

#ifndef NUM_SERIAL_PORTS
#if defined(NEC_98)
#define NUM_SERIAL_PORTS        1
#else  // !NEC_98
#define NUM_SERIAL_PORTS	4
#endif // !NEC_98
#endif /* NUM_SERIAL_PORTS */

/***************************************************************\
*	generic defines for those wandering files		*
\***************************************************************/

#define	FCntlH	<fcntl.h>
#define	StringH <string.h>
#define TimeH	<time.h>
#define	TypesH	<sys/types.h>
#define VTimeH	<time.h>
#define UTimeH	<unistd.h>
#define StatH	<sys/stat.h>
#define IoH	<io.h>
#define MemoryH	<memory.h>
#define MallocH	<malloc.h>
#define TermioH "TERMIO - THIS IS WRONG"
#define CursesH "CURSES - THIS IS WRONG"


#define strcasecmp _stricmp
#define host_pclose pclose
#define host_popen  popen
#define host_pipe_init()

#ifdef HUNTER
#define RB_MODE "r"
#endif /* HUNTER */

#define HOST_TIMER_TOOLONG_DELAY        15000   //BCN 1781

#define LIM

#define NTVDM	// To enable NT specific base code.

#define CPU_30_STYLE
#define PM

#if !defined(MONITOR) && !defined(PROD)
#define YODA                           //ie YODA in non x86 checked only
#endif


#define DELTA
#define HOST_MOUSE_INSTALLED
#define PRINTER


/*
 *  Miscellaneous function prototypes which don't have anywhere to go
 */

//  from copy_fnc.c
void
bwdcopy(
    char *src,
    char *dest,
    int len
    );

void
bwd_dest_copy(
    char *src,
    char *dest,
    int len
    );

void memfill(
    unsigned char data,
    unsigned char *l_addr_in,
    unsigned char *h_addr_in
    );

void
fwd_word_fill(
   unsigned short data,
   unsigned char *l_addr_in,
   int len
   );

void
memset4(
    unsigned int data,
    unsigned int *laddr,
    unsigned int count
    );


// from nt_lpt.c
void host_lpt_close_all(void);
void host_lpt_heart_beat(void);

// from nt_reset.c
PCHAR pszSystem32Path;
ULONG ulSystem32PathLen; // Does not include '\0'.
HANDLE LoadSystem32Library(PCWSTR pcwsShortNameW); // WARNING: don't forget the L
#define UnloadSystem32Library(handle) LdrUnloadDll((PVOID)handle)

// from nt_rflop.c
void host_flpy_heart_beat(void);

// from nt_sound.c
VOID LazyBeep(ULONG Freq, ULONG Duration);
void PlayContinuousTone(void);
void InitSound(BOOL);

// from config.c
extern unsigned char PifFgPriPercent;
#ifdef ARCX86
extern BOOL UseEmulationROM;
#endif

// fomr unix.c
void WakeUpNow(void);
void host_idle_init(void);
void WaitIfIdle(void);
void PrioWaitIfIdle(unsigned char);

// from nt_pif.c
void *ch_malloc(unsigned int NumBytes);

// from nt_bop.c
#ifdef i386
HINSTANCE SafeLoadLibrary(char *name);
#else
#define SafeLoadLibrary(name) LoadLibrary(name)
#endif

#define HOST_PRINTER_DELAY 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_rrr.h ===
#ifndef _HOST_ERROR_H
#define _HOST_ERROR_H
/*
 * VPC-XT Revision 2.0
 *
 * Title	: Host specific error defines for the NT
 *
 * Description	: Contains defines for the possible host errors
 *
 * Author(s)	: John Shanly
 *
 * Notes	:
 */ 

/* static char SccsID[]="@(#)host_error.h	1.2 6/30/91 Copyright Insignia Solutions Ltd."; */


/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */



#define EHS_FUNC_FAILED		 1001
#define EHS_SYSTEM_ERROR	 1002
#define EHS_UNSUPPORTED_BAUD	 1003
#define EHS_ERR_OPENING_COM_PORT 1004

#define EHS_MSG_LEN		 1024	    /* Max size of error message */
#define NUM_HOST_ERRORS          1          /* Number of host errors */



void nls_init(void);

extern char szDoomMsg[];
extern char szSysErrMsg[];
#ifdef X86GFX
extern wchar_t wszFrozenString[];
#endif
extern wchar_t wszHideMouseMenuStr[];
extern wchar_t wszDisplayMouseMenuStr[];



#endif /* !_HOST_ERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_inc.h ===
/*[
*************************************************************************

	Name:		host_inc.c
	Author:		James Bowman
	Created:	Novemeber 1993
	Derived from:	Original
	Sccs ID:	@(#)host_inc.h	1.6 07/21/94
	Purpose:	Wrapper for all host include files

	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.

*************************************************************************
]*/

#ifndef _HOST_INC_H
#define _HOST_INC_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <suplib.h>
#include <malloc.h>
#include <stdarg.h>
#include <assert.h>

#ifdef NTVDM

/*
 * Include support for windows system calls; unfortunataly this defines
 * lots of stuff that conflicts with base_def.h, so redefine the offending
 * names, and delete them afterwards. This won't work well if a future port
 * defines these as #defines rather than typedefs, but thats their problem
 * not mine ....
 */
#ifdef ULONG
#undef ULONG
#endif
#ifdef USHORT
#undef USHORT
#endif
//#ifdef DOUBLE
//#undef DOUBLE
//#endif
#define USHORT	NT_USHORT
#define ULONG	NT_ULONG
#define UINT	NT_UINT
#undef INT
#define INT 	NT_INT
#undef BOOL
#define BOOL	NT_BOOL
#define FLOAT	NT_FLOAT
//#define DOUBLE	NT_DOUBLE

#include <windows.h>
#include <io.h>
#include <process.h>
#include <direct.h>
#include <sys/stat.h>

#undef USHORT
#undef ULONG
#undef UINT
#undef INT
#undef BOOL
#undef FLOAT
//#undef DOUBLE

#include <nt_extra.h>

#else   /* !NTVDM */

#include <sys/param.h>
#endif   /* !NTVDM */

#endif  /* _HOST_INC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\hstsystm.h ===
/*	Required for herc.c	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\monsim32.h ===
// no action is required for this macro.
#define Sim32FlushVDMPointer( address, size, buffer, mode ) TRUE

// no action is required for this macro.
#define Sim32FreeVDMPointer( address, size, buffer, mode) TRUE

#define Sim32GetVDMMemory( address, size, buffer, mode) (memcpy(  \
    buffer, Sim32GetVDMPointer(address, size, mode), size), TRUE)

#define Sim32SetVDMMemory( address, size, buffer, mode) (memcpy( \
    Sim32GetVDMPointer(address, size, mode), buffer, size), TRUE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\host_trc.h ===
/*
 * VPC-XT Revision 2.0
 *
 * Title	: Host Trace module definitions
 *
 * Description	: Definitions for users of the trace module
 *
 * Author	: WTG Charnell
 *
 * Notes	: None
 */

/* SccsID[]="@(#)host_trace.h	1.5 8/2/90 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Verbose bit masks - set the following bits in the io_verbose
 * variable to produce the following trace outputs:
 */


/* sub message types */

#define ASYNC_VERBOSE		0x1000		 /* async event manager verbose */
#define PACEMAKER_VERBOSE	0x2000		 /* pacemaker verbose */
#define HOST_PIPE_VERBOSE	0x10000
#define HOST_COM_VERBOSE	0x40000
#define HOST_COM_EXTRA	0x80000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\insignia.h ===
#ifndef _INSIGNIA_H
#define _INSIGNIA_H
/*
 *      Name:           insignia.h
 *      Derived from:   HP 2.0 insignia.h
 *      Author:         Philippa Watson (amended Dave Bartlett)
 *      Created on:     23 January 1991
 *      SccsID:         @(#)insignia.h  1.2 03/11/91
 *      Purpose:        This file contains the definition of the Insignia
 *                      standard types and constants for the NT/WIN32
 *                      SoftPC.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 */

/*
 * Insignia Standard Types
 *
 * Note that the EXTENDED type is the same as the DOUBLE type for the
 * HP because there is no difference between the double and long double
 * fundamental types, it's an ANSI compiler feature.
 */


#ifndef NT_INCLUDED
#include <windows.h>
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#endif

#include <base_def.h>
#define VOID            void            /* Nothing */

#if !defined(_WINDOWS_) && !defined(NT_INCLUDED)    /* Types already defined by windows */
typedef char            CHAR;           /* Used as a text character */
#endif

typedef signed char     TINY;            /* 8-bit signed integer */

#if !defined(_WINDOWS_) && !defined(NT_INCLUDED)    /* Types already defined by windows */
typedef short           SHORT;          /* 16-bit signed integer */
//typedef long            LONG;           /* 32-bit signed integer */
#endif

typedef unsigned char   UTINY;          /* 8-bit unsigned integer */

#if !defined(_WINDOWS_) && !defined(NT_INCLUDED)    /* Types already defined by windows */
typedef unsigned char   UCHAR;          /*  8-bit unsigned integer */
typedef unsigned short  USHORT;         /* 16-bit unsigned integer */
//typedef unsigned long   ULONG;          /* 32-bit unsigned integer */
typedef unsigned short  WORD;           /* 16-bit unsigned integer */
typedef unsigned long   DWORD;          /* 32-bit unsigned integer */

typedef float           FLOAT;          /* 32-bit floating point */
//typedef double          DOUBLE;         /* 64-bit floating point */
#endif


typedef double          EXTENDED;       /* >64-bit floating point */

typedef int                  IBOOL;		/* True/False */
typedef signed char	         IS8;		/* 8 bit signed int */
typedef unsigned char        IU8;		/* 8 bit unsigned int */
typedef signed char          ISM8;		/* 8 bit signed int */
typedef unsigned char        IUM8;		/* 8 bit unsigned int */
typedef short                IS16;		/* 16 bit signed int */
typedef unsigned short       IU16;		/* 16 bit unsigned int */
typedef short                ISM16;		/* 16 bit signed int */
typedef unsigned short       IUM16;		/* 16 bit unsigned int */
typedef long                 IS32;		/* 32 bit signed int */
typedef unsigned long        IU32;		/* 32 bit unsigned int */
typedef long                 ISM32;		/* 32 bit signed int */
typedef unsigned long        IUM32;		/* 32 bit unsigned int */
typedef void *               IHP;		/* a generic pointer type */
typedef unsigned int         IHPE;	    /* an integer the same size as a IHP */
typedef int                  ISH;	    /* Host register sized signed quantity */
typedef unsigned int         IUH;	    /* Host register sized unsigned quantity */
#define LONG_SHIFT	2

/*
 * Insignia Standard Constants
 */

#ifndef FALSE
#define FALSE           ((BOOL) 0)      /* Boolean falsehood value */
#define TRUE            (!FALSE)        /* Boolean truth value */
#endif

#ifndef STRINGIFY
#define STRINGIFY(x)    #x
#endif

#if !defined(_WINDOWS_) && !defined(NT_INCLUDED)   /* Types already defined by windows */
//typedef int INT;
typedef unsigned int UINT;
#endif

#ifndef NULL
#define NULL            (0L)    /* Null pointer value */
#endif

#ifndef BOOL
#ifdef NT_INCLUDED
#if !defined(_WINDOWS_) 			  /* Types already defined by windows */
typedef int BOOL;	/* only defined in windows */
#endif
#else
#define BOOL UINT
#endif
#endif

/*
 * Insignia Standard Storage Classes
 */

#define GLOBAL                  /* Defined as nothing */
#define LOCAL   static          /* Local to the source file */
#define SAVED   static          /* For local static variables */
#define IMPORT  extern          /* To refer from another file */
#define FORWARD                 /* to refer from the same file */
#define FAST    register        /* High-speed Storage */

/*
** ANSI-independent function prototypes and definition macros.
**
** A function prototype looks like:
**
** IMPORT       USHORT  func    IPT2(UTINY, param0, CHAR *, param1);
**
** i.e. macro IPTn is used for a function with n parameters.
**
** The corresponding function definition looks like:
**
** GLOBAL       USHORT  funct   IFN2(UTINY, param0, CHAR *, param1)
** {
**      ... function body ...
** }
**
** Limitations: only parameters with declarations of the form "type name" can
** be handled. This rules out arrays (can use pointer syntax instead) and
** parameters which are pointers to functions or something similar. The previous** method of using ifdef ANSI must be used for these cases.
**
*/

#ifdef  ANSI

/* Function prototypes */

#define IPT0()                                  (void)
#define IPT1(t1, n1)                            (t1 n1)
#define IPT2(t1, n1, t2, n2)                    (t1 n1, t2 n2)
#define IPT3(t1, n1, t2, n2, t3, n3)            (t1 n1, t2 n2, t3 n3)
#define IPT4(t1, n1, t2, n2, t3, n3, t4, n4)    (t1 n1, t2 n2, t3 n3, t4 n4)
#define IPT5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5)
#define IPT6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6)
#define IPT7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7)
#define IPT8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8)

/* Function definitions */

#define IFN0()                                  (void)
#define IFN1(t1, n1)                            (t1 n1)
#define IFN2(t1, n1, t2, n2)                    (t1 n1, t2 n2)
#define IFN3(t1, n1, t2, n2, t3, n3)            (t1 n1, t2 n2, t3 n3)
#define IFN4(t1, n1, t2, n2, t3, n3, t4, n4)    (t1 n1, t2 n2, t3 n3, t4 n4)
#define IFN5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5)
#define IFN6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6)
#define IFN7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7)
#define IFN8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8)

#else   /* ANSI */

/* Function prototypes */

#define IPT0()                                                          ()
#define IPT1(t1, n1)                                                    ()
#define IPT2(t1, n1, t2, n2)                                            ()
#define IPT3(t1, n1, t2, n2, t3, n3)                                    ()
#define IPT4(t1, n1, t2, n2, t3, n3, t4, n4)                            ()
#define IPT5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5)                    ()
#define IPT6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6)            ()
#define IPT7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7)    ()
#define IPT8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        ()

/* Function definitions */

#define IFN0()                                  ()
#define IFN1(t1, n1)                            (n1) \
                                                t1 n1;
#define IFN2(t1, n1, t2, n2)                    (n1, n2) \
                                                t1 n1; t2 n2;
#define IFN3(t1, n1, t2, n2, t3, n3)            (n1, n2, n3) \
                                                t1 n1; t2 n2; t3 n3;
#define IFN4(t1, n1, t2, n2, t3, n3, t4, n4)    (n1, n2, n3, n4) \
                                                t1 n1; t2 n2; t3 n3; t4 n4;
#define IFN5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
                                                (n1, n2, n3, n4, n5) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5;
#define IFN6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
                                                (n1, n2, n3, n4, n5, n6) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6;
#define IFN7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
                                                (n1, n2, n3, n4, n5, n6, n7) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7;
#define IFN8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8;

#endif  /* ANSI */

#pragma warning (3:4013)

#endif /* _INSIGNIA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\ntcheese.h ===
#define IDM_POINTER  741
#define PERCENTILE   10L	/* Clip boundary as a percentage of client */
                                /* area boundary                           */

#define EFF5	116
#define EFF6	117
#define EFF7	118
#define EFF8	119

//
// Resource ID numbers for mouse options on the system menu.
//


extern BOOL AttachMouseMessage(void);
extern void MovePointerToWindowCentre(void);
extern void MouseAttachMenuItem(HANDLE);
extern void MouseDetachMenuItem(BOOL);
extern void MouseReattachMenuItem(HANDLE);

extern void MouseInFocus(void);
extern void MouseOutOfFocus(void);
extern void MouseSystemMenuON(void);
extern void MouseSystemMenuOFF(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_cga.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title	: Win32 CGA Graphics Includes
 *
 * Description	: 
 *
 *		This is the include file for the Win32 specific functions required
 *		to support the Hercules emulation.
 *
 * Author	: John Shanly
 *
 * Notes	:
 *
 */

/*:::::::::::::::::::::::::::::::::::: Character and screen sizes in pixels */

#define CGA_CHAR_WIDTH		8
#define CGA_CHAR_HEIGHT		16
#define CGA_WIN_WIDTH		(80 * CGA_CHAR_WIDTH)
#define CGA_WIN_HEIGHT		(25 * CGA_CHAR_HEIGHT)
#if defined(NEC_98)
#define NEC98_CHAR_WIDTH   (8)
#define NEC98_CHAR_HEIGHT  (16)
#define NEC98_WIN_WIDTH    (80 * NEC98_CHAR_WIDTH)
#define NEC98_WIN_HEIGHT   (25 * NEC98_CHAR_HEIGHT)
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\monregs.h ===
//extern CONTEXT IntelRegisters;
//extern ULONG IntelMSW;
// Flag Register constants

#define FLG_CARRY           0x00000001
#define FLG_CARRY_BIT       0x00000000
#define FLG_PARITY          0x00000004
#define FLG_PARITY_BIT      0x00000003
#define FLG_AUXILIARY       0x00000010
#define FLG_AUXILIARY_BIT   0x00000005
#define FLG_ZERO            0x00000040
#define FLG_ZERO_BIT        0x00000006
#define FLG_SIGN            0x00000080
#define FLG_SIGN_BIT        0x00000007
#define FLG_TRAP            0x00000100
#define FLG_INTERRUPT       0x00000200
#define FLG_INTERRUPT_BIT   0x00000009
#define FLG_DIRECTION       0x00000400
#define FLG_DIRECTION_BIT   0x0000000A
#define FLG_OVERFLOW        0x00000800
#define FLG_OVERFLOW_BIT    0x0000000B
extern ULONG  getEAX(VOID);
extern USHORT getAX(VOID);
extern UCHAR  getAL(VOID);
extern UCHAR  getAH(VOID);
extern ULONG  getEBX(VOID);
extern USHORT getBX(VOID);
extern UCHAR  getBL(VOID);
extern UCHAR  getBH(VOID);
extern ULONG  getECX(VOID);
extern USHORT getCX(VOID);
extern UCHAR  getCL(VOID);
extern UCHAR  getCH(VOID);
extern ULONG  getEDX(VOID);
extern USHORT getDX(VOID);
extern UCHAR  getDL(VOID);
extern UCHAR  getDH(VOID);
extern ULONG  getESP(VOID);
extern USHORT getSP(VOID);
extern ULONG  getEBP(VOID);
extern USHORT getBP(VOID);
extern ULONG  getESI(VOID);
extern USHORT getSI(VOID);
extern ULONG  getEDI(VOID);
extern USHORT getDI(VOID);
extern ULONG  getEIP(VOID);
extern USHORT getIP(VOID);
extern USHORT getCS(VOID);
extern USHORT getSS(VOID);
extern USHORT getDS(VOID);
extern USHORT getES(VOID);
extern USHORT getFS(VOID);
extern USHORT getGS(VOID);
extern ULONG  getCF(VOID);
extern ULONG  getPF(VOID);
extern ULONG  getAF(VOID);
extern ULONG  getZF(VOID);
extern ULONG  getSF(VOID);
extern ULONG  getTF(VOID);
extern ULONG  getIF(VOID);
extern ULONG  getDF(VOID);
extern ULONG  getOF(VOID);
extern USHORT getMSW(VOID);

extern VOID setEAX(ULONG);
extern VOID setAX(USHORT);
extern VOID setAH(UCHAR);
extern VOID setAL(UCHAR);
extern VOID setEBX(ULONG);
extern VOID setBX(USHORT);
extern VOID setBH(UCHAR);
extern VOID setBL(UCHAR);
extern VOID setECX(ULONG);
extern VOID setCX(USHORT);
extern VOID setCH(UCHAR);
extern VOID setCL(UCHAR);
extern VOID setEDX(ULONG);
extern VOID setDX(USHORT);
extern VOID setDH(UCHAR);
extern VOID setDL(UCHAR);
extern VOID setESP(ULONG);
extern VOID setSP(USHORT);
extern VOID setEBP(ULONG);
extern VOID setBP(USHORT);
extern VOID setESI(ULONG);
extern VOID setSI(USHORT);
extern VOID setEDI(ULONG);
extern VOID setDI(USHORT);
extern VOID setEIP(ULONG);
extern VOID setIP(USHORT);
extern VOID setCS(USHORT);
extern VOID setSS(USHORT);
extern VOID setDS(USHORT);
extern VOID setES(USHORT);
extern VOID setFS(USHORT);
extern VOID setGS(USHORT);
extern VOID setCF(ULONG);
extern VOID setPF(ULONG);
extern VOID setAF(ULONG);
extern VOID setZF(ULONG);
extern VOID setSF(ULONG);
extern VOID setIF(ULONG);
extern VOID setDF(ULONG);
extern VOID setOF(ULONG);
extern VOID setMSW(USHORT);

extern ULONG getPE(VOID);

// from v86\monitor\i386
VOID cpu_simulate(VOID);
VOID cpu_interrupt(int Type, int Number);
VOID cpu_init(VOID);
VOID cpu_terminate(VOID);
VOID host_unsimulate(VOID);
VOID host_simulate(VOID);
VOID cpu_exitthread(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_cgalt.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title		: Win32 CGA	look-up tables.
 *
 * Description	: 
 *
 * Author		: Dave Bartlett
 *
 * Notes		: This file should only be included by X_cga.c
 *
 */

/*:::::::::::::::::::::::: Lookup tables for CGA medium resolution graphics */

static half_word swap_pix1 [] = 
{
	0x00, 0xc0, 0x00, 0xc0, 0x30, 0xf0, 0x30, 0xf0,
	0x00, 0xc0, 0x00, 0xc0, 0x30, 0xf0, 0x30, 0xf0,
	0x0c, 0xcc, 0x0c, 0xcc, 0x3c, 0xfc, 0x3c, 0xfc,
	0x0c, 0xcc, 0x0c, 0xcc, 0x3c, 0xfc, 0x3c, 0xfc,
	0x00, 0xc0, 0x00, 0xc0, 0x30, 0xf0, 0x30, 0xf0,
	0x00, 0xc0, 0x00, 0xc0, 0x30, 0xf0, 0x30, 0xf0,
	0x0c, 0xcc, 0x0c, 0xcc, 0x3c, 0xfc, 0x3c, 0xfc,
	0x0c, 0xcc, 0x0c, 0xcc, 0x3c, 0xfc, 0x3c, 0xfc,
	0x03, 0xc3, 0x03, 0xc3, 0x33, 0xf3, 0x33, 0xf3,
	0x03, 0xc3, 0x03, 0xc3, 0x33, 0xf3, 0x33, 0xf3,
	0x0f, 0xcf, 0x0f, 0xcf, 0x3f, 0xff, 0x3f, 0xff,
	0x0f, 0xcf, 0x0f, 0xcf, 0x3f, 0xff, 0x3f, 0xff,
	0x03, 0xc3, 0x03, 0xc3, 0x33, 0xf3, 0x33, 0xf3,
	0x03, 0xc3, 0x03, 0xc3, 0x33, 0xf3, 0x33, 0xf3,
	0x0f, 0xcf, 0x0f, 0xcf, 0x3f, 0xff, 0x3f, 0xff,
	0x0f, 0xcf, 0x0f, 0xcf, 0x3f, 0xff, 0x3f, 0xff,
	0x00, 0xc0, 0x00, 0xc0, 0x30, 0xf0, 0x30, 0xf0,
	0x00, 0xc0, 0x00, 0xc0, 0x30, 0xf0, 0x30, 0xf0,
	0x0c, 0xcc, 0x0c, 0xcc, 0x3c, 0xfc, 0x3c, 0xfc,
	0x0c, 0xcc, 0x0c, 0xcc, 0x3c, 0xfc, 0x3c, 0xfc,
	0x00, 0xc0, 0x00, 0xc0, 0x30, 0xf0, 0x30, 0xf0,
	0x00, 0xc0, 0x00, 0xc0, 0x30, 0xf0, 0x30, 0xf0,
	0x0c, 0xcc, 0x0c, 0xcc, 0x3c, 0xfc, 0x3c, 0xfc,
	0x0c, 0xcc, 0x0c, 0xcc, 0x3c, 0xfc, 0x3c, 0xfc,
	0x03, 0xc3, 0x03, 0xc3, 0x33, 0xf3, 0x33, 0xf3,
	0x03, 0xc3, 0x03, 0xc3, 0x33, 0xf3, 0x33, 0xf3,
	0x0f, 0xcf, 0x0f, 0xcf, 0x3f, 0xff, 0x3f, 0xff,
	0x0f, 0xcf, 0x0f, 0xcf, 0x3f, 0xff, 0x3f, 0xff,
	0x03, 0xc3, 0x03, 0xc3, 0x33, 0xf3, 0x33, 0xf3,
	0x03, 0xc3, 0x03, 0xc3, 0x33, 0xf3, 0x33, 0xf3,
	0x0f, 0xcf, 0x0f, 0xcf, 0x3f, 0xff, 0x3f, 0xff,
	0x0f, 0xcf, 0x0f, 0xcf, 0x3f, 0xff, 0x3f, 0xff,
};

static half_word swap_pix2 [] = 
{
	0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0xc0, 0xc0,
	0x30, 0x30, 0xf0, 0xf0, 0x30, 0x30, 0xf0, 0xf0,
	0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0xc0, 0xc0,
	0x30, 0x30, 0xf0, 0xf0, 0x30, 0x30, 0xf0, 0xf0,
	0x0c, 0x0c, 0xcc, 0xcc, 0x0c, 0x0c, 0xcc, 0xcc,
	0x3c, 0x3c, 0xfc, 0xfc, 0x3c, 0x3c, 0xfc, 0xfc,
	0x0c, 0x0c, 0xcc, 0xcc, 0x0c, 0x0c, 0xcc, 0xcc,
	0x3c, 0x3c, 0xfc, 0xfc, 0x3c, 0x3c, 0xfc, 0xfc,
	0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0xc0, 0xc0,
	0x30, 0x30, 0xf0, 0xf0, 0x30, 0x30, 0xf0, 0xf0,
	0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0xc0, 0xc0,
	0x30, 0x30, 0xf0, 0xf0, 0x30, 0x30, 0xf0, 0xf0,
	0x0c, 0x0c, 0xcc, 0xcc, 0x0c, 0x0c, 0xcc, 0xcc,
	0x3c, 0x3c, 0xfc, 0xfc, 0x3c, 0x3c, 0xfc, 0xfc,
	0x0c, 0x0c, 0xcc, 0xcc, 0x0c, 0x0c, 0xcc, 0xcc,
	0x3c, 0x3c, 0xfc, 0xfc, 0x3c, 0x3c, 0xfc, 0xfc,
	0x03, 0x03, 0xc3, 0xc3, 0x03, 0x03, 0xc3, 0xc3,
	0x33, 0x33, 0xf3, 0xf3, 0x33, 0x33, 0xf3, 0xf3,
	0x03, 0x03, 0xc3, 0xc3, 0x03, 0x03, 0xc3, 0xc3,
	0x33, 0x33, 0xf3, 0xf3, 0x33, 0x33, 0xf3, 0xf3,
	0x0f, 0x0f, 0xcf, 0xcf, 0x0f, 0x0f, 0xcf, 0xcf,
	0x3f, 0x3f, 0xff, 0xff, 0x3f, 0x3f, 0xff, 0xff,
	0x0f, 0x0f, 0xcf, 0xcf, 0x0f, 0x0f, 0xcf, 0xcf,
	0x3f, 0x3f, 0xff, 0xff, 0x3f, 0x3f, 0xff, 0xff,
	0x03, 0x03, 0xc3, 0xc3, 0x03, 0x03, 0xc3, 0xc3,
	0x33, 0x33, 0xf3, 0xf3, 0x33, 0x33, 0xf3, 0xf3,
	0x03, 0x03, 0xc3, 0xc3, 0x03, 0x03, 0xc3, 0xc3,
	0x33, 0x33, 0xf3, 0xf3, 0x33, 0x33, 0xf3, 0xf3,
	0x0f, 0x0f, 0xcf, 0xcf, 0x0f, 0x0f, 0xcf, 0xcf,
	0x3f, 0x3f, 0xff, 0xff, 0x3f, 0x3f, 0xff, 0xff,
	0x0f, 0x0f, 0xcf, 0xcf, 0x0f, 0x0f, 0xcf, 0xcf,
	0x3f, 0x3f, 0xff, 0xff, 0x3f, 0x3f, 0xff, 0xff,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_conf.h ===
/*
 *	Name:		nt_conf.h
 *	Derived From:	unix_conf.h (gvdl)
 *	Author: 	Jerry Sexton
 *	Created On:	9th August 1991
 *	Purpose:	Host side config defines
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 */

/*
 * HOST defines for resource value option names. These are host specific and may
 * be changed or added to without base recompilation as long as the method used
 * below is adhered to.
 */

/* Host specific hostID #defines. */
#define C_LAST_OPTION   LAST_BASE_CONFIG_DEFINE+1

/************************************/
/* Defines for host specific things */
/************************************/

/* The name of the resource file for this host machine. */
#define SYSTEM_HOME	"SPCHOME"
#define SYSTEM_CONFIG	"$SPCHOME\\SOFTPC.REZ"
#define USER_CONFIG	"$SPCHOME\\SOFTPC.REZ"

GLOBAL CHAR *host_expand_environment_vars(char *scp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_ega.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title	: Win32 EGA Graphics Includes
 *
 * Description	: 
 *
 *		This is the include file for the Win32 specific functions required
 *		to support the EGA emulation.
 *
 * Author	: Dave Bartlett
 *
 * Notes	:
 *
 */


#define EGA_TICK_DELAY		2  /* ticks before EGA mode changes occur */
#define EGA_CHAR_WIDTH		8
#define EGA_CHAR_HEIGHT		14
#define EGA_WIN_WIDTH		(80 * EGA_CHAR_WIDTH)
#define EGA_WIN_HEIGHT		(25 * EGA_CHAR_HEIGHT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_det.h ===
/*
 * ==========================================================================
 *      Name:           nt_det.h
 *      Author:         Tim
 *      Derived From:   nt_fulsc.h
 *      Created On:     4th November 1992
 *      Purpose:        External defs for nt_det.c
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 * ==========================================================================
 */
extern PBYTE textBuffer;
extern COORD textBufferSize;
extern BOOL Frozen256Packed;
extern BOOL HandshakeInProgress;

#ifdef X86GFX
/* Hand-shaking events. */
extern HANDLE hStartHardwareEvent;
extern HANDLE hEndHardwareEvent;
extern HANDLE hErrorHardwareEvent;
#endif

/*
** Centralised console registration funx.
*/
IMPORT VOID doNullRegister IPT0();
IMPORT VOID doRegister IPT0();
IMPORT VOID initTextSection IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_com.h ===
// 
// Filename : nt_com.h
// Contains : function and structure definitions used external to nt_com.c
// Author   : D.A.Bartlett
//

/*::::::::::::::::::::::::::: Functions called from which thread identifiers */

#define RX	    /* Called from RX input thread only */
#define CPU	    /* Called from the CPU thread only */
#define RXCPU	    /* Called from the RX and CPU thread */

/*::::::::::::::::::::::::::::: Function protocols used by other host modules */


IMPORT void CPU host_com_heart_beat IPT0();
IMPORT void host_com_state IPT1(int, adapter);
IMPORT CPU void host_com_close_all IPT0();
IMPORT void host_com_disable_open IPT2(int, adapter, int, DisableOpen);


// from nt_ntfun.c
IMPORT void *AddNewIOStatusBlockToList(void **firstBlock,void **lastBlock,void *new);
IMPORT int RemoveCompletedIOCTLs(void **firstBlock, void **lastBlock);
IMPORT void *AllocStatusElement(void);
IMPORT int SendXOFFIoctl(HANDLE FileHandle,HANDLE Event,int Timeout,int Count,
                         int XoffChar, void *StatusElem);
IMPORT BOOL EnableMSRLSRRXmode(HANDLE FileHandle, HANDLE Event,
                               unsigned char EscapeChar);
IMPORT int FastSetCommMask(HANDLE FileHandle, HANDLE Event, ULONG CommMask);
IMPORT int FastGetCommModemStatus(HANDLE FileHandle,HANDLE Event,PULONG ModemStatus);
IMPORT BOOL FastWaitCommsOrCpuEvent(HANDLE FileHandle,PHANDLE CommsCPUWaitEvents,
				    int CommsEventInx, PULONG EvtMask,
				    PULONG Signalled);


// from nt_wcom.c

typedef HANDLE (*GCHfn)(WORD);
typedef BYTE (*GCSfn)(WORD);
extern HANDLE (*GetCommHandle)(WORD);
extern BYTE (*GetCommShadowMSR)(WORD);
#ifdef _RS232_H
IMPORT BOOL SyncLineSettings(HANDLE FileHandle, DCB *pdcb,
                      DIVISOR_LATCH *divisor_latch, LINE_CONTROL_REG *LCR_reg);
#endif

extern BOOL FastCommSetBaudRate(HANDLE FileHandle, int BaudRate);
extern BOOL FastCommSetLineControl(HANDLE FileHandle, UCHAR StopBits,
				   UCHAR Parity, UCHAR DataBits);
extern BOOL FastCommGetLineControl(HANDLE FileHandle, UCHAR *StopBits,
				   UCHAR *Parity, UCHAR *DataBits);
extern void com_int_data(int adapter, int *controller, int *line);
extern void setup_RTSDTR(int adapter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_eoi.h ===
/*
 *  nt_eoi.h
 *
 *  Visible Ica host functionality and typedefs
 *
 *  The types used in this file must be compatible with softpc base
 *  as the Ica includes this file directly
 *
 *  30-Oct-1993 Jonle , wrote it
 *
 */

typedef VOID (*EOIHOOKPROC)(int IrqLine, int CallCount);

// from nt_eoi.c
BOOL RegisterEOIHook(int IrqLine, EOIHOOKPROC EoiHookProc);
BOOL RemoveEOIHook(int IrqLine, EOIHOOKPROC EoiHookProc);
void host_EOI_hook(int IrqLine, int CallCount);
BOOL host_DelayHwInterrupt(int IrqLine, int CallCount, ULONG Delay);
void host_ica_lock(void);
void host_ica_unlock(void);
void InitializeIcaLock(void);
void WaitIcaLockFullyInitialized(VOID);
VOID ica_RestartInterrupts(ULONG IrqLine);
BOOL ica_restart_interrupts(int adapter);

extern ULONG DelayIrqLine;
extern ULONG UndelayIrqLine;


extern VDMVIRTUALICA VirtualIca[];

#ifdef MONITOR
extern ULONG iretHookActive;
extern ULONG iretHookMask;
extern ULONG AddrIretBopTable;  // seg:offset
extern IU32 host_iret_bop_table_addr(IU32 line);
#endif

//from base ica.c
LONG ica_intack(ULONG *hook_addr);
VOID host_clear_hw_int(VOID);
void ica_eoi(ULONG adapter, LONG *line, int rotate);
void ica_reset_interrupt_state(void);
void ica_hw_interrupt(ULONG adapter, ULONG line_no, LONG call_count);

extern VOID WOWIdle(BOOL bForce);

#define ICA_SLAVE 1
#define ICA_MASTER 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_egalt.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title		: Win32 EGA look-up tables.
 *
 * Description	: 
 *
 * Author		: Dave Bartlett (based on module by John Shanly)
 *
 * Notes		: This file should only be included by nt_ega.c
 *
 */


/*
 * Lookup table for EGA low resolution graphics
 */

static unsigned short ega_low_conv[] = 
{ 
	0x0000, 0x0300, 0x0c00, 0x0f00, 0x0300, 0x3300, 0x3c00, 0x3f00,
	0xc000, 0xc300, 0xcc00, 0xcf00, 0xf000, 0xf300, 0xfc00, 0xff00,
	0x0030, 0x0303, 0x0c03, 0x0f03, 0x3003, 0x3303, 0x3c03, 0x3f03,
	0xc003, 0xc303, 0xcc03, 0xcf03, 0xf003, 0xf303, 0xfc03, 0xff03,
	0x000c, 0x0c03, 0x0c0c, 0x0f0c, 0x300c, 0x330c, 0x3c0c, 0x3f0c,
	0xc00c, 0xc30c, 0xcc0c, 0xcf0c, 0xf00c, 0xf30c, 0xfc0c, 0xff0c,
	0x000f, 0x030f, 0x0c0f, 0x0f0f, 0x300f, 0x330f, 0x3c0f, 0x3f0f,
	0xc00f, 0xc30f, 0xcc0f, 0xcf0f, 0xf00f, 0xf30f, 0xfc0f, 0xff0f,
	0x0030, 0x0330, 0x0c30, 0x0f30, 0x3030, 0x3330, 0x3c30, 0x3f30,
	0xc030, 0xc330, 0xcc30, 0xcf30, 0xf030, 0xf330, 0xfc30, 0xff30,
	0x0033, 0x0333, 0x0c33, 0x0f33, 0x3033, 0x3333, 0x3c33, 0x3f33,
	0xc033, 0xc333, 0xcc33, 0xcf33, 0xf033, 0xf333, 0xfc33, 0xff33,
	0x003c, 0x033c, 0x0c3c, 0x0f3c, 0x303c, 0x333c, 0x3c3c, 0x3f3c,
	0xc03c, 0xc33c, 0xcc3c, 0xcf3c, 0xf03c, 0xf33c, 0xfc3c, 0xff3c,
	0x003f, 0x033f, 0x0c3f, 0x0f3f, 0x303f, 0x333f, 0x3c3f, 0x3f3f,
	0xc03f, 0xc33f, 0xcc3f, 0xcf3f, 0xf03f, 0xf33f, 0xfc3f, 0xff3f,
	0x00c0, 0x03c0, 0x0cc0, 0x0fc0, 0x30c0, 0x33c0, 0x3cc0, 0x3fc0,
	0xc0c0, 0xc3c0, 0xccc0, 0xcfc0, 0xf0c0, 0xf3c0, 0xfcc0, 0xffc0,
	0x00c3, 0x03c3, 0x0cc3, 0x0fc3, 0x30c3, 0x33c3, 0x3cc3, 0x3fc3,
	0xc0c3, 0xc3c3, 0xccc3, 0xcfc3, 0xf0c3, 0xf3c3, 0xfcc3, 0xffc3,
	0x00cc, 0x03cc, 0x0ccc, 0x0fcc, 0x30cc, 0x33cc, 0x3ccc, 0x3fcc,
	0xc0cc, 0xc3cc, 0xcccc, 0xcfcc, 0xf0cc, 0xf3cc, 0xfccc, 0xffcc,
	0x00cf, 0x03cf, 0x0ccf, 0x0fcf, 0x30cf, 0x33cf, 0x3ccf, 0x3fcf,
	0xc0cf, 0xc3cf, 0xcccf, 0xcfcf, 0xf0cf, 0xf3cf, 0xfccf, 0xffcf,
	0x00f0, 0x03f0, 0x0cf0, 0x0ff0, 0x30f0, 0x33f0, 0x3cf0, 0x3ff0,
	0xc0f0, 0xc3f0, 0xccf0, 0xcff0, 0xf0f0, 0xf3f0, 0xfcf0, 0xfff0,
	0x00f3, 0x03f3, 0x0cf3, 0x0ff3, 0x30f3, 0x33f3, 0x3cf3, 0x3ff3,
	0xc0f3, 0xc3f3, 0xccf3, 0xcff3, 0xf0f3, 0xf3f3, 0xfcf3, 0xfff3,
	0x00fc, 0x03fc, 0x0cfc, 0x0ffc, 0x30fc, 0x33fc, 0x3cfc, 0x3ffc,
	0xc0fc, 0xc3fc, 0xccfc, 0xcffc, 0xf0fc, 0xf3fc, 0xfcfc, 0xfffc,
	0x00ff, 0x03ff, 0x0cff, 0x0fff, 0x30ff, 0x33ff, 0x3cff, 0x3fff,
	0xc0ff, 0xc3ff, 0xccff, 0xcfff, 0xf0ff, 0xf3ff, 0xfcff, 0xffff,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_fdisk.h ===
/*
** nt_fdisk.h
*/

// from nt_fdisk.c
extern WORD *pFDAccess;
extern BYTE number_of_fdisk;
extern DWORD max_align_factor;
extern DWORD cur_align_factor;

void fdisk_heart_beat(void);
ULONG disk_read(HANDLE fd, PLARGE_INTEGER offset, DWORD size, PBYTE buffer);
ULONG disk_write(HANDLE fd, PLARGE_INTEGER offset, DWORD size, PBYTE buffer);
BOOL disk_verify(HANDLE fd, PLARGE_INTEGER offset, DWORD size);
PBYTE get_aligned_disk_buffer(void);
VOID host_using_fdisk(BOOL status);
VOID host_fdisk_change(UTINY hostID, BOOL apply);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_extra.h ===
/*[
*************************************************************************

	Name:		nt_extra.h
	Author:	    	Dave Peter
	Created:	May 1995
	Derived from:	Original
	Sccs ID:	@(#)nt_extra.h	1.3 07/20/94
	Purpose:	Extra stuff for NT compatibility.

	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.

*************************************************************************
]*/

#ifndef _NT_EXTRA_H
#define _NT_EXTRA_H

#ifdef NTVDM

#define strcasecmp  _stricmp
#define strncasecmp _strnicmp
#define mkdir(a,b)  _mkdir(a)
#define dup2        _dup2
#define read        _read
#define alloca      _alloca

/*
 * the following are clashes between things defined in windows.h, which
 * has to be included in insgignia.h for other reasons, and 486 definitions.
 */
#ifdef leave
#undef leave
#endif
#ifdef DELETE
#undef DELETE
#endif
#ifdef CREATE_NEW
#undef CREATE_NEW
#endif

#define S_ISDIR(_M)  ((_M & _S_IFMT)==_S_IFDIR) /* test for directory */
#define S_ISCHR(_M)  ((_M & _S_IFMT)==_S_IFCHR) /* test for char special */
#define S_ISBLK(_M)  ((_M & _S_IFMT)==_S_IFBLK) /* test for block special */
#define S_ISREG(_M)  ((_M & _S_IFMT)==_S_IFREG) /* test for regular file */
#define S_ISFIFO(_M) ((_M & _S_IFMT)==_S_IFIFO) /* test for pipe or FIFO */

#ifdef MAX_PATH
#define MAXPATHLEN MAX_PATH
#endif

#endif   /* !NTVDM */

#endif  /* _NT_EXTRA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_event.h ===
/*
 * ==========================================================================
 *      Name:           nt_event.h
 *      Author:         Tim
 *      Derived From:
 *      Created On:     27 Jan 93
 *      Purpose:        External defs for nt_event.c
 *
 *      (c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 * ==========================================================================
 */

/*::::::::::::::::::::::::::::::::::::::: Event types handled by nt_event.c */

#define ES_NOEVENTS     0
#define ES_SCALEVENT    4
#define ES_YODA         8
#ifdef YODA
void CheckForYodaEvents(void);
#endif
#ifndef X86GFX
void GetScaleEvent(void);
#endif

/*::::::::::::::::::::::::::::::::::::::: Prototypes */


IMPORT BOOL stdoutRedirected;

IMPORT ULONG CntrlHandlerState;
#define CNTRL_SHELLCOUNT         0xFFFF  // The LOWORD is used for shell count
#define CNTRL_PIFALLOWCLOSE      0x10000
#define CNTRL_VDMBLOCKED         0x20000
#define CNTRL_SYSTEMROOTCONSOLE  0x40000
#define CNTRL_PUSHEXIT           0x80000

#define INVALID_HANDLE           (HANDLE)-1

void nt_start_event_thread(void);
void nt_remove_event_thread(void);
void EnterEventCritical(void);
void LeaveEventCritical(void);
void GetNextMouseEvent(void);
BOOL MoreMouseEvents(void);
VOID DelayMouseEvents(ULONG count);
void FlushMouseEvents(void);
#ifdef X86GFX
IMPORT VOID SelectMouseBuffer(half_word mode, half_word lines);
#endif //X86GFX

VOID KbdResume(VOID);
ULONG  WaitKbdHdw(ULONG dwTimeOut);
VOID   HostReleaseKbd(VOID);
void SyncBiosKbdLedToKbdDevice(void);
void SyncToggleKeys(WORD wVirtualKeyCode, DWORD dwControlKeyState);
extern DWORD ToggleKeyState;

extern HANDLE hWndConsole;
extern PointerAttachedWindowed;
extern BOOL DelayedReattachMouse;
extern ULONG EventThreadKeepMode;
extern HANDLE hSuspend;             // request both app and console threads to be suspened
extern HANDLE hResume;              // Signal that console and app threads can continue
extern HANDLE hConsoleSuspended;    // Signal console thread is suspended
extern HANDLE hMainThreadSuspended; // Signal app thread is suspended
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_fulsc.h ===
/*
 * ==========================================================================
 *      Name:           nt_fulsc.h
 *      Author:         Jerry Sexton
 *      Derived From:
 *      Created On:     5th February 1992
 *      Purpose:        This header file contains definitions etc. for
 *                      full-screen graphics modules.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 * ==========================================================================
 */


/*
 * ==========================================================================
 * Macros
 * ==========================================================================
 */
#define ErrorExit() DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);


#define CURRENT_OFFSET(r)       ((DWORD) (r) - (DWORD) videoState)
#define GET_OFFSET(offset)      ((BYTE *) videoState + videoState->offset)

#define MID_VAL(x, y)   (x + (y - x) / 2)

#define NUM_SEQ_REGS    5
#define NUM_CRTC_REGS   25
#define NUM_GC_REGS     9
#define NUM_AC_REGS     21
#define NUM_DAC_REGS    256

#define STATELENGTH             sizeof(VIDEO_HARDWARE_STATE_HEADER)
#define LATCHLENGTH             4
#define RGBLENGTH               3
#define PLANELENGTH             0x10000

#define BASICSEQUENCEROFFSET    STATELENGTH
#define BASICCRTCONTOFFSET      BASICSEQUENCEROFFSET + NUM_SEQ_REGS
#define BASICGRAPHCONTOFFSET    BASICCRTCONTOFFSET + NUM_CRTC_REGS
#define BASICATTRIBCONTOFFSET   BASICGRAPHCONTOFFSET + NUM_GC_REGS
#define BASICDACOFFSET          BASICATTRIBCONTOFFSET + NUM_AC_REGS
#define BASICLATCHESOFFSET      BASICDACOFFSET + NUM_DAC_REGS * RGBLENGTH
#define PLANE1OFFSET            BASICLATCHESOFFSET + LATCHLENGTH
#define PLANE2OFFSET            PLANE1OFFSET + PLANELENGTH
#define PLANE3OFFSET            PLANE2OFFSET + PLANELENGTH
#define PLANE4OFFSET            PLANE3OFFSET + PLANELENGTH

#define VIDEO_PAGE_SIZE (80 * 25 * 2)   // Cols * rows * (char + attrib)

#define BIT_PLANE_SIZE  65536

#define VGA_WIDTH       80

#define VGA_HEIGHT_0    22
#define VGA_HEIGHT_1    25
#define VGA_HEIGHT_2    28
#define VGA_HEIGHT_3    43
#define VGA_HEIGHT_4    50

#define MAX_TITLE_LEN   256

#define MAX_CONSOLE_HEIGHT      50
#define MAX_CONSOLE_WIDTH       80
#define MAX_CONSOLE_SIZE        (MAX_CONSOLE_HEIGHT * MAX_CONSOLE_WIDTH)

#define DEF_FONT_WIDTH  8
#define DEF_FONT_HEIGHT 8

#define GET     FALSE
#define SET     TRUE

#define DISPLAY_TYPE    0x40

#define AC_MODE_CONTROL_REG     16

#ifndef PROD
/* Debug stuff. */
#define FullScreenTrace0(s) \
        if (FullScreenDebug) always_trace0(s)
#define FullScreenTrace1(s ,p0) \
        if (FullScreenDebug) always_trace1(s, p0)
#define FullScreenTrace2(s, p0, p1) \
        if (FullScreenDebug) always_trace2(s, p0, p1)
#define FullScreenTrace3(s, p0, p1, p2) \
        if (FullScreenDebug) always_trace3(s, p0, p1, p2)
#define FullScreenTrace4(s, p0, p1, p2, p3) \
        if (FullScreenDebug) always_trace4(s, p0, p1, p2, p3)
#define FullScreenTrace5(s, p0, p1, p2, p3, p4) \
        if (FullScreenDebug) always_trace5(s, p0, p1, p2, p3, p4)
#define FullScreenTrace6(s, p0, p1, p2, p3, p4, p5) \
        if (FullScreenDebug) always_trace6(s, p0, p1, p2, p3, p4, p5)
#define FullScreenTrace7(s, p0, p1, p2, p3, p4, p5, p6) \
        if (FullScreenDebug) always_trace7(s, p0, p1, p2, p3, p4, p5, p6)
#define FullScreenTrace8(s, p0, p1, p2, p3, p4, p5, p6, p7) \
        if (FullScreenDebug) always_trace7(s, p0, p1, p2, p3, p4, p5, p6, p7)
#else /* !PROD */
#define FullScreenTrace0(s)
#define FullScreenTrace1(s ,p0)
#define FullScreenTrace2(s, p0, p1)
#define FullScreenTrace3(s, p0, p1, p2)
#define FullScreenTrace4(s, p0, p1, p2, p3)
#define FullScreenTrace5(s, p0, p1, p2, p3, p4)
#define FullScreenTrace6(s, p0, p1, p2, p3, p4, p5)
#define FullScreenTrace7(s, p0, p1, p2, p3, p4, p5, p6)
#define FullScreenTrace8(s, p0, p1, p2, p3, p4, p5, p6, p7)
#endif /* !PROD */

/*
 * ==========================================================================
 * Typedefs
 * ==========================================================================
 */

/* Structure for saving video block name in. */
typedef struct
{
    WCHAR   *Name;
    ULONG   NameLen;
} WCHAR_STRING;

/* Valid hardware state table entry. */
typedef struct
{
    USHORT      LinesOnScreen;
    COORD       Resolution;
    COORD       FontSize;
} HARDWARE_STATE;

/*
 * ==========================================================================
 * Global Data
 * ==========================================================================
 */
IMPORT HANDLE MainThread;
IMPORT DWORD stateLength;
#ifdef X86GFX
IMPORT HANDLE hStartHardwareEvent;
IMPORT HANDLE hEndHardwareEvent;
IMPORT HANDLE hErrorHardwareEvent;
IMPORT PVIDEO_HARDWARE_STATE_HEADER videoState;
#endif
IMPORT PVOID textState; //Tim Nov 92.
IMPORT WCHAR_STRING videoSection;
IMPORT WCHAR_STRING textSection;
IMPORT BOOL NoTicks;
IMPORT HANDLE StartTToG;
IMPORT HANDLE EndTToG;
IMPORT BOOL BiosModeChange;
#ifndef PROD
IMPORT UTINY FullScreenDebug;
#endif /* PROD */

extern DWORD savedScreenState;
extern BOOL  ConsoleInitialised;
extern BOOL  ConsoleNoUpdates;
#ifdef X86GFX
extern DWORD mouse_buffer_width;
extern DWORD mouse_buffer_height;
#endif /* X86GFX */
extern BOOL blocked_in_gfx_mode;

/*
 * ==========================================================================
 * Imported Functions
 * ==========================================================================
 */
IMPORT VOID nt_init_event_thread(VOID);
IMPORT VOID ConsoleInit(VOID);
IMPORT VOID GfxReset(VOID);
IMPORT VOID ResetConsoleState(VOID);
IMPORT VOID InitTToG(VOID);
IMPORT VOID SwitchToFullScreen(BOOL);
IMPORT VOID CheckForFullscreenSwitch(VOID);
IMPORT UTINY getNtScreenState(VOID);
IMPORT BOOL hostModeChange(VOID);
IMPORT VOID DoFullScreenResume(VOID);
IMPORT VOID GfxCloseDown(VOID);

IMPORT VOID TextSectionName(WCHAR **, ULONG *);
IMPORT VOID VideoSectionName(WCHAR **, ULONG *);
IMPORT PVOID *CreateVideoSection(ULONG);
IMPORT PVOID *CreateTextSection(ULONG);
IMPORT VOID CommitSection(PVOID *, ULONG *);
IMPORT VOID CloseSection(PVOID);
IMPORT VOID LoseRegenMemory(VOID);
IMPORT VOID RegainRegenMemory(VOID);

IMPORT VOID DoHandShake(VOID);

IMPORT VOID ResetConsoleState IPT0();
IMPORT int  getModeType(VOID);

#ifdef X86GFX
#define CPI_FILENAME_LENGTH     9
#define CPI_FILENAME            "\\ega.cpi"
#define CPI_SIGNATURE_LENGTH    8
#define CPI_SIGNATURE_NT        "\xFF""FONT.NT"
#define CPI_SIGNATURE_DOS       "\xFF""FONT   "

#pragma pack(1)
typedef struct _CPIFILEHEADER {

    CHAR    Signature[8];               // "\xFF""FONT.NT" for nt ega.cpi
                                        // "\xFF""FONT   " for dos ega.cpi
    BYTE    Reserved[8];
    WORD    NumberOfPointers;
    BYTE    TypeOfPointer;
    DWORD   OffsetToCodePageHeader;
} CPIFILEHEADER, * PCPIFILEHEADER;

typedef struct _CPICODEPAGEHEADER{
    WORD    NumberOfCodePages;
} CPICODEPAGEHEADER, *PCPICODEPAGEHEADER;

typedef struct _CPICODEPAGEENTRY {
    WORD    HeaderSize;
    DWORD   OffsetToNextCodePageEntry;
    WORD    DeviceType;
    CHAR    DevieSubTypeID[8];
    WORD    CodePageID;
    BYTE    Reserved[6];
    DWORD   OffsetToFontHeader;         // absolute for DOS CPI
                                        // relative for NT CPI
}  CPICODEPAGEENTRY, *PCPICODEPAGEENTRY;

typedef struct _CPIFONTHEADER {
    WORD    Reserved;
    WORD    NumberOfFonts;
    WORD    LengthOfFontData;
} CPIFONTHEADER, *PCPIFONTHEADER;

typedef struct _CPIFONTDATA{
    BYTE    FontHeight;
    BYTE    FontWidth;
    WORD    AspectRatio;
    WORD    NumberOfCharacters;
} CPIFONTDATA, *PCPIFONTDATA;
#pragma pack()

IMPORT BOOL LoadCPIFont(UINT, WORD, WORD);
#endif


#ifdef X86GFX
VOID locateNativeBIOSfonts(VOID);
VOID GetROMsMapped(VOID);
VOID LoseRegenMemory(VOID);
VOID RegainRegenMemory(VOID);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_getxx.h ===
#ifdef CCPU
#undef getAX
extern getAX();
#undef getCX
extern getCX();
#undef getDX
extern getDX();
#undef getBX
extern getBX();
#undef getSP
extern getSP();
#undef getBP
extern getBP();
#undef getSI
extern getSI();
#undef getDI
extern getDI();
#undef getES
extern getES();
#undef getCS
extern getCS();
#undef getSS
extern getSS();
#undef getDS
extern getDS();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_hunt.h ===
#define IDM_MFAST	201
#define IDM_MNEXT	202
#define IDM_MPREV	203
#define IDM_MSHOW	204
#define IDM_MCONT	205
#define IDM_MABOR	206

#define IDM_EFLIP	211
#define IDM_ENEXT	212
#define IDM_EPREV	213
#define IDM_EALL	214
#define IDM_ECLEA	215

#define IDM_TRAPPER	200

IMPORT HANDLE TrapperDump;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_graph.h ===
/* 
 *
 * Title        : Win32 Graphics Function Declarations
 *
 * Description  : Definitions of routines for display adapters to use and
 *                the Win32 screen description structre.
 *
 * Author       : Dave Bartlett (based on module by Henry Nash)
 *
 * Notes        : None
 */

/*
 * This structure contains elements used by the GUI to control the SoftPC
 * output window. They are lumped together to provide a single control
 * structure and therefore point of reference.
 */

typedef struct
{
    HANDLE      OutputHandle;             /* Console standard output. */
    HANDLE      InputHandle;              /* Console standard input. */
    HANDLE      ScreenBufHandle;          /* Console screen buffer handle. */

    CONSOLE_GRAPHICS_BUFFER_INFO        ConsoleBufInfo;

    DWORD       OrgInConsoleMode;         /* Org input console mode settings */
    DWORD       OrgOutConsoleMode;        /* Org Output console mode settings */

    char        *BitmapLastLine;          /* Last line of console bitmap. */
    int         BitsPerPixel;             /* Bits per pixel of bitmap. */
    DWORD       ScreenState;              /* WINDOWED or FULLSCREEN. */
    int         ModeType;                 /* TEXT or GRAPHICS. */

    HWND        Display;                  /* Screen handle of output window */
    HDC         DispDC;                   /* Displays device context */
    int         Colours;                  /* Number of colors: 0, 8 or 16 */
    int         RasterCaps;               /* Displays raster capabilities */
    HPALETTE    ColPalette;               /* Colour palette */
    BOOL        StaticPalette;            /* Palette managed device */

    int         PCForeground;             /* PC foreground pixel value !!!*/
    int         PCBackground;             /* PC foreground pixel value !!!*/

    /*.............................................. Font control variables */

    HFONT       NormalFont;               /* Display fonts */
    HFONT       NormalUnderlineFont;      /* Not yet created !!!! */
    HFONT       BoldFont;
    HFONT       BoldUnderlineFont;        /* Not yet created !!!! */
    BOOL        FontsAreOpen;             /* TRUE if all fonts are open*/

    /*................................................ Font character sizes */

    int         CharLeading;              /* pixels to add before drawing */
    int         CharCellHeight;           /* Height of display char,pixels*/
    int         CharCellWidth;            /* Width of display char,pixels */

    int         CharWidth;                /* The above or these will be ..*/
    int         CharHeight;               /* .. deleted, soon - DAB */
    /*........................................ Repeat key control variables */

    int         RepeatScan;               /* Scan code of repeated char */
    int         NRepeats;                 /* Counter to start repeats  */

    /*...................................... Host screen sizing information */

    BOOL        ScaleOutput;              /* Scale output or use scroll bars */
    int         PC_W_Height;              /* Height of PC screen, pixels */
    int         PC_W_Width;               /* Width of PC screen, pixels */

    /*...................................... Handle focus changes */

    BOOL        Focus;                    /* Window has Input Focus */
    HANDLE      FocusEvent;               /* Focus has changed event */
    HANDLE      ActiveOutputBufferHandle; /* The current Console screen buffer handle. */
#ifdef X86GFX
    BOOL	Registered;		  /* TRUE when are registered to the console */
#endif
    WORD	ScreenSizeX;
    WORD	ScreenSizeY;
    HANDLE	AltOutputHandle;
    CONSOLE_SCREEN_BUFFER_INFO ConsoleBuffInfo;
}   SCREEN_DESCRIPTION;


// these were defined in a windows file & may now have moved.
#ifndef WINDOWED
#define WINDOWED        0
#endif
#ifndef FULLSCREEN
#define FULLSCREEN      1
#endif
#ifndef STREAM_IO
#define STREAM_IO	2
#endif


/*:::::::::::::::::::::::::::::::::::::::::::: Extra virtual key defination */

#define VK_SCROLLOCK    0x91

/*::::::::::::::::::::::::::::::::::::: Macros to access display attributes */

#define fg_colour(attr)         ((attr & 0x0f))
#define bg_colour(attr)         (((attr & bg_col_mask) >> 4))
#define UBPS (sizeof(short)/2) /* useful bytes per short */

#ifdef BIGWIN

#if defined(NEC_98)         
#define SCALE(value) (value)                                    
#define UNSCALE(value) (value)                                  
#else  // !NEC_98
#define SCALE(value) ((host_screen_scale * (value)) >> 1)
#define UNSCALE(value) (((value) << 1) / host_screen_scale)
#endif // !NEC_98
#define MAX_SCALE(value) ((value) << 1)

#else   /* BIGWIN */

#define SCALE(value) (value)
#define UNSCALE(value) (value)
#define MAX_SCALE(value) (value)

#endif /* BIGWIN */

/*@ACW=======================================================================
Define to access the Console Window handle from VDMConsoleOperation.
===========================================================================*/

#define VDM_WINDOW_HANDLE	2

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#define BYTES_IN_LO_RES_SCANLINE        (40)
#define BYTES_IN_HI_RES_SCANLINE        (80)

#define BYTES_IN_MONO_SCANLINE          (80)
#define SHORTS_IN_MONO_SCANLINE         (40)
#define INTS_IN_MONO_SCANLINE           (20)


#define INTS_IN_COLOUR_SCANLINE (160)

#define ONE_SCANLINE                    (1)
#define TWO_SCANLINES                   (2)
#define THREE_SCANLINES                 (3)
#define FOUR_SCANLINES                  (4)

#define MONO_BGND                       (0)
#define MONO_FGND                       (1)

#define MAX_IMAGE_WIDTH                 (MAX_SCALE(1056))
#define MAX_IMAGE_HEIGHT                (MAX_SCALE(768))

#define NT_MONO_IMAGE_WIDTH             (SCALE(1024))
#define NT_MONO_IMAGE_HEIGHT            (SCALE(768))

#define NT_CGA_IMAGE_WIDTH              (SCALE(640))
#define NT_CGA_IMAGE_HEIGHT             (SCALE(400))

#define NT_EGA_IMAGE_WIDTH              (SCALE(1056))
#define NT_EGA_IMAGE_HEIGHT             (SCALE(768))

#define NT_VGA_IMAGE_WIDTH              (SCALE(720))
#define NT_VGA_IMAGE_HEIGHT             (SCALE(480))

#define MONO_BITS_PER_PIXEL             1
#define CGA_BITS_PER_PIXEL              8
#define EGA_BITS_PER_PIXEL              8
#define VGA_BITS_PER_PIXEL              8

#define USE_COLOURTAB                   0
#define VGA_NUM_COLOURS                 256

/*
 * Definitions of number of bytes and longs in one scanline of a DIB.
 * NB scanlines in DIB's are aligned to LONG boundaries.
 */
#define BITSPERLONG                     (sizeof(LONG) * 8)
#define DIB_SCANLINE_BYTES(nBits) \
                (sizeof(LONG) * (((nBits) + BITSPERLONG - 1) / BITSPERLONG))
#define BYTES_PER_SCANLINE(lpBitMapInfo) \
                (DIB_SCANLINE_BYTES((lpBitMapInfo)->bmiHeader.biWidth * \
                                    (lpBitMapInfo)->bmiHeader.biBitCount))
#define SHORTS_PER_SCANLINE(lpBitMapInfo) \
                (BYTES_PER_SCANLINE(lpBitMapInfo) / sizeof(SHORT))
#define LONGS_PER_SCANLINE(lpBitMapInfo) \
                (BYTES_PER_SCANLINE(lpBitMapInfo) / sizeof(LONG))

/* Offsets used by look-up tables in nt_munge.c */
#define LUT_OFFSET                      512

#ifdef  BIGWIN
#define BIG_LUT_OFFSET                  768
#define HUGE_LUT_OFFSET                 1024
#endif  /* BIGWIN */

/*::::::::::::::: Colour table structures for DIB creation :::::::::::::::::*/

#define DEFAULT_NUM_COLOURS             16
#define MONO_COLOURS                    2

typedef struct
{
    int     count;
    BYTE    *red;
    BYTE    *green;
    BYTE    *blue;
} COLOURTAB;

IMPORT COLOURTAB defaultColours;
IMPORT COLOURTAB monoColours;

/*:::::::::::::::::::::::::::::: Mutex macros ::::::::::::::::::::::::::::::*/
#define GrabMutex(mutex)    { DWORD dwGMErr;                               \
            dwGMErr = WaitForSingleObject(mutex,INFINITE);                 \
            assert4(dwGMErr == WAIT_OBJECT_0,                              \
                    "Ntvdm:GrabMutex RC=%x GLE=%d %s:%d\n",                \
                     dwGMErr, GetLastError(), __FILE__,__LINE__);          \
            }

#define RelMutex(mutex) ReleaseMutex(mutex);




/*::::::::::::::::::::::::::::::::::::::::::::::::::: External declarations */

extern SCREEN_DESCRIPTION   sc;
extern int                  host_screen_scale;
extern half_word            bg_col_mask;

extern char                *DIBData;
extern PBITMAPINFO          MonoDIB;
extern PBITMAPINFO          CGADIB;
extern PBITMAPINFO          EGADIB;
extern PBITMAPINFO          VGADIB;
extern BOOL                 FunnyPaintMode;

/*::::::::::::::::::::::::::::::::::::::::::::::::::::: Paint vector table */

typedef struct
{
#if defined(NEC_98)         
        void (*NEC98_text)();             // Graph off(at PIF file) Text mode
        void (*NEC98_text20_only)();      // Graph on(at PIF file) Text20 only
        void (*NEC98_text25_only)();      // Graph on(at PIF file) Text25 only
        void (*NEC98_graph200_only)();    // Graph on(at PIF file) Graph200 only
        void (*NEC98_graph200slt_only)(); // Graph on(at PIF file) Graph200 only
        void (*NEC98_graph400_only)();    // Graph on(at PIF file) Graph400 only
        void (*NEC98_text20_graph200)();  // Graph on(at PIF file)Text20graph200
        void (*NEC98_text20_graph200slt)();//Graph on(at PIF file)Text20graph200
        void (*NEC98_text25_graph200)();  // Graph on(at PIF file)Text25graph200
        void (*NEC98_text25_graph200slt)();//Graph on(at PIF file)Text25graph200
        void (*NEC98_text20_graph400)();  // Graph on(at PIF file)Text20graph400
        void (*NEC98_text25_graph400)();  // Graph on(at PIF file)Text25graph400
#endif // NEC_98
        void (*cga_text)();
        void (*cga_med_graph)();
        void (*cga_hi_graph)();
        void (*ega_text)();
        void (*ega_lo_graph)();
        void (*ega_med_graph)();
        void (*ega_hi_graph)();
        void (*vga_graph)();
	void (*vga_med_graph)();
        void (*vga_hi_graph)();
#ifdef V7VGA
        void (*v7vga_hi_graph)();
#endif /* V7VGA */
} PAINTFUNCS;

typedef struct
{
#if defined(NEC_98)         
      void (*NEC98_text)();              // Graph off(at PIF file) Text
        void (*NEC98_text20_only)();     // Graph on(at PIF file) Text 20
        void (*NEC98_text25_only)();     // Graph on(at PIF file) Text 25
        void (*NEC98_graph200_only)();   // Graph on(at PIF file) Graph200
        void (*NEC98_graph200slt_only)();// Graph on(at PIF file) Graph200
        void (*NEC98_graph400_only)();   // Graph on(at PIF file) Graph400
        void (*NEC98_text20_graph200)(); // Graph on(at PIF file)Text20graph200
        void (*NEC98_text20_graph200slt)();//Graph on(at PIF file)Text20graph200
        void (*NEC98_text25_graph200)(); // Graph on(at PIF file)Text25graph200
        void (*NEC98_text25_graph200slt)();//Graph on(at PIF file)Text25graph200
        void (*NEC98_text20_graph400)(); // Graph on(at PIF file)Text20graph400
        void (*NEC98_text25_graph400)(); // Graph on(at PIF file)Text25graph400
#endif // NEC_98
        void (*cga_text)();
        void (*cga_med_graph)();
        void (*cga_hi_graph)();
        void (*ega_text)();
        void (*ega_lo_graph)();
        void (*ega_med_graph)();
        void (*ega_hi_graph)();
        void (*vga_hi_graph)();
} INITFUNCS;

/*::::::::::::::::::::::::::::::::::::::: Initialisation and paint routines */

IMPORT VOID closeGraphicsBuffer IPT0();
extern void nt_mark_screen_refresh();
extern void nt_init_text();
extern void nt_init_cga_mono_graph();
extern void nt_init_cga_colour_med_graph();
extern void nt_init_cga_colour_hi_graph();
extern void nt_text(int offset, int x, int y, int len, int height);
extern void nt_cga_mono_graph_std(int offset, int screen_x, int screen_y,
                                 int len, int height);
extern void nt_cga_mono_graph_big(int offset, int screen_x, int screen_y,
                                 int len, int height);
extern void nt_cga_mono_graph_huge(int offset, int screen_x, int screen_y,
                                 int len, int height);
extern void nt_cga_colour_med_graph_std(int offset, int screen_x, int screen_y,
                                 int len, int height);
extern void nt_cga_colour_med_graph_big(int offset, int screen_x, int screen_y,
                                 int len, int height);
extern void nt_cga_colour_med_graph_huge(int offset, int screen_x, int screen_y,
                                 int len, int height);
extern void nt_cga_colour_hi_graph_std(int offset, int screen_x, int screen_y,
                                 int len, int height);
extern void nt_cga_colour_hi_graph_big(int offset, int screen_x, int screen_y,
                                 int len, int height);
extern void nt_cga_colour_hi_graph_huge(int offset, int screen_x, int screen_y,
                                 int len, int height);

extern void nt_init_ega_lo_graph();
extern void nt_init_ega_mono_lo_graph();
extern void nt_init_ega_med_graph();
extern void nt_init_ega_hi_graph();
extern void nt_ega_text();
extern void nt_ega_lo_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_lo_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_lo_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_med_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_med_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_med_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_hi_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_hi_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_hi_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_lo_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_lo_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_lo_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_med_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_med_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_med_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_hi_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_hi_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_ega_mono_hi_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);

extern void nt_init_vga_hi_graph();
extern void nt_vga_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_med_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_med_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_med_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_hi_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_hi_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_hi_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_med_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_med_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_med_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_hi_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_hi_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_vga_mono_hi_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);

#ifdef V7VGA
extern void nt_v7vga_hi_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_v7vga_hi_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_v7vga_hi_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);

extern void nt_v7vga_mono_hi_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_v7vga_mono_hi_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_v7vga_mono_hi_graph_huge(int offset, int screen_x, int screen_y,
                         int width, int height);
#endif /* V7VGA */
#if defined(NEC_98)         
//Paint & Init routine extern declare for NEC PC-98 series
extern void nt_init_text20_only(void);
extern void nt_init_text25_only(void);
extern void nt_init_graph200_only(void);
extern void nt_init_graph200slt_only(void);
extern void nt_init_graph400_only(void);
extern void nt_init_text20_graph200(void);
extern void nt_init_text20_graph200slt(void);
extern void nt_init_text25_graph200(void);
extern void nt_init_text25_graph200slt(void);
extern void nt_init_text20_graph400(void);
extern void nt_init_text25_graph400(void);

extern void nt_text20_only(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_text25_only(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_graph200_only(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_graph200slt_only(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_graph400_only(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_text20_graph200(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_text20_graph200slt(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_text25_graph200(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_text25_graph200slt(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_text20_graph400(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_text25_graph400(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_cursor20_only(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_cursor25_only(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_cursor20(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void nt_cursor25(int offset, int screen_x, int screen_y,
                         int width, int height);
extern void dummy_cursor_paint(int offset, int screen_x, int screen_y,
                         int width, int height);
#endif // NEC_98

#ifdef MONITOR
void nt_cga_med_frozen_std(int offset, int screen_x, int screen_y, int len,
			   int height);
void nt_cga_hi_frozen_std(int offset, int screen_x, int screen_y, int len,
			  int height);
void nt_ega_lo_frozen_std(int offset, int screen_x, int screen_y,
                          int width, int height);
void nt_ega_med_frozen_std(int offset, int screen_x, int screen_y,
                           int width, int height);
void nt_ega_hi_frozen_std(int offset, int screen_x, int screen_y,
                          int width, int height);
void nt_vga_frozen_std(int offset, int screen_x, int screen_y,
                       int width, int height);
void nt_vga_frozen_pack_std(int offset, int screen_x, int screen_y,
                       int width, int height);
void nt_vga_med_frozen_std(int offset, int screen_x, int screen_y,
                           int width, int height);
void nt_vga_hi_frozen_std(int offset, int screen_x, int screen_y,
                          int width, int height);
void nt_dummy_frozen(int offset, int screen_x, int screen_y, int len,
		     int height);
#endif /* MONITOR */

void high_stretch3(unsigned char *buffer, int length);
void high_stretch4(unsigned char *buffer, int length);

/* functions in nt_munge.c */

IMPORT VOID ega_colour_hi_munge(unsigned char *, int, unsigned int *,
                                unsigned int *, int, int);

#ifdef BIGWIN

IMPORT VOID ega_colour_hi_munge_big(unsigned char *, int, unsigned int *,
                                    unsigned int *, int, int);
IMPORT VOID ega_colour_hi_munge_huge(unsigned char *, int, unsigned int *,
                                     unsigned int *, int, int);

#endif /* BIGWIN */


extern BYTE Red[];
extern BYTE Green[];
extern BYTE Blue[];

DWORD CreateSpcDIB(int, int, int, WORD, int, COLOURTAB *, BITMAPINFO **);
BOOL  CreateDisplayPalette(void);
int get_screen_scale IFN0();
void SetupConsoleMode(void);

#ifdef MONITOR
IMPORT void select_frozen_routines IFN0();
half_word get_vga_DAC_rd_addr(void);
void resetNowCur(void);
#endif /* MONITOR */

void do_new_cursor(void);
void textResize(void);
void resetWindowParams(void);
VOID resizeWindow(int, int);
void set_the_vlt(void);
void graphicsResize(void);

extern word int10_seg;
extern word int10_caller;
extern word useHostInt10;
extern word changing_mode_flag;
#ifndef NEC_98
extern boolean host_stream_io_enabled;
#endif // !NEC_98


// from nt_ega.c
void nt_init_ega_hi_graph(void);
void nt_init_ega_mono_lo_graph(void);
void nt_init_ega_lo_graph(void);
void nt_init_ega_med_graph(void);
void nt_ega_lo_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height);
void nt_ega_med_graph_std(int offset, int screen_x, int screen_y,
                          int width, int height);




// from nt_cga.c
void nt_init_cga_mono_graph(void);
void nt_init_cga_colour_med_graph(void);
void nt_init_cga_colour_hi_graph(void);
void nt_init_text(void);

// from nt_vga.c
void nt_init_vga_hi_graph(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_inthk.h ===
/*[
 *
 *  Name:	    nt_inthk.h
 *
 *  Derived From:   (original)
 *
 *  Author:	    Dave Bartlett
 *
 *  Created On:     18 Jan 1995
 *
 *  Coding Stds:    2.4
 *
 *  Purpose:	    Contain function proto-types for exception, software,
 *		    hardware interrupt hooks
 *
 *  Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
]*/


/* Hardware interrupt hooking functions */
IMPORT BOOL host_hwint_hook IPT1(IS32, int_no);
IMPORT NTSTATUS VdmInstallHardwareIntHandler IPT1(PVOID, HardwareIntHandler);


/* Software interrupt hooking functions */
#ifdef CCPU
IMPORT BOOL host_swint_hook IPT1(IS32, int_no);
#endif

IMPORT NTSTATUS VdmInstallSoftwareIntHandler IPT1(PVOID, SoftwareIntHandler);


/* Expection interrupt hooking functions */
#ifdef CCPU
IMPORT BOOL host_exint_hook IPT2(IS32, exp_no, IS32, error_code);
#endif

IMPORT NTSTATUS VdmInstallFaultHandler IPT1(PVOID, FaultHandler);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_mem.h ===
IMPORT IU8 *InitIntelMemory IPT1(IU32, MaxIntelMemorySize);
IMPORT GLOBAL VOID FreeIntelMemory IPT0();

IMPORT NTSTATUS VdmAllocateVirtualMemory IPT3(PULONG, Address,
					      ULONG, Size,
					      BOOL, Commit);
IMPORT NTSTATUS VdmDeCommitVirtualMemory IPT2(ULONG, INTELAddress,
					      ULONG, Size);
IMPORT NTSTATUS VdmCommitVirtualMemory IPT2(ULONG, INTELAddress,
					    ULONG, Size);
IMPORT NTSTATUS VdmFreeVirtualMemory IPT1(ULONG, Address);
IMPORT NTSTATUS VdmQueryFreeVirtualMemory IPT2(PULONG, FreeBytes,
                                               PULONG, LargestFreeBlock);
IMPORT NTSTATUS VdmReallocateVirtualMemory IPT3(ULONG, OriginalAddress,
                                                PULONG, NewAddress,
                                                ULONG, NewSize);
IMPORT NTSTATUS VdmAddVirtualMemory IPT3(ULONG, HostAddress,
                                         ULONG, Size,
                                         PULONG, IntelAddress);
IMPORT NTSTATUS VdmRemoveVirtualMemory IPT1(ULONG, IntelAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_mouse.h ===
/* global structure used to share mouse status data between nt_input.c
 * and nt_mouse.c
 */
/*@ACW*/


struct mouse_status
   {
   SHORT x,y;
   SHORT button_l,button_r;
   };

typedef struct mouse_status MOUSE_STATUS;


//
// defines for the Warping detection code.
//

#define NOWARP		0x0
#define	TOP		0x1
#define	BOTTOM		0x2
#define	RIGHT		0x4
#define	LEFT		0x8

#define	TOPLEFT		0x9	// TOP | LEFT	
#define	TOPRIGHT	0x5	// TOP | RIGHT	
#define	BOTTOMLEFT	0xa	// BOTTOM | LEFT
#define	BOTTOMRIGHT     0x6	// BOTTOM | RIGHT	

extern MOUSE_STATUS os_pointer_data;
extern boolean MouseCallBack;
void DoMouseInterrupt(void);
void SuspendMouseInterrupts(void);
void ResumeMouseInterrupts(void);
void LazyMouseInterrupt(void);
void host_hide_pointer(void);
void host_show_pointer(void);
void host_mouse_conditional_off_enabled(void);

void MouseDisplay(void);
void MouseHide(void);
void CleanUpMousePointer(void);
void MouseDetachMenuItem(BOOL);
VOID ResetMouseOnBlock(VOID);


extern BOOL bPointerOff;
extern word VirtualX;
extern word VirtualY;


// from base\mouse_io.c
extern void mouse_install1(void);
extern void mouse_install2(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_paint.h ===
/*:::::::::::::::::::::::: Console graphics globals :::::::::::::::::::::::*/
IMPORT CONSOLE_GRAPHICS_BUFFER_INFO	consoleBufInfo;
IMPORT HANDLE	screenBufHandle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_reset.h ===
/*
** nt_reset.h
*/
#ifdef X86GFX
extern  VOID InitDetect(VOID);
#endif

extern BOOL   VDMForWOW;
extern BOOL   fSeparateWow;
extern HANDLE MainThread;
extern ULONG  DosSessionId;
extern ULONG  WowSessionId;

VOID TerminateVDM(VOID);
void host_applClose(void);
extern VOID enable_stream_io(VOID);

extern BOOL   StreamIoSwitchOn;

extern HANDLE hMainThreadSuspended;
extern VOID CheckScreenSwitchRequest(HANDLE handle);
extern VOID EnableScreenSwitch(BOOLEAN OnlyFullScreenMode, HANDLE handle);
#define DisableScreenSwitch(handle)    {    \
        ResetEvent(handle);                 \
        CheckScreenSwitchRequest(handle);   \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_mon.h ===
/*
** Defs and decs for SoftPC stuff included by X86 Monitor.
** Tim Nov 92.
*/

typedef unsigned char UTINY;   //from host insignia.h
typedef UTINY half_word;       //from base xt.h
typedef UTINY byte;            //from base xt.h

typedef unsigned short USHORT; //from host insignia.h
typedef USHORT word;           //from base xt.h

typedef unsigned long IU32;    //from host insignia.h
typedef IU32 double_word;      //from base xt.h

typedef int BOOL;              //from host insignia.h
typedef BOOL boolean;          //from base xt.h

#include "nt_eoi.h"

//from base\cpu.h
typedef enum {  CPU_HW_RESET,   
                CPU_TIMER_TICK, 
                CPU_SW_INT,     
                CPU_HW_INT,     
                CPU_YODA_INT,   
                CPU_SIGIO_EVENT 
} CPU_INT_TYPE;                 

//from base xt.h
typedef double_word	sys_addr;	/* System Address Space */
typedef word		io_addr;	/* I/O Address Space 	*/
typedef byte		*host_addr;	/* Host Address Space 	*/

//from base ios.h
extern void     inb  (io_addr io_address, half_word * value);
extern void     outb (io_addr io_address, half_word value);  
extern void     inw  (io_addr io_address, word * value);  
extern void     outw (io_addr io_address, word value);

extern void outsb(io_addr io_address, half_word * valarray, word count);
extern void insb(io_addr io_address, half_word * valarray, word count);
extern void outsw(io_addr io_address, word * valarray, word count);
extern void insw(io_addr io_address, word * valarray, word count);



//from base timer.h
extern void host_timer_event();




// from base yoda.h
#ifdef PROD
#define check_I();
#else
extern void check_I();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_sb.h ===
#include <mmsystem.h>
//
// Definitions for MM api entry points. The functions will be linked
// dynamically to avoid bringing winmm.dll in before wow32.
// BUGBUG - shielint.  Should be moved to H file
//

typedef MMRESULT (WINAPI* SETVOLUMEPROC)(HWAVEOUT, DWORD);
typedef MMRESULT (WINAPI* GETVOLUMEPROC)(HWAVEOUT, LPDWORD);
typedef UINT     (WINAPI* GETNUMDEVSPROC)(VOID);
typedef MMRESULT (WINAPI* GETDEVCAPSPROC)(UINT, LPWAVEOUTCAPSA, UINT);
typedef MMRESULT (WINAPI* OPENPROC)(LPHWAVEOUT, UINT, LPCWAVEFORMATEX, DWORD, DWORD, DWORD);
typedef MMRESULT (WINAPI* PAUSEPROC)(HWAVEOUT);
typedef MMRESULT (WINAPI* RESTARTPROC)(HWAVEOUT);
typedef MMRESULT (WINAPI* RESETPROC)(HWAVEOUT);
typedef MMRESULT (WINAPI* CLOSEPROC)(HWAVEOUT);
typedef MMRESULT (WINAPI* GETPOSITIONPROC)(HWAVEOUT, LPMMTIME, UINT);
typedef MMRESULT (WINAPI* WRITEPROC)(HWAVEOUT, LPWAVEHDR, UINT);
typedef MMRESULT (WINAPI* PREPAREHEADERPROC)(HWAVEOUT, LPWAVEHDR, UINT);
typedef MMRESULT (WINAPI* UNPREPAREHEADERPROC)(HWAVEOUT, LPWAVEHDR, UINT);

typedef MMRESULT (WINAPI* SETMIDIVOLUMEPROC)(HMIDIOUT, DWORD);
typedef MMRESULT (WINAPI* GETMIDIVOLUMEPROC)(HMIDIOUT, LPDWORD);
typedef UINT     (WINAPI* MIDIGETNUMDEVSPROC)(VOID);
typedef MMRESULT (WINAPI* MIDIGETDEVCAPSPROC)(UINT, LPMIDIOUTCAPSA, UINT);
typedef MMRESULT (WINAPI* MIDIOPENPROC)(LPHMIDIOUT, UINT, DWORD, DWORD, DWORD);
typedef MMRESULT (WINAPI* MIDIRESETPROC)(HMIDIOUT);
typedef MMRESULT (WINAPI* MIDICLOSEPROC)(HMIDIOUT);
typedef MMRESULT (WINAPI* MIDILONGMSGPROC)(HMIDIOUT, LPMIDIHDR, UINT);
typedef MMRESULT (WINAPI* MIDISHORTMSGPROC)(HMIDIOUT, DWORD);
typedef MMRESULT (WINAPI* MIDIPREPAREHEADERPROC)(HMIDIOUT, LPMIDIHDR, UINT);
typedef MMRESULT (WINAPI* MIDIUNPREPAREHEADERPROC)(HMIDIOUT, LPMIDIHDR, UINT);

extern SETVOLUMEPROC            SetVolumeProc;
extern GETVOLUMEPROC            GetVolumeProc;
extern GETNUMDEVSPROC           GetNumDevsProc;
extern GETDEVCAPSPROC           GetDevCapsProc;
extern OPENPROC                 OpenProc;
extern PAUSEPROC                PauseProc;
extern RESTARTPROC              RestartProc;
extern RESETPROC                ResetProc;
extern CLOSEPROC                CloseProc;
extern GETPOSITIONPROC          GetPositionProc;
extern WRITEPROC                WriteProc;
extern PREPAREHEADERPROC        PrepareHeaderProc;
extern UNPREPAREHEADERPROC      UnprepareHeaderProc;

extern SETMIDIVOLUMEPROC        SetMidiVolumeProc;
extern GETMIDIVOLUMEPROC        GetMidiVolumeProc;
extern MIDIGETNUMDEVSPROC       MidiGetNumDevsProc;
extern MIDIGETDEVCAPSPROC       MidiGetDevCapsProc;
extern MIDIOPENPROC             MidiOpenProc;
extern MIDIRESETPROC            MidiResetProc;
extern MIDICLOSEPROC            MidiCloseProc;
extern MIDILONGMSGPROC          MidiLongMsgProc;
extern MIDISHORTMSGPROC         MidiShortMsgProc;
extern MIDIPREPAREHEADERPROC    MidiPrepareHeaderProc;
extern MIDIUNPREPAREHEADERPROC  MidiUnprepareHeaderProc;

extern BOOL     bHighSpeedMode;
extern HMIDIOUT HMidiOut;
extern HMIDIOUT HFM;
extern HWAVEOUT HWaveOut;
extern BOOL     bExitMidiThread;
extern WORD     MpuBasePort;
extern WORD     BasePort;
extern BOOL     bDevicesActive;

#define DisconnectPorts(First, Last) {                  \
            WORD i;                                      \
            for (i = First; i <= Last; i++) {           \
                io_disconnect_port(i, SNDBLST_ADAPTER); \
            }                                           \
        }

//
// Function Prototypes
//


//
// DSP prototypes
//

VOID
SbCloseDevices(
    VOID
    );

VOID
DspReadData(
    BYTE * data
    );

VOID
DspReadStatus(
    BYTE * data
    );

VOID
DspResetWrite(
    BYTE data
    );

VOID
DspWrite(
    BYTE data
    );

VOID
WriteCommandByte(
    BYTE command
    );

VOID
ResetDSP(
    VOID
    );

VOID
TableMunger(
    BYTE data
    );

DWORD
GetSamplingRate(
    VOID
    );

VOID
GenerateInterrupt(
    DWORD
    );

VOID
SetSpeaker(
    BOOL
    );

VOID
PauseWaveDevice(
    VOID
    );

VOID
RestartWaveDevice(
    VOID
    );

BOOL
FindWaveDevice(
    VOID
    );

BOOL
PrepareWaveInitialization(
    VOID
    );

VOID
CleanUpWave(
    VOID
    );

VOID
SetWaveOutVolume(
    DWORD Volume
    );

//
// FM Synth prototypes
//

VOID
ResetFM(
    VOID
    );

BOOL
OpenFMDevice(
    VOID
    );

VOID
CloseFMDevice(
    VOID
    );

VOID
FMStatusRead(
    BYTE *data
    );
VOID
FMDataWrite(
    BYTE data
    );

VOID
FMRegisterSelect(
    BYTE data
    );

//
// Mixer prototypes
//

void ResetMixer(void);
VOID
MixerDataRead(
    BYTE *pData
    );

VOID
MixerDataWrite(
    BYTE data
    );

VOID
MixerAddrWrite(
    BYTE data
    );

VOID
MixerSetMidiVolume(
    BYTE level
    );

VOID
MixerSetMasterVolume(
    BYTE level
    );

VOID
MixerSetVoiceVolume(
    BYTE level
    );

//
// MIDI prototypes
//

BOOL
InitializeMidi(
    VOID
    );

VOID
BufferMidi(
    BYTE data
    );

VOID
CloseMidiDevice(
    VOID
    );

BOOL
OpenMidiDevice(
    HANDLE CallbackEvent
    );

VOID
StopMidiThread(
    BOOL wait
    );

VOID
DetachMidi(
    VOID
    );

VOID
ResetMidiDevice(
    VOID
    );

VOID CALLBACK
MidiBlockPlayedCallback (
    HMIDIOUT HMidiOut,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

VOID
SetMidiOutVolume(
    DWORD Volume
    );

/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

void DbgOut(LPSTR lpszFormat, ...);

/*****************************************************************************
*
*    Debugging
*    Levels:
*    bit 0 - port usage
*    bit 1 - errors only
*    bit 2 - significant events
*    bit 3 - regular events
*    bit 4 - heaps o' information
*
*****************************************************************************/

#if DBG
    extern int DebugLevel;
    #define dprintf( _x_ )                         DbgOut _x_
    #define dprintf0( _x_ ) if (DebugLevel & 0x1)  DbgOut _x_
    #define dprintf1( _x_ ) if (DebugLevel & 0x2)  DbgOut _x_
    #define dprintf2( _x_ ) if (DebugLevel & 0x4)  DbgOut _x_
    #define dprintf3( _x_ ) if (DebugLevel & 0x8)  DbgOut _x_
    #define dprintf4( _x_ ) if (DebugLevel & 0x10) DbgOut _x_

#else

    #define dprintf(x)
    #define dprintf0(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif // DBG

//
// Temp stuff
//

#define REPORT_SB_MODE 1

#if REPORT_SB_MODE

#define DISPLAY_SINGLE     1
#define DISPLAY_HS_SINGLE  2
#define DISPLAY_AUTO       4
#define DISPLAY_HS_AUTO    8
#define DISPLAY_MIDI       16
#define DISPLAY_MIXER      32
#define DISPLAY_ADLIB      64
extern USHORT  DisplayFlags;
extern void DisplaySbMode(USHORT Mode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_pif.h ===
/*================================================================

Header file containing data structures and defines required by the
PIF file decoder.

Andrew Watson 31/1/92.

================================================================*/

#define LASTHEADER    0xffff   /* last extended header marker */


/*================================================================
Structure used to hold the data that CONFIG will need from the PIF
file. This is gleaned from both the main data block and from the
file extensions for Windows 286 and 386.
================================================================*/

typedef struct
   {
   char *WinTitle;          /* caption text(Max. 30 chars) + NULL */
   char *CmdLine;        /* command line (max 63 hars) + NULL */
   char *StartDir;          /* program file name (max 63 chars + NULL */
   char *StartFile;
   WORD fullorwin;
   WORD graphicsortext;
   WORD memreq;
   WORD memdes;
   WORD emsreq;
   WORD emsdes;
   WORD xmsreq;
   WORD xmsdes;
   char menuclose;
   char reskey;
   WORD ShortMod;
   WORD ShortScan;
   char idledetect;
   char CloseOnExit;
   char AppHasPIFFile;
   char IgnoreTitleInPIF;
   char IgnoreStartDirInPIF;
   char IgnoreShortKeyInPIF;
   char IgnoreCmdLineInPIF;
   char IgnoreConfigAutoexec;
   char SubSysId;
#ifdef JAPAN
   char IgnoreWIN31JExtention;
#endif // JAPAN
   } PIF_DATA;

/*================================================================
Default values for the PIF parameters that are used by config.
These values are used if a pif (either with the same base name as
the application or _default.pif) cannot be found.
NB. the following values were read from the Windows 3.1 Pif Editor
with no file open to edit; thus taken as default.
================================================================*/


/* first, the standard PIF stuff */

#define TEXTMODE             0
#define LOWGFXMODE           1
#define HIGHGFXMODE          2
#define NOMODE               3
#define GRAPHICSMODE         4      /* generic case for flag assignment */ 

#define PF_FULLSCREEN        1
#define PF_WINDOWED          0 

#define BACKGROUND           0
#define EXCLUSIVE            1
#define UNDEFINED            2

#define CLOSEYES             0
#define CLOSENO              1

#define NOSHORTCUTKEY        0
#define ALTTAB               1
#define ALTESC               (1 << 1)
#define CTRLESC              (1 << 2)
#define PRTSC                (1 << 3)
#define ALTPRTSC             (1 << 4)
#define ALTSPACE             (1 << 5)
#define ALTENTER             (1 << 6)

#define DEFAULTMEMREQ        128      /* kilobytes */ 
#define DEFAULTMEMDES        640      /* kilobytes */ 
#define DEFAULTEMSREQ        0        /* kilobytes */ 
#define DEFAULTEMSLMT        0        /* kilobytes */
#define DEFAULTXMSREQ        0        /* kilobytes */ 
#ifdef NTVDM
/* if we are unable to read any pif file,
   then we should let the system to decide the size(either
   from resgistry or based on the physical memory size, see xmsinit
   for detail. We use -1 here to indicate that the system can give
   if the maximum size if possible
*/
#define DEFAULTXMSLMT        0xffff
#else
#define DEFAULTXMSLMT        0         /* kilobytes ; ntvdm will choose it
                intelligently. sudeepb 26-Sep-1992*/
#endif

#define DEFAULTVIDMEM        TEXTMODE
#define DEFAULTDISPUS        PF_WINDOWED
#define DEFAULTEXEC          UNDEFINED

#define DEFAULTEXITWIN       CLOSEYES

/* second, the advanced options. */

#define DEFAULTBKGRND        50
#define DEFAULTFRGRND        100
#define DEFAULTIDLETM        TRUE     /* detect idle time */

#define DEFAULTEMSLOCK       FALSE    /* EMS memory locked */
#define DEFAULTXMSLOCK       FALSE    /* XMS memory locked */
#define DEFAULTHMAUSE        TRUE     /* uses high memory area */
#define DEFAULTAPPMEMLOCK    FALSE    /* lock application memory */ 

#define DEFAULTMONITORPORT   NOMODE   /* display options */
#define DEFAULTEMTEXTMODE    TRUE     /* emulate text mode */
#define DEFAULTRETAINVIDM    FALSE    /* retain video memory */

#define DEFAULTFASTPASTE     TRUE     /* allow fast paste */
#define DEFAULTACTIVECLOSE   FALSE    /* allow close when active */

#define DEFAULTSHTCUTKEYS    NOSHORTCUTKEY

extern DWORD dwWNTPifFlags;

#define STDHDRSIG     "MICROSOFT PIFEX"
#define W386HDRSIG    "WINDOWS 386 3.0"
#define W286HDRSIG    "WINDOWS 286 3.0"
#define WNTEXTSIG     "WINDOWS NT  3.1"

// equates for dwWNTFlags
#define NTPIF_SUBSYSMASK        0x0000000F      // sub system type mask
#define SUBSYS_DEFAULT          0
#define SUBSYS_DOS              1
#define SUBSYS_WOW              2
#define SUBSYS_OS2              3
#define COMPAT_TIMERTIC         0x10


void DisablePIFKeySetup(void);
void EnablePIFKeySetup(void);

VOID GetPIFConfigFiles(BOOL bConfig, char *pchFileName, BOOL bFreMem);
BOOL GetPIFData(PIF_DATA * pd, char *PifName);

extern BOOL IdleDisabledFromPIF;
extern DWORD dwWNTPifFlags;
extern UCHAR WNTPifFgPr;
extern UCHAR WNTPifBgPr;
extern PIF_DATA pfdata;
extern BOOL bPifFastPaste;
#ifdef JAPAN

#pragma pack (1)
typedef struct
    {
    unsigned short fSBCSMode;     // if 1 then then run the app in SBCS mode
    } PIFAXEXT;

#pragma pack()

#define AXEXTHDRSIG  "AX WIN 3.0 PRIV"
#define PIFAXEXTSIZE sizeof(PIFAXEXT)
#endif // JAPAN
#if defined(NEC_98) 
#ifndef _PIFNT_NEC98_
#define _PIFNT_NEC98_
/*****************************************************************************/
/*   Windows 3.1 PIF file extension for PC-9800                              */
/*****************************************************************************/
/*    For Header signature.    */

#define W30NECHDRSIG  "WINDOWS NEC 3.0"

/* Real Extended Structire for PC-9800 */

#ifndef RC_INVOKED
#pragma pack (1)                          
#endif
typedef struct {
    BYTE    cPlaneFlags;    
    BYTE    cNecFlags;    // +1
    BYTE    cVCDFlags;    // +2
    BYTE    EnhExtBit;    // +3
    BYTE    Extcont;      // +4 byte
    BYTE    cReserved[27];// reserved
    } PIFNECEXT;          // all = 32bytes
#ifndef RC_INVOKED
#pragma pack()                            
#endif
#define PIFNECEXTSIZE sizeof(PIFNECEXT)
/*-----------------------------------------------------------------------------
  cPlaneFlags (8 bit)

     0 0 0 0 X X X X
     | | | | | | | +-- Plane 0{On/Off}
     | | | | | | +---- Plane 1{On/Off}
     | | | | | +------ Plane 2{On/Off}
     | | | | +-------- Plane 3{On/Off}
     +-+-+-+---------- Reserved for 256 color

-----------------------------------------------------------------------------*/

#define P0MASK       0x01        /* plane 1 <ON>   */
#define NOTP0MASK    0xfe        /* plane 1 <OFF>  */

#define P1MASK        0x02        /* plane 2 <ON>   */
#define NOTP1MASK     0xfd        /* plane 2 <OFF>  */

#define P2MASK        0x04        /* plane 3 <ON>   */
#define NOTP2MASK     0xfb        /* plane 3 <OFF>  */

#define P3MASK        0x08        /* plane 4 <ON>   */
#define NOTP3MASK     0xf7        /* plane 4 <OFF>  */

/*-----------------------------------------------------------------------------
    cNECFLAGS (8 bit)
 
     X 0 0 X X X X X
     | | | | | | | +-- CRTC
     | | | | | | +---- 
     | | | | | +------ N/H Dynamic1 (N?H:0 H/N:1)
     | | | | +-------- N/H Dynamic2 (H:0 N:1)
     | | | +---------- GRAPH in window
     | +-+------------ Reserved
     +---------------- EMM large page frame
-----------------------------------------------------------------------------*/

#define CRTCMASK        0x01    /* CRTC <ON>    */
#define NOTCRTCMASK     0xfe    /* CRTC <OFF>    */

#define EXCHGMASK       0x02    /* Screen Exchange <GRPH ON>  */
#define NOTEXCHGMASK    0xfd    /* Screen Exchange <GRPH OFF> */

#define EMMLGPGMASK     0x80    /* EMM Large Page Frame <ON>  */
#define NOTEMMLGPGMASK  0x7f    /* EMM Large Page Frame <OFF> */

#define NH1MASK         0x04    /* N/H Dynamic1  <N/H> (UpdateScreen)*/
#define NOTNH1MASK      0xfb    /* N/H Dynamic1  <N?H> (UpdateScreen)*/

#define NH2MASK         0x08    /* N/H Dynamic2  < N > (UpdateScreen)*/
#define NOTNH2MASK      0xf7    /* N/H Dynamic2  < H > (UpdateScreen)*/

#define WINGRPMASK      0x10    /* door mado 1992 9 14 */
#define NOTWINGRPMASK   0xef    /*                    */

/*-----------------------------------------------------------------------------
  cVCDFlags (8 bit)

     0 0 0 0 X X X X
     | | | | | | | +-- 0/1 RS / CS
     | | | | | | +---- 0/1 Xon / Xoff
     | | | | | +------ 0/1 ER/DR
     | | | | +-------- Port(Reserved)
     | | | +---------- Port(Reserved)
     +-+-+-+---------- Reserved

------------------------------------------------------------------------------*/
#define VCDRSCSMASK         0x001       /* 0/1 RS/CS   handshake */
#define NOTVCDRSCSMASK      0xfe

#define VCDXONOFFMASK       0x02        /* 0/1 Xon/off handshake */
#define NOTVCDXONOFFMASK    0xfd

#define VCDERDRMASK         0x04        /* 0/1 ER/DR   handshake */
#define NOTVCDERDRMASK      0xfb

/*    Now Only Reserved    */
                                        /* port asign */
#define VCDPORTASMASK       0x18        /* 00:no change */
#define NOTVCDPORTASMASK    0xe7        /* 01:port1->port2 */
                                        /* 10:port1->port3 */
                                        /* 11:reserved */

/*-----------------------------------------------------------------------------
  EnhExtBit (8 bit)

     X 0 0 X X X X X
     | | | | | | | +-- Mode F/F (Yes:0 No:1)
     | | | | | | +---- Display/Draw (Yes:0 No:1)
     | | | | | +------ ColorPallett (Yes:0 No:1)
     | | | | +-------- GDC (Yes:0 No:1)
     | | | +---------- Font (Yes:0 No:1)
     | +-+-+---------- Reserved
     +---------------- All is set/not(Set:1 No:0)

------------------------------------------------------------------------------*/
#define MODEFFMASK           0x01
#define NOTMODEFFMASK        0xfe

#define DISPLAYDRAWMASK      0x02        /* 0/1 Xon/off handshake */
#define NOTDISPLAYDRAWMASK   0xfd

#define COLORPALLETTMASK     0x04        /* 0/1 ER/DR   handshake */
#define NOTCOLORPALLETTMASK  0xfb

#define GDCMASK              0x08
#define NOTGDCMASK           0xf7

#define FONTMASK            0x10
#define NOTFONTMASK         0xef

#define VDDMASK              0x80
#define NOTVDDMASK           0x7f

/*-----------------------------------------------------------------------------
  Extcont (8 bit)

    0 0 0 0 X X X X
    | | | | | | | +-- Mode F/F (8Color:0 16Color:1)
    | | | | | | +---- Reserved
    | | | | | +------ GDC TEXT (ON:1 OFF:0)
    | | | | +-------- GDC GRPH (ON:1 OFF:0)
    +-+-+-+---------- Reserved

------------------------------------------------------------------------------*/
#define    MODEFF16            0x01
#define    MODEFF8             0xfe

#define    GDCTEXTMASK          0x04
#define    NOTGDCTEXTMASK       0xfb

#define GDCGRPHMASK           0x08
#define NOTGDCGRPHMASK        0xf7

/*-----------------------------------------------------------------------------
    Reserved(8 bit)
 
     0 0 0 0 0 0 0 0
     | | | | | | | |
     +-+-+-+-+-+-+-+-- Reserved

-----------------------------------------------------------------------------*/
/*    reserved    */

/*****************************************************************************/
/*  Windows NT 3.1 PIF file extension for PC-9800                            */
/*****************************************************************************/
/*    For Header signature.  */

#define WNTNECHDRSIG        "WINDOWS NT31NEC"

/* Real Extended Structire for PC-9800 */

#ifndef RC_INVOKED
#pragma pack (1)                          
#endif
typedef struct {
    BYTE    cFontFlags;
    BYTE    cReserved[31];    // reserved
    } PIFNTNECEXT;    // all = 32bytes
#ifndef RC_INVOKED
#pragma pack()                            
#endif
#define PIFNTNECEXTSIZE sizeof(PIFNTNECEXT)
/*-----------------------------------------------------------------------------
    cFontFlags (8 bit)
 
     0 0 0 0 0 0 0 X
     | | | | | | | +-- font (default: FALSE)
     +-+-+-+-+-+-+---- Reserved
-----------------------------------------------------------------------------*/

#define NECFONTMASK      0x01    /* NEC98 Font <ON>    */
#define NONECFONTMASK    0xfe    /* NEC98 Font <OFF>   */

/*-----------------------------------------------------------------------------
    Reserved(8 bit)[31]
 
     0 0 0 0 0 0 0 0
     | | | | | | | |
     +-+-+-+-+-+-+-+-- Reserved

-----------------------------------------------------------------------------*/
/*    reserved    */

#endif // _PIFNT_NEC98_
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_smenu.h ===
/*================================================================

Header file for modules working with the system menu interrogation
system.

Andrew Watson 6/2/92

================================================================*/

#define IDM_SETTINGS      400
#define IDM_DOSPROMPT     229

#define IDD_DGBOX         100
#define IDD_FULLSCREEN    101
#define IDD_TERMINATE     102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_thred.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Thread control structures/ Macros / variables
 *
 * Description	: 
 *
 *		Contains structures/macros/variables used to control and
 *		log threads
 *
 * Author	: Dave Barteltt
 *
 * Notes	:
 *
 */


/*:::::::::::::::::::::::::::::::::::::::::::: Thread information structure */

typedef struct {

    HANDLE Handle;	    /* Threads object handle */
    DWORD ID;		    /* Threads ID */

} THREAD_INFO;

/*::::::::::::::::::::::::::::::::::::::::::: Threads containment structure */

typedef struct {

    THREAD_INFO Main;		    /* Main() thread */
    THREAD_INFO HeartBeat;	    /* Heart beat thread */
    THREAD_INFO EventMgr;	    /* Event manager thread */
    THREAD_INFO HddnWnd;	    /* Hidden window thread */
    THREAD_INFO Com1;		    /* Communication channel one */
    THREAD_INFO Com2;		    /* Communication channel two */
    THREAD_INFO Com3;		    /* Communication channel three */
    THREAD_INFO Com4;		    /* Communication channel four */

} THREAD_DATA;

IMPORT THREAD_DATA ThreadInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_vddp.h ===
/*++ BUILD Version: 0001
 *
 *  MVDM v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  nt_vddp.h
 *  private defines for Installable VDDs
 *
 *  History:
 *  27-Aug-1992 Sudeep Bharati (sudeepb)
 *  Created.
--*/


#define MAX_CLASS_LEN 32

typedef ULONG (*VDDPROC)();


extern VOID DispatchPageFault (ULONG,ULONG);

typedef struct _MEM_HOOK_DATA {
    DWORD   StartAddr;
    DWORD   Count;
    HANDLE  hvdd;
    PVDD_MEMORY_HANDLER MemHandler;
    struct _MEM_HOOK_DATA *next;
} MEM_HOOK_DATA, *PMEM_HOOK_DATA;

// These are the ports which we may handle directly in kernel.
// If a VDD hooks such a port we will makw sure that kernel
// does'nt handle it.

#define LPT1_PORT_STATUS        0x3bd
#define LPT2_PORT_STATUS        0x379
#define LPT3_PORT_STATUS        0x279
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_timer.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title		: nt_timer.h
 *
 * Description	: Structure definitions for the Sun4 timer code.
 *
 * Author	: John Shanly
 *
 * Notes	: None
 *
 */

/*
 * SccsID[]="@(#)sun4_timer.h	1.1 8/2/90 Copyright Insignia Solutions Ltd.";
 */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */
void TimerInit(void);
VOID SuspendTimerThread(VOID);
VOID ResumeTimerThread(VOID);
void TerminateHeartBeat(void);
LONG
VdmUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\winsigni.h ===
#ifndef _INSIGNIA_H
#define _INSIGNIA_H
/*
 *	Name:		insignia.h
 *	Derived from:	HP 2.0 insignia.h
 *	Author:		Philippa Watson (amended Dave Bartlett)
 *	Created on:	23 January 1991
 *	SccsID:		@(#)insignia.h	1.2 03/11/91
 *	Purpose:	This file contains the definition of the Insignia
 *			standard types and constants for the NT/WIN32
 *			SoftPC.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 */

/*
 * Insignia Standard Types
 *
 * Note that the EXTENDED type is the same as the DOUBLE type for the
 * HP because there is no difference between the double and long double
 * fundamental types, it's an ANSI compiler feature.
 */

#define	VOID		void		/* Nothing */
typedef	char		TINY;		/* 8-bit signed integer */

typedef	unsigned char	UTINY;		/* 8-bit unsigned integer */

#ifdef ANSI
typedef	long double	EXTENDED;	/* >64-bit floating point */
#else
typedef double		EXTENDED;       /* >64-bit floating point */
#endif

/*
 * Insignia Standard Constants
 */

#ifndef FALSE
#define	FALSE		((BOOL) 0)	/* Boolean falsehood value */
#define	TRUE		(!FALSE)	/* Boolean truth value */
#endif

#ifndef NULL
#define	NULL		(0L)	/* Null pointer value */
#endif

#ifndef BOOL
#define BOOL UINT
#endif


/*
 * Insignia Standard Storage Classes
 */

#define GLOBAL			/* Defined as nothing */
#define LOCAL	static		/* Local to the source file */
#define SAVED	static		/* For local static variables */
#define IMPORT	extern		/* To refer from another file */
#define FORWARD			/* to refer from the same file */
#define FAST	register	/* High-speed Storage */

#endif /* _INSIGNIA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\nt_uis.h ===
/*

Filename:   nt_uis.h
Purpose:    Contains Manifests, Macros, Structures used to drive the Win32
	    interface.

Author:     D.A.Bartlett

Revision History: 

Don't use any insignia.h conventions in this file - used in non SoftPC code.
*/

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::: Global variables */

extern HANDLE InstHandle;  /* Holds currently run processes instance handle */

/*:::::::::::::::::::::::::::::::::::::::::::::::: Host colour palette size */

#define PALETTESIZE	256    /* Number of entries in the system palette */

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Function protocols */

int DisplayErrorTerm(int ErrorNo, DWORD OSErrno, char *Filename, int Lineno);
BYTE KeyMsgToKeyCode(PKEY_EVENT_RECORD KeyEvent);
BOOL BiosKeyToInputRecord(PKEY_EVENT_RECORD pKeyEvent);
extern WORD aNumPadSCode[];


void RegisterDisplayCursor(HCURSOR newC);
int init_host_uis(void);


/*::::::::::::::::::::::::::::::: Control ID's used by SoftPC's error panel */

/*
 Manifests, Macros, Structures used to drive the Win32 interface.
 */

/*::::::::::::::::::::::::::::::: Control ID's used by SoftPC's error panel */

#define IDB_QUIT        (100)   /* Terminate button ID */
#define IDB_RETRY       (101)   /* Retry button ID */
#define IDB_CONTINUE	(102)	/* Continue button ID */
#define IDE_ICON        (103)   /* Icon Id */
#define IDE_ERRORMSG    (104)   /* Text control to transfer error message to*/
#define IDE_PROMPT      (105)   /* Prompt instruction */
#define IDE_APPTITLE    (106)   /* Text control to transfer app title to*/
#define IDE_EDIT        (107)   /* EditControl */
#define IDB_OKEDIT      (108)   /* OK - EditControl */

/*:::::::::::::::::::::::::::::: Manifests used to control heart beat timer */

#define TID_HEARTBEAT	(100)	/* Heart beat ID number */
#define TM_DELAY	(55)	/* Milliseconds between heart beats */

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::: Global variables */

extern HANDLE GHModule;	  /* Holds currently run processes module handle */

/*::::::::::::::::::::::::::::::::::::::::: Manifests used to ID menu items */

#define	IDM_SETTINGS	(200)		/* Settings */

/*:::::::::::::::::::::::::::::::::::::::::::::: String resource ID numbers */

#define IDS_SETTINGS	(100)		/* Name of option in system menu used

/*:::::::::::::::::::::::::::::::::::::::::::::::: Host colour palette size */

#define PALETTESIZE	256    /* Number of entries in the system palette */

/*:::::::::::::::::::::::::::::: String Table Entries :::::::::::::*/

/* entries from 0 - 299 are reserved for base errors. Seee host\inc\error.h */

/* entries from 301 to 332 are reserved for unsupported services */
#define D_A_MESS	300	// Direct Access Message
#define D_A_FLOPPY	301	// Direct Access to a floppy device
#define D_A_HARDDISK	302	// Direct Access to a hard disk
#define D_A_DRIVER	303	// Load 16 bit DOS device driver
////#define D_A_OLDPIF      304     // Obsolete PIF format
#define D_A_ILLBOP	305	// Illegal Bop
#define D_A_NOLIM       306     // to allocate Expanded Memory
#define D_A_MOUSEDRVR   307     // third party mouse drivers

/* Startup and Error reporting related strings */
#define ED_WOWPROMPT    333     // special prompt for wow
#define ED_WOWTITLE     334     // title message for win16 subsystem
#define ED_DOSTITLE     335     // title message for dos subsystem
#ifdef DBCS
#define ED_UNSUPPORT_CP	345
#endif // DBCS

#define ED_BADSYSFILE   336
#define ED_INITMEMERR   337
#define ED_INITTMPFILE  338
#define ED_INITFSCREEN  339
#define ED_MEMORYVDD    340
#define ED_REGVDD       341
#define ED_LOADVDD      342
#define ED_LOCKDRIVE    343
#define ED_DRIVENUM     344
#define ED_INITGRAPHICS 345


/* VDM UIS related strings */
#define SM_HIDE_MOUSE      500      /* Menu 'Hide Mouse Pointer' */
#define SM_DISPLAY_MOUSE   501      /* Menu 'Display Mouse Pointer' */
#define IDS_BURRRR         502      /* Frozen graphics window '-FROZEN' */

#define EXIT_NO_CLOSE      503      /* Console window title - Inactive */

#ifdef DBCS	    /* this should go to US build also */
#define IDS_PROMPT	   504	    /* command prompt for command.com title */
#endif // DBCS

#define ED_FORMATSTR0       505
#define ED_FORMATSTR1       506
#define ED_FORMATSTR2       507
#define ED_FORMATSTR3       508
/* entries from 1000+ are reserved for host errors. See host\inc\host_rrr.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\link\nt_uis.h ===
/*

Filename:   nt_uis.h
Purpose:    Contains Manifests, Macros, Structures used to drive the Win32
	    interface.

Author:     D.A.Bartlett

Revision Histroy:

*/

/*::::::::::::::::::::::::::::::: Control ID's used by SoftPC's error panel */

#define IDB_QUIT	(100)	/* Quit button ID */
#define IDB_RESET	(101)	/* Reset button ID */
#define IDB_CONTINUE	(102)	/* Continue button ID */
#define IDB_SETUP	(103)	/* Setup button ID */

#define IDE_ERRORMSG    (104)   /* Text control to transfer error message to*/
#define IDE_EXTRAMSG    (105)   /* Extra error message data */
#define IDE_APPTITLE    (106)   /* Text control to transfer app title to*/

/*:::::::::::::::::::::::::::::: Manifests used to control heart beat timer */

#define TID_HEARTBEAT	(100)	/* Heart beat ID number */
#define TM_DELAY	(55)	/* Milliseconds between heart beats */

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::: Global variables */

extern HANDLE GHModule;	  /* Holds currently run processes module handle */

/*::::::::::::::::::::::::::::::::::::::::: Manifests used to ID menu items */

#define	IDM_SETTINGS	(200)		/* Settings */

/*:::::::::::::::::::::::::::::::::::::::::::::: String resource ID numbers */

#define IDS_SETTINGS	(100)		/* Name of option in system menu used

/*:::::::::::::::::::::::::::::::::::::::::::::::: Host colour palette size */

#define PALETTESIZE	256    /* Number of entries in the system palette */

/*:::::::::::::::::::::::::::::: String Table Entries :::::::::::::*/
#define D_A_MESS	300	// Direct Access Message
#define D_A_FLOPPY	301	// Direct Access to a floppy device
#define D_A_HARDDISK	302	// Direct Access to a hard disk
#define D_A_DRIVER	303	// Load 16 bit DOS device driver
#define D_A_OLDPIF	304	// Obsolete PIF format
#define D_A_ILLBOP	305	// Illegal Bop
#define D_A_NOLIM       306     // to allocate Expanded Memory
#define D_A_MOUSEDRVR   307     // third party mouse drivers

      // entries from 301 to 332 are reserved for unsupported services
#define ED_APPTITLE     333     // Generic text for app title message
#define ED_WOWTITLE     334     // title message for win16 subsystem
#define ED_WOWAPP       335     // Win16 app name

#define ED_BADSYSFILE   336
#define ED_INITMEMERR   337
#define ED_INITTMPFILE  338
#define ED_DOSAPP       339
#define ED_MEMORYVDD    340
#define ED_REGVDD       341
#define ED_LOADVDD      342
#define ED_LOCKDRIVE    343
#define ED_WOWAPPTITLE  344     // Generic text for app title message (wow)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\inc\sim32.h ===
/*
 *      sim32.h -       Sim32 for Microsoft NT SoftPC include file.
 *
 *      Ade Brownlow
 *      Wed Jun 5 91
 *
 *      %W% %G% (c) Insignia Solutions 1991
 */

/* Microsoft Sas memory map extension */
typedef struct _IMEM
{
        struct _IMEM *Next;
        sys_addr StartAddress;
        sys_addr EndAddress;
        half_word Type;
} IMEMBLOCK, *PIMEMBLOCK;

/* structures for passing our registers about */
typedef union
{
        word x;
        struct
        {
                half_word l;
                half_word h;
        }       byte;
}       REG;

typedef struct _VDMREG
{
        /* registers */
        REG SS,SP;

}       VDMREG;

//
// Constants
//
#define MSW_PE              0x1


UCHAR *Sim32pGetVDMPointer(ULONG addr, UCHAR pm);
#define Sim32GetVDMPointer(Addr,Size,Mode) Sim32pGetVDMPointer(Addr,Mode)


#ifdef MONITOR
#include <monsim32.h>
#else
/********************************************************/
#ifdef ANSI
/* Sas/gmi Sim32 crossovers */
extern BOOL Sim32FlushVDMPointer (double_word, word, UTINY *, BOOL);
extern BOOL Sim32FreeVDMPointer (double_word, word, UTINY *, BOOL);
extern BOOL Sim32GetVDMMemory (double_word, word, UTINY *, BOOL);
extern BOOL Sim32SetVDMMemory (double_word, word, UTINY *, BOOL);

/* Sim32 cpu crossovers */
extern VDMREG *EnterIdle(void);
extern void LeaveIdle(void);

/* Sim32 cpu idle interrupt handler should only be called by the event manager */
extern void Sim32_cpu_stall(int);

/* Microsoft sas extensions */
extern IMEMBLOCK *sas_mem_map(void);
extern void sas_clear_map(void);

#else   /*ANSI*/
/* Sas/gmi Sim32 crossovers */
extern BOOL Sim32FlushVDMPointer ();
extern BOOL Sim32FreeVDMPointer ();
extern BOOL Sim32GetVDMMemory ();
extern BOOL Sim32SetVDMMemory ();

/* Sim32 cpu crossovers */
extern VDMREG *EnterIdle();
extern void LeaveIdle();

/* Sim32 cpu idle interrupt handler should only be called by the event manager */
extern void Sim32_cpu_stall();
#endif /* ANSI */

/* Microsoft sas extensions */
extern IMEMBLOCK *sas_mem_map ();
extern void sas_clear_map();

#endif /* MONITOR */

/* This flag is used to signal that the cpu has gone idle due to a call to EnterIdle */
extern BOOL cpu_flagged_idle;
extern sys_addr sim32_effective_addr(double_word, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\cpucstbs.c ===
#ifndef MONITOR
#ifdef A3CPU

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "ica.h"

void	npx_interrupt_line_waggled()
{
    ica_hw_interrupt(1, 5, 1);
}

// MIPS interface from CPU cacheflush request
void cacheflush(long base_addr, long length)
{
    // should check return, but what is correct action (Exit??) if failure?
    NtFlushInstructionCache(GetCurrentProcess(), (PVOID) base_addr, length);
}

void host_sigio_event()
{
}


#endif /* A3CPU */
#endif /* ! MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\config.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "windows.h"
#include "host_def.h"
#include "insignia.h"
/*
 *      config.c -      config for the NT port.
 *
 *      A happy chainsaw production by Ade Brownlow
 *
 *      This file is a hacked down (seriously) version of the 3.0 config.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "vdmapi.h"

#include "xt.h"
#include "error.h"
#include "config.h"
#include "sas.h"

#include "spcfile.h"
#include "umb.h"

#include "nt_pif.h"           /* PIF file interrogation data structure types */
#include "trace.h"

#include "conapi.h"
#include "nt_graph.h"
#include "gfi.h"
#include "floppy.h"

#include "ntddvdeo.h"
#include "host_rrr.h"
#include "nt_fulsc.h"
#include "nt_uis.h"
#include "nt_event.h"
#include "nt_reset.h"
#include "nt_fdisk.h"

#ifdef LIM
#include "emm.h"
#endif

#include "oemuni.h"

#include "pmvdm.h"

#ifdef HUNTER

#include "ckmalloc.h"
#include "debug.h"
#endif  //HUNTER

#ifdef ARCX86
#include "rom.h"
#endif /* ARCX86 */

/*================================================================
External references
================================================================*/
IMPORT SHORT gfi_floppy_active (UTINY hostID, BOOL active, CHAR *err);
IMPORT ULONG xmsMemorySize;

#ifdef HUNTER
/*
 * ===========================================================================
 * LOCAL DATA STRUCTURES
 * ===========================================================================
 */

typedef struct {
    ConfigValues *data;
    OptionDescription *def;
} ConfTabEntry;

/*
 * ===========================================================================
 * LOCAL FUNCTIONS
 * ===========================================================================
 */
VOID build_data_table(VOID);
VOID read_trapper_variables(VOID);
VOID convert_arg(CHAR *, OptionDescription *, ConfigValues *);
SHORT check_value(OptionDescription *, ConfigValues *);

/*
 * ===========================================================================
 * IMPORTED DATA STRUCTURES
 * ===========================================================================
 */

IMPORT OptionDescription host_defs[];   /* From hunt_conf.c */

/*
 * ===========================================================================
 * LOCAL DATA
 * ===========================================================================
 */

/* Dummy `common_defs' to pass to `host_config_init' */
LOCAL OptionDescription common_defs[] =
{
    { NULL, NULL, NULL, NULL, NULL, -1, C_RECORD_DELETE }
};
LOCAL ConfTabEntry *conf_tab = NULL;

#endif /* HUNTER */


PIF_DATA pfdata; /* data structure for holding all the relavent information
                    from the PIF file interrogated */
/* must be unsigned because they can be over 32768 */
USHORT PIFExtendMemSize = 0;     /* save value of extend mem from PIF file */
USHORT PIFEMSMemSize = 0;        /* save value of LIM mem from PIF file */
ULONG emsMemorySize;

#ifdef LIM
LIM_CONFIG_DATA     lim_config_data = {FALSE, 0, 0, 640 * 1024 / 16, FALSE};
#endif

APPKEY Shortkey;        /* PIF Shortcut key settings */
BYTE ReserveKey;        /* PIF Reserved key setting */
int  nShortKeys;
/*
 * ===========================================================================
 * GLOBAL DATA
 * ===========================================================================
 */
GLOBAL SHORT Npx_enabled = TRUE;        //For Jazz CPU support
GLOBAL BOOL IdleDisabledFromPIF = FALSE;//Flag showing idledetection wishes
GLOBAL UTINY number_of_floppy = 0;      // number of floppy drives
#ifdef ARCX86
GLOBAL BOOL UseEmulationROM = FALSE;   // For ARCx86 system
#endif /* ARCX86 */


/*================================================================
Local defines
================================================================*/

/* command definitions for read_profile_int */

#define PROFILE_LPT_AUTOCLOSE_DELAY 0
#define PROFILE_COM_AUTOCLOSE_DELAY 1
#define PROFILE_LPT_AUTOFLUSH_DELAY 2
#define PROFILE_COM_SYNCWRITE     3
#define PROFILE_COM_TXBUFFER_SIZE   4
#define PROFILE_MAX_INDEX      PROFILE_COM_TXBUFFER_SIZE + 1

#define EMBITSET        0x4

#define ONEMEG  0x100000L
#define ONEKB   0x400L

#define RESERVED_LENGTH  129
#define PMVDM_NTVDM_NAME    "ntvdm."
#define PMVDM_NTVDM_NAME_LENGTH 6       /* doesn't include NULL */

#define XMS_DEFAULT_MEMORY_SIZE 15*1024
#define EMS_DEFAULT_MEMORY_SIZE 4*1024
#define DPMI_DEFAULT_MEMORY_SIZE_FOR_DOS 8*1024
#define DPMI_DEFAULT_MEMORY_SIZE_FOR_WOW 16*1024
/* maximum ems memory size */
#define EMS_MAX_MEMORY_SIZE     32 * 1024   /* from EMM 4.0 specification */
#define XMS_MAX_MEMORY_SIZE     15 * 1024

int read_profile_int(int index);
void InitNtCpuInfo(void);

/*
 * ===========================================================================
 * GLOBAL FUNCTIONS
 * ===========================================================================
 */

VOID host_fdisk_active(UTINY hostID, BOOL active, CHAR *errString);
VOID host_fdisk_valid
        (UTINY hostID, ConfigValues *vals, NameTable *table, CHAR *errStr);

/* This routine is called when the DOS VDM runs its first binary. The
   parameter points to full path name of the dos app. This routine does'nt
   get called on subsequent dos apps in the same console window. It is not
   called on wow apps.
   Read PIF file and update VDM and console state from settings.
*/

VOID process_pif_exe (char *PifName)
{
#ifdef X86GFX
    COORD scrSize;
    DWORD flags;
#endif

    GetPIFData(&pfdata, PifName);

    // get app specific LIM memory size
    PIFEMSMemSize = pfdata.emsdes;

    // get app specific Extended memory size
    PIFExtendMemSize = pfdata.xmsdes;

        // store pif setting for AllowCloseOnExit
    if (pfdata.menuclose == 1) {
        CntrlHandlerState |= CNTRL_PIFALLOWCLOSE;
        }

    /* set app reserved key only if it has a new console;
       set app short cut keys only if it has a new console
       and there are not short cut keys come along with CreateProcess
       Reserved key must be set before set  console display mode
    */
    nShortKeys = 0;
    ReserveKey = 0;
    Shortkey.Modifier = 0;
    Shortkey.ScanCode = 0;

    if (DosSessionId || (pfdata.AppHasPIFFile && pfdata.SubSysId == SUBSYS_DOS))
    {
        ReserveKey = pfdata.reskey;
        if (!pfdata.IgnoreShortKeyInPIF) {
            Shortkey.Modifier = pfdata.ShortMod;
            Shortkey.ScanCode = pfdata.ShortScan;
            nShortKeys = (Shortkey.Modifier || Shortkey.ScanCode) ? 1 : 0;
        }
        if (ReserveKey || nShortKeys)
            SetConsoleKeyShortcuts(TRUE,
                                   ReserveKey,
                                   &Shortkey,
                                   nShortKeys
                                  );
    }

    if (pfdata.idledetect == 1)
        IdleDisabledFromPIF = FALSE;
    else
        IdleDisabledFromPIF = TRUE;
#ifdef X86GFX
    if (DosSessionId)    /* Only check screen state if we are in a NEW_CONSOLE */
    {
        /* Check to see if we are currently running windowed or full-screen. */
        if (!GetConsoleDisplayMode(&flags))
            ErrorExit();

        /* If PIF is telling us to switch to a different state, do so. */
        if (flags & CONSOLE_FULLSCREEN_HARDWARE)
        {
            if (pfdata.fullorwin == PF_WINDOWED)
            {
#ifndef PROD
                fprintf(trace_file, "Going windowed...\n");
#endif /* PROD */
                if (!SetConsoleDisplayMode(sc.OutputHandle,
                                           CONSOLE_WINDOWED_MODE,
                                           &scrSize))
                    ErrorExit();
            }
        }
        else /* WINDOWED */
        {
            if (pfdata.fullorwin == PF_FULLSCREEN)
            {
#ifndef PROD
                fprintf(trace_file, "Going fullscreen...\n");
#endif /* PROD */
                if (!SetConsoleDisplayMode(sc.OutputHandle,
                                           CONSOLE_FULLSCREEN_MODE,
                                           &scrSize))
                  {
                   if (GetLastError() == ERROR_INVALID_PARAMETER)  {
                       RcErrorDialogBox(ED_INITFSCREEN, NULL, NULL);
                       }
                   else {
                       ErrorExit();
                       }
                   }
            }
        }
    }
#endif  /* X86GFX */

}

/* Turn off the PIF reserved & shortcut keys - on block and quit */
void DisablePIFKeySetup(void)
{
    /* only doing this if the application was launched from a new console */
    if (ReserveKey || nShortKeys) {
        APPKEY ShortKey;
            Shortkey.Modifier = 0;
            Shortkey.ScanCode = 0;

            SetConsoleKeyShortcuts(TRUE, 0, &ShortKey, 0);
    }
}

/* Turn on the PIF reserved & shortcut keys - on resume */
void EnablePIFKeySetup(void)
{
    /* only doing this if the app has a new console.*/
    if (ReserveKey || nShortKeys)
        SetConsoleKeyShortcuts(TRUE,
                               ReserveKey,
                               &Shortkey,
                               nShortKeys
                               );

}



GLOBAL VOID config( VOID )
{
    VDMINFO GetPIF;
    char    UniqueTitle[64];
    char    Title[MAX_PATH];
    char    PifName[2*MAX_PATH + 1];
    char    CurDir[MAX_PATH + 1];
    char    Reserved[RESERVED_LENGTH];
    char    achRoot[] = "=?:";
    char    ch, *pch, *pch1;
    UTINY   hostID;
    int     i;
    DWORD   dw;
    char    achPIF[] = ".pif";
    ULONG dpmiMemorySize, vdmMemorySize;

#ifdef ARCX86
    {
        HKEY    hSystemKey;
        UCHAR   identifier[256];
        ULONG   identifierSize = 256;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         "HARDWARE\\DESCRIPTION\\System",
                         0,
                         KEY_QUERY_VALUE,
                         &hSystemKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hSystemKey,
                                "Identifier",
                                NULL,
                                NULL,
                                (LPBYTE)identifier,
                                &identifierSize) == ERROR_SUCCESS)
            {
                if (strstr(identifier, "ARCx86")) {
                    UseEmulationROM = TRUE;
                }
            }
            RegCloseKey(hSystemKey);
        }
    }
#endif /* ARCX86 */

#ifdef HUNTER

        /* Build table in which to store config data. */
        build_data_table();

        /* Initialise optionName fields of host_defs table. */
        host_config_init(common_defs);

        /* Read in trapper variables from environment. */
        read_trapper_variables();

#endif /* HUNTER */

         /*
          *  Set the window title to a unique string, to get
          *  the Consoles Window Handle, we will retrieve
          *  the window handle later when user server has
          *  had a chance to think about it.
          */
        Title[0] = '\0';
        if (!VDMForWOW)  {
            if (!DosSessionId && !GetConsoleTitle(Title, MAX_PATH))
                Title[0] = '\0';
            sprintf(UniqueTitle, "ntvdm-%lx.%lx.%lx",
                   GetCurrentProcessId(), GetCurrentThreadId(),
                   (DWORD)NtCurrentPeb()->ProcessParameters->ConsoleHandle);
            SetConsoleTitle(UniqueTitle);
            }
        else {
            // vdm for wow
            sprintf(Title, "Hidden Console of WOW VDM - %lx.%lx",
                   WowSessionId,
                   (DWORD)NtCurrentPeb()->ProcessParameters->ConsoleHandle);
            }


        /*
         *  Register with srvvdm
         *  Get PifName, ExecName
         */
        GetPIF.PifFile = PifName;
        GetPIF.PifLen = MAX_PATH;
        GetPIF.EnviornmentSize = 0;
        GetPIF.Enviornment = NULL;

        if (fSeparateWow) {
            GetPIF.VDMState = ASKING_FOR_PIF | ASKING_FOR_SEPWOW_BINARY;
            }
        else if (VDMForWOW) {
            GetPIF.VDMState = ASKING_FOR_PIF | ASKING_FOR_WOW_BINARY;
            }
        else {
            GetPIF.VDMState = ASKING_FOR_PIF | ASKING_FOR_DOS_BINARY;
            }

        GetPIF.CmdLine = NULL;
        GetPIF.CmdSize = 0;
        GetPIF.AppName = NULL;
        GetPIF.AppLen = 0;
        GetPIF.iTask      = VDMForWOW && !fSeparateWow ? WowSessionId : DosSessionId;
        GetPIF.Desktop    = NULL;
        GetPIF.DesktopLen = 0;
        GetPIF.ReservedLen = (VDMForWOW) ? 0 : RESERVED_LENGTH;
        GetPIF.Reserved = (VDMForWOW) ? NULL : Reserved;
        GetPIF.CurDirectoryLen = MAX_PATH + 1;
        GetPIF.CurDirectory = CurDir;

            // ask for title if we don't already have one
        if (!*Title) {
            GetPIF.Title    = Title;
            GetPIF.TitleLen = MAX_PATH;
            }
        else {
            GetPIF.Title    = NULL;
            GetPIF.TitleLen = 0;
            }
#ifdef JAPAN
        // only take win31j extention if we are running from a new console.
        pfdata.IgnoreWIN31JExtention = (DosSessionId) ? 0 : 1;
#endif // JAPAN

        PifName[0] = '\0';
        pfdata.IgnoreTitleInPIF = 0;
        pfdata.IgnoreStartDirInPIF = 0;
        pfdata.IgnoreShortKeyInPIF = 0;
        if (GetNextVDMCommand(&GetPIF)) {
            /* parsing the reserve field to decide if
               we should take StartDir, Title and hotkey from
               pif file. See windows\inc\pmvdm.h for the detail
            */

            Reserved[GetPIF.ReservedLen] = '\0';
            if (!VDMForWOW && GetPIF.ReservedLen &&
                (pch = strstr(Reserved, PMVDM_NTVDM_NAME)) != NULL)
            {
                pch += PMVDM_NTVDM_NAME_LENGTH;
                pch1 = pch;
                dw = 0;
                while(*pch >= '0' && *pch <= '9')
                    pch++;
                if (pch1 != pch) {
                    ch = *pch;
                    *pch = '\0';
                    dw = (DWORD) strtol(pch1, (char **)NULL, 10);
                    *pch = ch;
                    if (dw &  PROPERTY_HAS_CURDIR)
                        pfdata.IgnoreStartDirInPIF = 1;
                    if (dw & PROPERTY_HAS_HOTKEY)
                        pfdata.IgnoreShortKeyInPIF = 1;
                    if (dw & PROPERTY_HAS_TITLE)
                        pfdata.IgnoreTitleInPIF = 1;
                }
            }
            if (GetPIF.CurDirectoryLen) {
                achRoot[1] = CurDir[0];

                /* these needs to be ANSI calls not OEM as server passes
                   the informatio in ANSI*/

                SetEnvironmentVariable(achRoot, CurDir);
                SetCurrentDirectory(CurDir);

            }
        }


        pfdata.IgnoreCmdLineInPIF = 0;
        pfdata.IgnoreConfigAutoexec = 0;
        pfdata.AppHasPIFFile = PifName[0] ? 1 : 0;

        if(VDMForWOW) {
#ifdef JAPAN             
            if (!GetPIF.PifLen || !(pch = strchr(PifName, ' '))) {
              memcpy(PifName, pszSystem32Path, ulSystem32PathLen);
              memcpy(PifName+ulSystem32PathLen, "\\krnl386.pif", sizeof("\\krnl386.pif"));
            }
#endif // JAPAN
            DosSessionId = 0;            // Wow has hidden console !
            pfdata.IgnoreCmdLineInPIF =
            pfdata.IgnoreTitleInPIF =
            pfdata.IgnoreStartDirInPIF = 1;
            pfdata.IgnoreShortKeyInPIF = 1;
        }

        process_pif_exe(PifName);

        sas_term ();

        //
        // Calculate how big xms and ems will be.
        // XMS and EMS memory sizes are either taken from a PIF file, or
        // supplied from default values.
        //

        if (VDMForWOW) {

            //
            // For WOW, we don't need any EMS, and we just need enough
            // XMS to satisfy win16 apps looking at the real machine size
            //
            emsMemorySize = 0;
            xmsMemorySize = XMS_DEFAULT_MEMORY_SIZE;
            dpmiMemorySize = DPMI_DEFAULT_MEMORY_SIZE_FOR_WOW;
        } else {

            emsMemorySize = PIFEMSMemSize == (USHORT)(-1)
                            ? EMS_DEFAULT_MEMORY_SIZE
                            : PIFEMSMemSize;

            /* maximum size is 63MB */
            xmsMemorySize = PIFExtendMemSize == (USHORT)(-1)
                            ? XMS_DEFAULT_MEMORY_SIZE
                            : PIFExtendMemSize;

            /* put a upper limit on ems memory size based on EMM 4.0 spec */
            if (emsMemorySize > EMS_MAX_MEMORY_SIZE)
                emsMemorySize = EMS_MAX_MEMORY_SIZE;

            // Force at least 1 megabyte xms to keep himem and dosx working.
            if (xmsMemorySize < 1024) {
                xmsMemorySize = 1024;
            }
            else if(xmsMemorySize > XMS_MAX_MEMORY_SIZE) {
                xmsMemorySize = XMS_MAX_MEMORY_SIZE;
            }

            dpmiMemorySize = DPMI_DEFAULT_MEMORY_SIZE_FOR_DOS;
        }

#ifdef LIM
        /*  !!!! THIS MUST BE DONE BEFORE CALLING SAS_INIT !!!!!! */
        if(!VDMForWOW && config_inquire(C_LIM_SIZE, NULL) &&
           init_lim_configuration_data(&lim_config_data))
            lim_config_data.initialized = TRUE;

#endif

        //
        // Add everything up to decide how much physically installed memory
        // the virtual machine needs. On RISC platforms, we may create a
        // larger machine than xms or ems would call for to provide for
        // dpmi memory. We get this size from the registry.
        //

#ifdef i386
         // adding 1024 below is for conventional memory
         vdmMemorySize = xmsMemorySize + emsMemorySize + 1024;
#else
         vdmMemorySize = 16L * 1024L

         // Extend the vdm size if the user asks for it through a .PIF.
         // Also make sure we have at least appropriate size of dpmi
         // memory.
         //
         if ((xmsMemorySize + emsMemorySize +  1024 + dpmiMemorySize) >
              vdmMemorySize)
         {
            vdmMemorySize = xmsMemorySize + emsMemorySize + 1024 +
                            dpmiMemorySize;
         }
#endif

#ifndef PROD
        dpmiMemorySize = vdmMemorySize - (xmsMemorySize + emsMemorySize + 1024);

        printf("NTVDM: %dK Memory: %dK XMS, %dK EMS, %dK DPMI\n",
               vdmMemorySize, xmsMemorySize, emsMemorySize, dpmiMemorySize);
#endif

        sas_init(vdmMemorySize*ONEKB);


#ifdef CPU_40_STYLE

        /* sas_init has initialised Gdp, so now we can set up the pointers */
        /* to the Gdp variables that hold register values. This is to */
        /* allow NTSD debugger extensions to display those values. */
        InitNtCpuInfo();

#endif


#ifdef X86GFX
        GetROMsMapped();        /* before anyone else can toy with memory */

#ifdef ARCX86
    if (UseEmulationROM) {
        PVOID   BaseAddress;
        ULONG   ViewSize;
        NTSTATUS Status;
#if 0
   // XXX Temporary hack for ARCX86 VDM to work on PC with BIOS
   Status = NtUnmapViewOfSection(NtCurrentProcess(), 0xc0000);
   DbgPrint("config: NtUnmapViewOfSection 0xc0000. Status = %x\n", Status);
   Status = NtUnmapViewOfSection(NtCurrentProcess(), 0xf0000);
   DbgPrint("config: NtUnmapViewOfSection 0xf0000. Status = %x\n", Status);
#endif

        /* commit memory for ROM area */
        BaseAddress = (PVOID)EGA_ROM_START;
        ViewSize = 0x8000;
        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                         &BaseAddress,
                         0L,
                         &ViewSize,
                         MEM_RESERVE | MEM_COMMIT,
                         PAGE_EXECUTE_READWRITE
                         );
        if(!NT_SUCCESS(Status)) {
            TerminateVDM();
        }

        BaseAddress = (PVOID)(BIOS_START);
        ViewSize = PC_MEM_SIZE - BIOS_START;
        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                         &BaseAddress,
                         0L,
                         &ViewSize,
                         MEM_RESERVE | MEM_COMMIT,
                         PAGE_EXECUTE_READWRITE
                         );
        if(!NT_SUCCESS(Status)) {
            TerminateVDM();
        }

        rom_init();
    } else {
        locateNativeBIOSfonts();        /* get fonts from page 0 */
    }
#else  /* ARCX86 */
        locateNativeBIOSfonts();        /* get fonts from page 0 */
#endif /* ARCX86 */

#endif

           //  Now see if we can get the console window handle
        if (!VDMForWOW)  {
            i = 6;
            do {
                hWndConsole = FindWindow("ConsoleWindowClass", UniqueTitle);
                if (!hWndConsole && i)
                    Sleep(10);
              } while (!hWndConsole && i--);
            if (!hWndConsole) {
                hWndConsole = HWND_DESKTOP;
#ifndef PROD
                printf("NTVDM: using HWND_DESKTOP\n");
#endif
                }
            }

           // set the initial console title
        if (*Title)
            SetConsoleTitle(Title);



// Create UMB list (both MIPS and x86) -- williamh
        InitUMBList();
//
        host_runtime_init();            /* initialise the runtime system */


        /* Do not attempt to initialise printer system here */
// activate(open) floppy drives if there are any
        number_of_floppy = 0;
        for (i = 0, hostID = C_FLOPPY_A_DEVICE; i < MAX_FLOPPY; i++, hostID++)
            if ((gfi_floppy_active(hostID, 1, NULL)) == C_CONFIG_OP_OK)
                number_of_floppy++;
}

GLOBAL VOID *
config_inquire(UTINY hostID, ConfigValues *values)
{
        /* Must be a static because returned to called */
        // BUGBUG should be change (caller provides buffer!!!)
        static ConfigValues tmp_vals;

        if(!values) values = &tmp_vals;

        /*:::::::::::::::::::::::::::::::::::::: Hardwire the config stuff */

        switch (hostID)
        {
                case C_HARD_DISK1_NAME:
                        //
                        // this dubious practice will satisfy the disk
                        // bios to exist quietly enough for initialisation
                        // after which, DOS emulation should ensure no more
                        // disk bios calls are made.
                        //
                        host_using_fdisk(FALSE);    // tell fdisk it's ok to fail
                        strcpy (values->string, "?");
                        return ((VOID *) values->string);


                case C_HARD_DISK2_NAME:
                        strcpy (values->string, "");
                        {
                        char tmp[100];
                        host_fdisk_valid (hostID, values, NULL, tmp);
                        host_fdisk_change (hostID, TRUE);
                        host_fdisk_active (hostID, TRUE, tmp);
                        }

                        return ((VOID *) values->string);


                case C_GFX_ADAPTER:
                        values->index = VGA;
                        return ((VOID *)VGA);

                case C_WIN_SIZE:
                        values->index = 2;     /* 2, 3 or 4. */
                        return ((VOID *) values->index);

                case C_EXTENDED_MEM_SIZE:
                        values->index = (SHORT)(xmsMemorySize/1024);
                        return ((VOID *)values->index);

                case C_LIM_SIZE:
                        values->index = (SHORT)(emsMemorySize/1024);
                        return ((VOID *)values->index);

                case C_MEM_LIMIT:
                        values->index = 640;
                        return ((VOID *)values->index);

                case C_COM1_NAME:
                        strcpy (values->string, "COM1");
                        values->index = (short)read_profile_int(PROFILE_COM_AUTOCLOSE_DELAY);
                        return ((VOID *) values->string);

                case C_COM2_NAME:
                        strcpy (values->string, "COM2");
                        values->index = (short)read_profile_int(PROFILE_COM_AUTOCLOSE_DELAY);
                        return ((VOID *) values->string);

                case C_COM3_NAME:
                        strcpy (values->string, "COM3");
                        values->index = (short)read_profile_int(PROFILE_COM_AUTOCLOSE_DELAY);
                        return ((VOID *) values->string);

                case C_COM4_NAME:
                        strcpy (values->string, "COM4");
                        values->index = (short)read_profile_int(PROFILE_COM_AUTOCLOSE_DELAY);
                        return ((VOID *) values->string);

                case C_LPT1_NAME:
                        strcpy (values->string, "LPT1");
                        values->index = (short)read_profile_int(PROFILE_LPT_AUTOCLOSE_DELAY);
                        return ((VOID *) values->string);

                case C_LPT2_NAME:
                        strcpy (values->string, "LPT2");
                        values->index = (short)read_profile_int(PROFILE_LPT_AUTOCLOSE_DELAY);
                        return ((VOID *) values->string);

                case C_LPT3_NAME:
                        strcpy (values->string, "LPT3");
                        values->index = (short)read_profile_int(PROFILE_LPT_AUTOCLOSE_DELAY);
                        return ((VOID *) values->string);


/* Auto flush closes the port after 'n' seconds of inactivaty */

                case C_AUTOFLUSH:
                        values->index = TRUE;
                        return ((VOID *)values->index);

                case C_AUTOFLUSH_DELAY:
                        values->index = (short)read_profile_int(PROFILE_LPT_AUTOFLUSH_DELAY); //Delay in secs
                        return((VOID *)values->index);

//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


                case C_FSA_DIRECTORY:
                        strcpy (values->string, "\\");
                        return ((VOID *) values->string);

                case C_VDMLPT1_NAME:
                        strcpy(values->string, "\\\\.\\$VDMLPT1");
                        return ((VOID *)values->string);
                case C_VDMLPT2_NAME:
                        strcpy(values->string, "\\\\.\\$VDMLPT2");
                        return ((VOID *)values->string);
                case C_VDMLPT3_NAME:
                        strcpy(values->string, "\\\\.\\$VDMLPT3");
                        return ((VOID *)values->string);


#ifdef HUNTER

                case C_HU_FILENAME:
                case C_HU_MODE:
                case C_HU_BIOS:
                case C_HU_REPORT:
                case C_HU_SDTYPE:
                case C_HU_CHKMODE:
                case C_HU_CHATTR:
                case C_HU_SETTLNO:
                case C_HU_FUDGENO:
                case C_HU_DELAY:
                case C_HU_GFXERR:
                case C_HU_TS:
                case C_HU_NUM:
                    switch (conf_tab[hostID].def->flags & C_TYPE_MASK)
                    {
                    case C_STRING_RECORD:
                        strcpy(values->string,
                               conf_tab[hostID].data->string);
                        return ((VOID *) values->string);
                    case C_NAME_RECORD:
                    case C_NUMBER_RECORD:
                        values->index = conf_tab[hostID].data->index;
                        return ((VOID *) values->index);
                    default:
                        break;
                    }
                    break;

#endif /* HUNTER */

                case C_COM_SYNCWRITE:
                    values->index = (short)read_profile_int(PROFILE_COM_SYNCWRITE);
                    return ((VOID *)values->index);

                case C_COM_TXBUFFER_SIZE:
                    values->index = (short)read_profile_int(PROFILE_COM_TXBUFFER_SIZE);
                    return ((VOID *)values->index);

                default:        /* ie everything else */
                        /* fail */
                        break;
        }
    /* setup dummy values to stop loud explosions */
    strcpy (values->string, "");

    return ((VOID *) values->string);

}

GLOBAL VOID config_set_active(UTINY hostID, BOOL state)
{
        UNREFERENCED_FORMAL_PARAMETER(hostID);
        UNREFERENCED_FORMAL_PARAMETER(state);
        /* do nothing */
}

GLOBAL CHAR *convert_to_external(UTINY hostID)
{
        UNREFERENCED_FORMAL_PARAMETER(hostID);
        return (NULL);
}

GLOBAL CHAR *
find_optionname(UTINY hostID)
{

        UNREFERENCED_FORMAL_PARAMETER(hostID);
        return (NULL);
}

GLOBAL BOOL
config_get_active(UTINY hostID)
{


        UNREFERENCED_FORMAL_PARAMETER(hostID);
        /* It worked whatever it was supposed to do */
        return (TRUE);
}

GLOBAL VOID
config_activate(UTINY hostID, BOOL reqState)
{

        UNREFERENCED_FORMAL_PARAMETER(hostID);
        UNREFERENCED_FORMAL_PARAMETER(reqState);

        /* do all */
}

GLOBAL char *   host_expand_environment_vars IFN1(const char *, string)
{

        /* we're not going to use the environment for lookups */
        return ((char *)string);
}

/********************************************************/
/* host runtime stuff */
struct
{
        short mouse_attached;
        short config_verbose;
        short npx_enabled;
        short sound_on;
} runtime_status = {
        FALSE, FALSE, TRUE, TRUE};

void host_runtime_init()
{
#ifdef MONITOR
    CONTEXT txt;

    // get Floating point info for system.
    txt.ContextFlags = CONTEXT_FLOATING_POINT;
    if (! GetThreadContext(GetCurrentThread(), &txt) )
    {
        runtime_status.npx_enabled = FALSE;     //dont know for sure so be safe
    }
    else
    {
#if 0   /* if the correct fix ever is made... */
        if (txt.FloatSave.Cr0NpxState & EMBITSET)
            runtime_status.npx_enabled = FALSE;     //EM only on if no NPX
        else
            runtime_status.npx_enabled = TRUE;      //NPX present.
#endif

        // If no coprocessor, the CONTEXT_F_P bit will have been cleared
        if ((txt.ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT)
            runtime_status.npx_enabled = TRUE;     //EM only on if no NPX
        else
            runtime_status.npx_enabled = FALSE;
    }
#else
    runtime_status.npx_enabled = TRUE;
#endif
}

short host_runtime_inquire IFN1(UTINY, what)
{
        switch (what)
        {
                case C_MOUSE_ATTACHED:
                        return (runtime_status.mouse_attached);
                case C_NPX_ENABLED:
                        return (runtime_status.npx_enabled);
                case C_SOUND_ON:
                        return (runtime_status.sound_on);
                default:
#ifndef PROD
                        fprintf (trace_file,"host_runtime_inquire : Unknown option %d\n",what);
#endif
                        ;
        }
        return FALSE;
}

void host_runtime_set IFN2(UTINY, what, SHORT, val)
{
        switch (what)
        {
                case C_MOUSE_ATTACHED:
                        runtime_status.mouse_attached = val;
                        break;
                case C_NPX_ENABLED:
                        runtime_status.npx_enabled = val;
                        break;
                case C_SOUND_ON:
                        runtime_status.sound_on = val;
                        break;
                default:
#ifndef PROD
                        fprintf (trace_file,"host_runtime_set : Unknown option %d\n",what);
#endif
                        ;
        }
}



#ifdef HUNTER

/*
 * ==========================================================================
 * Function: translate_to_string.
 *
 *  Taken from `conf_util.c' which we don't use. Takes a SHORT and returns
 * the corresponding string in the `NameTable'.
 * ==========================================================================
 */
GLOBAL CHAR *
translate_to_string(SHORT value, NameTable table[])
{
        FAST NameTable *nameTabP;

        for (nameTabP = table; nameTabP->string; nameTabP++)
                if (nameTabP->value == value)
                        break;

        return nameTabP->string;
}

/*
 * ==========================================================================
 * Function: translate_to_value.
 *
 *  Taken from `conf_util.c' which we don't use. Takes a string and returns
 * the corresponding SHORT in the `NameTable'.
 * ==========================================================================
 */
GLOBAL SHORT
translate_to_value(CHAR *string, NameTable table[])
{
        FAST NameTable *nameTabP;

        for (nameTabP = table; nameTabP->string; nameTabP++)
                if(!strcmp(string, nameTabP->string))
                        break;

        return (!nameTabP->string)? C_CONFIG_NOT_VALID : nameTabP->value;
}

/*
 * ==========================================================================
 * Function: validate_item.
 *
 *  Taken from `conf_def.c' which we don't use. Needed because `hunt_conf.c'
 * uses it as the validation routine for several `config' variables (see
 * `host_defs' table in `hunt_conf.c').
 * ==========================================================================
 */
GLOBAL SHORT
validate_item(UTINY hostID, ConfigValues *value,
              NameTable *table, CHAR *err)
{
        char *what;

        if (!(what = translate_to_string(value->index, table)))
        {
                *err = '\0';
                return EG_BAD_VALUE;
        }
        return C_CONFIG_OP_OK;
}

/*
 * ==========================================================================
 * Function: add_resource_node.
 *
 *  Stubbed add_resource_node added to satisfy reference in unused
 * `host_read_resource_file' in `hunt_cnf.c'. Needed in order to make trapper
 * SoftPC link when using Microsoft `config'.
 * ==========================================================================
 */
GLOBAL LineNode *
add_resource_node(CHAR *str)
{
    always_trace0("Stubbed add_resource_node called");
    return((LineNode *) NULL);
}

#endif /* HUNTER */

/*
 * ===========================================================================
 * LOCAL FUNCTIONS
 * ===========================================================================
 */

#ifdef HUNTER

VOID
build_data_table(VOID)
{
    SHORT   maxHostID = 0;
    OptionDescription *defP;

    /* Don't do it more than once. */
    if (conf_tab != NULL)
        return;

    /* Find out how big the table needs to be. */
    for (defP = host_defs; defP->optionName; defP++)
        if (defP->hostID > maxHostID)
            maxHostID = defP->hostID;
    maxHostID++;

    /* Create the table. */
    check_malloc(conf_tab, maxHostID, ConfTabEntry);
}

VOID
read_trapper_variables(VOID)
{
    CHAR  arg[MAXPATHLEN],
         *vp;
    OptionDescription *defP;
    ConfigValues  data,
                 *cvp;
    ErrData errData;

    /* Read all the variables required by trapper from the environment. */
    for (defP = host_defs; defP->optionName; defP++)
    {

        /*
         * Ignore `host_defs' entries designed to override `common_defs'
         * entries as we have an empty common_defs table.
         */
        if ((defP->flags & C_TYPE_MASK) == C_RECORD_DELETE)
            continue;

        /* Get the variable. */
        vp = host_getenv(defP->optionName);
        if (vp != NULL) {
            strncpy(arg, vp,sizeof(arg));
            arg[sizeof(arg)-1] = '\0';
        }
        else
            arg[0] = '\0';

        /*
         * Convert variable and store in ConfigValues structure for use by
         * validation routine.
         */
        convert_arg(arg, defP, &data);
        errData.string_1 = arg;
        errData.string_2 = defP->optionName;
        while (check_value(defP, &data))
        {
            if (host_error_ext(EG_BAD_CONF, ERR_QU_CO, &errData) == ERR_CONT)
                convert_arg(arg, defP, &data);
        }

        /* Store the value in the data table. */
        check_malloc(cvp, 1, ConfigValues);
        conf_tab[defP->hostID].data = cvp;
        conf_tab[defP->hostID].def = defP;
        switch (defP->flags & C_TYPE_MASK)
        {
        case C_STRING_RECORD:
            always_trace2("read_trapper_variables: %s set to %s",
                          defP->optionName, data.string);
            strcpy(cvp->string, data.string);
            break;

        case C_NAME_RECORD:
        case C_NUMBER_RECORD:
            always_trace2("read_trapper_variables: %s set to %d",
                          defP->optionName, data.index);
            cvp->index = data.index;
            break;

        default:
            break;
        }
    }
}

VOID
convert_arg(CHAR *arg, OptionDescription *defP, ConfigValues *dataP)
{
    switch (defP->flags & C_TYPE_MASK)
    {
    case C_STRING_RECORD:
        strcpy(dataP->string, arg);
        break;

    case C_NAME_RECORD:
        dataP->index = translate_to_value(arg, defP->table);
        break;

    case C_NUMBER_RECORD:
        dataP->index = atoi(arg);
        break;

    default:
        (VOID) host_error(EG_OWNUP, ERR_QUIT, "Invalid TYPE");
        break;
    }
}

SHORT
check_value(OptionDescription *defP, ConfigValues *dataP)
{
    SHORT status;
    CHAR errbuf[MAXPATHLEN];

    if (defP->valid)
        status = (*defP->valid)(defP->hostID, dataP, defP->table, errbuf);
    else
        status = C_CONFIG_OP_OK;
    return(status);
}

#endif /* HUNTER */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Read auto close time ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#define APPNAME "Dos Emulation"

/* These are entries uder "WOW" section in the system registry to control
 * LPT and COM devices behaviors.
 *
 * "PrinterAutoClose=n" -- the printer port will be closed if there are
 *          not activities on the port for n seconds
 * "CommsAutoClose=n"   -- the comm port will be closed(suspended" if there
 *          there are not activities on the port for
 *          n s. 0 means auto close is disabled.
 * "LPT_timeout=n"   -- the printer port will be flushed every n seconds
 * "COM_SyncWrite=[0,1]" -- if 0, write to comm port(tx) if performed in
 *           async way(using overlapped i/o). If 1, then
 *           data will be written to the port in synchrounously.
 * "COM_TxBuffer_Size=n" -- comm tx queue buffer size. It also used to control
 *           the tx threshold -- setting the buffer size to
 *           1 effectively disables tx queuing.
 */
struct { char *keyword; int def; } ProfileStrings[] =
{
    { "PrinterAutoClose", 15 },
    { "CommsAutoClose", 0 },
    { "LPT_timeout", 15},
    { "COM_SyncWrite",0 },
    { "COM_TxBuffer_Size", 200}
};

int read_profile_int(int index)
{
    CHAR  CmdLine[100];
    ULONG CmdLineSize = 100;
    HKEY  hWowKey;

    ASSERT((unsigned int) index < PROFILE_MAX_INDEX);

    if (RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                       "SYSTEM\\CurrentControlSet\\Control\\WOW",
                       0,
                       KEY_QUERY_VALUE,
                       &hWowKey
                       ) != 0)
    {
        return(ProfileStrings[index].def);
    }

    if (RegQueryValueEx (hWowKey,
                         ProfileStrings[index].keyword,
                         NULL,
                         NULL,
                         (LPBYTE)CmdLine,
                         &CmdLineSize) != 0)
    {
        RegCloseKey (hWowKey);
        return(ProfileStrings[index].def);
    }

    RegCloseKey (hWowKey);

    return ((int) atoi(CmdLine));
}



#ifdef LIM
boolean get_lim_configuration_data(PLIM_CONFIG_DATA buffer)
{
    if (lim_config_data.initialized){
        *buffer = lim_config_data;
        return TRUE;
    }
    else
        return FALSE;
}
#endif


#ifdef MONITOR
/* this function returns the backfill starting segment to monitor
  *
 * VERT IMPORTANT !!!!
 * the backfill segment must be available before sas_init.
 *
 */

unsigned short get_lim_backfill_segment(void)
{
#ifdef LIM
    if (lim_config_data.initialized)
        return lim_config_data.base_segment;
    else
        return 640 * 1024 / 16;
#else
    return 640 * 1024 / 16;
#endif

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\copy_fnc.c ===
/* static char SccsID[] = " @(#)copy_func.c	1.6 6/24/91 Copyright Insignia Solutions Ltd."; */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "host_def.h"
#include "insignia.h"
#include "xt.h"

void
bwdcopy(
    char *src,
    char *dest,
    int len
    )
{
#if 0
register int loop;
      for(loop = 0; loop < len; loop++)
         *dest-- = *src--;

#else
      int i;

      i = len - 1;
      memcpy(dest - i , src - i, len);

#endif
}


void
bwd_dest_copy(
    char *src,
    char *dest,
    int len
    )
{
     int loop;

     for(loop = 0; loop < len; loop++)
         *dest-- = *src++;
}


void
memfill(
    unsigned char data,
    unsigned char *l_addr_in,
    unsigned char *h_addr_in
    )
{
     unsigned int len;

     len = h_addr_in + 1 - l_addr_in;
     memset(l_addr_in, data, len);

#if 0
	unsigned int data4;
	unsigned char *l_addr = l_addr_in;
	unsigned char *h_addr = h_addr_in;
	unsigned int *l_addr4,*h_addr4;

	l_addr4 = (unsigned int *)(((unsigned int)l_addr+3) & (~3));
	h_addr4 = (unsigned int *)(((unsigned int)h_addr+1) & (~3));
	if(h_addr4 > l_addr4)
        {
                data4 = data*0x01010101;   // 0x61 * 0x01010101 = 0x61616161
                for(;(unsigned int *)l_addr < l_addr4;l_addr++)
                    *l_addr = data;
                do {
                    *l_addr4++ = data4;
                  } while (h_addr4 > l_addr4);

		l_addr = (unsigned char *)l_addr4;
	}
        for(;l_addr <= h_addr;l_addr++)*l_addr = data;
#endif
}

void
fwd_word_fill(
   unsigned short data,
   unsigned char *l_addr_in,
   int len
   )
{
        unsigned int data4, count;
	unsigned char *l_addr = l_addr_in;
	unsigned char *h_addr = l_addr_in+(len<<1);
	unsigned int *l_addr4,*h_addr4;

	l_addr4 = (unsigned int *)(((unsigned int)l_addr+3) & (~3));
	h_addr4 = (unsigned int *)(((unsigned int)h_addr) & (~3));
#ifdef	LITTLEND
        data = ((data >> 8) & 0xff) | ((data << 8) & 0xff00);
#endif
	if(h_addr4 > l_addr4)
	{
		switch((unsigned char *)l_addr4-l_addr)
		{
			case 3:
				data = (data>>8) | (data<<8);
				*l_addr++ = (unsigned char)(data);
			case 2:
				*(unsigned short *)l_addr = data;
				break;
			case 1:
				data = (data>>8) | (data<<8);
				*l_addr = (unsigned char)data;
		}
                data4 = data+(data<<16);

#if 0
                do *l_addr4++ = data4; while (h_addr4 > l_addr4);
                l_addr = (unsigned char *)l_addr4;
#else
                count = h_addr4 - l_addr4;
                RtlFillMemoryUlong(l_addr4, count, data4);
                l_addr = (unsigned char *)l_addr4;
                l_addr += count;
#endif

	}
	switch(h_addr-l_addr)
	{
		case 5:
/*
			data = (data>>8) | (data<<8);
*/
        		data = ((data >> 8) & 0xff) | ((data << 8) & 0xff00);
                        *l_addr++ = (unsigned char)data;
			*(unsigned int *)l_addr = data | (data<<16);
			break;
		case 7:
/*
			data = (data>>8) | (data<<8);
*/
        		data = ((data >> 8) & 0xff) | ((data << 8) & 0xff00);
                        *l_addr++ = (unsigned char)data;
		case 6:
                        *l_addr++ = (unsigned char)data;
			*l_addr++ = data >> 8;
		case 4:
                        *l_addr++ = (unsigned char)data;
			*l_addr++ = data >> 8;
                        *l_addr++ = (unsigned char)data;
			*l_addr++ = data >> 8;
			break;
		case 3:
/*
			data = (data>>8) | (data<<8);
*/
        		data = ((data >> 8) & 0xff) | ((data << 8) & 0xff00);
			*l_addr++ = (unsigned char)(data);
		case 2:
                        *l_addr++ = (unsigned char)data;
			*l_addr++ = data >> 8;
			break;
		case 1:
/*
			data = (data>>8) | (data<<8);
*/
        		data = ((data >> 8) & 0xff) | ((data << 8) & 0xff00);
			*l_addr = (unsigned char)data;
        }
}




void
memset4(
    unsigned int data,
    unsigned int *laddr,
    unsigned int count
    )
{
#if 0
        while( count -- )
        {
                *laddr++ = data;
        }
#else

   /*
    * The argument, count, as passed to this function is the number of 4-byte
    * items to fill, all RtlFill type functions need their count in bytes, so
    * multiply count by 4. (JJS - 6/9/95).
    */
   RtlFillMemoryUlong(laddr, count << 2, data);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\makefile.inc ===
#dummy file to be included

{$(O)\}fprt.obj : ..\fprt.c

$(SOFTPC_DEST)\$(ALT_PROJECT_TARGET)\$(O)\fprt.obj : $(O)\fprt.OBJ
        copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_bop.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include "insignia.h"
#include "host_def.h"
#include <nt_thred.h>
#include <nt_pif.h>
#include "idetect.h"
#include "conapi.h"
#include "nt_graph.h"
#include <bop.h>

#ifndef MONITOR
#include <gdpvar.h>
#endif

/*          INSIGNIA MODULE SPECIFICATION
            -----------------------------


    THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
    CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
    NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
    AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DESIGNER        : Jim Hatfield

REVISION HISTORY    :
First version       : 29th August 1988
Second version      : 18th May    1991

MODULE NAME     : nt_bop

SOURCE FILE NAME    : nt_bop.c

PURPOSE         : Supply the NT-specific BOP FF operations.

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1] (if not basic C types)]

    STRUCTURES/TYPEDEFS/ENUMS:

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]

    PROCEDURES: None
    DATA:       None

-------------------------------------------------------------------------
[1.4 DESCRIPTION OF INTERMODULE INTERFACE]

[1.4.1 IMPORTED OBJECTS]

DATA OBJECTS      : None


/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
=========================================================================

[3.1 INTERMODULE IMPORTS]                       */

/* [3.1.1 #INCLUDES]                                                    */

#include "stdio.h"

#include "xt.h"
#include CpuH
#include "sas.h"
#include "error.h"
#include "config.h"
#include "cntlbop.h"
#include "host_bop.h"
#include "demexp.h"
#include "xmsexp.h"
#include "sim32.h"
#include "idetect.h"
#include "bios.h"
#include "nt_reset.h"
#include "nt_eoi.h"
#include <nt_com.h>
#include "yoda.h"
#include "nt_vdd.h"


/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]                        */


/*
5.MODULE INTERNALS   :   (not visible externally,global internally)]

[5.1 LOCAL DECLARATIONS]                        */

/* [5.1.1 #DEFINES]                         */

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]            */

//
// MYFARPROC
//

typedef ULONG (*MYFARPROC)();
typedef ULONG (*W32INITPROC)(VOID);

/* [5.1.3 PROCEDURE() DECLARATIONS]                 */

/* -----------------------------------------------------------------------
[5.2 LOCAL DEFINITIONS]

   [5.2.1 INTERNAL DATA DEFINITIONS                     */


/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]               */

/*
7.INTERMODULE INTERFACE IMPLEMENTATION :
 */

VOID WaitIfIdle(VOID), WakeUpNow(VOID);
VOID to_com_driver(VOID);
VOID call_ica_hw_interrupt(int, half_word, int);
VOID ica_enable_iret_hook(int, int, int);
VOID ica_iret_hook_called(int);

/*
[7.1 INTERMODULE DATA DEFINITIONS]              */


#define SEGOFF(seg,off) (((ULONG)(seg) << 16) + ((off)))


/********************************************************/
/* GLOBALS */

void UMBNotify(unsigned char);
VOID demDasdInit(VOID);

control_bop_array host_bop_table[] =
{
     0, NULL
};

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::;:::::: MS BOP stubs :::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

// DOS EMULATION BOP
void MS_bop_0(void) {
    ULONG DemCmd;

    EnableScreenSwitch(FALSE, hMainThreadSuspended);
    DemCmd = (ULONG)(*(PUCHAR)VdmMapFlat(getCS(), getIP(), VDM_V86));
    setIP((USHORT)(getIP() + 1));

    DemDispatch( DemCmd );

    // we need to prevent the idle system from going off on intensive file
    // reads. However, we don't want to disable it for continuous 'Get Time'
    // calls (command 0x15). Nor for Get Date (0x15).
    if (DemCmd != 0x15 && DemCmd != 0x14)
        IDLE_disk();
    DisableScreenSwitch(hMainThreadSuspended);
}

// WOW BOP
HANDLE hWOWDll;

MYFARPROC WOWDispatchEntry;
W32INITPROC WOWInitEntry;
VOID (*pW32HungAppNotifyThread)(UINT) = NULL;

static BOOL WowModeInitialized = FALSE;

void MS_bop_1(void) {

    if (!WowModeInitialized) {

    hWOWDll = LoadSystem32Library(L"WOW32.DLL");
    if (hWOWDll == NULL)
    {
#ifndef PROD
        HostDebugBreak();
#endif
        TerminateVDM();
        return;
    }

    // Get the init entry point and dispatch entry point
    if ((WOWInitEntry = (W32INITPROC)GetProcAddress(hWOWDll, "W32Init")) == NULL)
    {
#ifndef PROD
        HostDebugBreak();
#endif
        TerminateVDM();
    }

    if ((WOWDispatchEntry = GetProcAddress(hWOWDll, "W32Dispatch")) == NULL)
    {
#ifndef PROD
        HostDebugBreak();
#endif
        TerminateVDM();
    }

    //Get Comms functions
    if ((GetCommHandle = (GCHfn) GetProcAddress(hWOWDll, "GetCommHandle")) == NULL)
    {
#ifndef PROD
        HostDebugBreak();
#endif
        TerminateVDM();
    }

    if ((GetCommShadowMSR = (GCSfn) GetProcAddress(hWOWDll, "GetCommShadowMSR")) == NULL)
    {
#ifndef PROD
        HostDebugBreak();
#endif
        TerminateVDM();
    }

    //Get hung app Notification routine
    pW32HungAppNotifyThread = (VOID(*)(UINT))GetProcAddress( hWOWDll,
                                                    "W32HungAppNotifyThread");
    if (!pW32HungAppNotifyThread)
    {
#ifndef PROD
        HostDebugBreak();
#endif
        TerminateVDM();
    }


    // Call the init routine
    if ((*WOWInitEntry)() == FALSE)
    {
#ifndef PROD
        HostDebugBreak();
#endif
        TerminateVDM();
    }

    WowModeInitialized = TRUE;
    }

#if !defined(CPU_40_STYLE) || defined(CCPU)
    (*WOWDispatchEntry)();
#else
    // Dispatch to WOW dispatcher
    {
        static BYTE **AddressOfLocal;
        BYTE *localSimulateContext = GLOBAL_SimulateContext;

        AddressOfLocal = &localSimulateContext;

        (*WOWDispatchEntry)();

        SET_GLOBAL_SimulateContext(localSimulateContext);

        if(AddressOfLocal != &localSimulateContext)
        {
            //Thread switch detected via stack change, force CPU to
            //abort the current fragment, reseting GDP var's refering
            //to the host stack

            setEIP(getEIP());
        }
    }
#endif  /* CPU_40_STYLE */
}


// XMS BOP
void MS_bop_2(void) {
    ULONG XmsCmd;

    XmsCmd = (ULONG)(*(PUCHAR)VdmMapFlat(getCS(), getIP(), VDM_V86));
    setIP((USHORT)(getIP() + 1));

    XMSDispatch(XmsCmd);
}


// DEBUGGING BOP
void MS_bop_int3(void) {

#ifndef PROD
    force_yoda();
#endif
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

// MONITOR DPMI BOP

void MS_bop_3(void)
{
   IMPORT VOID DpmiDispatch(VOID);

   DpmiDispatch();
}

// SCS BOP
/* CMD dispatcher, this BOP will only work in real mode */

void MS_bop_4(void)
{
    ULONG Command;
    IMPORT BOOL CmdDispatch(ULONG);

    Command = (ULONG)(*(PUCHAR)VdmMapFlat(getCS(), getIP(), VDM_V86));
    setIP((USHORT)(getIP() + 1));
    CmdDispatch((ULONG) Command);
}


//
// MsBop6 - used to dispatch to debugger support functions
//

void MS_bop_6()
{
    IMPORT VOID DBGDispatch(VOID);
    /*
    ** All of the parameters for the debugger support
    ** should be on the VDMs stack.
    */
    DBGDispatch();
}

//
// DefaultVrInitialized - calls to VrInitialized (through a pointer to a routine)
// will return FALSE until the VDMREDIR DLL has been successfully loaded and
// initialized
//

ULONG DefaultVrInitialized(VOID);
ULONG DefaultVrInitialized() {
    return FALSE;
}

//
// publicly accessible routine addresses. These are not expected to be called
// until VrInitialized points at the real VrInitialized routine inside VdmRedir
//

#if DBG
ULONG DefaultVrError(VOID);
ULONG DefaultVrError() {
    printf("MS_bop_7: Error: function called without VDMREDIR loaded!\n");
    HostDebugBreak();
    return 0;
}
MYFARPROC VrDispatch = &DefaultVrError;
MYFARPROC VrInitialized = &DefaultVrInitialized;
MYFARPROC VrReadNamedPipe = &DefaultVrError;
MYFARPROC VrWriteNamedPipe = &DefaultVrError;
MYFARPROC VrIsNamedPipeName = &DefaultVrError;
MYFARPROC VrIsNamedPipeHandle = &DefaultVrError;
MYFARPROC VrAddOpenNamedPipeInfo = &DefaultVrError;
MYFARPROC VrConvertLocalNtPipeName = &DefaultVrError;
MYFARPROC VrRemoveOpenNamedPipeInfo = &DefaultVrError;
#else
MYFARPROC VrDispatch;
MYFARPROC VrInitialized = DefaultVrInitialized;
MYFARPROC VrReadNamedPipe;
MYFARPROC VrWriteNamedPipe;
MYFARPROC VrIsNamedPipeName;
MYFARPROC VrIsNamedPipeHandle;
MYFARPROC VrAddOpenNamedPipeInfo;
MYFARPROC VrConvertLocalNtPipeName;
MYFARPROC VrRemoveOpenNamedPipeInfo;
#endif

BOOL LoadVdmRedir(VOID);

VOID
MS_bop_7(
    VOID
    )

/*++

Routine Description:

    Calls Vdm Redir Dispatcher. If the VDMREDIR DLL is not loaded, tries to
    load it before calling Dispatcher. If the DLL could not be loaded (or
    couldn't be loaded in the past) return an ERROR_INVALID_FUNCTION

Arguments:

    None.

Return Value:

    None.

--*/

{
    static int VdmRedirLoadState = 0;   // tristate:
                                        //  0 = not loaded, first attempt
                                        //  1 = loaded
                                        //  2 = tried loading already, failed


    //
    // new: VdmRedir support is now a DLL. Try to load it. If it can't be loaded
    // for whatever reason, return an error to the DOS program. Since it is
    // trying to call a Redir function, we will return ERROR_INVALID_FUNCTION
    //

    switch (VdmRedirLoadState) {
    case 0:

        //
        // the DLL is not yet loaded. If we can't load it and get the entry
        // points for any reason, return ERROR_INVALID_FUNCTION. From now on,
        // net support (including DLC, NetBIOS, named pipes and mailslots) will
        // not be available to DOS programs in this session (running as part of
        // this NTVDM process), but the rest of DOS functionality will be OK
        //

        if (LoadVdmRedir()) {
            VdmRedirLoadState = 1;
        } else {
            VdmRedirLoadState = 2;
            goto returnError;
        }

        //
        // fall through to dispatcher in case 1
        //

    case 1:

        //
        // VdmRedir is loaded: do it
        //

        VrDispatch((ULONG)(*Sim32GetVDMPointer(SEGOFF(getCS(),getIP()),
                                               1,
                                               (UCHAR)(getMSW() & MSW_PE ? TRUE : FALSE)
                                               )));
        break;

    case 2:

        //
        // we tried to load VdmRedir once, but the wheels fell off, so we don't
        // try it any more - just return an error, OK?
        //

returnError:
        setCF(1);
        setAX(ERROR_INVALID_FUNCTION);
        break;

#if DBG
    default:
        printf("MS_bop_7: BAD: VdmRedirLoadState=%d???\n", VdmRedirLoadState);
#endif
    }

    //
    // irrespective of whether the DLL is/was loaded or not, we must bump the
    // VDM ip past the BOP
    //

    setIP((USHORT)(getIP() + 1));
}

BOOL VdmRedirLoaded = FALSE;

BOOL IsVdmRedirLoaded() {
    return VdmRedirLoaded;
}

BOOL LoadVdmRedir() {

    HANDLE hVdmRedir;
#if DBG
    LPSTR  funcName = "";
#endif

    if (VdmRedirLoaded) {
        return TRUE;
    }

    if (hVdmRedir = LoadSystem32Library(L"VDMREDIR.DLL")) {

        //
        // get addresses of procedures called by functions in dos\dem\demfile.c
        // and dos\dem\demhndl.c
        //

        if ((VrDispatch = (MYFARPROC)GetProcAddress(hVdmRedir, "VrDispatch")) == NULL) {
#if DBG
            funcName = "VrDispatch";
#endif
            goto closeAndReturnError;
        }
        if ((VrInitialized = (MYFARPROC)GetProcAddress(hVdmRedir, "VrInitialized")) == NULL) {
#if DBG
            funcName = "VrInitialized";
#endif
            goto closeAndReturnError;
        }
        if ((VrReadNamedPipe = (MYFARPROC)GetProcAddress(hVdmRedir, "VrReadNamedPipe")) == NULL) {
#if DBG
            funcName = "VrReadNamedPipe";
#endif
            goto closeAndReturnError;
        }
        if ((VrWriteNamedPipe = (MYFARPROC)GetProcAddress(hVdmRedir, "VrWriteNamedPipe")) == NULL) {
#if DBG
            funcName = "VrWriteNamedPipe";
#endif
            goto closeAndReturnError;
        }
        if ((VrIsNamedPipeName = (MYFARPROC)GetProcAddress(hVdmRedir, "VrIsNamedPipeName")) == NULL) {
#if DBG
            funcName = "VrIsNamedPipeName";
#endif
            goto closeAndReturnError;
        }
        if ((VrIsNamedPipeHandle = (MYFARPROC)GetProcAddress(hVdmRedir, "VrIsNamedPipeHandle")) == NULL) {
#if DBG
            funcName = "VrIsNamedPipeHandle";
#endif
            goto closeAndReturnError;
        }
        if ((VrAddOpenNamedPipeInfo = (MYFARPROC)GetProcAddress(hVdmRedir, "VrAddOpenNamedPipeInfo")) == NULL) {
#if DBG
            funcName = "VrAddOpenNamedPipeInfo";
#endif
            goto closeAndReturnError;
        }
        if ((VrConvertLocalNtPipeName = (MYFARPROC)GetProcAddress(hVdmRedir, "VrConvertLocalNtPipeName")) == NULL) {
#if DBG
            funcName = "VrConvertLocalNtPipeName";
#endif
            goto closeAndReturnError;
        }
        if ((VrRemoveOpenNamedPipeInfo = (MYFARPROC)GetProcAddress(hVdmRedir, "VrRemoveOpenNamedPipeInfo")) == NULL) {
#if DBG
            funcName = "VrRemoveOpenNamedPipeInfo";
#endif
            goto closeAndReturnError;
        }
        VdmRedirLoaded = TRUE;
        return TRUE;
    }

closeAndReturnError:

#if DBG
        printf("MS_bop_7: Error: cannot locate entry point %s in VDMREDIR.DLL\n", funcName);
#endif

    UnloadSystem32Library(hVdmRedir);
    return FALSE;
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::: More MS BOP stubs */

void MS_bop_5(void)
{
    IMPORT VOID ms_bop(VOID);

    ms_bop();
}

//
// MS_BOP_8 : Third Party Bop
//
void ISV_RegisterModule (BOOL);
void ISV_DeRegisterModule (void);
void ISV_DispatchCall (void);

void MS_bop_8 (void)
{
    ULONG iFunc;
    UCHAR uchMode = getMSW() & MSW_PE ? TRUE : FALSE;


    // Get the Function Number
    iFunc = (ULONG)(*Sim32GetVDMPointer(SEGOFF(getCS(),getIP()),
                                        1,
                                        uchMode
                                        ));

    switch (iFunc) {
    case 0:    /* RegisterModule */
        ISV_RegisterModule (uchMode);
        break;
    case 1:    /* DeRegisterModule */
        ISV_DeRegisterModule ();
        break;
    case 2:    /* DispatchCall */
        ISV_DispatchCall ();
        break;
    default:
        setCF(1);
    }
    setIP((USHORT)(getIP() + 1));
    return;
}


//
// MS_BOP_9 : Direct Access Error bop. An app has tried to do something
// dubious. Tell the user about it. Picks up the type of the error from
// AX.
//
void MS_bop_9(void)
{
    host_direct_access_error((ULONG)getAX());
}

//
// MS_BOP_A : Idle control from VDD.
//   AX == 0: VDD wants VDM to idle. It will (briefly - 10ms) provided it
//            has not just seen some counter idle indication.
//   AX == 1: VDD wants VDM to wake up if still idling.
//
void MS_bop_A(void)
{
    word control;

    control = getAX();

    if (control == 0)
        WaitIfIdle();
    else
        if (control == 1)
            WakeUpNow();
#ifndef PROD
        else
            printf("NTVDM:Idle control from VDD bop passed bad AX value (%d)\n", control);
#endif
}


/*
 * DbgBreakPoint Jonle
 * A very simple way to break into the debugger from 16 bit
 * Apps registers are unmodified
 * Uses the safe DbgBreakPoint in ntvdm.c
 * On a free build when we are not being debugged, nothing will happen.
 * On a checked build when we are not being debugged, access violate
 * With debugger running breaks into 32 bit debugger
 */
void MS_bop_B(void)
{
  OutputDebugString("NTVDM:BOP_DBGBREAKPOINT\n");
  DbgBreakPoint();
}


//devices bop

extern  VOID nt_mscdexinit(VOID);
extern  VOID nt_mscdex(VOID);
typedef VOID (*PFNSVC)(VOID);

PFNSVC  apfnDevicesSVC [] = {
     nt_mscdexinit,     //SVC_DEVICES_MSCDEXINIT
     nt_mscdex,         //SVC_DEVICES_MSCDEX
};

void MS_bop_C(void)
{
    ULONG   DevicesCmd;
    USHORT  ip;

    ip = getIP();
    DevicesCmd = (ULONG)(*(PUCHAR)VdmMapFlat(getCS(), ip, VDM_V86));
    setIP((USHORT)(ip + 1));

    if (DevicesCmd >= SVC_DEVICES_LASTSVC){
#if DBG
        printf("MS_bop_C: Error: Unimplemented devices SVC index %x\n", DevicesCmd);
#endif
        setCF(1);
    }

    (apfnDevicesSVC [DevicesCmd])();
}


/*:::::::::::::::::::::::::::::::::: This bop is used to control iret hooks */

void MS_bop_D(void)
{
#ifdef MONITOR
    extern VOID MonitorEndIretHook(VOID);
    half_word iret_index;


    // get iret index
    iret_index = *Sim32GetVDMPointer(SEGOFF(getCS(),getIP()),
                                     1,
                                     (UCHAR)(getPE() ? TRUE : FALSE)
                                     );

    // Tell ica that an iret bop has been called
    ica_iret_hook_called((int) iret_index);

    //
    // Clean up stack, and resume normal code path
    //
    MonitorEndIretHook();
#else
    illegal_bop();
#endif

}

// Notification bop
// currently defined notification code is
// 00 -- config.sys processing completed.
//
extern  LARGE_INTEGER   CounterStart, FrequenceStart;

void MS_bop_E(void)
{
   unsigned char  code;

   code = getAL();
   if (code == 0) {
       UMBNotify(0);
       demDasdInit();
       }
   else {
#ifndef PROD
       printf("Invalid notification bop\n");
#endif
       }
}


void MS_bop_F(void)
{
    extern void kb_setup_vectors(void);

    kb_setup_vectors();

    //
    // Now that int10_seg and UseHostInt10 are initialized we can reflect the
    // current display state to BIOS if needed.
    //

    if (sc.ScreenState != STREAM_IO) {
        sas_store_no_check((int10_seg << 4) + useHostInt10, (half_word)sc.ScreenState);
    }

    //
    // Set idle counter settings, we set this each time we read pif file since
    // Defaults (from static code init):
    //     WNTPifFgPr = 100, with range of 0 to 200.
    //     minConsecutiveTicks = 50
    //     minFailedPolls = 8
    //

    {
    int minTicks, minPolls;

    // higher pri, requires more minimum consecutive ticks, and more minimum polls
    // scale minTicks where 50 == 100%
    // scale minPolls where 8 == 100%
    minTicks = (WNTPifFgPr >> 2) + 25;

    minPolls = (WNTPifFgPr << 3) / 100;
    if (minPolls < 4) {
        minPolls +=4;
        }

    idle_set(minPolls, minTicks);
    }


#ifdef MONITOR

    AddrIretBopTable = ( ((ULONG)getDS() << 16) | (ULONG)getDI() );

#ifndef PROD
    if (getCX() != VDM_RM_IRETBOPSIZE) {
        OutputDebugString("NTVDM:spacing != VDM_RM_IRETBOPSIZE\n");
        DebugBreak();
        }
#endif
#endif

    /*
     * Now that spckbd is loaded, and the ivt rom vectors are hooked
     * we can allow hw interrupts.
     */
    // nt_init_event_thread will resume the event thread after it
    // sync up BIOS led states with the system
    // ResumeThread(ThreadInfo.EventMgr.Handle);
    host_ica_lock();
    DelayIrqLine = 0;
    if (!ica_restart_interrupts(ICA_SLAVE))
        ica_restart_interrupts(ICA_MASTER);
    host_ica_unlock();

#ifdef MONITOR
    setCF(1);
#else
    setCF(0);
#endif
}


#define MAX_ISV_BOP  10

typedef struct _ISVBOP {
    FARPROC fpDispatch;
    HANDLE  hDll;
} ISVBOP;

#define MAX_PROC_NAME   64
char procbuffer [MAX_PROC_NAME];

ISVBOP isvbop_table [MAX_ISV_BOP];

void ISV_RegisterModule (BOOL fMode)
{
    char *pchDll,*pchInit,*pchDispatch;
    HANDLE hDll;
    FARPROC DispatchEntry;
    FARPROC InitEntry;
    ULONG i;
    UCHAR uchMode;

    // Check if we have free space in bop table.
    for (i=0; i<MAX_ISV_BOP; i++) {
    if (isvbop_table[i].hDll == 0)
        break;
    }

    if (i == MAX_ISV_BOP) {
    setCF (1);
    setAX(4);
    return;
    }

    uchMode = fMode ? TRUE : FALSE;

    pchDll = (PCHAR) Sim32GetVDMPointer (SEGOFF(getDS(),getSI()),
                                         1,
                                         uchMode
                                         );
    if (pchDll == NULL) {
    setCF (1);
    setAX(1);
    return;
    }
    pchInit = (PCHAR) Sim32GetVDMPointer(SEGOFF(getES(),getDI()),
                                         1,
                                         uchMode
                                         );

    pchDispatch = (PCHAR) Sim32GetVDMPointer(SEGOFF(getDS(),getBX()),
                                             1,
                                             uchMode
                                             );
    if (pchDispatch == NULL) {
    setCF (1);
    setAX(2);
    return;
    }

    if ((hDll = SafeLoadLibrary(pchDll)) == NULL){
    setCF (1);
    setAX(1);
    return;
    }

    // Get the init entry point and dispatch entry point
    if (pchInit){
    if ((ULONG)pchInit < 64*1024){
        if (strlen (pchInit) >= MAX_PROC_NAME) {
        FreeLibrary(hDll);
        setCF (1);
        setAX(4);
        return;
        }
        strcpy (procbuffer,pchInit);
        pchInit = procbuffer;
    }

    if ((InitEntry = (MYFARPROC)GetProcAddress(hDll, pchInit)) == NULL){
        FreeLibrary(hDll);
        setCF(1);
        setAX(3);
            return;
    }
    }

    if ((ULONG)pchDispatch < 64*1024){
    if (strlen (pchDispatch) >= MAX_PROC_NAME) {
        FreeLibrary(hDll);
        setCF (1);
        setAX(4);
        return;
    }
    strcpy (procbuffer,pchDispatch);
    pchDispatch = procbuffer;
    }

    if ((DispatchEntry = (MYFARPROC)GetProcAddress(hDll, pchDispatch)) == NULL){
    FreeLibrary(hDll);
    setCF(1);
    setAX(2);
    return;
    }

    // Call the init routine
    if (pchInit) {
    (*InitEntry)();
    }

    // Fill up the bop table
    isvbop_table[i].hDll = hDll;
    isvbop_table[i].fpDispatch = DispatchEntry;

    i++;

    setAX((USHORT)i);

    return;
}

void ISV_DeRegisterModule (void)
{
    ULONG  Handle;
    HANDLE hDll;

    Handle = (ULONG)getAX();
    if (Handle == 0 || Handle > MAX_ISV_BOP){
#ifndef PROD
    printf("Invalid BOP Handle Passed to DeRegisterModule");
#endif
    TerminateVDM();
    return;
    }
    Handle--;
    hDll = isvbop_table[Handle].hDll;
    FreeLibrary (hDll);
    isvbop_table[Handle].hDll = 0;
    isvbop_table[Handle].fpDispatch = NULL;
    return;
}

void ISV_DispatchCall (void)
{
    ULONG Handle;
    FARPROC DispatchEntry;

    Handle = (ULONG)getAX();
    if (Handle == 0 || Handle > MAX_ISV_BOP){
#ifndef PROD
    printf("Invalid BOP Handle Passed to DispatchCall");
#endif
    TerminateVDM();
    return;
    }
    Handle--;

    DispatchEntry = isvbop_table[Handle].fpDispatch;
    (*DispatchEntry)();
    return;
}

#ifdef i386
/*
 * "Safe" version of LoadLibrary which preserves floating-point state
 * across the load.  This is critical on x86 because the FP state being
 * preserved is the 16-bit app's state.  MSVCRT.DLL is one offender which
 * changes the Precision bits in its Dll init routine.
 *
 * On RISC, this is an alias for LoadLibrary
 *
 */
HINSTANCE SafeLoadLibrary(char *name)
{
    HINSTANCE hInst;
    BYTE FpuState[108];

    // Save the 487 state
    _asm {
        lea    ecx, [FpuState]
        fsave  [ecx]
    }

    hInst = LoadLibrary(name);

    // Restore the 487 state
    _asm {
        lea    ecx, [FpuState]
        frstor [ecx]
    }

    return hInst;
}
#endif  //i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\fprt.c ===
#include "windows.h"
#include "insignia.h"
#include "stdlib.h"
#include "stdio.h"
#include "stdarg.h"
#ifdef HUNTER
#include "nt_hunt.h"
#endif /* HUNTER */

void OutputString(char *);

int __cdecl printf(const char *str, ...)
{
#ifndef PROD
    va_list ap;
    char buf[500];

    va_start(ap,str);
    vsprintf(buf, str, ap);
    OutputString(buf);
    va_end(ap);
#endif
    return(0);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static HANDLE pipe=NULL;

void OutputString(char *str)
{
#ifndef PROD
    char StrSizeStr[2];
    int  StrSize;
    DWORD BytesWritten;

    /*............................................ Connect to debug pipe */

    if(pipe == NULL && getenv("PIPE") != NULL)
    {
        pipe = CreateFile(getenv("PIPE"),GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                          NULL);

        if(pipe == (HANDLE) -1)
            OutputDebugString("ntvdm : Failed to connect to debug pipe\n");
    }

    /*.................................................... Output string */

    if(pipe != NULL && pipe != (HANDLE) -1)
    {
        StrSize = strlen(str);
        StrSizeStr[0] = (char) (StrSize % 256);
        StrSizeStr[1] = (char) (StrSize / 256);

        WriteFile(pipe, StrSizeStr, 2, &BytesWritten, NULL);
        WriteFile(pipe, str, StrSize, &BytesWritten, NULL);
    }
    else
        OutputDebugString(str);

#endif
#ifdef HUNTER
    if (TrapperDump != (HANDLE) -1)
        WriteFile(TrapperDump, str, strlen(str), &BytesWritten, NULL);
#endif /* HUNTER */
}

#define WACKY_INPUT	"[BOB&SIMON'SCHEESYINPUT]"
#define WACKY_INPUTLEN	0xff

#define INPUT_API_SIG	0xdefaced

VOID InputString(char *str, int len)
{
#ifndef PROD

    char input_request[2];
    DWORD BytesWritten, BytesRead;
    int StringSize;
    UNALIGNED DWORD *addsig;
    char *inorout;
    IMPORT ULONG DbgPrompt(char *, char *, ULONG);

    if(pipe != NULL && pipe != (HANDLE) -1)
    {
        input_request[0] = (char)0xff; input_request[1] = (char)0xff;
        WriteFile(pipe, input_request, 2, &BytesWritten, NULL);

        ReadFile(pipe, str, 2, &BytesRead, NULL);
        StringSize = (str[0]&0xff) + ((str[1]&0xff)*256);

        if(StringSize >= len)
            OutputDebugString("ntvdm : PIPE BUFFER OVERFLOW [FATAL]\n");

        ReadFile(pipe, str, StringSize, &BytesRead, NULL);
    }
    else
    {
/* 
    We used to do this...
        DbgPrompt("",str,len);
    but foozle dust now does this...

    Call OutputDebugString with the following:

     "Message" | 0xdefaced | len | inBuffer

where "Message" is printed
      0xdefaced is a magic (DWORD) signature
      len is a byte length of,,,
      inBuffer which the reply to 'Message will appear in.
*/
        /* do this so we can add prompt passing if we wish */
        StringSize = strlen("") + 1;
	inorout = malloc(len + StringSize + 5);
        if (!inorout)
        {
            printf("\nmemory allocation failure - getting input via kd\n");
            DbgPrompt("NTVDM>> ", str, len);
            return;
        }
	strcpy(inorout, "");
	addsig = (PDWORD)&inorout[StringSize];
	*addsig = INPUT_API_SIG;
	*(inorout + StringSize+4) = (BYTE)len;
        *(inorout + StringSize+5) = (BYTE)0xff; // success flag
        OutputDebugString(inorout);
        // check for no debugger or debugger that can't speak foozle
        if (*(inorout + StringSize + 5) == 0xff)
            DbgPrompt("", str, len);
        else
	    strcpy(str, inorout + StringSize + 5);
        free(inorout);
    }

#endif
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

int __cdecl fprintf(FILE *tf, const char *str, ...)
{
#ifndef PROD
    va_list ap;
    char buf[500];

    if (getenv("TRACE") == NULL)        //JonLu request to limit debugs
        return(0);

    va_start(ap,str);
    vsprintf(buf, str, ap);
    va_end(ap);
    OutputString(buf);
#endif
    return(0);
}

char *nt_fgets(char *buffer, int len, void *input_stream)
{
    /* Get Line from debug terminal */
    buffer[0] = 0;
    InputString(buffer,len);

    return(buffer);
}

char *nt_gets(char *buffer)
{
    return(nt_fgets(buffer, 500, (void *) 0));
}

#ifndef HUNTER
char * __cdecl fgets(char *buffer, int len, FILE *input_stream)
{
    int blen;

    // If not processing call to STDIN pass on to standard library function
    if(input_stream != stdin)
    {
	char *ptr = buffer;
	int chr;

	while(--len && (chr = fgetc(input_stream)) != EOF)
	{
	    *ptr++ = (char) chr;
	    if(chr == '\n') break;
	}

	*ptr = (char) 0;
	return(chr == EOF ? NULL : buffer);

    }

    // clear buffer...
    for(blen = 0; blen < len; blen++)
	buffer[blen] = 0;
    nt_fgets(buffer, len, input_stream);
    blen = strlen(buffer);
    if (blen + 1 < len)
    {
	buffer[blen] = '\n';	/* fgets adds newline */
	buffer[blen+1] = '\0';
    }
    return(buffer);
}

char * __cdecl gets(char *buffer)
{
    return(nt_fgets(buffer, 80, (void *) 0));
}

int __cdecl puts(const char *buffer)
{
    OutputString((char *)buffer);
    return(1);
}

size_t __cdecl fwrite(const void *buf, size_t size, size_t len, FILE *stream)
{
    char    *tmp_buf;		// force the compiler into avoiding const chk

    tmp_buf = (char *)((DWORD)buf);

    tmp_buf[len] = 0;		// write into a const ptr!
#ifndef PROD
    OutputString((char *)buf);
#endif  /* PROD */
    return(len);
}
#endif  /* HUNTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_cga.c ===
/*
 * SoftPC Revision 3.0
 *
 * Title        : Win32 CGA Graphics Module
 *
 * Description  :
 *
 *              This modules contain the Win32 specific functions required
 *              to support CGA emulations.
 *
 * Author       : Jerry Sexton (based on module by John Shanly)
 *
 * Notes        :
 *
 */

#include <windows.h>
#include <string.h>

#include "insignia.h"
#include "host_def.h"

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "sas.h"
#include "gfx_upd.h"

#include "error.h"
#include <stdio.h>
#include "trace.h"
#include "debug.h"
#include "config.h"
#include "host_rrr.h"
#include "conapi.h"

#include "nt_graph.h"
#include "nt_cga.h"
#include "nt_cgalt.h"
#include "nt_det.h"

#ifdef MONITOR
    #include <ntddvdeo.h>
    #include "nt_fulsc.h"
#endif /* MONITOR */

#if defined(JAPAN) || defined(KOREA)
    #include "video.h"
#endif

/* Externs */

extern char *image_buffer;

/* Statics */

static unsigned int cga_med_graph_hi_nyb[256];
static unsigned int cga_med_graph_lo_nyb[256];
#ifdef BIGWIN
static unsigned int cga_med_graph_hi_lut_big[256];
static unsigned int cga_med_graph_mid_lut_big[256];
static unsigned int cga_med_graph_lo_lut_big[256];

static unsigned int cga_med_graph_lut4_huge[256];
static unsigned int cga_med_graph_lut3_huge[256];
static unsigned int cga_med_graph_lut2_huge[256];
static unsigned int cga_med_graph_lut1_huge[256];
#endif

/*
 *  cga_graph_inc_val depends on whether data is interleaved ( EGA/VGA )
 *  or not ( CGA ). Currently always interleaved.
 */
#define CGA_GRAPH_INCVAL 4

// likewise for TEXT_INCVAL
// for x86 we have 2 bytes per character (char and attr)
// for risc we have 4 bytes per character because of vga interleaving
//
#ifdef MONITOR
    #define TEXT_INCVAL 2
#else
    #define TEXT_INCVAL 4
#endif

#if (defined(JAPAN) || defined(KOREA)) && defined(i386)
    #undef TEXT_INCVAL
#endif // (JAPAN || KOREA) && i386

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Initialise CGA text output ::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_text()
{
    half_word misc;
    IMPORT void vga_misc_inb(io_addr, half_word *);

    /*::::::::::::::::::::::::::::::::::::: Tell trace program were we are */

    sub_note_trace0(HERC_HOST_VERBOSE, "nt_init_text");

#ifdef X86GFX
    if (sc.ScreenState == WINDOWED) //fullscreen valid - mouse buffer
#endif  //X86GFX
        closeGraphicsBuffer(); /* Tim Oct 92 */

#ifdef MONITOR
    vga_misc_inb(0x3cc, &misc);
    if (misc & 1)
        set_screen_ptr((UTINY *)CGA_REGEN_BUFF);        //point screen to regen not planes
    else
        set_screen_ptr((UTINY *)MDA_REGEN_BUFF);     //0xb0000 not 0xb8000
#endif  //MONITOR
#if defined(JAPAN) || defined(KOREA)
    // change Vram addres to DosVramPtr from B8000
    if ( !is_us_mode() )
    {
        #ifdef i386
        set_screen_ptr( (byte *)DosvVramPtr );
        #endif // i386
        set_char_height( 19 );
        #ifdef JAPAN_DBG
            #ifdef i386
        DbgPrint( "NTVDM: nt_init_text() sets VRAM %x, set char_height 19\n", DosvVramPtr );
            #endif // i386
        #endif
    }
#endif // JAPAN || KOREA
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Init CGA mono graph ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_cga_mono_graph()
{
    sub_note_trace0(CGA_HOST_VERBOSE,"nt_init_cga_mono_graph - NOT SUPPORTED");
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Init CGA colour med graphics:::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


void nt_init_cga_colour_med_graph()
{
    static boolean cga_colour_med_deja_vu = FALSE;
    unsigned int i,
    byte1,
    byte2,
    byte3,
    byte4;

    sub_note_trace0(CGA_HOST_VERBOSE, "nt_init_cga_colour_med_graph");

    /* Set up bits-per-pixel for current mode. */
    sc.BitsPerPixel = CGA_BITS_PER_PIXEL;

    /* Initialise look-up table for first call. */
    if ( !cga_colour_med_deja_vu )
    {
        for (i = 0; i < 256; i++)
        {
            byte1 = i & 0x03;
            byte2 = ( i & 0x0C ) >> 2;
            byte3 = ( i & 0x30 ) >> 4;
            byte4 = ( i & 0xC0 ) >> 6;

#ifdef BIGEND
            cga_med_graph_hi_nyb[i]
            = ( byte4 << 24 ) | ( byte4 << 16)
              | ( byte3 << 8 ) | byte3;
            cga_med_graph_lo_nyb[i]
            = ( byte2 << 24 ) | ( byte2 << 16)
              | ( byte1 << 8 ) | byte1;

    #ifdef BIGWIN
            cga_med_graph_hi_lut_big[i]
            = ( byte4 << 24 ) | ( byte4 << 16)
              | ( byte4 << 8 ) | byte3;
            cga_med_graph_mid_lut_big[i]
            = ( byte3 << 24) | ( byte3 << 16 )
              | ( byte2 << 8 ) | byte2;
            cga_med_graph_lo_lut_big[i]
            = ( byte2 << 24 ) | ( byte1 << 16)
              | ( byte1 << 8 ) | byte1;

            cga_med_graph_lut4_huge[i]
            = ( byte4 << 24 ) | ( byte4 << 16)
              | ( byte4 << 8 ) | byte4;

            cga_med_graph_lut3_huge[i]
            = ( byte3 << 24 ) | ( byte3 << 16)
              | ( byte3 << 8 ) | byte3;

            cga_med_graph_lut2_huge[i]
            = ( byte2 << 24 ) | ( byte2 << 16)
              | ( byte2 << 8 ) | byte2;

            cga_med_graph_lut1_huge[i]
            = ( byte1 << 24 ) | ( byte1 << 16)
              | ( byte1 << 8 ) | byte1;
    #endif /* BIGWIN */
#endif /* BIGEND */

#ifdef LITTLEND
            cga_med_graph_hi_nyb[i]
            = ( byte3 << 24 ) | ( byte3 << 16)
              | ( byte4 << 8 ) | byte4;
            cga_med_graph_lo_nyb[i]
            = ( byte1 << 24 ) | ( byte1 << 16)
              | ( byte2 << 8 ) | byte2;

    #ifdef BIGWIN
            cga_med_graph_hi_lut_big[i]
            = ( byte3 << 24 ) | ( byte4 << 16)
              | ( byte4 << 8 ) | byte4;
            cga_med_graph_mid_lut_big[i]
            = ( byte2 << 24) | ( byte2 << 16 )
              | ( byte3 << 8 ) | byte3;
            cga_med_graph_lo_lut_big[i]
            = ( byte1 << 24 ) | ( byte1 << 16)
              | ( byte1 << 8 ) | byte2;

            cga_med_graph_lut4_huge[i]
            = ( byte4 << 24 ) | ( byte4 << 16)
              | ( byte4 << 8 ) | byte4;

            cga_med_graph_lut3_huge[i]
            = ( byte3 << 24 ) | ( byte3 << 16)
              | ( byte3 << 8 ) | byte3;

            cga_med_graph_lut2_huge[i]
            = ( byte2 << 24 ) | ( byte2 << 16)
              | ( byte2 << 8 ) | byte2;

            cga_med_graph_lut1_huge[i]
            = ( byte1 << 24 ) | ( byte1 << 16)
              | ( byte1 << 8 ) | byte1;
    #endif /* BIGWIN */
#endif /* LITTLEND */

        }

        cga_colour_med_deja_vu = TRUE;
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::: Init CGA colour hi graphics:::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


void nt_init_cga_colour_hi_graph()
{
    sub_note_trace0(CGA_HOST_VERBOSE,"nt_init_cga_colour_hi_graph");

    /* Set up bits-per-pixel for current mode. */
    sc.BitsPerPixel = MONO_BITS_PER_PIXEL;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::: Output CGA text :::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

IMPORT int now_height, now_width;

void nt_text(int ScreenOffset, int ScreenX, int ScreenY,
             int len, int height)
{
    int org_clen, org_height;
    int clen=len/2;
    int lines;
    SMALL_RECT WriteRegion;
    PBYTE   to;
    PBYTE   pScreenText = get_screen_ptr(ScreenOffset);
    #if defined(JAPAN) && defined(i386)
    int TEXT_INCVAL = (!is_us_mode() &&
                       (sas_hw_at_no_check(DosvModePtr) == 0x73)) ? 4 : 2;
    #endif // JAPAN && i386
    #if defined(KOREA) && defined(i386)
    int TEXT_INCVAL = 2;
    #endif // KOREA && i386
    DWORD   bufferSize = textBufferSize.X * textBufferSize.Y * TEXT_INCVAL;

    /*:::::::::::::::::::::::::::::::::::::::::::: Output trace information */

    sub_note_trace6( CGA_HOST_VERBOSE,
                     "nt_cga_text off=%d x=%d y=%d len=%d h=%d o=%#x",
                     ScreenOffset, ScreenX, ScreenY, len, height, pScreenText );

    /*:::::::::::::: Adjust re-paint start location from pixels to characters */

    #ifndef MONITOR
    /* Adjust for RISC parameters being in pixels */
    ScreenX = ScreenX / get_pix_char_width();
    ScreenY = ScreenY / get_host_char_height();
    #endif

    /*:: Clip requested re-paint region to currently selected console buffer */

    //Clip width
    if (ScreenX + clen > now_width)
    {
        /* Is it possible to adjust the repaint regions width */
        if (ScreenX+1 >= now_width)
        {
            assert4(NO,"VDM: nt_text() repaint region out of ranged x:%d y:%d w:%d h:%d\n",
                    ScreenX, ScreenY, clen, height);
            return;
        }

        //Calculate maximum width
        org_clen = clen;
        clen = now_width - ScreenX;

        assert2(NO,"VDM: nt_text() repaint region width clipped from %d to %d\n",
                org_clen,clen);
    }

    //Clip height
    if (ScreenY + height > now_height)
    {
        /* Is it possible to adjust the repaint regions height */
        if (ScreenY+1 >= now_height)
        {
            assert4(NO,"VDM: nt_text() repaint region out of ranged x:%d y:%d w:%d h:%d\n",
                    ScreenX, ScreenY, clen, height);
            return;
        }

        //Calculate maximum height
        org_height = height;
        height = now_height - ScreenY;

        assert2(NO,"VDM: nt_text() repaint region height clipped from %d to %d\n",
                org_height,clen);
    }

    if (get_chars_per_line() == 80)
    {
        //
        // Slam Dunk Screen text buffer into shared buffer
        // by copying full width blocks instead of subrecs.
        //

        DWORD start = (ScreenY*get_offset_per_line()/2 + ScreenX)*TEXT_INCVAL;
        DWORD size = (((height - 1)*get_offset_per_line()/2) + clen)*TEXT_INCVAL;

        if (start < bufferSize)
        {
            if (size > bufferSize - start)
            {
                size = bufferSize - start;
            }
            RtlCopyMemory(&textBuffer[start], pScreenText, size);
        }
        else
        {
            return;
        }
    }
    else
    {
        // the sharing buffer width never changes((80 chars, decided at the
        // moment we make the RegisterConsoleVDM call to the console).
        // We have to do some transformation when our screen width is not
        // 80.

        // note that the sharing buffer has different format on x86 and RISC
        // platforms. On x86, a cell is defined as:
        //      typedef _x86cell {
        //              byte    char;
        //              byte    attributes;
        //              }
        // on RISC, a cell is defined as:
        //      typedef _RISCcell {
        //              byte    char;
        //              byte    attributes;
        //              byte    reserved_1;
        //              byte    reserved_2;
        //              }
        // the size of each cell was defined by TEXT_INCVAL
        //
        // this is done so we can use memcpy for each line.
        //


        /*::::::::::::::::::::::::::::::::::::::::::::: Construct output buffer */

        PBYTE endBuffer = &textBuffer[bufferSize] - clen * TEXT_INCVAL;

        //Start location of repaint region
        to = &textBuffer[(ScreenY*80 + ScreenX) * TEXT_INCVAL];

        for (lines = height; lines, to <= endBuffer; lines--)
        {
            RtlCopyMemory(to, pScreenText, clen * TEXT_INCVAL); // copy this line
            pScreenText += get_chars_per_line() * TEXT_INCVAL;  // update src ptr
            to += 80 * TEXT_INCVAL;                             // update dst ptr
        }
    }


    /*:::::::::::::::::::::::::::::::::::::::::::::: Calculate write region */

    WriteRegion.Left = (SHORT)ScreenX;
    WriteRegion.Top = (SHORT)ScreenY;

    WriteRegion.Bottom = WriteRegion.Top + height - 1;
    WriteRegion.Right = WriteRegion.Left + clen - 1;

    /*:::::::::::::::::::::::::::::::::::::::::::::::::: Display characters */

    sub_note_trace4( CGA_HOST_VERBOSE, "t=%d l=%d b=%d r=%d",
                     WriteRegion.Top, WriteRegion.Left,
                     WriteRegion.Bottom, WriteRegion.Right
                   );

    if (!InvalidateConsoleDIBits(sc.OutputHandle, &WriteRegion))
    {
        /*
        ** We get a rare failure here due to the WriteRegion
        ** rectangle being bigger than the screen.
        ** Dump out some values and see if it tells us anything.
        ** Have also attempted to fix it by putting a delay between
        ** the start of a register level mode change and window resize.
        */
        assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                 GetLastError() );
        assert4( NO, "VDM: rectangle t:%d l:%d b:%d r:%d",
                 WriteRegion.Top, WriteRegion.Left,
                 WriteRegion.Bottom, WriteRegion.Right
               );
        assert2( NO, "VDM: bpl=%d sl=%d",
                 get_bytes_per_line(), get_screen_length() );
    }

}   /* end of nt_text() */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::: Paints CGA graphics for a mono monitor, in a standard window :::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_mono_graph_std(int offset, int screen_x, int screen_y,
                           int len, int height )
{
    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_mono_graph_std off=%d x=%d y=%d len=%d height=%d - NOT SUPPORTED\n",
                    offset, screen_x, screen_y, len, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::: Paints CGA graphics for a mono monitor, in a big window :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_mono_graph_big(int offset, int screen_x, int screen_y,
                           int len, int height)
{
    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_mono_graph_big off=%d x=%d y=%d len=%d height=%d - NOT SUPPORTED\n",
                    offset, screen_x, screen_y, len, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::: Paints CGA graphics for a mono monitor, in a huge window ::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_mono_graph_huge(int offset, int screen_x, int screen_y,
                            int len, int height)
{
    sub_note_trace5( CGA_HOST_VERBOSE,
                     "nt_cga_mono_graph_huge off=%d x=%d y=%d len=%d height=%d - NOT SUPPORTED\n",
                     offset, screen_x, screen_y, len, height );
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Paints CGA medium res graphics for a colour monitor,in a standard window */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_colour_med_graph_std(int offset, int screen_x, int screen_y,
                                 int len, int height)
{
    UTINY       *intelmem_ptr;
    ULONG       *graph_ptr;
    LONG         local_len,
    bytes_per_scanline,
    longs_per_scanline;
    ULONG        inc;
    SMALL_RECT   rect;
    static int   rejections=0; /* Stop floods of rejected messages */

    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_colour_med_graph_std off=%d x=%d y=%d len=%d height=%d\n",
                    offset, screen_x, screen_y, len, height );

    /*
    ** Tim Jan 93, rapid mode changes cause mismatch between update and
    ** paint rountines. Ignore paint request when invalid parameter
    ** causes crash.
    */
    if ( screen_y > 400 )
    {
        assert1( NO, "VDM: med gfx std rejected y=%d\n", screen_y );
        return;
    }

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if ( sc.ScreenBufHandle == (HANDLE)NULL )
    {
        if ( rejections==0 )
        {
            assert0( NO, "VDM: rejected paint request due to NULL handle" );
            rejections = 1;
        }
        return;
    }
    else
    {
        rejections = 0;
    }

    /* Clip image to screen */
    if (height > 1 || len > 80)
        height = 1;
    if (len>80)
        len = 80;

    /* Work out the width of a line (ie 640 pixels) in chars and ints. */
    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);


    /* Build up DIB. */
    inc = offset & 1 ? 3 : 1;
    intelmem_ptr = get_screen_ptr(offset);
    graph_ptr = (ULONG *) ((UTINY *) sc.ConsoleBufInfo.lpBitMap +
                           (screen_y * bytes_per_scanline + screen_x));
    local_len = len;
    do
    {
        *(graph_ptr + longs_per_scanline) = *graph_ptr =
                                            cga_med_graph_hi_nyb[*intelmem_ptr];
        graph_ptr++;

        *(graph_ptr + longs_per_scanline) = *graph_ptr =
                                            cga_med_graph_lo_nyb[*intelmem_ptr];
        graph_ptr++;

        intelmem_ptr += inc;
        inc ^= 2;
    }
    while ( --local_len );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = (SHORT)screen_x;
    rect.Top = (SHORT)screen_y;
    rect.Right = rect.Left + (len << 3) - 1;
    rect.Bottom = rect.Top + (height << 1) - 1;

    if ( sc.ScreenBufHandle )
    {
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
            assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                     GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:: Paints CGA medium res graphics for a colour monitor, in a big window ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_colour_med_graph_big(int offset, int screen_x, int screen_y,
                                 int len, int height)
{
#ifdef BIGWIN
    UTINY       *intelmem_ptr;
    ULONG       *graph_ptr;
    LONG         local_len,
    bytes_per_scanline,
    longs_per_scanline;
    ULONG        inc;
    SMALL_RECT   rect;

    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_colour_med_graph_big off=%d x=%d y=%d len=%d height=%d\n",
                    offset, screen_x, screen_y, len, height);

    /*
    ** Tim Jan 93, rapid mode changes cause mismatch between update and
    ** paint rountines. Ignore paint request when invalid parameter
    ** causes crash.
    */
    if ( screen_y > 400 )
    {
        assert1( NO, "VDM: med gfx big rejected y=%d\n", screen_y );
        return;
    }

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if ( sc.ScreenBufHandle == (HANDLE)NULL )
    {
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* Clip to window */
    height = 1;
    if (len > 80)
        len = 80;

    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    inc = offset & 1 ? 3 : 1;
    intelmem_ptr = get_screen_ptr(offset);
    graph_ptr = (ULONG *) ((UTINY *) sc.ConsoleBufInfo.lpBitMap +
                           SCALE(screen_y * bytes_per_scanline + screen_x));
    local_len = len;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        *(graph_ptr + 2 * longs_per_scanline) =
        *(graph_ptr + longs_per_scanline) =
        *graph_ptr =
        cga_med_graph_hi_lut_big[*intelmem_ptr];
        graph_ptr++;

        *(graph_ptr + 2 * longs_per_scanline) =
        *(graph_ptr + longs_per_scanline) =
        *graph_ptr =
        cga_med_graph_mid_lut_big[*intelmem_ptr];
        graph_ptr++;

        *(graph_ptr + 2 * longs_per_scanline) =
        *(graph_ptr + longs_per_scanline) =
        *graph_ptr =
        cga_med_graph_lo_lut_big[*intelmem_ptr];
        graph_ptr++;

        intelmem_ptr += inc;
        inc ^= 2;
    }
    while ( --local_len );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE(len << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    if ( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
            assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                     GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*: Paints CGA medium res graphics for a colour monitor, in a huge window. :*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_colour_med_graph_huge(int offset, int screen_x, int screen_y,
                                  int len, int height)
{
#ifdef BIGWIN
    UTINY       *intelmem_ptr;
    ULONG       *graph_ptr;
    LONG         local_len,
    bytes_per_scanline,
    longs_per_scanline;
    ULONG        inc;
    SMALL_RECT   rect;

    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_colour_med_graph_huge off=%d x=%d y=%d len=%d height=%d\n",
                    offset, screen_x, screen_y, len, height );

    /*
    ** Tim Jan 93, rapid mode changes cause mismatch between update and
    ** paint rountines. Ignore paint request when invalid parameter
    ** causes crash.
    */
    if ( screen_y > 400 )
    {
        assert1( NO, "VDM: med gfx huge rejected y=%d\n", screen_y );
        return;
    }

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if ( sc.ScreenBufHandle == (HANDLE)NULL )
    {
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* Clip to window */
    height = 1;
    if (len > 80)
        len = 80;

    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    inc = offset & 1 ? 3 : 1;
    intelmem_ptr = get_screen_ptr(offset);
    graph_ptr = (ULONG *) ((UTINY *) sc.ConsoleBufInfo.lpBitMap +
                           SCALE(screen_y * bytes_per_scanline + screen_x));
    local_len = len;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        *(graph_ptr + 3 * longs_per_scanline) =
        *(graph_ptr + 2 * longs_per_scanline) =
        *(graph_ptr + longs_per_scanline) =
        *graph_ptr = cga_med_graph_lut4_huge[*intelmem_ptr];
        graph_ptr++;

        *(graph_ptr + 3 * longs_per_scanline) =
        *(graph_ptr + 2 * longs_per_scanline) =
        *(graph_ptr + longs_per_scanline) =
        *graph_ptr = cga_med_graph_lut3_huge[*intelmem_ptr];
        graph_ptr++;

        *(graph_ptr + 3 * longs_per_scanline) =
        *(graph_ptr + 2 * longs_per_scanline) =
        *(graph_ptr + longs_per_scanline) =
        *graph_ptr = cga_med_graph_lut2_huge[*intelmem_ptr];
        graph_ptr++;

        *(graph_ptr + 3 * longs_per_scanline) =
        *(graph_ptr + 2 * longs_per_scanline) =
        *(graph_ptr + longs_per_scanline) =
        *graph_ptr = cga_med_graph_lut1_huge[*intelmem_ptr];
        graph_ptr++;

        intelmem_ptr += inc;
        inc ^= 2;
    }
    while (--local_len);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE(len << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    if ( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
            assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                     GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*: Paints CGA high res graphics for a colour monitor, in a standard window */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_colour_hi_graph_std(int offset, int screen_x, int screen_y,
                                int len, int height)
{
    register char   *intelmem,
    *bufptr;
    register int     i;
    int              bytes_per_scanline;
    SMALL_RECT       rect;
    static int       rejections=0; /* Stop floods of rejected messages */

    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_colour_hi_graph_std off=%d x=%d y=%d len=%d height=%d\n",
                    offset, screen_x, screen_y, len, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if ( sc.ScreenBufHandle == (HANDLE)NULL )
    {
        if ( rejections == 0 )
        {
            assert0( NO, "VDM: rejected paint request due to NULL handle" );
            rejections = 1;
        }
        return;
    }
    else
        rejections=0;

    /* Clip to window */
    height = 1;
    if (len > 80)
        len = 80;

    /* Work out offset, in bytes, of pixel directly below current pixel. */
    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /*
     * Build up DIB data. In 200-line CGA mode, pixels are double height so
     * one line of PC pixels is equivalent to two lines of host pixels.
     * Note: `height' parameter is always 1 when this function is called so
     * only 1 line at a time is updated.
     */
    intelmem = (char *) get_screen_ptr(offset);

    bufptr =  (char *) sc.ConsoleBufInfo.lpBitMap +
              screen_y * bytes_per_scanline +
              (screen_x >> 3);
    for ( i = len; i > 0; i-- )
    {
        *(bufptr + bytes_per_scanline) = *bufptr = *intelmem;
        intelmem += CGA_GRAPH_INCVAL;
        bufptr++;
    }

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = (SHORT)screen_x;
    rect.Top = (SHORT)screen_y;
    rect.Right = rect.Left + (len << 3) - 1;
    rect.Bottom = rect.Top + (height << 1) - 1;

    if ( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
            assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                     GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Paints CGA high res graphics for a colour monitor, in a big window :::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_colour_hi_graph_big(int offset, int screen_x, int screen_y,
                                int len, int height)
{
#ifdef BIGWIN
    register char   *intelmem,
    *bufptr;
    register int    i;
    char            *buffer;
    int             bytes_per_scanline;
    SMALL_RECT      rect;

    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_colour_hi_graph_big off=%d x=%d y=%d len=%d height=%d\n",
                    offset, screen_x, screen_y, len, height );
    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if ( sc.ScreenBufHandle == (HANDLE)NULL )
    {
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* Clip to window */
    height = 1;
    if (len > 80)
        len = 80;

    /*
     * In this mode each byte becomes 12 bits (1.5 screen size) so if screen_x
     * is on an odd byte boundary the resulting bitmap starts on a half-byte
     * boundary. To avoid this set screen_x to the previous even byte.
     */
    if (screen_x & 8)
    {
        screen_x -= 8;
        offset -= CGA_GRAPH_INCVAL;
        len++;
    }

    /* `len' must be even for `high_stretch3' to work. */
    if (len & 1)
        len++;

    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    bufptr = buffer = (char *) sc.ConsoleBufInfo.lpBitMap +
             SCALE(screen_y * bytes_per_scanline + (screen_x >> 3));
    intelmem = (char *) get_screen_ptr(offset);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    for (i = len; i > 0; i--)
    {
        *bufptr = *intelmem;
        intelmem += CGA_GRAPH_INCVAL;
        bufptr++;
    }

    high_stretch3((unsigned char *) buffer, len);

    memcpy(buffer + bytes_per_scanline, buffer, SCALE(len));
    memcpy(buffer + 2 * bytes_per_scanline, buffer, SCALE(len));

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE(len << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    if ( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
            assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                     GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Paints CGA high res graphics for a colour monitor, in a huge window ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_colour_hi_graph_huge(int offset, int screen_x, int screen_y,
                                 int len, int height )
{
#ifdef BIGWIN
    register char   *intelmem,
    *bufptr;
    char            *buffer;
    register int    i;
    int             bytes_per_scanline;
    SMALL_RECT      rect;

    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_colour_hi_graph_huge off=%d x=%d y=%d len=%d height=%d\n",
                    offset, screen_x, screen_y, len, height );
    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if ( sc.ScreenBufHandle == (HANDLE)NULL )
    {
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* Clip to window */
    height = 1;
    if (len > 80)
        len = 80;

    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    intelmem = (char *) get_screen_ptr(offset);
    bufptr = buffer = (char *) sc.ConsoleBufInfo.lpBitMap +
             SCALE(screen_y * bytes_per_scanline + (screen_x >> 3));

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    for ( i = len; i > 0; i-- )
    {
        *bufptr = *intelmem;
        intelmem += CGA_GRAPH_INCVAL;
        bufptr++;
    }

    high_stretch4((unsigned char *) buffer, len);

    memcpy(buffer + bytes_per_scanline, buffer, SCALE(len));
    memcpy(buffer + 2 * bytes_per_scanline, buffer, SCALE(len));
    memcpy(buffer + 3 * bytes_per_scanline, buffer, SCALE(len));

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE(len << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    if ( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
            assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                     GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

#ifdef MONITOR
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Paints CGA medium res graphics frozen window.                            */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_med_frozen_std(int offset, int screen_x, int screen_y, int len,
                           int height)
{
    UTINY       *plane1_ptr,
    *plane2_ptr,
    data;
    ULONG       *graph_ptr,
    longs_per_scanline,
    local_len,
    mem_x = screen_x >> 3,
    mem_y = screen_y >> 1,
    max_width = sc.PC_W_Width >> 3,
    max_height = sc.PC_W_Height >> 1;
    SMALL_RECT   rect;

    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_med_frozen_std off=%d x=%d y=%d len=%d height=%d\n",
                    offset, screen_x, screen_y, len, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if ( sc.ScreenBufHandle == (HANDLE)NULL )
    {
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((mem_x >= max_width) || (mem_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_cga_med_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (mem_x + len > max_width)
        len = max_width - mem_x;
    if (mem_y + height > max_height)
        height = max_height - mem_y;

    /* Work out the width of a line (ie 640 pixels) in ints. */
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);

    /* memory in this routine liable to be removed by fullscreen switch */
    try
    {
        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        /* Set up data pointers. */
        graph_ptr = (ULONG *) sc.ConsoleBufInfo.lpBitMap +
                    screen_y * longs_per_scanline + (screen_x >> 2);
        plane1_ptr = GET_OFFSET(Plane1Offset);
        plane2_ptr = GET_OFFSET(Plane2Offset);

        /* Each iteration of the loop processes 2 host bytes. */
        local_len = len >> 1;

        /* 'offset' is designed for interleaved planes. */
        offset >>= 1;

        /* 'height' is always 1 so copy a line to the bitmap. */
        do
        {
            data = *(plane1_ptr + offset);
            *(graph_ptr + longs_per_scanline) = *graph_ptr =
                                                cga_med_graph_hi_nyb[data];
            graph_ptr++;
            *(graph_ptr + longs_per_scanline) = *graph_ptr =
                                                cga_med_graph_lo_nyb[data];
            graph_ptr++;
            data = *(plane2_ptr + offset);
            *(graph_ptr + longs_per_scanline) = *graph_ptr =
                                                cga_med_graph_hi_nyb[data];
            graph_ptr++;
            *(graph_ptr + longs_per_scanline) = *graph_ptr =
                                                cga_med_graph_lo_nyb[data];
            graph_ptr++;
            offset += 2;
        }
        while (--local_len);

        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        /* Display the new image. */
        rect.Left = (SHORT)screen_x;
        rect.Top = (SHORT)screen_y;
        rect.Right = rect.Left + (len << 3) - 1;
        rect.Bottom = rect.Top + (height << 1) - 1;

        if ( sc.ScreenBufHandle )
        {
            if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        }
    }except(EXCEPTION_EXECUTE_HANDLER)
    {
        assert0(NO, "Handled fault in nt_cga_med_frozen_std. fs switch?");
        return;
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Paints CGA high res graphics frozen window.                            */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_cga_hi_frozen_std(int offset, int screen_x, int screen_y, int len,
                          int height)
{
    UTINY       *plane1_ptr,
    *graph_ptr;
    ULONG        bytes_per_scanline,
    local_len,
    mem_x = screen_x >> 3,
    mem_y = screen_y >> 1,
    max_width = sc.PC_W_Width >> 3,
    max_height = sc.PC_W_Height >> 1;
    SMALL_RECT   rect;

    sub_note_trace5(CGA_HOST_VERBOSE,
                    "nt_cga_hi_frozen_std off=%d x=%d y=%d len=%d height=%d\n",
                    offset, screen_x, screen_y, len, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if ( sc.ScreenBufHandle == (HANDLE)NULL )
    {
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((mem_x >= max_width) || (mem_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_cga_hi_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (mem_x + len > max_width)
        len = max_width - mem_x;
    if (mem_y + height > max_height)
        height = max_height - mem_y;

    /* memory here liable to be removed by fullscreen switch */
    try
    {
        /* Work out the width of a line (ie 640 pixels) in ints. */
        bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);

        /* 'offset' is designed for interleaved planes. */
        offset >>= 2;

        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        /* Set up data pointers. */
        graph_ptr = (UTINY *) sc.ConsoleBufInfo.lpBitMap +
                    screen_y * bytes_per_scanline + screen_x;
        plane1_ptr = GET_OFFSET(Plane1Offset) + offset;

        /* 'height' is always 1 so copy a line to the bitmap. */
        local_len = len;
        do
        {
            *(graph_ptr + bytes_per_scanline) = *graph_ptr = *plane1_ptr++;
            graph_ptr++;
        }
        while (--local_len);

        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        /* Display the new image. */
        rect.Left = (SHORT)screen_x;
        rect.Top = (SHORT)screen_y;
        rect.Right = rect.Left + (len << 3) - 1;
        rect.Bottom = rect.Top + (height << 1) - 1;

        if ( sc.ScreenBufHandle )
        {
            if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        }
    }except(EXCEPTION_EXECUTE_HANDLER)
    {
        assert0(NO, "Handled fault in nt_ega_hi_frozen_std. fs switch?");
        return;
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Dummy paint routine for frozen screens.                             ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_dummy_frozen(int offset, int screen_x, int screen_y, int len,
                     int height)
{
    assert0(NO, "Frozen screen error - dummy paint routine called.");
}
#endif /* MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_98grf.c ===
#if defined(NEC_98)
/*
 * SoftPC Revision 3.0
 *
 * Title        : Win32 NEC_98 Graphics Module
 *
 * Description  :
 *
 *              This modules contain the Win32 specific functions required
 *              to support the NEC_98 emulation.
 *
 * Author       : Age Sakane(NEC)
 *
 * Notes        : This code modify to source of nt_ega.c
 *
 * Date         : Start 93/7/15
 *
 */

#include <windows.h>
#include <string.h>
#include <memory.h>

#include "insignia.h"
#include "host_def.h"

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "sas.h"
#include "gfx_upd.h"
#include <stdio.h>
#include "trace.h"
#include "debug.h"

/* Not support video
#include "egagraph.h"
#include "egacpu.h"
#include "egaports.h"
*/

////////////#include "hostgrph.h"
#include "host_rrr.h"

#include <conapi.h>
#include "nt_graph.h"

/* No need
#include "nt_ega.h"
#include "nt_egalt.h"
*/

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: IMPORTS */

IMPORT int DisplayErrorTerm(int, DWORD, char *, int);
IMPORT void nt_text20(int, int, int, int, int);
IMPORT void nt_text25(int, int, int, int, int);
IMPORT void nt_init_text20(void);
IMPORT void nt_init_text25(void);

/* Statics */
static unsigned int NEC98_graph_luts[2048];

/* Virtual Vram interleave fixed number */

#define Vraminterleave 32*1024

/* Prototype for local function */
void NEC_98_graph_munge(unsigned char *, int ,unsigned int *,unsigned int *,int , int);
void nt_init_graph_luts(void);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::: Initialise NEC_98 colour graphics ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_graph_luts()
{
   static boolean  NEC98_colour_graph_deja_vu = FALSE;
   unsigned int    i,
                   byte0,
                   byte1,
                   byte2,
                   byte3,
                   byte4,
                   byte5,
                   byte6,
                   byte7,
                   or_of_bytes1,
                   or_of_bytes2,
                   *lut0_ptr = &NEC98_graph_luts[0],
                   *lut1_ptr = lut0_ptr + LUT_OFFSET,
                   *lut2_ptr = lut1_ptr + LUT_OFFSET,
                   *lut3_ptr = lut2_ptr + LUT_OFFSET;

   sub_note_trace0(EGA_HOST_VERBOSE,"nt_init_graph_luts");

   if (NEC98_colour_graph_deja_vu)
       return;

   NEC98_colour_graph_deja_vu = TRUE;

   /* Initialise look-up table for first call. */
   for( i = 0; i < 256; i++ )
   {
       byte0 = i & 0x1;
       byte1 = ( i & 0x2 ) >> 1;
       byte2 = ( i & 0x4 ) >> 2;
       byte3 = ( i & 0x8 ) >> 3;
       byte4 = ( i & 0x10 ) >> 4;
       byte5 = ( i & 0x20 ) >> 5;
       byte6 = ( i & 0x40 ) >> 6;
       byte7 = ( i & 0x80 ) >> 7;

       or_of_bytes1 = ( byte0 << 24 ) | ( byte1 << 16 ) | ( byte2 << 8 ) | byte3;
       or_of_bytes2 = ( byte4 << 24 ) | ( byte5 << 16 ) | ( byte6 << 8 ) | byte7;

       /* Graph 16 color palette assigned to Windows NT palette from 20h to 2fh of palette index */
       lut0_ptr[2*i]   = or_of_bytes2 | 0x20202020;
       lut0_ptr[2*i+1] = or_of_bytes1 | 0x20202020;
       lut1_ptr[2*i]   = (or_of_bytes2 << 1) | 0x20202020;
       lut1_ptr[2*i+1] = (or_of_bytes1 << 1) | 0x20202020;
       lut2_ptr[2*i]   = (or_of_bytes2 << 2) | 0x20202020;
       lut2_ptr[2*i+1] = (or_of_bytes1 << 2) | 0x20202020;
       lut3_ptr[2*i]   = (or_of_bytes2 << 3) | 0x20202020;
       lut3_ptr[2*i+1] = (or_of_bytes1 << 3) | 0x20202020;
   }
}  /* nt_init_graph_luts */

/*
 * NEC98_graph_munge
 *
 * PURPOSE:    Munge interleaved EGA plane data to bitmap form using lookup tables.
 * INPUT:      (unsigned char *) plane0_ptr - ptr to plane0 data
 *                     (int) width - # of groups of 4 bytes on the line
 *                     (unsigned int *) dest_ptr - ptr to output buffer
 *                     (unsigned int *) lut0_ptr - munging luts
 *                     (int) height - # of scanlines to output (1 or 2)
 *                     (int) line_offset - distance to next scanline
 * OUTPUT:     A nice bitmap in dest_ptr
 *
 */
 
void NEC98_graph_munge(unsigned char *plane0_ptr, int width,unsigned int *dest_ptr,
                      unsigned int *lut0_ptr,int height, int line_offset)
{

        unsigned int    *lut1_ptr = lut0_ptr + LUT_OFFSET;
        unsigned int    *lut2_ptr = lut1_ptr + LUT_OFFSET;
        unsigned int    *lut3_ptr = lut2_ptr + LUT_OFFSET;
        FAST unsigned int       hi_res;
        FAST unsigned int       lo_res;
        FAST unsigned int       *l_ptr;
        FAST half_word          *dataP0;
        FAST half_word          *dataP1;
        FAST half_word          *dataP2;
        FAST half_word          *dataP3;
   
        /* make sure we get the line offset in ints not bytes */
        line_offset /= sizeof(int);
    
        dataP3 = (half_word *) plane0_ptr;
        dataP0 = (half_word *) dataP3 + Vraminterleave;
        dataP1 = (half_word *) dataP0 + Vraminterleave;
        dataP2 = (half_word *) dataP1 + Vraminterleave;
   
    for ( ; width > 0; width--)
    {
           /* Get 8 bytes (2 longs) of output data from 1 byte of plane 0
           ** data
           */

           l_ptr = &lut3_ptr [*dataP3++*2];
           hi_res = *l_ptr++;
           lo_res = *l_ptr;

           /* Or in the output data from plane 1 */
           l_ptr = &lut0_ptr [*dataP0++*2];
           hi_res |= *l_ptr++;
           lo_res |= *l_ptr;
   
           /* Or in the output data from plane 2 */
           l_ptr = &lut1_ptr [*dataP1++*2];
           hi_res |= *l_ptr++;
           lo_res |= *l_ptr;

           /* Or in the output data from plane 3 */
           l_ptr = &lut2_ptr [*dataP2++*2];
           hi_res |= *l_ptr++;
           lo_res |= *l_ptr;

           /* Output the data to the buffer */
           if (height == 2)
           {
                   /* scanline doubling */
                   *(dest_ptr + line_offset) = hi_res;
                   *dest_ptr++ = hi_res;
                   *(dest_ptr + line_offset) = lo_res;
                   *dest_ptr++ = lo_res;
           }
           else if (height == 3)
           {
                   /* scanline sliting */
                   *(dest_ptr + line_offset) = (unsigned int)0;
                   *dest_ptr++ = hi_res;
                   *(dest_ptr + line_offset) = (unsigned int)0;
                   *dest_ptr++ = lo_res;
                   
           }
           else
           {
                   /* not scanline doubling */
                   *dest_ptr++ = hi_res;
                   *dest_ptr++ = lo_res;
           }
    }
} /* NEC98_graph_munge */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise graphics 200 ::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_graph200_only()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_graph200_only");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();
} /* nt_init_graph200_only */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise graphics 200 slt ::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_graph200slt_only()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_graph200slt_only");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();
} /* nt_init_graph200slt_only */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise graphics 400 ::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_graph400_only()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_graph400_only");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();

} /* nt_init_graph400_only */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise text20 & graphics 200 :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_text20_graph200()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_text20_graph200");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();
        nt_init_text20();
} /* nt_init_text20_graph200 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise text20 & graphics 200 slt::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_text20_graph200slt()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_text20_graph200");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();
        nt_init_text20();
} /* nt_init_text20_graph200slt */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise text25 & graphics 200 :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_text25_graph200()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_text25_graph200");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();
        nt_init_text25();
} /* nt_init_text25_graph200 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise text25 & graphics 200 slt :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_text25_graph200slt()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_text25_graph200");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();
        nt_init_text25();
} /* nt_init_text25_graph200slt */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise text20 & graphics 400 :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_text20_graph400()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_text20_graph400");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();
        nt_init_text20();
} /* nt_init_text20_graph400 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise text25 & graphics 400 :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_text25_graph400()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_text25_graph400");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = VGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_graph_luts();
        nt_init_text25();
} /* nt_init_text25_graph400 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::: Paint screen with text ::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 640x200 graph only ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_graph200_only(int offset, int screen_x, int screen_y,int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;
    
    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_graph200_only off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );
#if 0
   /* Beta 2' no support */
   return;
#endif

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height > charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height() / 2;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            TWO_SCANLINES,
                            bytes_per_line);

        ref_dest_ptr += TWO_SCANLINES * bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y << 1);
    rect.Right = rect.Left + SCALE( (width * get_char_width()) ) - 1;
    rect.Bottom = rect.Top + SCALE( ((height << 1) * get_char_height()) ) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

} /* nt_graph200_only */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 640x200 slt graph only ::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_graph200slt_only(int offset, int screen_x, int screen_y,int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;
    
    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_graph200_only off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );
#if 0
   /* Beta 2' no support */
   return;
#endif

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height > charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height() / 2;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            THREE_SCANLINES,
                            bytes_per_line);

        ref_dest_ptr += TWO_SCANLINES * bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y << 1);
    rect.Right = rect.Left + SCALE( (width * get_char_width()) ) - 1;
    rect.Bottom = rect.Top + SCALE( ((height << 1) * get_char_height()) ) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

} /* nt_graph200_only */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 640x400 graph only ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_graph400_only(int offset, int screen_x, int screen_y,int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;


    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_graph400_only off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );
                    
#if 0
    /* Beta 2' no support */
    return;
#endif

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height>charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height();
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            ONE_SCANLINE,
                            0);

        ref_dest_ptr += bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE( (width * get_char_width()) ) - 1;
    rect.Bottom = rect.Top + SCALE( (height * get_char_height()) ) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

} /* nt_graph400_only */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 80x20 640x200 :::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_text20_graph200(int offset, int screen_x, int screen_y,int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_text20_graph200 off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

#if 0
   /* Beta 2' no support */
   return;
#endif

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height>charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height() / 2;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            TWO_SCANLINES,
                            bytes_per_line);

        ref_dest_ptr += TWO_SCANLINES * bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    nt_text20(offset, screen_x, screen_y, width, height);

} /* nt_text20_graph200 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 80x20 640x200 slt :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_text20_graph200slt(int offset, int screen_x, int screen_y,int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_text20_graph200 off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

#if 0
   /* Beta 2' no support */
   return;
#endif

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height>charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height() / 2;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            THREE_SCANLINES,
                            bytes_per_line);

        ref_dest_ptr += TWO_SCANLINES * bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    nt_text20(offset, screen_x, screen_y, width, height);

} /* nt_text20_graph200slt */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 80x25 640x200 :::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_text25_graph200(int offset, int screen_x, int screen_y,int width, int height)
{

    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_text25_graph200 off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

#if 0
   /* Beta 2' no support */
   return;
#endif

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height>charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height() / 2;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            TWO_SCANLINES,
                            bytes_per_line);

        ref_dest_ptr += TWO_SCANLINES * bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    nt_text25(offset, screen_x, screen_y, width, height);
} /* nt_text25_graph200 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 80x25 640x200 :::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_text25_graph200slt(int offset, int screen_x, int screen_y,int width, int height)
{

    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_text25_graph200 off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

#if 0
   /* Beta 2' no support */
   return;
#endif

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height>charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height() / 2;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            THREE_SCANLINES,
                            bytes_per_line);

        ref_dest_ptr += TWO_SCANLINES * bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    nt_text25(offset, screen_x, screen_y, width, height);
} /* nt_text25_graph200slt */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 80x20 640x400 :::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_text20_graph400(int offset, int screen_x, int screen_y,int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;

    /* Beta 2' no support */
    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_text20_graph400 off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );
#if 0
   return;
#endif

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height>charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height();
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            ONE_SCANLINE,
                            0);

        ref_dest_ptr += bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */

/* No need code ???
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE(width) - 1;
    rect.Bottom = rect.Top + SCALE(height) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
 No need code */

    nt_text20(offset, screen_x, screen_y, width, height);
} /* nt_text20_graph400 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen 80x25 640x400 :::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_text25_graph400(int offset, int screen_x, int screen_y,int width, int height)
{

    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;
    int charcheck;

    sub_note_trace5(EGA_HOST_VERBOSE,
                 "nt_text25_graph400 off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    charcheck = get_char_height() == 20 ? 20 : 25;
    if( height>charcheck || width>160 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height * get_char_height();
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    
    ref_data_ptr = get_graph_ptr() + get_gvram_start_offset();

    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        NEC98_graph_munge((unsigned char *) data_ptr,
                            width/2,
                            (unsigned int *) dest_ptr,
                            NEC98_graph_luts,
                            ONE_SCANLINE,
                            0);

        ref_dest_ptr += bytes_per_line;
        ref_data_ptr += get_offset_per_line()/2;

    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */

/* No need code ???
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE(width) - 1;
    rect.Bottom = rect.Top + SCALE(height) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
 No need code */

     nt_text25(offset, screen_x, screen_y, width, height);
} /* nt_text25_graph400 */

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_aorc.c ===
/*
============================== nt_a_or_c.c ===================================

    This file provides a crude means of mapping a cpu specific function
    to a generically used function. Microsoft libraries to which we do not
    have the source, call getXX and setXX functions directly and thus a mapping
    is required if a C emulator is built or an assembly language variant is
    used.

    For example:

    If CCPU is defined, then getAX() maps to c_getAX(),
    If A3CPU is defined, then getAX() maps to a3_getAX(),

    Unfortunately, this does not allow a pigger to build.

    Andy Watson 3/11/94

==============================================================================
*/

#include "insignia.h"
#include "host_def.h"
#define CPU_PRIVATE
#include "cpu4.h"
#include "sas.h"

#ifdef CCPU

/*
 *
 * CCPU interface to the emulator registers.
 *
 */

#undef getAL
GLOBAL half_word	getAL()
{
	return c_getAL();
}

#undef getBL
GLOBAL half_word	getBL()
{
	return c_getBL();
}

#undef getCL
GLOBAL half_word	getCL()
{
	return c_getCL();
}

#undef getDL
GLOBAL half_word	getDL()
{
	return c_getDL();
}

#undef getAH
GLOBAL half_word	getAH()
{
	return c_getAH();
}

#undef getBH
GLOBAL half_word	getBH()
{
	return c_getBH();
}

#undef getCH
GLOBAL half_word	getCH()
{
	return c_getCH();
}

#undef getDH
GLOBAL half_word	getDH()
{
	return c_getDH();
}

#undef getAX
GLOBAL word		getAX()
{
	return c_getAX();
}

#undef getBX
GLOBAL word		getBX()
{
	return c_getBX();
}

#undef getCX
GLOBAL word		getCX()
{
	return c_getCX();
}

#undef getDX
GLOBAL word		getDX()
{
	return c_getDX();
}

#undef getSP
GLOBAL word		getSP()
{
	return c_getSP();
}

#undef getBP
GLOBAL word		getBP()
{
	return c_getBP();
}

#undef getSI
GLOBAL word		getSI()
{
	return c_getSI();
}

#undef getDI
GLOBAL word		getDI()
{
	return c_getDI();
}

#undef getIP
GLOBAL word		getIP()
{
	return c_getIP();
}

#undef getEIP
GLOBAL IU32		getEIP()
{
	return c_getEIP();
}

#undef getESP
GLOBAL IU32		getESP()
{
	return c_getESP();
}

#undef getEFLAGS
GLOBAL IU32		getEFLAGS()
{
	return c_getEFLAGS();
}



#undef GetInstructionPointer
GLOBAL IU32 GetInstructionPointer()
{
        return (IU32) c_getIP();
}

#undef getCS
GLOBAL word		getCS()
{
	return c_getCS();
}

#undef getDS
GLOBAL word		getDS()
{
	return c_getDS();
}

#undef getES
GLOBAL word		getES()
{
	return c_getES();
}

#undef getSS
GLOBAL word		getSS()
{
	return c_getSS();
}


#undef getAF
GLOBAL word		getAF()
{
	return c_getAF();
}

#undef getCF
GLOBAL word		getCF()
{
	return c_getCF();
}

#undef getDF
GLOBAL word		getDF()
{
	return c_getDF();
}

#undef getIF
GLOBAL word		getIF()
{
	return c_getIF();
}

#undef getOF
GLOBAL word		getOF()
{
	return c_getOF();
}

#undef getPF
GLOBAL word		getPF()
{
	return c_getPF();
}

#undef getSF
GLOBAL word		getSF()
{
	return c_getSF();
}

#undef getTF
GLOBAL word		getTF()
{
	return c_getTF();
}

#undef getZF
GLOBAL word		getZF()
{
	return c_getZF();
}

#undef getMSW
GLOBAL word		getMSW()
{
	return c_getMSW();
}
#undef getCPL
GLOBAL word getCPL()
{
	return c_getCPL();
}

#undef setAL
GLOBAL VOID		setAL(val)
half_word	val;
{
	setAX( (getAX() & 0xFF00) | (val & 0xFF) );
}


#undef setCL
GLOBAL VOID		setCL(val)
half_word	val;
{
	setCX( (getCX() & 0xFF00) | (val & 0xFF) );
}


#undef setDL
GLOBAL VOID		setDL(val)
half_word	val;
{
	setDX( (getDX() & 0xFF00) | (val & 0xFF) );
}


#undef setBL
GLOBAL VOID		setBL(val)
half_word	val;
{
	setBX( (getBX() & 0xFF00) | (val & 0xFF) );
}


#undef setAH
GLOBAL VOID		setAH(val)
half_word	val;
{
	setAX( getAL() | ((val & 0xFF) << 8) );
}


#undef setCH
GLOBAL VOID		setCH(val)
half_word	val;
{
	setCX( getCL() | ((val & 0xFF) << 8) );
}


#undef setDH
GLOBAL VOID		setDH(val)
half_word	val;
{
	setDX( getDL() | ((val & 0xFF) << 8) );
}


#undef setBH
GLOBAL VOID		setBH(val)
half_word	val;
{
	setBX( getBL() | ((val & 0xFF) << 8) );
}


#undef setAX
GLOBAL VOID		setAX(val)
word	val;
{
	c_setAX(val);
}

#undef setBX
GLOBAL VOID		setBX(val)
word	val;
{
	c_setBX(val);
}


#undef setCX
GLOBAL VOID		setCX(val)
word	val;
{
	c_setCX(val);
}


#undef setDX
GLOBAL VOID		setDX(val)
word	val;
{
	c_setDX(val);
}



#undef setSP
GLOBAL VOID		setSP(val)
word	val;
{
    c_setSP(val);
}


#undef setBP
GLOBAL VOID		setBP(val)
word	val;
{
	c_setBP(val);
}


#undef setSI
GLOBAL VOID		setSI(val)
word	val;
{
	c_setSI(val);
}


#undef setDI
GLOBAL VOID		setDI(val)
word	val;
{
	c_setDI(val);
}


#undef setIP
GLOBAL VOID		setIP(val)
word	val;
{
	c_setIP(val);
}

#undef setES
GLOBAL 	setES(val)
word	val;
{
	return c_setES(val);
}


#undef setCS
GLOBAL 	setCS(val)
word	val;
{
	return c_setCS(val);
}

#undef setSS
GLOBAL 	setSS(val)
word	val;
{
	return c_setSS(val);
}


#undef setDS
GLOBAL	setDS(val)
word	val;
{
	return c_setDS(val);
}



#undef setCF
GLOBAL VOID		setCF(val)
word	val;
{
	c_setCF(val);
}


#undef setPF
GLOBAL VOID		setPF(val)
word	val;
{
    c_setPF(val);
}


#undef setAF
GLOBAL VOID		setAF(val)
word	val;
{
	c_setAF(val);
}


#undef setZF
GLOBAL VOID		setZF(val)
word	val;
{
    c_setZF(val);
}


#undef setSF
GLOBAL VOID		setSF(val)
word	val;
{
    c_setSF(val);
}


#undef setTF
GLOBAL VOID		setTF(val)
word	val;
{
	c_setTF(val);
}


#undef setIF
GLOBAL VOID		setIF(val)
word	val;
{
	c_setIF(val);
}


#undef setDF
GLOBAL VOID		setDF(val)
word	val;
{
	c_setDF(val);
}


#undef setOF
GLOBAL VOID		setOF(val)
word	val;
{
	c_setOF(val);
}

#undef setMSW
GLOBAL VOID		setMSW(val)
word	val;
{
	c_setMSW(val);
}


#undef setEIP
GLOBAL VOID setEIP(val)
IU32	val;
{
    c_setEIP(val);
}

#undef setEFLAGS
GLOBAL void setEFLAGS(val)
IU32	val;
{
    c_setEFLAGS(val);
}

#if 0
#undef setFLAGS
GLOBAL void setFLAGS(val)
IU32 val;
{
    c_setEFLAGS(val);
}
#endif

#undef setESP
void setESP(val)
IU32  val;
{
    c_setESP(val);
}


/* fiddle for building prod version */

#undef getSS_BASE
GLOBAL word getSS_BASE()
{
    return c_getSS_BASE();
}

#undef getSS_AR
GLOBAL word getSS_AR()
{
    return c_getSS_AR();
}

#undef setSS_BASE_LIMIT_AR
void setSS_BASE_LIMIT_AR(base,limit,ar)
IU32  base,limit;
IU16  ar;
{
    c_setSS_BASE_LIMIT_AR(base,limit,ar);
}


#endif /* CCPU */

#ifdef CPU_40_STYLE
#if defined(PROD) && !defined(CCPU)


#undef setAL
void setAL(IU8  val)  {(*(Cpu.SetAL))(val); }
#undef setAH
void setAH(IU8  val)  {(*(Cpu.SetAH))(val); }
#undef setAX
void setAX(IU16 val)  {(*(Cpu.SetAX))(val); }
#undef setBL
void setBL(IU8  val)  {(*(Cpu.SetBL))(val); }
#undef setBH
void setBH(IU8  val)  {(*(Cpu.SetBH))(val); }
#undef setBX
void setBX(IU16 val)  {(*(Cpu.SetBX))(val); }
#undef setCL
void setCL(IU8  val)  {(*(Cpu.SetCL))(val); }
#undef setCH
void setCH(IU8  val)  {(*(Cpu.SetCH))(val); }
#undef setCX
void setCX(IU16 val)  {(*(Cpu.SetCX))(val); }
#undef setDL
void setDL(IU8  val)  {(*(Cpu.SetDL))(val); }
#undef setDH
void setDH(IU8  val)  {(*(Cpu.SetDH))(val); }
#undef setDX
void setDX(IU16 val)  {(*(Cpu.SetDX))(val); }
#undef setSI
void setSI(IU16 val)  {(*(Cpu.SetSI))(val); }
#undef setDI
void setDI(IU16 val)  {(*(Cpu.SetDI))(val); }
#undef setSP
void setSP(IU16 val)  {(*(Cpu.SetSP))(val); }
#undef setBP
void setBP(IU16 val)  {(*(Cpu.SetBP))(val); }
#undef setIP
void setIP(IU16 val)  {(*(Cpu.SetIP))(val); }
#undef setCS
void setCS(IU16 val)  {(*(Cpu.SetCS))(val); }
#undef setSS
void setSS(IU16 val)  {(*(Cpu.SetSS))(val); }
#undef setDS
void setDS(IU16 val)  {(*(Cpu.SetDS))(val); }
#undef setES
void setES(IU16 val)  {(*(Cpu.SetES))(val); }
#undef setFS
void setFS(IU16 val)  {(*(Cpu.SetFS))(val); }
#undef setGS
void setGS(IU16 val)  {(*(Cpu.SetGS))(val); }


#undef setEAX
void setEAX(val)  {(*(Cpu.SetEAX))(val); }
#undef setEBX
void setEBX(val)  {(*(Cpu.SetEBX))(val); }
#undef setECX
void setECX(val)  {(*(Cpu.SetECX))(val); }
#undef setEDX
void setEDX(val)  {(*(Cpu.SetEDX))(val); }
#undef setESI
void setESI(val)  {(*(Cpu.SetESI))(val); }
#undef setEDI
void setEDI(val)  {(*(Cpu.SetEDI))(val); }
#undef setESP
void setESP(val)  {(*(Cpu.SetESP))(val); }
#undef setEBP
void setEBP(val)  {(*(Cpu.SetEBP))(val); }
#undef setEIP
void setEIP(val)  {(*(Cpu.SetEIP))(val); }



#undef setEFLAGS
void setEFLAGS(val)  {(*(Cpu.SetEFLAGS))(val); }
#undef setFLAGS
void setFLAGS(val) {(*(Cpu.SetEFLAGS))(val); }
#undef setSTATUS
void setSTATUS(val)  {(*(Cpu.SetSTATUS))((IU16)val); }
#undef setIOPL
void setIOPL(val)  {(*(Cpu.SetIOPL))((IU8)val); }
#undef setMSW
void setMSW(val)  {(*(Cpu.SetMSW))((IU16)val); }
#undef setCR0
void setCR0(val)  {(*(Cpu.SetCR0))(val); }
#undef setCR2
void setCR2(val)  {(*(Cpu.SetCR2))(val); }
#undef setCR3
void setCR3(val)  {(*(Cpu.SetCR3))(val); }
#undef setCF
void setCF(IU16 val)  {(*(Cpu.SetCF))(val); }
#undef setPF
void setPF(IU16 val)  {(*(Cpu.SetPF))(val); }
#undef setAF
void setAF(IU16 val)  {(*(Cpu.SetAF))(val); }
#undef setZF
void setZF(IU16 val)  {(*(Cpu.SetZF))(val); }
#undef setSF
void setSF(IU16 val)  {(*(Cpu.SetSF))(val); }
#undef setTF
void setTF(IU16 val)  {(*(Cpu.SetTF))(val); }
#undef setIF
void setIF(IU16 val)  {(*(Cpu.SetIF))(val); }
#undef setDF
void setDF(IU16 val)  {(*(Cpu.SetDF))(val); }
#undef setOF
void setOF(IU16 val)  {(*(Cpu.SetOF))(val); }
#undef setNT
void setNT(IU16 val)  {(*(Cpu.SetNT))(val); }
#undef setRF
void setRF(IU16 val)  {(*(Cpu.SetRF))(val); }
#undef setVM
void setVM(IU16 val)  {(*(Cpu.SetVM))(val); }
#undef setAC
void setAC(IU16 val)  {(*(Cpu.SetAC))(val); }
#undef setPE
void setPE(IU16 val)  {(*(Cpu.SetPE))(val); }
#undef setMP
void setMP(IU16 val)  {(*(Cpu.SetMP))(val); }
#undef setEM
void setEM(IU16 val)  {(*(Cpu.SetEM))(val); }
#undef setTS
void setTS(IU16 val)  {(*(Cpu.SetTS))(val); }
#undef setPG
void setPG(IU16 val)  {(*(Cpu.SetPG))(val); }
#undef setLDT_SELECTOR
void setLDT_SELECTOR(val)  {(*(Cpu.SetLDT_SELECTOR))((IU16)val); }
#undef setTR_SELECTOR
void setTR_SELECTOR(val)  {(*(Cpu.SetTR_SELECTOR))((IU16)val); }

#undef getAL
IU8  getAL()  { return (*(Cpu.GetAL))(); }
#undef getAH
IU8  getAH()  { return (*(Cpu.GetAH))(); }
#undef getAX
IU16 getAX()  { return (*(Cpu.GetAX))(); }
#undef getBL
IU8  getBL()  { return (*(Cpu.GetBL))(); }
#undef getBH
IU8  getBH()  { return (*(Cpu.GetBH))(); }
#undef getBX
IU16 getBX()  { return (*(Cpu.GetBX))(); }
#undef getCL
IU8  getCL()  { return (*(Cpu.GetCL))(); }
#undef getCH
IU8  getCH()  { return (*(Cpu.GetCH))(); }
#undef getCX
IU16 getCX()  { return (*(Cpu.GetCX))(); }
#undef getDL
IU8  getDL()  { return (*(Cpu.GetDL))(); }
#undef getDH
IU8  getDH()  { return (*(Cpu.GetDH))(); }
#undef getDX
IU16 getDX()  { return (*(Cpu.GetDX))(); }
#undef getSI
IU16 getSI()  { return (*(Cpu.GetSI))(); }
#undef getDI
IU16 getDI()  { return (*(Cpu.GetDI))(); }
#undef getSP
IU16 getSP()  { return (*(Cpu.GetSP))(); }
#undef getBP
IU16 getBP()  { return (*(Cpu.GetBP))(); }
#undef getIP
IU16 getIP()  { return (*(Cpu.GetIP))(); }
#undef getCS
IU16 getCS()  { return (*(Cpu.GetCS))(); }
#undef getSS
IU16 getSS()  { return (*(Cpu.GetSS))(); }
#undef getDS
IU16 getDS()  { return (*(Cpu.GetDS))(); }
#undef getES
IU16 getES()  { return (*(Cpu.GetES))(); }
#undef getFS
IU16 getFS()  { return (*(Cpu.GetFS))(); }
#undef getGS
IU16 getGS()  { return (*(Cpu.GetGS))(); }


#undef getEAX
getEAX()  {return ((*(Cpu.GetEAX))()); }
#undef getEBX
getEBX()  {return ((*(Cpu.GetEBX))()); }
#undef getECX
getECX()  {return ((*(Cpu.GetECX))()); }
#undef getEDX
getEDX()  {return ((*(Cpu.GetEDX))()); }
#undef getESI
getESI()  {return ((*(Cpu.GetESI))()); }
#undef getEDI
getEDI()  {return ((*(Cpu.GetEDI))()); }
#undef getESP
getESP()  {return ((*(Cpu.GetESP))()); }
#undef getEBP
getEBP()  {return ((*(Cpu.GetEBP))()); }
#undef getEIP
getEIP()  {return ((*(Cpu.GetEIP))()); }



#undef getEFLAGS
IU32 getEFLAGS()  { return (*(Cpu.GetEFLAGS))(); }
#undef getSTATUS
IU16 getSTATUS()  { return (*(Cpu.GetSTATUS))(); }
#undef getIOPL
IU8  getIOPL()  { return (*(Cpu.GetIOPL))(); }
#undef getMSW
IU16 getMSW()  { return (*(Cpu.GetMSW))(); }
#undef getCR0
IU32 getCR0()  { return (*(Cpu.GetCR0))(); }
#undef getCR2
IU32 getCR2()  { return (*(Cpu.GetCR2))(); }
#undef getCR3
IU32 getCR3()  { return (*(Cpu.GetCR3))(); }
#undef getCF
IBOOL getCF()  { return (*(Cpu.GetCF))(); }
#undef getPF
IBOOL getPF()  { return (*(Cpu.GetPF))(); }
#undef getAF
IBOOL getAF()  { return (*(Cpu.GetAF))(); }
#undef getZF
IBOOL getZF()  { return (*(Cpu.GetZF))(); }
#undef getSF
IBOOL getSF()  { return (*(Cpu.GetSF))(); }
#undef getTF
IBOOL getTF()  { return (*(Cpu.GetTF))(); }
#undef getIF
IBOOL getIF()  { return (*(Cpu.GetIF))(); }
#undef getDF
IBOOL getDF()  { return (*(Cpu.GetDF))(); }
#undef getOF
IBOOL getOF()  { return (*(Cpu.GetOF))(); }
#undef getNT
IBOOL getNT()  { return (*(Cpu.GetNT))(); }
#undef getRF
IBOOL getRF()  { return (*(Cpu.GetRF))(); }
#undef getVM
IBOOL getVM()  { return (*(Cpu.GetVM))(); }
#undef getAC
IBOOL getAC()  { return (*(Cpu.GetAC))(); }
#undef getPE
IBOOL getPE()  { return (*(Cpu.GetPE))(); }
#undef getMP
IBOOL getMP()  { return (*(Cpu.GetMP))(); }
#undef getEM
IBOOL getEM()  { return (*(Cpu.GetEM))(); }
#undef getTS
IBOOL getTS()  { return (*(Cpu.GetTS))(); }
#undef getET
IBOOL getET()  { return (*(Cpu.GetET))(); }
#undef getNE
IBOOL getNE()  { return (*(Cpu.GetNE))(); }
#undef getWP
IBOOL getWP()  { return (*(Cpu.GetWP))(); }
#undef getPG
IBOOL getPG()  { return (*(Cpu.GetPG))(); }
#undef getGDT_BASE
IU32 getGDT_BASE()  { return (*(Cpu.GetGDT_BASE))(); }
#undef getGDT_LIMIT
IU16 getGDT_LIMIT()  { return (*(Cpu.GetGDT_LIMIT))(); }
#undef getIDT_BASE
IU32 getIDT_BASE()  { return (*(Cpu.GetIDT_BASE))(); }
#undef getIDT_LIMIT
IU16 getIDT_LIMIT()  { return (*(Cpu.GetIDT_LIMIT))(); }
#undef getLDT_SELECTOR
IU16 getLDT_SELECTOR()  { return (*(Cpu.GetLDT_SELECTOR))(); }
#undef getLDT_BASE
IU32 getLDT_BASE()  { return (*(Cpu.GetLDT_BASE))(); }
#undef getLDT_LIMIT
IU16 getLDT_LIMIT()  { return (IU16)(*(Cpu.GetLDT_LIMIT))(); }
#undef getTR_SELECTOR
IU16 getTR_SELECTOR()  { return (*(Cpu.GetTR_SELECTOR))(); }
#undef getTR_BASE
IU32 getTR_BASE()  { return (*(Cpu.GetTR_BASE))(); }
#undef getTR_LIMIT
IU16 getTR_LIMIT()  { return (IU16)(*(Cpu.GetTR_LIMIT))(); }
#undef getTR_AR
IU16 getTR_AR()  { return (*(Cpu.GetTR_AR))(); }
#undef setCPL
void setCPL IFN1 (IUH, prot) { ((Cpu.Private)->SetCPL)(prot); }

#undef getSS_BASE
IU32	getSS_BASE	IFN0()
{ return (*((*(Cpu.Private)).GetSS_BASE))(); }

#undef getSS_AR
IU16	getSS_AR	IFN0()
{ return (*((*(Cpu.Private)).GetSS_AR))(); }

#undef setSS_BASE_LIMIT_AR
IBOOL	setSS_BASE_LIMIT_AR	IFN3(IU32, base, IU32, limit, IU16, ar)
{ return (*((*(Cpu.Private)).SetSS_BASE_LIMIT_AR))(base, limit, ar); }


/*** SAS stuff required for PROD. ***/

#undef sas_enable_20_bit_wrapping
void   sas_enable_20_bit_wrapping()            { (*(Sas.Sas_enable_20_bit_wrapping))(); }
#undef sas_disable_20_bit_wrapping
void   sas_disable_20_bit_wrapping()           { (*(Sas.Sas_disable_20_bit_wrapping))(); }
#undef sas_twenty_bit_wrapping_enabled
IBOOL  sas_twenty_bit_wrapping_enabled()       { return (*(Sas.Sas_twenty_bit_wrapping_enabled))(); }
#undef sas_overwrite_memory
void   sas_overwrite_memory(IU32 addr, IU32 length)      {(*(Sas.Sas_overwrite_memory))(addr, length);}

#endif /* PROD && !CCPU */
#endif /* CPU_40_STYLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_com.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>
#include <windows.h>
#include <vdm.h>
#include "ptypes32.h"
#include "insignia.h"
#include "host_def.h"

/*
 *      Ade Brownlow    
 *      Wed Jul 10 91   
 *
 *      nt_com.c
 *
 *
 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#include "xt.h"
#include "rs232.h"
#include "error.h"
#include "config.h"
#include "ica.h"
#include "ios.h"
#include "host_com.h"
#include "host_trc.h"
#include "debug.h"
#include "idetect.h"
#include "nt_com.h"

#include <math.h>
#include <malloc.h>
#include <stdlib.h>
#include <stdio.h>
#include <excpt.h>
#include <nt_timer.h>
#include <nt_eoi.h>


/*:::::::::::::::::::::::::::::::::::::::::::::: Standard host com interface */

GLOBAL void host_com_init(int);
GLOBAL CPU void host_com_close IPT1(int, adapter);
GLOBAL RXCPU VOID host_com_read IPT3(int, adapter, UTINY *, data, int *, error);
GLOBAL RXCPU void host_com_write IPT2(int, adapter, char, data);
GLOBAL void host_com_ioctl(int, int, long);
GLOBAL void host_com_reset(int);

GLOBAL void host_com_lock(int adapter);
GLOBAL void host_com_unlock(int adapter);
GLOBAL int host_com_open(int);


/* autoflush stub */
GLOBAL void host_setup_aflush (int);
GLOBAL DWORD nt_poll_comms(DWORD);
DWORD PollCommsThread(PVOID pv);

/*:::::::::::::::::::::::::::::: TX flush and control functions and defines */

#define TX_MAX_BUFFER       (200)
#define TX_SCALING_TRIGGER  (2)

typedef enum { XOFF_TRIGGER, TIMER_TRIGGER, TXFULL_TRIGGER, CLOSE_TRIGGER } FLUSHTYPE;

/*::::::::::::::::::::::::::::::::::::::::: Local adaptor control structure */

#define MAX_PENDING_WRITES  (3)
// this is the buffer size we ask the serial driver to allocate
// for its isr buffer(nopaged pool with quota). TonyE said it is no harm
// to give it a bigger one(a big smile, eh). 4KB already gave us lots
// of trouble, especially, on a slow machine.
#define INPUT_QUEUE_SIZE    (8*1024)
#define OUTPUT_QUEUE_SIZE   100

// this is the buffer size we use to receive rx data from serial driver
// it should be big enough to prevent the serial driver from overflowing its
// ISR buffer. The speed we delivery rx data to the application can not
// keep up with the speed that serial driver can handle.

#define BUFFER_SIZE         INPUT_QUEUE_SIZE *2


// this is the max number of chars we delivery to the application
// before the CPU thread gives the RX thread a taste of CPU.
// Too small, we waste too much time doing context switching and deliverying
// too many unnecessary rda interrupts to some smart application ISR,
// thus, reduce the overall throughput. Too big, we  choke the application
// (because we immediately delivery another rda interrupt to the
// application as soon as the application IRET).
// Application RX buffer size can be anywhere and depends how smart the
// appllication ISR is, we may make the application really angry.
// Some application ISR read LSR register after it gets the first char
// and if the LSR indicates that there is another bytes ready,
// it reads it immediately without waiting for the other int.
// Some application set the IER after EOI an RDA int and expects
// another interrupt.
#define DEFAULT_RXWINDOW_SIZE   256


#define ADAPTER_NULL      0             /* NULL device (/dev/null) */
#define ADAPTER_REAL      1             /* Real comm port device */
#define ADAPTER_SUSPENDED 2             /* Real device suspended */

typedef struct _COM_STATES {
    UCHAR   Break;
    UCHAR   DTR;
    UCHAR   RTS;
    UCHAR   Parity;
    UCHAR   StopBits;
    UCHAR   DataBits;
    DWORD   BaudRate;
}COM_STATES, *PCOM_STATES;


#define ESCAPECHAR ((UCHAR)(-1))

#if defined(NEC_98)
BYTE pifrsflag;                        // Get pif data from nt_pif.c
#define PIFRS_RTS_CTS  0x01            // rts/cts flow control
#define PIFRS_Xon_Xoff 0x02            // Xon/xoff flow control
#define PIFRS_DTR_DSR  0x04            // dtr/dsr flow control
#endif // NEC_98

typedef struct _host_com
{
    HANDLE handle;              /* Device handle */
    int type;                   /* hopefully NULL or a device */
    BOOL rx;
    BOOL dcbValid;              /* TRUE if dcbBeforeOpen contains a valid DCB */
    DCB dcbBeforeOpen;          /* device control block before open*/
    DWORD modem_status;         /* modem status line settings */
    HANDLE ModemEvent;          /* Get modem status control event */

    int controller;             /* ICA control used */
    int line;                   /* ICA line */

    /*..................................... Error display control variables */

    BOOL DisplayError;          /* Enabled/Disabled */

    /*......................................... RX buffer control variables */
    UCHAR   * buffer;                   /* rx buffer */
    int  head_inx;                      /* Next place to add char to */
    int  tail_inx;                      /* Next place to remove char from */
    int  bytes_in_rxbuf;                /* Number of bytes in buffer */
    int  rxwindow_size;                 /* rx buffer sliding window size */
    int  bytes_in_rxwindow;             /* bytes in the rx window */
    int  EscapeCount;
    int  EscapeType;

    BOOL CharReadFromUART;
    int RXFlushTrigger;

    HANDLE RXControlObject;
    DWORD SignalRXThread;

    /*......................................... TX buffer control variables */

    unsigned char TXBuffer[TX_MAX_BUFFER];
    int no_tx_chars;                    /* Chars in tx buffer */
    int tx_threshold;                   /* Current flush threshold */
    int max_tx_threshold;               /* Max flush threshold */

    int tx_flush_count;                 /* No. of flushs of below size */
    int tx_heart_beat_count;
    int tx_timer_flush_count;           /* Consecutive timer flush counts */
    int todate_timer_flush_total;

    OVERLAPPED DWOV[MAX_PENDING_WRITES];/* Delayed writes */
    int DWOVInx;                        /* Delayed writes index */

    /*.............................................. Access control objects */

    CRITICAL_SECTION CSEvent;   /* Used to control access to above */
    CRITICAL_SECTION AdapterLock;
    int AdapterLockCnt;         /* Adapter lock count */

    volatile BOOL TerminateRXThread;

    int ReOpenCounter;          /* Counter to prevent to many open attempts */
    int RX_in_Control;

    /*.......................................... XON/XOFF control variables */

    HANDLE XOFFEvent;           /* XOFF ioctl competion event */
    BOOL XOFFInProgress;        /* XOFF currently in progress */

    void *firstStatusBlock;     /* first block in IO status block linked list */
    void *lastStatusBlock;      /* last block in IO staus block linked list */

    /*...................................... Overlapped I/O control handles */

    HANDLE RXEvent;                     /* Overlapped read complete event */
    HANDLE TXEvent[MAX_PENDING_WRITES]; /* Overlapped write complete event */

    HANDLE EvtHandle;                   /* Used by WaitCommEvent */

    /*............................................. RX thread handle and ID */

    DWORD RXThreadID;           /* RX thread ID */
    HANDLE RXThreadHandle;      /* RX thread handle */
    COM_STATES ComStates;  /* Com device states as we know it */
    int     SuspendTimeoutTicks; /* auto close ticks setting */
    int     SuspendTickCounter; /* auto close tick counter */
    BOOL    SyncWrite;     /* TRUE if we should write data synchrounously */
    BOOL    Suspended;     /* TRUE if the port has been suspended */
    BOOL    Suspending;    /* TRUE when the port is being suspended */
    DWORD   TickCount;

} HOST_COM, *PHOST_COM;

#define BUMP_TAIL_INX(t,c)     (c)--;if(++(t) == BUFFER_SIZE) (t) = 0;

typedef enum { RXCHAR, CHARINERROR, RXERROR, MODEMSTATE, RXBUFEMPTY, UNKNOWN} RXBUFCHARTYPE;

/*:::::::::::::::::::::::::::::::::::::::::::::::::: Local function protocols */

DWORD GetCharsFromDriver(int adaptor);
void RX GetErrorFromDriver(int adapter);
CPU int SendXOFFIoctlToDriver(int adapter);

DWORD ReadWaitTimeOut(int adapter);
int MapHostToBaseError(UCHAR host_error);

void RX WaitForAllXOFFsToComplete(int adapter);
BOOL RX RemoveCompletedXOFFs(int adapter);
void SendDataToDriver(int adatper, char data);

void CPU FlushTXBuffer(int adapter, FLUSHTYPE FlushReason);
void ScaleTXThreshold(register HOST_COM *current, FLUSHTYPE FlushReason);

GLOBAL void host_com_EOI_hook(long adapter);
GLOBAL void CPU host_com_poll(int adapter);

RXBUFCHARTYPE GetCharacterTypeInBuffer(register HOST_COM *current);
void CPU EmptyRXBuffer(int adapter);
void GetCharFromRXBuffer(HOST_COM *current, RXBUFCHARTYPE type,
         UCHAR *data, UCHAR *error);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: LOCAL DATA */

LOCAL HOST_COM host_com[4];    /* 4 comm ports - the insignia MAX */

LOCAL PHOST_COM host_com_ptr[4] = { &host_com[0], &host_com[1],&host_com[2],
                &host_com[3]};

LOCAL int disable_open[4] = { FALSE, FALSE, FALSE, FALSE };

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Local defines */

#define CURRENT_ADAPTER() register HOST_COM *current = host_com_ptr[adapter]

#define EV_MODEM (EV_CTS | EV_DSR | EV_RING | EV_RLSD)
//#define EV_MODEM (EV_DSR | EV_RING | EV_RLSD)

#define  XON_CHARACTER   (17)           /* XON character, Cntrl-Q */
#define  XOFF_CHARACTER  (19)           /* XOFF character, Cntrl-S */
#define  XOFF_TIMEOUT    (2*1000)       /* Timeout in milliseconds */
#define  XOFF_RXCHARCNT  (5)            /* RX character count */

#define  REOPEN_DELAY    (36)           /* Reopen delay in 55ms (2 secs) */
#define  RXFLUSHTRIGGER  (36)           /* RX flush trigger (2 secs), if a
                  character is not read from the
                  UART within this time the RX buffer
                  is flushed */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Init comms system ::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#include "error.h"
#include "host_rrr.h"
#include "nt_uis.h"


GLOBAL CPU void host_com_init IFN1(int, adapter)
{
    UNUSED(adapter);

    // Comms ports are only opened when they are accessed.
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Disable Open :::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
//This is called at the start of the adapter init code to prevent the comm
//port being opened during com_init()

void host_com_disable_open IFN2(int, adapter, int, DisableOpen)
{
    disable_open[adapter] = DisableOpen;
}


#ifdef NTVDM
boolean host_com_check_adapter(int adapter)
{
    CURRENT_ADAPTER();
    return (current->type == ADAPTER_REAL);

}
#endif

GLOBAL void tx_holding_register_empty(int adapter);
GLOBAL void tx_shift_register_empty(int adapter);
GLOBAL void SyncBaseLineSettings(int, DIVISOR_LATCH *, LINE_CONTROL_REG *);


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Open comms port ::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Called first time port is written to ! */

GLOBAL CPU int host_com_open(int adapter)
{
    COMMTIMEOUTS comout;            /* Comm port time out settings */
    DIVISOR_LATCH divisor_latch;    /* Current latch settings */
    LINE_CONTROL_REG LCR_reg;       /* Current LCR status */
    int i;
    DCB LocalDCB;
    ConfigValues    ComConfigValues;

    CURRENT_ADAPTER();              /* Define and setup pointer to adapter */

    /*:::::::::::::::::::::::::::::::::::::::::: Is the port already open ? */

    if(current->type == ADAPTER_REAL)
   return(TRUE);       /* Exit port already open */

    /*::::::::::: Attempting to open the port to soon after a failed open ? */

    if(current->ReOpenCounter || disable_open[adapter])
   return(FALSE);              /* Yes */

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

    always_trace1("HOST_COM_OPEN adapter= %d\n", adapter);

    /*::::::::::::::::::::::::::::::::::::::::::::: Check for a NULL device */

    if(adapter > 3 || adapter < 0)
    {
   current->type = ADAPTER_NULL;
   current->ReOpenCounter = REOPEN_DELAY;   /* Delay next open attempt */
   return(FALSE);                           /* Open attempt failed */
    }

    /*::::::::::::::::::::::::::: We have a vaild adapter so try to open it */
    config_inquire((UTINY)(C_COM1_NAME + adapter),
         &ComConfigValues);
    current->handle = CreateFile(ComConfigValues.string,
             GENERIC_READ | GENERIC_WRITE, 0, NULL,
             OPEN_EXISTING,
             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
             NULL);

    /*............................................... Validate open attempt */

    if(current->handle == (HANDLE) -1)
    {
   always_trace1("Cannot open comms port '%s'\n",
        (CHAR*) config_inquire((UTINY)(C_COM1_NAME+adapter),NULL));

   if(current->DisplayError) {
       RcErrorBoxPrintf(EHS_ERR_OPENING_COM_PORT,
       (CHAR*) config_inquire((UTINY)(C_COM1_NAME+adapter),NULL));
       current->DisplayError = FALSE; //Error only display once per session
   }

   current->ReOpenCounter = REOPEN_DELAY;   /* Delay next open attempt */
   current->type = ADAPTER_NULL;       /* Unable to open adapter */
   return(FALSE);
    }


    /* allocate rx buffer and initialize rx queue size */

    current->buffer = (UCHAR *) malloc(BUFFER_SIZE);
    if (current->buffer == NULL) {
   CloseHandle(current->handle);
   current->type = ADAPTER_NULL;
   return FALSE;
    }
    current->rxwindow_size = DEFAULT_RXWINDOW_SIZE;
    current->bytes_in_rxwindow = 0;
    current->SyncWrite = (BOOL)config_inquire(C_COM_SYNCWRITE, NULL);
    /*:: Find out which ICA controller and line are used by this comms port */

    com_int_data(adapter, &current->controller, &current->line);

    /*::::::::::::::::::::::::::::::: Enable IRET hooks for comms interrupt */

#ifdef MONITOR
    ica_iret_hook_control(current->controller, current->line, TRUE);
#endif

    /*:::::::::::::::::::::: Create objects used to control comms activity */

    current->ModemEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    current->RXControlObject = CreateEvent(NULL,FALSE,FALSE,NULL);
    current->RXEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    current->EvtHandle = CreateEvent(NULL,TRUE,FALSE,NULL);
    current->DWOVInx = 0;

    //Create objects used to control multipe overlapping writes
    for(i=0; i < MAX_PENDING_WRITES; i++)
    {
   //Objects must be created in the signalled state for the closedown
   //routine to function correctly

   current->TXEvent[i] = CreateEvent(NULL,TRUE,TRUE,NULL);
   current->DWOV[i].hEvent = NULL;
    }

    /*::::::::::::::::::::::::::::::::::::::::::::::::: Empty RX/TX buffers */

    current->head_inx = current->tail_inx = 0;
    current->EscapeCount = current->bytes_in_rxbuf = current->no_tx_chars = 0;

    current->CharReadFromUART = FALSE;
    current->RXFlushTrigger = RXFLUSHTRIGGER;
    current->RX_in_Control = TRUE;
    current->SignalRXThread = (DWORD) 0;
    /*:::::::::::::::::::::::::::::::::::::::::::: Get TX buffer thresholds */

    current->max_tx_threshold = (short)config_inquire(C_COM_TXBUFFER_SIZE, NULL);
    if (!current->max_tx_threshold || current->max_tx_threshold > TX_MAX_BUFFER)
   current->max_tx_threshold = TX_MAX_BUFFER;

    //Setup other delayed write control variables
    if (current->max_tx_threshold == 1)
   current->tx_threshold = 0;
    current->tx_flush_count = 0;        // No. of flushs of below size
    /*::::::::::::::::::::::::::: Extended control variables used by adaper */

    current->type = ADAPTER_REAL;               /* Adapter type */
    current->TerminateRXThread = FALSE;         /* RX thread termination flag */

    /*:::::::::::::::::::::::::::::::: Initialise the XOFF control varibles */

    current->XOFFInProgress = FALSE;
    current->XOFFEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    current->firstStatusBlock = current->lastStatusBlock = NULL;

    /*:::: Init critical sections used to sync access to host functions, data */

    /* critical section used to control access to adapters data structure */
    InitializeCriticalSection(&current->CSEvent);

    /* critical section used to lock access to adapter from the base */
    InitializeCriticalSection(&current->AdapterLock);
    current->AdapterLockCnt = 0;

    /* NULL thread handle because host_com_close() may be called before
       the comms RX thread is created */

    current->RXThreadHandle = NULL;
    current->dcbValid = FALSE;
    /*::::::::::::::::::::::::::::::::::::::: Set Comms port to binary mode */

    if(!GetCommState(current->handle, &(current->dcbBeforeOpen)))
    {
   always_trace0("ntvdm : GetCommState failed on open\n");
   host_com_close(adapter);    /* turn it into a NULL adapter */
   current->ReOpenCounter = REOPEN_DELAY;   /* Delay next open attempt */
   return(FALSE);
    }

    current->dcbValid = TRUE;

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Setup DCB */


    /* we make a local copy of DCB because we have to reset the DCB
     * to whatever it was before we opened it. This function is the only place
     * we ever touch DCB.
     */

    LocalDCB = current->dcbBeforeOpen;
    LocalDCB.fBinary = 1;                        /* Run in RAW mode */
    LocalDCB.fOutxCtsFlow = FALSE;               /* Disable CTS */
    LocalDCB.fOutxDsrFlow = FALSE;               /* Disable DSR */
#if defined(NEC_98)
    LocalDCB.fDtrControl = ((pifrsflag & PIFRS_DTR_DSR) == PIFRS_DTR_DSR ) ?
                           DTR_CONTROL_HANDSHAKE : DTR_CONTROL_DISABLE;
    LocalDCB.fOutX = FALSE;          /* Disable XON/XOFF */
    LocalDCB.fInX = ((pifrsflag & PIFRS_Xon_Xoff) == PIFRS_Xon_Xoff) ?
                    TRUE : FALSE;
    LocalDCB.fTXContinueOnXoff = LocalDCB.fInX;
    LocalDCB.fRtsControl = ((pifrsflag & PIFRS_RTS_CTS) == PIFRS_RTS_CTS) ?
                           RTS_CONTROL_HANDSHAKE : RTS_CONTROL_DISABLE;
#else // !NEC_98
    LocalDCB.fDtrControl = DTR_CONTROL_DISABLE;
    LocalDCB.fOutX = FALSE;          /* Disable XON/XOFF */
    LocalDCB.fInX = FALSE;
    LocalDCB.fRtsControl = RTS_CONTROL_DISABLE;
#endif // !NEC_98

    LocalDCB.XonChar = XON_CHARACTER;    /* Define XON/XOFF chars */
    LocalDCB.XoffChar = XOFF_CHARACTER;
    LocalDCB.fErrorChar = FALSE;                 /* Turn off error char replacement */
    /* if we are resuming the device, initialize DCB parameters to
     * what they were before suspended
     */
    if (current->Suspended) {
   LocalDCB.BaudRate = current->ComStates.BaudRate;
   LocalDCB.Parity = current->ComStates.Parity;
   LocalDCB.StopBits = current->ComStates.StopBits;
   LocalDCB.ByteSize = current->ComStates.DataBits;
   LocalDCB.fParity = (LocalDCB.Parity == NOPARITY);
    }
    /* initialize the ComStates by copying data from DCB */
    else {
   current->ComStates.BaudRate = current->dcbBeforeOpen.BaudRate;
   current->ComStates.Parity = current->dcbBeforeOpen.Parity;
   current->ComStates.StopBits = current->dcbBeforeOpen.StopBits;
   current->ComStates.DataBits = current->dcbBeforeOpen.ByteSize;
   current->ComStates.Break = 0;
    }
    ASSERT(LocalDCB.BaudRate != 0);

    /*::::::::::::::::::::::::::::::::::: Sync base to current line settings */

    if(!SyncLineSettings(NULL, &(LocalDCB), &divisor_latch, &LCR_reg))
    {
   always_trace0("ntvdm : Unable to sync line states\n");

   host_com_close(adapter);
   current->ReOpenCounter = REOPEN_DELAY;   /* Delay next open attempt */
   return(FALSE);
    }

    SyncBaseLineSettings(adapter,&divisor_latch, &LCR_reg);

    /*:::::::::::::::::::::::::::::::::::::::::::::::: Set Comms port state */

    if(!SetCommState(current->handle, &(LocalDCB)))
    {
   always_trace0("ntvdm : SetCommState failed on open\n");

   host_com_close(adapter);
   current->ReOpenCounter = REOPEN_DELAY;   /* Delay next open attempt */
   return(FALSE);
    }

    /*::::::::::::::::::::: Put the driver into streaming MSR,LSR, RX mode */

    if(!EnableMSRLSRRXmode(current->handle, current->ModemEvent,
            (unsigned char) ESCAPECHAR))
    {
   always_trace0("ntvdm : GetCommState failed on open\n");
   host_com_close(adapter);    /* turn it into a NULL adapter */
   current->ReOpenCounter = REOPEN_DELAY;   /* Delay next open attempt */
   return(FALSE);
    }

    /*::::::::::::::::::::::::::::::::::::::::: Setup comm port queue sizes */

    if(!SetupComm(current->handle,INPUT_QUEUE_SIZE,OUTPUT_QUEUE_SIZE))
    {
   always_trace1("ntvdm : SetupComm failed, %d\n",GetLastError());

   host_com_close(adapter);
   current->ReOpenCounter = REOPEN_DELAY;   /* Delay next open attempt */
   return(FALSE);
    }

    /*::::::::::::::::::::: Set communication port up for non-blocking read */

    GetCommTimeouts(current->handle,&comout);

    comout.ReadIntervalTimeout = (DWORD) -1;
    comout.ReadTotalTimeoutMultiplier = 0;
    comout.ReadTotalTimeoutConstant = 0;

    SetCommTimeouts(current->handle,&comout);

    /* restore device states in case of resume */
    if (current->Suspended) {
   /* break line */
   if (current->ComStates.Break)
       SetCommBreak(current->handle);
   else
       ClearCommBreak(current->handle);
   /* Data Terminal Ready line */
   if (current->ComStates.DTR)
       EscapeCommFunction(current->handle, SETDTR);
   else
       EscapeCommFunction(current->handle, CLRDTR);
   /* Request To Send line */
   if (current->ComStates.RTS)
       EscapeCommFunction(current->handle, SETRTS);
   else
       EscapeCommFunction(current->handle, CLRRTS);

   /* parity, stop bits and data bits */
   FastCommSetLineControl(current->handle,
         current->ComStates.StopBits,
         current->ComStates.Parity,
         current->ComStates.DataBits
        );
   /* baud rate */
   FastCommSetBaudRate(current->handle, current->ComStates.BaudRate);

   /* we are no longer in suspended state */
   current->Suspended = FALSE;

    }
    else {
   /*::::::::::::::::::::::::::::::::::::::::::::: Setup RTS and DTR states */
   setup_RTSDTR(adapter);
    }

    /*::::::::::::::::::::::::::::::::::::::::::::::: Create Comms RX thread */

    if(!(current->RXThreadHandle = CreateThread(NULL,
                  8192,
                  PollCommsThread,
                  (LPVOID)adapter,
                  0,
                  &current->RXThreadID)))
    {
   always_trace1("ntvdm : Failed comms thread for %d\n", adapter);
   host_com_close(adapter);        /* Unable to create RX thread */
   current->ReOpenCounter = REOPEN_DELAY;   /* Delay next open attempt */
   return(FALSE);
    }
    /* reset the counter */
    current->SuspendTimeoutTicks = ComConfigValues.index * 1000;
    current->SuspendTickCounter =  current->SuspendTimeoutTicks;
    current->TickCount = 0;
    return(TRUE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Close all open comms ports :::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

GLOBAL CPU void host_com_close_all(void)
{
    int adapter;

    for(adapter = 0; adapter < 4; adapter++)
    {
   host_com[adapter].DisplayError = TRUE; //Enable error displaying
   host_com_close(adapter);
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::: Close comms port ::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

GLOBAL CPU void host_com_close IFN1(int, adapter)
{
    CURRENT_ADAPTER();
    int i;

    /*:::::::::::::::::::::::::::::::::::::::: Dealing with NULL adapter ? */

    if(current->type != ADAPTER_NULL)
    {
   always_trace1("Closing comms port %d\n",adapter);

   /* only touch the device if we own the device */
   if (current->type == ADAPTER_REAL) {
       /*....... Flush any delayed writes and wait for writes to complete */
       if (current->no_tx_chars)
      FlushTXBuffer(adapter,CLOSE_TRIGGER);
       WaitForMultipleObjects(MAX_PENDING_WRITES,current->TXEvent,TRUE,INFINITE);
       /* reset DCB to whatever it was before open */
       if (current->dcbValid) {
      SetCommState(current->handle, &current->dcbBeforeOpen);
      current->dcbValid = FALSE;
       }

   }


   /* keep the base adapter states intact if we are suspending the device */
   if (!current->Suspending)
       /*........................................ Reset base comms adatper */
       com_init(adapter);      /* Initialise base comms adapter */

   /*................................................. Close RX thread */

   if(current->RXThreadHandle)
   {
       /*................................. Tell RX thread to terminate */

       current->TerminateRXThread = TRUE;  // Tell RX thread to terminate
       current->RX_in_Control = TRUE;
       SetEvent(current->RXControlObject);

       /* Wait for RX thread to close itself, max wait 30 seconds */

       WaitForSingleObject(current->RXThreadHandle,30000);
       CloseHandle(current->RXThreadHandle);

       current->RXThreadHandle = NULL;  // Mark thread as closed
   }
   /* now it is safe to close the device */
   CloseHandle(current->handle); current->handle = NULL;

   /*............... Delete RX critical section and RX control objects */

   DeleteCriticalSection(&current->CSEvent);
   DeleteCriticalSection(&current->AdapterLock);

   /*............................................. Close event objects */

   CloseHandle(current->ModemEvent);
   CloseHandle(current->RXControlObject);
   CloseHandle(current->RXEvent);      // Overlapped read wait object
   for(i=0; i < MAX_PENDING_WRITES; i++)
   {
       CloseHandle(current->TXEvent[i]); // Overlapped write wait object
       current->TXEvent[i] = NULL;
   }

   CloseHandle(current->EvtHandle);    // WaitCommEvent wait object
   CloseHandle(current->XOFFEvent);

   current->XOFFEvent = current->RXEvent = current->EvtHandle = NULL;

   /*.......................... Disable IRET hooks for comms interrupt */

#ifdef MONITOR
   ica_iret_hook_control(current->controller, current->line, FALSE);
#endif

   /*. This makes sure that the next access to the port will reopen it */
   current->ReOpenCounter = 0;

   free(current->buffer);
   current->buffer = NULL;
   current->type = ADAPTER_NULL;   /* Mark adapter as closed */
     }
     else if (current->Suspended) {
   /* the application is terminating while the port is suspended.
    * first we turn the disable-open on so that we will not try
    * to physical touch the port. Then we call base to reset the
    * adapter
    */

   BOOL  DisableOpen;
   DisableOpen = disable_open[adapter];
   disable_open[adapter] = TRUE;
   com_init(adapter);
   disable_open[adapter] = DisableOpen;
   current->Suspended = FALSE;
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::: Request from base for character :::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#ifdef FIFO_ON
GLOBAL CPU UTINY host_com_read_char( int adapter, FIFORXDATA * buffer, UTINY count)
{
    CURRENT_ADAPTER();
    UCHAR host_error;
    RXBUFCHARTYPE CharType;
    UTINY RetCount = count;
   /* if xoff is in progress, don't read nothing */
   if (!current->XOFFInProgress) {
   while (count) {
       CharType = GetCharacterTypeInBuffer(current);
       if (CharType == RXCHAR || CharType == CHARINERROR) {
      buffer->error = 0;
      GetCharFromRXBuffer(current, CharType, &buffer->data, &host_error);
      if (!host_error)
          buffer->error = MapHostToBaseError(host_error);
      buffer++;
      count--;
       }
       else
      break;
   }
    }
      /* Tell comms idle system that there has been comms activity */
    IDLE_comlpt();
    current->SuspendTickCounter = current->SuspendTimeoutTicks;
    return (RetCount - count);

}
GLOBAL CPU void host_com_fifo_char_read(int adapter)
{
    CURRENT_ADAPTER();
    current->CharReadFromUART = TRUE;
}
#endif

GLOBAL RXCPU VOID host_com_read IFN3(int, adapter, UTINY *, data, int *, error)
{
    CURRENT_ADAPTER();
    UCHAR host_error;
    RXBUFCHARTYPE CharType;
    BOOL MoreToProcess = TRUE;
    /*::::::::::::::::::::::::::::::::::::::::: Dealing with NULL adapter ? */

    if(current->type != ADAPTER_REAL && !host_com_open(adapter))
   return;                             /* Exit, unable to open adapter */

    /*::::::::::::::::::::::: Get next character from input character queue */


    while(MoreToProcess)
    {

   CharType = GetCharacterTypeInBuffer(current);

   //Process next character in buffer
   switch(CharType)
   {
       //................................................Process character

       case RXCHAR:
       case CHARINERROR:
      host_error = 0;
      GetCharFromRXBuffer(current,CharType,(UCHAR *)data,&host_error);

      //error reading character
      if(host_error)
          *error = MapHostToBaseError(host_error); /* Get error */
      MoreToProcess = FALSE;
      break;

       //.....................Process receive error, no character available

       case RXERROR:
      com_lsr_change(adapter);
      break;

       //...................................... Process modem state changes

       case MODEMSTATE:
      com_modem_change(adapter);
      break;

       //..................................................RX buffer empty

       case RXBUFEMPTY:
      always_trace0("Read requested on empty RX buffer");
      *error = 0; *data = (UTINY)-1; //Buffer empty
      MoreToProcess = FALSE;
      break;

       case UNKNOWN:
      GetCharFromRXBuffer(current,CharType,(UCHAR *)data,&host_error);
      *error = MapHostToBaseError(host_error); /* Get error */
      MoreToProcess = FALSE;
      break;

   }
    }

    /* Tell comms idle system that there has been comms activity */
    IDLE_comlpt();
    current->SuspendTickCounter = current->SuspendTimeoutTicks;
}

/*:::::::::::::::::::::::::: Comms read returned to application by the base */
// This function is called after each character is read from the comms port

int CPU host_com_char_read(int adapter, int data_available_ints)
{
    CURRENT_ADAPTER();

    current->CharReadFromUART = TRUE;           //Char read from UART
    if(data_available_ints)
   host_com_EOI_hook((long) adapter);
    else
   host_com_poll(adapter);

    return(0);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::: Map host error to base error ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

int RXCPU MapHostToBaseError(UCHAR host_error)
{
    int base_error = 0;
    LINE_STATUS_REG LSR;

    LSR.all = host_error;
    if(LSR.bits.framing_error)    base_error |= HOST_COM_FRAMING_ERROR;
    if(LSR.bits.parity_error)     base_error |= HOST_COM_PARITY_ERROR;
    if(LSR.bits.break_interrupt)  base_error |= HOST_COM_BREAK_RECEIVED;
    if(LSR.bits.overrun_error)    base_error |= HOST_COM_OVERRUN_ERROR;

    return(base_error);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::: Write to comms port :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

GLOBAL RXCPU void host_com_write IFN2(int, adapter, char, data)
{
    CURRENT_ADAPTER();

    /*:::::::::::::::::::::::::::::::::: Are we dealing with a NULL adapter */

    if(current->type != ADAPTER_REAL && !host_com_open(adapter))
   return;                             /* Exit, unable to open adapter */

    if(data == XOFF_CHARACTER || data == XON_CHARACTER)
   sub_note_trace1(HOST_COM_VERBOSE,"XO%s sent",data == XOFF_CHARACTER ? "FF" : "N");

    /*::::::::::::::::::::::::::::::::::::::::: Is the user sending an XOFF */


    if(data == XOFF_CHARACTER)
    {
   if(current->no_tx_chars) FlushTXBuffer(adapter,XOFF_TRIGGER);
   SendXOFFIoctlToDriver(adapter);
    }
    else
   SendDataToDriver(adapter,data);

    /*::::::::::: Tell comms idle system that there has been comms activity */

    IDLE_comlpt();
    current->SuspendTickCounter = current->SuspendTimeoutTicks;
    /* tell base that the tx holding register is empty */
    tx_holding_register_empty(adapter);
    /* async write mode -> tell base that the tx shift register is empty
     * sync mode -> FlushTxBuffer will do the signaling.
     */
    if (!current->SyncWrite)
   tx_shift_register_empty(adapter);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::: Write data to driver */

void SendDataToDriver(int adapter, char data)
{
    DWORD BytesWritten, error = 0;
    OVERLAPPED OV;
    CURRENT_ADAPTER();

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::: Delay write ? */

    if(current->tx_threshold)
    {
   //Add char to tx buffer queue
   current->TXBuffer[current->no_tx_chars++] = (unsigned char) data;


   //Write threshold reached ?
   if(current->tx_threshold <= current->no_tx_chars ||
      current->XOFFInProgress)
       FlushTXBuffer(adapter,(current->XOFFInProgress) ?
           XOFF_TRIGGER : TXFULL_TRIGGER);
   return;
    }


    /*:::::::::::::::::::::::::::::: Setup overlapped I/O control structure */

    OV.hEvent = current->TXEvent[0];     /* Event used to signal completion */

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::: Write character */

    if(!WriteFile(current->handle, &data, 1, &BytesWritten, &OV))
    {
   if((error = GetLastError()) == ERROR_IO_PENDING)
   {
       /* Write request pending wait for it to complete */
       if(GetOverlappedResult(current->handle,&OV,&BytesWritten,TRUE))
      error = 0;             /* Write successful */
       else
      error = GetLastError();
   }

   /* Reset comms port, clear error */
   if(error) ClearCommError(current->handle,&error,NULL);
    }

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::: Display error */

#ifndef PROD
    if(error)
   always_trace2("host_com_write error, adapter %d,%d\n",adapter,error);
#endif
    /* tell base that the tx shift register is empty */
    tx_shift_register_empty(adapter);

}


/*::::::::::::::::::::::::::::::::::::::::::::::::::: Send magic XOFF ioctl */

CPU int SendXOFFIoctlToDriver(int adapter)
{
    CURRENT_ADAPTER();
    void *newIOStatusBlock;
    int rtn;

    /*.................... Allocate new IOstatus block, used by magic ioctl */

    newIOStatusBlock = AllocStatusElement();

    /*.............................................. Issue magic xoff IOCTL */

    if(SendXOFFIoctl(current->handle,    // Handle of comms port
        current->XOFFEvent,    // Event to signal completion on
        XOFF_TIMEOUT,          // Timeout in milliseconds
        XOFF_RXCHARCNT,        // RX character count
        XOFF_CHARACTER,        // XOFF character
        newIOStatusBlock))     // IO status block for ioctl

    {
   /*............................. Add new status block to linked list */

   EnterCriticalSection(&current->CSEvent);

   AddNewIOStatusBlockToList(&current->firstStatusBlock,
              &current->lastStatusBlock, newIOStatusBlock);

   current->XOFFInProgress = TRUE;
   LeaveCriticalSection(&current->CSEvent);
   rtn =TRUE;                      // XOFF ioctl successful
    }
    else
    {
   /* Error, XOFF ioctl failed */
   free(newIOStatusBlock);
   rtn = FALSE;                    // XOFF ioctl failed
    }

    return(rtn);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


GLOBAL RXCPU void host_com_ioctl IFN3(int, adapter, int, request, long, arg)
{
    UCHAR host_modem, error;
    MODEM_STATUS_REG MSR;
    char BaudRateStr[100];
    ULONG ModemState;
    UCHAR   DataBits, StopBits, Parity;

    CURRENT_ADAPTER();      /* Define and set 'current' adaptor pointer */

    /*:::::::::::::::::::::::::::::::::: Are we dealing with a null adapter */

    if(current->type != ADAPTER_REAL)
    {
   // Attempt to open adapter !

   if(request == HOST_COM_FLUSH || request == HOST_COM_INPUT_READY ||
      request == HOST_COM_MODEM || !host_com_open(adapter))
   {
       return;
   }
    }
    /*:::::::::::::::::::::::::::::::::::::::::::::: Identify ioctl request */


    switch(request)
    {

   case HOST_COM_LSR:
       if(GetCharacterTypeInBuffer(current) == RXERROR)
       {
      GetCharFromRXBuffer(current, RXERROR, NULL, &error);
      *(DWORD *)arg = (DWORD)error;
       }
       break;

   /*:::::::::::::::::::::::::::::::::::::::::: Process break requests */

   case HOST_COM_SBRK:         /* Set BREAK */
       sub_note_trace0(HOST_COM_VERBOSE, "set BREAK");
       SetCommBreak(current->handle);
       current->ComStates.Break = 1;
       break;

   case HOST_COM_CBRK:        /* Clear BREAK */
       sub_note_trace0(HOST_COM_VERBOSE, "clear BREAK");
       ClearCommBreak(current->handle);
       current->ComStates.Break = 0;
       break;

   /*::::::::::::::::::::::::::::::::::::::::: Process baud rate change */

   case HOST_COM_BAUD:

       if (!FastCommSetBaudRate(current->handle, arg))
       {
      sprintf(BaudRateStr, "(%d)", arg);
      host_error(EHS_UNSUPPORTED_BAUD, ERR_CONT, BaudRateStr);
      always_trace1("set BAUD failed - SetBaudRate:%d", arg);
       }
       current->ComStates.BaudRate = (DWORD)arg;

       break;

   /*:::::::::::::::::::::::::::::::::::::::: Process DTR line requests */

   case HOST_COM_SDTR:                 /* Set DTR line */
       //printf("Set DTR\n");
       sub_note_trace0(HOST_COM_VERBOSE, "set DTR");
       if(!EscapeCommFunction (current->handle, SETDTR))
      sub_note_trace0(HOST_COM_VERBOSE, "set DTR FAILED");
       current->ComStates.DTR = 1;
       break;

   case HOST_COM_CDTR:                 /* Clear DTR line */
       //printf("Clear DTR\n");
       sub_note_trace0(HOST_COM_VERBOSE, "clear DTR");
       if(!EscapeCommFunction (current->handle, CLRDTR))
      sub_note_trace0(HOST_COM_VERBOSE, "clear DTR FAILED");
       current->ComStates.DTR = 0;
       break;

   /*::::::::::::::::::::::::::::::::::::::::::::::::: flush comms port */

   case HOST_COM_FLUSH:                /* Flush comms port */
       sub_note_trace0(HOST_COM_VERBOSE, "Flush comms port");
       break;

   /*:::::::::::::::::::::::::::::::::::::::: Process RTS line requests */

   case HOST_COM_CRTS:                 /* Clear RTS */
       //printf("Clear RTS\n");
       sub_note_trace0(HOST_COM_VERBOSE, "clear RTS");
       if(!EscapeCommFunction (current->handle, CLRRTS))
      sub_note_trace0(HOST_COM_VERBOSE, "clear RTS FAILED");
       current->ComStates.RTS = 0;
       break;

   case HOST_COM_SRTS:
       //printf("Set RTS\n");
       sub_note_trace0(HOST_COM_VERBOSE, "set RTS");
       if(!EscapeCommFunction (current->handle, SETRTS))
      sub_note_trace0(HOST_COM_VERBOSE, "set RTS FAILED");
       current->ComStates.RTS = 1;
       break;

   /*::::::::::::::::::::::::::::::::::: Return status of the RX buffer */

   case HOST_COM_INPUT_READY:
       *(long *)arg = current->rx;   /* check the port for data */
       break;

   /*:::::::::::::::::::::::::::::::::::::::::::::: Return modem status */

   case HOST_COM_MODEM:              /* Get modem state */

       current->modem_status = 0;
       if(GetCharacterTypeInBuffer(current) == MODEMSTATE)
       {
      GetCharFromRXBuffer(current, MODEMSTATE, &host_modem, &error);
      MSR.all = host_modem;

      if(MSR.bits.CTS)  current->modem_status |= HOST_COM_MODEM_CTS;
      if(MSR.bits.RI)   current->modem_status |= HOST_COM_MODEM_RI;
      if(MSR.bits.DSR)  current->modem_status |= HOST_COM_MODEM_DSR;
      if(MSR.bits.RLSD) current->modem_status |= HOST_COM_MODEM_RLSD;
       }
       else
       {
      //.......................Get modem data from the serial driver ?

      FastGetCommModemStatus(current->handle, current->ModemEvent,
                   &ModemState);

      if(ModemState & MS_CTS_ON)
          current->modem_status |= HOST_COM_MODEM_CTS;

      if(ModemState & MS_RING_ON)
          current->modem_status |= HOST_COM_MODEM_RI;

      if(ModemState & MS_DSR_ON)
          current->modem_status |= HOST_COM_MODEM_DSR;

      if(ModemState & MS_RLSD_ON)
          current->modem_status |= HOST_COM_MODEM_RLSD;
       }

       //.......................Return modem change information to the base

       sub_note_trace4(HOST_COM_VERBOSE, "CTS:%s RI:%s DSR:%s RLSD:%s",
           current->modem_status & HOST_COM_MODEM_CTS  ? "ON" : "OFF",
           current->modem_status & HOST_COM_MODEM_RI   ? "ON" : "OFF",
           current->modem_status & HOST_COM_MODEM_DSR  ? "ON" : "OFF",
           current->modem_status & HOST_COM_MODEM_RLSD ? "ON" : "OFF");

       *(long *)arg = current->modem_status;
       break;

   /*::::::::::::::::::::::::::::::::::::::::: Setup number of stop bits */

   case HOST_COM_STOPBITS:
       sub_note_trace1(HOST_COM_VERBOSE, "Setting Stop bits %d", arg);
       if (FastCommGetLineControl(current->handle, &StopBits, &Parity,
                   &DataBits))
       {
      switch (arg)
      {
          case 1:
         StopBits = ONESTOPBIT;
         break;
          case 2:
         StopBits = DataBits == 5 ? ONE5STOPBITS : TWOSTOPBITS;
         break;

          default:
         always_trace1("STOPBITS strange request %d\n", arg);
         break;
      }

      if(!FastCommSetLineControl(current->handle, StopBits, Parity, DataBits))
      {

          always_trace1("set STOPBITS failed- FastCommSetLineControl:%d",arg);
      }
       }
       else {

      always_trace1("set STOPBITS failed- FastCommGetLineControl:%d",arg);
       }
       current->ComStates.StopBits = StopBits;
       break;

   /*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Setup parity */

   case HOST_COM_PARITY:
       if (FastCommGetLineControl(current->handle, &StopBits, &Parity, &DataBits))
       {
      switch(arg)
      {
          case HOST_COM_PARITY_EVEN:
         sub_note_trace0(HOST_COM_VERBOSE, "Set EVEN Parity");
         Parity=EVENPARITY;
          break;

          case HOST_COM_PARITY_ODD:
         sub_note_trace0(HOST_COM_VERBOSE, "Set ODD Parity");
         Parity=ODDPARITY;
         break;

          case HOST_COM_PARITY_MARK:
         sub_note_trace0(HOST_COM_VERBOSE, "Set MARK Parity");
         Parity=MARKPARITY;
         break;

          case HOST_COM_PARITY_SPACE:
         sub_note_trace0(HOST_COM_VERBOSE, "Set SPACE Parity");
         Parity=SPACEPARITY;
         break;

          case HOST_COM_PARITY_NONE:
         sub_note_trace0(HOST_COM_VERBOSE, "Set DISABLE Parity");
         Parity=NOPARITY;
         break;
      }
      if(!FastCommSetLineControl(current->handle, StopBits, Parity, DataBits))
      {
          always_trace1("set PARITY failed - FastCommSetLineControl :%d",arg);
      }
       }
       else {

      always_trace1("set STOPBITS failed- FastCommGetLineControl:%d",arg);
       }
       current->ComStates.Parity = Parity;
       break;

   /*::::::::::::::::::::::::::::::::::::::::::::::::::: Setup data bits */

   case HOST_COM_DATABITS:
       sub_note_trace1(HOST_COM_VERBOSE, "Setting data bits %d",arg);
       if (FastCommGetLineControl(current->handle, &StopBits, &Parity, &DataBits))
       {
      DataBits = (UCHAR)arg;
      if(!FastCommSetLineControl(current->handle, StopBits, Parity, DataBits))
      {
          always_trace1("set DATABITS failed - FastCommSetLineControl:%d",arg);
      }
       }
       else {

      always_trace1("set STOPBITS failed- FastCommGetLineControl:%d",arg);
       }
       current->ComStates.DataBits = DataBits;
       break;

   /*::::::::::::::::::::::::::::::::::::::: Unrecognised host_com ioctl */

   default:
       always_trace0("Bad host_com_ioctl\n");
       sub_note_trace0(HOST_COM_VERBOSE, "Bad host_com_ioctl");
       break;
    }

    /* Tell comms idle system that there has been comms activity */
    IDLE_comlpt();
    current->SuspendTickCounter = current->SuspendTimeoutTicks;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::: Host comms reset ????? */

GLOBAL void host_com_reset IFN1(int, adapter)
{
    int controller, line;
    half_word IMR_value;

    com_int_data(adapter, &controller, &line);

    always_trace3("com reset Adapter %d, controller %d, line %d\n",adapter,controller,line);

    //Disable interrupts on port being reset
    ica_inb((io_addr) (controller ? ICA1_PORT_1 : ICA0_PORT_1), &IMR_value);
    IMR_value |= 1 << line;
    ica_outb((io_addr) (controller ? ICA1_PORT_1 : ICA0_PORT_1), IMR_value);

    //Enable error displaying
    host_com[adapter].DisplayError = TRUE;
    host_com[adapter].Suspended = FALSE;
    host_com[adapter].Suspending = FALSE;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Autoflush */

GLOBAL void host_setup_aflush IFN1(int, state)
{
    UNREFERENCED_FORMAL_PARAMETER(state);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: RX buffer handling routines :::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*:::::::::::::::::::::::::::::::::::::::: Get chars from the serial driver */


DWORD RX GetCharsFromDriver(int adapter)
{
    CURRENT_ADAPTER();
    DWORD bytesread = 0, bytestoread;
    OVERLAPPED OV;
    DWORD    CommError;
    DWORD   bytes_before_wrap;
    DWORD   total_bytes_read = 0;


    OV.hEvent = current->RXEvent;   /* Event to signal completion on */
    EnterCriticalSection(&current->CSEvent);

    bytestoread = BUFFER_SIZE - current->bytes_in_rxbuf;
    bytes_before_wrap = BUFFER_SIZE - current->head_inx;
    if (bytes_before_wrap < bytestoread){
   OV.Offset = 0;          /* reset offset or ReadFile can fail */
   OV.OffsetHigh = 0;
   if (!ReadFile(current->handle, &current->buffer[current->head_inx],
            bytes_before_wrap, &bytesread, &OV))
   {
       // we have zero timeout for the read operation
       // this pending check may be redundant??????
       if (GetLastError() == ERROR_IO_PENDING) {
      GetOverlappedResult(current->handle, &OV,
                &bytesread, TRUE);
       }
       else {
      ClearCommError(current->handle, &CommError, NULL);
      bytesread = 0;
       }
   }

   if (bytesread) {
       total_bytes_read = bytesread;
       current->bytes_in_rxbuf += bytesread;
       if (bytesread == bytes_before_wrap) {
      current->head_inx = 0;
      bytestoread -= bytesread;
       }
       else {
      current->head_inx += bytesread;
      bytestoread = 0;

       }
   }
   else
       bytestoread = 0;
    }
    if (bytestoread){
   OV.Offset = 0;          /* reset offset or ReadFile can fail */
   OV.OffsetHigh = 0;
   if (!ReadFile(current->handle, &current->buffer[current->head_inx],
            bytestoread, &bytesread, &OV))
   {
       if (GetLastError() == ERROR_IO_PENDING) {
      GetOverlappedResult(current->handle, &OV,
                &bytesread, TRUE);
       }
       else {
      ClearCommError(current->handle, &CommError, NULL);
      bytesread = 0;
       }
   }
   if (bytesread) {
       current->bytes_in_rxbuf += bytesread;
       current->head_inx += bytesread;
       total_bytes_read += bytesread;
   }
    }
    LeaveCriticalSection(&current->CSEvent);

    return (total_bytes_read);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: RX thread, one per comm port :::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

DWORD PollCommsThread(PVOID pv)
{
   DWORD adapter = (DWORD)pv;
   DWORD dwRet = (WORD)-1;

   try {
      dwRet = nt_poll_comms(adapter);
      }
   except(VdmUnhandledExceptionFilter(GetExceptionInformation())) {
      ;  // we shouldn't arrive here
      }

   return dwRet;
}



DWORD CPU nt_poll_comms IFN1(DWORD, adapter)
{
    CURRENT_ADAPTER();                  /* Setup ptr to current adapter */
    DWORD EvtMask;                      /* Comms event mask */
    ULONG SignalledObj = (ULONG) -1;
    HANDLE WaitTable[2];
    HANDLE SetCommEvt;                  /* Handle used by FastSetCommEvent */

    BOOL CheckDriverForChars = FALSE;   /* Check driver for characters */
    RXBUFCHARTYPE CharType;

    /*::::::::::::::::::::::::::::::::: Setup table of event signal objects */

    WaitTable[0] = current->EvtHandle;
    WaitTable[1] = current->RXControlObject;

    /*:::::::::::::::::::::::::::::::::::::::::::::::: Setup comm wait mask */

    SetCommEvt = CreateEvent(NULL,TRUE,FALSE,NULL);

    FastSetCommMask(current->handle,SetCommEvt,EV_RXCHAR | EV_ERR | EV_MODEM);

    //Initialise FastWaitCommsOrCpuEvent function
    FastWaitCommsOrCpuEvent(NULL, NULL, 0, NULL, NULL);

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::: Enter read loop */

    while(TRUE)
    {
   /*::::::::::::::::: Wait for communications events then process them */

   if(SignalledObj != 1)
   {
       if(!FastWaitCommsOrCpuEvent(current->handle, WaitTable, 0, &EvtMask,
               &SignalledObj))
       {
      // Error getting comms/CPU thread event ?
      DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
       }
   }

   /*::::::::::::::::::::: Is the CPU thread returning control to us ? */

   if(SignalledObj == 1 || current->TerminateRXThread)
   {
       // The CPU thread is trying to tell us something.

       /*..................... Is it time to terminate this thread !!! */

       if(current->TerminateRXThread)
       {
      FastSetCommMask(current->handle,SetCommEvt,0);
      WaitForAllXOFFsToComplete(adapter);   // Complete ioctl's
      CloseHandle(SetCommEvt);
      return(0);                            // Terminate thread
       }

       /* we have 3 reasons why we are here:
          (1). the CPU thread has emptied the current rx window
          (2). XOFF is in progress
        */
   }

   if (SignalledObj == 0 || current->bytes_in_rxwindow == 0)
       GetCharsFromDriver(adapter);
   /*:::::::::::::::::::::::::::::::: Is there data to pass to the base */

   if((CharType = GetCharacterTypeInBuffer(current)) != RXBUFEMPTY)
   {
       if (CharType  == RXCHAR || CharType == CHARINERROR) {
      WaitForAllXOFFsToComplete(adapter);
       }

       // slid the window. Note that there may be some character left in
       // the window(because of XOFF). It  is no harm to slid
       // the window.
       //
       EnterCriticalSection(&current->CSEvent);
       if (current->bytes_in_rxbuf > current->rxwindow_size)
      current->bytes_in_rxwindow = current->rxwindow_size;
       else
      current->bytes_in_rxwindow = current->bytes_in_rxbuf;
       LeaveCriticalSection(&current->CSEvent);

       host_com_lock(adapter);

       if(CharType == MODEMSTATE)
      com_modem_change(adapter);
       else if (CharType == RXERROR)
      com_lsr_change(adapter);
       else {
      com_recv_char(adapter);
      /*
       * reset rx flush counter so we won't flush Rx buffer.
       * current->RXFlushTrigger may have been RXFLUSHTRIGGER - 1
       * at this moment and when we switch context to main thread
       * another timer tick may have come which would trigger
       * EmptyRxBuffer and cause unwantted overrun.
       */
      current->RXFlushTrigger = RXFLUSHTRIGGER;
      current->RX_in_Control = FALSE;
      current->SignalRXThread = 0;
       }
       host_com_unlock(adapter);

       //Wait for CPU thread to return control
       if(CharType != MODEMSTATE && CharType != RXERROR)
       {
      WaitForSingleObject(current->RXControlObject, INFINITE);
       }

       SignalledObj = 1;
   }
   else
       SignalledObj = (ULONG) -1;
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Wait for XOFF ioctl's to complete ::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/



void RX WaitForAllXOFFsToComplete(int adapter)
{
    CURRENT_ADAPTER();
    int PendingXOFF;

    if(current->firstStatusBlock == NULL && current->lastStatusBlock == NULL)
   return; //list of pending ioctrl's empty

    /*::::::::::::::::::::::: Wait for all pending xoff ioctl's to complete */

    do
    {
   PendingXOFF = RemoveCompletedXOFFs(adapter);

   /*................................... Are there any ioctl's pending */

   if(PendingXOFF)
       WaitForSingleObject(current->XOFFEvent,XOFF_TIMEOUT); // wait for ioctl
    }
    while(PendingXOFF);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::: Removed completed XOFF ioctl's :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

BOOL RX RemoveCompletedXOFFs(int adapter)
{
    CURRENT_ADAPTER();
    int PendingXOFF;

    /*........................................ Remove completed ioctl's */

    EnterCriticalSection(&current->CSEvent);

    PendingXOFF = RemoveCompletedIOCTLs(&current->firstStatusBlock,
               &current->lastStatusBlock);

    if(!PendingXOFF) current->XOFFInProgress = FALSE;

    LeaveCriticalSection(&current->CSEvent);

    return((BOOL) PendingXOFF);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Enter critical section for adapter :::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void RXCPU host_com_lock(int adapter)
{
    CURRENT_ADAPTER();
    if(current->type != ADAPTER_REAL) return;   /* Exit, NULL adapter */

    EnterCriticalSection(&current->AdapterLock);
    current->AdapterLockCnt++;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Leave critical section for adapter :::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void RXCPU host_com_unlock(int adapter)
{
    CURRENT_ADAPTER();

    if(current->type != ADAPTER_REAL || current->AdapterLockCnt == 0)
   return; /* Exit, NULL adapter */

    current->AdapterLockCnt--;
    LeaveCriticalSection(&current->AdapterLock);

    //Have we been requested to signal the RX thread. After the SetEvent()
    //function call the RX thread, which is blocked on the
    //current->RXControlObject object, will run. If the SetEvent() function
    //is called from within the critical section, then because it is highly
    //likely that the RX thread will attempt to perform a host_com_lock(). The
    //RX thread will block in the host_com_lock() function until another time
    //slice is given to the CPU thread.

    // do not set the event if RX thread already in control
    if(current->SignalRXThread &&
       current->SignalRXThread == GetCurrentThreadId())
    {
   current->RX_in_Control = TRUE;
   SetEvent(current->RXControlObject);
   current->SignalRXThread = (DWORD) 0;
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::: Host coms heart beat ::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

//This function is called approximately every 55ms.

GLOBAL void CPU host_com_heart_beat()
{
    register int adapter;        /* Adapter no of adapter being processed */
    register HOST_COM *current;  /* Ptr to current adapter being processed */
    DWORD   TickCount;

    /*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

    for(adapter = 0; adapter < (sizeof(host_com)/sizeof(HOST_COM)); adapter++)
    {
   current = host_com_ptr[adapter]; /* Ptr to current adapter */

   if(current->type == ADAPTER_NULL)
   {
       if(current->ReOpenCounter) current->ReOpenCounter--;
   }
   else if (current->type == ADAPTER_REAL)
   {
       if(current->no_tx_chars) FlushTXBuffer(adapter,TIMER_TRIGGER);
       current->tx_heart_beat_count++;

       if(current->RXFlushTrigger == 0 && !current->CharReadFromUART)
      EmptyRXBuffer(adapter); //Empty RX buffer
       else
      if(current->CharReadFromUART)
      {
          current->RXFlushTrigger = 0;        //Force trigger reset
          current->CharReadFromUART = FALSE;
      }

       //Update RX flush trigger counter
       if(--current->RXFlushTrigger < 0)
          current->RXFlushTrigger = RXFLUSHTRIGGER;
       /* if auto close is enable, decrement the counter and
        * suspend the adapter is time out
        */

       if (current->SuspendTimeoutTicks) {
      TickCount = GetTickCount();

      if (current->TickCount) {
          current->SuspendTickCounter -= TickCount - current->TickCount;
      }
      else {
          /* we have not yet initialize the tick count yet,
           * presume that it is 55ms
           */
          current->SuspendTickCounter -= 55;
      }
      current->TickCount = TickCount;

      /* time out, suspend the port */
      if (current->SuspendTickCounter <= 27) {
          /* make sure host_com_close won't reset the adapter because
           * we want to keep the adapter current states
           */
          current->Suspending = TRUE;
          host_com_close(adapter);
          current->Suspended = TRUE;
          current->Suspending = FALSE;
      }
       }
   }
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::: Flush TX buffer ::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void CPU FlushTXBuffer(int adapter, FLUSHTYPE FlushReason)
{
    CURRENT_ADAPTER();
    DWORD BytesWritten, error = 0;

    /*................................................. Scale TX threshold */

    ScaleTXThreshold(current, FlushReason);

    if (current->SyncWrite) {
   if (!WriteFile(current->handle, current->TXBuffer,
             current->no_tx_chars, &BytesWritten,
             &current->DWOV[0])) {
       error = GetLastError();
       if (error == ERROR_IO_PENDING) {
      if (!GetOverlappedResult(current->handle,
                &current->DWOV[0],
                &BytesWritten,
                TRUE))
          error = GetLastError();
      else
          error = ERROR_SUCCESS;
       }
   }
   if (error != ERROR_SUCCESS) {
       ClearCommError(current->handle, &error, NULL);
#ifndef PROD
       always_trace2("host_com_write error, adapter %d,%d\n", adapter, error);
#endif
   }
   tx_shift_register_empty(adapter);
   current->no_tx_chars = 0;
   return;
    }
    /*...Clear pending writes on the OV structure that we are about to use*/

    if(current->DWOV[current->DWOVInx].hEvent)
    {
   if(GetOverlappedResult(current->handle,
                &current->DWOV[current->DWOVInx],
                &BytesWritten,TRUE))
   {
       error = 0;         /* Write successful */
   }
   else
   {
       error = GetLastError();
   }

#ifndef PROD
   if(error)
       always_trace2("host_com_write error, adapter %d,%d\n",adapter,error);
#endif

    }
    else
   current->DWOV[current->DWOVInx].hEvent = current->TXEvent[current->DWOVInx];

    /*..................................................... Write characters */


    if(!WriteFile(current->handle, current->TXBuffer, current->no_tx_chars,
       &BytesWritten, &current->DWOV[current->DWOVInx]))
    {
   if((error = GetLastError()) == ERROR_IO_PENDING)
       error = 0;         //ignore IO PENDING

   /* Reset comms port, clear error */
   if(error)
   {
       ClearCommError(current->handle,&error,NULL);
#ifndef PROD
       always_trace2("host_com_write error, adapter %d,%d\n",adapter,
           error);
#endif
   }
    }

    if(++current->DWOVInx == MAX_PENDING_WRITES) current->DWOVInx =0;
    current->no_tx_chars = 0;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::: Scale TX threshold :::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


void ScaleTXThreshold(register HOST_COM *current,FLUSHTYPE FlushReason)
{

    if(FlushReason != TIMER_TRIGGER)
    {
   current->tx_timer_flush_count = 0;
   current->todate_timer_flush_total = 0;
    }

    /*....................................................................*/

    switch(FlushReason)
    {
   // Comms heart beat caused flush

   case TIMER_TRIGGER:
       //printf("T%d",current->no_tx_chars);
       if(++current->tx_timer_flush_count == 3)
       {
      //printf("X");
      // three consecutive timer trigged flushes, this maybe because
      // the TX threshold is to high. If the threshold is to high
      // then we are wasting time waiting for the communications
      // heart beat to flush the buffer. Reduce TX threshold.

      current->todate_timer_flush_total += current->no_tx_chars;
      current->tx_threshold = current->todate_timer_flush_total/3;

      //printf("[%dT]",current->tx_threshold);

      // Reset TXFULL_TRIGGER control variables
      current->tx_heart_beat_count = 0;
      current->tx_flush_count = 0;

      // Reset TIMER_TRIGGER control variables
      current->tx_timer_flush_count = 0;
      current->todate_timer_flush_total = 0;
       }
       else
       {
      current->todate_timer_flush_total += current->no_tx_chars;
       }

       break;

   // TX threshold reached

   case TXFULL_TRIGGER:

       //printf("F");
       //TX scaling trigger triggered ?????
       if(current->tx_heart_beat_count <= 3 &&
          current->tx_flush_count++ == TX_SCALING_TRIGGER)
       {
      current->tx_threshold = current->tx_threshold*2 > current->max_tx_threshold
               ? current->max_tx_threshold
               : current->tx_threshold*2;

      //printf("[%dF]",current->tx_threshold);
      current->tx_flush_count = 0;
       }
       else
      if(current->tx_heart_beat_count > 3)
      {
          current->tx_heart_beat_count = 0;
          current->tx_flush_count = 0;
      }

       break;

   // XOFF triggered or close triggered flush

   case XOFF_TRIGGER:
   case CLOSE_TRIGGER:
       break;

    } /* End of switch statement */
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::: Comms character read hook ::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

//This function is called after a character has been read out of the comms
//adapter (com.c). This function is always called from within an adapter
//critical section, host_com_lock().

void CPU host_com_EOI_hook(long adapter)
{
    CURRENT_ADAPTER();
    RXBUFCHARTYPE CharType;

    if (!current->XOFFInProgress && current->bytes_in_rxwindow)
    {
   while ((CharType = GetCharacterTypeInBuffer(current)) != RXBUFEMPTY){
       if (CharType == MODEMSTATE)
      com_modem_change(adapter);
       else if (CharType == RXERROR)
          com_lsr_change(adapter);
       else {
      com_recv_char((int) adapter);
      return;
       }
   }
    }
    //Request host_com_unlock() to signal the RX thread. This will
    //return responsibility for interrupt generation to the RX thread.

    current->SignalRXThread = GetCurrentThreadId();
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: Polling applications LSR hook ::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
// This following function is only called from the comms adapter if data
// available interrupts are disabled and the adapters receive buffer is
// empty. Being called under these circumstances indicates that we
// are dealing with a application that is polling the comms adapter.

// This function is always called from within an adapter critical section


void CPU host_com_poll(int adapter)
{
    CURRENT_ADAPTER();
    RXBUFCHARTYPE CharType;

    /*:::::::::::::::::::::::::::::::::: Are we dealing with a null adapter */

    if(current->type != ADAPTER_REAL && !host_com_open(adapter))
   return;                             /* Exit, unable to open adapter */

    /*::::::::::::::::: Has an XOFF character stop the generation of ints */

    if(current->XOFFInProgress)
    {
   // XOFF in process, pass no more characters to the base and return
   // control to the RX thread.

   current->SignalRXThread = GetCurrentThreadId();
   return;
    }

    // If the RX buffer is empty see if there are any characters hanging
    // around in the serial driver

    if(current->bytes_in_rxbuf == 0) GetCharsFromDriver(adapter);

    /*:::::::::::::::::::::: Are there any characters to pass to the base ? */

    if(current->bytes_in_rxbuf == 0 ||
       (CharType = GetCharacterTypeInBuffer(current)) == RXBUFEMPTY)
    {
   current->SignalRXThread = GetCurrentThreadId();
    }
    else
    {
   //Process modem state characters
   while(CharType == MODEMSTATE || CharType == RXERROR)
   {
       if (CharType == MODEMSTATE)
      com_modem_change(adapter);
       else
      com_lsr_change(adapter);
       CharType = GetCharacterTypeInBuffer(current);
   }

   if(CharType != RXBUFEMPTY)
   {
       com_recv_char((int)adapter);
   }
   else
       current->SignalRXThread = GetCurrentThreadId();
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::: Comms adapter data available interrupt hook ::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
// The comms adapter calls this function when the status of the data available
// interrupt has changed. The adapter lock is in affect

void CPU host_com_da_int_change(int adapter, int data_int_state, int data_state)
{
    CURRENT_ADAPTER();

    /*:::::::::::::::::::::::::::::::::: Are we dealing with a null adapter */

    if(current->type != ADAPTER_REAL)
    {
   // Only attempt to open a null adapter if data available interrupts
   // are being enabled

   if(data_int_state == 0 || !host_com_open(adapter))
       return;
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::: Get the type of character in tail of RX buffer :::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

RXBUFCHARTYPE GetCharacterTypeInBuffer(register HOST_COM *current)
{
    int tail_inx = current->tail_inx;
    int bytes_in_buf = current->bytes_in_rxbuf;
    RXBUFCHARTYPE rtn;

    //Buffer empty ?

    if(bytes_in_buf == 0) return(RXBUFEMPTY);

    //Escape character at head of buffer

    if(current->buffer[tail_inx] == ESCAPECHAR && bytes_in_buf > 1)
    {
   BUMP_TAIL_INX(tail_inx,bytes_in_buf);

   switch(current->buffer[tail_inx])
   {
       case SERIAL_LSRMST_ESCAPE :
      rtn = RXCHAR;
      break;

       case SERIAL_LSRMST_LSR_NODATA :
      rtn = bytes_in_buf > 1 ? RXERROR : RXBUFEMPTY;
      break;

       case SERIAL_LSRMST_LSR_DATA :
      rtn = bytes_in_buf > 2 ? CHARINERROR : RXBUFEMPTY;
      break;

       case SERIAL_LSRMST_MST :
      rtn = bytes_in_buf > 1 ? MODEMSTATE : RXBUFEMPTY;
      break;
       // receive an invalid escape id
       default:
      rtn = UNKNOWN;
      break;
   }
    }
    else
    {
   rtn = current->buffer[tail_inx] == ESCAPECHAR ? RXBUFEMPTY : RXCHAR;
    }

    return(rtn);
}


//::::::::::::::::::::::::::::::::::::Get the next character from the RX buffer.

void GetCharFromRXBuffer(register HOST_COM *current, RXBUFCHARTYPE type,
         UCHAR *data, UCHAR *error)
{
    EnterCriticalSection(&current->CSEvent);

    switch(type)
    {
   //................................................. Return modem status

   case MODEMSTATE :
       // Skip escape character and type marker
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);

       *data = current->buffer[current->tail_inx];
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       current->bytes_in_rxwindow -= 3;
       break;

   //.................................................... Return character

   case RXCHAR :
       if(current->buffer[current->tail_inx] == ESCAPECHAR)
       {
      //Skip ESCAPE character
      BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
      current->bytes_in_rxwindow--;
      *data = ESCAPECHAR;
       }
       else
      *data = current->buffer[current->tail_inx];

       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       current->bytes_in_rxwindow--;
       break;

   //...........................................Return character and error

   case CHARINERROR :
       // Skip escape character and type marker
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);

       *error = current->buffer[current->tail_inx];
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       *data =  current->buffer[current->tail_inx];
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       current->bytes_in_rxwindow -= 4;
       break;

   //................................Return line status error with no data

   case RXERROR :
       // Skip escape character and type marker
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);

       // Get linr status error
       *error = current->buffer[current->tail_inx];
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       current->bytes_in_rxwindow -= 3;
       break;
   case UNKNOWN:
       // The only case we will hit an unknown type is unsupport escape
       // id. Dump the escape char, return the byte follows the escape
       // characater and post an overrun error
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       *data = current->buffer[current->tail_inx];
       BUMP_TAIL_INX(current->tail_inx, current->bytes_in_rxbuf);
       current->bytes_in_rxwindow -= 2;
       *error =  2;
       break;

    }

    LeaveCriticalSection(&current->CSEvent);
}

//::::::Empty RX buffer, processing characters and changing in the modem status

void CPU EmptyRXBuffer(int adapter)
{
    RXBUFCHARTYPE CharType;
    CURRENT_ADAPTER();

    if(!current->RX_in_Control && current->SignalRXThread == (DWORD)0)
    {
   always_trace0("Char not removed from UART, RX buffer flushed\n");

   host_com_lock(adapter);

   while((CharType = GetCharacterTypeInBuffer(current)) != RXBUFEMPTY)
   {
       if(CharType == MODEMSTATE)
      com_modem_change(adapter);
       else if (CharType == RXERROR)
      com_lsr_change(adapter);
       else
      com_recv_char(adapter);
   }

   host_com_unlock(adapter);

   //Buffer empty return control to the RX thread
   current->RX_in_Control = TRUE;
   SetEvent(current->RXControlObject);
    }
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ DEBUG functions


#if 0
void host_com_state(int adapter)
{

    CURRENT_ADAPTER();

    printf("Adapter          %d\n\n",adapter);
    printf("RX in control    %s\n", current->RX_in_Control ? "TRUE" : "FALSE");
    printf("XOFFInProgress   %s\n", current->XOFFInProgress ? "TRUE" : "FALSE");

    printf("Head buffer ptr  %xh\n",current->head_inx);
    printf("Tail buffer ptr  %xh\n",current->tail_inx);
    printf("Bytes in buffer  %d\n",current->bytes_in_rxbuf);

    printf("Bytes in TX buf  %d\n",current->no_tx_chars);
    printf("TX buf threshold %d\n",current->tx_threshold);
    printf("TX threshold max %d\n",current->max_tx_threshold);
    printf("TX flush count   %d\n",current->tx_flush_count);
    printf("TX timer count   %d\n",current->tx_heart_beat_count);

    if(current->AdapterLock.DebugInfo)
    {
   printf("Adapter CS count %d\n",current->AdapterLock.DebugInfo->ContentionCount);
   printf("Data CS count    %d\n",current->CSEvent.DebugInfo->ContentionCount);
    }

    printf("Bytes RX to date %d\n",byte_count);
    printf("Last read size   %d\n",lastread);
    printf("Avg read size    %d\n",byte_count && readcount ? byte_count/readcount : 0);
    printf("Zero reads       %d\n",zeroreads);

    zeroreads = readcount = byte_count=0;

    com_reg_dump();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_cgw.c ===
#if defined(NEC_98)
#include <windows.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>
#include <conapi.h>
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "debug.h"
#include "cg.h"
#include "error.h"
#include "nt_graph.h"
#include <devioctl.h>
#include <ntddvdeo.h>
#include "host_rrr.h"
#include "nt_fulsc.h"
#include "tgdc.h"

void cg_all_copy IPT0();
void gaij_save IPT1(unsigned short, value);
void gaij_load IPT2(unsigned short, value, unsigned char *, pattern);
void cg_half_load IPT2(unsigned short, value, unsigned char *, pattern);
void cg_ank_load IPT2(unsigned short, value, unsigned char *, pattern);
void cg_all_load IPT2(unsigned short, value, unsigned char *, pattern);
#if 1                                                   // 931022
void null_write IPT1(unsigned char *, pattern);         // 931022
#else                                                   // 931022
void null_write IPT0();
#endif                                                  // 931022
unsigned short cg_font_load IPT2(unsigned short, value, unsigned char *, pattern);
unsigned short set_bit_pattern IPT2(unsigned short, value,unsigned char *,pattern);
void cg_save IPT0();
void host_set_gaij_data IPT1(unsigned short, value);
void host_set_all_gaij_data IPT0();
void host_get_all_gaij_data IPT0();

extern TerminateVDM();

BOOL cg_flg = TRUE;
unsigned char pat[32];
unsigned short old_code;
unsigned short old_count;
void *Base;
GAIJ_GLOBS *gaijglobs;
BOOL cg_lock;

extern MODEFF_GLOBS modeffglobs;
extern BOOL fontselchanged;
extern BOOL independvsync;
extern BOOL VDMForWOW;
IMPORT BOOL is_vdm_register;

void cg_all_copy IFN0() {
        unsigned char *src,*dst;
        int             i;
        src = CG_WINDOW_START;
        dst = CG_WINDOW_START+32;
        for(i=1;i<120;i++) {
                memcpy(dst,src,32);
                dst += 32;
        }
}

void gaij_save IFN1(unsigned short, value) {
        unsigned short code;
        unsigned char *src,*dst;
        int             i,j;
        BOOL    call_console = FALSE;

        code = value - USER_GAIJ_START;
        if (code > 0x7F)
                code = (code & 0x00FF)+0x7F;
        gaijglobs[code].code = value;
        src = CG_WINDOW_START;
        dst = gaijglobs[code].pattern;
        src++;
        if (old_count & 0x20)
                src += 32;
        else
                dst++;
        for (i=0;i<16;i++,src+=2,dst+=2)
            if(*dst != *src) {
                *dst = *src;
                call_console = TRUE;
            }
#ifdef VSYNC                                    // VSYNC
        if (sc.ScreenState == FULLSCREEN && call_console) {
                host_set_gaij_data(code);
        }
#endif                                          // VSYNC
}

void gaij_load IFN2(unsigned short, value, unsigned char *, pattern) {
        unsigned short code;
        unsigned char *src;
        int             i,j;
        half_access = TRUE;
        code = (value & 0x7f7f)- USER_GAIJ_START;
        if (code == 0x7F) {
#if 1                                                   // 931022
                null_write(pattern);                    // 931022
#else                                                   // 931022
                null_write();
#endif                                                  // 931022
                return;
        } else {
                if (code > 0x7F)
                        code = (code & 0x007F)+0x7F;
                src = gaijglobs[code].pattern;
//              if (HIRESO_MODE) ;
//              else {
                        if (cg_flg) {
                                if (!(cgglobs.counter & 0x20))
                                        src++;
                                for (i=0;i<32;i+=2,src+=2) {
                                        cgglobs.cgwindow_ptr[i] = 0xFF;
                                        cgglobs.cgwindow_ptr[i+1] = *src;
                                }
                                cg_all_copy();
                        } else {
                                for (i=0;i<16;i++,src+=2,pattern++)
                                        *pattern = *src;
                                src = gaijglobs[code].pattern;
                                src++;
                                for (i=16;i<32;i++,src+=2,pattern++)
                                        *pattern = *src;
                        }
//              }
        }
}

void cg_half_load IFN2(unsigned short, value,unsigned char *, pattern) {
        unsigned char *src;
        int             i,j;
        unsigned short  Hi,Lo;
        half_access = TRUE;
        Hi = (value & 0x7F00) >>8;
        Lo = (value & 0x007F);
        src = (unsigned char *) Base + ((Hi-0x01)*94+(Lo-0x21))*32+0x1800;
//      if (HIRESO_MODE) ;
//       else {
                if (cg_flg) {
                        if (!(cgglobs.counter & 0x20))
                                src++;
                        for (i=0;i<32;i+=2,src+=2) {
                                cgglobs.cgwindow_ptr[i] = 0xFF;
                                cgglobs.cgwindow_ptr[i+1] = *src;
                        }
                        cg_all_copy();
                } else {
                        if ((value >= HALF_CHAR_START) && (value <= HALF_CHAR_END)) {
                                for (i=0;i<16;src+=2,i++,pattern++)
                                *pattern = *src;
                                for (i=16;i<32;i++,pattern++)
                                        *pattern = 0x00;
                        } else {
                                for (i=0;i<16;i++,src+=2,pattern++)
                                        *pattern = *src;
                                src = (unsigned char *) Base + ((Hi-0x01)*94+(Lo-0x21))*32+0x1800;
                                src++;
                                for (i=16;i<32;i++,src+=2,pattern++)
                                        *pattern = *src;
                        }
                }
//      }
}

void cg_ank_load IFN2(unsigned short, value, unsigned char *, pattern) {
        unsigned char *src;
        int             i,j;
        unsigned short  Lo;
        half_access = TRUE;
        Lo = (value >> 8);
//      if (HIRESO_MODE) ;
//      else {
                if ((modeffglobs.modeff_data[3]) & 0x01) {
                        src = (unsigned char *) Base + Lo*16+2048;
                        if (cg_flg) {
                                for (i=0;i<32;i+=2,src++) {
                                        cgglobs.cgwindow_ptr[i] = 0xFF;
                                        cgglobs.cgwindow_ptr[i+1] = *src;
                                }
                                cg_all_copy();
                        } else {
                                for (i=0;i<16;i++,src++,pattern++)
                                        *pattern = *src;
                                for (i=16;i<32;i++,pattern++)
                                        *pattern = 0x00;
                        }
                } else {
                        if (cg_flg) {
                                src = (unsigned char *) Base + Lo*8;
                                for (i=0;i<16;i+=2,src++) {
                                        cgglobs.cgwindow_ptr[i] = 0xFF;
                                        cgglobs.cgwindow_ptr[i+1] = *src;
                                }
                                for (i=16;i<32;i++) {
                                        cgglobs.cgwindow_ptr[i] = 0xff;
                                }
                                cg_all_copy();
                        } else {
                                src = (unsigned char *) Base + Lo*16+2048;
                                for (i=0;i<16;i++,src++,pattern++)
                                        *pattern = *src;
                                for (i=16;i<32;i++,pattern++)
                                        *pattern = 0x00;
                        }
                }
//      }
}

void cg_all_load IFN2(unsigned short, value, unsigned char *, pattern) {
        unsigned char *src;
        int             i,j;
        unsigned short  Hi,Lo;
        half_access = FALSE;
        Hi = (value & 0x7F00) >>8;
        Lo = (value & 0x007F);
        src = (unsigned char *) Base + ((Hi-0x01)*94+(Lo-0x21))*32+0x1800;
//      if (HIRESO_MODE) ;
//       else {
                if (cg_flg) {
                        for (i=0;i<32;i++,src++)
                                cgglobs.cgwindow_ptr[i] = *src;
                        cg_all_copy();
                } else {
                        for (i=0;i<16;i++,src+=2,pattern++)
                                *pattern = *src;
                        src = (unsigned char *) Base + ((Hi-0x01)*94+(Lo-0x21))*32+0x1800;
                        src++;
                        for (i=16;i<32;i++,src+=2,pattern++)
                                *pattern = *src;
                }
//      }
}

#if 1                                                   // 931022
void null_write IFN1(unsigned char *, pattern) {        // 931022
        unsigned char *dst;                             // 931022
        int             i,j;                            // 931022
                                                        // 931022
        if (cg_flg) {                                   // 931022
                dst = CG_WINDOW_START;                  // 931022
                for (i=0;i<32;i++,dst++) {              // 931022
                        *dst = 0x00;                    // 931022
                }                                       // 931022
                cg_all_copy();                          // 940113 bug fix
        } else {                                        // 931022
                for (i=0;i<32;i++,pattern++)            // 931022
                        *pattern = 0x00;                // 931022
        }                                               // 931022
}                                                       // 931022
#else                                                   // 931022
void null_write IFN0() {
        unsigned char *dst;
        int             i,j;
        dst = CG_WINDOW_START;
        for (i=0;i<32;i++,dst++) {
                if (cg_flg) {
                        *dst = 0x00;
                }
        }
        cg_all_copy();
}
#endif                                                  // 931022

unsigned short cg_font_load IFN2(unsigned short, value, unsigned char *, pattern) {
        if(sc.ScreenState == FULLSCREEN && independvsync)
                return(0xFFFF);

        if ((cg_flg == FALSE)
                        ||(! ((old_code == (value & 0x7F7F)) && (old_count == cgglobs.counter)))
                        || (fontselchanged)) {
                if (cg_flg == TRUE) {
                        if ((old_code >= USER_GAIJ_START)
                                        && (old_code <= USER_GAIJ_END))
                                gaij_save(old_code);
                }
                if ((value & 0x00FF) == 0)
                        cg_ank_load(value,pattern);
                else {
//                      cgglobs.code &= 0x7F7F;
                        value &= 0x7F7F;
                        if ((value >= USER_GAIJ_START)
                                        && (value <= USER_GAIJ_END))
                                gaij_load(value,pattern);
                        else {
                                if (((value & 0x007f) >= 0x21)
                                                && ((value & 0x007f) <= 0x7e)) {
                                        if (((value >= JIS1_CHAR_START)
                                                        && (value <= JIS1_CHAR_END)) ||
                                                ((value >= JIS1_KANJ_START)
                                                        && (value <= JIS2_KANJ_END)))
                                                cg_all_load(value,pattern);
                                        else {
                                                if ((value >= HALF_CHAR_START)
                                                        && (value <= LARG_KANJ_END))
                                                        cg_half_load(value,pattern);
                                                else {
#if 1                                                           // 931022
                                                        null_write(pattern);// 931022
#else                                                           // 931022
                                                        null_write();
#endif                                                          // 931022
                                                        return(0xFFFF);
                                                }
                                        }
                                } else {
#if 1                                                           // 931022
                                                        null_write(pattern);// 931022
#else                                                           // 931022
                                        null_write();
#endif                                                          // 931022
                                        return(0xFFFF);
                                }
                        }
                }
                if (cg_flg) {
                        old_code = (value & 0x7F7F);
                        old_count = cgglobs.counter;
                }
                return(value);
        }
}

void mapping_init IFN0() {
        CHAR *szBinFileName;
        HANDLE  File,Mapping;
        GAIJ_GLOBS *tmp;
        short   err_no;
        int i;
//      if (HIRESO_MODE)
//              gaijglobs = (GAIJ_GLOBS *) host_malloc(18870);
//      else
#if 1                                                              // 941014
                gaijglobs = (GAIJ_GLOBS *) host_malloc(sizeof(GAIJ_GLOBS) * 0x105);
#else                                                              // 941014
                gaijglobs = (GAIJ_GLOBS *) host_malloc(8670);
#endif
        for (i=0; i<127; i++)
                gaijglobs[i].code = USER_GAIJ_START+i;
        for (i=127; i<254; i++)
                gaijglobs[i].code = USER_GAIJ_START+i+0x81;

        szBinFileName = (CHAR*) malloc(MAX_PATH);
        GetEnvironmentVariable("SystemRoot",szBinFileName,MAX_PATH);
        strncat(szBinFileName,"\\system32\\dot16.bin",MAX_PATH-strlen(szBinFileName));  // HIRESO_MODE dot24.bin
        szBinFileName[MAX_PATH - 1] = '\0';

        File = CreateFile((LPSTR)szBinFileName,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL
                        );
        if (File == INVALID_HANDLE_VALUE) {
                err_no = host_error(EG_SYS_MISSING_FILE, ERR_QUIT, szBinFileName);
                free(szBinFileName);
                TerminateVDM();
        }
        Mapping = CreateFileMapping(File,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                        );
        CloseHandle( File );
        if (Mapping == NULL) {
                err_no = host_error(EG_SYS_MISSING_FILE, ERR_QUIT, szBinFileName);
                free(szBinFileName);
                TerminateVDM();
        }
        Base = MapViewOfFile(Mapping,
                                FILE_MAP_READ,
                                0,
                                0,
                                0
                        );
        CloseHandle( Mapping );
        if (Base == NULL) {
                err_no = host_error(EG_SYS_MISSING_FILE, ERR_QUIT, szBinFileName);
                free(szBinFileName);
                TerminateVDM();
        }
        free(szBinFileName);
}

unsigned short set_bit_pattern IFN2(unsigned short, value, unsigned char *, pattern) {
        int i;
        unsigned short r;
        cg_flg = FALSE;
//      if (value < 0x100) value <<= 8;
        value = (unsigned short) ((value <<8) | (value >>8));
//      if (cg_font_load(value,pattern) == 0xFFFF) {
//              cg_flg = TRUE;
//              return(0xFFFF);
//      } else {
//              for (i=0;i<32;i++)
//                      pattern[i] = pat[i];
//              cg_flg = TRUE;
//              return(value);
        r=cg_font_load(value,pattern);
        cg_flg = TRUE;
        return(r);
//      }
}

unsigned short set_bit_pattern_20 IFN2(unsigned short, value, unsigned char *, pattern) {
        int     i;
        *pattern++ = 0;
        *pattern++ = 0;
        if (set_bit_pattern(value,pattern) == 0xFFFF)
                return(0xFFFF);
        else {
                        for (i=35;i>19;i--)                     // May 25 1994
                                pattern[i] = pattern[i-4];
                        for (i=16;i<20;i++)
                                pattern[i] = 0;
                        pattern[36] = 0;
                        pattern[37] = 0;
        }
        return(value);
}

void cg_save IFN0() {
        if (((cgglobs.code & 0x7F7F)>= USER_GAIJ_START) &&
                 ((cgglobs.code & 0x7F7F)<= USER_GAIJ_END)) {
//          if((cgglobs.code & 0x7f))
                if(cg_lock)
                        return;
                cg_lock = TRUE;
//              gaij_save(cgglobs.code & ~0x80);
//              gaij_save(cgglobs.code);
                gaij_save(cgglobs.code&0x7F7F);
                cg_lock = FALSE;
        }
}

void host_set_gaij_data IFN1(unsigned short, value) {
#ifdef VSYNC                                    // VSYNC
#if 1
    VDM_IOCTL_PARAM param;

  if(is_vdm_register){

    param.dwIoControlCode = IOCTL_VIDEO_SET_FONT_DATA;
    param.cbInBuffer = sizeof(VIDEO_FONT_DATA);
    param.lpvInBuffer = (LPVOID)&gaijglobs[value];
    param.lpvOutBuffer = (LPVOID)NULL;
    param.cbOutBuffer = 0L;

    if(!VDMConsoleOperation(VDM_VIDEO_IOCTL, (LPDWORD)&param)){
        ErrorExit();
    }

  }
#else
        LPVDM_USER_CHAR_PARAM   param;
        param = (LPVDM_USER_CHAR_PARAM) &gaijglobs[value];
        VDMConsoleOperation(    VDM_SET_USER_CHAR,
                                                        (LPDWORD) param
                                        );                                      //      call Console API
#endif
#endif                                          // VSYNC
}

void host_set_all_gaij_data IFN0() {
#ifdef VSYNC                                    // VSYNC
#if 1
    VDM_IOCTL_PARAM param;

    param.dwIoControlCode = IOCTL_VIDEO_SET_ALL_FONT_DATA;
    param.cbInBuffer = sizeof(VIDEO_ALL_FONT_DATA);
    param.lpvInBuffer = (LPVOID)gaijglobs;
    param.lpvOutBuffer = (LPVOID)NULL;
    param.cbOutBuffer = 0L;

    if(!VDMConsoleOperation(VDM_VIDEO_IOCTL, (LPDWORD)&param)){
        ErrorExit();
    }
#else
        int             i;
        for(i =0; i<254; i++) {
//              if ((gaijglobs[i].code < USER_GAIJ_START) ||
//                                                      (gaijglobs[i].code > USER_GAIJ_END)) {
                        host_set_gaij_data((unsigned short) i);
//              }
        }
#endif
#endif                                          // VSYNC
}
void host_sleep(i)
int i;
{
        Sleep(i);
}


void host_get_all_gaij_data IFN0() {
    VDM_IOCTL_PARAM param;

    param.dwIoControlCode = IOCTL_VIDEO_GET_ALL_FONT_DATA;
    param.cbInBuffer = 0L;
    param.lpvInBuffer = (LPVOID)NULL;
    param.lpvOutBuffer = (LPVOID)gaijglobs;
    param.cbOutBuffer = sizeof(VIDEO_ALL_FONT_DATA);

    if(!VDMConsoleOperation(VDM_VIDEO_IOCTL, (LPDWORD)&param)){
        ErrorExit();
    }
}

void video_real_out(DWORD ioctl, word port,word value)
{
    VDM_IOCTL_PARAM param;
    DWORD io_data;

    io_data = (value << 16) + port;
    param.dwIoControlCode = ioctl;
    param.cbInBuffer = 4L;
    param.lpvInBuffer = (LPVOID)&io_data;
    param.cbOutBuffer = 0L;
    param.lpvOutBuffer = NULL;

    if(!VDMConsoleOperation(VDM_VIDEO_IOCTL, (LPDWORD)&param)){
        ErrorExit();
    }

    return;
}

word video_real_in(DWORD ioctl, word port,word value)
{
    VDM_IOCTL_PARAM param;
    DWORD io_data;

    io_data = (value << 16) + port;
    param.dwIoControlCode = ioctl;
    param.cbInBuffer = 4L;
    param.lpvInBuffer = (LPVOID)&io_data;
    param.cbOutBuffer = 0L;
    param.lpvOutBuffer = NULL;

    if(!VDMConsoleOperation(VDM_VIDEO_IOCTL, (LPDWORD)&param)){
        ErrorExit();
    }

    param.dwIoControlCode = IOCTL_VIDEO_GET_IN_DATA;
    param.cbInBuffer = 0L;
    param.lpvInBuffer = NULL;
    param.cbOutBuffer = 4L;
    param.lpvOutBuffer = (LPVOID)&io_data;

    if(!VDMConsoleOperation(VDM_VIDEO_IOCTL, (LPDWORD)&param)){
        ErrorExit();
    }

    return((word)((io_data >> 16) & 0xffff));
}

void protect_inb(word port,word *value)
{
    if(VDMForWOW && port == 0x42) {
        *value = video_real_in(IOCTL_VIDEO_CHAR_IN, port, NULL);
    }
}
void protect_outb(word port,word value)
{
    if(VDMForWOW && port == 0x40) {
        video_real_out(IOCTL_VIDEO_CHAR_OUT, port , value);
    }
}
void protect_inw(word port,word *value)
{
#if 0
    *value = video_real_in(IOCTL_VIDEO_SHORT_IN, port , NULL);
#endif
}
void protect_outw(word port,word value)
{
#if 0
    video_real_out(IOCTL_VIDEO_SHORT_OUT, port, value);
#endif
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_cprgs.c ===
/*
	SccsID = @(#)sun4_cpuregs.c	1.12 3/27/91 Copyright Insignia Solutions Ltd.
*/
#include "host_def.h"
#include "insignia.h"
#include "xt.h"
#include CpuH

#include <stdio.h>


/*
 *  --- SUN_VA  CPU Interface Functions ---
 *
 *  There are two sections here. Compile-time define
 *  the one that is right for you!
 *
 *  CCPU   - use the C         CPU when HW is not available
 *  A2CPU  - use the assembler CPU when HW is not available
 *
 */


/* HW and SW HOST_SIMULATE functions. */
extern void sw_host_simulate ();		/* in ccpu.o AND a2cpu.o  */
extern void hw_host_simulate ();		/* in hcpu/host/hostsim.c */

/*
 *	The function pointers...
 */
#ifdef CCPU
GLOBAL   VOID		(*setLDTR_func ) ();
GLOBAL   word		(*getTR_func ) ();
GLOBAL	 INT		(*getTS_func ) ();
GLOBAL   VOID		(*setEM_func ) ();
GLOBAL   VOID		(*setGDTR_limit_func ) ();
GLOBAL   VOID		(*setIDTR_limit_func ) ();
GLOBAL   VOID		(*setIOPL_func ) ();
GLOBAL   VOID		(*setGDTR_base_func ) ();
GLOBAL   word		(*getLDTR_func ) ();
GLOBAL   VOID		(*setTR_func ) ();
GLOBAL   VOID		(*setTS_func ) ();
GLOBAL	 INT		(*getPE_func ) ();
GLOBAL	 sys_addr	(*getGDTR_base_func ) ();
GLOBAL   word		(*getMSW_reserved_func ) ();
GLOBAL   int		(*getCPL_func ) ();
GLOBAL	 INT		(*getMP_func ) ();
GLOBAL   VOID		(*setPE_func ) ();
GLOBAL   word		(*getGDTR_limit_func ) ();
GLOBAL   word		(*getIDTR_limit_func ) ();
GLOBAL   VOID		(*setMSW_reserved_func) ();
GLOBAL   VOID		(*setMP_func) ();
GLOBAL   VOID		(*setIDTR_base_func) ();
GLOBAL   word		(*getNT_func) ();
GLOBAL   VOID		(*setCPL_func) ();
GLOBAL	 INT		(*getEM_func) ();
GLOBAL   VOID		(*setNT_func ) ();
GLOBAL   sys_addr	(*getIDTR_base_func) ();
#endif

GLOBAL word		(*getAX_func) ();
GLOBAL half_word	(*getAH_func) ();
GLOBAL half_word	(*getAL_func) ();
GLOBAL word		(*getBX_func) ();
GLOBAL half_word	(*getBH_func) ();
GLOBAL half_word	(*getBL_func) ();
GLOBAL word		(*getCX_func) ();
GLOBAL half_word	(*getCH_func) ();
GLOBAL half_word	(*getCL_func) ();
GLOBAL word		(*getDX_func) ();
GLOBAL half_word	(*getDH_func) ();
GLOBAL half_word	(*getDL_func) ();
GLOBAL word		(*getSP_func) ();
GLOBAL word		(*getBP_func) ();
GLOBAL word		(*getSI_func) ();
GLOBAL word		(*getDI_func) ();
GLOBAL word		(*getIP_func) ();
GLOBAL word		(*getCS_func) ();
GLOBAL word		(*getDS_func) ();
GLOBAL word		(*getES_func) ();
GLOBAL word		(*getSS_func) ();
GLOBAL word		(*getMSW_func) ();

#ifdef CCPU
GLOBAL INT		(*getDF_func) ();
GLOBAL INT		(*getIF_func) ();
GLOBAL INT		(*getTF_func) ();
GLOBAL INT		(*getPF_func) ();
GLOBAL INT		(*getAF_func) ();
GLOBAL INT		(*getSF_func) ();
GLOBAL INT		(*getZF_func) ();
GLOBAL INT		(*getOF_func) ();
GLOBAL INT		(*getCF_func) ();
GLOBAL INT		(*getIOPL_func ) ();
#endif

#ifdef A3CPU
GLOBAL word		(*getDF_func) ();
GLOBAL word		(*getIF_func) ();
GLOBAL word		(*getTF_func) ();
GLOBAL word		(*getPF_func) ();
GLOBAL word		(*getAF_func) ();
GLOBAL word		(*getSF_func) ();
GLOBAL word		(*getZF_func) ();
GLOBAL word		(*getOF_func) ();
GLOBAL word		(*getCF_func) ();
GLOBAL word		(*getIOPL_func ) ();
#endif

GLOBAL word		(*getSTATUS_func) ();

GLOBAL double_word	(*getOPA_func) ();
GLOBAL double_word	(*getOPB_func) ();
GLOBAL double_word	(*getOPR_func) ();
GLOBAL sys_addr		(*getSSD_func) ();
GLOBAL sys_addr		(*getDSD_func) ();

GLOBAL VOID		(*setAX_func) ();
GLOBAL VOID		(*setAH_func) ();
GLOBAL VOID		(*setAL_func) ();
GLOBAL VOID		(*setBX_func) ();
GLOBAL VOID		(*setBH_func) ();
GLOBAL VOID		(*setBL_func) ();
GLOBAL VOID		(*setCX_func) ();
GLOBAL VOID		(*setCH_func) ();
GLOBAL VOID		(*setCL_func) ();
GLOBAL VOID		(*setDX_func) ();
GLOBAL VOID		(*setDH_func) ();
GLOBAL VOID		(*setDL_func) ();
GLOBAL VOID		(*setSP_func) ();
GLOBAL VOID		(*setBP_func) ();
GLOBAL VOID		(*setSI_func) ();
GLOBAL VOID		(*setDI_func) ();
GLOBAL VOID		(*setIP_func) ();
GLOBAL INT		(*setCS_func) ();
GLOBAL INT		(*setDS_func) ();
GLOBAL INT		(*setES_func) ();
GLOBAL INT		(*setSS_func) ();
GLOBAL VOID		(*setMSW_func) ();
GLOBAL VOID		(*setDF_func) ();
GLOBAL VOID		(*setIF_func) ();
GLOBAL VOID		(*setTF_func) ();
GLOBAL VOID		(*setPF_func) ();
GLOBAL VOID		(*setAF_func) ();
GLOBAL VOID		(*setSF_func) ();
GLOBAL VOID		(*setZF_func) ();
GLOBAL VOID		(*setOF_func) ();
GLOBAL VOID		(*setCF_func) ();

GLOBAL VOID		(*setOPLEN_func) ();
GLOBAL VOID		(*setOPA_func) ();
GLOBAL VOID		(*setOPB_func) ();
GLOBAL VOID		(*setOPR_func) ();

GLOBAL VOID		(*host_simulate_func) ();

#ifdef CPU_30_STYLE

#ifdef CCPU

GLOBAL VOID load_sw_cpu_access_functions()
{
  IMPORT VOID	c_cpu_simulate();

  fprintf (stderr,"[load_sw_cpu_access_functions] init READ/WRITE functions.\n");

  /* READ functions */
  getAX_func     = c_getAX;
  getAH_func     = c_getAH;
  getAL_func     = c_getAL;
  getBX_func     = c_getBX;
  getBH_func     = c_getBH;
  getBL_func     = c_getBL;
  getCX_func     = c_getCX;
  getCH_func     = c_getCH;
  getCL_func     = c_getCL;
  getDX_func     = c_getDX;
  getDH_func     = c_getDH;
  getDL_func     = c_getDL;
  getSP_func     = c_getSP;
  getBP_func     = c_getBP;
  getSI_func     = c_getSI;
  getDI_func     = c_getDI;
  getIP_func     = c_getIP;
  getCS_func     = c_getCS;
  getDS_func     = c_getDS;
  getES_func     = c_getES;
  getSS_func     = c_getSS;
  getMSW_func    = c_getMSW;
  getDF_func     = c_getDF;
  getIF_func     = c_getIF;
  getTF_func     = c_getTF;
  getPF_func     = c_getPF;
  getAF_func     = c_getAF;
  getSF_func     = c_getSF;
  getZF_func     = c_getZF;
  getOF_func     = c_getOF;
  getCF_func     = c_getCF;

  
  /* WRITE functions */  
  setAX_func     = c_setAX;
  setAH_func     = c_setAH;
  setAL_func     = c_setAL;
  setBX_func     = c_setBX;
  setBH_func     = c_setBH;
  setBL_func     = c_setBL;
  setCX_func     = c_setCX;
  setCH_func     = c_setCH;
  setCL_func     = c_setCL;
  setDX_func     = c_setDX;
  setDH_func     = c_setDH;
  setDL_func     = c_setDL;
  setSP_func     = c_setSP;
  setBP_func     = c_setBP;
  setSI_func     = c_setSI;
  setDI_func     = c_setDI;
  setIP_func     = c_setIP;
  setDF_func     = c_setDF;
  setIF_func     = c_setIF;
  setTF_func     = c_setTF;
  setPF_func     = c_setPF;
  setAF_func     = c_setAF;
  setSF_func     = c_setSF;
  setZF_func     = c_setZF;
  setOF_func     = c_setOF;
  setCF_func     = c_setCF;
  setSS_func	 = c_setSS;
  setDS_func     = c_setDS;
  setES_func     = c_setES;
  setCS_func     = c_setCS;

  /* SW HOST_SIMULATE function */
  host_simulate_func = c_cpu_simulate;
}
#endif /* CCPU */


/* Temporary 3.0 stubs... */
#ifdef A3CPU

LOCAL double_word	a3_na_gOPA()
{
	printf ("%s:%d - getOPA() not supported.\n", __FILE__, __LINE__);
	return 0;
}
LOCAL double_word	a3_na_gOPB()
{
	printf ("%s:%d - getOPB() not supported.\n", __FILE__, __LINE__);
	return 0;
}
LOCAL double_word	a3_na_gOPR ()
{
	printf ("%s:%d - getOPR() not supported.\n", __FILE__, __LINE__);
	return 0;
}
LOCAL sys_addr		a3_na_gSSD()
{
	printf ("%s:%d - getSSD() not supported.\n", __FILE__, __LINE__);
	return 0;
}
LOCAL sys_addr		a3_na_gDSD()
{
	printf ("%s:%d - getDSD() not supported.\n", __FILE__, __LINE__);
	return 0;
}
LOCAL VOID		a3_na_sOPLEN()
{
	printf ("%s:%d - setOPLEN() not supported.\n", __FILE__, __LINE__);
}
LOCAL VOID		a3_na_sOPA()
{
	printf ("%s:%d - setOPA() not supported.\n", __FILE__, __LINE__);
}
LOCAL VOID		a3_na_sOPB()
{
	printf ("%s:%d - setOPB() not supported.\n", __FILE__, __LINE__);
}
LOCAL VOID		a3_na_sOPR()
{
	printf ("%s:%d - setOPR() not supported.\n", __FILE__, __LINE__);
}
LOCAL VOID		a3_na_sMSW()
{
	printf ("%s:%d - setMSW() not supported.\n", __FILE__, __LINE__);
}

GLOBAL VOID load_sw_cpu_access_functions ()
{
  IMPORT VOID	_asm_simulate();

  fprintf (stderr,"[load_sw_cpu_access_functions] init READ/WRITE functions.\n");

  /* READ functions */
  getAX_func     = a3_getAX;
  getAH_func     = a3_getAH;
  getAL_func     = a3_getAL;
  getBX_func     = a3_getBX;
  getBH_func     = a3_getBH;
  getBL_func     = a3_getBL;
  getCX_func     = a3_getCX;
  getCH_func     = a3_getCH;
  getCL_func     = a3_getCL;
  getDX_func     = a3_getDX;
  getDH_func     = a3_getDH;
  getDL_func     = a3_getDL;
  getSP_func     = a3_getSP;
  getBP_func     = a3_getBP;
  getSI_func     = a3_getSI;
  getDI_func     = a3_getDI;
  getIP_func     = a3_getIP;
  getOPA_func    = a3_na_gOPA;
  getOPB_func    = a3_na_gOPB;   
  getOPR_func    = a3_na_gOPR;   
  getSSD_func    = a3_na_gSSD;   
  getDSD_func    = a3_na_gDSD;   
  getCS_func     = a3_getCS;
  getDS_func     = a3_getDS;
  getES_func     = a3_getES;
  getSS_func     = a3_getSS;
  getMSW_func    = a3_getMSW;
  getDF_func     = a3_getDF;
  getIF_func     = a3_getIF;
  getTF_func     = a3_getTF;
  getPF_func     = a3_getPF;
  getAF_func     = a3_getAF;
  getSF_func     = a3_getSF;
  getZF_func     = a3_getZF;
  getOF_func     = a3_getOF;
  getCF_func     = a3_getCF;

  
  /* WRITE functions */  
  setAX_func     = a3_setAX;
  setAH_func     = a3_setAH;
  setAL_func     = a3_setAL;
  setBX_func     = a3_setBX;
  setBH_func     = a3_setBH;
  setBL_func     = a3_setBL;
  setCX_func     = a3_setCX;
  setCH_func     = a3_setCH;
  setCL_func     = a3_setCL;
  setDX_func     = a3_setDX;
  setDH_func     = a3_setDH;
  setDL_func     = a3_setDL;
  setSP_func     = a3_setSP;
  setBP_func     = a3_setBP;
  setSI_func     = a3_setSI;
  setDI_func     = a3_setDI;
  setIP_func     = a3_setIP;
  setMSW_func    = a3_na_sMSW;
  setDF_func     = a3_setDF;
  setIF_func     = a3_setIF;
  setTF_func     = a3_setTF;
  setPF_func     = a3_setPF;
  setAF_func     = a3_setAF;
  setSF_func     = a3_setSF;
  setZF_func     = a3_setZF;
  setOF_func     = a3_setOF;
  setCF_func     = a3_setCF;
  setOPLEN_func  = a3_na_sOPLEN;   
  setOPA_func    = a3_na_sOPA;     
  setOPB_func    = a3_na_sOPB;     
  setOPR_func    = a3_na_sOPR;     
  setSS_func	 = a3_setSS;
  setDS_func     = a3_setDS;
  setES_func     = a3_setES;
  setCS_func     = a3_setCS;

  /* SW HOST_SIMULATE function */
  host_simulate_func = _asm_simulate;
}
#endif /* A3CPU */

#else /* CPU_30_STYLE */


#ifdef CCPU
/*
 *     ----------------------------------------
 *     ---- SUN_VA   Soft CCPU   Interface ----
 *     ----------------------------------------
 */

extern reg A;
extern reg B;
extern reg C;
extern reg D;
extern reg SP;
extern reg BP;
extern reg SI;
extern reg DI;
extern reg CS;
extern reg DS;
extern reg SS;
extern reg ES;
extern reg IP;

extern word m_s_w;

extern void ext_load_CS();
extern void ext_load_DS();
extern void ext_load_ES();
extern void ext_load_SS();


word soft_ccpu_getAX ()
{
   return (A.X);
}

half_word soft_ccpu_getAH ()
{
   return (A.byte.high);
}

half_word soft_ccpu_getAL ()
{
   return (A.byte.low);
}

word soft_ccpu_getBX ()
{
   return (B.X);
}

half_word soft_ccpu_getBH ()
{
   return (B.byte.high);
}

half_word soft_ccpu_getBL ()
{
   return (B.byte.low);
}

word soft_ccpu_getCX ()
{
   return (C.X);
}

half_word soft_ccpu_getCH ()
{
   return (C.byte.high);
}

half_word soft_ccpu_getCL ()
{
   return (C.byte.low);
}

word soft_ccpu_getDX ()
{
   return (D.X);
}

half_word soft_ccpu_getDH ()
{
   return (D.byte.high);
}

half_word soft_ccpu_getDL ()
{
   return (D.byte.low);
}

word soft_ccpu_getSP ()
{
   return (SP.X);
}

word soft_ccpu_getBP ()
{
   return (BP.X);
}

word soft_ccpu_getSI ()
{
   return (SI.X);
}

word soft_ccpu_getDI ()
{
   return (DI.X);
}

word soft_ccpu_getIP ()
{
   return (IP.X);
}

word soft_ccpu_getCS ()
{
   return (CS.X);
}

word soft_ccpu_getDS ()
{
   return (DS.X);
}

word soft_ccpu_getES ()
{
   return (ES.X);
}

word soft_ccpu_getSS ()
{
   return (SS.X);
}

word soft_ccpu_getMSW ()
{
   return ((m_s_w));
}

word soft_ccpu_getDF ()
{
   return (STATUS_DF);
}

word soft_ccpu_getIF ()
{
   return (STATUS_IF);
}

word soft_ccpu_getTF ()
{
   return (STATUS_TF);
}

word soft_ccpu_getPF ()
{
   return (STATUS_PF);
}

word soft_ccpu_getAF ()
{
   return (STATUS_AF);
}

word soft_ccpu_getSF ()
{
   return (STATUS_SF);
}

word soft_ccpu_getZF ()
{
   return (STATUS_ZF);
}

word soft_ccpu_getOF ()
{
   return (STATUS_OF);
}

word soft_ccpu_getCF ()
{
   return (STATUS_CF);
}

word soft_ccpu_getSTATUS ()
{
   return (getCF()         |
           getOF()   << 11 |
           getZF()   << 6  |
           getSF()   << 7  |
           getAF()   << 4  |
           getPF()   << 2  |
           getTF()   << 8  |
           getIF()   << 9  |
           getDF()   << 10 |
           getIOPL() << 12 |
           getNT()   << 14);
}

int soft_ccpu_getCPL ()
{
   return (CPL);
}
 
sys_addr soft_ccpu_getGDTR_base ()
{
   return (GDTR_base);
}
 
sys_addr soft_ccpu_getIDTR_base ()
{
   return (IDTR_base);
}
 
word soft_ccpu_getGDTR_limit ()
{
   return (GDTR_limit);
}
 
word soft_ccpu_getIDTR_limit ()
{
   return (IDTR_limit);
}
 
word soft_ccpu_getLDTR ()
{
   return (LDTR.X);
}
 
word soft_ccpu_getTR ()
{
   return (TR.X);
}
 
word soft_ccpu_getMSW_reserved ()
{
   return (MSW.reserved);
}
 
word soft_ccpu_getTS ()
{
   return (MSW.TS);
}
 
word soft_ccpu_getEM ()
{
   return (MSW.EM);
}
 
word soft_ccpu_getMP ()
{
   return (MSW.MP);
}
 
word soft_ccpu_getPE ()
{
   return (MSW.PE);
}
 
word soft_ccpu_getNT ()
{
   return (STATUS_NT);
}
 
word soft_ccpu_getIOPL ()
{
   return (STATUS_IOPL);
}
 
void soft_ccpu_setAX (val)
unsigned int val;
{
  A.X = val;
}

void soft_ccpu_setAH (val)
unsigned int val;
{
  A.byte.high = val;
}

void soft_ccpu_setAL (val)
unsigned int val;
{
  A.byte.low = val;
}

void soft_ccpu_setBX (val)
unsigned int val;
{
  B.X = val;
}

void soft_ccpu_setBH (val)
unsigned int val;
{
  B.byte.high = val;
}

void soft_ccpu_setBL (val)
unsigned int val;
{
  B.byte.low = val;
}

void soft_ccpu_setCX (val)
unsigned int val;
{
  C.X = val;
}

void soft_ccpu_setCH (val)
unsigned int val;
{
  C.byte.high = val;
}

void soft_ccpu_setCL (val)
unsigned int val;
{
  C.byte.low = val;
}

void soft_ccpu_setDX (val)
unsigned int val;
{
  D.X = val;
}

void soft_ccpu_setDH (val)
unsigned int val;
{
  D.byte.high = val;
}

void soft_ccpu_setDL (val)
unsigned int val;
{
  D.byte.low = val;
}

void soft_ccpu_setSP (val)
unsigned int val;
{
  SP.X = val;
}

void soft_ccpu_setBP (val)
unsigned int val;
{
  BP.X = val;
}

void soft_ccpu_setSI (val)
unsigned int val;
{
  SI.X = val;
}

void soft_ccpu_setDI (val)
unsigned int val;
{
  DI.X = val;
}

void soft_ccpu_setIP (val)
unsigned int val;
{
  IP.X = val;
}

void soft_ccpu_setMSW (val)
unsigned int val;
{
  m_s_w = val;
}

void soft_ccpu_setDF (val)
unsigned int val;
{
  STATUS_DF = val;
}

void soft_ccpu_setIF (val)
unsigned int val;
{
  STATUS_IF = val;
}

void soft_ccpu_setTF (val)
unsigned int val;
{
  STATUS_TF = val;
}

void soft_ccpu_setPF (val)
unsigned int val;
{
  STATUS_PF = val;
}

void soft_ccpu_setAF (val)
unsigned int val;
{
  STATUS_AF = val;
}

void soft_ccpu_setSF (val)
unsigned int val;
{
  STATUS_SF = val;
}

void soft_ccpu_setZF (val)
unsigned int val;
{
  STATUS_ZF = val;
}

void soft_ccpu_setOF (val)
unsigned int val;
{
  STATUS_OF = val;
}

void soft_ccpu_setCF (val)
unsigned int val;
{
  STATUS_CF = val;
}

void soft_ccpu_setCPL ( val )
int	val;
{
	CPL = val;
}
 
void soft_ccpu_setGDTR_base ( val )
sys_addr	val;
{
	GDTR_base = val;
}
 
void soft_ccpu_setIDTR_base ( val )
sys_addr	val;
{
	IDTR_base = val;
}
 
void soft_ccpu_setGDTR_limit ( val )
word	val;
{
	GDTR_limit = val;
}
 
void soft_ccpu_setIDTR_limit ( val )
word	val;
{
	IDTR_limit = val;
}
 
void soft_ccpu_setLDTR ( val )
word	val;
{
	LDTR.X = val;
}
 
void soft_ccpu_setTR ( val )
word	val;
{
	TR.X = val;
}
 
void soft_ccpu_setMSW_reserved ( val )
word	val;
{
	MSW.reserved = val;
}
 
void soft_ccpu_setTS ( val )
word	val;
{
	MSW.TS = val;
}
 
void soft_ccpu_setEM ( val )
word	val;
{
	MSW.EM = val;
}
 
void soft_ccpu_setMP ( val )
word	val;
{
	MSW.MP = val;
}
 
void soft_ccpu_setPE ( val )
word	val;
{
	MSW.PE = val;
}
 
void soft_ccpu_setNT ( val )
word	val;
{
	STATUS_NT = val;
}
 
void soft_ccpu_setIOPL ( val )
word	val;
{
	STATUS_IOPL = val;
}





void
load_sw_cpu_access_functions ()
{
  /* READ functions */
  getAX_func     = soft_ccpu_getAX;
  getAH_func     = soft_ccpu_getAH;
  getAL_func     = soft_ccpu_getAL;
  getBX_func     = soft_ccpu_getBX;
  getBH_func     = soft_ccpu_getBH;
  getBL_func     = soft_ccpu_getBL;
  getCX_func     = soft_ccpu_getCX;
  getCH_func     = soft_ccpu_getCH;
  getCL_func     = soft_ccpu_getCL;
  getDX_func     = soft_ccpu_getDX;
  getDH_func     = soft_ccpu_getDH;
  getDL_func     = soft_ccpu_getDL;
  getSP_func     = soft_ccpu_getSP;
  getBP_func     = soft_ccpu_getBP;
  getSI_func     = soft_ccpu_getSI;
  getDI_func     = soft_ccpu_getDI;
  getIP_func     = soft_ccpu_getIP;
  getCS_func     = soft_ccpu_getCS;
  getDS_func     = soft_ccpu_getDS;
  getES_func     = soft_ccpu_getES;
  getSS_func     = soft_ccpu_getSS;
  getMSW_func    = soft_ccpu_getMSW;
  getDF_func     = soft_ccpu_getDF;
  getIF_func     = soft_ccpu_getIF;
  getTF_func     = soft_ccpu_getTF;
  getPF_func     = soft_ccpu_getPF;
  getAF_func     = soft_ccpu_getAF;
  getSF_func     = soft_ccpu_getSF;
  getZF_func     = soft_ccpu_getZF;
  getOF_func     = soft_ccpu_getOF;
  getCF_func     = soft_ccpu_getCF;
  getSTATUS_func = soft_ccpu_getSTATUS;             /* not used in a2CPU */
  getCPL_func = soft_ccpu_getCPL;                   /* not used in a2CPU */
  getGDTR_base_func = soft_ccpu_getGDTR_base;       /* not used in a2CPU */
  getGDTR_limit_func = soft_ccpu_getGDTR_limit;     /* not used in a2CPU */
  getIDTR_base_func = soft_ccpu_getIDTR_base;       /* not used in a2CPU */
  getIDTR_limit_func = soft_ccpu_getIDTR_limit;     /* not used in a2CPU */
  getLDTR_func = soft_ccpu_getLDTR;                 /* not used in a2CPU */
  getTR_func = soft_ccpu_getTR;                     /* not used in a2CPU */
  getMSW_reserved_func = soft_ccpu_getMSW_reserved; /* not used in a2CPU */
  getTS_func = soft_ccpu_getTS;                     /* not used in a2CPU */
  getEM_func = soft_ccpu_getEM;                     /* not used in a2CPU */
  getMP_func = soft_ccpu_getMP;                     /* not used in a2CPU */
  getPE_func = soft_ccpu_getPE;                     /* not used in a2CPU */
  getNT_func = soft_ccpu_getNT;                     /* not used in a2CPU */
  getIOPL_func = soft_ccpu_getIOPL;                 /* not used in a2CPU */

  
  /* WRITE functions */  
  setAX_func     = soft_ccpu_setAX;
  setAH_func     = soft_ccpu_setAH;
  setAL_func     = soft_ccpu_setAL;
  setBX_func     = soft_ccpu_setBX;
  setBH_func     = soft_ccpu_setBH;
  setBL_func     = soft_ccpu_setBL;
  setCX_func     = soft_ccpu_setCX;
  setCH_func     = soft_ccpu_setCH;
  setCL_func     = soft_ccpu_setCL;
  setDX_func     = soft_ccpu_setDX;
  setDH_func     = soft_ccpu_setDH;
  setDL_func     = soft_ccpu_setDL;
  setSP_func     = soft_ccpu_setSP;
  setBP_func     = soft_ccpu_setBP;
  setSI_func     = soft_ccpu_setSI;
  setDI_func     = soft_ccpu_setDI;
  setIP_func     = soft_ccpu_setIP;
  setCS_func	 = ext_load_CS;
  setDS_func     = ext_load_DS;
  setES_func     = ext_load_ES;
  setSS_func     = ext_load_SS;
  setMSW_func    = soft_ccpu_setMSW;
  setDF_func     = soft_ccpu_setDF;
  setIF_func     = soft_ccpu_setIF;
  setTF_func     = soft_ccpu_setTF;
  setPF_func     = soft_ccpu_setPF;
  setAF_func     = soft_ccpu_setAF;
  setSF_func     = soft_ccpu_setSF;
  setZF_func     = soft_ccpu_setZF;
  setOF_func     = soft_ccpu_setOF;
  setCF_func     = soft_ccpu_setCF;
  setCPL_func = soft_ccpu_setCPL;	            /* not used in a2CPU */
  setGDTR_base_func = soft_ccpu_setGDTR_base;       /* not used in a2CPU */
  setGDTR_limit_func = soft_ccpu_setGDTR_limit;     /* not used in a2CPU */
  setIDTR_base_func = soft_ccpu_setIDTR_base;       /* not used in a2CPU */
  setIDTR_limit_func = soft_ccpu_setIDTR_limit;     /* not used in a2CPU */
  setLDTR_func = soft_ccpu_setLDTR;                 /* not used in a2CPU */
  setTR_func = soft_ccpu_setTR;                     /* not used in a2CPU */
  setMSW_reserved_func = soft_ccpu_setMSW_reserved; /* not used in a2CPU */
  setTS_func = soft_ccpu_setTS;                     /* not used in a2CPU */
  setEM_func = soft_ccpu_setEM;                     /* not used in a2CPU */
  setMP_func = soft_ccpu_setMP;                     /* not used in a2CPU */
  setPE_func = soft_ccpu_setPE;                     /* not used in a2CPU */
  setNT_func = soft_ccpu_setNT;                     /* not used in a2CPU */
  setIOPL_func = soft_ccpu_setIOPL;                 /* not used in a2CPU */

  /* SW HOST_SIMULATE function */
  host_simulate_func = sw_host_simulate;
}
#endif CCPU















#ifdef A2CPU
/*
 *     --------------------------------------------
 *     ---- SUN_VA   Assember CCPU   Interface ----
 *     --------------------------------------------
 */

/* need extern definition for M[] */
#include  "sas.h"

extern sreg INTEL_STATUS;
extern void	(*R_ROUTE)();
extern int	R_INTR;
extern reg R_AX;		/* Accumulator		*/
extern reg R_BX;		/* Base			*/
extern reg R_CX;		/* Count		*/
extern reg R_DX;		/* Data			*/
extern reg R_SP;		/* Stack Pointer	*/
extern reg R_BP;		/* Base pointer		*/
extern reg R_SI;		/* Source Index		*/
extern reg R_DI;		/* Destination Index	*/

extern double_word R_OPA;
extern double_word R_OPB;
extern double_word R_OPR;
extern int	R_MISC_FLAGS;

extern sys_addr R_IP;		/* Instruction Pointer	*/

extern sys_addr R_ACT_CS;	/* Code Segment	*/
extern sys_addr R_ACT_DS;	/* Data Segment */
extern sys_addr R_ACT_SS;	/* Stack Segment */
extern sys_addr R_ACT_ES;	/* Extra Segment */

extern sys_addr R_DEF_SS;	/* Default SS register  */
extern sys_addr R_DEF_DS;	/* Default DS register  */

extern void do_setSF();
extern void do_setOF();
extern void do_setPF();
extern void do_setZF();
extern void do_setCF();


word soft_a2cpu_getAX ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getAX\n");
#endif MIKE_DEBUG
   return (R_AX.X);
}

half_word soft_a2cpu_getAH ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getAH\n");
#endif MIKE_DEBUG
   return (R_AX.byte.high);
}

half_word soft_a2cpu_getAL ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getAL\n");
#endif MIKE_DEBUG
   return (R_AX.byte.low);
}

word soft_a2cpu_getBX ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getBX\n");
#endif MIKE_DEBUG
   return (R_BX.X);
}

half_word soft_a2cpu_getBH ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getBH\n");
#endif MIKE_DEBUG
   return (R_BX.byte.high);
}

half_word soft_a2cpu_getBL ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getBL\n");
#endif MIKE_DEBUG
   return (R_BX.byte.low);
}

word soft_a2cpu_getCX ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getCX\n");
#endif MIKE_DEBUG
   return (R_CX.X);
}

half_word soft_a2cpu_getCH ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getCH\n");
#endif MIKE_DEBUG
   return (R_CX.byte.high);
}

half_word soft_a2cpu_getCL ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getCL\n");
#endif MIKE_DEBUG
   return (R_CX.byte.low);
}

word soft_a2cpu_getDX ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getDX\n");
#endif MIKE_DEBUG
   return (R_DX.X);
}

half_word soft_a2cpu_getDH ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getDH\n");
#endif MIKE_DEBUG
   return (R_DX.byte.high);
}

half_word soft_a2cpu_getDL ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getDL\n");
#endif MIKE_DEBUG
   return (R_DX.byte.low);
}

word soft_a2cpu_getSP ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getSP\n");
#endif MIKE_DEBUG
   return (R_SP.X);
}

word soft_a2cpu_getBP ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getBP\n");
#endif MIKE_DEBUG
   return (R_BP.X);
}

word soft_a2cpu_getSI ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getSI\n");
#endif MIKE_DEBUG
   return (R_SI.X);
}

word soft_a2cpu_getDI ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getDI\n");
#endif MIKE_DEBUG
   return (R_DI.X);
}

word soft_a2cpu_getIP ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getIP\n");
#endif MIKE_DEBUG
   return (R_IP - (sys_addr)M - (sys_addr)(getCS() << 4) );
}


double_word soft_a2cpu_getOPA ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getOPA\n");
#endif MIKE_DEBUG
   return (R_OPA);
}

double_word soft_a2cpu_getOPB ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getOPB\n");
#endif MIKE_DEBUG
   return (R_OPB);
}

double_word soft_a2cpu_getOPR ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getOPR=0x%x\n",R_OPR);
#endif MIKE_DEBUG
   return (R_OPR);
}

sys_addr soft_a2cpu_getSSD ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getSSD\n");
#endif MIKE_DEBUG
   return ((R_ACT_SS - (sys_addr)M) >> 4);
}

sys_addr soft_a2cpu_getDSD ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getDSD\n");
#endif MIKE_DEBUG
   return ((R_ACT_DS - (sys_addr)M) >> 4);
}

word soft_a2cpu_getCS ()
{
#ifdef MIKE_DEBUG
unsigned int tmp;

   tmp = ((R_ACT_CS - (sys_addr)M) >> 4);
   fprintf (stderr,"getCS, return=0x%x [M=0x%x R_ACT_CS=0x%x]\n",tmp,M,R_ACT_CS);
#endif MIKE_DEBUG
   return ((R_ACT_CS - (sys_addr)M) >> 4);
}

word soft_a2cpu_getDS ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getDS\n");
#endif MIKE_DEBUG
   return (getDSD());
}

word soft_a2cpu_getES ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getES\n");
#endif MIKE_DEBUG
   return ((R_ACT_ES - (sys_addr)M) >> 4);
}

word soft_a2cpu_getSS ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getSS\n");
#endif MIKE_DEBUG
   return (getSSD());
}

word soft_a2cpu_getMSW ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getMSW\n");
#endif MIKE_DEBUG
   return ((m_s_w));
}

word soft_a2cpu_getDF ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getDF\n");
#endif MIKE_DEBUG
   return (INTEL_STATUS.DF);
}

word soft_a2cpu_getIF ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getIF\n");
#endif MIKE_DEBUG
   return (INTEL_STATUS.IF);
}

word soft_a2cpu_getTF ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getTF\n");
#endif MIKE_DEBUG
   return (INTEL_STATUS.TF);
}

word soft_a2cpu_getPF ()
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"getPF=0x%x\n",pf_table[getOPR() & 0xff]);
#endif MIKE_DEBUG
  return (pf_table[getOPR() & 0xff]);
}

word soft_a2cpu_getAF ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getAF\n");
#endif MIKE_DEBUG
   return (((((getOPA()) ^ (getOPB())) ^ (getOPR())) >> 4) & 1);
}

word soft_a2cpu_getSF ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getSF\n");
#endif MIKE_DEBUG
   return ((IS_BYTE_OP ? getOPR() >> 7 : getOPR() >> 15 ) & 1);
}

word soft_a2cpu_getZF ()
{
#ifdef MIKE_DEBUG
word tmp;

   tmp = (REALLY_ZERO ? 1 : (IS_BYTE_OP ? ((getOPR() & 0xff) ? 0 : 1) : ((getOPR() & 0xffff) ? 0 : 1)));
   fprintf (stderr,"getZF=0x%x\n",tmp);
#endif MIKE_DEBUG
   return (REALLY_ZERO ? 1 : (IS_BYTE_OP ? ((getOPR() & 0xff) ? 0 : 1) : ((getOPR() & 0xffff) ? 0 : 1)));
}

word soft_a2cpu_getOF ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getOF\n");
#endif MIKE_DEBUG
   return ((IS_BYTE_OP ? (((getOPR() ^ getOPA() ^ getOPB()) ^ (getOPR() >> 1)) >> 7) & 1 : ((getOPR() ^ getOPA() ^ getOPB()) ^ (getOPR() >> 1)) >> 15 ) & 1 );
}

word soft_a2cpu_getCF ()
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"getCF\n");
#endif MIKE_DEBUG
   return ((IS_BYTE_OP ? getOPR() >> 8 : getOPR() >> 16) & 1);
}


#define getRET()
#define setRET(x)

 
void soft_a2cpu_setAX (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"setAX\n");
#endif MIKE_DEBUG
   R_AX.X = val;
}

void soft_a2cpu_setAH (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
   fprintf (stderr,"setAH\n");
#endif MIKE_DEBUG
   R_AX.byte.high = val;
}

void soft_a2cpu_setAL (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setAL\n");
#endif MIKE_DEBUG
  R_AX.byte.low = val;
}

void soft_a2cpu_setBX (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setBX\n");
#endif MIKE_DEBUG
  R_BX.X = val;
}

void soft_a2cpu_setBH (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setBH\n");
#endif MIKE_DEBUG
  R_BX.byte.high = val;
}

void soft_a2cpu_setBL (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setBL\n");
#endif MIKE_DEBUG
  R_BX.byte.low = val;
}

void soft_a2cpu_setCX (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setCX\n");
#endif MIKE_DEBUG
  R_CX.X = val;
}

void soft_a2cpu_setCH (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setCH\n");
#endif MIKE_DEBUG
  R_CX.byte.high = val;
}

void soft_a2cpu_setCL (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setCL\n");
#endif MIKE_DEBUG
  R_CX.byte.low = val;
}

void soft_a2cpu_setDX (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setDX\n");
#endif MIKE_DEBUG
  R_DX.X = val;
}

void soft_a2cpu_setDH (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setDH\n");
#endif MIKE_DEBUG
  R_DX.byte.high = val;
}

void soft_a2cpu_setDL (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setDL\n");
#endif MIKE_DEBUG
  R_DX.byte.low = val;
}

void soft_a2cpu_setSP (val)
unsigned int val;
{
  R_SP.X = val;
#ifdef MIKE_DEBUG
  fprintf (stderr,"setSP to 0x%x [val=0x%x]\n",R_SP.X,val);
#endif MIKE_DEBUG
}

void soft_a2cpu_setBP (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setBP\n");
#endif MIKE_DEBUG
  R_BP.X = val;
}

void soft_a2cpu_setSI (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setSI\n");
#endif MIKE_DEBUG
  R_SI.X = val;
}

void soft_a2cpu_setDI (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setDI\n");
#endif MIKE_DEBUG
  R_DI.X = val;
}

void soft_a2cpu_setIP (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
unsigned int tmp;
#endif MIKE_DEBUG

  R_IP = val + (sys_addr)M +(sys_addr) (getCS() << 4);
#ifdef MIKE_DEBUG
  tmp = getCS ();
  fprintf (stderr,"setIP to 0x%x [M=0x%x getCS()=0x%x]\n",R_IP,M,tmp);
#endif MIKE_DEBUG
}

void soft_a2cpu_setMSW (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setMSW\n");
#endif MIKE_DEBUG
  m_s_w = val;
}

void soft_a2cpu_setDF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setDF\n");
#endif MIKE_DEBUG
  INTEL_STATUS.DF = val;
}

void soft_a2cpu_setIF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setIF\n");
#endif MIKE_DEBUG
  INTEL_STATUS.IF = val;
}

void soft_a2cpu_setTF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setTF\n");
#endif MIKE_DEBUG
  INTEL_STATUS.TF = val;
}

void soft_a2cpu_setPF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
word tmp;
#endif MIKE_DEBUG

  do_setPF (val);
#ifdef MIKE_DEBUG
  tmp = soft_a2cpu_getPF();
  fprintf (stderr,"setPF to 0x%x. Read back as 0x%x\n",val,tmp);
#endif MIKE_DEBUG
}

void soft_a2cpu_setAF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setAF\n");
#endif MIKE_DEBUG
  setOPA (val << 4);
  setOPB (getOPR() & 0x7f);
}

void soft_a2cpu_setSF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setSF\n");
#endif MIKE_DEBUG
  do_setSF (val);
}

void soft_a2cpu_setZF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setZF\n");
#endif MIKE_DEBUG
  do_setZF (val);
}

void soft_a2cpu_setOF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setOF\n");
#endif MIKE_DEBUG
  do_setOF (val);
}

void soft_a2cpu_setCF (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setCF\n");
#endif MIKE_DEBUG
  do_setCF (val);
}

void soft_a2cpu_setOPLEN (val)
unsigned int val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setOPLEN\n");
#endif MIKE_DEBUG
  R_MISC_FLAGS &= 0x7fffffff;
  R_MISC_FLAGS |= val;
}

void soft_a2cpu_setOPA (val)
double_word val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setOPA\n");
#endif MIKE_DEBUG
  R_OPA   = val;
}

void soft_a2cpu_setOPB (val)
double_word val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setOPB\n");
#endif MIKE_DEBUG
  R_OPB   = val;
}

void soft_a2cpu_setOPR (val)
double_word val;
{
#ifdef MIKE_DEBUG
  fprintf (stderr,"setOPR\n");
#endif MIKE_DEBUG
  R_OPR   = val;
}

void soft_a2cpu_setSS (val)
sys_addr val;
{
  R_ACT_SS = (sys_addr)M + (val << 4);
#ifdef MIKE_DEBUG
  fprintf (stderr,"setSS to 0x%x [M=0x%x,val=0x%x]\n",R_ACT_SS,M,val);
#endif MIKE_DEBUG
}

void soft_a2cpu_setDS (val)
sys_addr val;
{
  R_ACT_DS = (sys_addr)M + (val << 4);
#ifdef MIKE_DEBUG
  fprintf (stderr,"setDS to 0x%x [M=0x%x val=0x%x]\n",R_ACT_DS,M,val);
#endif MIKE_DEBUG
}

void soft_a2cpu_setES (val)
sys_addr val;
{
  R_ACT_ES = ((sys_addr)M + (val << 4));
#ifdef MIKE_DEBUG
  fprintf (stderr,"setES to 0x%x [M=0x%x val=0x%x]\n",R_ACT_ES,M,val);
#endif MIKE_DEBUG
}

void soft_a2cpu_setCS (val)
sys_addr val;
{
  R_ACT_CS = (sys_addr)M + (val << 4);
#ifdef MIKE_DEBUG
  fprintf (stderr,"setCS to 0x%x [M=0x%x val=0x%x]\n",R_ACT_CS,M,val);
#endif MIKE_DEBUG
}




void
load_sw_cpu_access_functions ()
{
  fprintf (stderr,"[load_sw_cpu_access_functions] init READ/WRITE functions.\n");

  /* READ functions */
  getAX_func     = soft_a2cpu_getAX;
  getAH_func     = soft_a2cpu_getAH;
  getAL_func     = soft_a2cpu_getAL;
  getBX_func     = soft_a2cpu_getBX;
  getBH_func     = soft_a2cpu_getBH;
  getBL_func     = soft_a2cpu_getBL;
  getCX_func     = soft_a2cpu_getCX;
  getCH_func     = soft_a2cpu_getCH;
  getCL_func     = soft_a2cpu_getCL;
  getDX_func     = soft_a2cpu_getDX;
  getDH_func     = soft_a2cpu_getDH;
  getDL_func     = soft_a2cpu_getDL;
  getSP_func     = soft_a2cpu_getSP;
  getBP_func     = soft_a2cpu_getBP;
  getSI_func     = soft_a2cpu_getSI;
  getDI_func     = soft_a2cpu_getDI;
  getIP_func     = soft_a2cpu_getIP;
  getOPA_func    = soft_a2cpu_getOPA;	/* not used in CCPU */
  getOPB_func    = soft_a2cpu_getOPB;   /* not used in CCPU */
  getOPR_func    = soft_a2cpu_getOPR;   /* not used in CCPU */
  getSSD_func    = soft_a2cpu_getSSD;   /* not used in CCPU */
  getDSD_func    = soft_a2cpu_getDSD;   /* not used in CCPU */
  getCS_func     = soft_a2cpu_getCS;
  getDS_func     = soft_a2cpu_getDS;
  getES_func     = soft_a2cpu_getES;
  getSS_func     = soft_a2cpu_getSS;
  getMSW_func    = soft_a2cpu_getMSW;
  getDF_func     = soft_a2cpu_getDF;
  getIF_func     = soft_a2cpu_getIF;
  getTF_func     = soft_a2cpu_getTF;
  getPF_func     = soft_a2cpu_getPF;
  getAF_func     = soft_a2cpu_getAF;
  getSF_func     = soft_a2cpu_getSF;
  getZF_func     = soft_a2cpu_getZF;
  getOF_func     = soft_a2cpu_getOF;
  getCF_func     = soft_a2cpu_getCF;

  
  /* WRITE functions */  
  setAX_func     = soft_a2cpu_setAX;
  setAH_func     = soft_a2cpu_setAH;
  setAL_func     = soft_a2cpu_setAL;
  setBX_func     = soft_a2cpu_setBX;
  setBH_func     = soft_a2cpu_setBH;
  setBL_func     = soft_a2cpu_setBL;
  setCX_func     = soft_a2cpu_setCX;
  setCH_func     = soft_a2cpu_setCH;
  setCL_func     = soft_a2cpu_setCL;
  setDX_func     = soft_a2cpu_setDX;
  setDH_func     = soft_a2cpu_setDH;
  setDL_func     = soft_a2cpu_setDL;
  setSP_func     = soft_a2cpu_setSP;
  setBP_func     = soft_a2cpu_setBP;
  setSI_func     = soft_a2cpu_setSI;
  setDI_func     = soft_a2cpu_setDI;
  setIP_func     = soft_a2cpu_setIP;
  setMSW_func    = soft_a2cpu_setMSW;
  setDF_func     = soft_a2cpu_setDF;
  setIF_func     = soft_a2cpu_setIF;
  setTF_func     = soft_a2cpu_setTF;
  setPF_func     = soft_a2cpu_setPF;
  setAF_func     = soft_a2cpu_setAF;
  setSF_func     = soft_a2cpu_setSF;
  setZF_func     = soft_a2cpu_setZF;
  setOF_func     = soft_a2cpu_setOF;
  setCF_func     = soft_a2cpu_setCF;
  setOPLEN_func  = soft_a2cpu_setOPLEN;   /* not used in CCPU */
  setOPA_func    = soft_a2cpu_setOPA;     /* not used in CCPU */
  setOPB_func    = soft_a2cpu_setOPB;     /* not used in CCPU */
  setOPR_func    = soft_a2cpu_setOPR;     /* not used in CCPU */
  setSS_func	 = soft_a2cpu_setSS;
  setDS_func     = soft_a2cpu_setDS;
  setES_func     = soft_a2cpu_setES;
  setCS_func     = soft_a2cpu_setCS;

  /* SW HOST_SIMULATE function */
  host_simulate_func = sw_host_simulate;
}
#endif A2CPU


#endif /* CPU_30_STYLE */










#ifdef SUN_VA
/*
 *     ---- SUN_VA   HARDWARE   SUPPORT ----
 *  needed regardless which softCPU is being used.
 *     ----                             ----
 */

 
extern union SDOS_XTSS *sdos_xtss_ptr;

/*
 *  The XTSS fields are stored in i486 format. SWAP the fields
 *  when accessed from Host-side before writes and after reads.
 */

#define FLAGS_CF   0x00000001
#define FLAGS_PF   0x00000004
#define FLAGS_AF   0x00000010
#define FLAGS_ZF   0x00000040
#define FLAGS_SF   0x00000080
#define FLAGS_TF   0x00000100
#define FLAGS_IF   0x00000200
#define FLAGS_DF   0x00000400
#define FLAGS_OF   0x00000800
#define FLAGS_IOPL 0x00003000
#define FLAGS_NT   0x00004000
#define FLAGS_RF   0x00010000
#define FLAGS_VM   0x00020000


static word       word_reg;
static half_word hword_reg;

word hard_cpu_getAX ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.ax), &word_reg);
   return (word_reg);
}

half_word hard_cpu_getAH ()
{
   sas_load       (&(sdos_xtss_ptr->h.ah), &hword_reg);
   return (hword_reg);
}

half_word hard_cpu_getAL ()
{
   sas_load       (&(sdos_xtss_ptr->h.al), &hword_reg);
   return (hword_reg);
}

word hard_cpu_getBX ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.bx), &word_reg);
   return (word_reg);
}

half_word hard_cpu_getBH ()
{
   sas_load       (&(sdos_xtss_ptr->h.bh), &hword_reg);
   return (hword_reg);
}

half_word hard_cpu_getBL ()
{
   sas_load       (&(sdos_xtss_ptr->h.bl), &hword_reg);
   return (hword_reg);
}

word hard_cpu_getCX ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.cx), &word_reg);
   return (word_reg);
}

half_word hard_cpu_getCH ()
{
   sas_load       (&(sdos_xtss_ptr->h.ch), &hword_reg);
   return (hword_reg);
}

half_word hard_cpu_getCL ()
{
   sas_load       (&(sdos_xtss_ptr->h.cl), &hword_reg);
   return (hword_reg);
}

word hard_cpu_getDX ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.dx), &word_reg);
   return (word_reg);
}

half_word hard_cpu_getDH ()
{
   sas_load       (&(sdos_xtss_ptr->h.dh), &hword_reg);
   return (hword_reg);
}

half_word hard_cpu_getDL ()
{
   sas_load       (&(sdos_xtss_ptr->h.dl), &hword_reg);
   return (hword_reg);
}

word hard_cpu_getSP ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.sp), &word_reg);
   return (word_reg);
}

word hard_cpu_getBP ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.bp), &word_reg);
   return (word_reg);
}

word hard_cpu_getSI ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.si), &word_reg);
   return (word_reg);
}

word hard_cpu_getDI ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.di), &word_reg);
   return (word_reg);
}

word hard_cpu_getIP ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.ip), &word_reg);
   return (word_reg);
}

word hard_cpu_getCS ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.cs), &word_reg);
   return (word_reg);
}

word hard_cpu_getDS ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.ds), &word_reg);
   return (word_reg);
}

word hard_cpu_getES ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.es), &word_reg);
   return (word_reg);
}

word hard_cpu_getSS ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.ss), &word_reg);
   return (word_reg);
}

word hard_cpu_getMSW ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   return (word_reg);
}

word hard_cpu_getDF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_DF)
     return (1);
   else
     return (0);
}

word hard_cpu_getIF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_IF)
     return (1);
   else
     return (0);
}

word hard_cpu_getTF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_TF)
     return (1);
   else
     return (0);
}

word hard_cpu_getPF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_PF)
     return (1);
   else
     return (0);
}

word hard_cpu_getAF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_AF)
     return (1);
   else
     return (0);
}

word hard_cpu_getSF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_SF)
     return (1);
   else
     return (0);
}

word hard_cpu_getZF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_ZF)
     return (1);
   else
     return (0);
}

word hard_cpu_getOF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_OF)
     return (1);
   else
     return (0);
}

word hard_cpu_getCF ()
{
   sas_loadw_swap (&(sdos_xtss_ptr->x.flags), &word_reg);
   if (word_reg & FLAGS_CF)
     return (1);
   else
     return (0);
}


 
  
void hard_cpu_setAX (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.ax), val);
}

void hard_cpu_setAH (val)
unsigned int val;
{
  sas_store		(&(sdos_xtss_ptr->h.ah), val);
}

void hard_cpu_setAL (val)
unsigned int val;
{
  sas_store		(&(sdos_xtss_ptr->h.al), val);
}

void hard_cpu_setBX (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.bx), val);
}

void hard_cpu_setBH (val)
unsigned int val;
{
  sas_store		(&(sdos_xtss_ptr->h.bh), val);
}

void hard_cpu_setBL (val)
unsigned int val;
{
  sas_store		(&(sdos_xtss_ptr->h.bl), val);
}

void hard_cpu_setCX (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.cx), val);
}

void hard_cpu_setCH (val)
unsigned int val;
{
  sas_store		(&(sdos_xtss_ptr->h.ch), val);
}

void hard_cpu_setCL (val)
unsigned int val;
{
  sas_store		(&(sdos_xtss_ptr->h.cl), val);
}

void hard_cpu_setDX (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.dx), val);
}

void hard_cpu_setDH (val)
unsigned int val;
{
  sas_store		(&(sdos_xtss_ptr->h.dh), val);
}

void hard_cpu_setDL (val)
unsigned int val;
{
  sas_store		(&(sdos_xtss_ptr->h.dl), val);
}

void hard_cpu_setSP (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.sp), val);
}

void hard_cpu_setBP (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.bp), val);
}

void hard_cpu_setSI (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.si), val);
}

void hard_cpu_setDI (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.di), val);
}

void hard_cpu_setIP (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.ip), val);
}

void hard_cpu_setCS (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.cs), val);
}

void hard_cpu_setDS (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.ds), val);
}

void hard_cpu_setES (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.es), val);
}

void hard_cpu_setSS (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.ss), val);
}

void hard_cpu_setMSW (val)
unsigned int val;
{
  sas_storew_swap	(&(sdos_xtss_ptr->x.flags), val);
}

void hard_cpu_setDF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_DF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_DF)));
}

void hard_cpu_setIF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_IF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_IF)));
}

void hard_cpu_setTF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_TF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_TF)));
}

void hard_cpu_setPF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_PF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_PF)));
}

void hard_cpu_setAF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_AF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_AF)));
}

void hard_cpu_setSF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_SF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_SF)));
}

void hard_cpu_setZF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_ZF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_ZF)));
}

void hard_cpu_setOF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_OF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_OF)));
}

void hard_cpu_setCF (val)
unsigned int val;
{
unsigned short temp;

  sas_loadw_swap	(&(sdos_xtss_ptr->x.flags), &temp);
  if (val)
    sas_storew_swap	(&(sdos_xtss_ptr->x.flags), (temp | FLAGS_CF));
  else
    sas_storew_swap     (&(sdos_xtss_ptr->x.flags), (temp & (~FLAGS_CF)));
}



/*  these routines load the CPU access functions pointers for HW and SW. */
void load_hw_cpu_access_functions ()
{
  /* READ functions */
  getAX_func     = hard_cpu_getAX;
  getAH_func     = hard_cpu_getAH;
  getAL_func     = hard_cpu_getAL;
  getBX_func     = hard_cpu_getBX;
  getBH_func     = hard_cpu_getBH;
  getBL_func     = hard_cpu_getBL;
  getCX_func     = hard_cpu_getCX;
  getCH_func     = hard_cpu_getCH;
  getCL_func     = hard_cpu_getCL;
  getDX_func     = hard_cpu_getDX;
  getDH_func     = hard_cpu_getDH;
  getDL_func     = hard_cpu_getDL;
  getSP_func     = hard_cpu_getSP;
  getBP_func     = hard_cpu_getBP;
  getSI_func     = hard_cpu_getSI;
  getDI_func     = hard_cpu_getDI;
  getIP_func     = hard_cpu_getIP;
  getCS_func     = hard_cpu_getCS;
  getDS_func     = hard_cpu_getDS;
  getES_func     = hard_cpu_getES;
  getSS_func     = hard_cpu_getSS;
  getMSW_func    = hard_cpu_getMSW;
  getDF_func     = hard_cpu_getDF;
  getIF_func     = hard_cpu_getIF;
  getTF_func     = hard_cpu_getTF;
  getPF_func     = hard_cpu_getPF;
  getAF_func     = hard_cpu_getAF;
  getSF_func     = hard_cpu_getSF;
  getZF_func     = hard_cpu_getZF;
  getOF_func     = hard_cpu_getOF;
  getCF_func     = hard_cpu_getCF;
  
  /* WRITE functions */  
  setAX_func     = hard_cpu_setAX;
  setAH_func     = hard_cpu_setAH;
  setAL_func     = hard_cpu_setAL;
  setBX_func     = hard_cpu_setBX;
  setBH_func     = hard_cpu_setBH;
  setBL_func     = hard_cpu_setBL;
  setCX_func     = hard_cpu_setCX;
  setCH_func     = hard_cpu_setCH;
  setCL_func     = hard_cpu_setCL;
  setDX_func     = hard_cpu_setDX;
  setDH_func     = hard_cpu_setDH;
  setDL_func     = hard_cpu_setDL;
  setSP_func     = hard_cpu_setSP;
  setBP_func     = hard_cpu_setBP;
  setSI_func     = hard_cpu_setSI;
  setDI_func     = hard_cpu_setDI;
  setIP_func     = hard_cpu_setIP;
  setCS_func	 = hard_cpu_setCS;
  setDS_func     = hard_cpu_setDS;
  setES_func     = hard_cpu_setES;
  setSS_func     = hard_cpu_setSS;
  setMSW_func    = hard_cpu_setMSW;
  setDF_func     = hard_cpu_setDF;
  setIF_func     = hard_cpu_setIF;
  setTF_func     = hard_cpu_setTF;
  setPF_func     = hard_cpu_setPF;
  setAF_func     = hard_cpu_setAF;
  setSF_func     = hard_cpu_setSF;
  setZF_func     = hard_cpu_setZF;
  setOF_func     = hard_cpu_setOF;
  setCF_func     = hard_cpu_setCF;

  /*  HW HOST_SIMULATE function */
  host_simulate_func = hw_host_simulate;
}

#endif SUN_VA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_det.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include "host_def.h"
#include "insignia.h"

/*
 * ==========================================================================
 *      Name:           nt_det.c
 *      Author:         Jerry Sexton
 *      Derived From:
 *      Created On:     6th August 1992
 *      Purpose:        This module contains the code for the thread which
 *                      detects transitions between windowed and full-screen.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 * ==========================================================================
 *
 * Modifications:
 *
 * Tim August 92. Full-screen and windowed transitions now switch between
 *     SoftPC video BIOS and host PC video BIOS.
 *
 */

/*
 * ==========================================================================
 * Other includes
 * ==========================================================================
 */
#include <stdlib.h>
#include <ntddvdeo.h>
#include "xt.h"
#include CpuH
#include "gmi.h"
#include "gvi.h"
#include "ios.h"
#include "sas.h"
#include "gfx_upd.h"
#include "egacpu.h"
#include "egaports.h"
#include "egamode.h"
#include "egagraph.h"
#include "video.h"
#include "conapi.h"
#include "host_rrr.h"
#include "debug.h"
#include "error.h"
#include "config.h"
#include "idetect.h"
#include "nt_uis.h"
#include "nt_fulsc.h"
#include "nt_graph.h"
#include "nt_mouse.h"
#include "nt_thred.h"
#include "nt_reset.h"
#include "nt_eoi.h"
#include "nt_event.h"

/*
 * ==========================================================================
 * Macros
 * ==========================================================================
 */
#define SUSP_FAILURE            0xffffffff


//
// A bunch of imports
//
extern DISPLAY_MODE choose_mode[];
#ifdef JAPAN
extern BOOL VDMForWOW;         // 32bit IME disable and enable for RAID #1085
#endif // JAPAN



/*
 * ==========================================================================
 * Global data
 * ==========================================================================
 */

/* Size of video save block. */
GLOBAL DWORD stateLength;

/* Video save block pointer. */
GLOBAL PVIDEO_HARDWARE_STATE_HEADER videoState;
GLOBAL PVOID textState; // Tim Oct 92.

/* Name of the shared video block. */
GLOBAL WCHAR_STRING videoSection;
GLOBAL WCHAR_STRING textSection; // Tim Oct 92

GLOBAL BOOLEAN HandshakeInProgress = FALSE;
#ifdef X86GFX
/* Hand-shaking events. */
GLOBAL HANDLE hStartHardwareEvent;
GLOBAL HANDLE hEndHardwareEvent;
GLOBAL HANDLE hErrorHardwareEvent;
extern PVOID CurrentMonitorTeb;
extern HANDLE ThreadLookUp(PVOID Teb);
extern BOOLEAN MainThreadInMonitor;
#define HANDSHAKE_TIMEOUT 600000
#endif

/*
** Tim Oct 92.
** New strategy for windowed graphics updates. A shared buffer with Console
** will remove need to copy the new data over, just pass a rectangle co-ord
** instead. But we still need to copy into the buffer.
*/
GLOBAL PBYTE *textBuffer;
GLOBAL COORD  textBufferSize;      // Dimensions of the shared buffer

GLOBAL BOOL Frozen256Packed = FALSE;  // use packed 256 mode paint routine




/*
 * ==========================================================================
 * Local data
 * ==========================================================================
 */

/* Variable that indicates if we are in a non-standard VGA mode. */
LOCAL BOOL inAFunnyMode = FALSE;
LOCAL BOOL ModeSetBatch = FALSE;

/* Storage for the frozen-window thread handle. */
LOCAL HANDLE freezeHandle = (HANDLE)0;

/*
 * ==========================================================================
 * Local function declarations
 * ==========================================================================
 */

#undef LOCAL
#define LOCAL

LOCAL VOID getCursorInfo(word *, half_word *, half_word *, half_word *);
LOCAL VOID setCursorInfo(word, half_word, half_word, half_word);
LOCAL VOID windowedToFullScreen(SHORT, BOOL);
LOCAL VOID fullScreenToWindowed(VOID);
LOCAL VOID syncHardwareToVGAEmulation(SHORT);
LOCAL VOID syncVGAEmulationToHardware(VOID);
LOCAL BOOL funnyMode(VOID);
LOCAL VOID freezeWindow(VOID);
#ifndef PROD
LOCAL VOID dumpBlock(VOID);
LOCAL VOID dumpPlanes(UTINY *, UTINY *, UTINY *, UTINY *);
#endif /* PROD */

#define ScreenSwitchExit()  {       \
        SetEvent(hErrorHardwareEvent);   \
        if (sc.Registered == FALSE)      \
        {                                \
            HandshakeInProgress = FALSE; \
            ResetEvent(hSuspend);        \
            SetEvent(hResume);           \
        } else {                         \
            ErrorExit();                 \
        }                                \
}

/*
 * ==========================================================================
 * Global functions
 * ==========================================================================
 */

/*
** Tim Oct 92
** Centralised Console funx.
*/

GLOBAL VOID doNullRegister()
{
    DWORD dummylen;
    PVOID dummyptr;
    COORD dummycoord = {0};

#ifdef X86GFX
    //
    // Indicate that ntvdm is not registered to console before actually unregistering
    // ourselves.  The RegisterConsoleVDM() call may get blocked if Handshake is in progress.
    //
    sc.Registered = FALSE;
    SetEvent(hErrorHardwareEvent);  // break handshake
#endif
    if (!RegisterConsoleVDM( CONSOLE_UNREGISTER_VDM,
                             NULL,
                             NULL,
                             NULL,
                             0,
                             &dummylen,
                             &dummyptr,
                             NULL,
                             0,
                             dummycoord,
                             &dummyptr
                           )
       )
        ErrorExit();
}

/*
*******************************************************************
** initTextSection()
*******************************************************************
*/
GLOBAL VOID initTextSection(VOID)
{
    DWORD flags;

    //
    // VideoSection size is determined by nt video driver
    // TextSectionSize is 80 * 50 * BytesPerCharacter
    //     on risc BytesPerCharacter is 4 (interleaved vga planes)
    //     on x86  BytesPerCharacter is 2 (only char\attr)
    //
    textBufferSize.X = 80;
    textBufferSize.Y = 50;

#ifdef X86GFX
    /*
     * Deallocate the regen area if we start up fullscreen. We have to do this
     * before we call RegisterConsoleVDM. Note that's right before the register
     * call to make sure no one tries to allocate any memory (eg create a
     * section) that could nick bits of the video hole, causing bye-byes.
     */
    if (!GetConsoleDisplayMode(&flags))
        ErrorExit();
    savedScreenState = sc.ScreenState = (flags & CONSOLE_FULLSCREEN_HARDWARE) ?
                       FULLSCREEN : WINDOWED;

    //
    // If ntio is initialized, reflect the ScreenState to ntio.  Otherwise,
    // this will be done after ntio notifies us via BOP 0F.
    // Note, if stream_io is enabled the consoleInit/InitTextSection will not be invoked.
    // Only when stream_io is disabled this code will be invoked.  For some case, it may be
    // happen as early as before ntio is loaded and run.
    //

    if (int10_seg != 0 || useHostInt10 != 0) {
        sas_store_no_check((int10_seg << 4) + useHostInt10, (half_word)sc.ScreenState);
    }

    if (sc.ScreenState == FULLSCREEN)
        LoseRegenMemory();

#else
    sc.ScreenState = WINDOWED;
#endif

    ResetEvent(hErrorHardwareEvent);
    if (!RegisterConsoleVDM( VDMForWOW ?
                             CONSOLE_REGISTER_WOW : CONSOLE_REGISTER_VDM,
#ifdef X86GFX
                             hStartHardwareEvent,
                             hEndHardwareEvent,
                             hErrorHardwareEvent,
#else
                             NULL,
                             NULL,
                             NULL,
#endif
                             0,
                             &stateLength,
                             (PVOID *) &videoState,
                             NULL,            // sectionname no longer used
                             0,               // sectionnamelen no longer used
                             textBufferSize,
                             (PVOID *) &textBuffer
                           )
       )
        ErrorExit();

#ifdef X86GFX
    /* stateLength can be 0 if fullscreen is disabled in the console */
    if (stateLength)
        RtlZeroMemory((BYTE *)videoState, sizeof(VIDEO_HARDWARE_STATE_HEADER));
    sc.Registered = TRUE;
#endif

} /* end initTextSection() */

#ifdef X86GFX

/***************************************************************************
 * Function:                                                               *
 *      InitDetect                                                         *
 *                                                                         *
 * Description:                                                            *
 *      Does detection initialisation.                                     *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID InitDetect(VOID)
{

    /*
     * Register start and end events with the console. These events are used
     * when gaining or losing control of the hardware.
     */
    hStartHardwareEvent = CreateEvent((LPSECURITY_ATTRIBUTES) NULL,
                                      FALSE,
                                      FALSE,
                                      NULL);
    hEndHardwareEvent = CreateEvent((LPSECURITY_ATTRIBUTES) NULL,
                                    FALSE,
                                    FALSE,
                                    NULL);
    hErrorHardwareEvent = CreateEvent((LPSECURITY_ATTRIBUTES) NULL,
                                      FALSE,
                                      FALSE,
                                      NULL);
    if ((hStartHardwareEvent == NULL) || (hEndHardwareEvent == NULL) ||
        (hErrorHardwareEvent == NULL))
        ErrorExit();

    /* Poll the event to try and get rid of any console queued sets
     * This shouldn't be needed (or shouldn't work) but something along
     * those lines seems to be happening at the moment.
     */
    WaitForSingleObject(hStartHardwareEvent, 0);


    #ifdef SEPARATE_DETECT_THREAD
    /* Go into hand-shaking loop. */
    while (WaitForSingleObject(hStartHardwareEvent, (DWORD) -1) == 0)
        DoHandShake();

    /* We have exited the loop so something funny must have happened. */
    ErrorExit();
    #endif

}
    #ifdef SEPARATE_DETECT_THREAD

/***************************************************************************
 * Function:                                                               *
 *      CreateDetectThread                                                 *
 *                                                                         *
 * Description:                                                            *
 *      Creates the detection thread.                                      *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID CreateDetectThread(VOID)
{
    DWORD        detectID;
    HANDLE       detectHandle;


    /*
     *  If this codes is activated you must close the thread handle
     *  28-Feb-1993 Jonle
     */


    /* Create the detection thread. */
    detectHandle = CreateThread((LPSECURITY_ATTRIBUTES) NULL,
                                DETECT_THREAD_SIZE,
                                (LPTHREAD_START_ROUTINE) InitDetect,
                                (LPVOID) NULL,
                                (DWORD) 0,
                                &detectID);
    if (detectHandle == NULL)
        ErrorExit();
}
    #endif /* SEPARATE_DETECT_THREAD */

/***************************************************************************
 * Function:                                                               *
 *      DoHandShake                                                        *
 *                                                                         *
 * Description:                                                            *
 *      Does the hand-shaking with the console server.                     *
 *      If for any reason, the handshake fails.  The main thread and event *
 *      thread will be left in wait state.                                 *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID DoHandShake(VOID)
{
    DWORD retCode;
    BOOL success = FALSE, wait = TRUE, attention = TRUE;
    HANDLE events[2] = {hErrorHardwareEvent, hMainThreadSuspended};
    HANDLE   MainThread;

    ResetEvent(hResume);
    SetEvent(hSuspend);
    HandshakeInProgress = TRUE;

    //
    // First check application thread and console timeout event
    //

    //
    // First we need to release time slice to give main thread a
    // chance to run to predefined location.  And then we can check
    // MainThreadInMonitor and decide if kernel APC needs to be fired.
    //

    retCode = WaitForSingleObject(hMainThreadSuspended, 5000);
    if (retCode == WAIT_TIMEOUT)
    {
        _asm
        {
            mov     eax, FIXED_NTVDMSTATE_LINEAR
            lock or dword ptr [eax], VDM_HANDSHAKE;
        }
        MainThread = ThreadLookUp(CurrentMonitorTeb);
        if (MainThread)
        {
            NtVdmControl(VdmQueueInterrupt, (PVOID)MainThread);
            // nothing much we can do if this fails
        }
        retCode = WaitForMultipleObjects(2, events, FALSE, HANDSHAKE_TIMEOUT);
        if (retCode != 1)
        {
            SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
            goto exitHandShake;
        }
    }

    //
    // Make sure the console is still registered
    // Synchronize access to the console with nt_block_event_thread
    //
    if (sc.Registered == FALSE)
    {
        HandshakeInProgress = FALSE;
        SetEvent(hErrorHardwareEvent);  // Unlock console
        ResetEvent(hSuspend);
        SetEvent(hResume);
        return;
    }

    events[1] = hConsoleSuspended;
    retCode = WaitForMultipleObjects(2, events, FALSE, HANDSHAKE_TIMEOUT);
    if (retCode != 1) {
        SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
        goto exitHandShake;
    }

    events[1] = hStartHardwareEvent;
    if (!SetEvent(hEndHardwareEvent) ||
        WaitForMultipleObjects(2, events, FALSE, HANDSHAKE_TIMEOUT) != 1)  // tell console memory's gone
    {
        SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
        goto exitHandShake;
    }

    try
    {

        /*
         * We have the event telling us to switch so if we are windowed go
         * full-screen or if we full-screen go windowed.
         */
        if (sc.ScreenState == FULLSCREEN)
        {
            fullScreenToWindowed();
        }
        else
        {
            windowedToFullScreen(TEXT, BiosModeChange);
        }

        success = TRUE;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
    }

exitHandShake:

    if (!success)
    {
        ScreenSwitchExit();
    }
    else
    {
        //
        // Before we resume the suspended main thread, make sure console is still
        // with us.  Otherwise. the main thread will GP fault once we release it.
        //
        retCode = WaitForSingleObject(hErrorHardwareEvent, 0);
        if (retCode == 0) {

            //
            // Error event signaled
            //
            SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
            ScreenSwitchExit();
        }
        else
        {
            //
            // Now resume the main thread and event thread
            //
            HandshakeInProgress = FALSE;
            ResetEvent(hSuspend);
            SetEvent(hResume);
        }
    }
    return;
}

/*
 * ==========================================================================
 * Local functions
 * ==========================================================================
 */

/*
***************************************************************************
** getCursorInfo() - use BIOS funcs to get cursor position and other stuff
***************************************************************************
** The BIOS could be the SoftPC video BIOS or the host PC's real video BIOS.
** Cursor information needs to be communicated between the two BIOSes when
** a windowed/full-screen transition occurs.
** Tim July 92.
*/
LOCAL VOID getCursorInfo(word *type, half_word *column, half_word *row,
                         half_word *page)
{

    /* Get active page. */
    *page = sas_hw_at_no_check(vd_current_page);

    /* Get cursor position */
    *type = sas_w_at_no_check(VID_CURMOD);
    *column = sas_hw_at_no_check(current_cursor_col);
    *row = sas_hw_at_no_check(current_cursor_row);
}

/*
***************************************************************************
** setCursorInfo() - use BIOS funcs to set cursor position and other stuff
***************************************************************************
** The BIOS could be the SoftPC video BIOS or the host PC's real video BIOS.
** Cursor information needs to be communicated between the two BIOSes when
** a windowed/full-screen transition occurs.
** Tim July 92.
*/
LOCAL VOID setCursorInfo(word type, half_word column, half_word row, half_word page)
{

    /* Set active page. */
    sas_store_no_check(vd_current_page, page);

    /* Set cursor position. */
    sas_storew_no_check(VID_CURMOD, type);
    sas_store_no_check(current_cursor_col, column);
    sas_store_no_check(current_cursor_row, row);
}

/***************************************************************************
 * Function:                                                               *
 *      windowedToFullScreen                                               *
 *                                                                         *
 * Description:                                                            *
 *      Called when the user or SoftPC requests that the console goes      *
 *      fullscreen. It disables screen updates, synchronises the hardware  *
 *      to SoftPC's video planes and signals the console when it is        *
 *      finished.                                                          *
 *                                                                         *
 * Parameters:                                                             *
 *      dataType - the type of data stored in the video planes, set to     *
 *                 either TEXT or GRAPHICS.                                *
 *      biosModeChange - TRUE means call host BIOS to do mode change.      *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
LOCAL VOID windowedToFullScreen(SHORT dataType, BOOL biosModeChange)
{
    word cursorType;
    half_word cursorCol, cursorRow, activePage;

    /* Disable the Idling system when Fullscreen as we cannot detect video
     * updates and thus would always idle.
     */
    IDLE_ctl(FALSE);

    /* Pass the current state of our VGA emulation to the hardware. */
    syncHardwareToVGAEmulation(dataType);

    /*
    ** A variable in K.SYS decides whether
    ** to call the host INT 10, or do a video BOP.
    ** Set the variable directly and subsequent INT 10's go to host
    ** video BIOS.
    */
    sas_store_no_check((int10_seg << 4) + useHostInt10, FULLSCREEN);

    /*
    ** Tim August 92. Transfer to host video BIOS.
    */
    getCursorInfo(&cursorType, &cursorCol, &cursorRow, &activePage);

    setCursorInfo(cursorType, cursorCol, cursorRow, activePage);

    /*
     * We only want to call the host bios to do a mode change if the current
     * screen switch is due to a bios mode change.
     */
    if (biosModeChange)
    {
        always_trace1("Host BIOS mode change to mode %x.",
                      sas_hw_at_no_check(vd_video_mode));

        /*
        ** Tim August 92. Transfer to host video BIOS.
        */
        getCursorInfo(&cursorType, &cursorCol, &cursorRow, &activePage);

        setCursorInfo(cursorType, cursorCol, cursorRow, activePage);
    }
}

/***************************************************************************
 * Function:                                                               *
 *      syncHardwareToVGAEmulation                                         *
 *                                                                         *
 * Description:                                                            *
 *      Copies the contents of SoftPC's video registers and regen buffer   *
 *      to the real hardware on a transition to full-screen.               *
 *                                                                         *
 * Parameters:                                                             *
 *      dataType - the type of data stored in the video planes, set to     *
 *                 either TEXT or GRAPHICS.                                *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
LOCAL VOID syncHardwareToVGAEmulation(SHORT dataType)
{
    ULONG    memLoc;
    UTINY   *regPtr,
    *egaPlanePtr,
    *regenptr,
    *fontptr,
    *plane1Ptr,
    *plane2Ptr,
    *plane3Ptr,
    *plane4Ptr;
    half_word dummy,
    acModeControl,
    acIndex,
    index,
    value,
    rgb;
    USHORT   dacIndex;
    BOOL     monoMode;
    VIDEO_HARDWARE_STATE stateChange;
    DWORD bitmapLen = sizeof(VIDEO_HARDWARE_STATE);
    DWORD timo;
    #ifdef KOREA
    UTINY   BasicGraphContValue[NUM_GC_REGS] = {0x00,0x00,0x00,0x00,0x00,0x10,0x0e,0x00,0xff};
    #endif
    HANDLE ScreenSwitchEvents[2] = {hStartHardwareEvent, hErrorHardwareEvent};

    /* If we timed out during switch (stress!!), the videoState buffer will
     * be removed by console. Check for this before accessing structure and
     * take error path down to rest of handshake which will time out and report
     * error cleanly.
     */
    try
    {
        videoState->ExtendedSequencerOffset = 0;
    }except(EXCEPTION_EXECUTE_HANDLER)
    {
        assert0(NO, "NTVDM:VideoState has valid pointer, but no memory at that address");
        goto syncHandshake;
    }
    /*
    ** If it's a text mode
    ** zero the extended fields in the shared saved/restore structure.
    ** Kipper, Tim Nov 92.
    */

    /* initialize the video state header if we haven't done it yet.
       if it is initialized, leave it alone.
    */
    if (videoState->Length == 0)
    {
        videoState->Length = STATELENGTH;
        videoState->BasicSequencerOffset = BASICSEQUENCEROFFSET;
        videoState->BasicCrtContOffset = BASICCRTCONTOFFSET;
        videoState->BasicGraphContOffset = BASICGRAPHCONTOFFSET;
        videoState->BasicAttribContOffset = BASICATTRIBCONTOFFSET;
        videoState->BasicDacOffset = BASICDACOFFSET;
        videoState->BasicLatchesOffset = BASICLATCHESOFFSET;
        videoState->PlaneLength = PLANELENGTH;
        videoState->Plane1Offset = PLANE1OFFSET;
        videoState->Plane2Offset = PLANE2OFFSET;
        videoState->Plane3Offset = PLANE3OFFSET;
        videoState->Plane4Offset = PLANE4OFFSET;
    }
    /* Save the current state of the attribute controller index register. */
    inb(EGA_AC_INDEX_DATA, &acIndex);

    /* Enable palette */
    acIndex |= 0x20;

    /*
     * Find out if we are running in mono mode as CRTC registers are different
     * if we are.
     */
    inb(EGA_IPSTAT1_REG, &dummy);
    outb(EGA_AC_INDEX_DATA, AC_MODE_CONTROL_REG);
    inb(EGA_AC_SECRET, &acModeControl);
    monoMode = acModeControl & DISPLAY_TYPE;

    /* Restore the state of the attribute controller index register. */
    inb(EGA_IPSTAT1_REG, &dummy);
    outb(EGA_AC_INDEX_DATA, acIndex);

    /*
     * Store values to be written to each of the real registers to synchronise
     * them to the current state of the registers in the VDD.
     */
    if (monoMode)
    {
        /* Port 0x3b4 */
        inb(0x3b4, (half_word *)&videoState->PortValue[0x4]);
        /* Port 0x3b5 */
        inb(0x3b5, (half_word *)&videoState->PortValue[0x5]);
    }

    /* Port 0x3c0 */
    videoState->PortValue[0x10] = acIndex;

    /* Port 0x3c1 */
    inb(EGA_AC_SECRET, (half_word *)&videoState->PortValue[0x11]);

    /* Port 0x3c2 */
    inb(VGA_MISC_READ_REG, (half_word *)&videoState->PortValue[0x12]);

    videoState->PortValue[0x13] = 0xff; /* Testing */

    /* Port 0x3c4 */
    inb(EGA_SEQ_INDEX, (half_word *)&videoState->PortValue[0x14]);

    /* Port 0x3c5 */
    inb(EGA_SEQ_DATA, (half_word *)&videoState->PortValue[0x15]);

    /* Port 0x3c6 */
    inb(VGA_DAC_MASK, (half_word *)&videoState->PortValue[0x16]);

    /* Port 0x3c7 */
    videoState->PortValue[0x17] = get_vga_DAC_rd_addr();

    /* Port 0x3c8 */
    inb(VGA_DAC_WADDR, (half_word *)&videoState->PortValue[0x18]);

    /* Port 0x3c9 */
    inb(VGA_DAC_DATA, (half_word *)&videoState->PortValue[0x19]);

    /* Port 0x3ce */
    inb(EGA_GC_INDEX, (half_word *)&videoState->PortValue[0x1e]);

    /* Port 0x3cf */
    inb(EGA_GC_DATA, (half_word *)&videoState->PortValue[0x1f]);

    if (!monoMode)
    {
        /* Port 0x3d4 */
        inb(EGA_CRTC_INDEX, (half_word *)&videoState->PortValue[0x24]);
        /* Port 0x3d5 */
        inb(EGA_CRTC_DATA, (half_word *)&videoState->PortValue[0x25]);
    }

    /* Port 0x3da */
    inb(VGA_FEAT_READ_REG, (half_word *)&videoState->PortValue[0x2a]);

    /* Store INDEX/DATA etc. register pairs. */

    /* Initialise `regPtr'. */
    regPtr =  GET_OFFSET(BasicSequencerOffset);

    /* Sequencer registers. */
    for (index = 0; index < NUM_SEQ_REGS; index++)
    {
        outb(EGA_SEQ_INDEX, index);
        inb(EGA_SEQ_DATA, &value);
        *regPtr++ = value;
    }

    /* CRTC registers. */
    regPtr = GET_OFFSET(BasicCrtContOffset);
    for (index = 0; index < NUM_CRTC_REGS; index++)
    {
        outb(EGA_CRTC_INDEX, index);
        inb(EGA_CRTC_DATA, &value);
        *regPtr++ = value;
    }

    /* Graphics controller registers. */
    regPtr = GET_OFFSET(BasicGraphContOffset);
    #ifdef KOREA
    if (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x03)
    {
        for (index = 0; index < NUM_GC_REGS; index++)
        {
            *regPtr++ = BasicGraphContValue[index];
        }
    }
    else
    #endif
        for (index = 0; index < NUM_GC_REGS; index++)
        {
            outb(EGA_GC_INDEX, index);
            inb(EGA_GC_DATA, &value);
            *regPtr++ = value;
        }

    /* Attribute controller registers. */
    regPtr = GET_OFFSET(BasicAttribContOffset);
    for (index = 0; index < NUM_AC_REGS; index++)
    {
        inb(EGA_IPSTAT1_REG, &dummy);   /* Reading 3DA sets 3C0 to index. */
        outb(EGA_AC_INDEX_DATA, index); /* Writing to 3C0 sets it to data. */
        inb(EGA_AC_SECRET, &value);
        *regPtr++ = value;
    }
    inb(EGA_IPSTAT1_REG, &dummy);       // re-enable video...
    outb(EGA_AC_INDEX_DATA, 0x20);

    /* DAC registers. */
    regPtr = GET_OFFSET(BasicDacOffset);
    outb(VGA_DAC_RADDR, (UTINY) 0);
    for (dacIndex = 0; dacIndex < NUM_DAC_REGS; dacIndex++)
    {

        /* Get 3 values for each port corresponding to red, green and blue. */
        for (rgb = 0; rgb < 3; rgb++)
        {
            inb(VGA_DAC_DATA, &value);
            *regPtr++ = value;
        }
    }

    /* Latches (which we always set to 0) */
    regPtr = GET_OFFSET(BasicLatchesOffset);
    *regPtr++ = 0;
    *regPtr++ = 0;
    *regPtr++ = 0;
    *regPtr++ = 0;

    if (!BiosModeChange)
    {
        /* if this windowed->fullscreen switch was because of video mode change
           do not change anything in the code buffer and the font because
           the ROM bios set mode will clear them anyway. If "not clear VRAM"
           bit was set(int 10h, ah = mode | 0x80), the application will take care
           the VRAM refreshing and restoring because if it doesn't the screen
           would look funnny as we just swtch mode from TEXT to GRAPHICS and the
           video planar chaining conditions are changed.
        */
        /* set up pointer to regen memory where the real data lies */
        regenptr = (UTINY *)0xb8000;

        /* and one to the fonts living in the base of the regen area */
        fontptr = (UTINY *)0xa0000;

        plane1Ptr = GET_OFFSET(Plane1Offset);
        plane2Ptr = GET_OFFSET(Plane2Offset);
        plane3Ptr = GET_OFFSET(Plane3Offset);
        plane4Ptr = GET_OFFSET(Plane4Offset);


// if we go to fullscreen graphics from text window then the regen contents
// is probably junk??? except when previous save... We can detect this
// transition, so should we save time and just store blank planes???

    #ifdef JAPAN
// mode73h support
        if (!is_us_mode() &&
            ( ( sas_hw_at_no_check(DosvModePtr) == 0x03 ) ||
              ( sas_hw_at_no_check(DosvModePtr) == 0x73 ) ))
        {

            regenptr = (UTINY *)DosvVramPtr; // for test
            for (memLoc = 0; memLoc < (0xc0000 - 0xb8000); memLoc++)
            {
                *plane1Ptr++ = 0x20;
                *plane1Ptr++ = 0;           //char interleave
                *plane2Ptr++ = 0x00;
                *plane2Ptr++ = 0;           //attr interleave
            }
            for (memLoc = 0; memLoc < 0x4000; memLoc++)
            {
                *plane3Ptr++ = *fontptr++;
                *plane3Ptr++ = *fontptr++;
                *plane3Ptr++ = *fontptr++;
                *plane3Ptr++ = *fontptr++;
            }
        }
        else
    #endif // JAPAN
            if (dataType == TEXT)
        {
            // Surprise of the week - the individual planes 0 & 1 actually appear
            // to be interleaved with 0's when dumped. Go with this for now, until
            // we can suss if that's correct or whether we're not programming up
            // the save and restore states properly.
            // Probably good on further thoughts as fontplane doesn't show same
            // interleave.
            //
            for (memLoc = 0; memLoc < (0xc0000 - 0xb8000); memLoc++)
            {
                *plane1Ptr++ = *regenptr++;
                *plane1Ptr++ = 0;           //char interleave
                *plane2Ptr++ = *regenptr++;
                *plane2Ptr++ = 0;           //attr interleave
            }
            for (memLoc = 0; memLoc < 0x4000; memLoc++)
            {
                *plane3Ptr++ = *fontptr++;
                *plane3Ptr++ = *fontptr++;
                *plane3Ptr++ = *fontptr++;
                *plane3Ptr++ = *fontptr++;
            }
        }
        else
        {    //only true if restoring previous fullscreen graphics save
            /*
             * Get a copy of the video planes which are inter-leaved in one big
             * plane - byte 0 = plane 0, byte 1 = plane 1, byte 2 = plane 2,
             * byte 3 = plane 3, byte 4 = plane 0, etc.
             */
            /* Set up a pointer to the video planes. */
            egaPlanePtr = EGA_planes;

            for (memLoc = 0; memLoc < videoState->PlaneLength; memLoc++)
            {
                *plane1Ptr++ = *egaPlanePtr++;
                *plane2Ptr++ = *egaPlanePtr++;
                *plane3Ptr++ = *egaPlanePtr++;
                *plane4Ptr++ = *egaPlanePtr++;
            }
        }
    }

    /* Now pass the data on to the hardware via the console. */
    stateChange.StateHeader = videoState;
    stateChange.StateLength = videoState->Plane4Offset +
                              videoState->PlaneLength;

    #ifndef PROD
    dumpBlock();
    #endif

    /* Transfer to this label only occurs if console has removed videostate */
    syncHandshake:

    // do this here to ensure no surprises if get conflict with timer stuff
    sc.ScreenState = FULLSCREEN;

    /* make room for the real video memory */
    LoseRegenMemory();

    if (!SetEvent(hEndHardwareEvent))   // tell console memory's gone
        ScreenSwitchExit();

    // wait for console to tell us we can go on. Timeout after 60s
    timo = WaitForMultipleObjects(2, ScreenSwitchEvents, FALSE, HANDSHAKE_TIMEOUT);

    if (timo != 0)
    {              // 0 is 'signalled'
    #ifndef PROD
        if (timo == WAIT_TIMEOUT)
            printf("NTVDM:Waiting for console to map frame buffer Timed Out\n");
        if (timo == 1)
            printf("NTVDM:Waiting for console to map frame buffer received error\n");
    #endif
        SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
        ScreenSwitchExit();
    }
    // tell console it can go on.
    if (!SetEvent(hEndHardwareEvent))
        ScreenSwitchExit();

}

/***************************************************************************
 * Function:                                                               *
 *      fullScreenToWindowed                                               *
 *                                                                         *
 * Description:                                                            *
 *      When hStartHardwareEvent is detected by the timer thread the user  *
 *      wants to go windowed. This function is then called to get the      *
 *      current state of the hardware and send it to the VGA emulation.    *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/

int BlockModeChange=0; /* Tim, when set stop nt_set_paint_routine() calling */
                       /* SwitchToFullScreen() */

LOCAL VOID fullScreenToWindowed(VOID)
{

    BlockModeChange = 1; /* Temp. disable TextToGraphics calls in the */
                         /* following syncVGA... cos it chucks display */
                         /* back into full-screen */

    /* Pass the current state of the hardware to our VGA emulation. */
    syncVGAEmulationToHardware();

    /*
    ** Tim August 92. Switch to SoftPC video BIOS.
    */
    BlockModeChange = 0; /* Temp. disable cos it don't work! */

    /*
    ** Set the K.SYS variable which determines whether to use the host
    ** video BIOS or do a video BOP. Writing zero means use SoftPC BIOS.
    */
    sas_store_no_check((int10_seg << 4) + useHostInt10, (half_word)sc.ScreenState);

    /* Enable the Idling system when return to Windowed */
    /* Only do the following stuff if we are really in windowed mode.
       this can happen: (fullscreen ->windowed(frozen) -> fullscreen) */
    if (sc.ScreenState != FULLSCREEN)
    {
        /*
         ** Force re-paint of windowed image.
         */
        RtlFillMemory(&video_copy[0], 0x7fff, 0xff);

        IDLE_ctl(TRUE);
        IDLE_init();        /* and reset triggers */

        /*
         * Clear the old pointer box that has been left befind from
         * fullscreen
         */

        CleanUpMousePointer();

        resetNowCur(); /* reset static vars holding cursor pos. */
    }
}       /* end of fullScreenToWindowed() */

/***************************************************************************
 * Function:                                                               *
 *      syncVGAEmulationToHardware                                         *
 *                                                                         *
 * Description:                                                            *
 *      Copies the real hardware state to SoftPC's video registers and     *
 *      regen buffer on a transition from full-screen to windowed,         *
 *      freezing if we are currently running in a graphics mode.           *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
LOCAL VOID syncVGAEmulationToHardware(VOID)
{
    ULONG    memLoc,
    StateFlags;
    UTINY   *regPtr,
    *plane1Ptr,
    *plane2Ptr,
    *plane3Ptr,
    *plane4Ptr,
    *RegenPtr,
    index,
    dummy,
    rgb;
    USHORT   dacIndex;
    DWORD bitmapLen = 0, timo;
    HANDLE ScreenSwitchEvents[2] = {hStartHardwareEvent, hErrorHardwareEvent};

    #if defined(i386) && defined(KOREA)
        #define  DOSV_VRAM_SIZE  8000  // Exactly same as HDOS virtual buffer size in base\video.c
        #define  MAX_ROW         25
        #define  MAX_COL         80

    byte SavedHDosVram[DOSV_VRAM_SIZE];

    // bklee. 07/25/96
    // If system call SetEvent(hEndHardwareEvent), real HDOS VRAM will be destroyed.
    // HDOS doesn't have virtual VRAM like Japanse DOS/V, we should save current
    // VRAM here before it is destroyed. Later, we should replace this virtual VRAM
    // to HDOS VRAM(DosvVramPtr).
    if (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x03)
    {
        sas_loads_to_transbuf((sys_addr)DosvVramPtr,
                              (host_addr)SavedHDosVram,
                              MAX_ROW*MAX_COL*2);
    }
    #endif // KOREA

    /* Tell console we've got the hardware state. */
    if (!SetEvent(hEndHardwareEvent))
        ScreenSwitchExit();

    /* Wait for console to unmap memory. */
    timo = WaitForMultipleObjects(2, ScreenSwitchEvents, FALSE, HANDSHAKE_TIMEOUT);

    if (timo != 0)
    {              /* 0 is 'signalled' */
    #ifndef PROD
        if (timo == WAIT_TIMEOUT)
            printf("NTVDM:Waiting for console to unmap frame buffer Timed Out\n");
        if (timo == 1)
            //
            // ErrorHardwareEvent - screen switch error event
            //
            printf("NTVDM:Waiting for console to unmap frame buffer received error\n");
    #endif
        SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
        ScreenSwitchExit();
    }

    /* Put some memory back into the regen area. */
    RegainRegenMemory();

    /* used to free console here - now must wait as may need to do gfx first */
    #if defined(JAPAN) || defined(KOREA)
    // mode73h support
    // if ( getOrSet == GET ) {
    {
        if ((BOPFromDispFlag) && (sas_w_at_no_check(DBCSVectorAddr) != 0 )&&
            #if defined(JAPAN)
            ( (sas_hw_at_no_check(DosvModePtr) == 0x03)||
              (sas_hw_at_no_check(DosvModePtr) == 0x73 ) ))
        {
            #elif defined(KOREA) //JAPAN
            ( (sas_hw_at_no_check(DosvModePtr) == 0x03) ))
        {
            #endif // KOREA
            // GetConsoleCP() cannot use
            UTINY *regPtr;
            int curpos, curx, cury;

            // restore cursor position and cursur type
            // from BIOS data area.
            curpos = sas_w_at_no_check(VID_CURPOS);
            curx = curpos & 0xff;
            cury = curpos >> 8;
            curpos = ( cury * sas_w_at_no_check(VID_COLS) + curx ); //0x44a


        #ifdef JAPAN_DBG
            DbgPrint( "NTVDM: doHardwareState change register\n" );
        #endif
            regPtr = GET_OFFSET(BasicSequencerOffset);
            *regPtr = 0x03;
            regPtr++; *regPtr = 0x01;
            regPtr++; *regPtr = 0x03;
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0x02;

            regPtr = GET_OFFSET(BasicCrtContOffset);
            *regPtr = 0x5f; //0x00
            regPtr++; *regPtr = 0x4f;
            regPtr++; *regPtr = 0x50;
            regPtr++; *regPtr = 0x82;
            regPtr++; *regPtr = 0x54; //55
            regPtr++; *regPtr = 0x80; //81
            regPtr++; *regPtr = 0x0b; //bf
            regPtr++; *regPtr = 0x3e; //1f
            regPtr++; *regPtr = 0x00; //0x08
            regPtr++; *regPtr = 0x12; //4f
            regPtr++;                 //CursorStart 8/24/93
        #ifdef JAPAN_DBG
            DbgPrint("0xA=%x ", *regPtr );
        #endif
            regPtr++;                 //Cursor End 8/24/93
        #ifdef JAPAN_DBG
            DbgPrint("0xB=%x\n", *regPtr );
        #endif
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = curpos >> 8;        //0x0E - Cursor Pos
        #ifdef JAPAN_DBG
            DbgPrint("0xE=%x  ", *regPtr );
        #endif
            regPtr++; *regPtr = curpos & 0xff;      //0x0F - Cursor Pos
        #ifdef JAPAN_DBG
            DbgPrint("0xF=%x\n", *regPtr );
        #endif
            regPtr++; *regPtr = 0xea; //0x10
            regPtr++; *regPtr = 0x8c;
            regPtr++; *regPtr = 0xdb;
            regPtr++; *regPtr = 0x28;
            regPtr++; *regPtr = 0x12;
            regPtr++; *regPtr = 0xe7;
            regPtr++; *regPtr = 0x04;
            regPtr++; *regPtr = 0xa3;
            regPtr++; *regPtr = 0xff; //0x18

            regPtr = GET_OFFSET(BasicGraphContOffset);
            *regPtr = 0x00; //0x00
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0x10; //0x05
            regPtr++; *regPtr = 0x0e;
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0xff;
// willliam
// no reason to reset attribute controller.
//
        #if 0

            regPtr = GET_OFFSET(BasicAttribContOffset);
            *regPtr = 0x00; //0x00
            regPtr++; *regPtr = 0x01;
            regPtr++; *regPtr = 0x02;
            regPtr++; *regPtr = 0x03;
            regPtr++; *regPtr = 0x04;
            regPtr++; *regPtr = 0x05;
            regPtr++; *regPtr = 0x14;
            regPtr++; *regPtr = 0x07;
            regPtr++; *regPtr = 0x38; //0x08
            regPtr++; *regPtr = 0x39;
            regPtr++; *regPtr = 0x3a;
            regPtr++; *regPtr = 0x3b;
            regPtr++; *regPtr = 0x3c;
            regPtr++; *regPtr = 0x3d;
            regPtr++; *regPtr = 0x3e;
            regPtr++; *regPtr = 0x3f;

            regPtr++; *regPtr = 0x00; //0x10
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0x0f;
            regPtr++; *regPtr = 0x00;
            regPtr++; *regPtr = 0x00; //0x14
        #endif // 0

            videoState->PortValue[0x3b4-0x3b0] = 0x00;
            videoState->PortValue[0x3ba-0x3b0] = 0x00;
            videoState->PortValue[0x3c2-0x3b0] = 0xe3;
            videoState->PortValue[0x3c4-0x3b0] = 0x01;
            videoState->PortValue[0x3c6-0x3b0] = 0xff;
            videoState->PortValue[0x3c7-0x3b0] = 0x00;
            videoState->PortValue[0x3c8-0x3b0] = 0x40;
            videoState->PortValue[0x3ce-0x3b0] = 0x06;
            videoState->PortValue[0x3d4-0x3b0] = 0x1b;

        }
    }
    #endif // JAPAN || KOREA

/********************* WARNING ********************************************
 *                                                                        *
 *  For international adaptation, please note that we no longer support   *
 *  graphic mode frozen window.  If an app is running under full screen   *
 *  graphic mode and alt-enter is pressed, instead of switching to frozen *
 *  windowed graphic mode we now simply minimize the window.  In another  *
 *  words, we no longer draw graphic frozen window.                       *
 *  The change may break international code.  If you are working on       *
 *  international adaptation, please double check the changes here and    *
 *  make appropriate changes here.                                        *
 *                                                                        *
 **************************************************************************/

    StateFlags = videoState->VGAStateFlags;

    ModeSetBatch = FALSE;

    /*
     * This actually indicates that the save/restore included all extended
     * registers which increases the chances of a mode not being what it
     * appears to be from the VGA registers. We need to tighten up the 'funny
     * mode' detection. (But not now - too much chance of things).
     *
     *  if (StateFlags & VIDEO_STATE_NON_STANDARD_VGA)
     *  {
     *      always_trace0("NTVDM:Non standard VGA - freeze state \n");
     *      ModeSetBatch = TRUE;
     *  }
     */

    if (StateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE)
    {
        always_trace0("NTVDM:Unemulated VGA State - freeze\n");
        ModeSetBatch = TRUE;
    }

    if (StateFlags & VIDEO_STATE_PACKED_CHAIN4_MODE)
    {
        always_trace0("NTVDM:will need packed 256 colour paint\n");
        Frozen256Packed = TRUE;
    }
    else
        Frozen256Packed = FALSE;

    //
    // More checkings to make sure we are indeed capable of displaying window.
    //

    if (!ModeSetBatch)
    {
        if (sc.ModeType == getModeType())
        {
            if (sc.ModeType == TEXT)
            {
                /* Double check not race on graphics mode change */
                if (sas_hw_at((int10_seg << 4) + changing_mode_flag) == 1)
                {
                    /* In middle of mode change - may actually be graphics any second */
                    if ((sas_hw_at(vd_video_mode) > 3) && (sas_hw_at(vd_video_mode) != 7))
                        ModeSetBatch = TRUE;
                }
            }
            else
            {
                ModeSetBatch = TRUE;
            }
        }
        else
        {
            ModeSetBatch = TRUE;
    #ifdef JAPAN // mode 0x73 does not match screen mode
            if (sas_hw_at_no_check(DosvModePtr) == 0x73) ModeSetBatch = FALSE;
    #endif // JAPAN
        }
    }

    if (ModeSetBatch)
    {
        goto minimizeWindow;
    }

    /* Store sequencer values */
    regPtr = GET_OFFSET(BasicSequencerOffset);
    for (index = 0; index < NUM_SEQ_REGS; index++)
    {
        outb(EGA_SEQ_INDEX, index);
        outb(EGA_SEQ_DATA, *regPtr++);
    }

    /* disable CRTC port locking */
    outb(EGA_CRTC_INDEX, 0x11);
    outb(EGA_CRTC_DATA, 0);

    /* Store CRTC values */
    regPtr = GET_OFFSET(BasicCrtContOffset);
    for (index = 0; index < NUM_CRTC_REGS; index++)
    {
        outb(EGA_CRTC_INDEX, index);
        outb(EGA_CRTC_DATA, *regPtr++);
    }


    /* Store graphics context values */
    regPtr = GET_OFFSET(BasicGraphContOffset);
    for (index = 0; index < NUM_GC_REGS; index++)
    {
        outb(EGA_GC_INDEX, index);
        outb(EGA_GC_DATA, *regPtr++);
    }


    /* Store attribute context values */
    regPtr = GET_OFFSET(BasicAttribContOffset);
    inb(EGA_IPSTAT1_REG, &dummy);       /* Reading 3DA sets 3C0 to index. */
    for (index = 0; index < NUM_AC_REGS; index++)
    {
        outb(EGA_AC_INDEX_DATA, index);
        outb(EGA_AC_INDEX_DATA, *regPtr++);
    }


    /* Store DAC values. */
    regPtr = GET_OFFSET(BasicDacOffset);
    outb(VGA_DAC_WADDR, (UTINY) 0);
    for (dacIndex = 0; dacIndex < NUM_DAC_REGS; dacIndex++)
    {
        for (rgb = 0; rgb < 3; rgb++)
            outb(VGA_DAC_DATA, *regPtr++);
    }


    /* Store single value registers. */
    outb( (io_addr)0x3b4, (half_word)videoState->PortValue[0x3b4 - 0x3b0]); //Mono crtc ind
    outb( (io_addr)0x3ba, (half_word)videoState->PortValue[0x3ba - 0x3b0]); //Mono Feat
    outb( (io_addr)0x3c2, (half_word)videoState->PortValue[0x3c2 - 0x3b0]); //Misc Output
    outb( (io_addr)0x3c4, (half_word)videoState->PortValue[0x3c4 - 0x3b0]); //Seq Index
    outb( (io_addr)0x3c6, (half_word)videoState->PortValue[0x3c6 - 0x3b0]); //DAC mask
    outb( (io_addr)0x3c7, (half_word)videoState->PortValue[0x3c7 - 0x3b0]); //DAC read
    outb( (io_addr)0x3c8, (half_word)videoState->PortValue[0x3c8 - 0x3b0]); //DAC write
    outb( (io_addr)0x3ce, (half_word)videoState->PortValue[0x3ce - 0x3b0]); //GC Index
    outb( (io_addr)0x3d4, (half_word)videoState->PortValue[0x3d4 - 0x3b0]); //CRTC index

    /* Set up pointers to the planes in the video save block. */
    plane1Ptr = GET_OFFSET(Plane1Offset);
    plane2Ptr = GET_OFFSET(Plane2Offset);
    plane3Ptr = GET_OFFSET(Plane3Offset);
    plane4Ptr = GET_OFFSET(Plane4Offset);

    #ifndef PROD
    dumpPlanes(plane1Ptr, plane2Ptr, plane3Ptr, plane4Ptr);
    #endif /* PROD */

    /*
     * Here is where we need to start making decisions about what mode the above
     * has put us into as it effects what we do with the plane data - into regen
     * or into ega planes.
     */

    (*choose_display_mode)();
    /* screen switching can happen when the BIOS is in the middle
       of set mode. The video driver only batches the protected registers(we
       will get VIDEO_STATE_UNEMULATED_VGA_STATE, which will set ModeSetBatch).
       When we are out of set mode batch and a screen switch happens,
       the choose_display_mode would choose a wrong mode(different what the
       the bios says) and the parameters setup in base code could be wrong
       (we calculate those parameters as it is in TEXT mode while we are in
       graphic mode.

       For example, the base code calculate the screen length as:

       screen length = offset_per_line * screen_height_resolution / font_height

       if the bios video mode is graphic mode 4(320 * 200), then
       font_height = 2
       screen_height_resolution = 200
       offset_per_line = 80
       the screen_lenght = 80 * 200 / 2 = 8000 bytes which means
       the screen has 8000 / 80 = 100 lines!!!!

       Treat it like we are in mode set batch process, so we go to iconized.
    */
    if (sc.ModeType == getModeType())
    {

        /* Write data to video planes if we are in a graphics mode. */
    #ifdef JAPAN
// Copy to B8000 from MS-DOS/V VRAM
        if (!is_us_mode() &&
            ( (sas_hw_at_no_check(DosvModePtr) == 0x03) ||
              (sas_hw_at_no_check(DosvModePtr) == 0x73) ))
        {
            help_mode73:
            SetVram();
            host_set_paint_routine( EGA_TEXT_80,
                                    get_screen_height() ); // MSKKBUG #2071

        #if 0
// It doesn't need to copy to B8000 from DosvVram

            /* Now copy the data to the regen buffer. */
            RegenPtr = (UTINY *)0xb8000;
            sas_move_words_forward( DosvVramPtr, RegenPtr, DosvVramSize/2);
        #endif // 0
        }
        else
    #elif defined(KOREA) // JAPAN
        // Copy to B8000 from Hangul MS-DOS VRAM
        if (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x03)
        {
        #if defined(i386)
            // bklee. 07/25/96
            // Restore virtual VRAM to real DOS VRAM.
            RtlCopyMemory( (void *)DosvVramPtr, SavedHDosVram, MAX_ROW*MAX_COL*2);
        #endif
            SetVram();
            host_set_paint_routine( EGA_TEXT_80,
                                    get_screen_height() ); // MSKKBUG #2071
        }
        else
    #endif // KOREA
        {
            /* If we come here, it must be TEXT mode */
            /* Now copy the data to the regen buffer. */
            RegenPtr = (UTINY *)0xb8000;
            for (memLoc = 0; memLoc < 0x4000; memLoc++)
            { /* 16k of text data. */
                *RegenPtr++ = *plane1Ptr++;             /* char */
                plane1Ptr++;                    /* skip interleave */
                *RegenPtr++ = *plane2Ptr++;             /* attr */
                plane2Ptr++;                    /* skip interleave */
            }

            /* Now the font. */
            RegenPtr = (UTINY *)0xa0000;
            for (memLoc = 0; memLoc < 0x4000; memLoc++)
            { /* Up to 64k of font data. */
                *RegenPtr++ = *plane3Ptr++;
                *RegenPtr++ = *plane3Ptr++;
                *RegenPtr++ = *plane3Ptr++;
                *RegenPtr++ = *plane3Ptr++;
            }
        }
        /* Re-enable vga attribute palette. */
        inb(EGA_IPSTAT1_REG, &dummy);   /* Reading 3DA sets 3C0 to index. */
        outb(EGA_AC_INDEX_DATA, 0x20);
    }
    else
    {
    #ifdef JAPAN // mode 0x73 does not match screen mode
        if (sas_hw_at_no_check(DosvModePtr) == 0x73)
            goto help_mode73;
    #endif // JAPAN
    #ifndef PROD
        OutputDebugString("fullscreen->windowed switching in set mode\n");
    #endif
    }

    minimizeWindow:

    /*
     * If the state returned by the hardware is one we don't recognise iconify
     * the window. If, however, the hardware returns a graphics mode, the
     * current image will be displayed. In both cases the app will be frozen
     * until the user changes back to fullscreen.
     */
    #if defined(JAPAN) || defined(KOREA)
    if (!is_us_mode() &&
        #if defined(JAPAN)
        ( (sas_hw_at_no_check(DosvModePtr) == 0x03) ||
          (sas_hw_at_no_check(DosvModePtr) == 0x73) ))
    {
        #elif defined(KOREA)  // JAPAN
        ( (sas_hw_at_no_check(DosvModePtr) == 0x03) ))
    {
        #endif // KOREA

        /* Tell console we're done. */
        if (!SetEvent(hEndHardwareEvent))
            ScreenSwitchExit();

        /* Set up screen-state variable. */
        sc.ScreenState = WINDOWED;

        // for MSKKBUG #2002
        {
            IU16 saveCX, saveAX;
            extern void ega_set_cursor_mode(void);

            saveCX = getCX();
            saveAX = getAX();
            setCH( sas_hw_at_no_check(0x461) );
            setCL( sas_hw_at_no_check(0x460) );
            setAH( 0x01 );
            ega_set_cursor_mode();
            setCX( saveCX );
            setAX( saveAX );
        }
        #ifndef PROD
        /* Dump out a view of the state block as it might be useful. */
        dumpBlock();
        #endif /* PROD */

    }
    else
    #endif // JAPAN || KOREA
        if (ModeSetBatch || (inAFunnyMode = funnyMode()) || (sc.ModeType == GRAPHICS))
    {

    #ifndef PROD
        dumpBlock();
    #endif /* PROD */

        /* Must do this before resize function. */
        sc.ScreenState = WINDOWED;

        /* Once we've done this, the VGA emulation is pushed into a graphics
         * mode. If we restart windowed, we must ensure it forces itself
         * back to a text mode for correct display & so correct screen buffer
         * is active. This will be cancelled if we return to a text window.
         */
        blocked_in_gfx_mode = TRUE;

        /*
         * freezewindow used to run in its own thread. Unfortunately, due to
         * console sync problems with video restore on XGA, this did unpleasant
         * things to the screen. Thus now this is has become a valid and *Only*
         * place in fullscreen switching where console permits us to make
         * console API calls.
         * I'm sorry, did you say 'Quack', Oh no, I see...
         */

        freezeWindow();

        /* Tell console we're done. */
        if (!SetEvent(hEndHardwareEvent))
            ScreenSwitchExit();

        /* We block here until user switches us fullscreen again. */
        WaitForSingleObject(hStartHardwareEvent, INFINITE);

        /* Tell console we are ready */
        if (!SetEvent(hEndHardwareEvent))
            ScreenSwitchExit();

        /* Wait for console to tell us to upmap regen memory */
        timo = WaitForMultipleObjects(2, ScreenSwitchEvents, FALSE, HANDSHAKE_TIMEOUT);

        if (timo != 0)
        {          /* 0 is 'signalled' */
    #ifndef PROD
            if (timo == WAIT_TIMEOUT)
                printf("NTVDM:Waiting for console unmap regen memory request Timed Out\n");
            if (timo == 1)
                printf("NTVDM:Waiting for console unmap regen memory request received error\n");
    #endif
            SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
            ScreenSwitchExit();
        }

        /* Prevent updates which would cause hang. */
        sc.ScreenState = FULLSCREEN;

        savedScreenState = WINDOWED;   /* won't have been changed by timer fn */

        inAFunnyMode = TRUE;

        /* Put video section back as passed to us as we have not changed it. */
        LoseRegenMemory();

        /* Tell console memory's gone. */
        if (!SetEvent(hEndHardwareEvent))
            ScreenSwitchExit();

        /* Wait for console to tell us we can go on. Timeout after 60s */
        timo = WaitForMultipleObjects(2, ScreenSwitchEvents, FALSE, HANDSHAKE_TIMEOUT);

        if (timo != 0)
        {          /* 0 is 'signalled' */
    #ifndef PROD
            if (timo == WAIT_TIMEOUT)
                printf("NTVDM:Waiting for console to map frame buffer Timed Out\n");
            if (timo == 1)
                printf("NTVDM:Waiting for console to map frame buffer received error\n");
    #endif
            SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
            ScreenSwitchExit();
        }

        Frozen256Packed = FALSE;

        sas_connect_memory(0xb8000, 0xbffff, SAS_VIDEO);
        // tell console server it can go on
        if (!SetEvent(hEndHardwareEvent))
            ScreenSwitchExit();
    }
    else
    { /* TEXT */
        /* Tell console we're done. */
        if (!SetEvent(hEndHardwareEvent))
            ScreenSwitchExit();

        /* Set up screen-state variable. */
        sc.ScreenState = WINDOWED;

        blocked_in_gfx_mode = FALSE;   /* save restart mode switch */
    #ifndef PROD
        /* Dump out a view of the state block as it might be useful. */
        dumpBlock();
    #endif /* PROD */
    }

    do_new_cursor();    /* sync emulation about cursor state */
}

/***************************************************************************
 * Function:                                                               *
 *      funnyMode                                                          *
 *                                                                         *
 * Description:                                                            *
 *      Detects whether the state of the video hardware returned when      *
 *      switching from fullscreen is one that our VGA emulation            *
 *      understands.                                                       *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      TRUE if it is a funny state, otherwise FALSE.                      *
 *                                                                         *
 ***************************************************************************/
LOCAL BOOL funnyMode(VOID)
{

    /*
     * If the screen is of a higher resolution than 640 x 480 we have a
     * non-standard VGA mode.
     */
    if ((get_bytes_per_line() > 80) || (get_screen_height() > 480))
    {
        return ( FALSE ); /* Tim, don't like it, see what happens other way! */
        //return(TRUE);
    }

    /*
     * If 'nt_set_paint_routine' was called with 'mode' set to one of the
     * "funny" values e.g. TEXT_40_FUN we assume that the mode the hardware
     * is currently in is not compatible with the VGA emulation.
     */
    if (FunnyPaintMode)
    {
        return (TRUE);
    }

    /* We have a standard VGA mode. */
    return (FALSE);
}

/***************************************************************************
 * Function:                                                               *
 *      freezeWindow                                                       *
 *                                                                         *
 * Description:                                                            *
 *      This function is the entry point for the temporary thread which    *
 *      does console calls when the main thread is frozen on a fullscreen  *
 *      to windowed transition.                                            *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
LOCAL VOID freezeWindow(VOID)
{

    DWORD Dummy;

    /* Add -FROZEN to the window title. */
    //FreezeWinTitle();

    /* Turn off any active sounds (eg flight simulator engine noise) */
    InitSound(FALSE);

    /* Iconify if we are in a funny mode, otherwise paint the screen. */
    if (ModeSetBatch || inAFunnyMode)
        VDMConsoleOperation(VDM_HIDE_WINDOW, &Dummy);
    else
    {


        /* Set the screen size. */
        graphicsResize();

        //
        // Remove the Hide Mouse Pointer message from the
        // system menu so the user cannot apply this option
        // the screen is frozen.
        // Andy!

        MouseDetachMenuItem(TRUE);

        /*
         * Set up the palette as DAC registers may have changed and we
         * won't get any more timer ticks after this one until we
         * unfreeze (the palette is not set up until 2 timer ticks after
         * 'choose_display_mode' has been called).
         */
        set_the_vlt();

        /*
         * Full window graphics paint - relies on paint routines to check
         * for memory overflow.
         */
        VGLOBS->dirty_flag = (ULONG) 0xffffffff;
        (*update_alg.calc_update)();
    }
    /* Unblock frozen-window thread creation. */
    freezeHandle = 0;
}

    #ifndef PROD

/***************************************************************************
 * Function:                                                               *
 *      dumpBlock                                                          *
 *                                                                         *
 * Description:                                                            *
 *      Dumps the contents of the video state block.                       *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
int dumpit = 0;
LOCAL VOID dumpBlock(VOID)
{
    USHORT i,
    dacIndex;
    UTINY *regPtr,
    index,
    rgb;

    if (dumpit == 0) return;

    /* Dump out single value registers. */
    printf("\nSingle value registers:\n");
    for (i = 0; i < 0x30; i++)
        printf("\tPort %#x = %#x\n", i, videoState->PortValue[i]);

    /* Dump sequencer values */
    regPtr = GET_OFFSET(BasicSequencerOffset);
    printf("Sequencer registers: (addr %#x)\n",regPtr);
    for (index = 0; index < NUM_SEQ_REGS; index++)
    {
        printf(" %#x = %#x\t", index, *regPtr++);
    }
    printf("\n");

    /* Dump CRTC values */
    regPtr = GET_OFFSET(BasicCrtContOffset);
    printf("CRTC registers: (addr %#x)\n",regPtr);
    for (index = 0; index < NUM_CRTC_REGS; index++)
    {
        printf(" %#x = %#x\t", index, *regPtr++);
    }
    printf("\n");

    /* Dump graphics context values */
    regPtr = GET_OFFSET(BasicGraphContOffset);
    printf("Graphics context registers: (addr %#x)\n",regPtr);
    for (index = 0; index < NUM_GC_REGS; index++)
    {
        printf(" %#x = %#x\t", index, *regPtr++);
    }
    printf("\n");

    /* Dump attribute context values */
    regPtr = GET_OFFSET(BasicAttribContOffset);
    printf("Attribute context registers: (addr %#x)\n",regPtr);
    for (index = 0; index < NUM_AC_REGS; index++)
    {
        printf(" %#x = %#x\t", index, *regPtr++);
    }
    printf("\n");

    /* Dump DACs. First few only otherwise too slow & console times out! */
    regPtr = GET_OFFSET(BasicDacOffset);
    printf("DAC registers:\n");
    for (dacIndex = 0; dacIndex < NUM_DAC_REGS/8; dacIndex++)
    {
        printf("Ind:%#02x:  ", dacIndex);
        for (rgb = 0; rgb < 3; rgb++)
        {
            printf("R:%#02x G:%#02x B:%#02x\t", *regPtr++, *regPtr++, *regPtr++);
        }
        if ((dacIndex % 4) == 0) printf("\n");
    }
}

int doPlaneDump = 0;
LOCAL VOID dumpPlanes(UTINY *plane1Ptr, UTINY *plane2Ptr, UTINY *plane3Ptr,
                      UTINY *plane4Ptr)
{
    HANDLE      outFile;
    char        planeBuffer[256],
    *bufptr;
    DWORD       i,
    j,
    k,
    plane,
    nBytes,
    bytesWritten;
    UTINY       *planes[4];
    FAST UTINY  *tempPlanePtr;

    if (doPlaneDump)
    {

        /* Dump out plane(s). */
        outFile = CreateFile("PLANE",
                             GENERIC_WRITE,
                             (DWORD) 0,
                             (LPSECURITY_ATTRIBUTES) NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             (HANDLE) NULL);
        if (outFile == INVALID_HANDLE_VALUE)
            ScreenSwitchExit();
        planes[0] = plane1Ptr;
        planes[1] = plane2Ptr;
        planes[2] = plane3Ptr;
        planes[3] = plane4Ptr;
        for (plane = 0; plane < 4; plane++)
        {
            tempPlanePtr = planes[plane];
            sprintf(planeBuffer, "Plane %d\n", plane);
            strcat(planeBuffer, "-------\n");
            if (!WriteFile(outFile,
                           planeBuffer,
                           strlen(planeBuffer),
                           &bytesWritten,
                           (LPOVERLAPPED) NULL))
                ScreenSwitchExit();
            for (i = 0; i < 0x10000; i += 0x10)
            {
                sprintf(planeBuffer, "%04x\t", i);
                bufptr = planeBuffer + strlen(planeBuffer);
                for (j = 0; j < 2; j++)
                {
                    for (k = 0; k < 8; k++)
                    {
                        LOCAL char numTab[] =
                        {
                            '0', '1', '2', '3', '4', '5', '6', '7',
                            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
                        };
                        FAST UTINY temp;

                        temp = *tempPlanePtr++;
                        *bufptr++ = numTab[(temp >> 4) & 0xf];
                        *bufptr++ = numTab[temp & 0xf];
                        *bufptr++ = ' ';
                    }
                    if (j == 0)
                    {
                        *bufptr++ = '-';
                        *bufptr++ = ' ';
                    }
                }
                *bufptr++ = '\n';
                *bufptr++ = '\0';
                nBytes = strlen(planeBuffer);
                if (!WriteFile(outFile,
                               planeBuffer,
                               nBytes,
                               &bytesWritten,
                               (LPOVERLAPPED) NULL))
                    ScreenSwitchExit();
            }
            if (!WriteFile(outFile,
                           "\n",
                           1,
                           &bytesWritten,
                           (LPOVERLAPPED) NULL))
                ScreenSwitchExit();
        }
        CloseHandle(outFile);
    }
}

    #endif /* PROD */
#endif /* X86GFX */

#ifdef PLANEDUMPER
extern half_word *vidpl16;
void planedumper()
{
    char filen[50];
    half_word outs[100];
    HANDLE pfh;
    int loop, curoff;
    char *format = "0123456789abcdef";
    half_word *pl, ch;

    printf("planedumper for plane %d\n", *vidpl16 - 1);
    strcpy(filen, "plane ");
    filen[5] = '0' + *vidpl16 - 1;
    pfh = CreateFile(filen,
                     GENERIC_WRITE,
                     (DWORD) 0,
                     (LPSECURITY_ATTRIBUTES) NULL,
                     CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL,
                     (HANDLE) NULL);
    if (pfh == INVALID_HANDLE_VALUE)
    {
        printf("Can't create file %s\n", filen);
        return;
    }

    pl = (half_word *)0xa0000;

    curoff = 0;
    for (loop = 0; loop < 64*1024; loop++)
    {
        ch = *pl++;
        outs[curoff++] = *(format + (ch >> 4));
        outs[curoff++] = *(format + (ch & 0xf));
        outs[curoff++] = ' ';

        if (curoff == 78)
        {
            outs[curoff] = '\n';

            WriteFile(pfh, outs, 80, &curoff, (LPOVERLAPPED) NULL);
            curoff = 0;
        }
    }
    outs[curoff] = '\n';

    WriteFile(pfh, outs, curoff, &curoff, (LPOVERLAPPED) NULL);

    CloseHandle(pfh);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_devs.c ===
/*++

Copyright (c) 1991, Microsoft Corporation

Module Name:

    nt_devs.c

Abstract:

    Support for MSCDEX and other devices

Environment:

    NT-MVDM (User Mode VDD)

Author:

    Neil Sandlin (neilsa), 3/20/93

Notes:

    Implementation Restrictions-

    Currently, the starting and ending locations returned by the mscdex
    "audio status info" are not returned by NT drivers. This makes it
    difficult to maintain these values when the calling applications
    exit, or when multiple applications are controlling a single drive.

    Currently, this implementation does not validate the length argument of
    the IOCTL calls. This needs to be added for robustness, but will not
    affect well-behaved apps.


Revision History:



--*/

//
// Include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "host_def.h"
#include "insignia.h"
#include "ios.h"

#include <stdlib.h>
#include <stdio.h>
#include <softpc.h>

#include "ntddcdrm.h"
#include "ntdddisk.h"
#include "nt_devs.h"

//
// Global variables.
//

PFNSVC  apfnMSCDEXSVC [] = {
    ApiGetNumberOfCDROMDrives,
    ApiGetCDROMDriveList,
    ApiGetCopyrightFileName,
    ApiGetAbstractFileName,
    ApiGetBDFileName,
    ApiReadVTOC,
    ApiReserved,
    ApiReserved,
    ApiAbsoluteDiskRead,
    ApiAbsoluteDiskWrite,
    ApiReserved,
    ApiCDROMDriveCheck,
    ApiMSCDEXVersion,
    ApiGetCDROMDriveLetters,
    ApiGetSetVolDescPreference,
    ApiGetDirectoryEntry,
    ApiSendDeviceRequest
};

PDRIVE_INFO DrivePointers[MAXDRIVES]={0};
PDRIVE_INFO DrvInfo;
LPREQUESTHEADER VdmReq;                     // for "send device request"
USHORT NumDrives = 0, FirstDrive = 0xff;
DWORD DeviceHeader;                         // for "get CDROM drive list"
BYTE LastRealStatus = AUDIO_STATUS_NO_STATUS;
UCHAR g_bProtMode;                        // FALSE for v86, TRUE for 16:16 PM

#define IS_DRIVE_CDROM(drive)       \
                        (drive < MAXDRIVES && DrivePointers[drive] != NULL)



VOID
nt_mscdexinit(
    VOID
    )
/*++

Routine Description:

    This routine is called when the MSCDEXNT TSR makes its RegisterModule
    call. Most of the initialization is done here instead of in the
    VDDInitialize routine to improve performance in the case where the
    VDD is loaded, but not used.

    The main point of this routine is to search for CDROM drives and set
    up an array of pointers to point to DRIVE_INFO structures. The array
    is a fixed size array, one for each possible DOS drive. The structures
    are allocated only if a CDROM drive exists at the corresponding drive
    letter in the array.

    By doing a CreateFile() to the drive letter of the drive, a handle to
    the SCSI CDROM class driver is returned. This handle is used for all
    communication with the drive.



Return Value:

    SUCCESS - Client carry is clear
              Client CX = # of CDROM drives

    FAILURE - Client carry is set

--*/


{
    CHAR chRoot [] = "?:\\";
    USHORT i;
    HANDLE hDriver;
    PDRIVE_INFO drvp;
    static BOOLEAN Initialized = FALSE;

    if (Initialized) {
        setCF(0);
        return;
    }


    // Make far pointer with offset zero (DX is para aligned)
    DeviceHeader = (DWORD) ((getCS() << 16) + (getDX() << 12));

    for (i=0; i<MAXDRIVES; i++) {

        chRoot[0] = i + 'A';

        if (GetDriveType((LPSTR) chRoot) == DRIVE_CDROM) {

            hDriver = OpenPhysicalDrive(i);

            if (hDriver != INVALID_HANDLE_VALUE) {

                drvp = (PDRIVE_INFO)malloc(sizeof(DRIVE_INFO));
                if(drvp == NULL) {
                    DebugPrint (DEBUG_MOD, "VCDEX: Out of memory on initializetion\n");
                    Initialized = FALSE;
                    setCF(1);
                    return;
                }

                DrivePointers[i]   = drvp;
                drvp->Handle       = hDriver;
                drvp->DriveNum     = i;
                drvp->ValidVTOC    = FALSE;
                drvp->MediaStatus  = MEDCHNG_CHANGED;

                drvp->PlayStart.dw = 0;
                drvp->PlayCount    = 0;
                GetAudioStatus (drvp);

                NumDrives++;
                if (FirstDrive == 0xff)
                    FirstDrive = i;


                //
                // Keep the handle close until app really wants to use it
                //
                drvp->Handle  = INVALID_HANDLE_VALUE;
                CloseHandle(hDriver);


            } else {
                DrivePointers[i] = NULL;
            }

        }

    }

    if (NumDrives == 0) {

        setCF(1);

    } else {
        PDEVICE_HEADER pDev = (PDEVICE_HEADER) GetVDMAddr(getCS(), getDX());

        // Put the first valid cdrom drive number in the device header
        pDev->drive = FirstDrive+1;

        DebugPrint (DEBUG_MOD, "VCDEX: Initialized\n");
        Initialized = TRUE;

        setCF(0);

    }

    return;
}

VOID
nt_devices_block_or_terminate(
    VOID
    )
{

    int DrvNum;

    //
    // Do the MSCDEX part.
    //
    DrvNum = MAXDRIVES;
    while (DrvNum--) {
       if (DrivePointers[DrvNum] &&
           DrivePointers[DrvNum]->Handle != INVALID_HANDLE_VALUE )
         {
           CloseHandle(DrivePointers[DrvNum]->Handle);
           DrivePointers[DrvNum]->Handle = INVALID_HANDLE_VALUE;
       }
    }
}






BOOL
nt_mscdex(
    VOID
    )
/*++

Routine Description:

    This is the main MSCDEX api function dispatcher.

    It's called in protected mode by DPMI's end-of-PM-chain Int 2f handler,
    as well as in v86 mode by the MSCDEX TSR.  This allows us to avoid
    the transition to v86 mode to handle PM calls, and more importantly
    skips the translation of buffers to below 1MB, because the VDD
    keeps track of the client processor mode and translates pointers
    appropriately.

    When this routine is entered from the TSR, an int2f has just been
    executed. Client registers are set to what they were at the time
    of the call.

    When this routine is enterd from DPMI, an int2f has just reached
    its prot-mode handler and the client AX is still intact.
    we are responsible for bounds-checking AL and returning FALSE for
    unhandled Int 2f AH=15 calls, so that DPMI can chain to the
    real-mode handlers.  For calls handled by MSCDEX, we return
    success or failure in the client carry bit.


Return Value:

    TRUE  - Handled by the TSR, client carry indicates success:
        SUCCESS - Client carry is clear
        FAILURE - Client carry is set

    FALSE - Only in protmode for unhandled Int 2f AH=15 calls,
            client registers untouched.
--*/

{

    BOOL    bHandled = TRUE;
    BYTE    bAL;

    g_bProtMode = ( getMSW() & MSW_PE );
    bAL=getAL();

    if ( bAL >= (sizeof(apfnMSCDEXSVC) / sizeof(apfnMSCDEXSVC[0]))) {
        bHandled = FALSE;
        setCF(1);
    } else {
        (apfnMSCDEXSVC [bAL])();
    }

    return bHandled;
}



/****************************************************************************

        MSCDEX API SUBROUTINES

    The following routines perform the individual functions specified by
    the MSCDEX extensions.


 ****************************************************************************/
VOID
ApiReserved(
    VOID
    )

{

    DebugFmt (DEBUG_API, "VCDEX: Reserved Function call, ax=%.4X\n", getAX());

}


VOID
ApiGetNumberOfCDROMDrives(
    VOID
    )

{

    DebugPrint (DEBUG_API, "VCDEX: Get # of CDROM drives\n");

    setBX (NumDrives);

    if (NumDrives)
        setCX (FirstDrive);

}


VOID
ApiGetCDROMDriveList(
    VOID
    )

{

    PDRIVE_DEVICE_LIST devlist, devlist0;
    ULONG   VdmAddress;
    USHORT  Drive;
    BYTE    Unit;

    DebugPrint (DEBUG_API, "VCDEX: Get CDROM drive list\n");

    VdmAddress = ( getES() << 16 ) | getBX();
    devlist = devlist0 = (PDRIVE_DEVICE_LIST) Sim32GetVDMPointer (VdmAddress,
                                          MAXDRIVES*sizeof(DRIVE_DEVICE_LIST),
                                          g_bProtMode);

    for (Drive=0, Unit=0; Drive<MAXDRIVES; Drive++)
        if (DrivePointers[Drive] != NULL) {
            devlist->Unit = Unit;
            devlist->DeviceHeader = DeviceHeader;
            devlist++;
            Unit++;
        }

    Sim32FreeVDMPointer (VdmAddress,
                         MAXDRIVES*sizeof(DRIVE_DEVICE_LIST),
                         devlist0,
                         g_bProtMode);

}

VOID
ApiGetCopyrightFileName(
    VOID
    )
{
    ULONG   VdmAddress;
    LPBYTE  fnBuffer;

    DebugPrint (DEBUG_API, "VCDEX: Get Copyright File Name\n");

    if (!IS_DRIVE_CDROM(getCX())) {     // Is drive CDROM?
        setAX (15);                         // no
        setCF (1);
    }

    VdmAddress = ( getES() << 16 ) | getBX();
    fnBuffer = (LPBYTE) Sim32GetVDMPointer (VdmAddress, 38, g_bProtMode);

    *fnBuffer = 0;                  // currently not implemented

    Sim32FreeVDMPointer (VdmAddress, 38, fnBuffer, g_bProtMode);

}

VOID
ApiGetAbstractFileName(
    VOID
    )
{

    ULONG   VdmAddress;
    LPBYTE  fnBuffer;

    DebugPrint (DEBUG_API, "VCDEX: Get Abstract File Name\n");

    if (!IS_DRIVE_CDROM(getCX())) {     // Is drive CDROM?
        setAX (15);                         // no
        setCF (1);
    }

    VdmAddress = ( getES() << 16 ) | getBX();
    fnBuffer = (LPBYTE) Sim32GetVDMPointer (VdmAddress, 38, g_bProtMode);

    *fnBuffer = 0;                  // currently not implemented

    Sim32FreeVDMPointer (VdmAddress, 38, fnBuffer, g_bProtMode);

}


VOID
ApiGetBDFileName(
    VOID
    )
{

    ULONG   VdmAddress;
    LPBYTE  fnBuffer;

    DebugPrint (DEBUG_API, "VCDEX: Get Bibliographic Doc File Name\n");

    if (!IS_DRIVE_CDROM(getCX())) {     // Is drive CDROM?
        setAX (15);                         // no
        setCF (1);
    }

    VdmAddress = ( getES() << 16 ) | getBX();
    fnBuffer = (LPBYTE) Sim32GetVDMPointer (VdmAddress, 38, g_bProtMode);

    *fnBuffer = 0;                  // currently not implemented

    Sim32FreeVDMPointer (VdmAddress, 38, fnBuffer, g_bProtMode);

}

VOID
ApiReadVTOC(
    VOID
    )
{

    DebugPrint (DEBUG_API, "VCDEX: Read VTOC\n");
    setCF(1);                       // currently not implemented

}



VOID
ApiAbsoluteDiskRead(
    VOID
    )
{

    DebugPrint (DEBUG_API, "VCDEX: Absolute Disk Read\n");
    setCF(1);                       // currently not implemented

}

VOID
ApiAbsoluteDiskWrite(
    VOID
    )
{
    DebugPrint (DEBUG_API, "VCDEX: Absolute Disk Write\n");
    setCF(1);                       // read only
}


VOID
ApiCDROMDriveCheck(
    VOID
    )

{

    DebugPrint (DEBUG_API, "VCDEX: CDROM drive check\n");

    setBX (0xADAD);                     // MSCDEX Signature

    if (IS_DRIVE_CDROM(getCX()))        // is CD ROM drive
        setAX (1);                      // yes
    else
        setAX (0);                      // no

}

VOID
ApiMSCDEXVersion(
    VOID
    )

{
    DebugPrint (DEBUG_API, "VCDEX: MSCDEX Version\n");
    setBX (MSCDEX_VERSION);                     // MSCDEX Version #

}

VOID
ApiGetCDROMDriveLetters(
    VOID
    )

{
    ULONG   VdmAddress;
    LPBYTE  VdmPtr, VdmPtr0;
    USHORT  Drive;

    DebugPrint (DEBUG_API, "VCDEX: Get CDROM Drive Letters\n");

    VdmAddress = (getES() << 16) | getBX();
    VdmPtr = VdmPtr0 = (LPBYTE) Sim32GetVDMPointer (VdmAddress, MAXDRIVES, g_bProtMode);

    for (Drive=0; Drive<MAXDRIVES; Drive++)
        if (DrivePointers[Drive] != NULL)
            *VdmPtr++ = (BYTE) Drive;

    Sim32FreeVDMPointer (VdmAddress, MAXDRIVES, VdmPtr0, g_bProtMode);

}


VOID
ApiGetSetVolDescPreference(
    VOID
    )
{

    DebugPrint (DEBUG_API, "VCDEX: Set Volume Descriptor Preference\n");
    setCF(1);                       // currently not implemented

}

VOID
ApiGetDirectoryEntry(
    VOID
    )
{

    DebugPrint (DEBUG_API, "VCDEX: Get Directory Entry\n");
    setCF(1);                       // currently not implemented

}



VOID
ApiSendDeviceRequest(
    VOID
    )
{

    ULONG   VdmAddress;
    BOOL    Success;
    DWORD   BytesReturned;
    DWORD absStart, absEnd;
    int     DrvNum;

    VdmAddress = ( getES() << 16 ) | getBX();
    VdmReq = (LPREQUESTHEADER) Sim32GetVDMPointer (VdmAddress,
                                              sizeof (REQUESTHEADER),
                                              g_bProtMode);


    DebugFmt (DEBUG_IO, ">RQ %d ", (DWORD) VdmReq->rhFunction);

    VdmReq->rhStatus = 0;
    DrvNum = getCX();

    if (!IS_DRIVE_CDROM(DrvNum)) {
        VdmReq->rhStatus = CDSTAT_ERROR | CDSTAT_DONE | CDERR_UNKNOWN_UNIT;
        return;

    }

    DrvInfo = DrivePointers[DrvNum];

    if (DrvInfo->Handle == INVALID_HANDLE_VALUE) {
        DrvInfo->Handle = OpenPhysicalDrive(DrvInfo->DriveNum);
        if (DrvInfo->Handle == INVALID_HANDLE_VALUE) {
            VdmReq->rhStatus = CDSTAT_ERROR | CDSTAT_DONE | CDERR_UNKNOWN_UNIT;
            free(DrvInfo);
            DrivePointers[DrvNum] = NULL;
            NumDrives--;
            if (FirstDrive == DrvNum) {
                FirstDrive = 0xff;
                while (++DrvNum < MAXDRIVES) {
                    if (DrivePointers[DrvNum]) {
                        FirstDrive = (USHORT)DrvNum;
                        break;
                    }
                }
            }

            return;
        }
    }


    GetAudioStatus (DrvInfo);

    if (DrvInfo->Playing)
        VdmReq->rhStatus |= CDSTAT_BUSY;

    switch (VdmReq->rhFunction) {

        case IOCTL_READ:

            IOCTLRead();

            break;

        case IOCTL_WRITE:

            IOCTLWrite();

            break;

        case INPUT_FLUSH:
        case OUTPUT_FLUSH:
        case DEVICE_OPEN:
        case DEVICE_CLOSE:
        case READ_LONG:
        case READ_LONG_PREFETCH:
        case SEEK:
            DebugPrint (DEBUG_API, "Unsupported MSCDEX Device Request\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;
            break;

        case PLAY_AUDIO: {

            CDROM_PLAY_AUDIO_MSF PlayAudioMSF;
            PPLAY_AUDIO_BLOCK playreq = (PPLAY_AUDIO_BLOCK) VdmReq;

            if (playreq->addrmode == MODE_HSG) {

                absStart = playreq->startsect.dw;
                PlayAudioMSF.StartingM = (BYTE) (absStart / (75 * 60));
                PlayAudioMSF.StartingS = (BYTE) ((absStart / 75) % 60);
                PlayAudioMSF.StartingF = (BYTE) (absStart % 75);

            } else if (playreq->addrmode == MODE_REDBOOK) {

                PlayAudioMSF.StartingM = playreq->startsect.b[2];
                PlayAudioMSF.StartingS = playreq->startsect.b[1];
                PlayAudioMSF.StartingF = playreq->startsect.b[0];

                absStart = (PlayAudioMSF.StartingM * 75 * 60) +
                           (PlayAudioMSF.StartingS * 75) +
                           (PlayAudioMSF.StartingF);
            } else {

                VdmReq->rhStatus = CDSTAT_ERROR | CDERR_PARAMETER;
                break;

            }

            absEnd = absStart + playreq->numsect - 1;

            PlayAudioMSF.EndingM = (BYTE) (absEnd / (75 * 60));
            PlayAudioMSF.EndingS = (BYTE) ((absEnd / 75) % 60);
            PlayAudioMSF.EndingF = (BYTE) (absEnd % 75);

            DebugPrint (DEBUG_IO, "Play ");

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_PLAY_AUDIO_MSF,
                                      (LPVOID) &PlayAudioMSF,
                                      sizeof (CDROM_PLAY_AUDIO_MSF),
                                      (LPVOID) NULL, 0,
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)

                ProcessError (DrvInfo, PLAY_AUDIO,0);

            else {

                DrvInfo->Playing = TRUE;
                DrvInfo->Paused = FALSE;
                DrvInfo->PlayStart.dw = playreq->startsect.dw;
                DrvInfo->PlayCount = playreq->numsect;

            }

            break;
        }

        case STOP_AUDIO:

            if (DrvInfo->Playing) {

                DebugPrint (DEBUG_IO, "Pause ");
                Success = DeviceIoControl (DrvInfo->Handle,
                                          (DWORD) IOCTL_CDROM_PAUSE_AUDIO,
                                          (LPVOID) NULL, 0,
                                          (LPVOID) NULL, 0,
                                          &BytesReturned, (LPVOID) NULL);

                if (!Success)

                    ProcessError (DrvInfo, STOP_AUDIO,0);

                else {
                    DrvInfo->Playing = FALSE;
                    DrvInfo->Paused = TRUE;
                }

            } else {

                DebugPrint (DEBUG_IO, "Stop ");

                Success = DeviceIoControl (DrvInfo->Handle,
                                          (DWORD) IOCTL_CDROM_STOP_AUDIO,
                                          (LPVOID) NULL, 0,
                                          (LPVOID) NULL, 0,
                                          &BytesReturned, (LPVOID) NULL);

                // Fake out GetAudioStatus to simulate stop
                DrvInfo->Playing = FALSE;
                DrvInfo->Paused = FALSE;
                LastRealStatus = AUDIO_STATUS_PLAY_COMPLETE;

                if (!Success) {
                    DWORD dwErr;

                    dwErr = GetLastError();
                    if (dwErr == ERROR_MR_MID_NOT_FOUND ||
                        dwErr == ERROR_NO_MEDIA_IN_DRIVE )
                      {
                       CloseHandle(DrvInfo->Handle);
                       DrvInfo->Handle = INVALID_HANDLE_VALUE;
                    }
                }

            }

            break;

        case WRITE_LONG:
        case WRITE_LONG_VERIFY:

            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_WRITE_PROTECT;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;

            break;

        case RESUME_AUDIO:

            if (DrvInfo->Paused) {

                DebugPrint (DEBUG_IO, "Resume ");
                Success = DeviceIoControl (DrvInfo->Handle,
                                          (DWORD) IOCTL_CDROM_RESUME_AUDIO,
                                          (LPVOID) NULL, 0,
                                          (LPVOID) NULL, 0,
                                          &BytesReturned, (LPVOID) NULL);

                if (!Success)

                    ProcessError (DrvInfo, RESUME_AUDIO,0);

            } else {

                VdmReq->rhStatus = CDSTAT_ERROR | CDERR_GENERAL;
                CloseHandle(DrvInfo->Handle);
                DrvInfo->Handle = INVALID_HANDLE_VALUE;
            }

            break;

        default:
            DebugPrint (DEBUG_API, "Invalid MSCDEX Device Request\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;

    }

    VdmReq->rhStatus |= CDSTAT_DONE;

    DebugFmt (DEBUG_IO, ": %.4X   ", VdmReq->rhStatus);

}

VOID
IOCTLRead(
    VOID
    )

{

    LPBYTE Buffer;
    BOOL Success;
    DWORD   BytesReturned;

    Buffer = Sim32GetVDMPointer ((ULONG)VdmReq->irwrBuffer, 16, g_bProtMode);

    DebugFmt (DEBUG_IO, "iord %d ", (DWORD) *Buffer);

    switch (*Buffer) {

        case IOCTLR_AUDINFO: {

            PIOCTLR_AUDINFO_BLOCK audinfo = (PIOCTLR_AUDINFO_BLOCK) Buffer;
            VOLUME_CONTROL VolumeControl;

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_GET_VOLUME,
                                      (LPVOID) NULL, 0,
                                      (LPVOID) &VolumeControl,
                                      sizeof (VOLUME_CONTROL),
                                      &BytesReturned, (LPVOID) NULL);

            if (Success) {

                // no support for input=>output channel manipulation
                audinfo->chan0 = 0;
                audinfo->chan1 = 1;
                audinfo->chan2 = 2;
                audinfo->chan3 = 3;

                audinfo->vol0 = VolumeControl.PortVolume[0];
                audinfo->vol1 = VolumeControl.PortVolume[1];
                audinfo->vol2 = VolumeControl.PortVolume[2];
                audinfo->vol3 = VolumeControl.PortVolume[3];

            } else {
                CloseHandle(DrvInfo->Handle);
                DrvInfo->Handle = INVALID_HANDLE_VALUE;
            }

            break;
        }

        case IOCTLR_DEVSTAT: {

            PIOCTLR_DEVSTAT_BLOCK devstat = (PIOCTLR_DEVSTAT_BLOCK) Buffer;

            devstat->devparms = DEVSTAT_DOOR_UNLOCKED |
                                DEVSTAT_SUPPORTS_RBOOK;


            if (!DrvInfo->StatusAvailable) {

                DrvInfo->MediaStatus = MEDCHNG_CHANGED;
                CloseHandle(DrvInfo->Handle);
                DrvInfo->Handle = INVALID_HANDLE_VALUE;

                switch (DrvInfo->LastError) {
                    case ERROR_NO_MEDIA_IN_DRIVE:
                        devstat->devparms |= DEVSTAT_NO_DISC |
                                             DEVSTAT_DOOR_OPEN;

                        DebugFmt (DEBUG_STATUS, ":%.4X ", devstat->devparms);

                        break;
                    //BUGBUG case for recently inserted (80000016) - see below
                }

                break;
            }

            if (!(DrvInfo->current.Control & AUDIO_DATA_TRACK))
                devstat->devparms |= DEVSTAT_PLAYS_AV;

            break;
        }

        case IOCTLR_VOLSIZE: {

            PIOCTLR_VOLSIZE_BLOCK volsize = (PIOCTLR_VOLSIZE_BLOCK) Buffer;
            PTRACK_DATA Track;
            PCDROM_TOC cdromtoc;

            if ((cdromtoc = ReadTOC (DrvInfo))!=NULL) {

                Track = &cdromtoc->TrackData[cdromtoc->LastTrack];

                volsize->size = (DWORD) ( (Track->Address[1]*60*75) +
                                          (Track->Address[2]*75) +
                                           Track->Address[3]      );

            }
            break;
        }

        case IOCTLR_MEDCHNG: {

            PIOCTLR_MEDCHNG_BLOCK medptr = (PIOCTLR_MEDCHNG_BLOCK) Buffer;
            BYTE status = DrvInfo->MediaStatus;

            if (status == MEDCHNG_NOT_CHANGED) {

                Success = DeviceIoControl (DrvInfo->Handle,
                                          (DWORD) IOCTL_CDROM_CHECK_VERIFY,
                                          (LPVOID) NULL, 0,
                                          (LPVOID) NULL, 0,
                                          &BytesReturned, (LPVOID) NULL);

                if (Success)

                    medptr->medbyte = MEDCHNG_NOT_CHANGED;

                else {

                    medptr->medbyte = MEDCHNG_CHANGED;
                    DrvInfo->MediaStatus = MEDCHNG_CHANGED;
                    CloseHandle(DrvInfo->Handle);
                    DrvInfo->Handle = INVALID_HANDLE_VALUE;
                }

            } else
                medptr->medbyte = DrvInfo->MediaStatus;

            break;
        }

        case IOCTLR_DISKINFO: {

            PIOCTLR_DISKINFO_BLOCK diskinfo = (PIOCTLR_DISKINFO_BLOCK) Buffer;
            PTRACK_DATA Track;
            PCDROM_TOC cdromtoc;

            if ((cdromtoc = ReadTOC (DrvInfo))!=NULL) {
                diskinfo->tracklow = cdromtoc->FirstTrack;
                diskinfo->trackhigh = cdromtoc->LastTrack;

                Track = &cdromtoc->TrackData[cdromtoc->LastTrack];

                diskinfo->startleadout.b[0] = Track->Address[3];
                diskinfo->startleadout.b[1] = Track->Address[2];
                diskinfo->startleadout.b[2] = Track->Address[1];
                diskinfo->startleadout.b[3] = Track->Address[0];

            } else {

                // zeroes apparently needed when not there physically
                diskinfo->tracklow = 0;
                diskinfo->trackhigh = 0;
                diskinfo->startleadout.dw = 0;

            }
            break;
        }

        case IOCTLR_TNOINFO: {

            PIOCTLR_TNOINFO_BLOCK tnoinfo = (PIOCTLR_TNOINFO_BLOCK) Buffer;
            PTRACK_DATA Track;
            PCDROM_TOC cdromtoc;

            if ((cdromtoc = ReadTOC (DrvInfo))!=NULL) {

                if (tnoinfo->trknum > cdromtoc->LastTrack) {
                    VdmReq->rhStatus = CDSTAT_ERROR | CDERR_SECT_NOTFOUND;
                    break;
                }

                Track = &cdromtoc->TrackData[tnoinfo->trknum-1];
                tnoinfo->start.b[0] = Track->Address[3];
                tnoinfo->start.b[1] = Track->Address[2];
                tnoinfo->start.b[2] = Track->Address[1];
                tnoinfo->start.b[3] = Track->Address[0];

                tnoinfo->trkctl = Track->Control;
            }

            break;
        }

        case IOCTLR_QINFO: {

            PIOCTLR_QINFO_BLOCK qinfo = (PIOCTLR_QINFO_BLOCK) Buffer;

            if (DrvInfo->StatusAvailable) {

                qinfo->ctladr = DrvInfo->current.Control | DrvInfo->current.ADR<<4;
                qinfo->trknum = DrvInfo->current.TrackNumber;
                qinfo->pointx = DrvInfo->current.IndexNumber;
                qinfo->min = DrvInfo->current.TrackRelativeAddress[1];
                qinfo->sec = DrvInfo->current.TrackRelativeAddress[2];
                qinfo->frame = DrvInfo->current.TrackRelativeAddress[3];

                qinfo->zero = DrvInfo->current.AbsoluteAddress[0];
                qinfo->apmin = DrvInfo->current.AbsoluteAddress[1];
                qinfo->apsec = DrvInfo->current.AbsoluteAddress[2];
                qinfo->apframe = DrvInfo->current.AbsoluteAddress[3];

            } else {
                CloseHandle(DrvInfo->Handle);
                DrvInfo->Handle = INVALID_HANDLE_VALUE;
            }

            break;
        }

        case IOCTLR_UPCCODE: {

            PIOCTLR_UPCCODE_BLOCK upccode = (PIOCTLR_UPCCODE_BLOCK) Buffer;
            SUB_Q_MEDIA_CATALOG_NUMBER MediaCatalog;
            static CDROM_SUB_Q_DATA_FORMAT subqfmt = {IOCTL_CDROM_MEDIA_CATALOG};
            int i;

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_READ_Q_CHANNEL,
                                      (LPVOID) &subqfmt,
                                      sizeof (CDROM_SUB_Q_DATA_FORMAT),
                                      (LPVOID) &MediaCatalog,
                                      sizeof (SUB_Q_MEDIA_CATALOG_NUMBER),
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)

                ProcessError (DrvInfo, IOCTL_READ, IOCTLR_UPCCODE);

            else {

                if (MediaCatalog.Mcval) {

                    // The author is uncertain that this is the correct method,
                    // but it appears to work empirically.
                    for (i=0; i<7; i++)
                        upccode->upcean[i] = MediaCatalog.MediaCatalog[i];

                } else

                    VdmReq->rhStatus = CDSTAT_ERROR | CDERR_SECT_NOTFOUND;

            }

            break;
        }

        case IOCTLR_AUDSTAT: {
            PIOCTLR_AUDSTAT_BLOCK audstat = (PIOCTLR_AUDSTAT_BLOCK) Buffer;

            audstat->audstatbits = 0;

            if (DrvInfo->Paused)
                audstat->audstatbits |= AUDSTAT_PAUSED;

            audstat->startloc.dw = DrvInfo->PlayStart.dw;
            audstat->endloc.dw = DrvInfo->PlayCount;

            break;
        }


        case IOCTLR_RADDR:
        case IOCTLR_LOCHEAD:
        case IOCTLR_ERRSTAT:
        case IOCTLR_DRVBYTES:
        case IOCTLR_SECTSIZE:
        case IOCTLR_SUBCHANINFO:
            DebugPrint (DEBUG_API, "Unsupported MSCDEX IOCTL Read\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;
            break;

        default:
            DebugPrint (DEBUG_API, "Invalid MSCDEX IOCTL Read\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;

    }
}

VOID
IOCTLWrite(
    VOID
    )

{
    LPBYTE Buffer;
    BOOL Success;
    DWORD   BytesReturned;

    Buffer = Sim32GetVDMPointer ((ULONG)VdmReq->irwrBuffer, 16, g_bProtMode);

    DebugFmt (DEBUG_IO, "iowt %d ", (DWORD) *Buffer);

    switch (*Buffer) {

        case IOCTLW_EJECT:
            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_EJECT_MEDIA,
                                      (LPVOID) NULL, 0,
                                      (LPVOID) NULL, 0,
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)
                ProcessError (DrvInfo, IOCTL_WRITE, IOCTLW_EJECT);
            break;

        case IOCTLW_LOCKDOOR: {

            PREVENT_MEDIA_REMOVAL MediaRemoval;
            PIOCTLW_LOCKDOOR_BLOCK lockdoor = (PIOCTLW_LOCKDOOR_BLOCK) Buffer;

            MediaRemoval.PreventMediaRemoval = (BOOLEAN) lockdoor->lockfunc;

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_MEDIA_REMOVAL,
                                      (LPVOID) &MediaRemoval,
                                      sizeof(PREVENT_MEDIA_REMOVAL),
                                      (LPVOID) NULL, 0,
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)
                ProcessError (DrvInfo, IOCTL_WRITE, IOCTLW_LOCKDOOR);
            break;
        }

        case IOCTLW_AUDINFO: {
            PIOCTLW_AUDINFO_BLOCK audinfo = (PIOCTLW_AUDINFO_BLOCK) Buffer;
            VOLUME_CONTROL VolumeControl;

            // note: no support for input=>output channel manipulation
            VolumeControl.PortVolume[0] = audinfo->vol0;
            VolumeControl.PortVolume[1] = audinfo->vol1;
            VolumeControl.PortVolume[2] = audinfo->vol2;
            VolumeControl.PortVolume[3] = audinfo->vol3;

            Success = DeviceIoControl (DrvInfo->Handle,
                                      (DWORD) IOCTL_CDROM_SET_VOLUME,
                                      (LPVOID) &VolumeControl,
                                      sizeof (VOLUME_CONTROL),
                                      (LPVOID) NULL, 0,
                                      &BytesReturned, (LPVOID) NULL);

            if (!Success)
                ProcessError (DrvInfo, IOCTL_WRITE, IOCTLW_AUDINFO);
            break;
        }



        case IOCTLW_RESETDRV:
        case IOCTLW_DRVBYTES:
        case IOCTLW_CLOSETRAY:
            DebugPrint (DEBUG_API, "Unsupported MSCDEX IOCTL Write\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;
            break;

        default:
            DebugPrint (DEBUG_API, "Invalid MSCDEX IOCTL Write\n");
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_UNKNOWN_CMD;
            CloseHandle(DrvInfo->Handle);
            DrvInfo->Handle = INVALID_HANDLE_VALUE;

    }


}


/**************************************************************************

        INTERNAL UTILITY ROUTINES

 **************************************************************************/

PCDROM_TOC
ReadTOC (
    PDRIVE_INFO DrvInfo
    )
/*++

Routine Description:

    Because several MSCDEX functions return information that is in the
    Volume Table Of Contents (VTOC), this routine is called to cache
    the TOC in the DRIVE_INFO structure. Subsequent operations that
    request information from the VTOC will not have to get it from
    the drive.

Return Value:

    DWORD value from GetLastError()

--*/

{
    BOOL    Success = TRUE;
    DWORD   BytesReturned;

    if ((DrvInfo->ValidVTOC) &&
        (DrvInfo->MediaStatus == MEDCHNG_NOT_CHANGED))
        return(&DrvInfo->VTOC);

    Success = DeviceIoControl (DrvInfo->Handle,
                              (DWORD) IOCTL_CDROM_READ_TOC,
                              (LPVOID) NULL, 0,
                              (LPVOID) &DrvInfo->VTOC, sizeof (CDROM_TOC),
                              &BytesReturned, (LPVOID) NULL);

    if (!Success) {
        DrvInfo->ValidVTOC = FALSE;
        ProcessError (DrvInfo, 0, 0);
        return (NULL);
        }

    DrvInfo->ValidVTOC = TRUE;
    DrvInfo->MediaStatus = MEDCHNG_NOT_CHANGED;
    return (&DrvInfo->VTOC);


}

BOOLEAN
GetAudioStatus(
    PDRIVE_INFO DrvInfo
    )

/*++

    Because the AudioStatus byte does not statically reflect the difference
    between paused and stopped, we have to try to watch for the transition
    from one state to another to keep track of it.

--*/
{

    static CDROM_SUB_Q_DATA_FORMAT subqfmt = {IOCTL_CDROM_CURRENT_POSITION};
    DWORD BytesReturned;
    BYTE AudStat;

    DrvInfo->Paused       = FALSE;
    DrvInfo->Playing      = FALSE;

    DrvInfo->StatusAvailable = (BOOLEAN)DeviceIoControl (DrvInfo->Handle,
                                             (DWORD) IOCTL_CDROM_READ_Q_CHANNEL,
                                             (LPVOID) &subqfmt,
                                             sizeof (CDROM_SUB_Q_DATA_FORMAT),
                                             (LPVOID) &DrvInfo->current,
                                             sizeof (SUB_Q_CURRENT_POSITION),
                                             &BytesReturned, (LPVOID) NULL);

    if (DrvInfo->StatusAvailable) {

        AudStat = DrvInfo->current.Header.AudioStatus;

        DebugFmt (DEBUG_STATUS, "+%.2X ", AudStat);

        switch (AudStat) {

            case AUDIO_STATUS_IN_PROGRESS:

                DrvInfo->Paused = FALSE;
                DrvInfo->Playing = TRUE;
                LastRealStatus = AudStat;
                break;

            case AUDIO_STATUS_PAUSED:

                if (LastRealStatus == AUDIO_STATUS_IN_PROGRESS) {

                    DrvInfo->Playing = FALSE;
                    DrvInfo->Paused = TRUE;

                }
                break;

            case AUDIO_STATUS_PLAY_ERROR:
            case AUDIO_STATUS_PLAY_COMPLETE:

                DrvInfo->Paused = FALSE;
                DrvInfo->Playing = FALSE;
                LastRealStatus = AudStat;
                break;

        }

    } else {
        DrvInfo->LastError = GetLastError();
    }

    return (DrvInfo->StatusAvailable);

}


DWORD
ProcessError(
    PDRIVE_INFO DrvInfo,
    USHORT Command,
    USHORT Subcmd
    )
/*++

Routine Description:

    This routine is called when a DeviceIoControl() fails. The extended
    error code is retrieved, and status bits are set according to the
    operation that was in progress.

    The DriveInfo Handle is closed


Return Value:

    DWORD value from GetLastError()

--*/


{
    DWORD err;

    err = GetLastError();

    DebugFmt (DEBUG_ERROR, "Err! %d, ", Command);
    DebugFmt (DEBUG_ERROR, "%d: ", Subcmd);
    DebugFmt (DEBUG_ERROR, "%.8X\n", err);

    switch (err) {

        case ERROR_MEDIA_CHANGED:
        case ERROR_NO_MEDIA_IN_DRIVE:

            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_NOT_READY;
            DrvInfo->MediaStatus = MEDCHNG_CHANGED;
            break;

        default:
            VdmReq->rhStatus = CDSTAT_ERROR | CDERR_GENERAL;

    }

    CloseHandle(DrvInfo->Handle);
    DrvInfo->Handle = INVALID_HANDLE_VALUE;

    return (err);

}



HANDLE
OpenPhysicalDrive(
    int DriveNum
    )
/*++

Routine Description:

   int DriveNum; Zero based (0 = A, 1 = B, 2 = C ...)

Return Value:

    HANDLE Drive Handle as returned from CreateFile

--*/
{
    HANDLE hDrive;
    CHAR chDrive [] = "\\\\.\\?:";

    chDrive[4] = DriveNum + 'A';

    hDrive = CreateFile (chDrive,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          (LPSECURITY_ATTRIBUTES) NULL,
                          OPEN_EXISTING,
                          0,
                          (HANDLE) NULL);


    return hDrive;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_ega.c ===
/*
 * SoftPC Revision 3.0
 *
 * Title        : Win32 EGA Graphics Module
 *
 * Description  :
 *
 *              This modules contain the Win32 specific functions required
 *              to support the EGA emulation.
 *
 * Author       : Dave Bartlett (based on X_ega.c)
 *
 * Notes        :
 *
 */

#include <windows.h>
#include <string.h>
#include <memory.h>

#include "insignia.h"
#include "host_def.h"

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "sas.h"
#include "gfx_upd.h"
#include <stdio.h>
#include "trace.h"
#include "debug.h"
#include "egagraph.h"
#include "egacpu.h"
#include "egaports.h"
#include "host_rrr.h"

#include "conapi.h"
#include "nt_graph.h"
#include "nt_ega.h"
#include "nt_egalt.h"

#ifdef MONITOR
#include <ntddvdeo.h>
#include "nt_fulsc.h"
#endif /* MONITOR */

/* Statics */

static unsigned int ega_lo_graph_0_0[256];
static unsigned int ega_lo_graph_0_1[256];
static unsigned int ega_lo_graph_0_2[256];
static unsigned int ega_lo_graph_0_3[256];
static unsigned int ega_lo_graph_1_0[256];
static unsigned int ega_lo_graph_1_1[256];
static unsigned int ega_lo_graph_1_2[256];
static unsigned int ega_lo_graph_1_3[256];
static unsigned int ega_lo_graph_2_0[256];
static unsigned int ega_lo_graph_2_1[256];
static unsigned int ega_lo_graph_2_2[256];
static unsigned int ega_lo_graph_2_3[256];
static unsigned int ega_lo_graph_3_0[256];
static unsigned int ega_lo_graph_3_1[256];
static unsigned int ega_lo_graph_3_2[256];
static unsigned int ega_lo_graph_3_3[256];

#ifdef BIGWIN
static unsigned int ega_lo_graph_0_0_big[256];
static unsigned int ega_lo_graph_0_1_big[256];
static unsigned int ega_lo_graph_0_2_big[256];
static unsigned int ega_lo_graph_0_3_big[256];
static unsigned int ega_lo_graph_1_0_big[256];
static unsigned int ega_lo_graph_1_1_big[256];
static unsigned int ega_lo_graph_1_2_big[256];
static unsigned int ega_lo_graph_1_3_big[2